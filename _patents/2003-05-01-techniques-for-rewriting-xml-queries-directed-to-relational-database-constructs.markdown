---
title: Techniques for rewriting XML queries directed to relational database constructs
abstract: Techniques for executing database commands include receiving a database command that includes an XML component operation that operates on an XML construct that is based on a first set of one or more relational database constructs. It is determined whether the XML component operation can be transformed to a relational database operation on a particular set of one or more relational database constructs of the first set, which does not involve the XML component operation. If it is determined that the XML component operation can be transformed, then the XML component operation is rewritten as a particular relational database operation that operates on the particular set and that does not involve the XML component operation. The particular relational database operation is evaluated. In another aspect, techniques include determining a primitive set of XML generation operations and replacing non-primitive XML generation operations with one or more operations from the primitive set.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07120645&OS=07120645&RS=07120645
owner: Oracle International Corporation
number: 07120645
owner_city: Redwood Shores
owner_country: US
publication_date: 20030501
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","General Overview","Structural Overview","Functional Overview","XPath Queries","SQL\/XML Functions","Example XML Generation Sub-Query","Canonical XML Generation Operations","Method for Processing XML Queries","Method for Determining whether to Rewrite XML Queries","Gateway Conditions","Rewrite of XML Operations on Data Stored as XML Types","XML Operations on Data Not Stored as XML Types","Tree of Canonical XML Generation Functions","Tree of XML Component Operations on the Sub-Query","Elimination of Nodes on Two Trees","Rewrite of XML Operations on Data not Stored as XML Types","Hardware Overview"],"p":["This application claims benefit as a Continuation-in-part of application Ser. No. 10\/259,278, filed Sep. 27, 2002, (hereinafter referenced as Murthy-1) the entire contents of which are hereby incorporated by reference as if fully set forth herein, under 35 U.S.C. \u00a7120.","This application is related to application Ser. No. 10\/428,443, filed May 1, 2003, (hereinafter referenced as Murthy-2) the entire contents of which are hereby incorporated by reference as if fully set forth herein.","The present invention relates to techniques for using eXtensible Markup Language (XML) data in a relational database system.","The World Wide Web (WWW) involves a network of servers on the Internet, each of which is associated with one or more Hypertext Markup Language (HTML) pages. The HTML pages are transferred between clients that make requests of servers and the servers using the Hypertext Transfer Protocol (HTTP). Resources available from servers on the Internet are located using a Universal Resource Locator (URL). The standards and protocols of the WWW are promulgated by the World Wide Web Consortium (W3C) through its servers at www.w3c.org, and are used on many private networks in addition to their use on the Internet.","The HTML standard is one application of a more general markup language standard called the Standard Generalized Markup Language (SGML). Recently, a subset of SGML that is more powerful and flexible than HTML has been defined and has gained popularity for transferring information over the Internet and other networks. The new standard, developed and promoted by W3C, is called the eXtensible Markup Language (XML). XML provides a common syntax for expressing structure in data. Structured data refers to data that is tagged for its content, meaning, or use. XML provides an expansion of the tagging that is done in HTML, which focuses on format or presentation. XML tags identify XML elements and attributes of XML elements. XML elements can be nested to form hierarchies of elements.","A set of syntax rules for XML elements shared by multiple XML documents is defined by an XML schema, itself an XML document. For example, the syntax rules indicate what elements can be used in a document, in what order they should appear, which elements can appear inside other elements, which elements have attributes, what those attributes are, and any restrictions on the type of data or number of occurrences of an element. XML allows documents to contain elements from several distinct XML schema by the use of namespaces. In particular, elements from other, independently created XML schema can be interleaved in one XML document.","Given the elements defined and used by XML, a document object model (DOM) is a tree structure formed to define how the information in an XML document is arranged. The DOM is navigated using an XPath expression that indicates a particular node of content in the hierarchy of elements and attributes in an XML document. XPath is a standard promulgated by W3C.","Relational databases predate, and developed independently of, the World Wide Web. Relational databases store data in various types of data containers that correspond to logical relationships within the data. As a consequence, relational databases support powerful search and update capabilities. Relational databases typically store data in tables of rows and columns where the values in all the columns of one row are related. For example, the values in one row of an employee table describe attributes of the same employee, such as her name, social security number, address, salary, telephone number and other information. Each attribute is stored in a different column. Some attributes, called collections, can have multiple entries. For example, the employee may be allowed to have multiple telephone numbers. Special structures are defined in some relational databases to store collections.","A relational database management system (DBMS) is a system that stores and retrieves data in a relational database. The relational DBMS processes requests to perform database functions such as creating and deleting tables, adding and deleting data in tables, and retrieving data from the tables in the database. A well-known standard language for expressing the database requests is the Structured Query Language (SQL).","Object-relational databases extend the power of relational databases. Object-relational databases allow the value in a column to be an object, which may include multiple attributes. For example, the value in the address column may be an address object that itself has multiple attributes, such as a street address, a city, a state, a country, and a zip code or equivalent. An object type defines the attributes of an object in an object-relational database. SQL has been extended to allow the definition and use of objects and object types in object-relational databases. As used hereinafter, the term \u201cobject-relational database\u201d refers to a subset of relational databases that support object-relational constructs; and an object-relational construct is one example of a relational construct.","Because of the popularity of XML as a data exchange format that supports hierarchical relationships among elements, and because of the power of relational DBMSs to update and retrieve data, there is a demand for generating XML data output from relational databases and storing XML data into relational databases. To support this demand, an industry standard SQL to operate on XML documents has been developed. This standard is called SQL\/XML and documents relating to SQL\/XML are available at the time of this writing at www.sqlx.org. As used in the following, XML constructs include XML elements, XML attributes, XML documents (which always have a single root element), and document fragments that include multiple elements at the root level; object relational constructs include such constructs as tables, rows, columns, objects and views.","Recent work, described in Murthy-1., has been directed to mechanisms for mapping XML constructs in an XML schema, to constructs in an object-relational DBMS Murthy-1. also describe mechanisms for storing XML content into the appropriated object-relational construct. One or more object-relational constructs that correspond to all or part of an XML construct are associated with an XML type. These mechanisms support various options for storing the XML type, from storing the entire document as a single featureless large object in the database (e.g., a character large object, CLOB, of the ORACLE\u2122 DBMS available from Oracle International Corporation, of Redwood Shores, Calif.) to storing one or more XML elements as one or more simple or object type columns or collections in one or more tables.","An SQL\/XML query may include XPath based operations such as EXTRACT, EXISTNODE, and EXTRACTVALUE, which operate on a portion of an XML construct indicated by an XPath expression provided as an argument to the operator. EXISTNODE returns one value (e.g., 0) if there is no XML element at the position in the hierarchy indicated by the XPath expression, and a different value (e.g., 1) otherwise. EXTRACT returns a data stream representing a portion of the XML construct at nodes in the hierarchy of the XML construct that include and descend from the XML element or elements indicated by the XPath expression. EXTRACTVALUE returns a scalar value, if any, from the XML element indicated by the XPath expression.","When a query with an XPath based operation is directed to an XML type, the SQL\/XML DBMS may convert the stored data to its XML form and then send the XML form of the data to the process that implements the XPath operation. The XPath operation process parses the data to identify and return the indicated information. This process can be wasteful if only a portion of the XML construct, stored separately in one or more columns of a relational or object-relational database, affects the results. It would be desirable to extract only data from the columns of interest with an SQL query. In addition, the use of an SQL query enables further SQL optimizations that fully exploit the object-relational storage. Such optimization may not be available during parsing by an XPath operation.","Based on the foregoing, there is a clear need for a mechanism to rewrite a query with an XPath operation, directed to an XML type object-relational construct, as an SQL query","Many database owners have large amounts of data already stored in legacy databases that did not define object-relational constructs that correspond closely to XML constructs. For such users to operate on XML data, the object-relational constructs have to be related to XML constructs, before XPath based queries can be evaluated.","One approach to making legacy relational and object-relational databases available for XPath based queries is to migrate the entire database to a different database that supports XML. This approach involves converting the relational or object-relational data into XML format, such as by writing and executing a procedure to do the conversion, and storing the resulting XML constructs in a native XML database, such as the ORACLE\u2122 XMLDatabase. However, such data migration may be expensive; and costs may exceed a database owner's willingness or ability to pay for the migration.","Another approach is to retrieve data from the database using relational or object-relational queries from a mid-tier application separate from the database server; and modify the mid-tier application to form and manipulate XML constructs. This approach can also be expensive, because the application must be modified. Also, this approach may be inefficient in that more data is often exported to the mid tier than is used in the results after the XML constructs are manipulated. This wastes communication bandwidth, wastes the processing resources at the database server to retrieve and send the excess data, and wastes the processing resources at the application to convert the excess data to XML constructs.","A SQL\/XML DBMS, for example ORACLE\u2122 XML Database, may allow a view of XML type to be defined based on one or more underlying tables. A view is a relational database construct for a stored query that generates a set of rows with columns from one or more tables, when a query directed to the view is executed. The query stored in the view becomes a sub-query of the query directed to the view. An XML type view is a stored query that generates a data stream of XML elements of the associated type from columns in one or more tables, when a query directed to the view is executed. XML type views can be used to generate XML data from legacy data stored in relational and object-relational constructs.","A SQL\/XML DBMS, may allow some queries to include an XPath portion and a second portion, called a \u201csub-query\u201d that produces an XML type. The XML type sub-query might not be stored as a view, but also generates a data stream of XML elements. As used hereinafter an XML type sub-query refers to a sub-query that generates a stream of XML elements, whether or not the sub-query is stored as a XML type view.","It would be desirable if, in some circumstances, the XML query directed to the XML type sub-query would be rewritten as one or more SQL queries on the underlying object-relational constructs. Rewriting XML queries as SQL queries avoids composing the data into an XML data stream and then parsing the XML stream during an XPath operation. Avoiding such composing and parsing saves computational resources and enhances performance. In addition, rewriting XML queries as SQL queries also allows SQL optimizations of the rewritten SQL query to fully exploit the object-relational storage, such as the use of indexes.","Based on the foregoing, there is a clear need for a mechanism to rewrite a query with an XPath operator directed to an XML type sub-query as an SQL query.","The past approaches described in this section could be pursued, but are not necessarily approaches that have been previously conceived or pursued. Therefore, unless otherwise indicated herein, the approaches described in this section are not to be considered prior art to the claims in this application merely due to the presence of these approaches in this background section.","Techniques are described for executing database commands that involve operations on XML constructs for XML documents that are based on relational database constructs. In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to avoid unnecessarily obscuring the present invention.","According to one aspect of the invention, a technique for executing database commands that involve operations on XML constructs includes receiving the database command. It is then determined whether an XML component operation in the database command can be transformed to a relational database operation, which operates on a particular set of one or more relational database constructs, and which does not involve the XML component operation. If it is determined that the XML operation can be transformed, then the XML component operation is rewritten to a particular relational database operation that does not involve the XML component operation. The particular relational database operation on the particular set of one or more relational database constructs is evaluated.","This technique allows a database management system (DBMS) to employ the efficiencies in relational database storage, and therefore this technique often greatly enhances database performance. This technique also allows a DBMS to avoid generating XML elements and parsing those elements in an XML processor when the elements contribute nothing to the outcome of the query. Avoiding such excess generation and parsing further enhances database performance.","According to another aspect of the invention, a technique for executing database commands that involve generating an XML type from relational database constructs includes determining a primitive set of XML generation operations for generating any XML construct from any relational database construct. It is determined whether a database command involves a particular XML generation operation that is not a member of the primitive set. If it is determined that the database command involves the particular XML generation operation that is not a member of the primitive set, then a particular set of one or more XML generation operations from the primitive set is determined that produces the same result as the particular XML generation operation. The particular set of one or more primitive XML generation operations is used instead of the non-primitive operation to evaluate the database command.","This technique allows a DBMS to employ simpler rules for determining when XML components contribute nothing to the outcome of a database command or when XML component operations can be replaced by SQL operations. The technique therefore allows the DBMS to more easily determine when to avoid generating excess XML elements that have to be parsed in an XML processor and when to replace XML operations with SQL operations that can be executed more efficiently in a database. Avoiding such excess generation and parsing and using more SQL operations can often greatly enhance database performance.","Embodiments are described in the following in the context of a commercial extensible markup language\/structured query language (XML\/SQL) database server, which uses object-relational constructs for storage of content for one or more XML constructs, and which responds to XPath queries for that content to be output as one or more XML constructs. XPath queries involve an XPath expression to locate data in an XML construct and zero or more XPath based functions to produce, combine or compare data located by an XPath expression. XPath standard functions include EXTRACT, EXTRACTVALUE, AND NODESEXIST, described in above in the Background section. However, the invention is not limited to this context, but may be applied in any context involving relational database constructs and XML data.","For example, embodiments may be employed in an XML database that uses relational database constructs but not object-relational constructs; or an XML database that uses relational database commands that do not conform to SQL. Embodiments may be employed in an XML\/SQL database that is accessed through an application programming interface (API) rather than being accessed as a server that responds to messages sent over a network. In some embodiments, the database command may include data manipulation language (DML) operations to change contents stored in the database, or may include data definition language (DDL) operations to change the relational database constructs used to store the XML or non-XML contents.","In some embodiments, another syntax different from XPath may be used to express locations of data within an XML construct; and XML operations different from XPath based functions may be used to combine or compare data located in an XML construct. For example, an object notation (in which levels in an object hierarchy are indicated by dots between object names) may be used to express an object-relational data item that corresponds to an XML element or attribute instead of XPath notation (in which levels in an XML hierarchy are indicated by slashes \u201c\/\u201d between element names); and the object notation may be used as an argument for an XPath based function or some other function that operates on data from an XML construct.","Some embodiments of these aspects produce advantages over the mid-tier approach. Fetching all the data into the mid-tier can be a waste of resources, since this approach might entail having to fetch all the data into the mid-tier before XML manipulation can be performed. It is often not feasible to build a good query optimizer in the mid-tier since the optimizer needs to be aware of costs, statistics and other information for query optimization, which are usually present in the database instead of the mid-tier.","Some embodiments of these aspects produce advantages over the data migration-based approach. Data does not need to be migrated in order to make it available to XML manipulation tools. If the data is migrated to non-schema-based XML type tables, then XPath queries over the relational data still involve the entire XML to be manifested, and DOM operations to be carried out on the manifested XML. Querying XML data in such a manner can be prohibitively expensive.","When queries are rewritten to an object-relational form, the queries can be efficiently optimized using relational and object-relational techniques. Traditional object-relational access methods, such as B-Tree indexes, can be used to efficiently access the data. This can lead to orders of magnitude improvement in performance over previous approaches.","Structures involved in embodiments of the invention include XML constructs and relational database constructs.  is a block diagram that illustrates an example XML document , an example associated XML schema , and example object-relational constructs that store XML construct contents in an object-relational database managed by an object-relational database server .","XML document  is an instance of a particular XML document type, called hereinafter a \u201cDEPT\u201d XML document, which describes a department of an enterprise. For purposes of illustration it is assumed that an example DEPT document  includes an XML element (named \u201cDNO\u201d) for a department number, an XML element (named \u201cDNAME\u201d) for a department name, an XML element (named \u201cDLOC\u201d) for a department location, and an XML element (named \u201cELIST\u201d) for a list of employees in the department. The element ELIST includes elements , and others indicated by ellipsis  (named \u201cENO\u201d) for an employee number, collectively referenced hereinafter as ENO elements . The full text representation of the XML document , with tags, is indicated, in part, in Table 1. XML tags appear inside angle brackets \u201c<\u201d and \u201c>\u201d; the end of an XML element is indicated by a slash \u201c\/\u201d. For purposes of illustration, values are given for each element. The ellipses in lines  and  indicate other lines of XML text not shown in Table 1.",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Portion of full text representation of XML document"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line",{}]},{"entry":["number","XML text"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["\u20021","..."]},{"entry":["\u20022","<DEPT>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20023",{},"<DNO> 101 <\/DNO>"]},{"entry":["\u20024",{},"<DNAME> Human Resources, Corp. <\/DNAME>"]},{"entry":["\u20025",{},"<DLOC>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20026",{},"1000 Main St, Centerville, MO, 11111-2222,"]},{"entry":[{},{},"USA"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20027",{},"<\/DLOC>"]},{"entry":["\u20028",{},"<ELIST>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20029",{},"<ENO> 0017 <\/ENO>"]},{"entry":["10",{},"<ENO> 1897 <\/ENO>"]},{"entry":["11",{},"<ENO> 0112 <\/ENO>"]},{"entry":["12",{},"<ENO> 3211 <\/ENO>"]},{"entry":["13",{},"..."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["14",{},"<\/ELIST>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["15","<\/DEPT>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The DEPT type may be described in an XML schema document such as XML schema . For example, the XML schema  lists several child elements of documents of type DEPT, which include mandatory elements DNO, DNAME, DLOC and ELIST. XML schema  indicates what type of information is stored in each of these elements and what attributes each element has. An example attribute is an element name. Information types may include, for example, character data, numeric data, and another element, among other types of information. For example, element ELIST may include one or more other elements having element name ENO.","Example XML database server  is an object-relational database server, which imports and exports XML constructs, and which stores contents for the XML constructs in one or more object-relational constructs in database storage space .","For example, XML Database Server  stores a mapping  between XML elements or attributes and one or more objects of XML type. In some embodiments, as described in Murthy-1., the mapping includes an XML schema with optional notations that indicated object-relational construct properties. For example, documents of type DEPT are associated with rows in a DEPT table . The DEPT table has columns that correspond to the child elements of DEPT XML documents. Although the methods of Murthy-1. allow the column names to differ from the element names, for simplicity in the illustrated embodiment, the column names in Table  are the same as the element names in DEPT type XML documents. For example, table  has columns named DNO, DNAME, DLOC and ELIST.","The methods of Murthy-1. allow the element ELIST to be treated as a collection of sub-elements rather than as a large opaque object such as a large object (LOB) or a character large object (CLOB). Collection structures in some object-relational databases include variable arrays and nested tables. The collection structure for one ELIST may be stored within table  (\u201cin line\u201d) as a series of columns within the column named ELIST or in a separate table (\u201cout of line\u201d). In the illustrated embodiment, the ELIST is stored as an out of line collection in collection structure , such as a table of variable arrays. When stored out of line, the ELIST column of table  indicates which rows of the separate collection structure correspond to a particular row in table . For example, the value in the ELIST column of table  is repeated in the ELIST column of table  in each row of table  associated with one row in table .","Sample rows in tables ,  are listed in Table 2, and Table 3, respectively. For purposes of illustration, values are given for XML document  as well as other XML documents of type DEPT.",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Portion of DEPT table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["row","DNO","DNAME","DLOC","ELIST"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["1","100","Corporate","1000 Main St, Centerville, MO,","1234"]},{"entry":[{},{},{},"11111-2222, USA"]},{"entry":["2","101","Human","1000 Main St, Centerville, MO,","1235"]},{"entry":[{},{},"Resources,","11111-2222, USA"]},{"entry":[{},{},"Corp."]},{"entry":["3","105","SALES","52 Fifth Ave., New York, NY,","1236"]},{"entry":[{},{},{},"10000-9999, USA"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Portion of variable array table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["row","ELIST","ENO"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["18","1234","2314"]},{"entry":["19","1235","0017"]},{"entry":["20","1235","1897"]},{"entry":["21","1235","0112"]},{"entry":["21","1235","3211"]},{"entry":["22","1236","1654"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The mapping  is used to convert between data in XML constructs, like XML document , and data in one or more XML type object-relational constructs, like table  or table .","In addition to, or instead of, mappings  and XML type object-relational construct ; the database server  may also store on database storage space  a legacy database . In the legacy database, the tables are not directly related to an XML construct through a mapping . For example the data may have been stored and used in multiple applications before DEPT type XML documents were defined in schema . In the illustrated embodiment, the legacy database  includes a DPT table and an EMP table. The DPT table includes columns with column names DPTNO, DPTNA, DPTLO, and DPTMGR to store data that represents department number, department name, department location and department manager, respectively. One or more of these columns may be object types of an object-relational database; for example, column DPTLO may include objects of ADDRESS type. The EMP table includes columns with column names EMPNO, EMPNA, DPTNO and EADD, among others, to store data that represents employee number, employee name, employee department, employee address, among others, respectively.","Sample rows in tables ,  are listed in Table 4, and Table 5, respectively. For purposes of illustration, values are given for several departments that might be converted to several XML documents of type DEPT.",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Portion of DPT table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["row","DPTNO","DPTNA","DPTLO","DPTMGR"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["1","100","Corporate","1000 Main St, Centerville, MO,","0002"]},{"entry":[{},{},{},"11111-2222, USA"]},{"entry":["2","101","Human","1000 Main St, Centerville, MO,","0017"]},{"entry":[{},{},"Resources,","11111-2222, USA"]},{"entry":[{},{},"Corp."]},{"entry":["3","105","SALES","52 Fifth Ave., New York, NY,","0054"]},{"entry":[{},{},{},"10000-9999, USA"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Portion of EMP table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["row","EMPNO","EMPNA","DPTNO","EADD",". . . "]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["\u20031","0002","Alice Founder","100","578 Pine Avenue,",{}]},{"entry":[{},{},{},{},"Centerville, MO"]},{"entry":[{},{},{},{},"11111-2222, USA"]},{"entry":["\u20032","0008","Fred Altrue","100","279 Maple Road,"]},{"entry":[{},{},{},{},"Outerville, MO"]},{"entry":[{},{},{},{},"11115, USA"]},{"entry":["\u20033","0017","John Gladstone","101","8 Lovely Lane,"]},{"entry":[{},{},{},{},"Lowerville, Mo"]},{"entry":[{},{},{},{},"11112-4321, USA"]},{"entry":". . . "},{"entry":["\u200221","0112","Sanjay Mural","101",". . . "]},{"entry":". . . "},{"entry":["434","1654","Jose Gonzales","105",". . . "]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"XML queries have no meaning for object-relational contracts such as tables and columns that are not XML type. An XML type object is generated for the XML queries. An XML type object may be generated in an XML database server from non-XML type constructs using one or more XML generation functions. A sub-query including XML generation functions is then included in XML queries directed to data in object-relational constructs that are not XML type. In some cases a sub-query including XML generation functions may be stored as an XML type view, such as XML type view .","Under some conditions, when the SQL\/XML query is being compiled, the SQL\/XML DBMS can determine one or more columns of one or more tables where the queried data reside, which columns represent less than the whole XML construct in the tables. When this occurs, the SQL\/XML query is rewritten as an SQL query on the one or more columns of the underlying tables where the queried XML data are stored. For example, XPath queries over schema-based and non-schema-based XML type views are rewritten to go directly over the underlying object-relational data. The entire XML construct does not need to be manifested, and, in many cases, the query is rewritten to go directly on relational data. The rewritten query allows efficient access of the relational data, and can lead to orders of magnitude performance gains over previous approaches. Relational indexes can be created and optimized and used for highly efficient query execution. Furthermore, existing relational indexes already created can be used for a new domain of applications, namely, those that use XPath retrieval. In addition, knowledge about the metadata of the underlying data can lead to more efficient access paths, as well as more optimal query execution algorithms","Murthy-1. reveals a mechanism to rewrite a query with an XPath operator, directed to an XML type table, as an SQL query. When the re-written query is executed, some information of interest comes directly from the tables without generating an XML representation and without subsequent parsing by the XPath operation. In some cases, no XML operation need be invoked at all.","In other embodiments disclosed herein, techniques are employed that rewrite a query that includes a sub-query with XML generation operations, either explicitly, or implicitly as a view of XML type.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 2","b":["130","210","210","210"]},"XML database server  includes a query rewrite processor  that determines at compile time whether the query  can be rewritten to eliminate one or more XML operations, and, if so, rewrites the query without those XML operations that can be eliminated. Query rewrite processor  uses information in the mapping  or the definition of a stored sub-query in XML type view , or both, to determine whether and how to rewrite the query . In some embodiments, one or more data structures  hold data indicating a set of canonical XML generation operations and rules for substituting the canonical XML generation operations for any non-canonical XML generation operations. In some embodiments, the data structures  hold data indicating rules for eliminating or replacing XPath operations on canonical XML generation operations. When the query  involves one or more XML generation operations in a sub-query of query  or in XML type view , the data structures  are also used by the query rewrite processor .","When the query can be rewritten, the output of the query rewrite processor  is a rewritten query  with one or more XML operations replaced by SQL operations. The SQL portions of the rewritten query  are input to an SQL processor  to optimize, store and eventually execute the SQL portions of the rewritten query . Portions of the query that are not rewritten are input to an XML processor (not shown) to generate and parse XML constructs.","XPath expressions are used to specify a location in an XML construct, e.g., a \u201cnode\u201d of the DOM tree for the XML construct, in a series of steps from a root level of the DOM indicated by a leading slash \u201c\/\u201d. A step to a child element from a parent element is indicated by a slash \u201c\/,\u201d and an attribute of an element is indicated by a ampersand \u201c@\u201d. Each direction of traversal from an element is called an axis of traversal. In addition to child and attribute axes, there are axes that represent traversals to a parent, all descendents, all ancestors, all siblings, all preceding elements, all following elements, only elements of a particular type, as well as other axes. XPath also allows conditions predicate (\u201cpredicates\u201d) that are to be satisfied by the indicated locations. An XPath predicate is enveloped by square brackets \u201c[\u201c,\u201d]\u201d. For example, in the XML document , one of the ENO elements  in ELIST , which has the value  can be indicated by the XPath expression:\n\n\/DEPT\/ELIST\/ENO[ENO=1234].\n","SQL\/XML functions allow XPath expressions as operands. In particular, three SQL\/XML functions are widely used to operate on XML types that represent XML constructs or portions thereof: EXISTSNODE, EXTRACT, and EXTACTVALUE. EXISTSNODE operating on an XPath expression returns a value \u201c1\u201d if the location indicated by the XPath expression actually occurs in the XML construct, and a \u201c0\u201d otherwise. EXTRACT operating on an XPath expression returns a data stream representing XML elements of the indicated location and all their descendents. EXTRACTVALUE operating on an XPath expression returns a scalar value, if any, associated with the element at the indicated location, excluding any XML tags.","Object-relational types that are not XML types can be used to generate XML data streams using one or more XML generation functions in a sub-query (such as in a view definition). For example, an XML type view can be defined that outputs an XML data stream from columns that are not XML types. XML type views can be implemented in an Oracle XML Database DBMS using different techniques. Legacy and non-legacy data can be mapped to XML using XML type views. The object types serve as metadata for the XML produced by capturing all the element and attribute names, as well as their nesting and hierarchical information. In general, this technique can be used to produce XML of desired structure by creating object types of appropriate structure, without the need for data migration.","According to one technique, data stored in columns of a relational table are directly made available to XML applications by creating object views over the relational data, and then creating XML type views over the object views. The mapping of the relational data to XML is determined by the object types used. A variant of this technique is to create XML type views directly over the relational data, but using object types to first build an object-relational data set. Table 6 lists example SQL\/XML commands to generate an XML type view.",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example XML type view"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line",{}]},{"entry":["number","SQL\/XML statements"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["\u20021","CREATE OR REPLACE TYPE EMP_T AS OBJECT ("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20022",{},"\u201c@EMPLOYEEID\u201d NUMBER,"]},{"entry":[{},{},"NAME VARCHAR2(30),"]},{"entry":["\u20023",{},"JOB VARCHAR2(30),"]},{"entry":["\u20024",{},"MANAGER VARCHAR2(30));"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u20025","CREATE VIEW EMPLOYEE_XML OF XMLTYPE"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u20026",{},"WITH OBJECT ID"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u20027",{},"(EXTRACT(SYS_NC_ROWINFO$,"]},{"entry":["\u20028",{},"\u2002\/ROW\/@EMPLOYEEID').GETNUMBERVAL( ))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u20029",{},"AS SELECT"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["10",{},"SYS_XMLGEN (EMP_T(EMPNO, ENAME,"]},{"entry":[{},{},"JOB, MGR))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["11",{},"FROM EMP;"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["1","4","5","11","10","6","8","154"]},"An XML data stream that such a view might generate from a row of data is given in Table 7.",{"@attributes":{"id":"p-0071","num":"0070"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example output from XML type view in Table 6."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line",{}]},{"entry":["number","XML statements"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["1","<?xml version=\u201c1.0\u201d?>"]},{"entry":["2","<ROW EMPLOYEEID=\u201c7369\u201d>"]},{"entry":["3","\u2003<NAME>SMITH<\/NAME>"]},{"entry":["4","\u2003<JOB>CLERK<\/JOB>"]},{"entry":["5","\u2003<MANAGER>7902<\/MANAGER>"]},{"entry":["6","<\/ROW>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"According to a second technique, SQL\/XML functions are used as part of XML type views to construct relational data in appropriate format. Note that object types can also be potentially used, but the primary mode of controlling the mapping is in the hierarchy of the XML generation functions itself. A combination of both above techniques may also be used to generate XML type views. Several columns can be defined as objects and a combination of these objects or other columns can be converted to XML type.","Table 8 lists example SQL\/XML commands to generate an XML type view according to the second technique.",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example XML type view"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line",{}]},{"entry":["number","SQL\/XML statements"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["\u20021","CREATE VIEW EMPLOYEE_SQL_XML OF XMLTYPE"]},{"entry":["\u20022","\u2003WITH OBJECT ID"]},{"entry":["\u20023","\u2003\u2003(EXTRACT(SYS_NC_ROWINFO$,"]},{"entry":["\u20024","\u2003\u2003\u2018\/ROW\/@EMPLOYEEID\u2019).getnumberval( ))"]},{"entry":["\u20025","AS SELECT"]},{"entry":["\u20026","\u2003XMLELEMENT("]},{"entry":["\u20027","\u2003\u2002\u201cROW\u201d,"]},{"entry":["\u20028","\u2003\u2002XMLATTRIBUTES(EMPNO AS EMPLOYEEID),"]},{"entry":["\u20029","\u2003\u2002XMLFOREST("]},{"entry":["10","\u2003\u2003\u2002ENAME AS NAME,"]},{"entry":["11","\u2003\u2003\u2002JOB AS JOB,"]},{"entry":["12","\u2003\u2003\u2009MGR AS MANAGER"]},{"entry":["13","\u2003\u2002)"]},{"entry":["14","\u2003\u2009)"]},{"entry":["15","\u2003FROM EMP;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["6","14","8","9","13","2","4"]},"An XML data stream that such a view might generate from a row of data is given in Table 9.",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example output from XML type view in Table 8."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line",{}]},{"entry":["number","XML statements"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["1","<ROW EMPLOYEEID=\u201c7369\u201d>"]},{"entry":["2","\u2003<NAME>SMITH<\/NAME>"]},{"entry":["3","\u2003<JOB>CLERK<\/JOB>"]},{"entry":["4","\u2003<MANAGER>7902<\/MANAGER>"]},{"entry":["5","<\/ROW>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"According to a third technique, an XMLSchema document is used to control the snapping of the relational and object-relational data to XML. The resultant XML is schema-based, so there is an associated XMLSchema document to which the resultant XML conforms. Annotations in the XMLSchema provide a flexible means of controlling the mapping of the relational or object-relational data into XML constructs. XMLSchema can be used for renaming the elements in the resultant XML, for capturing constraints such as enumeration, and other aspects of XML generation and validation.","Table 10 lists example SQL\/XML commands to generate an XML type view according to the third technique.",{"@attributes":{"id":"p-0079","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 10"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example XML type view"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line",{}]},{"entry":["number","SQL\/XML statements"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["1","CREATE OR REPLACE VIEW EMP_VIEW OF XMLTYPE"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["2",{},"XMLSCHEMA \u201chttp:\/\/www.ABCcorp.com\/"]},{"entry":[{},{},"tkxmsch16.xsd\u201d"]},{"entry":["3",{},"ELEMENT \u201cEmployee\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["4",{},"WITH OBJECT ID ((EXTRACT(SYS_NC_ROWINFO$,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["5",{},"\u2018\/ROW\/@EMPLOYEEID\u2019).getnumberval( ))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["6",{},"AS SELECT"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["7",{},"EMP_T(EMPNO, ENAME, JOB, MGR)"]},{"entry":["8",{},"FROM EMPL"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["2","16","142","142","4","5","7"]},"An XML data stream that such a view might generate from a row of data in the EMP table is given in Table 11.",{"@attributes":{"id":"p-0081","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 11"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example output from XML type view in Table 10."}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line",{}]},{"entry":["number","XML statements"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["1","<?xml version=\u201c1.0\u201d?>"]},{"entry":["2","<Employee ID=\u201c7369\u201d>"]},{"entry":["3","\u2003<EMPLOYEENAME>SMITH<\/EMPLOYEENAME>"]},{"entry":["4","\u2003<OCCUPATION>CLERK<\/OCCUPATION>"]},{"entry":["5","\u2003<MANAGER>7902<\/MANAGER>"]},{"entry":["6","<\/Employee>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"SQL\/XML includes several XML generation functions, including XMLFOREST, XMLCOLATTVAL, XMLCONCAT, SYS_XMLGEN, SYS_XMLAGG, and XMLFORMAT, among others, to form XML type output conveniently in different circumstances. The SQL\/XML generation functions are well known in the art and some are described in more detail in examples given below. Some of these are illustrated in the previous section where they are used to generate XML type output from data in object-relational constructs. Some XML functions are DBMS specific extensions to the SQL\/XML standards, such as XMLSEQUENCE, described in Murthy 2 and further in a following section.","According to some embodiments, all XML generation functions can be replaced by a smaller set of primitive XML generation operations. In one embodiment, an illustrated set of primitive XML generation functions constitute a set of so called \u201ccanonical XML generation functions,\u201d or simply \u201ccanonical functions.\u201d The canonical functions are indicated hereinafter as XEL, XAT, XCDAT, XPI, XCOM, XAG. In other embodiments, the functionality of a primitive set of XML generation functions, or their names, or both, may be different from these canonical functions.","The canonical function XEL outputs a data stream of XML type based on a first input operand that indicates the XML tag for the element, and a series of one or more additional operands that specify child elements or attributes of the element. A null in the first position indicates a surrounding tag is not generated, and a series of operands would be interpreted as sibling nodes in an XML hierarchy. Each operand following the first is an SQL or XML generation expression that evaluates to a value for the corresponding element, with an optional name (called an \u201calias\u201d) for the element following the keyword \u201cAS\u201d after the expression. The alias may be an expression that generates the alias name. If an alias is missing, the element will have an automatically generated name. The function XEL may be nested as an operand of another call to function XEL.","The canonical function XAT outputs a data stream that indicates an XML attribute of a particular element based on an operand that is a name expression that evaluates to a value for the attribute name, with \u201cname\u201d following the keyword \u201cAS\u201d after the name expression. The function XAT may be nested as an operand of the canonical function XEL to form an attribute for that element.","The canonical functions XCDAT, XPI, XCOM output data streams that indicate character data, a processing instruction, or a comment, respectively. These functions may be nested in the canonical function XEL to add such data to an element.","The canonical function XAG is an aggregate function that takes as input a group of XML type expression. XAG aggregates the values of XML type in each group by concatenating them all together, and outputs a single value of XML type per group as result.","In the illustrated embodiment, rules are established for replacing XML generation operations with one or more nested or non-nested calls to the canonical functions. For example, Table 12 lists how some XML generation operations are replaced by one or more canonical functions.",{"@attributes":{"id":"p-0089","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":{"entry":"TABLE 12"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sample Rules for converting XML Generation Operations to Canonical Functions"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Case","XML Generation Operation","Canonicalization Rule"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["1","XMLFOREST(expr1, expr2 as","XEL(null, expr1 as \u201c<expr1_name>\u201d,"]},{"entry":[{},"\u2003alias2, . . . , expr n as \u201calias n\u201d)","expr2 as alias2 . . . , expr n as \u201calias n\u201d)"]},{"entry":["2","XMLCOLATTVAL(","XEL(null,"]},{"entry":[{},"\u2003expr1,","\u2003XEL(\u201ccolumn\u201d, XAT(\u2018<expr1_name>\u2019 as name),"]},{"entry":[{},"\u2003expr2 as alias2, . . . ,","\u2003\u2003expr1),"]},{"entry":[{},"expr n as \u201calias n\u201d)","\u2003XEL(\u201ccolumn\u201d, XAT(\u2018alias2\u2019 as name), expr2),"]},{"entry":[{},{},"\u2003\u2003. . . ,"]},{"entry":[{},{},"\u2003XEL(\u201ccolumn\u201d, XAT(\u2018alias n\u2019 as name), expr n)"]},{"entry":[{},{},")"]},{"entry":["3","XMLCONCAT(xmlexpr1, . . . ,","XEL(null, xmlexpr1, . . . , xmlexpr n)"]},{"entry":[{},"\u2003xmlexpr n)"]},{"entry":["4","SYS_XMLGEN(expr1","XEL(\u201calias1\u201d, expr1)"]},{"entry":[{},"\u2003[,XMLFORMAT(\u2018alias1\u2019)]","[the identifier \u201cROW\u201d is used for \u201calias1\u201d in case"]},{"entry":[{},")","an alias is not specified using XMLFORMAT]"]},{"entry":["5","SYS_XMLAGG(expr1","XEL(\u201calias1\u201d, XAG(expr1))"]},{"entry":[{},"\u2003[, XMLFORMAT(\u2018alias1\u2019)]","[the identifier \u201cROWSET\u201d is used for \u201calias1\u201d in"]},{"entry":[{},")","case an alias is not specified using XMLFORMAT]"]},{"entry":["6","(SELECT XMLAGG(expr1","XEL(CAST(MULTISET("]},{"entry":[{},"\u2003ORDER BY expr3)","\u2003SELECT XEL(expr1)"]},{"entry":[{},"\u2003FROM t1","\u2003FROM t1 WHERE expr2 ORDER BY expr3)"]},{"entry":[{},"\u2003WHERE expr2))","AS XMLSEQUENCETYPE))"]},{"entry":["7","(XMLSEQUENCE(","CAST(MULTISET("]},{"entry":[{},"\u2002SELECT XMLAGG(","\u2002SELECT XEL(\u2018alias\u2019, expr 1, . . . , expr n)"]},{"entry":[{},"\u2003XEL(\u2018alias\u2019, expr1, . . . , expr n))","\u2002FROM t1 WHERE <cond>"]},{"entry":[{},"FROM t1 WHERE <cond>","\u2002GROUP BY <gby expr>"]},{"entry":[{},"GROUP BY <gby expr>","\u2002ORDER BY <oby expr>)"]},{"entry":[{},"ORDER BY <oby expr>))","\u2002AS XMLSEQUENCETYPE)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In Table 12, the nested CAST(MULTISET( )) SQL functions convert a row source to an instance of XMLSequence type. XMLSequence type is a variable array of XML type instances. The CAST(MUTLISET( )) function populates the elements of the variable array such that the XML type data from each row of the row source goes into one element of the variable array. The XMLSEQUENCE function takes as input an XML type instance, and returns an instance of XMLSequence type. The XMLSEQUENCE function populates the elements of the variable array such that each top-level element in the input XML type instance goes into one element of the variable array.","The use of primitive operations, such as the canonical functions, simplifies the determination of whether and how to rewrite an XML query that involves an XML generation operation in a sub-query, as is described in further detail in a later section.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 3","b":["300","3","300"]},"In Step , a set of canonical XML generation operations and rules for converting legal XML generation operations to one or more of the canonical operations are determined. For example, the canonical functions XEL, XAT, XCDAT, XPI, XCOM, XAG are defined and the canonicalization rules of Table 12 are established. In other embodiments, other primitive operations may be defined and used with different rules for converting legal XML operations.","In step , a query is received from a database client. The query includes one or more XML operations for data stored in relational or object-relational database constructs.","In step , it is determined whether the query can be rewritten to replace one or more XML operations with one or more SQL operations on the data stored in the relational or object-relational constructs. In some embodiments, determining whether the query can be rewritten includes determining how to rewrite the query. Step  is described in more detail in a later section with reference to FIG. .","Step  represents a branch point in the flow. If it is determined in step  that the query can be rewritten to remove one or more XML operations, then control passes to step  to rewrite the query. Otherwise, the query is not rewritten and control passes to step  to begin processing the original query.","In step , the query is rewritten to eliminate one or more XML operations. In some embodiments, in which it is determined how to rewrite the query during step , step  overlaps steps  and  in time.","In step , the SQL operations are evaluated with an SQL processor according to any method known in the art. For example, in some embodiments, step  includes optimizing the SQL statements using any indexes available to efficiently execute the query, storing the optimized query for repeated use, and executing the optimized query for the current values in the database. In embodiments in which the original query includes only XML operations and the query cannot be rewritten, step  may be omitted.","In step , the XML operations are evaluated with an SQL\/XML processor according to any method known in the art. For example, in some embodiments, step  includes generating a data stream of XML elements and parsing the data stream to operate on portions of the XML data stream. In embodiments in which the rewritten query includes no XML operations, step  may be omitted.","In some other embodiments, step  is performed before step . In some embodiments steps  and  overlap in time.","The process repeats at step  when another query with XML operations is received by the XML Database DBMS server.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 4","b":["320","300","3"]},"In step  the query is examined to determine whether an embedded XML operation belongs to a certain kind that are to be rewritten. These gateway conditions under which the query is to be rewritten depend on the embodiment. In an illustrated embodiment, described in the following paragraphs, the conditions depend on the kind of XPath expression and the SQL\/XML functions that operate on those XPath expressions. In the following, object types are also called abstract data types (ADTs).","XPath based SQL\/XML operators (EXTRACT, EXISTNODE, EXTRACTVALUE) operating on schema-based XML type columns are rewritten to go against the underlying SQL columns. This enables further SQL optimizations that fully exploit the object-relational storage of the XML constructs. The following kinds of XPath expressions can be translated into the underlying SQL queries using simple rules.","1. Simple XPath expressions\u2014involve simple traversals, wherein the XPath expression consists only of a series of child axis traversals.","2. Collection traversal expressions\u2014involve traversal wherein one or more of the nodes in the XPath expression maps to a collection in the object-relational mapping.","3. Expressions involving wildcard axes (*) axes\u2014Transform those expressions involving the wildcard axes provided the datatypes of the resulting nodes are all coercible. (e.g. CUST\/*\/CUSTNAME must point to CUSTNAMEs which are all of the same or coercible datatypes).","4. Expressions involving descendant axis (\/\/)\u2014Transform these expressions provided the datatypes of the resulting nodes are the same or coercible.","5. All of these expressions must work with the type cache, which includes \u201chidden\u201d traversals like REFs to XML types etc. (for instance xdb$schema_t stores a varray of REFs to xdb$element_t and this is not directly apparent in the XPath expression or the resulting XML construct).","Transformations of these XPath expressions are supported in the EXISTSNODE, EXTRACTVALUE and EXTRACT usage scenarios. EXTRACT, EXTRACTVALUE and EXISTSNODE can appear in the following positions\n\n","If the gateway conditions for rewriting that are tested in step  are not satisfied, then control passes to step , bypassing further efforts to rewrite the query. If the gateway conditions are satisfied, control passes to step .","In step  it is determined whether the data are stored in XML types, such as are defined in an XML schema for relational constructs, like mapping . If so, then control passes to step . If not, then control passes to step . For example, if the data are stored in tables  and  of XML type, then control passes to step . If the data are stored in tables , , then control passes to step . In some embodiments, both schema-based and non schema-based XML conversions are rewritten using the same rules; in such embodiments, step  may be omitted.","In step , further conditions on rewriting queries with XML operations are tested, if any. In some embodiments, these conditions include that the target of the query be a column in one of the object-relational constructs. If these conditions are satisfied, then control passes to step , indicating that the query can be rewritten. If not, control passes to step , to bypass rewriting. For example, if the target of the XPath is an element of a parent that is stored as a LOB, the XML operation can not be entirely replaced by an SQL operation that produces the same result. In some embodiments, the conditions of step  are included in the gateway conditions tested in step , and step  may be omitted. In some embodiments, the gateway conditions of step  are included in step , and step  can be omitted.","When control passes to step , the query rewrite step  performs the following steps.","Simple XPath traversals are rewritten into object type accessors. Predicates are handled by putting them in the where clause. Any XPath child access over an object type is translated to an object attribute access on the underlying object type. For example A\/B maps to a.b where A maps to the object type a and the XPath node B maps to the attribute of \u201ca\u201d named \u201cb\u201d. This rewrite is consistent at any level of the XPath expression, e.g. whether the XPath traversal occurs within a predicate, or a location path variable.","Some example rewrites for XML types are described next.\n\n","Predicates are handled by rewriting the predicate expression in the underlying object expressions.","In the simple case, for EXISTSNODE, the main location path traversal becomes a IS NOT NULL predicate, whereas for the EXTRACT case, this becomes the actual node being extracted.\n\n","Predicates are handled in a similar manner. For example, in the operator given below,\n\n","The XPath expressions may also span collection constructs and the queries are still rewritten by using subqueries on the collection tables. For example,\n\n","Further examples of rewriting queries involving XML type object-relational constructs follow.\n\n","If it is determined in step  that data are not stored as XML types, then XML generation operations are involved in a sub-query to generate the XML data stream on which the XPath and SQL\/XML operations operate. Control passes to step  to determine the sub-query with XML generation operations.","For purposes of illustration, it is assumed that the sub-query is stored as an XML type view  named \u201cdept_xv\u201d on the non-XML tables , , named DPT and EMP, respectively, as shown in FIG. . The view dept_xv is defined by the SQL\/XML statements in Table 13, including one or more XML generation operations. Further examples are provided in the Appendix.",{"@attributes":{"id":"p-0124","num":"0148"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 13"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"XML type view dept_xv"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line",{}]},{"entry":["number","SQL\/XML statements"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","CREATE OR REPLACE VIEW dept_xv OF XMLTYPE AS"]},{"entry":["2","\u2003SELECT SYS_XMLAGG("]},{"entry":["3","\u2003\u2003SYS_XMLGEN (d.DPTNO, XMLFORMAT(\u201cDNO\u201d)),"]},{"entry":["4","\u2003\u2003SYS_XMLGEN (d.DPTNA, XMLFORMAT(\u201cDNAME\u201d)),"]},{"entry":["5","\u2003\u2003SYS_XMLGEN (d.DPTLO, XMLFORMAT(\u201cDLOC\u201d)),"]},{"entry":["6","\u2003\u2003SYS_XMLAGG("]},{"entry":["7","\u2003\u2003\u2003(SELECT (SYS_XMLGEN(e.EMPNO), XMLFORMAT"]},{"entry":[{},"(\u201cENO\u201d))"]},{"entry":["8","\u2003\u2003\u2003FROM EMP e"]},{"entry":["9","\u2003\u2003\u2003WHERE e.DPTNO = d.DPTNO))"]},{"entry":["10","\u2003\u2003ORDER BY d.DPTNO,"]},{"entry":["11","\u2003\u2003XMLFORMAT (\u201cDEPT\u201d)"]},{"entry":["12","\u2003\u2003\u2003)"]},{"entry":["13","\u2003FROM DPT d"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The sub-query stored as view dept_xv contains the XML generation operations SYS_XMLGEN and SYS_XMLAGG.","In step , it is determined whether the sub-query includes non-canonical XML generation operations. If so, then control passes to step  to convert to canonical functions. If not, then step  is skipped and control passes to step . In the illustrated embodiment, the view dept_xv includes the non-canonical XML generation operations SYS_XMLGEN and XMLAGG, so control passes to step . In other embodiments, step  involves determining whether the sub-query includes non-primitive operations.","In step , the non-canonical XML generation operations are converted to canonical XML generation operations using the rules in Table 12. In other embodiments, step  involves converting to other primitive XML generation operations. In the illustrated embodiment, the XML generation operations in Table 13 for dept_xv are converted to the canonical functions as shown in Table 14.",{"@attributes":{"id":"p-0128","num":"0152"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 14"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sub-query of XML type view dept_xv after canonicalization"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["line","SQL\/XML"]},{"entry":["number","statements with canonicalized XML generation functions"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","SELECT XEL("]},{"entry":["2","\u2003\u2003\u201cDEPT\u201d,"]},{"entry":["3","\u2003\u2003XEL (\u201cDNO\u201d, d.DPTNO),"]},{"entry":["4","\u2003\u2003XEL (\u201cDNAME\u201d, d.DPTNA),"]},{"entry":["5","\u2003\u2003XEL (\u201cDLOC\u201d, d.DPTLO),"]},{"entry":["6","\u2003\u2003XEL (\u201cELIST\u201d,"]},{"entry":["7","\u2003\u2003\u2003SELECT XAG(XEL(\u201cENO\u201d, e.EMPNO)"]},{"entry":["8","\u2003\u2003\u2003\u2003ORDER BY d.DPTNO)"]},{"entry":["9","\u2003\u2003\u2003\u2003FROM EMP e"]},{"entry":["10","\u2003\u2003\u2003\u2003WhERE e.DPTNO = d.DPTNO"]},{"entry":["11","\u2003\u2003)"]},{"entry":["12",")"]},{"entry":["13","FROM DPT d"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In step , canonical XML generation functions are expanded to a normalized tree of canonical functions. In other embodiments, the primitive XML generation operations are expanded to a normalized tree of primitive operations. In a normalized tree, each XEL function has a single non-XML type operand, such as a single scalar operand, or a single abstract data type (ADT) operand, or a single collection type column (typically at a leaf node of the normalized tree), or a set of operands that are of XML type (typically at a parent node of the normalized tree). In some embodiments, a set of operands of XML type might be the result of a tree of canonical XML generation functions. It is ensured that each child in the normalized tree is explicitly tagged. If the child is an ADT that is not tagged, the XEL function is converted to the form XEL (null, \u201c<value expression>\u201d as \u201c<type name>\u201d). Scalar operands are always tagged.","For example,  is a block diagram that illustrates a normalized tree  of XML generation operations in the sub-query for view dept_xv. In tree , each XEL function has a single non-XML type operand, or a set of XML type operands.","For example, node  corresponds to the XEL function call that generates XML element DNO, as indicated in line  of Table 14. The operand of this XEL function is a single scalar, the department number value in column DPTNO from a row in table DPT as indicated in tree  by node . Similarly, nodes ,  corresponds to the XEL function calls that generate elements DNAME, DLOC, respectively, as indicated in lines  and  of Table 14. The operands of these XEL function are each a single scalar or object, the department name value in column DPTNA from a row in table DPT as indicated by node , or the department location object value in column DPTLO from a row in table DPT as indicated by node .","Node  corresponds to an SQL query (a sub-query of view dept_xv) that produces multiple XML elements ENO, as indicated in lines  through  of Table 14. Node  corresponds to the XEL function call that generates XML element ELIST, as indicated in line  of Table 14. The operand of this XEL function is a set of XML elements ENO formed by the sub-query at node .","Node  corresponds to the XEL function call that generates the root XML element DEPT, as indicated in lines  and  of Table 14. The operand of this XEL function is a set of XML elements output by nested XEL function calls that generate elements DNO, DNAME, DLOC and ELIST as indicated in tree  by nodes , , , .","In step , XML component operations that operate on the results of the XML generating sub-query are expanded to a second tree of XML component operations. For example, an XPath expression consists of a series of steps, applied in order. The result of one step can be viewed as the input to the next. This leads to the mapping of an XPath expression to a tree of XPath operators. The XPath expression is broken into its component steps. Each step is represented as a subtree using the fundamental XPath operators, plus other operators that cannot be further simplified. The root of this subtree becomes the child of the next set of operators corresponding to the next step. The set of fundamental XPath operators includes the following:\n\n","For example, the XPath expression \u2018\/PurchaseOrder\/Address\/City[Zip=94404]\u2019 can be broken down into: XPATG(\u2018PurchaseOrder\u2019, \u2018\/\u2019) under XPATG(\u2018Address\u2019, \u2018\/\u2019) under XPATG(\u2018City\u2019, \u2018\/\u2019) under XPPRED. The other child of XPPRED is an XPOPR(\u2018=\u2019). The XPOPR has two children: XPATG(\u2018Zip\u2019, \u2018City\u2019) and XPLIT(94404).","In step , the root node of the first normalized XML generation tree is used as input to a leaf node of the second tree of XML component operations on the sub-query; and it is determined whether and which nodes of the second tree eliminate a node of the first tree. Both nodes are eliminated if the two nodes represent inverse transformations or if the nodes can be replaced by an SQL operation. A node on the XML generation tree is eliminated if the current remaining XPath node does not yield a result from operating on that node of the XML generation tree. If at least one set of nodes can be eliminated, then the query can be rewritten without the node or with the corresponding SQL operation, and control passes to step  to rewrite the query during step . If no nodes, or too few nodes, can be eliminated, then control passes to step  to bypass rewriting of the query.",{"@attributes":{"id":"p-0137","num":"0166"},"figref":"FIG. 5","b":["590","510","500"]},"For purposes of illustration, it is assumed that an XML query Q has been received directed to XML type view dept_xv and that the query Q is of the form\n\n","During step , an example node is eliminated as follows. The node  to get the root context element DEPT operates on node  to make the root context element DEPT. Because the name of the element being generated in tree  matches the name of the element being traversed in tree , the two nodes represent inverse operations and can be eliminated. The result is the set of XEL function calls at nodes , , ,  that are operands of the XEL function at node . The XPath step at node  operates on the XML generation functions at these nodes , , , . Because a node can be eliminated, the query is rewritten. The remainder of the node elimination steps and the resulting rewritten query are performed during step .","Nodes  and  are inverse operations, as described above, and are both eliminated. The XPath step at node  to get element ELIST operates on the XML generation functions at nodes , , , ","Node  to get the child element ELIST first operates on node  to generate the child element DNO. Because the names do not match, there is no result of this operation. Similarly, there is no result from node  operating on nodes  or . Nodes , ,  and all descendents from these nodes in tree  are eliminated.","When node  operates on node  for generating the element ELIST the name of the element being generated matches the name of the element being traversed. The two nodes represent inverse operations and both can be eliminated. The result is the SQL query to select several rows from an underlying table. Therefore, the XPath step at node  to get element ENO() operates on the query at node .","Because the operand is a query, the XPath operation is performed on each XML element in the select list of the query. For example, the XPath step to get element ENO[] operates on XEL(\u201cENO\u201d, e.EMPNO) in the SELECT list of the query (see line  of Table 14). In different embodiments, this may be handled differently. In the illustrated embodiment, an indexed collection element in an XPath expression with an index greater than 1 is considered meaningful only if the XML generation operations specifies an order for elements in the collection. In the example view, an order is specified for the EMPNO values output by the query into ENO elements. Therefore the XPath expression to get the second element is reduced to an enclosing query that gets the second row in the row source.","The result of the rewrite for the example query on dept_xv is therefore:\n\n","Other examples of rewritten XML queries are provided in the following.","A simple traversal of form\n\n","An operation to return a scalar value, such as\n\n","An operation to return a scalar value from an element that satisfies a condition predicate, such as\n\n","An operation to return an indexed scalar value, such as\n\n","Some XML operations are not reduced further in the illustrated embodiment, but may be rewritten in other embodiments. For example, the following expression is not rewritten in the illustrated embodiment, but may be rewritten in other embodiments.\n\n","A predicate on a collection is rewritten in a where clause of a sub-query for generating the collection. For example, the expression\n\n","An embodiment of a rule set for converting XPath operations on canonical XML generation functions is provided in the Appendix. Further examples applying that rule set are also provided in the Appendix.",{"@attributes":{"id":"p-0153","num":"0209"},"figref":"FIG. 6","b":["600","600","602","604","602","600","606","602","604","606","604","600","608","602","604","610","602"]},"Computer system  may be coupled via bus  to a display , such as a cathode ray tube (CRT), for displaying information to a computer user. An input device , including alphanumeric and other keys, is coupled to bus  for communicating information and command selections to processor . Another type of user input device is cursor control , such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor  and for controlling cursor movement on display . This input device typically has two degrees of freedom in two axes, a first axis (e.g., x) and a second axis (e.g., y), that allows the device to specify positions in a plane.","The invention is related to the use of computer system  for implementing the techniques described herein. According to one embodiment of the invention, those techniques are performed by computer system  in response to processor  executing one or more sequences of one or more instructions contained in main memory . Such instructions may be read into main memory  from another computer-readable medium, such as storage device . Execution of the sequences of instructions contained in main memory  causes processor  to perform the process steps described herein. In alternative embodiments, hard-wired circuitry may be used in place of or in combination with software instructions to implement the invention. Thus, embodiments of the invention are not limited to any specific combination of hardware circuitry and software.","The term \u201ccomputer-readable medium\u201d as used herein refers to any medium that participates in providing instructions to processor  for execution. Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media. Non-volatile media includes, for example, optical or magnetic disks, such as storage device . Volatile media includes dynamic memory, such as main memory . Transmission media includes coaxial cables, copper wire and fiber optics, including the wires that comprise bus . Transmission media can also take the form of acoustic or light waves, such as those generated during radio-wave and infra-red data communications.","Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, or any other magnetic medium, a CD-ROM, any other optical medium, punchcards, papertape, any other physical medium with patterns of holes, a RAM, a PROM, and EPROM, a FLASH-EPROM, any other memory chip or cartridge, a carrier wave as described hereinafter, or any other medium from which a computer can read.","Various forms of computer readable media may be involved in carrying one or more sequences of one or more instructions to processor  for execution. For example, the instructions may initially be carried on a magnetic disk of a remote computer. The remote computer can load the instructions into its dynamic memory and send the instructions over a telephone line using a modem. A modem local to computer system  can receive the data on the telephone line and use an infra-red transmitter to convert the data to an infra-red signal. An infra-red detector can receive the data carried in the infra-red signal and appropriate circuitry can place the data on bus . Bus  carries the data to main memory , from which processor  retrieves and executes the instructions. The instructions received by main memory  may optionally be stored on storage device  either before or after execution by processor .","Computer system  also includes a communication interface  coupled to bus . Communication interface  provides a two-way data communication coupling to a network link  that is connected to a local network . For example, communication interface  may be an integrated services digital network (ISDN) card or a modem to provide a data communication connection to a corresponding type of telephone line. As another example, communication interface  may be a local area network (LAN) card to provide a data communication connection to a compatible LAN. Wireless links may also be implemented. In any such implementation, communication interface  sends and receives electrical, electromagnetic or optical signals that carry digital data streams representing various types of information.","Network link  typically provides data communication through one or more networks to other data devices. For example, network link  may provide a connection through local network  to a host computer  or to data equipment operated by an Internet Service Provider (ISP) . ISP  in turn provides data communication services through the world wide packet data communication network now commonly referred to as the \u201cInternet\u201d . Local network  and Internet  both use electrical, electromagnetic or optical signals that carry digital data streams. The signals through the various networks and the signals on network link  and through communication interface , which carry the digital data to and from computer system , are exemplary forms of carrier waves transporting the information.","Computer system  can send messages and receive data, including program code, through the network(s), network link  and communication interface . In the Internet example, a server  might transmit a requested code for an application program through Internet , ISP , local network  and communication interface .","The received code may be executed by processor  as it is received, and\/or stored in storage device , or other non-volatile storage for later execution. In this manner, computer system  may obtain application code in the form of a carrier wave.","In the foregoing specification, the invention has been described with reference to specific embodiments thereof. It will, however, be evident that various modifications and changes may be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense.","Appendix","Query Rewrite Optimization Rules","An embodiment of a query rewrite node elimination phase (also called herein a query rewrite optimization phase) consists of applying XPath operators in the expanded XPath operator tree to the XML Generation function tree. Along with other compile-time optimizations, the query rewrite optimization phase can reduce a complex XPath query over a view to a simpler query over the underlying relational table itself.","The query rewrite phase goes through the following rule set based on the type of XPath operation and the type of XML generation operation serving as operand for the XPath operation. It is assumed that the query has been reduced to the canonical representation, and that the Xpath expression has been expanded. In particular, it is assumed that every XEL has either a set of arguments, all of XML type, or a single argument of arbitrary type. Matching refers to the process of comparing a XPath expression element name either with a specified alias or, if an XML Schema is specified, against the name transformed according to the XML Schema. In the following, square brackets indicate optional arguments in a function call.\n\n","Consider the following XML type view definition. This XML type view definition will be used as the running example for this subsection.\n\n","A rewrite for a simple XPath involves accessing the attribute (object-relational column) corresponding to the XPath expression. Thus, rewrite of the expressions \u2018\/ROW\/DEPTNAME\u2019, \/ROW\/@DEPTNO\u2019 and \u2018\/ROW\/EMPLOYEES\u2019 map to dname, deptno, and CAST(MULTISET(select emp_t(empno, . . . ) from emp e where . . . ) AS emplist) respectively.","For example, consider a query that extracts the department number from the department view:\n\n","Suppose a B-Tree index exists on the department number column, then that index will be picked up and an index-based search will be used to return query results. If a query such as this is evaluated without rewrite, then manifesting the XML for each row and then executing DOM operations on them can be prohibitively expensive.","Relational indexes can be used for efficient XPath retrieval. If a functional index is created on extract(value(p), \u2018\/ROW\/DEPTNAME\u2019).getstringval( ), firstly, it will not be as efficient as a relational index because the relational index is likely to be more compact. Secondly, the functional index is not aware of certain metadata information, for instance, in certain implementations, the fact that only a single number, not an arbitrary XML type, is going to be returned by the extract( ) query. The functional index prevents simpler and more efficient indexes such as B-Trees to be used.","Mapping for Scalar Nodes","An XPath expression containing a text( ) operator may be rewritten into the underlying relational column. For example, consider a query that extracts the department name from the department view.\n\n","Now, suppose we create a B-Tree index on <DNAME, LOC>. Creating a functional index on <extractvalue(value(p), \u2018\/ROW\/DEPTNAME\u2019), extractvalue(value(p), \u2018\/ROW\/LOC\u2019)> is not likely to be as efficient, since firstly, in certain implementations, it is not known that there is a single value returned per row of the query. Secondly, more efficient query optimization algorithms such as sort-merge join may be employed to execute the query efficiently. Such techniques are only possible due to use of the additional metadata information.","Mapping of Predicates","Predicates are mapped to SQL predicate expressions. For example, consider a query that gets the number of departments called ACCOUNTING.\n\n","Simple traversals through a collection are rewritten using XAG( ) to aggregate over the elements of the collection. Consider the following query, which extracts all the employee numbers from the department view. Since it needs to iterate over the elements of the collection of employees per department, an XAG is added to aggregate over the final result.\n\n","An XPath expression can also access a particular index of a collection For example, \u2018\/ROW\/EMPLOYEES\/EMP_T[]\/EMPNO\u2019 is rewritten to get the first element in the employees collection of the department view, and then to get the employee number from the first element.","Predicates in Collections","An XPath expression that traverses through a collection might involve predicates. For example, the expression extract(value(p),\u2018\/ROW[EMPLOYEES\/EMP_T\/EMPNO>7900]\u2019) involves a comparison predicate (>7900). XPath 1.0 defines such XPaths to be satisfied if any of the items of the collection satisfies the predicate. Thus, this expression is rewritten to retrieve all those rows that have an employee collection such that at least one employee in the collection has an employee number greater than 7900. An existential check using the EXISTS( ) clause is used to get the list of all such rows."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
