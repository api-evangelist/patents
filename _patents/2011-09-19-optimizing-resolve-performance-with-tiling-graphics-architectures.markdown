---
title: Optimizing resolve performance with tiling graphics architectures
abstract: Aspects of the disclosure relate to a method of processing graphics that includes organizing graphics data into a plurality of polygons and assigning to each of the polygons a polygon index value that indicates an order in which each polygon will be rendered. The method also includes associating pixels of graphics data with one of the polygon index values and determining when the pixels of graphics data will finish rendering based at least partially on the association of the pixels to the one of the polygon index values. The method also includes resolving the pixels of video data based on the determination.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08902228&OS=08902228&RS=08902228
owner: QUALCOMM Incorporated
number: 08902228
owner_city: San Diego
owner_country: US
publication_date: 20110919
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Aspects of the disclosure relate to graphics processing.","Graphics processing units (GPUs) are commonly implemented to render three-dimensional (3D) graphics content for presentation on a two-dimensional visual display. For example, a GPU may be implemented to render pixels that are representative of 3D content on a display. The GPU may perform graphics processing to generate pixel values for each pixel of the display when rendering a scene.","Some GPUs may render an entire scene at one time. Alternatively, a GPU may render graphics in smaller portions of a scene, often referred to as \u201ctiles\u201d of a scene. For example, a GPU may subdivide a scene into a plurality of tiles, and individually render each of the tiles. The GPU may then reconstruct the scene by combining each of the rendered tiles. Tiles may be sized so that the data associated with a particular tile can be stored in local GPU memory resources during rendering.","In general, this disclosure describes techniques for interleaving GPU processes to increase shader core utilization. This disclosure describes techniques for interleaving a rendering process and a resolve process of a GPU. That is, rather than rendering and resolving an entire scene or tile of pixel data, techniques of this disclosure relate to interleaving the rendering process and the resolve process, such that the GPU can resolve one or more pixels of data independently from rendering the one or more pixels of data. In addition, this disclosure describes techniques for interleaving a rendering process and an unresolve\/clear process of a GPU. That is, rather than unresolving or clearing an entire scene or tile of pixel data, techniques of this disclosure relate to interleaving the unresolve\/clear process and the rendering process, such that the GPU can unresolve or clear one or more pixels of data immediately following the resolve process, while also rendering other pixels of data.","In an example, aspects of the disclosure are directed to a method of processing graphics. The method includes organizing graphics data into a plurality of polygons, and assigning to each of the polygons a polygon index value that indicates an order in which each polygon will be rendered. The method also includes associating pixels of graphics data with one of the polygon index values, and determining when the pixels of graphics data will finish rendering based at least partially on the association of the pixels to the one of the polygon index values. The method also includes resolving the pixels of video data based on the determination.","In another example, aspects of the disclosure are directed to an apparatus for processing graphics. The apparatus includes one or more processors configured to organize graphics data into a plurality of polygons; assign to each of the polygons a polygon index value that indicates an order in which each polygon will be rendered; associate pixels of graphics data with one of the polygon index values; determine when the pixels of graphics data will finish rendering based at least partially on the association of the pixels to the one of the polygon index values; and resolve the pixels of video data based on the determination.","In another example, aspects of the disclosure are directed to an apparatus for processing graphics that includes a means for organizing graphics data into a plurality of polygons, and a means for assigning to each of the polygons a polygon index value that indicates an order in which each polygon will be rendered. The apparatus also includes a means for associating pixels of graphics data with one of the polygon index values, and a means for determining when the pixels of graphics data will finish rendering based at least partially on the association of the pixels to the one of the polygon index values. The apparatus also includes a means for resolving the pixels of video data based on the determination.","In another example, aspects of the disclosure are directed to a computer program product comprising a computer-readable medium having stored thereon instructions that, when executed, cause one or more processors to organize graphics data into a plurality of polygons; assign to each of the polygons a polygon index value that indicates an order in which each polygon will be rendered; associate pixels of graphics data with one of the polygon index values; determine when the pixels of graphics data will finish rendering based at least partially on the association of the pixels to the one of the polygon index values; and resolve the pixels of video data based on the determination.","The details of one or more aspects of the disclosure are set forth in the accompanying drawings and the description below. Other features, objects, and advantages of the disclosure will be apparent from the description and drawings, and from the claims.","In general, this disclosure describes techniques for increasing efficiency of a graphics processing unit (GPU), which in some examples, implements a tile-based rendering architecture. Aspects of the disclosure include techniques for interleaving GPU processes to increase shader core utilization. More specifically, this disclosure describes techniques for interleaving a rendering process and a resolve process of a GPU. In some examples, the GPU may group pixel data into blocks (e.g., a 4\u00d74 block of pixels, an 8\u00d78 block of pixels, a 16\u00d716 block of pixels, and the like), and the GPU may render some blocks of pixel data while resolving other blocks of pixel data. Accordingly, rather than rendering and resolving an entire scene or tile of pixel data, techniques of this disclosure relate to interleaving the rendering process and the resolve process in time, such that the GPU can resolve one or more blocks of pixel data independently from rendering other blocks of pixels of data.","For purposes of example and explanation, this disclosure describes techniques for a GPU that implements a tile-based rendering architecture. Tile-based rendering techniques typically reduce the need for a GPU to include large amounts of memory. For example, a GPU that implements a traditional rendering architecture may render an entire scene of pixel data (e.g., a frame of video data, a computer-generated graphics image, a still image, and the like), store the scene to GPU memory, and transfer the scene from the GPU memory to an external memory such as a display buffer. Alternatively, a GPU that implements a tile-based architecture may individually render predefined portions (commonly referred to as \u201ctiles\u201d) of a scene, store the tiles to a relatively smaller on-chip GPU memory, and transfer the tiles from the GPU memory to an external memory. The tiles can then be assembled in the external memory and displayed as a single scene. While this disclosure describes techniques being carried out by a GPU that implements a tile-based architecture, it should be understood that the techniques may also be carried out by GPUs that implement other architectures, such as the scene-by-scene architecture described above.","Tile-based rendering may be performed in several steps. For example, a GPU implementing a tile-based architecture may initially process, or preprocess, an entire scene during a binning pass to define a number of bins, also referred to as \u201ctiles.\u201d The binning pass may be followed by a series of rendering passes, during which each of the defined tiles are rendered. In some examples, each of the rendering passes is completed in three stages: (1) clear\/unresolve, (2) render, (3) resolve.","During the binning pass, the GPU may generate polygons (e.g., triangles) that make up a scene and sort the polygons to a plurality of \u201cbins.\u201d As described herein, the bins defined during the binning pass may directly relate to tiles of a final scene presented on a display (e.g., sometimes referred to as \u201cscreen tiles\u201d). For example, each bin represents a portion, or tile of the final scene (e.g., a predefined portion of a frame of video data, computer-generated graphics image, still image, or the like). Accordingly, the terms \u201cbin\u201d and \u201ctile\u201d may be used herein interchangeably.","In some examples, the GPU also performs operations during the binning pass to determine which of the polygons are visible in the scene, such as performing a depth test to determine whether a polygon covers another polygon. Upon determining which polygons are visible in the scene, the GPU can generate a stream of data referred to as a \u201cvisibility stream.\u201d The visibility stream may include a value for each of the polygons of the scene, and the value may represent whether the polygon is visible (e.g., a value of \u201c1\u201d may indicate that the polygon is visible and a value of \u201c0\u201d may indicate that the polygon is not visible).","After binning, the GPU may separately render each of the tiles by processing each of the tiles again. In some examples, the GPU implements the visibility stream generated during binning to omit, or skip, invisible polygons, so that the invisible polygons are not rendered. Accordingly, only the visible polygons, i.e., those polygons that contribute to the final scene, are processed and rendered. The GPU may carry out the rendering process on each of the tiles in three stages: (1) clear\/unresolve, (2) rendering, and (3) resolve.","During the clear\/unresolve stage, the GPU may initialize local memory resources (e.g., on-chip GPU memory) for a new tile. In some examples, the GPU initializes the GPU memory by performing a clear process to clear the GPU memory. In other examples, the GPU may initialize the GPU memory by performing an unresolve process. During an unresolve process, the GPU may read values into the GPU memory from an external memory. The GPU may implement the unresolve process when only a portion of a scene is being updated with new data. For example, pixel data that is not changed from one scene to another may be preserved across more than one scene (e.g., more than one frame of graphics data) using the unresolve process.","During rendering, the GPU may recreate the polygons associated with a current tile, as well as generate pixel values and finish a current tile, such that the tile can be displayed on a display. For example, the GPU may generate the appropriate pixel values during the rendering stage so that the pixel data that is displayed accurately represents the scene. In some examples, the GPU may store the final pixel values in the on-chip GPU memory.","After rendering, the GPU may resolve the current tile by copying the contents of the on-chip memory to a memory external to the GPU, such as a buffer for used by a display in displaying finished scenes. The GPU must typically wait to resolve pixel data until the pixel data has finished rendering. For example, if the GPU resolves, or copies, pixel data from GPU memory to external memory before the pixels have been fully rendered, the resulting scene will not exhibit the appropriate attributes of the intended scene when displayed.","In some examples, the GPU may wait to resolve a tile until the entire tile has finished rendering. For example, the GPU may wait until an entire tile is ready for display before copying the tile from GPU memory to an external memory. The GPU repeats the process until the entire scene is finished by clearing\/unresolving GPU memory for the next tile, rendering the next tile, and resolving the next tile.","This disclosure describes techniques for resolving pixel data after rendering the pixel data, without waiting for an entire tile to finish rendering, i.e., without waiting for pixel data to be rendered for all polygons in the tile. According to some aspects of the disclosure, the GPU may group pixels into \u201cblocks\u201d of pixel data (e.g., a 4\u00d74 block of pixels, an 8\u00d78 block of pixels, a 16\u00d716 block of pixels, and the like) and resolve the blocks of pixels after rendering the blocks of pixel data, without waiting for an entire tile to finish rendering.","To help to ensure that blocks of pixels are fully rendered prior to being resolved, techniques of the disclosure relate to implementing a polygon indexing system. For example, a GPU may perform polygon indexing during the binning process to track when each of the visible polygons of a scene will be rendered. That is, the GPU may apply polygon index values to the visible polygons of a tile according to an order in which the polygons will be rendered. According to some aspects of the disclosure, the polygon index values can be associated with, or tied to, blocks of pixels. For example, the GPU may assign a polygon index value to a block of pixels each time a polygon is generated in the block. The last polygon index value to be assigned to the block, then, is the last polygon to be rendered in the block.","The GPU may reference the polygon index value again during rendering. For example, the GPU may maintain a rolling counter for each polygon that is rendered in a tile. Upon generating a current polygon, the GPU can compare the counter value for the current polygon to the polygon index value for each block of pixels that the polygon \u201ctouches\u201d (e.g., each block of pixels that will be used to display the polygon in the final scene). If the counter for the current polygon matches a polygon index value associated with a relevant block, the relevant block will be finished after the GPU renders the current triangle. For example, because the current triangle is the last triangle to be rendered in the block, no additional data will later be rendered in the block. Accordingly, the GPU can resolve the matching blocks after rendering the current triangle, without waiting for the rest of the tile to finish rendering.","Techniques of the disclosure relate to polygon indexing during the binning process. For example, in addition to determining which polygons are visible in the scene and generating the visibility stream, techniques of the disclosure include assigning an index number to each of the visible polygons of a scene during binning According to some aspects of the disclosure, the polygon indexing is performed according to an order in which the polygons are rasterized (e.g., during which the pixels of the polygons are initially generated), because the order in which the polygons are rasterized dictates the order in which the GPU will render the polygons. For example, the GPU may render the polygons (e.g., during which final pixel values are generated and blended for display) in the same order that the GPU rasterizes the polygons. Accordingly, by implementing polygon indexing after the rasterizing process, the GPU can track the order in which the polygons are rendered.","In addition to performing polygon indexing during the binning process, techniques of the disclosure relate to associating polygon index values with blocks of pixel data (e.g., 4\u00d74 blocks of pixels, 8\u00d78 blocks of pixel, 16\u00d716 blocks of pixels, and the like). For example, according to some aspects of the disclosure, a GPU may associate polygon index values of the polygons with the blocks of pixels as the polygons are generated (e.g., rasterized) during the binning process. Accordingly, the GPU may associate the polygon index value of the last polygon to be rendered in a particular block with that particular block. Thus, the polygon index number associated with a particular block will be highest polygon index number associated with a polygon that is rendered in the particular block.","In some examples, the GPU may implement a block buffer to store the polygon index values that are associated with blocks. For example, the GPU may implement a block buffer that includes an entry for each block of pixels in a scene. The GPU may store the index value of the last polygon that will be rendered in a particular block to the appropriate corresponding location in the block buffer. According to some examples, the polygon index value stored to the block buffer may be referred to as a \u201cblock index value,\u201d where the block index value is equivalent to the polygon index value of the last polygon that will be rendered in a block.","This disclosure describes techniques for utilizing polygon index values associated with blocks of pixels during a rendering process to determine when the blocks of pixels will finish rendering. For example, during a rasterization phase of a rendering pass, the GPU may maintain a rolling counter associated with each polygon that is rasterized. The GPU may increment the counter each time the GPU creates a polygon. In addition, the GPU may compare the counter value of a current polygon to the previously generated and stored index value of the last polygon to be rendered in each block that the polygon touches. If the counter value of the current polygon matches the polygon index value stored for that block, the block is ready to be resolved after the current polygon has been rendered. For example, no additional pixel data will be rendered to the block, because the current polygon is the last polygon that contributes to the block.","According to some aspects of the disclosure, the GPU may resolve a block of pixels as soon as the GPU determines that no additional pixel data will be written to the block of pixels. For example, upon determining that a rolling polygon counter of a current polygon matches the polygon index value associated with a particular block, the GPU may resolve the block immediately after rendering the current polygon.","In some examples, the GPU may resolve the blocks of a scene by implementing a resolve queue and a resolve unit. According to some aspects, the GPU may track blocks that are ready to be resolved in a resolve queue according to block identifiers. For example, the GPU may generate a position value, or block identifier value, associated with each block of a given tile. The GPU may identify each block of a given tile by assigning each block an identifier value based on the spatial location of the block in the tile.","In one example, each block may be identified by its 2-D coordinate, e.g., (x, y) in Cartesian coordinates. For example, the block located at the top-left corner of the tile may be identified as the block located at (0, 0). The block immediately to the right of the block located at (0, 0) may be identified as the block located at (1, 0). The block immediately below the block located at (0, 0) may be identified as the block located at (0, 1). The Cartesian coordinates described above are described for illustration purposes only, and the positions of the blocks may be identifiable in other ways with other coordinate systems (e.g., polar coordinates, bipolar coordinates, parabolic coordinates, offsets, and the like).","Upon matching the counter value with the stored polygon index value of a particular block, the GPU may signal that the block is ready to be resolved by writing the block identifier value to the resolve queue. The resolve queue may be large enough to store all of the identifier values of all of the blocks of a tile. Accordingly, the resolve queue may store the order in which each of the blocks of a given tile should be resolved.","According to some aspects of the disclosure, the resolve unit may read the resolve queue and perform the resolving of the blocks (e.g., copy the pixel data associated with the blocks from GPU memory to an external memory). In some examples, the resolve unit resolves the blocks according to the position of the block's identifier value in the resolve queue. For example, the resolve queue may be a first-in-first-out (\u201cFIFO\u201d) type register, such that the first block identifier stored in the resolve queue (which corresponds with the first block that is ready to be resolved) is also the first block identifier value read by the resolve unit. The resolve unit may operate asynchronously from rendering. For example, the resolve unit can read values stored in the resolve queue and resolve blocks of pixel data at any time during rendering.","By implementing the polygon indexing system, a GPU can determine when pixels, or blocks of pixels, have finished rendering. Accordingly, the GPU can resolve pixels as soon as they are finished rendering and ready to be displayed, e.g., as soon as no additional information is going to be written to the block. The GPU does not have to wait for an entire tile to finish rendering before resolving the tile.","By resolving smaller blocks of data, rather than waiting for an entire tile of pixels to finish rendering, shader core utilization and overall GPU efficiency can be increased. GPU efficiecy is generally maximized when the processing units, referred to as shader core(s), are processing pixel data. Large data transfers, such as data transfers between GPU memory and an external memory, may slow the overall performance of the GPU, because the shader cores may be idle during data transfer.","For example, a GPU that implements a traditional rendering architecture may clear or unresolve on-chip GPU memory, render an entire tile of pixel data, store the tile to on-chip GPU memory, and transfer the entire tile from the GPU memory to an external memory such as a display buffer. During the time that the GPU is clearing\/unresolving GPU memory and again when transferring data from GPU memory to external memory (e.g., resolving), the shader cores sit idle. Due to memory bus constraints between GPU memory and external memory, there may be considerable latency associated with data transfers, leading to large shader core idle times.","As described in this disclosure, resolving pixel data on a block-by-block basis, independently of the rendering process, may improve utilization of the shader cores. For example, the shader cores of the GPU may be rendering data of a tile while at the same time resolving data of that tile to external memory. By implementing the polygon indexing techniques described in this disclosure, a GPU may interleave the process of resolving data with the process of rendering data, thereby increasing the utilization of the shader cores. For example, the shader cores may have less idle time because it is not necessary to for the shader cores to stand idle waiting for an entire tile to be transferred to external memory. Instead, the shader cores may continue to process other portions of a tile while previously processed portions are transferred to external memory.","In addition to interleaving the rendering and resolving processes, techniques of this disclosure relate to improving the unresolve\/clear process. For example, after the GPU has resolved pixel data (e.g., written data from on-chip GPU memory to external memory) the GPU can immediately replace the resolved pixel data with new data. The data can be immediately replaced, because pixel data that has been resolved to an external memory, such as a display buffer, will no longer be used by the GPU during a current rendering pass, and if necessary, will be unresolved from external memory back to the GPU memory.","According to some aspects of the disclosure, upon resolving a block of pixel data, the GPU replaces the block of pixel data in on-chip memory by clearing or unresolving the block of pixel data from GPU memory. In some examples, the GPU can clear\/unresolve pixel data in blocks, without waiting to clear\/unresolve an entire tile of pixel data. In this way, the GPU can interleave the clear\/unresolve process with the rendering process, thereby increasing shader core utilization. For example, the GPU can render pixel data using the shader cores while simultaneously clearing\/unresolving data from GPU memory.","Techniques of the disclosure also relate to further modifying the unresolve\/clear process and\/or rendering process such that, in some cases, the GPU may not perform the clear\/unresolve process and\/or rendering process. For example, according to some aspects of this disclosure, a GPU may maintain a second block buffer that stores a polygon index value of a final polygon that touches the block (e.g., the final polygon that will be rendered in a particular block of pixels) and fully covers the block (e.g., the polygon is opaque and is rendered in all of the pixels of the particular block). For example, the GPU may generate a polygon index value in the same manner as that described above, but may only store the polygon index value to the second block buffer if the polygon is the final polygon that will be rendered in a particular block and fully covers the block (e.g., pixels from other polygons rendered later than this polygon in the same rendering pass do not contribute to the block).","Using this second block buffer, the GPU may identify blocks that do not need to be cleared\/unresolved during the rendering process. For example, as noted above, the GPU may initially clear or unresolve the contents of GPU memory during a rendering pass. According to aspects of the disclosure, prior to unresolving the contents of GPU memory when rendering a particular polygon, the GPU may compare the polygon index value of the current polygon to the polygon index value stored in the second block buffer. If the index value of the current polygon is less than the polygon index value stored in the second block buffer (e.g., if such a value has been stored), it is known that the current polygon will be overwritten later. That is, it is known that there is a polygon that fully covers the block and that will be rendered later in the rendering pass (e.g., and thus, has a higher polygon index value), which will eliminate\/overwrite any contribution from the current polygon. Accordingly, the GPU may skip the unresolve process if the contents will be overwritten later. In this way, the GPU may only unresolve blocks that do not have a polygon that fully covers the block, but still have polygons that touch the blocks.","Additionally or alternatively, the GPU may refrain from rendering certain polygons based on the polygon index value stored in the second block buffer. For example, GPU may refrain from rendering polygons that will be overwritten later during the rendering pass. That is, when a polygon index value is stored in the second block buffer, GPU may refrain from rendering polygons associated with a lower polygon index value than the polygon index value stored in the second block buffer. GPU may refrain from rendering such polygons, because it is known that the polygon associated with the polygon index value stored in the second block buffer will overwrite such polygons.","While certain aspects above are described with respect to a \u201csecond block buffer,\u201d it should be understood that in another example the polygon index value described with respect to the second block buffer may be stored in a common block buffer with the other polygon index value described above. In this example, a first polygon index value may be maintained separately from a second polygon index value in the common buffer.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 1","FIG. 1"],"b":["20","20","24","28","32","36","40","44","20","48","20","20"]},"The illustrated computing device  of  is merely one example. Techniques for interleaving processes of a GPU, such as GPU , may be carried out by a variety of other computing devices having other components. In some examples, computing device  may include additional components not shown in  for purposes of clarity. For example, computing device  may include one or more communication bridges for transferring data between components of the computing device . Moreover, the components of computing device  shown in  may not be necessary in every example of computing device . For example, user interface  and display  may be external to computing device  in examples where computing device  is a desktop computer.","Host processor  may include any one or more of a microprocessor, a controller, a digital signal processor (DSP), an application specific integrated circuit (ASIC), a field-programmable gate array (FPGA), or equivalent discrete or integrated logic circuitry. Additionally, the functions attributed to host processor , in this disclosure, may be embodied as software, firmware, hardware or any combination thereof.","Host processor  processes instructions for execution within computing device . Host processor  may be capable of processing instructions stored on storage device  or instructions stored in memory . Host processor  may execute applications that cause viewable content to be displayed on display . According to some aspects of the disclosure, and as described in greater detail below with respect to GPU , host processor  may collaborate with GPU  to generate viewable content for display . For example, host processor  may initialize execution of an application and delegate certain graphics processing functions associated with the application to GPU .","Storage device  may include one or more computer-readable storage media. Storage device  may be configured for long-term storage of information. In some examples, storage device  may include non-volatile storage elements. Examples of such non-volatile storage elements may include magnetic hard discs, optical discs, floppy discs, flash memories, or forms of electrically programmable memories (EPROM) or electrically erasable and programmable (EEPROM) memories. Storage device  may, in some examples, be considered a non-transitory storage medium. The term \u201cnon-transitory\u201d may indicate that the storage medium is not embodied in a carrier wave or a propagated signal. However, the term \u201cnon-transitory\u201d should not be interpreted to mean that storage device  is non-movable. As one example, storage device  may be removed from computing device , and moved to another device. As another example, a storage device, substantially similar to storage device , may be inserted into computing device . Storage device  may store instructions for execution of one or more applications by host processor  or GPU .","Memory  may be configured to store information within computing device  during operation. In some examples, memory  is a temporary memory, meaning that a primary purpose of memory  is not long-term storage. Memory  may, in some examples, be described as a computer-readable storage medium. Accordingly, memory  may also be considered \u201cnon-transitory,\u201d despite storing data that can change over time. Memory  may also, in some examples, be described as a volatile memory, meaning that memory  does not maintain stored contents when the computer is turned off. Examples of volatile memories include random access memories (RAM), dynamic random access memories (DRAM), static random access memories (SRAM), and other forms of volatile memories known in the art.","In some examples, memory  may be used to store program instructions for execution by host processor  or GPU . Memory  may be used by software or applications running on computing device  to temporarily store information during program execution. As such, memory  may be accessed by other components of computing device  such as host processor  and GPU .","According to some aspects of the disclosure, memory  may be implemented as a display buffer that stores pixel data (e.g., a frame of video data, a computer-generated graphics image, a still image, and the like) before the data is displayed by display . For example, GPU  may resolve pixel data to memory  before the pixel data is displayed by display .","Computing device  may utilize network module  to communicate with external devices via one or more networks, such as one or more wireless networks. Network module  may be a network interface card, such as an Ethernet card, an optical transceiver, a radio frequency transceiver, or any other type of device that can send and receive information. In some examples, computing device  may utilize network module  to wirelessly communicate with an external device such as a server, mobile phone, or other networked computing device.","Computing device  also includes user interface . Examples of user interface  include, but are not limited to, a trackball, a mouse, a keyboard, and other types of input devices. User interface  may also include a touch-sensitive screen that is incorporated as a part of display . Display  may comprise a liquid crystal display (LCD), an organic light emitting diode (OLED) display, a plasma display, or another type of display device.","GPU  of computing device  may be a dedicated hardware unit having fixed function and programmable components for rendering graphics and executing GPU applications. GPU  may also include a DSP, a general purpose microprocessor, an ASIC, an FPGA, or other equivalent integrated or discrete logic circuitry. GPU  may also include other components, such as dedicated GPU memory .","In addition, although shown as separate components in , in some examples, GPU  may be formed as part of host processor . GPU  may be configured to utilize processing techniques in accordance with a variety of application programming interfaces (APIs). For example, a user may program an application to be executed by GPU  using a standard software interface that can run on multiple platforms, operating systems, and hardware.","In some examples, GPU  may be configured to utilize applications generated using the OpenGL platform, including OpenGL for Embedded Systems (\u201cOpenGL ES,\u201d released March, 2007 and publically available). In general, an API includes a predetermined, standardized set of commands that are executed by associated hardware. API commands allow a user to instruct hardware components of a GPU to execute commands without user knowledge as to the specifics of the hardware components.","GPU  may be implemented to render graphics for display on display . According to some aspects of the disclosure, GPU  may implement a tile-based rendering architecture. For example, rather than rendering an entire scene of pixel data (e.g., a frame of video data, a computer-generated graphics image, a still image, and the like), GPU  may break a scene into multiple pieces (e.g., \u201ctiles\u201d), and individually render the tiles. The GPU  may write each of the rendered tiles to a buffer, such as a display buffer included in memory . Upon writing all of the tiles of the scene to memory , computing device  may assemble the rendered tiles and display the scene on display .","According to some aspects of the disclosure, GPU  may perform tile-based rendering in a plurality of \u201cpasses\u201d (e.g., a \u201cpass\u201d may generally refer to processing pixel data). During an initial binning pass, GPU  may initially process an entire scene to determine which polygons (e.g., triangles) are visible in the scene (e.g., using depth testing or z-buffering) and assign the polygons to bins that define tiles. The GPU  may follow the binning pass with a series of rendering passes, during which the GPU  renders each of the tiles. In some examples, each of the rendering passes is completed in three stages: (1) clear\/unresolve, (2) render, (3) resolve.","Prior to binning, the GPU  may receive data associated with a scene from host processor . GPU  may then process the polygons that make up the scene, which are generally referred to herein as triangles, although GPU  may implement a variety of other polygons to render a scene. GPU  also determines which triangles are visible and generates a visibility stream. GPU  may use the visibility stream to identify visible triangles and skip invisible or covered triangles during tile-based rendering passes.","After binning, the GPU  may separately render each of the tiles by performing a rendering pass on each of the tiles. According to some aspects of the disclosure, GPU  may transfer data associated with a tile that is currently being rendered from an external memory, such as memory , to local GPU memory . The GPU  may also implement the visibility stream to prevent polygons that are not visible in the final scene from being rendered. The rendering pass of the tiles may include in three stages: (1) clear\/unresolve, (2) rendering, and (3) resolve.","When rendering a tile, GPU  may initially prepare GPU memory  for processing by removing the contents of GPU memory  (\u201cclear\u201d), or reading values into GPU memory  from an external memory, such as memory  (\u201cunresolve\u201d). The GPU  may unresolve GPU memory  when preserving pixel data between tiles. During rendering, GPU  may generate and fill the triangles signaled in the visibility stream. For example, GPU  may generate the appropriate pixel values during the rendering so that the tile accurately represents a portion of the final scene. After rendering, GPU  may resolve the current tile by copying the contents from GPU memory  to memory . In some examples, GPU  may wait to resolve a tile until the GPU  has finished rendering the entire tile. The GPU  repeats the rendering process on a tile-by-tile basis until the entire scene is finished.","As described in greater detail with respect to , GPU  may interleave, or perform concurrently, certain processes associated with rendering tiles. For example, GPU  may concurrently render pixel data of a tile while also resolving other pixel data of the tile to memory . That is, GPU  may resolve some pixel data associated with a tile to memory  without waiting to render the entire tile. Additionally or alternatively, techniques of the disclosure include concurrently unresolving or clearing data associated with a particular tile from GPU memory  while rendering other data associated with the tile. That is, GPU  may concurrently render pixel data of a tile while also clearing or unresolving pixel data of the tile that has already been rendered and resolved. In this way, GPU  can clear or unresolve pixel data of a tile that has already been rendered and resolved, but that is still stored in GPU memory , in preparation for another tile while the GPU  finishes rendering a current tile. Additionally or alternatively, techniques of the disclosure include performing a subset the rendering steps described above (e.g., clear\/unresolve, render, resolve). That is, certain aspects of the disclosure relate to skipping the clear\/unresolve portion of the rendering process to improve the efficiency of GPU . Certain aspects of the disclosure may also relate to refraining from rendering certain pixel data to improve the efficiency of GPU .",{"@attributes":{"id":"p-0069","num":"0068"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 2"],"b":["48","48","48","52","56","56","56","60","64","68","72","76","48","32","80"]},{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 2"],"b":["48","48","48","56","56","48","56"]},"In some examples, GPU memory  is similar to memory  shown in . For example, GPU memory  may be a temporary computer-readable storage medium. Examples of GPU memory  include random access memories (RAM), dynamic random access memories (DRAM), static random access memories (SRAM), and other forms of registers and memories known in the art. In examples where GPU  is formed as part of another processor, such as host processor  shown in , GPU memory  may be accessed by components other than GPU .","In some examples, components of GPU  may access GPU memory  with relatively lower latency than the components of GPU  may access an external memory, such as memory . For example, GPU memory  may be an on-chip memory that is in relatively close proximity with GPU components, and may be associated with a dedicated memory buss within GPU . To access data stored in external memory , however, GPU  may have to share memory hub  with other computing device components, thereby reducing the available bandwidth.","To take advantage of the high bandwidth, low latency GPU memory , GPU  may render graphics using a tile-based rendering architecture. GPU  may break a scene (e.g., a display screen) into smaller portions (e.g., tiles), and GPU memory  may store data associated with a tile of a scene while GPU  renders the tile. For example, after dividing a scene into tiles, GPU  may transfer a tile of pixel data from an external memory, such as memory  to GPU memory  via memory hub . GPU  may then render the tile. After rending the tile, GPU  may resolve, or copy, the rendered pixel data from GPU memory  to memory  via memory hub .","According to some aspects of the disclosure, shader cores  are configured as \u201ccommon shader cores,\u201d and are responsible for vertex, geometry, and pixel related shader operations of GPU . For example, shader cores  may be responsible for determining vertex positions of polygons (e.g., triangles) that make up a scene and producing a triangle mesh of the scene. In addition, shader cores  may be responsible for generating primitives from the triangle mesh, as well as pixel filling and shading operations. Shader cores  may be configured identically, or may be individually configured to perform a specific task. For example, shader core A may be configured as a \u201cbinning shader\u201d that is responsible for binning operations, while shader cores B-D may be responsible for other vertex, geometry, or pixel related operations.","Rasterizer  may receive vertex information from memory or visibility module , described below, and may generate a representation of triangles of a scene. In some examples, rasterizer  applies predefined rules to received vertex information to determine which triangles are visible in the final scene. Rasterizer  may cull, or remove, any invisible triangles of the scene. For example, rasterizer  may perform z-buffering to remove triangles that are covered by other triangles, and therefore not visible in the final scene. According to some aspects of the disclosure, rasterizer  may perform rasterization and triangle culling on a block-by-block basis. For example, rasterizer  may group pixels into \u201cblocks\u201d of pixel data (e.g., a 4\u00d74 block of pixels, an 8\u00d78 block of pixels, a 16\u00d716 block of pixels, and the like) and perform rasterization and triangle culling on a low resolution basis.","Visibility module  may receive the rasterized data from rasterizer module  and generate one or more visibility streams. To generate the visibility stream, visibility module  may distribute each of the visible triangles, as determined by rasterizer , to bins. Each bin may represent a tile of the finished scene. In some examples, visibility module  may generate a separate visibility stream for each of the bins. For example, visibility module  may generate a visibility stream for a particular bin by setting flags to indicate which triangles of the particular bin are visible and which triangles of the particular are invisible. According to some aspects, visibility module  may set a flag value of \u201c1\u201d to indicate that a triangle is visible in the final scene and a flag value of \u201c0\u201d to indicate that a triangle is not visible in the final scene. Accordingly, visibility module  may generate a plurality of visibility streams comprising flags that indicate the visible triangles of each of the bins. In some examples, visibility module  may compress the visibility streams. For example, visibility module  may apply a compression scheme to reduce large strings of \u201c0\u201d flags and reduce the amount of memory required to restore the visibility streams.","According to some aspects of the disclosure, in addition to generating the visibility streams, visibility module  may also perform triangle indexing. For example, in addition to determining which triangles are visible in each of the bins and generating the visibility streams, techniques of the disclosure include assigning an index number to each of the visible triangles of a scene during binning Visibility module  may assign triangle index values to the visible triangles of a particular tile according to an order in which rasterizer module  rasterizes the visible triangles. Assigning the index values in this way results in triangles having temporally relative index values. For example, GPU  may render the triangles in the same order in which rasterizer module  rasterizes the triangles. Accordingly, a triangle having a relatively lower index value indicates that the triangle is rasterized and rendered before triangles having relatively higher index values.","Block buffer  may include registers or other memory for storing triangle index values. According to some aspects of the disclosure, each entry of block buffer  may correspond to a blocks of pixels of a tile (e.g., a 4\u00d74 block, a 8\u00d78 block, a 16\u00d716 block, and the like). For example, block buffer  may include a plurality of entries that correspond to each of the blocks of pixels that were rasterized by rasterizer module . In some examples, block buffer  may be represented as a table of triangle index values, with each entry in the table corresponding to a spatial location of a block in the tile (e.g., as shown and described in greater detail with respect to ). According to some examples, the triangle index values stored to the block buffer  may be referred to as a \u201cblock index values,\u201d where the block index values are equivalent to the triangle index values.","Visibility module  may be responsible for storing triangle index values to block buffer . In some examples, visibility module  may store a triangle index value of the last triangle to be rendered in a particular block to that block's position in block buffer . As described above, the highest triangle index value associated with a particular block relates to the last triangle that is rendered in that block. Accordingly, visibility module  may identify and store the highest index value associated with a triangle of a particular block to that block's position in block buffer . Although represented as an independent buffer in , according to some examples, block buffer  may be integrated in another component of GPU . In one example, block buffer  may be included in visibility module . In another example, block buffer  may be a partition of GPU memory .","Resolve queue  may include registers or other memory for storing block identifiers that correspond to the spatial location of blocks in a tile. In one example, each block of a tile may be identifiable by its 2-D coordinate, e.g., (x, y) in Cartesian coordinates. For example, the block located at the top-left corner of the tile may be identified as the block located at (0, 0). The block immediately to the right of the block located at (0, 0) may be identified as the block located at (1, 0). The block immediately below the block located at (0, 0) may be identified as the block located at (0, 1). The Cartesian coordinates described above are used for described for illustration purposes only, and the positions of the blocks may be identifiable in other ways with other coordinate systems (e.g., polar coordinates, bipolar coordinates, parabolic coordinates, and the like).","According to some aspects of the disclosure, the resolve queue  holds the block identifiers of blocks that are ready to be resolved. For example, resolve queue  may hold the block identifiers of blocks that have been rendered by GPU  (e.g., using shader cores ) and are ready to be resolved to memory  via memory hub . Resolve queue  may be sized to store all of the block identifiers of a given tile. In some examples, the resolve queue  may be a first-in-first-out (\u201cFIFO\u201d) type buffer, such that the first block identifier received by the resolve queue  is also the first to be read from the resolve queue .","Resolve module  may read the block identifier values stored in resolve queue  and resolve blocks of pixels according to the order of the block identifiers stored in resolve queue . For example, resolve module  may read a particular block identifier stored in resolve queue  and copy the rendered block of pixel data from GPU memory  to memory  via memory hub . Resolve module  may operate asynchronously from the rendering process. For example, the resolve module  can read block index values stored in the resolve queue  and resolve blocks of pixel data at any time, including during rendering.","Aspects of the disclosure relate to interleaving rendering and resolve processes of GPU . In some examples, GPU  may initially receive a command from an external source, such as host processor  shown in , to render a scene for display. GPU  may begin by processing the entire scene during a binning pass. For example, GPU  may implement one or more of the shader cores  to generate vertex information, and implement rasterizer module  to transform the vertex information into triangles of the scene. Rasterizer  may also determine which triangles of the scene are visible. In some examples, rasterizer  may perform rasterization and cull triangles that are not visible in the final scene.","Visibility module  may receive the rasterized data and distribute each of the visible triangles to bins (e.g., each bin represents a tile of the scene). Visibility module  may generate a separate visibility stream for each of the bins by setting flags to indicate which triangles of the particular bin are visible. To enable interleaving of rendering and resolve processes, visibility module  may also perform triangle indexing. For example, visibility module  may assign triangle index values to the visible triangles of a particular tile according to an order in which rasterizer module  rasterizes the visible triangles.","According to some aspects of the disclosure, visibility module  may also be responsible for associating triangle index values with blocks of pixels and storing the triangle index values to block buffer . For example, each time visibility module  processes a triangle, visibility module  may determine which block or blocks that the triangle \u201ctouches\u201d (e.g., which blocks will be used to display the triangle in the final scene). Visibility module  may associate the triangle index value of the triangle currently being processed with each block that the triangle touches, and store those associations to the appropriate locations in block buffer . According to some examples, visibility module  may overwrite the triangle index values stored in block buffer  as visibility module  processes each triangle. For example, if a new triangle touches the same block as a previously processed triangle, visibility module  may associate the triangle index value of the new triangle with the block. Visibility module  may also overwrite the corresponding position in block buffer  with the new triangle index value. In this way, visibility module  can store the triangle index value for a last triangle that is processed in a particular block to that block's associated position in block buffer .","After GPU  has completed binning the entire scene, GPU  may render each tile of visible triangles separately during a plurality of rendering passes. During each of the rendering passes, GPU  may perform three processes to finish the tiles: (1) clear\/unresolve, (2) render, and (3) resolve. Aspects of the disclosure relate to interleaving the rendering and resolve processes. For example, GPU  may perform the rendering and resolve processes simultaneously, and without waiting for an entire tile render before resolving the tile.","GPU  may interleave the rendering and resolve processes by utilizing the triangle index values stored in block buffer . During a rendering pass of a tile, GPU  may initially prepare GPU memory  for the tile by clearing (e.g., erasing) or unresolving (e.g., overwriting) the contents of GPU memory . Rasterizer module  may then generate the visible triangles of the tile using the visibility stream stored in visibility module . In addition, rasterizer module  may maintain a rolling counter associated with each triangle that is generated. For example, rasterizer module  may increment a counter each time that rasterizer module  generates a triangle.","According to some aspects of the disclosure, when generating triangles, the rasterizer module  also compares the triangle counter value with the triangle index values stored in block buffer  for each block of pixels that the triangle touches. That is, if rasterizer module  generates a triangle that spans three blocks (e.g., the triangle is displayed in three different blocks of pixels in the tile), rasterizer module  compares the triangle counter value to each of the triangle index values stored for each of the three blocks. Rasterizer module  may determine that a particular block will be ready to be resolved (e.g., after pixel shading and filling operations performed by shader cores ) if the triangle counter value matches the stored triangle index value. For example, rasterizer module  may determine that no additional pixel data will be rendered to the block after the current triangle has been rendered, because the current triangle is the last triangle that contributes to the block.","If rasterizer module  determines that a block is ready to be resolved after the block has finished rendering (e.g., the counter value of the current triangle matches a triangle index value stored in block buffer  for the block), the rasterizer module  may store a block identifier value associated with the block to resolve queue . In some examples, the rasterizer  may also generate a resolve event (e.g., a flag or other event) that is associated with the block. The resolve event may be sent to the resolve module  through the remaining rendering stages (e.g., graphics pipeline operations such as pixel shading and filling operations).","By sending the resolve event through the remaining rendering stages, GPU  is able to finish rendering the current triangle before the event is received by resolve module . For example, the resolve module  may be positioned at the relative end of a rendering pipeline of GPU . If the resolve event follows the current triangle through the rendering stages of GPU , the triangle will finish rendering before the resolve module  receives the event. After receiving the resolve event, resolve module  may read the block identifier from resolve queue and resolve the block to external memory  via memory hub .","In this way, GPU  may interleave the rendering and resolve processes such that GPU  can render portions of a tile while simultaneously resolving other portions of the tile. For example, instead of waiting for an entire tile to finish rendering before resolving the tile, GPU  can identify smaller portions of a tile, i.e., one or more pixels (e.g., blocks), that are ready to be resolved. According to some aspects of the disclosure, prior to rendering, GPU  can store an index value for each block of pixels in a tile. The stored index value identifies the last triangle that will be rendered in each respective block. During rendering, GPU  can identify when a portion of a tile (e.g., a block of pixels) will be ready to be resolved by comparing a rolling counter value for a triangle that is currently being rendered to the stored index values for each block that the triangle touches. If the counter value of the triangle that is currently being rendered matches a stored index value, the block associated with that stored index values will be finished (e.g., ready for resolve) when the current triangle has finished rendering. Accordingly, GPU  can identify and resolve the blocks that are finished while still rendering the other blocks of the tile.","Resolving pixel data on a block-by-block basis, independently of the rendering process, may improve utilization of the shader cores . For example, interleaving the rendering and resolve processes may reduce large transfers of data between GPU memory  and external memory  when resolving an entire tile of data, during which time shader cores  sit idle. Instead, the shader cores  of GPU  may continue rendering pixel data of a tile, while at the same time resolving data of that tile to external memory .","In addition to interleaving the rendering and resolving processes, techniques of this disclosure relate to improving the unresolve\/clear process. For example, after GPU  has resolved a block of pixel data to external memory , GPU  can immediately replace the resolved block of pixel data with new data. According to some aspects of the disclosure, upon resolving a block of pixel data in GPU memory , GPU  replaces the block of pixel data in GPU  by clearing or unresolving the block of pixel data from GPU memory . In this way the GPU  may replace the block (e.g., via clear\/unresolve) while continuing to render other blocks of data in the same tile.","Interleaving the rendering process with the unresolve\/clear process may further improve utilization of the shader cores . For example, interleaving the rendering and unresolve\/clear process may reduce large transfers of data between GPU memory  and external memory when starting to perform binning on a new tile. That is, rather than having to clear\/unresolve an entire tile after resolving the tile, the GPU  can clear\/unresolve portions of the tile while continuing to render other portions of the tile.","According to some aspects of the disclosure, to enable a partial clear\/unresolve of a tile, GPU  may store an additional triangle index value. For example, GPU  may store a second triangle index value for a final triangle that touches a block that also fully covers the block to block buffer . For example, GPU  may generate a triangle index value in the same manner as that described above, but may only store a second triangle index value to block buffer  if the triangle is the final triangle rendered in a particular block and the triangle also fully covers the block (e.g., pixels from other triangles rendered later than this triangle in the same rendering pass do not contribute to the block).","In some examples, the final triangle that touches the block and fully covers the block must also have certain properties to ensure that no other information from other triangles contribute to the block. For example, such properties may include that there is no blending with other triangles, that there is no alpha kill associated with the triangle, that the triangle is opaque, and the like. If the triangle is the final triangle to touch a block, fully covers the block, and exhibits the predetermined properties, GPU  may store a second triangle index value for the triangle to block buffer .","The second triangle index value may aid GPU  in identifying blocks that do not need to be cleared\/unresolved during the rendering process. For example, as noted above, GPU  may initially clear or unresolve the contents of GPU memory  during a rendering pass. Prior to unresolving the contents of GPU memory , however, GPU  may compare a triangle index value of a triangle currently being rendered to the second triangle index value in block buffer . If the index value of the current triangle is less than the second triangle index value (e.g., if a second triangle index value has been stored), GPU  may determine that the current triangle will be overwritten later. That is, GPU  may identify that there is a triangle that fully covers the block and that is rendered later in the rendering pass (e.g., and thus, has a higher triangle index value) that will eliminate\/overwrite any contribution from the current triangle. Accordingly, GPU  may not clear\/unresolve the block. That is, GPU  may only unresolve blocks that do not have a triangle that fully covers the block, but that still have triangles that touch the blocks.","In some examples, GPU  may refrain from rendering certain triangles based on the second triangle index value. For example, GPU  may refrain from rendering triangles that will be overwritten later during the rendering pass. That is, based on a second triangle index value, GPU  may refrain from rendering triangles associated with a lower index value than the second triangle index value. GPU  may refrain from rendering such triangles, because the triangle associated with the second index value will overwrite such triangles.","In this way, GPU  may identify the last triangle that is rendered in a block that fully overwrites all pixels in the block and may optimize the rendering pass accordingly. In an example, GPU  may not process some blocks at all. That is, if both the first triangle index value and the second triangle index values are zero, GPU  can determine that nothing is rendered to the block. Accordingly, there is no need to unresolve and resolve the block. In another example, when rendering a particular triangle, GPU  may not perform a clear\/unresolve for the triangle if the triangle is fully covered by another triangle. That is, GPU  may use the second triangle index value, as described above, to determine when a block should be cleared\/unresolved. Moreover, GPU  may use the second triangle index value to optimize rendering by reducing overdraw. That is, if GPU  identifies, prior to rendering a current triangle, that the current triangle will be overwritten by a triangle that fully covers the block later in the rendering pass (e.g., as identified by the second triangle index value), GPU  may refrain from rendering the current triangle.","The functions attributed to certain modules described with respect to  are provided merely for purposes of example. According to aspects of the disclosure, functions attributed to one module may be carried out by, or in cooperation with, another module of GPU . For example, the visibility module  is described above as generating associations between blocks of pixels and triangle index values. In other examples, rasterizer module  may be implemented to perform the associations.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":["FIG. 3","FIG. 1","FIG. 2","FIG. 3","FIGS. 1 and 2"],"b":["100","104","104","104","104","108","104","48","48","100","48"]},"The scene  shown in  is a two dimensional representation of a three dimensional work space having a desk and a computer. Each component of the scene  may be represented with a plurality of triangles. The visible triangles of the scene  are shown in . In some examples, GPU  may be implemented to generate and fill the pixels that make up each of the triangles of scene .","According to some aspects of the disclosure, GPU  may perform a binning pass on scene . During the binning pass, GPU  may identify visible triangles of the scene  and sort the visible triangles to bins . In addition, to enable interleaving of GPU processes, GPU  may also perform triangle indexing. For example, as described in greater detail with respect to , GPU  may assign triangle index values to the visible triangles of the bins  according to an order in which the triangles of a bin  will be rendered. As described in greater detail with respect to , GPU  may also identify and store the highest triangle index value touching a block  to that block's position in block buffer . In this way, GPU  can store the triangle index value of the last triangle to be rendered in a particular block  to that block's position in block buffer .",{"@attributes":{"id":"p-0104","num":"0103"},"figref":["FIG. 4","FIG. 3","FIG. 1","FIG. 2","FIG. 4","FIG. 4","FIGS. 1 and 2"],"b":["104","108","48","104","100","48"]},"According to some aspects of the disclosure, GPU  may assign triangle index values to triangles of bin F based on an order in which the triangles will be rendered. For example, GPU  may generate triangle index values and assign the values to visible triangles of bin F during a rasterization process.","In some examples, GPU  may implement triangle indexing during a rasterization process that is carried out during both an initial binning process and again during a rendering process. For example, GPU  may generate triangle index values during the binning process when distributing visible triangles to bin F. In , each triangle includes an index value, such as index value 1 (e.g., with a portion of triangle  being covered by triangle ). As described in greater detail with respect to , GPU  may also store the highest triangle index value touching a given block, such as block A shown in , to the given block's position in block buffer  during the binning process.","GPU  may also generate triangle index values for visible triangles of bin F using the visibility stream stored in visibility module  during rendering. For example, GPU  may maintain a rolling counter associated with each triangle that is generated during the rendering process for bin F. GPU  may increment the counter each time that a triangle is generated during rendering. According to some aspects of the disclosure, as described in greater detail with respect to , the counter value may be compared to the index values stored in block buffer  to determine when a particular block , such as block A, is ready to be resolved.",{"@attributes":{"id":"p-0108","num":"0107"},"figref":["FIG. 5","FIGS. 3 and 4","FIG. 1","FIG. 2","FIG. 5","FIGS. 3 and 4","FIG. 5","FIGS. 1 and 2"],"b":["120","108","48","120","104","48"]},"According to aspects of the disclosure, the table of triangle index values  is one example of a table of triangle index values that may be stored in block buffer . In the example shown in , each entry of table  corresponds to a spatial location of a block  in bin F shown in . That is, the upper left hand entry of table , marked 0,0, may correspond to block A shown in . The remaining entries of table  may similarly correspond to the other blocks  of bin F.","GPU  may assign a triangle index value of the final triangle to be rendered in a particular block  to the corresponding location in table  (e.g., the last triangle to be rendered in time). The last triangle rendered in a particular block  is known, because the triangle index values are applied to the triangles according to the order in which the triangles will be rendered. For example, GPU  associates a triangle index value with one or more blocks each time that GPU  generates a triangle during rasterization. For example, GPU  determines the block or blocks in which a particular triangle is rendered in (e.g., which blocks the triangle \u201ctouches\u201d) and stores the triangle index value of that triangle to the corresponding locations in block buffer . If GPU  later generates another triangle that touches the same blocks as a previous triangle, GPU  can overwrite the corresponding locations in block buffer  with the new triangle index number. In this way, the GPU  stores the triangle index value of the last triangle to touch a particular block in the corresponding location of block buffer .","According to some examples, the triangle index values stored to the block buffer may be referred to as a \u201cblock index values,\u201d where the block index values are equivalent to the triangle index number of the last polygon that will be rendered in a block in time. According to aspects of the disclosure, the triangle index values stored in table  may be used during the rendering of bin F to aid in interleaving a rendering process and a resolve process. For example, GPU  may utilize the triangle index values stored in table  to determine when the corresponding blocks  will finish rendering. In some examples, GPU  may maintain a rolling counter for each triangle that is generated during a rendering phase, and compare the counter value of a current triangle to the entries of table  that the current triangle touches. If the counter value of the current triangle matches any of the relevant triangle index values stored in table , the corresponding blocks will be ready to be resolved after the current triangle has been rendered.","Upon matching the counter value and the triangle index values stored in table , GPU  may store a block identifier (e.g., such as the Cartesian coordinates described above) to resolve queue . As described in greater detail with respect to , the resolve queue  may be read by resolve module .",{"@attributes":{"id":"p-0113","num":"0112"},"figref":["FIG. 6","FIG. 1","FIG. 2","FIG. 6","FIGS. 1 and 2"],"b":["140","48","140","48"]},"According to the method , GPU  initially receives a scene of pixel data (e.g., from host processor  shown in ) and performs binning and triangle indexing for the scene (). For example, GPU  may generate the triangles that make up the scene, cull triangles that are not visible in the scene, and generate one or more visibility streams for each bin of the scene by distributing visible triangles to each bin. After distributing the triangles of the scene to bins, GPU  may also perform triangle indexing for each bin. That is, GPU  may generate a triangle index value for each triangle of each bin that indicates when a particular triangle will be rendered, relative to the other triangles of the bin.","According to aspects of the disclosure, GPU  also associates triangle index values with smaller portions of each bin, such as blocks of pixels (a 4\u00d74 block, an 8\u00d78 block, a 16\u00d716 block, or the like), and stores the triangle index value of the final triangle to be rendered in a particular block to block buffer  (). In some examples, GPU  associates a triangle index value with one or more blocks each time that GPU  generates a triangle. For example, GPU  determines which blocks that a particular triangle is rendered in (e.g., \u201ctouches\u201d) and stores the triangle index value of the triangle to the corresponding block locations in block buffer . If GPU  later renders another triangle that touches the same blocks, the corresponding block buffer values can be overwritten with the new triangle index number. In this way, the GPU  can store the triangle index value of the last triangle to touch a particular block in the corresponding location of block buffer .","After finishing the binning and storing triangle index values to block buffer , GPU may perform rendering on a first bin, also referred to as a tile. For example, GPU  may clear or unresolve GPU memory  (). GPU  then begins rendering the tile by generating the visible triangles that make up the scene using a visibility stream from visibility module . In addition, GPU  maintains a rolling counter that is incremented for each triangle that is generated (). Upon generating a triangle, GPU  may compare the counter value for the current triangle to the triangle index values stored in block buffer  for each block that the current triangle touches (). If the counter value does not match the relevant triangle index values stored in block buffer , GPU  continues rendering the current triangle without taking further action (). For example, each of the blocks that the current triangle touches will include information from triangles that are rendered later. GPU  then continues by generating the next tile and incrementing the counter value ().","If the counter value does match any of the relevant triangle index values stored in block buffer , GPU  stores a block identifier of the matching blocks to resolve queue  (). For example, GPU  identifies the matching blocks and identifies those matching blocks using block identifiers that identify the spatial location of the matching blocks. Adding a block identifier to resolve queue  may indicate that the block is ready to be resolved after the current triangle has finished rendering.","In addition, GPU  may generate a resolve event () and continue rendering the current triangle (). According to some examples, as described in greater detail with respect to , the resolve event may travel through the rendering pipeline with the current triangle and be received by resolve module . GPU  then determines whether the current triangle is the last triangle of the tile (). If the current triangle is the last triangle of the tile, GPU  moves on to the next tile () and repeats the process at step . If the current triangle is not the last triangle of the tile, GPU  continues rendering at step .",{"@attributes":{"id":"p-0119","num":"0118"},"figref":["FIG. 7","FIG. 1","FIG. 2","FIG. 7","FIGS. 1 and 2"],"b":["180","48","180","48"]},"As described with respect to , GPU  may generate resolve events at certain times during rendering. More specifically, GPU  may generate a resolve event when a counter value of a current triangle matches a triangle index value that is stored for a block that the current triangle touches. According to examples of the disclosure, resolve module  receives a resolve event (). Upon receiving the resolve event, resolve module  may read a value from resolve queue  that identifies a block that is ready to be resovled (). In some examples, the resolve queue  is a FIFO type register such that the first block identifier to be stored in resolve queue  is also the first to be read by resolve module .","After reading the resolve queue , resolve module  may read the block identified in the resolve queue  out from GPU memory  to external memory  (). In addition, GPU  may clear or unresolve the block of pixel data that was just read out to external memory  with new data ().","While certain aspects of this disclosure have been described with respect to \u201ctriangles,\u201d it should be understood, as noted above, that a number of other polygons may be used. That is, a GPU may implement the techniques described herein using any polygon, and the aspects of this disclosure are not limited to triangles.","In one or more examples, the functions described may be implemented in hardware, software executed on hardware, firmware executed on hardware, or any combination thereof. In some examples, instructions stored on a computer-readable media may cause the hardware components to perform their respective functions described above. The computer-readable media may include computer data storage media. Data storage media may be any available media that can be accessed by one or more computers or one or more processors to retrieve instructions, code and\/or data structures for implementation of the techniques described in this disclosure. By way of example, and not limitation, such computer-readable media can comprise RAM, ROM, EEPROM, CD-ROM or other optical disk storage, magnetic disk storage, or other magnetic storage devices, flash memory, or any other medium that can be used to carry or store desired program code in the form of instructions or data structures and that can be accessed by a computer. Combinations of the above should also be included within the scope of computer-readable media.","The code may be executed by one or more processors, such as one or more DSPs, general purpose microprocessors, ASICs, FPGAs, or other equivalent integrated or discrete logic circuitry. Accordingly, the term \u201cprocessor,\u201d as used herein may refer to any of the foregoing structure or any other structure suitable for implementation of the techniques described herein. In addition, in some aspects, the functionality described herein may be provided within dedicated hardware and\/or software modules configured for encoding and decoding, or incorporated in a combined codec. Also, the techniques could be fully implemented in one or more circuits or logic elements.","The techniques of this disclosure may be implemented in a wide variety of devices or apparatuses, including a wireless handset, an integrated circuit (IC) or a set of ICs (e.g., a chip set). Various components, modules, or units are described in this disclosure to emphasize functional aspects of devices configured to perform the disclosed techniques, but do not necessarily require realization by different hardware units. Rather, as described above, various units may be combined by a collection of interoperative hardware units, including one or more processors as described above, in conjunction with suitable software and\/or firmware.","Various examples have been described. These and other examples are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 5","FIGS. 3 and 4"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
