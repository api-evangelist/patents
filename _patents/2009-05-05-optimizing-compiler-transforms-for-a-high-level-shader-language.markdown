---
title: Optimizing compiler transforms for a high level shader language
abstract: A high level shader language compiler incorporates transforms to optimize shader code for graphics processing hardware. An instruction reordering transform determines instruction encapsulations of dependent instructions that reduce concurrent register usage by the shader. A phase pulling transform re-organizes the shader's instructions into phases that reduce a measure of depth of texture loads. A register assigning transform assigns registers to lower register usage by the shader.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08689199&OS=08689199&RS=08689199
owner: Microsoft Corporation
number: 08689199
owner_city: Redmond
owner_country: US
publication_date: 20090505
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["This is a continuation of U.S. application Ser. No. 10\/445,397, filed May 23, 2003, now U.S. Pat. No. 7,530,062, which application is incorporated herein in its entirety.","1. Technical Field","The invention relates generally to optimizing code generation by compilers, and more particularly relates to code transforms for improved code generation in compilers for high level shader languages.","2. Description of Related Art","Computers commonly have a graphics adapter or graphics accelerator that contains a specialized microprocessor, generally known as a graphics co-processor or graphics processing unit (GPU). A GPU also can be integrated into the chip set contained on the motherboard of the computer. The GPU handles high-speed graphics-related processing to free the computer's central processing unit (CPU) for other tasks. Today's graphics adapters (e.g., various graphics adapter models available from NVIDIA and ATI Technologies, among others) feature GPUs that are specifically designed to render 3-dimensional (3D) graphics images and video at high frame rates, such as for use in computer games, video and other graphics intensive applications. Some CPUs for computers also include specialized instructions in their instruction sets that are designed for graphics-related processing (e.g., the MMX instructions in Intel Corporation microprocessors).","In past graphics adapters, the GPU generally provided fixed functionality for graphics processing operations. Application programs (e.g., a game with 3D graphics) would interact with the graphics adapter through a graphics application programming interface (API), such as Microsoft Corporation's DirectX\u00ae, and OpenGL\u00ae of Silicon Graphics, Inc. Through a graphics API, the application programs directed the GPU to execute its fixed graphics processing functions.","In its version 8, Microsoft DirectX\u00ae more recently introduced the concept of a programmable graphics shader for recent programmable graphics hardware. A shader is a program that executes on graphics hardware to perform graphics processing on a per pixel, or per vertex (or other graphics component or fragment) basis for 3D graphics rendering. DirectX\u00ae 8 included a language for writing shaders. However, this language was a low-level, assembly-like language and also very specific to certain GPU architectures. This made it more difficult for application developers to take advantage of this improved programmability of the graphics hardware.","DirectX\u00ae version 9 introduced a high level programming language for shaders (called the High Level Shading Language or HLSL) to make it easier for application developers to create shaders. The HLSL is syntactically similar to the well known C programming language. This makes it easier for programmers who are familiar with C to understand.","A problem arises, however, in that non- or less than optimal object code may result from compiling a high level language into object code of a target processor. Further, programmable GPUs are vector-based processors with different architectural constraints than conventional CPU processors. Accordingly, known code optimization techniques may still fail to produce more optimal code for shaders on programmable graphics hardware.","For example, a current typical programmable GPU provides a set of vector registers for loading textures from graphics memory. The textures are a set or array of values held in the graphics memory of the graphics adapter. Typically, the registers have capacity for four components of vector values pulled one at a time from an assigned texture in memory. The GPU executes texture load instructions that assign the texture to be loaded in the components of a register, and arithmetic instructions that operate on vectors of the texture. However, direct translation by a compiler of high level shader language instructions would result in shaders that fail to efficiently utilize the register architecture of these processors, and conventionally known compiler code optimizations are not designed to optimize this type of processor architecture.","A compiler for a high level shader language employs shader code optimizing transforms to produce more optimal code, such as for execution on a programmable GPU or other graphics hardware. This allows efficient shader programs to be produced using a high level shader language that is easier for programmers to write.","Among other optimizing transforms implemented in a high level shader language compiler described herein, the shader code optimizing transforms include an instruction reordering transform, a phase pulling transform and a register assigning transform. The instruction reordering transform determines instruction encapsulations of dependent instructions that reduce concurrent register usage by the shader. The phase pulling transform re-organizes the shader's instructions into pairs of texture load and arithmetic operation phases that reduce a measure of depth of texture loads. The register assigning transform assigns registers to variables in such a way as to lessen the number of registers used by the shader.","Additional features and advantages of the invention will be made apparent from the following detailed description of embodiments that proceeds with reference to the accompanying drawings.","The following description is directed to a high level shader language compiler that incorporates shader code optimizing transforms to produce more optimal shaders for programmable graphics hardware. In one implementation, the shader optimizing transforms are incorporated in a compiler for Microsoft Corporation's high level shading language. Alternatively, the shader optimizing transforms can be incorporated into compilers for other high level shader languages, such as Cg (\u201cC\u201d for graphics) of NVIDIA and glslang (The OpenGL Shading Language) of 3Dlabs, Inc. Ltd.","1. General Compilation Process for High Level Shader Language","With reference to , an optimizing high level shader language compiler  (hereafter optimizing shader compiler) compiles text source files  written in a high level shader language into final code  for execution on programmable graphics hardware. The final code can be hardware-specific executable code, or can be an intermediate code form that is generic to multiple programmable graphics hardware platforms.","The optimizing shader compiler  utilizes familiar compilation techniques, including lexical analysis, syntax analysis, code generation and code optimization to translate from the high level shader language into target code. In particular, the optimizing shader compiler  includes a tokenizer , a preprocessor , a parser , a compiler , scalar transforms , vector transforms  and a back-end . The tokenizer  first reads the high level shader language text contained in the source file(s) , and performs lexical analysis of the text to separate out individual words (called tokens). This translates the high level shader language text into a tokenized version (or token stream) of the shader. The preprocessor  further reads this tokenized version of the shader, and performs macro expansions of any macros appearing in the program to build a final tokenized version of the shader.","The parser  then performs syntax analysis of the tokenized shader to recognize syntax structures of the high level shader language in the tokenized shader, and organizes the tokens into a tree representing the syntax structure of the shader. This results in a token tree representation of the shader.","The compiler  then translates the shader into a sequence of mid-level instructions. The compiler  reads the token tree representation of the shader, and generates a set of corresponding mid-level instructions. The mid-level instructions are then operated upon by two sets of transforms that seek to better optimize the shader for more efficient execution on the graphics hardware. First, a set of scalar transforms  operate on the mid-level instructions, which treat all arguments of the mid-level instructions as scalars. The scalar transforms include dead code removal, combining or removing duplicate expressions, and simplifying expressions (for example, identifying data types and operations that can be simplified to expose dead code or duplicate expressions that can be removed). These scalar transforms  are repeated in multiple passes over the mid-level instruction sequence until no further changes result.","Second, a set of vector transforms  that recognize arguments as vectors (when applicable) are applied to the mid-level instruction sequence. These vector transforms can include transforms to vectorize, remove swizzles, combine instructions and vectorize literals. The vectorize transform ensures inputs and outputs of expressions are vectorized, and may also split an expression into sub-expressions. The remove swizzles transform identifies whether a variable is always referenced in the shader with a swizzle, and if so, reorders the variable to remove the swizzle. The combine instructions transform attempts to identify separate instructions that can be combined into a single instructions. For example where there are two 2-way add instructions in the same register, the transform can combine the add instructions into a more efficient single 4-way add instruction. The vectorize literals transform assigns literals to constant registers in a compact way.","In addition, the vector transforms  include a set of shader optimizing transforms that better optimize the code to execute as a shader on programmable graphics hardware. The shader optimizing transforms seek to structure the code of the shader to the characteristics of programmable graphics hardware, for example, to better utilize the vector registers that are characteristic of GPUs. These shader optimizing transforms include a reorder transform , a phase pulling transform  and a register assigning transform , which are discussed more fully below.","Finally, the back-end  compiles the mid-level instructions to produce final code of the shader, such as in assembly code or machine code that is executable on the target graphics hardware platform.","2. Reorder Instructions Transform","With reference now to , the reorder instruction transform  () modifies the order in which instructions occur in the shader to make better use of the limited number of vector registers in programmable graphics hardware. In particular, the reorder instruction transform seeks to move instructions ahead when possible that reduce the number of registers in active use by the shader. In effect, the transform thereby minimizes the active register count of the shader (i.e., the shader can execute with fewer registers available). Where the graphics hardware provides multiple shader execution units all utilizing a set of registers, this may permit more instances of the shader to execute concurrently on the graphics hardware, or permit concurrent execution with other shaders on other execution units of the GPU.","The reorder instruction transform in the illustrated compiler  () is implemented as a process  () and recursive procedure  (). The reorder instruction transform  begins by, for each instruction in the shader (actions , ), computing (action ) a list of the instruction's parent instructions and a list of its child instructions. Parent instructions are those instructions that produce values consumed by the current instruction. Child instructions are those instructions that consume values produced by the current instruction.","The reorder instruction transform  then works backward from each output instruction of the shader (actions , ), invoking (action ) the recursive procedure  to emit all of the instruction's parents before the instruction itself is emitted. If the instruction has more than one parent, the recursive procedure  sorts between the parent instructions and first emits those parent instructions that lessen the register load. This has the effect of moving forward in the shader's execution sequence those instructions that lessen the register load as possible, so that the shader's overall active register count is reduced.","More particularly, the recursive emit instruction procedure  first determines (actions , ) whether the current instruction has no parents, has one parent, or has multiple parents. In the case where the instruction has multiple parents, the recursive emit instruction procedure  employs a heuristic to decide a sort order in which to emit the parent instructions. In one implementation, the heuristic involves calculating (action ) a register load metric of each of the instruction's parents to measure which instruction may better reduce the active register load. The metric generally represents the number of registers that the instruction requires to be active from above the instruction versus the number of registers required to be active following the instruction, or in other words the effect the instruction has on the shader's register load. The metric takes into consideration various characteristics of the parent instruction, i.e., how many values emitting the parent will consume (which lessens the register load), how many values emitting the parent will produce (increases the register load), and how many instructions it will take to emit the parent.","More particularly, the procedure  calculates the register load metric of each parent of the current instruction by identifying a sub-graph of the instructions in the shader, which sub-graph contains the respective parent instruction and all the parent's ancestors which have not yet been emitted (conceptually, \u201ccoloring\u201d a sub-graph containing the parent and its ancestors). The procedure  then counts the number of reads made from inside this sub-graph to outside (\u201cNumReadsFromInside\u201d), and vice versa (NumReadsFromOutside). The metric is then calculated as the difference between these numbers, divided by the number of instructions in the sub-graph, as follows:",{"@attributes":{"id":"p-0036","num":"0035"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["M","RL"]},"mo":"=","mfrac":{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["R","I"]},{"mi":["R","O"]}],"mo":"-"}},"mi":"I"}}}},"br":{},"sub":["RL ","I ","O "]},"At action , the recursive emit instruction procedure  then sorts the parent instructions in order of which of the parent instructions better reduces the register load according to the calculated metric. At action , the recursive emit instruction procedure  is invoked for the parent instructions according to this sort order, so that the sub-tree of the parent instruction that better reduces the register load is emitted first. After returning from the recursive emit instruction procedure invocations on the parent instructions, the current instruction is emitted at action .","In the case that the current instruction has but a single parent (actions , ), the recursive emit instruction procedure  is invoked for the single parent instruction at action . After which, the current instruction is emitted at action .","In the case that the instruction for the current invocation of the recursive emit instruction procedure  has no parents, the current instruction is simply emitted at action .","3. Phase Pulling Transform","With reference to , the phase pulling transform  () is an attempt to organize the shader into \u201cphases,\u201d which consist of sets of non-interdependent texture load instructions alternating with sets of arithmetic instructions on the loaded textures. The texture load instructions in any one phase are not dependent on each other. This organization of the shader's instructions into phases helps satisfy dependent texture read limitations. The phase pulling transform has the effect of packing the shader's instructions into a more minimal number of phases or blocks.","In a first part , the phase pulling transform  first calculates the \u201cdependent depth\u201d of every instruction in the shader. As indicated in actions , , the phase pulling transform begins from the end of the shader program, and works backward. Each parent instruction is assigned (action ) a dependent depth that is at least one higher than any of its children (i.e., a maximum of the dependent depths of the instruction's children plus one). Further, if the parent is a texture load instruction while the child (with the maximum dependent depth of the children) is an arithmetic instruction (or vice versa) at actions , , the parent's dependent depth is increased by an additional increment at action . If both parent and this maximum dependent depth child are texture load instructions (action ), then the parent's dependent depth is increased by two at action  (so as to reflect an \u201cempty\u201d phase with no arithmetic instructions).","In a second part , the phase pulling transform  performs a series of passes over the shader, alternating moving lower dependent depth instructions toward the end of the shader and moving higher dependent depth instructions toward the beginning of the shader, subject to certain constraints. This effect is analogous to a centrifuge in that lower dependent depth instructions fall, while higher dependent depth instructions rise in the shader.","In particular, the phase pulling transform in actions - moves instructions with lower dependent depth downward in the shader. This downward moving pass begins at the top of the shader (action ). The phase pulling transform examines the instructions in turn. If the dependent depth of the current instruction is less than or equal to that of the next instruction (action ) and moving the current instruction down would not cause the number of registers used by the shader to exceed a maximum (action ), then the instruction is moved down past the next instruction.","Then, in an upward moving pass in actions -, the phase pulling transform moves instructions with higher dependent depth upward in the shader. The phase pulling transform examines the instructions in order from the bottom of the shader (action ). If both the current instruction's dependent depth is greater or equal to the next instruction (action ) and an upward move would not cause the shader to exceed the maximum number of registers in use (action ), then the phase pulling transform moves the current instruction up past the next instruction at action .","The phase pulling transform continues to alternate the upward moving pass (actions -) and downward moving pass (actions -) until no further moves are possible (action ).","4. Register Assignment Transform","With reference now to , the register assigning transform  attempts to solve a problem of packing instruction operands into a finite number of graphics processor registers. As summarized above, current programmable GPUs typically provide a finite number of multi-component vector registers that can be assigned by texture load instructions to pull vector values from a texture in graphics memory. For example, a GPU may have registers that hold 4-component values, labeled x, y, z and w. On the other hand, the instruction operands may be arrays of scalars or vectors having 1, 2, 3 or 4 component values. Further, certain sizes of operands (in component number) have preferred placements in the registers. In some programmable GPUs, the GPU is structured so that arithmetic instructions on scalar (single-value) operands operate more efficiently when the value is stored as the w-component of a register, whereas arithmetic on 3-component vector operands are more efficiently executed with the values stored in the x, y and z components of the register. However, assigning a register to store a scalar value prevents its use for storing a 4-component vector operand, and leaves 3 components of the register unused. Further, the values have different lifetimes (durations of occupation of the register), depending on when they are first written and last read in the shader.","The register assigning transform  achieves a more efficient utilization of the registers by weighing assigning operands among available registers according to a set of factors. The factors include the preferred component location for the size of the operand, avoiding partially full registers, and how closely in time the lifetimes of all operands in the register will expire (having operands become free as closely in time as possible tends toward maximizing the number of free registers).","More particularly, the register assigning transform  executes process  when assigning the register location for an instruction operand. In process , the register assigning transform  first calculates a weighted score for each available register assignment for the operand in actions -. In calculating this weighted score, the register assigning transform  weights (action ) the score against register assignments where the operand would be in other than a preferred component location according to the operand's component size (e.g., the w-component for scalar operands, or x, y and z components for 3-component vector operands). Additionally, the register assigning transform  weights (action ) against register assignments that would leave components of the assigned register unused. Further, the register assigning transform weights against register assignments where operands in a register have divergent ends of lifetime, i.e., the component locations of the register become free at divergent times.","In one implementation, the weighted score is computed using the following expression: (SumOfComponentDistancesFromDesired <<24)|(NumberOfComponentsLeftOver <<16)|(SumOfDistancesBetweenReadMax), where \u201c<<\u201d is a left shift operator and \u201c|\u201d is a bit-wise OR operator as per C-programming language notation. The value, \u201cSumOfComponentDistancesFromDesired,\u201d is the distance from the preferred component location for the operand. For example, assigning a scalar operand to the z-component location of a register is one distant from the preferred assignment of scalars to the w-component location, whereas assignment to an x-component location of a register would be three distant from the operand's preferred component location. The value, \u201cNumberOfComponentsLeftOver,\u201d is the number of components left unused by the assignment. For example, assigning a scalar component to the w-component location of an empty register would leave three components unoccupied. However, assigning a scalar component to a register already having a 2-component operand occupying its x- and y-component locations would leave only one component location unoccupied. The value, \u201cSumOfDistancesBetweenReadMax,\u201d is the distance between read instructions that read operands from the register (thus freeing the component locations occupied by the operands). For example, assigning a 2-component operand to a register already occupied by another 2-component operand, where the read instructions that consume the operands are 21 instructions apart in the shader, would have a maximum distance between reads of 21. In this implementation of the weighted score calculation, the register assignment having the lower score is the winning register assignment.","The register assigning transform  further considers whether the instruction whose operand is being assigned is a move (MOV) instruction. For most instructions (non-move instructions), the register assigning transform  assigns the registers in least-recently used order (action ). The register assigning transform  assigns operands of move instructions in most-recently used order (action ). This is because a move instruction between the same source and destination register locations would be a no-operation instruction that can be omitted from the shader.","5. Computing Environment","The above described software development tool  () and macro processing and display techniques can be implemented on any of a variety of computing devices and environments, including computers of various form factors (personal, workstation, server, handheld, laptop, tablet, or other mobile), distributed computing networks, and Web services, as a few general examples. The high level shader language compiler  () incorporating the above-described shader optimizing transforms can be implemented in hardware circuitry, as well as in compiler software  executing within a computer or other computing environment, such as shown in .",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 7","b":["700","700"]},"With reference to , the computing environment  includes at least one processing unit  and memory . In , this most basic configuration  is included within a dashed line. The processing unit  executes computer-executable instructions and may be a real or a virtual processor. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power. The memory  may be volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory, etc.), or some combination of the two. The memory  stores software  implementing the high level shader language compiler  with shader optimizing transforms.","A computing environment may have additional features. For example, the computing environment  includes storage , one or more input devices , one or more output devices , and one or more communication connections . An interconnection mechanism (not shown) such as a bus, controller, or network interconnects the components of the computing environment . Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment , and coordinates activities of the components of the computing environment .","The storage  may be removable or non-removable, and includes magnetic disks, magnetic tapes or cassettes, CD-ROMs, CD-RWs, DVDs, or any other medium which can be used to store information and which can be accessed within the computing environment . The storage  stores instructions for the device connectivity and networking software .","The input device(s)  (e.g., for devices operating as a control point in the device connectivity architecture ) may be a touch input device such as a keyboard, mouse, pen, or trackball, a voice input device, a scanning device, or another device that provides input to the computing environment . For audio, the input device(s)  may be a sound card or similar device that accepts audio input in analog or digital form, or a CD-ROM reader that provides audio samples to the computing environment. The output device(s)  may be a display, printer, speaker, CD-writer, or another device that provides output from the computing environment . The output devices  can include a graphics adapter with a programmable GPU on which the shader is to execute, or alternatively the processing unit  may include graphics instructions for executing shaders. However, the computing environment  need not include the graphics processor on which the shader is to execute, and instead may simply compile the shader for execution on graphics processors of other computers or computing environments.","The communication connection(s)  enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer-executable instructions, audio\/video or other media information, or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired or wireless techniques implemented with an electrical, optical, RF, infrared, acoustic, or other carrier.","The high level shader language compiler herein can be described in the general context of computer-readable media. Computer-readable media are any available media that can be accessed within a computing environment. By way of example, and not limitation, with the computing environment , computer-readable media include memory , storage , communication media, and combinations of any of the above.","The techniques herein can be described in the general context of computer-executable instructions, such as those included in program modules, being executed in a computing environment on a target real or virtual processor. Generally, program modules include routines, programs, libraries, objects, classes, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer-executable instructions for program modules may be executed within a local or distributed computing environment.","For the sake of presentation, the detailed description uses terms like \u201cdetermine,\u201d \u201cgenerate,\u201d \u201cadjust,\u201d and \u201capply\u201d to describe computer operations in a computing environment. These terms are high-level abstractions for operations performed by a computer, and should not be confused with acts performed by a human being. The actual computer operations corresponding to these terms vary depending on implementation.","In view of the many possible embodiments to which the principles of our invention may be applied, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIGS. 4 and 5","FIG. 1"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 6","FIG. 1"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 7","FIG. 1"]}]},"DETDESC":[{},{}]}
