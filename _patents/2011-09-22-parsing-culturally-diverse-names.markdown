---
title: Parsing culturally diverse names
abstract: Provided are techniques for parsing a name. A name to be parsed is received. A culture of the name is identified. One or more name phrases from the name are identified. Statistics for the one or more name phrases are identified. It is determined whether to perform a first parsing technique that parses different types of name elements within at least one field of the name. In response to determining that the first parsing technique is to be performed, the name is parsed using the statistics and the first parsing technique. In response to determining that the first parsing technique is not to be performed, the name is parsed using the statistics and a second parsing technique.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08855998&OS=08855998&RS=08855998
owner: International Business Machines Corporation
number: 08855998
owner_city: Armonk
owner_country: US
publication_date: 20110922
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","COPYRIGHT","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Additional Embodiment Details"],"p":["This application is a continuation-in-part application and claims the benefit of U.S. Pat. No. 8,041,560, having U.S. application Ser. No. 12\/197,119, filed Aug. 22, 2008, which is a continuation of U.S. application SER. No. 10\/055,178, filed Jan. 25, 2002, now abandoned which is a continuation of and claims the benefit of U.S. Pat. No. 6,963,871, having U.S. application Ser. No. 09\/275,766, filed Mar. 25, 1999, which is a non-provisional of and claims the benefit of U.S. Provisional Patent Application No. 60\/079,233, filed Mar. 25, 1998, and the entire contents of each of these applications is incorporated herein by reference.","A portion of this disclosure contains material in which copyright is claimed by the applicant and\/or others. The copyright owner has no objection to the copying of this material in the course of making copies of the application file or any patents that may issue on the application, but all other rights whatsoever in the copyrighted material are reserved.","Embodiments of the invention relate to processing names in general, including parsing personal names that are representative of multiple cultures.","Also, embodiments of the invention relate generally to automatic data processing systems that search and retrieve records from a database based on matching of personal names, and to improved systems and methods for intelligently processing name comparisons.","Information about individuals is often stored in a computer. Access to that information is most readily gained by using the name of the individual involved. The nature of names, however, their behavior and permutations, pose significant challenges to information retrieval. Names vary during one's life (e.g., through marriage or professional preparation); they take on different forms, depending on the formality of the situation (WILLIAM CARVER\/BILLY CARVER); they may be spelled differently if recorded by someone other than the individual (PRICE PRIES). To amplify the difficulties even more, naming conventions vary across cultures. It may not be appropriate to assume that the typical American name structure of single given name (first name), single middle name or initial followed by a surname (last name) applies in a database that contains names from all over the world, a situation that is usual in today's world of global technology and communication. Names from other cultures may have compound surnames or may be composed of only one name. Names written in writing systems other than Roman may be transcribed in a variety ways into the Roman alphabet because there is no single way to represent sounds that occur in another language but do not occur in English, causing significant differences in the spelling (KIM\/GHIM).","Adequate information retrieval that is based on the name must anticipate the range and kinds of variation that can occur in names, both generally and in specific cultures. Other name search or information retrieval systems are generally unable to recognize or address the full range of variation in names. Some systems assume that names are static and search only for an exact match on the name. These systems cannot accommodate even the slightest spelling variations, initials or abbreviations (JOS. Z. BROWN\/JOSEPH ZACHARY BROWNE). Other systems may use techniques or keys (such as Soundex or Soundex-like keys) that permit some minor spelling differences between names (DORSHER\/DOERSHER) but these techniques generally fail to cope with significant variation (DOERSHER\/DOESHER) or problems posed by names from non-Anglo cultures (ABDEL RAHMAN\/ABDURRAMAN). If cultural differences are recognized, it is typically through use of equivalency lists or tables. Some of the more common variants can be accommodated in this way, but retrieval is then limited to those items on the list and cannot accommodate new representations or random variation or keying errors (GOMEZ\/BOMEZ).","For a system to reach a level of adequacy for automatic name searching, it must therefore address a diverse set of issues related to name variation. Although spelling variations can often be addressed through character-matching techniques (e.g., SMITH\/SMYTH), false-positive matches can result from traditional string or character comparisons when common morphological endings, such as OVICH, occur at the end of otherwise dissimilar names (e.g., ZELENOVICH\/JOVANOVICH). Transcription from foreign writing systems to the Roman writing system poses additional spelling concerns. Different character sets, dialectal variations and sounds that are not represented in Roman alphabetic form at all contribute to the possibility of multiple, and often inconsistent, representations of the same name. A single Chinese character (ideogram) can be transcribed to produce numerous roman forms that have little or no resemblance to one another due to dialectal variations. For example, the character CHANG, JANG and ZHANG are different roman representations of the exact same Chinese name, as are the names WU, MHO and ENG. Similarly, a single Arabic name can result in transcriptions as diverse as KHADHAFI, CODOFFI, QATHAFI.","Character-based systems may also be confronted with significant retrieval problems caused by names with the same pronunciation but with divergent spellings. WOOSTER, WORCHESTER, and WUSTER may all share at least one identical pronunciation and yet show very different spellings. When name data are shared orally, the speaker's pronunciation, the listener's hearing (or mishearing) of the name and the speaker's expectations about the spelling of the name will impact the final written representation of a name. For example, a telephone reservationist may record a caller's name with a variety of phonetically correct spellings, which may not correspond (and may therefore not be matched to) an existing database record for that caller.","Another common cause of name variation, which creates retrieval difficulty for name search systems, is the inclusion or exclusion of name data. Depending on the data source, names may be formal such as THOMAS EDWARD WINTHROP III, or informal such as TOM WINTHROP. An ideal name search system would be capable of correlating these two names, even though only a portion of the full name is available. To predict the relationship among variant formats of names, the system must also be able to recognize what rules govern which elements can be deleted or included or changed in different cultures. MARIA DEL CARMEN BUSTOS SAENZ will become MARIA DEL CARMEN BUSTOS DE LOPEZ, if she marries JUAN ANTONIO LOPEZ GARCIA. Predicting the relationship between these names is fundamental to retrieval success.","In many name search applications, it is important to identify variant forms of a name that are considered legitimate and to link and preserve the variations; in others, it may be appropriate to establish one form of a name and to treat all other forms as errors. Even if the data base is cleaned by linking variant forms and eliminating identifiable errors, users may search for names under yet more variations.","U.S. Pat. No. 5,040,218 to Vitale et al. discloses a voice synthesis system which attempts to identify the origin of a name to enhance pronunciation. The system first searches a dictionary for a name, and if the name is not found, uses grapheme and n-gram analysis to identify the name's likely origin. Similarly, U.S. Pat. No. 5,062,143 to Schmitt shows a system that identifies name origin using n-gram analysis.","U.S. Pat. No. 5,724,481 to Garberg et al. shows a method of matching proper names in a database using a phonemic representation.","U.S. Pat. No. 5,758,314 to McKenna shows an international database processing system. However, this system uses Soundex algorithms to process Unicode input for all cases, rather than providing a name searching system with culture-specific algorithms.","Design Pat. D359,480 shows an IPA-based computer keyboard, but does not disclose any use of IPA for identifying data records.","The article \u201cIdentifying Source Languages: the Case of Proper Names\u201d by Valencia and Yvon (1997) discloses statistical models for name searching based on n-gram comparisons. The article also discloses determination of the source language and the use of different statistical models for comparisons, based on the source language.","John Hermansen, a named inventor, authored a doctoral dissertation, \u201cAutomatic Name Searching in Large Data Bases of International Names\u201d (1985) which explores the concept of cultural differences in names. The document suggests searching using different culturally specific algorithms, but discloses only a simple n-gram based algorithm.","The assignee has developed a software program known as PC-NAS. An early version of this program was incorporated into a government computer system more than one year before the priority date of this application. This early version performed name searching using a combination of n-gram distribution and positional properties, and included a limited name regularization algorithm as part of an Arabic processing algorithm. Its architecture included sets of algorithms applicable to different cultures, but no automatic classification of the cultural origin of a name.","U.S. Pat. No. 5,485,373 to Davis et al. discloses a text searching system which relies on a Unicode representation (not a phonetic alphabet). The Davis system may vary algorithms based on the language being searched, but has no name classifier. This system is not designed to search for proper names; comparisons are performed based on a Unicode representation, which is not a phonetic alphabet.","Other patents relating generally to computerized language analysis and processing include: U.S. Pat. No. 5,323,316 to Kadashevich et al.; U.S. Pat. No. 5,337,232 to Sakai et al.; U.S. Pat. No. 5,369,726 to Kroeker et al.; U.S. Pat. No. 5,369,727 to Nomura et al.; U.S. Pat. No. 5,371,676 to Heemels et al.; U.S. Pat. Nos. 5,375,176 and 5,425,110 to Spitz; U.S. Pat. No. 5,377,280 to Nakayama; U.S. Pat. No. 5,432,948 to Davis et al.; U.S. Pat. No. 5,434,777 to Luciw; U.S. Pat. No. 5,440,663 to Moese et al.; U.S. Pat. No. 5,457,770 to Miyazawa; U.S. Pat. No. 5,490,061 to Tolin et al.; U.S. Pat. No. 5,515,475 to Gupta et al.; U.S. Pat. No. 5,526,463 to Gillick et al.; and U.S. Pat. No. 5,548,507 to Martino et al.","None of these earlier systems provide a satisfactory system and method for multicultural name searching. Thus, the inventors believe there is a need for an improved system and method for searching name-based records and for determining the degree of similarity between two name representations.","Culturally diverse names may be parsed differently, despite having similar syntactic characteristics. For example, in an English name that includes three tokens, the first two tokens typically represent given names, and the last token typically represents a surname. However, in names of other ethnicities, the middle token may represent a qualifier for the last token, so the first token may represent a given name, and the last two tokens may collectively represent a single surname. As another example, a given name typically precedes a surname in an English name, while a surname typically precedes a given name in an Asian name. For these and other reasons, parsing a group of names correctly and consistently can be difficult, particularly when names within the group represent multiple cultures.","Provided are a method, computer program product, and system for parsing a name. A name to be parsed is received. A culture of the name is identified. One or more name phrases from the name are identified. Statistics for the one or more name phrases are identified. It is determined whether to perform a first parsing technique that parses different types of name elements within at least one field of the name. In response to determining that the first parsing technique is to be performed, the name is parsed using the statistics and the first parsing technique. In response to determining that the first parsing technique is not to be performed, the name is parsed using the statistics and a second parsing technique.","In the following description, reference is made to the accompanying drawings which form a part hereof and which illustrate several embodiments of the invention. It is understood that other embodiments may be utilized and structural and operational changes may be made without departing from the scope of the invention.","It is a general object of the present invention to provide a name searching system architecture with multiple processing options, which automatically selects and uses an appropriate cultural-specific set of algorithms to search for database names and evaluate their proximity to a query name.","Another broad object of the invention is to provide a system and method implementing multi-algorithm name searching strategies, where search processing differs based on one or more of: culture, ethnicity, distribution, and language.","Another more specific object of the invention is to provide an improved system and method for conducting searches using a combination of n-gram distribution and positional properties to identify matches.","A further object of the invention is to provide an improved cultural name classifier which leads to application of an appropriate set of name-regularizing linguistic rules that generate a standardized name based on stored cultural intelligence.","Yet another object of the invention is to provide an improved name classifier, incorporating a multi-step process, including preemptive lists, linguistic rules, n-gram analysis, and additional algorithms.","A further object of the invention is to provide an improved name searching system, incorporating segment-level pre-processing. Segmentation rules and syllabic stress rules contribute to a determination of where \u201cwhite space\u201d should appear in the name. Algorithms determine which graphemes are mapped to which phonemes (based on phonological, historical, and morphological principles).","Another significant object of the invention is to provide a name searching system and method incorporating an innovative key-searching system based on the International Phonetic Alphabet (IPA). This technique converts the query name to a plurality of IPA representations, which are then used to select matching keys in a first pass through the database.","A further object of the invention is to provide a name searching system and method that selectively uses sets of generic and language-specific spelling rules to infer possible phonological manifestations for personal names. A unique aspect of the comparison algorithm derives a scored match based on atomic phonological features.","Additional objects and advantages of the invention will be apparent upon review of the specification, including its drawings and appendices A-N.","The present invention provides an improved automatic data processing system for searching names and an improved process for effectively searching and retrieving personal names in a database. It also provides a mechanism for a user to determine the distance between two names, i.e., how closely two personal names match.","In one aspect of the invention, \u201cfuzzy logic\u201d name searching and matching technology is provided to locate a target database record despite a lack of absolute identity between a query name and a record name.","In one embodiment, a complete automated name searching system is provided, incorporating various advantageous features of the present invention. The automated search system incorporates an automatic name classifier, a multi-path architecture in which different algorithms are applied based on cultural identity of the name, name variant generation, query regularization and expansion, compensation for transpositions, affixes, and inversions, and sorting and filtering of output. The name classifier incorporates a preemptive list, analysis of morphological elements, length, and linguistic rules. The name regularizer produces a computer recognized form (character based computational representation) rather than a human recognizable form of the name. The software design uses a pronunciation equivalent (e.g. IPA) representation and language specific rules to generate name searching keys, which are used in a first pass to eliminate database entries which are obviously not matches for the name of interest.","In another embodiment, the inventive search methodologies are implemented as Application Program Interfaces (APIs) that can be integrated into an existing program application or can be used to provide the foundation for a new program application that requires name matching capabilities. In API form, the features of the present invention may be selectively used in various combinations is depending on the requirements of the particular application. A callable set of library routines include an intelligent preprocessor and a name evaluator that produces a score comparing a query name and database name, based on a variety of user-adjustable parameters. The user-controlled parameters permit tuning of the search methodologies for specific custom applications, so as to achieve desired levels of precision and recall for name searching in widely varying operational settings.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIGS. 1A and 1B","b":["100","100","100","100"]},"Referring now to , system  comprises name classifier module , variant generation module , name reference library , name retrieval technology processing module , retrieval module , and precision filter and sorting module . System  has an input query  and an output .","Processing of a query begins with evaluation of the searched name by name classifier module . Name classifier module  evaluates spelling, word segmentation, titles, prefixes and suffixes, and other identifiable features of the name to determine whether it falls into one of a predetermined set of identified cultural origins, including, for example, Chinese, Arabic, Hispanic, or Russian. Anglo names and names which do not fall into one of the predetermined set of special-case cultures are classified as \u201cother\u201d and processed according to a generic cultural algorithm. Appropriate pre-processing is also performed to segment the name appropriately (standardize the handling of spacing between name segments and the order of the segments) and identify apparent surnames, given names, honorifics, etc., that are part of the input name. The operation of the name classifier in this regard is unique and inventive. To determine the type of name, name classifier module  may use one or more of the following, depending on the observed characteristics of the name in question: a list of names which occur with high frequency in various cultures (used to preemptively type common names without extensive algorithmic processing), culture-specific linguistic rules in the form of a Titles, Affixes, and Qualifiers (TAQ) lookup table, n-gram based name typing, and name length. N-gram name typing according to the present invention may be performed as a digraph, trigraph or other n-gram analysis where both positional and distributional properties of the n-grams (e.g., digraphs and trigraphs) are used in the algorithm for making the type determination. Name classifier module  preferably operates according to the software design description in Appendix A, which forms a part of this specification.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 3","b":["102","102","302","304","306","309","306","312","314"]},"LID processor  incorporates linguistic information aggregator  and LID intermediate decision processor . LID aggregator  includes high frequency name processor , morphological processor , title\/affix\/qualifier (TAQ) processor , and ngram processor .","LID processor  accumulates and weighs factors from multiple knowledge sources to determine whether there is sufficient evidence to identify the input name as belonging to a particular ethnicity, e.g. Hispanic, Arabic, etc. Linguistic information aggregator  performs linguistic analysis, gathering information and scoring for the input name. In embodiments, linguistic information aggregator  generates scores from four data sources. High frequency name processor  accesses a high frequency name data store of names that occur frequently in particular cultures. A match with one of these names causes aggregator  to retrieve and record the culture associated with the name and a confidence score associated with that name. TAQ processor  breaks the name into particles and makes use of the information contained in those particles to match a list of titles, affixes, and qualifiers commonly used in names of various cultures, to help determine cultural affinity. The input name is segmented based on spaces in the name, and for each segment present in the input name, TAQ processor  determines whether that segment is a particle present in a TAQ data store. If so, TAQ processor  retrieves and records the culture, name field, and confidence score associated with that TAQ particle.","Morphological processor  processes morphological elements such as \u201c-ovich\u201d which suggest a particular cultural affinity. Morphological processor  determines whether morphemes in a morpheme data store are present in the input name by searching for matching substrings of the name segments in the input name. For each morpheme found in the input name, morphological processor  records the morpheme found, the culture, name field, and confidence level associated with that morpheme.","N-gram processor  searches the input name for strings of letters that occur with statistical significance in names with a given cultural affinity. For each n-gram present in an associated n-gram data store, n-gram processor  determines whether that n-gram is present in the input name. When a match is found, the processor records the n-gram found, the culture, name field, and score associated with that n-gram.","To avoid conflict between treatment of name segments and particles by the various processing modules operating on the input name, an order of precedence is established for processing. The order of precedence is preferably TAQ particle, morpheme, and then n-gram. That is, if a string of letters is identified as a TAQ particle, that string or any substring cannot also be identified as a morpheme or n-gram for that culture. If a string is identified as a morpheme, that string and its substrings cannot be considered as part of an n-gram for that culture. Locating the name among the high frequency names for a culture does not preclude morpheme or n-grams processing of the high frequency name, but if the confidence level in the high frequency match is high, further processing may not be necessary.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 4","FIG. 3","FIG. 5"],"b":["304","308","402","106","308","316","318","320","322"]},"As shown in , processed information from linguistic information aggregator  passes to LID intermediate decision processor , where it is processed and the results passed to digraph distribution processor  or to final decision processor  (shown in ).","LID intermediate decision processor  makes a preliminary decision about the cultural affinity of the name, based on the scoring information gathered by linguistic information aggregator . Processor  determines whether enough linguistic information has been gathered by LIA  to confidently determine that the input name belongs to one of the cultures identified by the system. Processor  accepts as input one aggregate LID score for each culture, as well as an aggregate LID score for \u201cother.\u201d For each score, processor  compares the score to a LID threshold for the appropriate culture. If the LID score for a culture exceeds the threshold for that culture, processor  returns a value of \u201ctrue\u201d for the indicated culture. A \u201ctrue\u201d value for a culture indicates that enough evidence has been gathered to confidently identify the name as belonging to that culture. A \u201cfalse\u201d value for a culture indicates that not enough evidence has been accumulated to suggest that the name belongs to that culture. Alternatively, processor  may return a value for each culture equal to the LID score minus the LID threshold for that culture; in this case, negative values correspond to \u201cfalse\u201d and positive values correspond to a \u201ctrue\u201d indication.","Names which are strongly associated with one culture based on the output of LID intermediate decision processor  will not be processed further to identify their cultural origin, i.e. digraph and other analysis will be skipped.","Assuming the name has not been definitely identified, the surname portion is processed by digraph distribution processor . Based on a statistical model derived from digraph distribution statistics for names within various cultures, processor  computes a likelihood that the input name has a particular cultural origin. The information gathered from LID and digraph processing is combined, along with any other available information on the person (such as country of birth), in final decision processor . The available factors are weighted according to their confidence level to maximize the likelihood of an accurate ethnic origin evaluation. The result is an output indicating the likely classification of the name.","Following name typing, the system executes name variant generation module , which pre-processes the names according to culture-specific rules to generate query regularizations, based on algorithms adapted specifically for the cultural origin of the name in question, as determined by the name classifier. Variant generation module  also generates query expansions, i.e., identifies expected variants of the name to enhance matching capability.","As noted above, preferably, specialized processing is provided for each of a variety of ethnic name origins. Appendices B and C, which form a part of this specification, are software design descriptions for preprocessing and search algorithms for Arabic and Hispanic type names, respectively. As an example of such processing, the Hispanic processing algorithm referenced in Appendix C will now be discussed in some detail.  is a flowchart showing Hispanic name processing used in accordance with certain embodiments. The process begins in name classification in block  when the input name is identified as an Hispanic name. The name is then fed to Hispanic name preprocessor in block , and to the Hispanic search engine in block , which searches database . Then, an Hispanic sorter and filter are applied in block . The process produces sorted Hispanic search results as an output in block .",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 7","FIG. 6"],"b":"604"},"The process begins with a name length determiner operation on Block , which determines the length of the surname. Next, the name is processed by a Hispanic surname segmenter in block . This operation divides surnames exceeding a predetermined length (e.g. nine characters) into component segments to compensate for the fact that fixed size data fields often do not accommodate an entire Hispanic surname, leading data entry operators to conjoin name segments in a single field. Then, additional query records are generated for the separated segments and alias records are added for the separated surname segments. This process accesses a high frequency surname type data store to identify surname portions that should be separated. For example, this operation would separate \u201cRAMIREZDELAPAZ\u201d in the surname field into RAMIREZ DELA PAZ and \u201cPEREZDELOPEZ\u201d into PEREZ DE LOPEZ by finding the known surname components DE and DELA.","An Hispanic TAQ processor operates in Block  to scan the given name and surname for known titles, affixes, and qualifiers which do not have useful search value. TAQ elements such as DEL, DELA, DE, and SAN are then flagged to be either deleted, disregarded during matching operations, or removed. Delete means that the segment is disregarded for the remainder of the name search process and contributes marginal information to the filter process, but is not actually removed from the record. Disregard means the segment is disregarded in the remainder of the name search process but contributes to evaluation in the filter process. Remove means that a segment conjoined to the name stem is removed from the stem, and then flagged to be either deleted or disregarded as appropriate.","The Hispanic segment positioner in Block  operates to move any high frequency surname found in the given name field into the surname field. The name is then formatted by a Hispanic name formatter in Block  to generate additional name formats in case the record has more than two surname stems. Next, the name is processed by a segment position identifier in Block  to identify the relative position of each of the surname and given name stems. Hispanic names generally contain more than one stem in the given name and surname. In a given name, the leftmost name stem generally indicates gender; in a surname, the leftmost stem is the family name and the other stems are differentiators. Therefore, it is important to identify names that are out of position so that this may be corrected and their relevance appropriately evaluated during the search.","Next, the likely gender of the name is identified by a Hispanic gender identifier in Block . The gender identifier attempts to predict gender based on the gender marker of the leftmost given name segment, but may also rely on (or override the apparent gender) based on additional information such as a gender indicated as associated with the search name.","The name is processed by a frequency path director in Block  which directs a record for high frequency processing or low frequency processing depending on the presence or absence of high frequency surnames in the input name string.","In , the flow of operation of the Hispanic search engine  is shown in more detail in accordance with certain embodiments. As described above, the frequency path director operates in block  and then determines in block  whether the surname contains all high frequency segments. If so, control passes to the high frequency processor in block . If not, control passes to the low frequency processor in block .","The high frequency processor operation begins in Block  with generation of keys for the given names. Then, in block , records are retrieved according to a high frequency surname matrix and the given name keys. Control then passes to filter and sorter  (shown in ).","Low frequency processor operation begins in Block  where each low frequency surname segment is examined to identify related high frequency and low frequency surnames, in blocks  and . This processing loop continues until names related to the segments have been identified. A \u201crelationship\u201d to a high frequency surname is determined by digraph comparison. If the number of identical digraphs exceeds a specified threshold, the surname is deemed to be a mere spelling variant of the similar high frequency surname. If the surnames all relate to known high frequency names, control passes through block  to block  in the high frequency processor. If the surnames have mixed high and low frequency relationships, control passes through block  to block . If all surnames have low frequency, control passes through block  to block . In block , a year of birth range is determined for the name. Records are then retrieved based on name content (same or different), position of the name segments, the year of birth range, the record gender, and possibly additional restrictions based on the given name.","Referring again to , the typing and processing of names within the system is preferably informed by cultural information encoded in a name reference library . The factors included in name reference library  are identified in the database structures shown in Appendix D, which forms a part of this specification. Appendix E, which also forms a part of this specification, provides additional flowcharts and software descriptions for a preferred embodiment of name classifier module  and the Hispanic name search algorithms.","Significantly, as part of name regularization for the purpose of generating an index key for a first pass through the database, the present invention applies the International Phonetic Alphabet to generate index keys, rather than using a Soundex or another conventional key. The IPA algorithm, according to the present invention, generates keys by segmenting (e.g. syllabifying) the name in question and converting it to IPA representation. In this manner, the system generates a key or set of keys which identify a set of pronounced equivalents, rather than generating a key by letter similarity, as in the traditional Soundex method. Significantly, the system generates multiple keys in IPA representation for most names, since most names have multiple possible pronunciations. The system determines multiple possible pronunciations of the name, where applicable, and associates an IPA key with each possible pronunciation. Then, records matching any of the IPA keys for a name are then selected for further consideration and comparison.","To program the IPA conversion, a rule set is generated that relates spelling to sounds. A different rule set is preferably generated for each ethnic origin of name, since pronunciations of apparently similar names may vary significantly based on origin. To generate a rule set, preferably a database of single name elements is obtained, such as a census list. The names in the list may are then manually tagged for their ethnic origin A variety of sources may then be used to determine possible pronunciations. These sources include native speaker knowledge and textual information. The rules are written broadly so that the most plausible pronunciations will be captured with some certainty. Rules for languages not written in roman characters will necessarily take into account transcription variations. The rules are written in a predetermined notation which can be processed effectively by the system. A typical rule format is:\n\n","As an example of the advantages of matching on IPA, consider a query on the name Lee. Converted to the IPA string [li], exact matches with numerous spelling variants are automatic, including Leigh and Li. Typical prior-art character based matches will fail to retrieve Leigh or Li, since the percentage of character overlap is minimal. Conversely, a standard index matching system such as Soundex will categorize Lee and Li identically, but will still miss Leigh, given the presence of a salient letter (g), and will retrieve a large number of names of low relevance, including Lu, Liao, Low, Louie, Lahoya, and Lehew. The IPA analysis process is further described in Appendix F, which forms a part of this specification.","While the IPA key generation, according to the present invention, provides a significant functional advantage in many cases, it should be noted that it may not be desirable to apply IPA processing to all classes of names. For example, the inventors have found that names of Arabic and Chinese origin are better processed using custom regularization algorithms rather than by the generalized IPA approach, since names acknowledged as similar in these cultures are often quite distinct phonologically.","Following regularization and expansion, name retrieval technology processing module  is applied. These algorithms facilitate more complete retrieval, by compensating for transpositions; deleting affixes, where appropriate; and compensating for inverted surnames, deleted surnames and nicknames. Each of these algorithms uses stored information defining naming conventions for a particular culture in the manner described herein.","Next, retrieval module  is applied to the results of the preprocessing performed by name classifier , variant generation module , and retrieval technology module . Retrieval module  retrieves records matching the keys (IPA or other culture-specific keys) generated by the operation of the first three modules. These records are then provided to precision filter and sorting module , which compares each record to the query name to determine a similarity\/equivalence measurement defining the \u201cdistance\u201d between the query name and the record name. Precision filter and sorting module  may perform segment position comparisons, character comparisons, phonological similarity comparisons, structural similarity comparisons, phono-feature-distance comparisons, and\/or n-gram comparisons.","The output  of precision filter and sorting module  is then provided to the user. The output preferably consists of a rank-ordered list of records in descending order of likelihood of matching the query name.","One embodiment implementing many desirable features of the system shown in  is a standalone database search and retrieval program. In addition to including the features described above (and in further detail in the Appendices), this embodiment of the invention may preferably be implemented according to the disclosure in Appendices G, H, I, and J, which form a part of this specification and are: a narrative description, technical plan, acceptance test, and source code listing respectively for a system demonstrating numerous features of the present invention.","Another desirable embodiment of the invention is as a set of name searching tools which may be provided as one or more Application Programming Interfaces (APIs) for use in developing custom database management and searching applications. A flowchart for one embodiment of an API embodiment is shown in  in accordance with certain embodiments. Further detail of the embodiment of this embodiment is provided in Appendices K (software design description), L (default parameters), M (developer's documentation) and N (source code listing), each of which forms a part of this specification. Operation of elements in the embodiment of  are generally similar to like operational features described with reference to .","As shown in , an API-based name searching system  comprises name extraction tools  and name comparison tools . Name extraction tools  comprise Intelligent Search Data Generator (ISDG)  and associated intelligent search database , intelligent pre-processor , name classifier , name regularizer , and phonetic key generator . Name comparison tools  comprise name evaluator  and results manager , with scored name data  as an intermediate step. The system receives as an input name data , and provides ordered similar data  as an output from name comparison tools .","The output of ISDG  is search data , which is provided to data update and data access applications  and from there to the name comparison tools  as query and candidate search data . A names database with intelligent search data  is provided in association with data update and data access applications .","The embodiment of , like that described previously with reference to , implements a multifaceted approach to multicultural name searching. For example, in the Hispanic culture, an individual typically has a compound family name (e.g., \u2014Arantxa SANCHEZ VICARIO), the first of which (SANCHEZ) provides the more valuable identifying information. In contrast, although Portuguese names also typically have compound family names and look very similar to Hispanic names (e.g., Maria FERREIRA DOS SANTOS), the second family name (DOS SANTOS) provides the more valuable identifying information. If a single solution were proposed where, for example, the Last Name is considered the most important name, as in American names, Hispanic names would not be adequately accommodated.","The disclosed embodiment automatically applies whatever resources will adequately address the problem at hand, whether the variation is cross-cultural or arises from spelling variation, from transcription from other writing systems, from sound similarity, or from missing or additional information.","In operation, the user system supplies both a query name and a database name to the system. The system employs linguistic intelligence to separate the name into its integral components in intelligent preprocessor . Further linguistic intelligence is employed to compare the two names in name evaluator . The result of the comparison is a scored database name, scored name data . The scored name is passed to results manager , which collects and orders the names that are scored against a single query name. The final output is an ordered set of scored database names, ordered similar data .","The cornerstone of this embodiment is a programming library (functions and classes) that enables a developer to add fuzzy logic personal name searching to an application. For example, the developer may perform operations such as \u201cGive me the 10 closest names to \u2018James Slesinger\u2019 from my database\u201d, or \u201cGive me all the names from my database that match \u2018John Wong\u2019 with a degree of confidence of 0.9\u201d or \u201cTell me the degree of similarity between \u2018Paul Vanesann\u2019 and \u2018P Vanlesann\u2019\u201d. The system incorporates and uses a variety of linguistic techniques to achieve these results, in the manner described previously with respect to a standalone name searching system.","Users can enhance the functionality of the APIs by incorporating their business rules and data into the name comparison process. This embodiment provides fine granularity when comparing names. That is, names are scored and ranked more precisely, which is important when dealing with large volumes of data. The technology incorporates numerous parameters (to customize the user's search comparison).","From the user\/developer perspective, the name search system is quite simple to utilize. A typical name search requires the use of just four classes (SNQueryParms, SNQueryNameData, SNEvalNameData, and SNResultsList). In addition, it is important to note that the extra code required to integrate this name search technology is minimal.","The API name search interface is simplified by the fact that it makes no assumptions about the data and how it is stored. The user provides the API with the query name as well as the names from the database as input . The library routine then presents names which are likely matches, and qualifies their degree of similarity. From the perspective of the developer, the tool is straightforward and easy to integrate.","Searches via the API embodiment are configurable by adjusting any of 43 parameters (see Appendix L for defaults). Each parameter controls some aspect of how two names are evaluated when determining if they are similar. Some of the more basic parameters set thresholds for determining how close two names must be to be considered a match. Other parameters control more complex processing, such as how to handle multi-segment names. In general, only a small set of parameters need to be adjusted by the developer, because reasonable defaults exist for each one.","The API embodiment also provides pre-defined packages of parameters, each tailored to a particular culture or ethnicity. For example, Hispanic names have certain characteristics such as compound surnames (e.g., TORRES DE LA CRUZ) that can cause problems when searching for Hispanic names using conventional, Anglo-centric methods. The Hispanic parameters package contains settings that address Hispanic-specific name issues. New cultural\/ethnic parameter packages can be established and existing packages can be modified as desired.","Embodiments use a C++ object framework, so that users\/developers can extend the existing product functionality to incorporate additional data elements in the scoring algorithm or create evaluation methods specific to their business or application needs. For example, a database might contain a Social Security number, in addition to given name and surname. Although the name search technology only compares name data, a developer can take advantage of class inheritance (a feature of C++), and easily subclass the program's SNEvalNameData and SNQueryNameData objects to include Social Security numbers or any other desired data element(s). These data elements can then be used in the methods that score evaluation names and determine which evaluation names are matches. In other words, record matching can be performed using name data in conjunction with other available data element information.","Users\/Developers can also provide custom methods for determining if an evaluation name matches a query name or not. The default method compares the average of the given name score and surname score to a user\/developer supplied threshold value. However, a more complex method may be desired. For example, the business rules of an application might dictate that a name cannot be considered a match unless either the surname or given name is an exact match. By overriding the default method, the developer can easily implement this logic in just a few lines of code.","The functions provided in the API embodiment will now be described in more detail. The available functions include comparing a query name with one or more candidate names to produce an ordered list of candidate names with the highest probability of representing the same named person. This functionality is referenced as the name comparison tools . The basic name checking tool employs multiple evaluation techniques to evaluate and score two names. The name checking tool incorporates information regarding variations in spelling, discrepancy in the number of name segments (amount of information included), exclusion of expected information, and positional information to establish a name score, which indicates the probability that the two names represent the same individual. The tool is controlled by a set of configurable parameters. The tool also manages and produces an ordered or unordered list of candidate names with the highest probability of representing the same named person, based on the developer defined criteria for establishing a set of results. Various culture specific callable modules are available as extensions to the name check tool, including a name classifier that culturally classifies name data, a name regularizer that levels variations in name data to a single representation, and a phonetic name key that represents name data based on phonetic similarity. Again, each of these tools and modules incorporates the methods and technology described above with reference to FIGS.  and -.","The program also generates and stores intelligent search data for use in extracting relevant subsets of data from large data bases for further evaluation. These mechanisms will facilitate more efficient name searching while ensuring complete and accurate results. This functionality is referenced as the Name Extraction Tool(s). The disclosed embodiment provides users\/developers with the capability to compare two names to determine the probability that they both represent the same named individual or to compare a single query name with a set of candidate names to determine which candidate names are most likely to represent the same named individual.","When a set of candidate names is evaluated, the APIs enable the user\/developer to define the criteria for producing their own ordered list of results. The criteria for defining an ordered list of results include the following: the top X candidate names (i.e., the X candidate names scoring the highest probability that they represent the same named individual; e.g., the top ten candidate names); all candidate names whose name score exceeds a predefined name threshold (e.g., if the threshold=0, all candidate names will be returned in an ordered list); or the top X candidate names whose name score exceeds a pre-defined name threshold.","Name comparison tools  include a name evaluator , which employs multiple evaluation techniques to evaluate and score two names. Name evaluator  incorporates information regarding variations in spelling, inclusion of additional information, exclusion of expected information, and positional information in order to establish a name score, which indicates the probability that the two names represent the same individual. Name evaluator  is controlled by a set of configurable parameters. Results manager  uses the intermediate scoring information provided by name evaluator  to manage and produce an ordered list of candidate names with the highest probability of representing the same named person, based on the developer-defined criteria for establishing the results.","Name extraction tools  include an Intelligent Search Data Generator (ISDG)  which generates one or more search data values that facilitate extraction of relevant information from a data base for further comparative analysis. This tool is an important component of any search system that must search large volumes of data to locate similar name data, to the extent that it is not feasible to retrieve and evaluate every name record in a data base to determine its relevance to a query name. ISDG  provides a motivated method for retrieving all relevant information from a data base while reducing the amount of non-relevant information retrieved. This tool can provide significant performance improvements while also ensuring an accurate and complete name search. Various culture-specific tools are available as extensions to ISDG  to address specific issues such as the cultural classification of name data, performed by name classifier ; leveling of variations in name data to a single representation, performed by name regularizer ; and the representation of name data based on phonetic similarity, performed by phonetic key generator .","Thus, there has been disclosed an improved system and method, in multiple embodiments, for searching personal name databases, with maximum simplicity and ease of integration, maximum flexibility, and maximum extensibility.","Parsing Culturally Diverse Names","A disclosed parsing system automatically parses culturally diverse names using culture-specific parsing techniques. A culture of a name to be parsed is identified, and statistical information describing constituent name phrases is identified. A parsing technique that is specific to the identified culture (i.e., that is culture-specific) classifies each of the name phrases based on the statistical information. The parsing system determines whether the classification of the name phrases represents a valid parse of the name. If the parse is not valid, then the name is parsed again to produce a different parse.","In one general aspect, parsing names includes enabling access to multiple parsing techniques for parsing name elements into one or more types of elements. The multiple parsing techniques include separate parsing techniques that respectively correspond to at least one of multiple known cultures. A name that includes one or more elements is received, and an indication of at least one culture from among the multiple known cultures is accessed for the name. One of the multiple parsing techniques is selected based on the indication of the culture of the name. The one or more elements of the name are parsed into element types using the selected parsing technique, and an indication of the element types of the one or more elements is provided.","Embodiments may include one or more of the following features. For example, accessing the indication of the culture of the name may include detecting a characteristic of at least one of the elements of the name. The indication of the culture of the name may be determined based on the characteristics detected.","A database providing a statistical indication of a type of an element may be accessed. Parsing also may be based on the statistical indication.","A validity score for the parsing of the elements may be determined. The validity score may be compared to a threshold. Whether to reorder the one or more elements may be determined based on a result from the comparing. For example, a determination to reorder the one or more elements may be made based on the validity score. A database providing statistical indications of the types of the one or more elements may be accessed, and the one or more elements may be reordered using the statistical indications. The reordered elements of the name may be parsed into element types using the selected parsing technique. An indication of the validity score may be provided.","Parsing the one or more elements of the name into element types may include classifying each of the one or more elements as a title, a given name, a surname, or a qualifier. Statistics describing at least one of the one or more elements of the name may be provided. Receiving the name may include receiving a personal name.","In certain embodiments, the name elements into which a name is parsed are defined as title, given name, surname, or qualifier. These are the name elements used in an actual search embodiment, where names are fielded into a title field, a given name field, a surname field, and a qualifier field. In certain other embodiments, a more fine-grained parse is performed that parses different types of name elements within at least one field of the name. In certain embodiments, the fields are: title, given name, surname, and qualifier. As an example, for some cultures, such as Arabic, such a fine-grained parse is performed. For instance, an Arabic name might consist of several identifiable parts or name elements within a field, and the fine-grained parsing parses the Arabic name into more name elements (than title, given name, surname, and qualifier). This kind of analysis depends upon cultural classification, with different cultures lending themselves to different parsing techniques that differently parse different types of name elements within at least one field of the name based on the culture.","In another general aspect, identifying a valid parse of a name includes receiving a name that includes one or more elements. The one or more elements of the name are parsed into element types. Whether the element types of the one or more elements represent a valid parse of the name is determined, and an indication of whether the element types of the one or more elements represent a valid parse of the name is provided.","Embodiments may include one or more of the following features. For example, determining whether the element types represent a valid parse of the name may include determining a validity score for the element types. The validity score may be compared to a threshold. Whether to reorder the one or more elements may be determined based on a result from the comparing. For example, a determination to reorder the one or more elements may be made based on the validity score. A database providing statistical indications of the types of the one or more elements may be accessed, and the one or more elements may be reordered using the statistical indications. The reordered elements of the name may be parsed into element types using the selected parsing technique.","In another general aspect, processing a name includes receiving an indication of a name that includes multiple tokens. An indication of a culture of the name is accessed. One or more name phrases included in the name are identified based on the culture of the name. At least one of the identified name phrases has more than one token. The identified name phrases is designated as an input to a subsequent name processing operation, and the name is processed using the identified name phrases as an input to the subsequent name processing operation.","Embodiments may include one or more of the following features. For example, processing the name may include parsing the name. Identifying the one or more name phrases may include classifying each of the multiple tokens in the name as a prefix, suffix, or stem based on the culture of the name. The classified tokens may be grouped into name phrases based on the classification of the tokens and the culture of the name.","In another general aspect, parsing a conjoined name includes receiving a conjoined name construct that includes multiple elements. Multiple names indicated by the conjoined name construct are identified. Each of the multiple names includes one or more elements. At least one of the multiple elements of the conjoined name construct is included as an element in each of the multiple names. The one or more elements of at least one name of the multiple names are parsed into element types, and an indication of the element types of the one or more elements of the at least one name is provided.","Embodiments may include one or more of the following features. For example, access to multiple parsing techniques for parsing name elements into one or more types of elements may be enabled. The multiple parsing techniques may include separate parsing techniques that respectively correspond to at least one of multiple known cultures. An indication of at least one culture from among the multiple known cultures may be accessed for the at least one name. The indication may reflect at least one culture selected from among the multiple known cultures. One of the multiple parsing techniques may be selected based on the indication of the culture of the at least one name. Parsing the one or more elements of the at least one name may include parsing the one or more elements using the selected parsing technique.","A database providing a statistical indication of a type of an element of the at least one name may be accessed. Parsing also may be based on the statistical indication.","Various disclosed embodiments include a parser that parses names that are representative of multiple cultures. The parser provides multiple culture-specific parsing techniques from among which a technique is selected based on the culture of an input name to be parsed. Upon receipt of an input name, the parser accesses a name database, referred to as Name Data Object (NDO), that indicates the probability that a particular name phrase of the name is a given name, a surname, a qualifier, or a title. Using culture-specific rules, the parser applies the selected parsing technique to parse the name into a title, a given name, a surname, and a qualifier. Then, based on the probabilities from the NDO, the parser calculates a validity score for the name parse, and compares the calculated validity score against a threshold. If the validity score fails to meet the threshold, the parse is deemed invalid, the name phrases of the name are reordered, and the name is parsed and verified again.","Referring to , a name processing system  includes a name processing application  that is used to parse personal names that are representative of multiple cultures. The name processing application  includes an input\/output module  that receives names to be parsed and provides parsed versions of the names. A parsing controller  that controls parsing of the names uses a classifier , a name phrase identifier , a Name Data Object (NDO) , and multiple culture-specific parsing techniques . A parsing validity checker  determines whether valid parses of the names have been produced.","The name processing application  may be used for multiple purposes. For example, the name processing application may be used to verify that names included in one or more databases have been parsed accurately and\/or consistently. The name processing application may be used to correct inaccurately parsed names in the databases and to identify a single parsed version of a name for which multiple parsed versions exist in the databases. Parsing a name consistently may reduce recall errors stemming from using different parses of a name and may help to reduce duplicative records from the database. The name processing application  also may be used to generate alerts of inaccurately parsed names within the database.","The input\/output module  receives personal names to be parsed and provides parsed versions of the personal names. The input\/output module  also may receive a specification of one or more parameters that indicate how the personal names are parsed. For example, the input\/output module  may receive an indication of whether a name is to be reparsed automatically when a previous parse is invalid, or an indication of criteria under which a parse is invalid. In one embodiment, the input\/output module  is a user interface (UI), such as a command line interface or a graphical user interface (GUI), with which the personal names may be specified, and with which the parsed version of the personal names may be presented. Values for the parameters also may be specified with the UI.","In another embodiment, the input\/output module  implements an application programming interface (API) to the name processing application . In other words, functions or methods provided by the input\/output module  may be used by an external application to provide personal names, to receive parsed names, and to provide parameter values. The input\/output module  may receive the name as text that has been formatted with, for example, the American Standard Code for Information Interchange (ASCII) encoding scheme, the Unicode encoding scheme, or the International Standards Organization (ISO) 8859-1 encoding scheme. A list providing examples of encoding schemes with which the personal names may be formatted may be found at http:\/\/www.iana.org\/assignments\/character-sets.","The parsing controller  controls parsing of personal names. More particularly, the parsing controller  receives a personal name to be parsed from the input\/output module . The parsing controller  passes the personal name, and information describing the personal name, to the classifier , the name phrase identifier , the NDO , one of the culture-specific parsing techniques , and the parsing validity checker , and receives information from these components in the process of parsing the name. The parsing controller  then provides the parsed name to the input\/output module .","The classifier  identifies a culture to which a personal name corresponds. More particularly, the classifier  receives a personal name to be parsed from the parsing controller . The classifier  processes the received personal name to identify a culture of the name, and provides an indication of the culture to the parsing controller . For example, the classifier  may identify the culture based on one or more characteristics of the personal name, or on one or more characteristics of an element of the personal name.","In one embodiment, the classifier  includes multiple culture-specific classifying techniques. Each of the techniques takes a name as an input and produces a score indicating the likelihood that the name is representative of a corresponding culture. An input name is provided to each of the classifying techniques, and is determined to be representative of the culture corresponding to the technique that identifies the greatest likelihood of representation.","Each of the techniques examines characteristics of the input name, or of elements of the input name, to determine whether the name is representative of the corresponding culture. More particularly, the technique identifies characteristics of the input name that are representative of names in the corresponding culture. If such characteristics are identified within the input name, then the technique indicates that the name has a high likelihood of being representative of the corresponding culture.","Some of the classifying techniques identify orthographic characteristics of the input name. For example, such a technique may consider the type, position, and order of characters within the input name, or a length of the name, when classifying the input name. Alternatively or additionally, such techniques may perform an n-gram analysis of the name. In an n-gram analysis of a name, a database that maintains an indication of the likelihood of any sequence of n consecutive characters appearing in a name that is representative of a particular culture is used. The probabilities that sequences of n consecutive characters from the input name are included in the particular culture are accessed from the database and used to determine whether the name is representative of the particular culture.","Other classifying techniques perform a semantic analysis of the input name. Such a technique may identify the meaning of one or more parts of the name. For example, a part of the name may be a word in a language of a particular culture, so the technique may determine that the name is representative of the particular culture. As another example, the technique may determine that the name is representative of the particular culture when the name includes an affix that is typical of words of a language of the particular culture. Other techniques may use syllabic, syntactic, or phonological characteristics of the name when determining the likelihoods that the name is representative of corresponding cultures.","In another embodiment, the classifier  may identify the culture to which the input name corresponds by a process of elimination. For example, one or more of the culture-specific classifying techniques may indicate that the name is not representative of the corresponding cultures. As a result, the set of cultures to which the input name may correspond is reduced. If a sufficient number of the culture-specific classifying techniques indicate that the input name is not representative of the corresponding cultures, then a culture to which the name corresponds may thereby be uniquely identified.","An input name may correspond to multiple cultures. For example, a first token of the input name may correspond to a first culture, and a second token of the input name may correspond to a second culture. In one embodiment, the classifier  may identify, for example, the first culture as a culture of the name if the first token has a stronger correspondence to the first culture than the second token has to the second culture. In such an embodiment, the name may be parsed based on a culture to which a portion of the name does not correspond. In another embodiment, the classifier  may identify both of the first and second cultures as the culture of the name. In such an embodiment, the name may be parsed individually based on each of the first and second cultures. One of the resulting parses may be selected as the parsed version of the name, or the resulting parses may be combined into the parsed version of the name. Alternatively or additionally, the name may be parsed simultaneously based on both the first and second cultures.","Various embodiments for classifying a name are described in U.S. application Ser. No. 09\/275,766, titled \u201cSystem and Method for Adaptive Multi-Cultural Searching and Matching of Personal Names,\u201d and filed on Mar. 25, 1999. U.S. application Ser. No. 09\/275,766 is hereby incorporated by reference in its entirety for all purposes.","The name phrase identifier  identifies one or more name phrases included in a personal name. Each of the name phrases may include one or more tokens. For example, the name phrase includes a stem to which zero or more prefixes or suffixes have been added. The stem of the name phrase is the portion of the name phrase that is not a prefix or a suffix of the name phrase. The name phrase identifier  may consult a culture-specific list of possible prefixes and suffixes, such as is maintained by the NDO , when identifying the name phrases. For example, using the NDO , the name phrase identifier  may classify each token of the name as a prefix, a suffix, or a stem in names of a particular culture of the name. A token may be classified as a stem as a result of not being included in the list of prefixes and suffixes for the particular culture, or as a result of being included in a list of name phrases included in names of the particular culture, such as is maintained by the NDO . Consequently, the classification of the tokens may depend on the particular culture of the name.","The classification and the order of the tokens may indicate the name phrases of the name. In general, a name phrase includes a stem, the tokens that immediately precede the stem that are prefixes, and the tokens that immediately follow the stem that are suffixes. For example, referring to , a name , \u201cCarlos de la Fuente\u201d includes four tokens -. The tokens and may be classified as stems, and the tokens and may be classified as prefixes. Because the name  includes two stem tokens and , the name  includes two name phrases and . The name phrase includes the token , which is not preceded by any prefix tokens or followed by any suffix tokens. The name phrase includes the token , which is preceded by the prefix tokens and . In some embodiments, a prefix that follows the stem may be part of the name phrase as long as a suffix appears between the prefix and the next stem.","Therefore, the grouping of the tokens of the name into name phrases may depend on lexical and syntactic characteristics of the name. The lexical characteristics include the classifications of the tokens as prefixes, suffixes, and stems, and the syntactic characteristics include the order in which the tokens appear in the name. Furthermore, the grouping may depend on the culture of the tokens. For example, a prefix may be grouped with a subsequent stem only if the prefix and the stem correspond to the same culture, or only if name phrases of names of a culture of the stem typically include prefixes.","Alternatively, or additionally, the name phrase identifier  may consult the list of name phrases when identifying the name phrases. For example, the name phrase identifier  may look up a group of one or more consecutive tokens from the name in the list to determine whether the group represents a name phrase. After the group has been identified as a name phrase, name phrases that include the remaining tokens in the name are identified. In this manner, the set of possible name phrases may be reduced with each name phrase that is identified, until a complete set of valid name phrases included in the name have been identified.","In one embodiment, the name phrase identifier  identifies the name phrases without reference to a culture of the name that was identified by the classifier . In another embodiment, the name phrase identifier  may use culture-specific information when identifying the name phrases. The name phrase identifier  may identify the name phrases such that statistics describing the name phrases may be identified from the NDO .","Identifying name phrases of names and processing the names based on the name phrases may be advantageous over processing the names based on tokens of the names. For example, processing names based on name phrases may be particularly useful when processing non-English names that have been transliterated from a non-Roman alphabet. Multiple transliteration schemes may be available to transliterate the names from the non-Roman alphabet to the Roman alphabet. When transliterating a name, the transliteration schemes may use different numbers of tokens to represent a particular continuous portion of the name, such as, for example, a surname. Therefore, different transliterations of the name may include different numbers of tokens. However, the different transliterations typically include the same number of name phrases for the name. More particularly, the different transliterations typically include a single name phrase for the particular portion (for example, the surname) of the name. Therefore, processing of the name based on the name phrases may reduce the effect of inconsistent separation of portions of the name into tokens. In other words, using the name phrases enables the processing of the name to withstand incorrectly, or inconsistently, placed boundaries between tokens (for example, \u201cde la Tour\u201d versus \u201cDelatour\u201d). As another example, particular tokens of the names may have more meaning or significance to the name when they are combined with one or more adjacent tokens. For example, in Arabic names, the prefix \u201cal\u201d may be more meaningful when combined with an adjacent stem token, as many Arabic surnames include the prefix \u201cal.\u201d","The NDO  is a database of name phrases and relative frequencies with which the name phrases appear in personal names from a variety of cultures. More particularly, the NDO  includes the name phrases that are included in a large set of culturally-diverse personal names. For each name phrase (see, for example, ), the NDO  indicates the number of times the name phrase is included in the set as a given name or as a surname. In addition, the NDO  includes a list of name phrases that are titles, and a list of name phrases that are qualifiers. Therefore, the NDO  indicates the probability that a name phrase is included in a given name, a surname, a qualifier, or a title of a name.","The given name, the surname, the qualifier, and the title represent four possible types of a name phrase. A surname typically indicates an association (e.g., family, clan, tribe, ethnic group, religion, profession, location, or lineage.). A given name designates an individual. A title typically identifies a position, a social status, or a gender. Examples of titles include \u201cMr.,\u201d \u201cMrs.,\u201d \u201cMs.,\u201d \u201cDr.,\u201d \u201cSr.,\u201d \u201cSra.,\u201d \u201cMlle.,\u201d and \u201cHerr.,\u201d Qualifiers modify portions of a given name or a surname, or further describe or identify the individual corresponding to the personal name. Examples of qualifiers include \u201cJr.,\u201d \u201cSr.,\u201d \u201cIII,\u201d and \u201cEsq.\u201d","In addition, the NDO  includes, for each name phrase, an indication of at least one country or culture having names that include the name phrase, particularly those name phrases that are included in the set as a given name or as a surname. For each indicated country or culture, the NDO  also includes an indication of the number of names, from among the set of names, that include the name phrase and that are representative of the country or culture. In one embodiment, the NDO  includes information describing name phrases from approximately one billion culturally-diverse personal names.","Referring to , part of the NDO  may be organized as a table. For example, the NDO  includes a statistics table  having columns - and rows -. A name phrase column  contains one name phrase per row. A surname column  includes counts of the names from the set (described earlier) that include the name phrases as surnames. For example, 132,884 names from the set include the name phrase \u201cJames\u201d as a surname, as is indicated by the number at the intersection of row and the surname column . Similarly, a given name column  includes counts of the names from the set that include the name phrases as given names. For example, 179,090 names from the set include the name phrase \u201cKim\u201d as a given name, as is indicated by the number at the intersection of row and the given name column .","For each of the rows -, the country column  indicates one or more countries or cultures with names that include the corresponding name phrase. For example, names from the United States, Holland, and Vietnam include the name phrase \u201cVan,\u201d as is indicated by the information at the intersection of row and the country column . The country column  also includes an indication of a relative proportion of the names that include the name phrase among the one or more countries or cultures. For example, 70% of the names that include the name phrase \u201cVan\u201d are from Vietnam, 20% are from Holland, and 10% are from the United States, as is indicated by the information at the intersection of row and the country column .",{"@attributes":{"id":"p-0156","num":"0156"},"figref":"FIG. 12","b":["1200","1100","1210","1260","1270","1270","1210","1230","1110","1120","1100","1200"],"i":["a","z"]},"A culture column  indicates at least one culture with names that include the name phrases. For example, Arabic names include the name phrase \u201cal,\u201d as is indicated by the culture listed at the intersection of row and the culture column . A name phrase may be represented in multiple rows of the statistics table . For example, the name phrase \u201cJae\u201d is represented by rows and in the statistics table . A name phrase corresponds to multiple rows when the name phrase is included in names from multiple cultures, and the statistics table  includes a separate row for the name phrase for each of the multiple cultures. For any such row, column  indicates the number of names, from the set of names, that correspond to the particular culture and that include the particular name phrase as a surname. In certain embodiments, statistics table  may include a column for a given name that indicates the number of names, from the set of names, that correspond to the particular culture and that include the particular name phrase as a given name. For example, the row and the column  of the statistics table  indicate that the name phrase \u201cKim\u201d may appear in English and Korean names. Consequently, the statistics table  includes the row to describe English names that include \u201cKim\u201d and the row to describe Korean names that include \u201cKim.\u201d For example, the row indicates that 175,508 English names from the set of names include \u201cKim\u201d as a given name, while the row indicates that 1,456,882 Korean names from the set of names include \u201cKim\u201d as a surname. Therefore, most of the names in which \u201cKim\u201d appears as a given name are English names, even though most of the names in which \u201cKim\u201d appears are Korean names.","Referring also to , the NDO  also includes a token table  that identifies tokens that are prefixes to stems of name phrases, tokens that are suffixes to stems of name phrases, tokens that are stems of title name phrases, and tokens that are stems of qualifier name phrases. The tokens included in the tokens table  may be included in names from the set of names. The token table  includes columns - and rows -. A token column  contains one token per row. A type column  indicates the types of the tokens. For example, the token \u201cde\u201d is a prefix, as indicated row and the type column . Similarly, a culture column  indicates one or more cultures of names from the set of names that include the tokens. For example, the token \u201cHerr\u201d typically is included in German names, as indicated by the row and the column .","The token table  enables the classification of tokens of a name as, for example, a prefix, a suffix, or a stem of a name phrase of a name, based on a culture of the name. For example, the row , the column , and the column  indicate that the token \u201cdin\u201d is a suffix in Arabic names. As another example a token that is not included the token table  as a prefix or a suffix in the culture of the name may be assumed to be a stem of a name phrase, by a process of elimination.","The token table  also enables the classification of tokens as stem tokens of either a title or a qualifier in names of a particular culture. For example, the row , the column , and the column  indicate that the token \u201cJr.\u201d is a stem token of a qualifier in English names. As another example, a token that is not included in the token table  as a stem of either a title or a qualifier of names of the particular culture may be assumed to be a stem of either a given name or a surname, by a process of elimination. When a token is not included in the token table  as a stem of a title or a qualifier, the token may be included in one of the statistics tables  or , which may indicate whether the token is a stem of a given name or a surname.","The token table  may be used, for example, by the name phrase identifier  when identifying name phrases of a name. In addition, the token table  may be used when identifying statistics for a name phrase from one of the statistics tables  or . For example, if a name phrase is not included in one of the statistics tables  or , then the token table  may be used to identify a stem of the name phrase that may be included in one of the statistics tables  or . The statistics for the stem may be used as the statistics for the name phrase.","The numbers included in the statistics table  and the statistics table  enable the determination of the relative frequencies of appearance for different name phrases. For example, the rows and indicate that names (from the set of names) include the name phrase \u201cSmith\u201d more often than the name phrase \u201cDong.\u201d In addition, the statistics tables  and  enable the classification of a name phrase as a given name or a surname. For example, the row indicates that the name phrase \u201cVan\u201d most likely is a surname, because \u201cVan\u201d appears in the set of names more often as a surname than as a given name. Furthermore, the token table  enables the classification of a name phrase a title or a qualifier. For example, the row , the column , and the column  of the token table  indicate that the name phrase \u201cMr.\u201d is a title in English names.","A token may appear in both the token table  and one of the statistics tables  and . For example, a token may represent a prefix or a suffix in names of a first culture, and a given name or a surname in a second culture. For example, the token table  indicates that the token \u201cvan\u201d is a prefix in Dutch names, and the statistics table  indicates that the token \u201cVan\u201d is a surname in Vietnamese names. In such a case, the token may be uniquely classified based on the culture of a name that includes the token using one of the token table  or the statistics tables  and . Alternatively, the token may represent a prefix or suffix in some names of a particular culture, and a given name or a surname in other names of the particular culture. In such a case, classification of the token is based on the token table , and not one of the statistics tables  or .","Turning now to the techniques , the parsing controller  passes to one of the techniques  a name to be parsed. The technique  that receives the name is a technique that parses names from the culture that was determined by the classifier . The parsing controller  also may provide the technique  with an indication of the name phrases that are included in the name, and statistics describing the name phrases that have been retrieved from the NDO . Using the information received from the parsing controller , the technique  classifies the name phrases of the name as one of the possible types of name phrases. In other words, the technique  classifies each of the name phrases as being included in a title, a given name, a surname, and a qualifier of the name. Consequently, the technique  may indicate that multiple name phrases have the same type within the name. The multiple name phrases of the same type may be grouped together. For example, if the technique  indicates that two name phrases are given names, the two name phrases may be grouped to form a single given name for the parsed name. In one embodiment, the order in which the multiple name phrases are grouped is the order in which the multiple name phrases appear in the original name. Each of the techniques  may use conventional parsing techniques to parse names of corresponding cultures.","Each of the culture-specific parsing techniques  parses names that are representative of one or more cultures. For example, techniques  may include a technique for parsing Chinese names, a technique for parsing Korean names, a technique for parsing Japanese names, a technique for parsing Spanish names, a technique for parsing Arabic names, and a technique for parsing English names. Alternatively or additionally, the techniques  may include, for example, a technique that parses Asian names, instead of dedicated techniques for each type of Asian name. In some embodiments, the culture-specific parsing techniques  may include a generic parsing technique that is configured to parse names that are representative of any culture. The generic parsing technique may be used, for example, when a culture-specific parsing technique for a name is not identified.","The technique for parsing names of a particular culture uses characteristics of names of the particular culture to determine how to parse the name. For example, a technique for a particular culture may access indications of prefixes, suffixes, titles, and qualifiers that are specific to the particular culture from the NDO . The culture-specific prefixes, suffixes, titles, and qualifiers may be used to group tokens of the names into name phrases, and to identify which of the name phrases represent titles and qualifiers for the name.","As another example, a technique for parsing Asian names may use the convention that a surname precedes a given name to identify the leftmost name phrase as the surname and the rightmost name phrase as the given name. However, the technique might do so only when the statistics received from the NDO  indicate that the leftmost name phrase is a surname and that the rightmost name phrase is a given name. For example, if the statistics indicate that the leftmost name phrase is a given name and that the rightmost name phrase is a surname, then the technique may conclude the same, even though such a conclusion violates the conventional structure of Asian names. Additionally, when the culture-specific technique  examines the statistics for a name phrase, the technique  may consult the culture-specific statistics (for example, from the statistics table ) or the combined statistics (for example, from the statistics table ).","As another example, a technique for parsing Arabic names may use knowledge that many surnames are preceded by the prefix \u201cal\u201d to determine that, in a name that includes that prefix, the prefix forms a name phrase with a token that immediately follows the prefix. Furthermore, the technique may determine that the name phrase is likely to be a surname because the name phrase includes the prefix \u201cal.\u201d However, the technique might only do so if the statistics received from the NDO  indicate that the token following the prefix typically is a surname.","For some cultures, such as Arabic, a parsing technique that parses different types of name elements within at least one field of the name is performed. For instance, an Arabic name might consist of several identifiable parts, and the parsing technique parses the Arabic name into more parts (than given name and surname). For example, an Arabic name may be: MOHAMMAD ABU IBRAHIM BIN MUSTAFA AL-SAUDI. A reasonable parse of this Arabic name into a given name and a surname for search purposes might be:\n\n","With fine grained parsing, embodiments can also provide a more analytically useful parse that identifies, for a name that may be separated into fields (e.g., surname and given name fields), different types of name elements within a field, such as:\n\n","This kind of analysis depends upon cultural classification, with different cultures lending themselves to different parsing techniques that parse different types of name elements within at least one field of the name. That is, different cultures may each be associated with a different parsing technique that parses different types of name elements within at least one field of the name based on that culture.","That is, instead of the output of the parsing process being a name broken down into a given name field and a surname field (along with any titles and qualifiers, if those were present), the classifier provides the user with more detailed information within a field. As another example, an Arabic name may be: HAJ MOHAMMAD BIN IBRAHIM AS SAUDI. A reasonable parse of this Arabic name into a title, a given name, and a surname for search purposes might be:\n\n","With fine grained parsing, embodiments can also provide a more analytically useful parse that identifies different types of name elements within a field, such as:\n\n","The parsing validity checker  determines whether a parse of a name identified by one of the techniques  represents a valid parse of the name. In one embodiment, the parsing validity checker  receives the parsed name from the parsing controller  after the parsing controller  receives the parsed name from one of the techniques . In another embodiment, the parsing validity checker  receives the parsed name directly from the techniques . In one embodiment, each of the techniques  includes a parsing validity checker . In such an embodiment, the parsing validity checker  corresponding to one of the techniques  determines whether parsed names produced by the technique are valid.","Referring to , one embodiment of the parsing validity checker  includes multiple validity tests -. Each of the validity tests -examines characteristics of at least a portion of a parsed name to aid in a determination of whether the parsed name is valid. A combination module  combines the results of the validity tests -into an overall indication of the validity of the parsed name. The indication of the validity of the parsed name is sent from the parsing validity checker  over a communications interface  to other components of the name processing application .","In one embodiment, the validity tests -measure the conformity of the parsed name to a set of criteria. For example, the validity tests may measure the conformity of the parsed name to other names of the same culture as the parsed names, or to other names that include the same name phrases as the parsed name. Each of the validity tests -assigns a score to at least a portion of the parsed name based on the characteristics of the parsed name.","For example, one or more of the tests -may identify a dominance factor for one or more of the name phrases included in the parsed name. The dominance factor indicates the ratio of (i) the names in the set of names reflected in the NDO  that include the name phrase as a particular type to (ii) the names in the set that include the name phrase as any of the possible types. Dominance factors typically are calculated for name phrases that have been classified as given names or surnames in the parsed name, and the dominance factor of a name phrase depends on whether the name phrase has been classified as a given name or a surname. If the parsed name includes the name phrase as a given name, then the dominance factor for the name phrase indicates the likelihood that the name phrase is a given name. In such a case, the dominance factor is the ratio between (i) the number of names from the set of names that include the name phrase as a given name and (ii) the number of names from the set of names that include the name phrase as any of the possible types. Similarly, when the parsed name includes the name phrase as a surname, the dominance factor indicates the likelihood that the name phrase is a surname. Dominance factors may not be calculated for name phrases that have been classified as titles or qualifiers because such name phrases typically are not incorrectly classified. In other words, the only name phrases that are classified as titles are name phrases that the NDO  indicates are titles, and the only name phrases that are classified as qualifiers are name phrases that the NDO  indicates are qualifiers. However, name phrases that the NDO indicates are titles or qualifiers also may be classified as given names or surnames.","One or more of the validity tests -may assign dominance factors to special name phrases. Special name phrases include name phrases that include an initial, name phrases that are not included in the NDO , and name phrases that include a title or a qualifier. For example, a name phrase that includes an initial may be passed to a particular one of the tests -. Name phrases that include an initial typically are classified as given names. Consequently, the particular test may assign a dominance factor to the name phrase to indicate that the name phrase typically appears as a given name. In one embodiment, the test may assign the name phrase a high dominance factor when the name phrase has been classified as a given name in the parsed name, and the test may assign the name phrase a low dominance factor when the name phrase has been classified as a surname in the parsed name. In one embodiment, the high dominance factor is 0.8, or 80%, and the low dominance factor is 0.2, or 20%.","Another one of the tests -may indicate that a name phrase that is not included in the NDO  is not to be assigned a dominance factor and is not to be considered when determining the overall validity score of the parsed name. Alternatively or additionally, the test may indicate that the name phrase is not to be considered when a portion of the name phrase is not included in the NDO . For example, the test may indicate that the name phrase is not to be considered when a stem of the name phrase is not included in the NDO .","Another one of the tests -may indicate that a name phrase with a stem that typically is a title or a qualifier be assigned a dominance factor of 0.1, or 10%, regardless of whether the name phrase has been classified as a given name or as a surname in the parsed name. The NDO  may indicate whether the stem of the name phrase is a title or a qualifier.","Others of the tests -may process the parsed name as a whole to identify a validity score for the parsed name. For example, one of the tests -may determine whether or not the parsed name includes at least one given name and at least one a surname. If not, then the test may assign a validity score of 0.5, or 50%, to the parsed name, which typically indicates that the parsed name is invalid.","Another one of the tests -may determine whether or not the name phrases included in the parsed name as given names or surnames are included in the NDO . If none of the name phrases are included in the NDO , then the test may assign a validity score of 0.5, or 50%, to the parsed name.","Another one of the tests -may base the validity score on whether an order in which the name phrases appear in the parsed name is an order in which the name phrases typically appear, as indicated by information describing the name phrases from the NDO , and by characteristics of names of a culture of the parsed name. The test may assign a high validity score when the order of the name phrases in the parsed name is an order in which the name phrases typically appear, and the test may assign a low validity score otherwise.","Another one of the tests -may determine whether the name phrases are spelled correctly. For example, the test may determine whether a misspelled name phrase was included as a given name when the name phrase, when spelled correctly, typically is included as a surname. If the misspelled name phrase is incorrectly classified within the parsed name, the test may assign a low validity score to the parsed name. In some embodiments, the test also may correct the spelling of the name phrase.","The combination module  mediates the operation of the parsing validity checker . In one embodiment, the combination module  provides at least a portion of the parsed name, such as a name phrase, to each of the validity tests -and receives a score from each of the validity tests -. The combination module  combines the scores received from the tests -into an overall validity score for the parsed name. For example, the combination module  may normalize and average, or otherwise combine, the scores to identify the validity score. In one embodiment, the combination module  may receive dominance factors for some of the name phrases of the parsed name from one or more of the tests -, and the combination module  may average the dominance factors to identify the validity score for the parsed name as a whole. Alternatively, for each dominance factor that is less than 0.5, the combination module may subtract a fixed amount from a maximum allowable overall validity score, and the remainder of the maximum allowable validity score may represent the validity score for the parsed name as a whole. Alternatively, the combination module may apply a logarithmic function to each of the dominance factors (e.g., raise 10 to the power of the difference of one and the dominance factor), and then may average the resulting values to identify the validity score for the parsed name.","In another embodiment, the combination module  may receive a validity score for the parsed name from each of the tests -and may average the received validity scores to identify the overall validity score for the parsed name. In one embodiment, the validity score is a number between 0 and 1, or a corresponding percentage between 0% and 100%. The validity score also may be referred to as a confidence in the parsed name.","The validity score is passed from the validity checker to the parsing controller  over the communications interface . In addition, the parsed name, and information describing the parsed name, is received over the communications interface . The parsing controller  may determine whether the parsed name is valid based on the validity score that is received from the parsing validity checker . In one embodiment, the parsing controller  may determine that the parsed name is valid when the validity score is greater than a threshold value. If the parsed name is invalid, then the parsing controller  may reorder (described later) the name phrases of the name and parse the name again.","Referring to , a process  is used to parse a name (e.g., a personal name) that is representative of one of multiple supported cultures. The process may be executed by a name processing application, such as the name processing application . More particularly, the process may be executed by a parsing controller of the name processing application, such as the parsing controller .","The controller receives a name to be parsed from an input\/output module of the name processing application, such as the input\/output module  (). In embodiments where the input\/output module is a UI for the name processing application, the input\/output module receives a specification of the name from a user of the UI. In embodiments where the input\/output module implements an API to the name processing application, the input\/output module receives the name through an invocation of a method or function provided by the API. For example, a \u201cparse\u201d method provided by the API may be called with the name as an argument to the method. The input\/output module passes the received name to the controller for further processing.","The controller identifies a culture of the name using a classifier, such as the classifier  (). More particularly, the controller passes the name to the classifier, and the classifier identifies and returns an indication of a culture of the name. The classifier may determine one or more characteristics of the name, and may identify the culture based on the determined characteristics.","The controller then identifies one or more name phrases from the name with a name phrase identifier, such as the name phrase identifier  (). More particularly, the controller passes the name to the name phrase identifier, and the name phrase identifier identifies and returns the name phrases. In one embodiment, the name phrase identifier classifies each token of the name as a prefix, a suffix, or a stem, and uses the classification to identify the name phrases. In another embodiment, the name phrase identifier consults a list of name phrases, such as is maintained by the NDO , when identifying the name phrases. In addition to the name, the controller also may provide an indication of the culture of the name to the name phrase identifier, and the name phrase identifier may use the indication of the culture when identifying the name phrases.","The controller identifies statistics describing the name phrases of the name from an NDO of the name processing application, such as the NDO  (). More particularly, for each name phrase, the controller accesses indications of the number of names, from a set of culturally-diverse names, that include the name phrase as each of the possible types. The controller also may access indications of countries or cultures with names that include the name phrases, as well as numbers of names from each of the countries or cultures that include the name phrases, from the NDO. In embodiments where the name phrase identifier accesses the statistics from the NDO when identifying the name phrases, the name phrase identifier may provide the statistics to the controller.","The controller determines whether a first parsing technique that parses different types of name elements within at least one field of the name (e.g., a fine-grained parsing technique) is to be performed (). In certain embodiments, the determination of whether to perform the first parsing technique is based one on or more factors. Culture is one example of such a factor. For example, if a name is Hispanic, the controller may use a culture-specific parsing technique that identifies the patronymic surname and the matronymic surname; while, if the name is Russian, then the controller may use a culture-specific parsing technique that identifies the patronymic middle name. As another example, if the name is American, the controller may use a second parsing technique (e.g., a general parsing technique) that parses the name into one or more of: a title, a given name, a surname, and a qualifier.","The following table provides an example of the parsing technique that parses different types of name elements within at least one field of the name for the Hispanic culture. In particular, the parsing technique parses different types of name elements within the surname field.",{"@attributes":{"id":"p-0195","num":"0207"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MARIA CARMEN","GARCIA","RODRIGUEZ","VDA","CABRERA","LOPEZ"]},{"entry":[{},"Patronymic","Matronymic","Particle","Husband's","Husband's"]},{"entry":[{},"Surname","Surname","indicating","patronymic","matronymic"]},{"entry":[{},{},{},"widowhood","surname","surname"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"217pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Given Name Field","Surname Field"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"If the first parsing technique is to be performed, the controller parses the name phrases using the identified statistics and the first parsing technique that is specific to the identified culture, such as one of the parsing techniques  (). In certain embodiments, the first parsing technique annotates name types within a field. The controller parses the name phrases using the identified statistics and a second parsing technique that is specific to the identified culture, such as one of the parsing techniques  (). More particularly, the parsing technique may be identified from among several potential parsing techniques based on non-equivalent matching. For example, if the identified culture of the name is the Korean culture, the parsing technique may be specific to multiple Asian cultures, including the Korean culture. The controller passes the name phrases and the identified statistics to the parsing technique. The controller also may provide, for example, an indication of the order in which the name phrases appear in the name, and other syntactic information describing the name, to the parsing technique. The parsing technique separates the name phrases into the possible types using the identified statistics and characteristics of names of the identified culture. The parsing technique provides a parsed version of the name to the controller, and the controller receives the parsed version of the name.","The controller determines whether the parsed version of the name is valid using a parsing validity checker, such as the parsing validity checker  of  (). The controller passes the parsed version of the name to the validity checker. The controller also may provide other information describing the name, such as the statistics that were identified from the NDO, to the validity checker. The validity checker performs one or more tests that examine characteristics of the parsed version of the name. The results of the tests are combined into an overall indication of the validity of the parsed name, such as a validity score. The controller receives the indication of the validity of the parsed name from the validity checker.","The controller determines whether the parsed version of the name is valid (). More particularly, the controller determines whether the indication of the validity of the parsed name indicates that the parsed name is valid. For example, if the indication of the validity of the parsed name is a validity score, the controller may determine that the parsed version of the name is valid when the validity score exceeds a threshold value. The threshold value may be user-specified and may be received when the name is received. In one embodiment, the threshold value is 0.65, or 65%.","If the parsed version of the name is not valid, then the controller reorders the name phrases of the name using the identified statistics and\/or the first or second parsing technique (). For example, the name phrases of the name may be reordered such that the name phrases that are titles appear first, followed in order by (i) the name phrases that are given names, (ii) the name phrases that are surnames, and (iii) the name phrases that are qualifiers. The name phrases may be classified as one of the possible types based on the identified statistics. For example, a name phrase may be classified as a given name when the identified statistics indicate that the name phrase typically appears as a given name either across all cultures or for a particular culture. The identified statistics may indicate that a name phrase typically appears as a given name when, for example, at least half of the names that include the name phrase include the name phrase as part of a given name.","A name may include multiple name phrases of the same type. In one embodiment, when multiple name phrases have the same type, the relative order of the multiple name phrases within the reordered name is not changed.","Referring to , parsing a name , \u201cJohnson James Arnold Jr. Dr.\u201d with five name phrases -initially may lead to an invalid parse. The statistics identified for the name phrases -may indicate (as shown in , below each name phrase) that the name phrase is a surname (SN), the name phrase is a given name (GN), the name phrase is a given name, the name phrase is a qualifier (Q), and the name phrase is a title (T). In such a case, the name phrases of the name , which originally appeared in the order \u201cJohnson James Arnold Jr. Dr.,\u201d may be reordered to appear in the order \u201cDr. James Arnold Johnson Jr.,\u201d as indicated in the reordered name . In the reordered name , titles appear before given names, which appear before surnames, which occur before qualifiers. In addition, the relative order of name phrases of the same type is maintained. For example, the relative order in the name of the name phrases and , which are both given names, is unchanged from the name ","When a name includes multiple name phrases that are given names or surnames, but does not include both a given name and a surname, the name is assumed to be complete. In other words, it is assumed that the name should include at least one name phrase that is a given name and at least one name phrase that is a surname. Therefore, the name phrases may be reordered such that at least one name phrase is classified as a given name, and such that at least one name phrase is classified as a surname. Doing so may increase the likelihood that a valid parse of the name may be identified.","For example, when the identified statistics indicate that all of the multiple name phrases are surnames, one of the multiple name phrases is classified as a given name. Dominance factors are calculated for the multiple name phrases. The dominance factors indicate the likelihood that the multiple name phrases are surnames. The name phrase with the lowest dominance factor has the greatest likelihood of being a given name, and that name phrase is included in the reordered name as a given name. If more than one of the multiple name phrases share the lowest dominance factor, then the name phrase with the lowest dominance factor that appears first in the name is classified as a given name. Similar classifications are made when the identified statistics indicate that all of the multiple name phrases are given names.","For example, the statistics table  indicates that the three name phrases of the name \u201cSmith Kim Stephenson\u201d are surnames. Moreover, the statistics table  indicates that the dominance factor of \u201cSmith\u201d is 0.996, that the dominance factor of \u201cKim\u201d is 0.892, and that the dominance factor of \u201cStephenson\u201d is 0.982. Because \u201cKim\u201d has the lowest dominance factor, to some extent because \u201cKim\u201d appears as a given name more often than \u201cSmith\u201d or \u201cStephenson\u201d appear as given names, \u201cKim\u201d is classified as a given name. Because given names are placed before surnames in the reordered name, and because the relative order of the name phrases is otherwise maintained, the reordered name is \u201cKim Smith Stephenson.\u201d In another embodiment, the name phrases may be ordered based on corresponding dominance factors. For example, name phrases may be included in order of increasing dominance factors. In such a case, the reordered name becomes \u201cKim Stephenson Smith.\u201d Because \u201cKim\u201d appears first in the reordered name, \u201cKim\u201d is classified as a given name. As another example, a name may include three name phrases, and all three name phrases may be given names. In such a case, one of the given names is classified as a surname, similarly to how a surname was classified as a given name in the above example.","In another embodiment, the name phrases may be reordered arbitrarily. In other words, the name phrases may be placed in an order in which the name phrases have not previously been placed for parsing. Such reordering of the name phrases does not require classification of the name phrases as one of the possible types.","In another embodiment, only a subset of the name phrases may be reordered, based on a determined validity of a parsed version of the name, or on statistics gathered in the parsing process. For example, the statistics may indicate that two name phrases appear to be reversed. In such a case, the positions of the two name phrases may be reversed, and the other name phrases may remain in place.","After the name phrases of the name have been reordered, the name phrases and the identified statistics are parsed again (, , ). A new parsed version of the name that is identified by the parsing technique typically classifies the name phrases of the name into the possible types that were indicated by the reordered name phrases. For example, the name phrases that appear first typically are classified as titles, the next name phrases as given names, the next name phrases as surnames, and the next name phrases as qualifiers. Rather than parsing the name phrases again to classify the name phrases, the name phrases may be classified directly into the possible types that were indicated by the reordered name phrases.","The controller may determine whether the new version is valid (, ). If the new version also is not valid, then the name phrases may be reordered again (), and the name may be parsed again with the culture-specific parsing technique (, , ). In this manner, a name may be repeatedly parsed until a valid parse of the name is identified. However, in typical embodiments, parsing the name more than twice does not identify a parsed version of the name that is different from the parsed version of the name identified by the second parse of the name.","If a subsequent parsed version of the name does not differ from a previous parsed version of the name, then the name might not be parsed again, and a previously identified parsed version of the name that is the most valid may be identified as an appropriate parse of the name. Furthermore, if the validity of a subsequent parsed version does not improve over the validity of a previous parsed version, then the name might not be parsed again, and a previously identified parsed version of the name that is the most valid may be identified as an appropriate parse of the name. For example, if a validity score of the subsequent parsed version is not greater than the validity score of the previous parsed version, then the name might not be parsed again. In such a case, a technically invalid parsed version of the name may be produced. In typical embodiments, the previously identified parsed version of the name that is most valid is the first parsed version of the name.","If the parsed version of the name is valid (), then the controller provides the parsed version of the name to the input\/output module (). More particularly, the controller provides the input\/output module with indications of the name phrases of the name that are included in the title, the given name, the surname, and the qualifier in the parsed version of the name. In some embodiments, the controller may provide only a portion of the parsed version of the name to the input\/output module. For example, the controller may provide only the given name and the surname of the parsed name to the input\/output module. In some embodiments, the controller may provide the parsed version of the name to the input\/output module when the parsed version of the name is not valid. The controller may do so, for example, if a name is not to be reparsed automatically in response to an invalid parse. If the name has been parsed multiple times, the controller may provide the multiple parsed versions of the name to the input\/output module. A recipient of the multiple parsed versions from the input\/output module may select one of the multiple parsed versions for use.","In addition, the controller may provide statistics describing the parsed version of the name to the input\/output module (). For example, the controller may provide the statistics retrieved from the NDO for each of the name phrases included in the parsed version of the name. As another example, the controller may provide an indication of the validity of the parsed version of the name. In embodiments where the input\/output module is a UI for the name processing application, the input\/output module may present the parsed version of the name and the statistics with the UI. In embodiments where the input\/output module implements an API to the name processing application, the input\/output module may provide the parsed version of the name and the statistics as returned values from the method or function that was invoked to indicate that the name should be parsed.","As an example, the process  may be used to parse the name \u201cKim Jae Dong.\u201d The controller receives the name from the input\/output module (). The controller uses the classifier to identify a culture of the name, which is Korean in this case (). The controller uses the name phrase identifier to determine that the name includes three name phrases, \u201cKim,\u201d \u201cJae,\u201d and \u201cDong\u201d (). The controller retrieves statistics for the three name phrases from the NDO (). The statistics may be culture-specific statistics (for example, from the statistics table ) or combined statistics (for example, from the statistics table ). For example, as indicated in row of the statistics table , the name phrase \u201cKim\u201d occurs as a title in 0 Korean names, as a given name in 161,181 Korean names, as a surname in 1,337,953 Korean names, and as a qualifier in 0 Korean names. Therefore, as a Korean name, \u201cKim\u201d is typically a surname. As indicated in row , the name phrase \u201cJae\u201d occurs as a title in 0 Korean names, as a given name in 171,766 Korean names, as a surname in 1824 Korean names, and as a qualifier in 0 Korean names. Therefore, as a Korean name, \u201cJae\u201d is typically a given name. As indicated in row , the name phrase \u201cDong\u201d occurs as a title in 0 Korean names, as a given name in 82,426 Korean names, as a surname in 10,557 Korean names, and as a qualifier in 0 Korean names. Therefore, as a Korean name, \u201cDong\u201d is typically a given name.","The controller parses the name phrases using the identified statistics and a parsing technique that is specific to the Korean culture (). The technique may be a technique that parses only Korean names, or that parses all Asian names. However, such techniques may not be available to the controller, so the controller passes the name phrases and the identified statistics to a generic technique for parsing names from all cultures. The generic technique uses the statistics to generate a parsed version of the name. The parsed version may indicate that the given name is \u201cKim Jae\u201d and that the surname is \u201cDong.\u201d The controller identifies a validity score for the parsed version of the name (). Because \u201cKim\u201d is found in the given name and \u201cDong\u201d is found in the surname, the parsed version of the name may be given a low validity score, as described earlier. As a result, the controller may determine that the parsed version of the name is invalid ().","In certain embodiments, a Korean given name, such as \u201cEUN GYUNG\u201d, is broken down into single name tokens so that EUN would get a count of 1 and GYUNG would get a count of 1. Korean and Chinese given names, however, are almost always two-token names, and the two tokens go together as a unit. EUN or GYUNG may combine with other elements to create a completely different name. Thus, in certain embodiments, the parser parses certain names (e.g., Korean and Chinese names) to assign a count of one to a two-token name. For example, the name EUN GYUNG now gets a count of 1 (rather than counting the two tokens separately). The parser makes use of this new information by first checking to see if a multi-token name is possible before examining the given name-surname distribution of the individual tokens.","The controller then reorders the name phrases (). Because, \u201cJae\u201d and \u201cDong\u201d typically are found in given names, \u201cKim\u201d typically is found in surnames, and given names typically appear before surnames (in the culture in which the controller is being used), the controller may reorder the name phrases such that \u201cJae\u201d appears first, \u201cDong\u201d appears second, and \u201cKim\u201d appears third. The name is reparsed, and the new parsed version of the name may indicate that the given name is \u201cJae Dong\u201d and that the surname is \u201cKim\u201d (). The controller identifies a validity score for the new parsed version (). Because the three name phrases appear in fields of the new parsed version in which they typically appear, the new parsed version of the name may be given a high validity score. As a result, the controller may determine that the parsed version of the name is valid (). The controller provides the parsed version of the name to the input\/output module (). The controller also may provide statistics describing the parsed version of the name to the input\/output module ().",{"@attributes":{"id":"p-0216","num":"0228"},"figref":"FIG. 17","b":["1500","902","1710","1710","1710","1710","1720","1730","1770","1730","1740","1750","1760","1770","1730","1760"],"i":["a","j ","a","j "]},"Each of the parsed names is represented by a row -in the table , and each of the names -correspond to one or more of the rows -. An arrow between one of the names -and one of the rows -indicates that the row represents a parsed version of the name.","An empty cell in one of the rows -indicates that a corresponding one of the names -does not include a name phrase of a type corresponding to the column of the empty cell. For example, the cell in the row and the column  is empty because the corresponding name does not include a title.","Several of the names -have been parsed into given names and surnames that include multiple name phrases. Furthermore, each of the multiple name phrases may include multiple tokens, such as a name stem and one or more prefixes or suffixes. For example, the name , \u201cSra. Maria del Carmen Bustamante de la Fuente\u201d has been parsed into a given name that includes two name phrases and a surname that includes two name phrases. The given name \u201cMaria del Carmen\u201d includes the name phrases \u201cMaria\u201d and \u201cdel Carmen,\u201d and \u201cdel Carmen\u201d includes the name stem \u201cCarmen\u201d and the prefix \u201cdel.\u201d Similarly, the surname \u201cBustamante de la Fuente\u201d includes the name phrases \u201cBustamante\u201d and \u201cde la Fuente,\u201d and \u201cde la Fuente\u201d includes the name stem \u201cFuente\u201d and the prefixes \u201cde\u201d and \u201cla.\u201d","Most of the validity scores listed in the validity score column  exceed a minimum allowable validity score for corresponding parsed names to be valid, which may be 65%. Several of the names -may have been parsed multiple times to identify parsed versions of the names with sufficiently high validity scores. Consequently, name phrases of those names were reordered each time the name was to be reparsed. In an embodiment producing the results of the table , the name , \u201cSmith James\u201d was parsed initially with \u201cSmith\u201d as the given name and \u201cJames\u201d as the surname. Such a parse of the name may lead to a low validity score, because \u201cSmith\u201d typically is found in surnames and \u201cJames\u201d typically is found in given names. In the embodiment, the name phrases of the name may be reordered and reparsed such that \u201cJames\u201d becomes the given name and \u201cSmith\u201d becomes the surname, as indicated in the row . Such a parse of the name has a higher validity score of 93%.","However, all names in which a surname appears before a given name are not parsed multiple times. For example, the row indicates that the surname appears before the given name in the name , and the row indicates that the surname appears before the given name in the name . A parsing technique used to parse the Asian names, of which the names and are examples, may recognize this typical structure and may correctly parse the names and such that sufficiently high validity scores of 68% and 92% are initially achieved.","Furthermore, some of the validity scores listed in the validity score column  do not exceed the minimum allowable validity score, even though the corresponding names were parsed multiple times. For example, the validity score for the parsed name in row is 58%, which is less than the minimum allowable validity score, even though the name was parsed multiple times. In an embodiment producing the results of the table , an initial parse of the name indicated that \u201cKees Andries\u201d is the given name and that \u201cVan Der Merve\u201d is the surname, and such a parse received a validity score of 58%. In the embodiment, reordering the name phrases of the name and reparsing the reordered name did not improve the validity score, so the initial order of the name phrases in the name is relied upon when identifying the initial parse as the better parse of the name ","The names and are examples of conjoined name constructs. A conjoined name construct is a string that indicates multiple names that are joined by conjunctions. A conjoined name is one of the multiple names that are indicated by the conjoined name construct. For example, each of the names and indicates two conjoined names. Other examples of conjoined name constructs include \u201cJohn and Mary Smith,\u201d \u201cMr. and Mrs. John and Mary Smith,\u201d and \u201cJohn and Mary Smith and Robert Jones.\u201d Typically, the number of surnames or given names in a conjoined name construct is less than the number indicated conjoined names. For example, the name indicates two conjoined names, but includes only one surname. When a conjoined name construct is parsed, a parsed version of each conjoined name indicated by the conjoined name construct is produced. For example, when the name is parsed, parsed names represented by the rows and are produced. Similarly, when the name is parsed, parsed names represented by the rows and are produced.","Referring to , a conjoined name construct , \u201cDr. and Mrs. John and Mary Jones, Jr.,\u201d indicates a name , \u201cDr. John Jones, Jr.,\u201d includes one or more tokens or punctuation marks that indicate multiple conjoined names that may be extracted from the conjoined name construct. The tokens may be conjunctions, such as \u201cand\u201d or \u201cor,\u201d and the punctuation marks may include, for example, an ampersand, a comma, or a semicolon. Such tokens may be referred to as separating elements of the conjoined name construct, because they may be used to separate the conjoined name construct into multiple indicated conjoined names.","The separating elements included in the conjoined name construct  may be used to extract two conjoined names and from the conjoined name construct . More particularly, the name phrases included in the conjoined name construct  are identified, for example, with the name phrase identifier  of . The identified name phrases do not include any of the separating elements included in the conjoined name construct . Each of the identified name phrases is classified as one of the possible types, for example, using statistics from the NDO  of . The classification of the name phrases and the locations of the separating elements indicate how the conjoined name construct is to be separated into the multiple conjoined names.","For example, if the name phrases on either side of a separating element are both titles (e.g., \u201cMrs. and Mrs. John Smith, Jr.\u201d), then each title is grouped with the other given names, surnames, and qualifiers of the conjoined name construct (e.g., \u201cMr. John Smith, Jr.\u201d and \u201cMrs. John Smith, Jr.\u201d). As another example, when a separating element is preceded by a surname or a qualifier, and the separating element is followed by title or a given name (e.g., \u201cJohn Smith, Jr. and Mary Jones\u201d), then the separating element is assumed to be separating two complete conjoined names (e.g., \u201cJohn Smith, Jr.\u201d and \u201cMary Jones\u201d).","As yet another example, if the name phrases on either side of a separating element are given names, (e.g., \u201cJohn and Mary Smith, Jr.\u201d), then each given name is grouped with the other surnames and qualifiers of the conjoined name construct (e.g., \u201cJohn Smith, Jr.\u201d and \u201cMary Smith, Jr.\u201d). Conjoined names are identified similarly if multiple name phrases on either side of the separating element are given names (e.g., \u201cJohn Peter and Mary Smith, Jr.\u201d yields \u201cJohn Peter Smith, Jr.\u201d and \u201cMary Smith, Jr.\u201d).","Furthermore, if the one or more given names on one side of the separating element is preceded or followed by a title (e.g., \u201cMr. John and Mary Smith, Jr.\u201d), then the one or more given names and their associated title are grouped with the other surnames and qualifiers of the conjoined name construct (e.g., \u201cMr. John Smith, Jr.\u201d and \u201cMary Smith, Jr.\u201d). As another example, \u201cMr. John and Mrs. Mary Smith, Jr.\u201d yields \u201cMr. John Smith, Jr.\u201d and \u201cMrs. Mary Smith, Jr.\u201d Rules may be also applied to the examine the parsed names for common exceptions, such as, for example, changing \u201cMary Smith., Jr.\u201d to \u201cMary Smith\u201d.","The above rules for identifying conjoined names from a conjoined name construct may be extended to apply to conjoined name constructs that include multiple separating elements. For example, the rule for separating a conjoined name construct that includes given names on either side a separating element may be extended to apply to separating a conjoined name construct that includes three or more given names that are separated by two or more separating elements (e.g., \u201cTom, Dick and Harry Smith\u201d). In such a case, each given name is grouped with the other surnames and qualifiers of the conjoined name construct (e.g., \u201cTom Smith,\u201d \u201cDick Smith,\u201d and \u201cHarry Smith\u201d).","Other rules are specific only to conjoined name constructs that include multiple separating elements. For example, if name phrases on either side of a first separating element are titles, and if name phrases on either side of a second separating element are given names, as is the case in the conjoined name construct , the conjoined name construct represents a parallel construction. In such a case, the first title is grouped with the first given name, as well as the other surnames and qualifiers of the conjoined name construct, and the second title is grouped with the second given name and the other surnames and qualifiers, as is indicated by the names and ","As another example, in conjoined name constructs with multiple separating elements, a determination of whether a particular one the separating elements is separating two complete conjoined names, each of which may represent a conjoined name construct themselves, is made. If that is the case, then the name is separated into the two conjoined names at the particular separating element. Each of the two conjoined names is processed recursively to determine whether the conjoined name represents a conjoined name construct, and, if so, to identify the conjoined names that are indicated by the conjoined name construct, using the rules described above. For example, in the name \u201cJohn and Mary Smith and Bob and Linda Jones,\u201d the second \u201cand\u201d separates two conjoined names, \u201cJohn and Mary Smith\u201d and \u201cBob and Linda Jones.\u201d Both of the conjoined names include a separating element (e.g., \u201cand\u201d), so both of the conjoined names represent conjoined name constructs. Therefore, the two conjoined names are processed using the above rules to determine that the original conjoined name construct indicated four conjoined names, \u201cJohn Smith,\u201d \u201cMary Smith,\u201d \u201cBob Jones\u201d and \u201cLinda Jones.\u201d","The above rules do not require that titles appear before given names in the conjoined name construct, that given names appear before surnames, or that surnames appear before qualifiers to identify the indicated conjoined names. However, when grouping the name phrases into the conjoined names, titles appear first, followed by given names, surnames, and qualifiers. Therefore, the conjoined name construct \u201cSmith John Mr. and Mrs.\u201d yields the conjoined names \u201cMr. John Smith\u201d and \u201cMrs. John Smith.\u201d Furthermore, when grouping name phrases of the conjoined name construct to form the conjoined names, the order of name phrases of the same type in the conjoined name construct is maintained in the conjoined names.","After the conjoined names have been identified, each of the conjoined names is parsed. For example, parsing techniques that are specific to cultures of each of the conjoined names may be used to parse the conjoined names. As a result, name phrases of the conjoined names are parsed into each of the possible element types. For example, the names and are parsed individually to produce parsed names and , respectively. The parsed names and include titles and , given names and , surnames and , and qualifiers and , respectively.","Referring to , a parsing interface  enables a user to specify one or more personal names to be parsed and to view parsed versions of the personal names. The interface  also enables the user to specify values for one or more parameters to control how the names are parsed. The parsing interface  may represent an input\/output module of a name processing application, such as the input\/output module  of the name processing application .","The parsing interface includes an input field  into which one or more names to be parsed are entered. Multiple individual names may be entered into the input field  if they are separated by particular punctuation marks, such as a comma or a semicolon. In addition, one or more conjoined name constructs may be entered into the input field . In the illustrated interface , the conjoined name construct \u201cDr. William Frederic and Mrs. Elizabeth Wilson de la Tour III, Esq.\u201d has been entered into the input field .","Selecting a parse button  signals for the names included in the input field  to be parsed. In other words, selecting the parse button  passes the names to be parsed to a parsing controller of the name processing application, such as the parsing controller . The parsing controller uses other components of the name processing application to create parsed versions of the names. The parsed versions are passed to the input\/output module and displayed in an output field . The output field  is a table that includes columns for titles, given names, surnames, and qualifiers of the parsed names. Each of the parsed names is given a row in the table, and the components of the parsed names are spread among the columns accordingly. For example, two conjoined names were indicated by the conjoined name construct that was entered into the input field , so two parsed names are displayed in the output field . The first parsed name has \u201cDr.\u201d as a title, \u201cWilliam Frederic\u201d as a given name, \u201cWilson de la Tour\u201d as a surname, and \u201cIII, Esq.\u201d as a qualifier, and the second parsed name has \u201cMrs.\u201d as a title, \u201cElizabeth\u201d as a given name, \u201cWilson de la Tour\u201d as a surname, and \u201cIII, Esq.\u201d as a qualifier. Each row also includes an indication of the validity score or confidence of the corresponding parsed name. In the illustrated interface , both parsed names have validity scores of 95%, which indicates that the parsed names are considered to be valid.","A reorder checkbox  enables the user to indicate that name phrases of a name that has been entered into the input field  should be reordered and reparsed automatically when a previous parse of the name has a validity score below a threshold value. The threshold value may be specified in a text field . In one embodiment, the user may specify the threshold value in the text field  only after the checkbox  has been selected. A reorder button  enables a user to indicate manually that a name should be reparsed. For example, the user may view a parsed version of a name and an associated validity score in the results field . After manually determining that the parse is invalid because the validity score is too low, the user may select the reorder button  to reorder the name phrases of the name, to reparse the name, and to receive another parse of the name.","A parse tree button  causes an interface displaying a parse tree for a parsed name that has been selected from the results field  to be displayed. The parse tree indicates the types of name phrases in the parsed name, as well as components of the included name phrases. The parse tree also indicates numbers of names in which the name phrases appear as given names and surnames, as indicated by a corresponding NDO, such as the NDO .","Referring also to , an interface  displays a parse tree  for the first parsed name listed in the results field . Only a portion of the parse tree  is visible in the interface . More particularly, the parse tree  indicates the name phrases, and the components thereof, that are included in the given name and the surname of the parsed name.","The parse tree  indicates that the given name \u201cWilliam Frederic\u201d includes two name phrases. The name phrase \u201cWilliam\u201d is included in 700,555 names as a given name, and in 6,910 names as a surname. The name phrase includes a single component, namely the name stem \u201cWilliam.\u201d Similarly, the parse tree  indicates that the surname \u201cWilson de la Tour\u201d includes two name phrases. The name phrase \u201cWilson\u201d has only one component, and the name phrase \u201cde la Tour\u201d has three components. The parse tree  indicates that \u201cTour\u201d is the name stem for the second name phrase, and that \u201cde\u201d and \u201cla\u201d are prefixes to the name stem. Invisible portions of the parse tree  indicate that the title includes a single name phrase that includes a single title (e.g., \u201cDr.\u201d). In addition, the invisible portions of the parse tree  indicate that the qualifier includes two name phrases, each of which includes a single qualifier (e.g., \u201cIII\u201d and \u201cEsq.\u201d).","Referring again to , a transformed text checkbox  enables a user to indicate that the parsed names should be presented in the results field  without formatting. For example, when the checkbox  is selected, the parsed names may be presented in the results field  in uppercase letters without punctuation, accents, or noise characters, or characters that are not included in the parsed names. Presenting or providing the parsed names without formatting may enable the parsed name to be viewed or used by users or systems that are not configured to recognize the formatting.","A custom tokens button  enables a user to specify additional tokens or name phrases to be added to the NDO used by the name processing application. When the custom tokens button  is selected, an interface with which the user may specify the additional tokens or name phrases is displayed. The interface enables the user to specify a name phrase, numbers of names in which the name phrase is each of the possible types, as well as a comment for the name phrase. In addition, the interface also enables specification of one or more noise filters. A noise filter includes words that are ignored when included in names being parsed. A noise filter may indicate that words that typically are not included in names be ignored. For example, when parsing the name \u201cThomas P. \u201cTip\u201d O'Neill, Jr.,\u201d a noise filter may indicate that words within quotation marks (e.g., \u201cTip\u201d), which typically represent nicknames, are to be ignored.","A help button  enables a user to receive help when using the interface . Selecting the button  causes a help interface that describes how to use the interface  to be displayed to the user. A close button  dismisses the interface  when selected.","Referring also to , name phrases of a name entered into the input field  of the interface  may be reordered to correctly parse the name. For example, the name \u201cStephenson Peter\u201d has been entered into the input field . That name includes two name phrases, namely \u201cStephenson\u201d and \u201cPeter,\u201d and each of the name phrases is typically found in English names. In English names with two name phrases, the first name phrase typically is a given name, and the second name phrase typically is a surname. Therefore, the name may be parsed such that \u201cStephenson\u201d is the given name and \u201cPeter\u201d is the surname, as in indicated in the results field .","However, row of the statistics table  and row of the statistics table  indicate that the name phrase \u201cStephenson\u201d appears more frequently as a surname. In addition, row of the statistics table  indicates that the name phrase \u201cPeter\u201d appears more frequently as a given name. Therefore, the initial parse of the name that is listed in the results field  may be invalid, as is indicated by the relatively low confidence or validity score (1%) assigned to the initial parse.","Referring to , selecting the reorder button  rearranges the two name phrases of the name \u201cStephenson Peter.\u201d Because the name includes only two name phrases, the name may be reordered in only one manner, and the name is parsed as if entered originally as \u201cPeter Stephenson.\u201d Using the conventional rules for English names, \u201cPeter\u201d is identified as the given name, and \u201cStephenson\u201d is identified as the surname, as is indicated in the results field . This is corroborated by the information included in the statistics tables  and , which results in the high validity score of 98% assigned to the parsed name.","Referring to , an alternative process  also may be used to parse culturally diverse names. The process  is similar to the process . The process  may be executed by a name processing application, such as the name processing application .","The name processing application enables access to multiple culture-specific parsing techniques (). Each of the culture-specific parsing techniques parses names of one or more corresponding cultures. For example, a German parsing technique may parse German names, while an Asian parsing technique may parse Chinese, Japanese, and Korean names.","The name processing application receives a name that includes one or more elements (). The name may be received, fox example, from a UI for the name processing application, or through invocation of a method of an API that is implemented by the name processing application.","The name processing application accesses an indication of a culture of the name (). The name processing application may identify the culture based on at least one characteristic of the name. The name processing application selects one of the multiple culture-specific parsing techniques (). More particularly, the name processing application selects the culture-specific parsing technique that corresponds to the indicated culture. For example, if the indicated culture is German, the technique for parsing German names may be selected. As another example, if the indicated culture is Korean, the technique for parsing Asian names may be selected.","The name processing application parses the one or more elements of the name into element types using the selected parsing technique (). More particularly, the name processing application classifies each of the elements of the names as one of the possible types. The classification of the elements may be based on characteristics of names of the indicated culture. The classification also may be based on statistics describing the elements of the name, such as the information that is accessible from the NDO  of .","The name processing application provides an indication of the element types of the one or more elements (). The name processing application may provide the indication of the element types through the UI or API from which the name was received.","Referring to , a process  is used to identify valid parses of names. If a valid parse of a name is not identified initially, the name may be parsed again. The process  may be executed by a name processing application, such as the name processing application .","The name processing application receives a name that includes one or more elements (). The name may be received, fox example, from a UI for the name processing application, or through invocation of a method of an API that is implemented by the name processing application.","The name processing application parses the one or more elements into element types (). More particularly, the name processing application may parse each of the elements of the names as one of the possible types. The classification may be based on statistics describing the elements of the name, such as the information that is accessible from the NDO  of . The name processing application may parse the one or more elements with or without reference to a culture of the name. If the elements are parsed with reference to the culture, the elements may be parsed using a technique that parses names of the culture based on characteristics of names of the indicated culture.","The name processing application determines whether the element types of the one or more elements represent a valid parse of the name (). The name processing application may make such a determination by identifying a validity score for the parsed version of the name. In one embodiment, the name processing application uses a validity checker, such as the validity checker  of , to identify the validity score. A validity score that exceeds a threshold (or a previous score) may indicate that the parsed version is valid, and a validity score that is less than or equal to the threshold (or a previous score) may indicate that the parsed version is not valid.","The name processing application provides an indication of whether the element types of the one or more elements represent a valid parse of the name (). The name processing application may provide the indication of the element types through the UI or API from which the name was received.","The name processing application also may parse the one or more elements of the name into element types again when the element types do not represent a valid parse of the name (). Before doing so, the name processing application may reorder the elements of the name, as described above. After the elements have been parsed again, the name processing application may determine whether the new parse of the name is valid (). In this manner, the name may be parsed repeatedly until, for example, a valid parse is identified, or until a new parse that is more valid that a previous parse is not identified.","The NDO  is described throughout as including, for each name phrase that appears in a set of names, numbers or counts of the names that include the name phrase as each of the possible types of name phrases. However, in another embodiment, the NDO may include percentages of the names in the set that include the name phrase in general. In addition, the NDO may maintain percentages of the names that include the name phrase in general that include the name phrase as each of the possible types. In another embodiment, the NDO may maintain other indications of the frequency with which the name phrase appears in general and as each of the possible types in the set of names.","The described techniques may be applied in batch mode processing of a set of names. In other words, multiple names may be parsed without receipt of a separate indication from the user that each of the names should be parsed. For example, an input file may include a list of names to be parsed. In response to a single action by the user, the described techniques may be used to individually parse each name in the input file. Parsed versions of each name may be listed in an output file that the user may access. In one embodiment, the user may be enabled to specify a format in which the names to be parsed are specified in the input file, or a format in which the parsed names are listed in the output file. The user also may indicate whether names are to be reparsed automatically when a previous parse is invalid. The user also may be enabled to specify custom name phrases to be added to the NDO that is used to parse the names included in the input file.","Certain embodiments for parsing names enable access to multiple parsing techniques for parsing name elements into one or more types of elements, the multiple parsing techniques including separate parsing techniques that respectively correspond to at least one of multiple known cultures; receive a name that includes one or more elements; receive from a user an indication that the name is to be reparsed automatically when a previous parse is invalid; access, for the name, an indication of at least one culture from among the multiple known cultures; select one of the multiple parsing techniques based on the indication of the culture of the name, wherein the multiple parsing techniques include culture-specific first parsing techniques and the culture-specific second parsing techniques; parse the one or more elements of the name into element types using the selected parsing technique; determine whether the element types represent a valid parse of the name by determining a validity score for the parsing of the one or more elements by performing multiple validity tests and combining results from the multiple validity tests, wherein the multiple validity tests include a test to measure conformity of the parsed one or more elements of the name to other names of a same culture as the parsed one or more elements of the name; and, in response to determining that the validity score indicates that the element types do not represent a valid parse of the name, reorder the one or more elements using statistical indications, wherein the one or more elements are reordered with an order of: titles, given names, surnames, and qualifiers, wherein each of the one or more elements are classified as one of a title, a given name, a surname, and a qualifier based on the statistical indications and reparse the reordered one or more elements into element types using the selected parsing technique, wherein determining the validity score, reordering, and reparsing the reordered one or more elements occurs until it is determined that the parsing resulted in a valid parse of the name or that reparsing is not to be done.","In certain embodiments, accessing the indication of the culture of the name includes detecting a characteristic of at least one of the elements of the name and determining the indication of the culture of the name based on the characteristics detected.","In certain embodiments, a database providing a statistical indication of a type of an element is accessed, and parsing is based on the statistical indication.","In certain embodiments, the validity score is compared to a threshold, and it is determined whether to reorder the one or more elements based on a result from the comparing.","In certain embodiments it is determined to reorder the one or more elements based on the validity score, a database providing the statistical indications of the types of the one or more elements is accessed, and the one or more elements are reordered using the statistical indications.","In certain embodiments an indication of the validity score is provided.","In certain embodiments, parsing the one or more elements of the name into element types includes classifying each of the one or more elements as a title, a given name, a surname, or a qualifier.","In certain embodiments providing statistics describes at least one of the one or more elements of the name.","In certain embodiments, receiving the name comprises receiving a personal name.","Certain embodiments for identifying a valid parse of a name receive a name that includes one or more elements. The one or more elements of the name are parsed into element types by: enabling access to multiple parsing techniques for parsing the one or more elements of the name into the element types, the multiple parsing techniques including separate parsing techniques that respectively correspond to at least one of multiple known cultures, wherein the multiple parsing techniques include culture-specific first parsing techniques and the culture-specific second parsing techniques; accessing, for the name, an indication of at least one culture from among the multiple known cultures; and selecting one of the multiple parsing techniques based on the indication of the culture of the at least one name, wherein parsing the one or more elements of the name comprises parsing the one or more elements using the selected parsing technique. It is determined whether the element types of the one or more elements represent a valid parse of the name by performing multiple validity tests to determine whether the parse of the name is valid and combining results from the multiple validity tests to generate a validity score for the element types, wherein at least one of the multiple validity tests identifies a dominance factor for one element of the one or more elements included in the parsed name, wherein the dominance factor indicates a ratio of names in a set of names that include the one element as a particular type to names in a set that include the one element as any of multiple possible types. In response to determining that the validity score indicates that the element types do not represent a valid parse of the name, the one or more elements are reordered using statistical indications in order of increasing dominance factors of the one or more elements and the reordered one or more elements are reparsed into element types using the selected parsing technique, wherein determining the validity score, reordering, and reparsing the reordered one or more elements occurs until it is determined that the parsing resulted in a valid parse of the name or that reparsing is not to be done.","Certain embodiments for processing a name receive an indication of a name that includes multiple tokens; access an indication of a culture of the name; identify one or more name phrases included in the name based on the culture of the name, at least one of the identified name phrases having more than one token, by grouping the tokens into name phrases based on a classification of the tokens and the culture of the name; designate the identified name phrases as an input to a subsequent name processing operation; and process the name using the identified name phrases as an input to the subsequent name processing operation, including classifying each of the identified name phrases as one of a title, a given name, a surname, and a qualifier and grouping multiple name phrases that have a same type within the name in an order in which the multiple name phrases appear in the name. Processing the name includes: determining whether the one or more name phrases represent a valid parse of the name by determining a validity score by performing multiple validity tests, wherein the multiple validity tests include a test to measure conformity of the parsed name to other names of a same culture as the parsed one or more name phrases, a test to identify a dominance factor that indicates a ratio of names in a set of names that include a name phrase as a particular type to names in a set that include the name phrase as any of multiple possible type for the one or more name phrases, and a test that determines whether an order in which the one or more name phrases appear in the parsed name is an order in which the one or more name phrases typically appear based on characteristics of names of the culture of the parsed name; and, in response to determining that the one or more name phrases do not represent a valid parse of the name, reordering the one or more name phrases, wherein the one or more elements are reordered with an order of: titles, given names, surnames, and qualifiers, wherein each of the one or more elements are classified as one of a title, a given name, a surname, and a qualifier based on statistical indications and reparsing the reordered one or more name phrases, wherein determining the validity score, reordering, and reparsing the reordered one or more name phrases occurs until it is determined that the parsing resulted in a valid parse of the name or that reparsing is not to be done.","In certain embodiments, identifying the one or more name phrases includes classifying each of the multiple tokens in the name as a prefix, suffix, or stem based on the culture of the name.","Certain embodiments for parsing a conjoined name receive a conjoined name construct that includes multiple elements that are joined by a conjunction and include one or more punctuation marks, wherein one of the multiple elements is a surname, wherein the punctuation marks are capable of including an ampersand, a comma, and a semicolon; identify multiple names indicated by the conjoined name construct, each of the multiple names including the surname and one or more of the multiple elements, wherein the conjunction and the one or more punctuation marks are used to separate the conjoined name construct into the multiple names, wherein the identified multiple names do not include the conjunction and the one or more punctuation marks; and parse the one or more elements of at least one name of the multiple names into element types. Parsing includes enabling access to multiple parsing techniques for parsing the one or more elements of the at least one name into the element types, the multiple parsing techniques including separate parsing techniques that respectively correspond to at least one of multiple known cultures; accessing, for the at least one name, an indication of at least one culture from among the multiple known cultures; and selecting one of the multiple parsing techniques based on the indication of the culture of the at least one name, wherein parsing the one or more elements of the at least one name comprises parsing the one or more elements using the selected parsing technique. It is determined whether the element types represent a valid parse of the name by determining a validity score using the selected one of the multiple parsing techniques; and, in response to determining that the element types do not represent a valid parse of the name, the one or more elements are reordered using statistical indications, wherein the one or more elements are reordered with an order of: titles, given names, surnames, and qualifiers, wherein each of the one or more elements are classified as one of a title, a given name, a surname, and a qualifier based on the statistical indications, and the reordered one or more elements are reparsed into element types, wherein determining the validity score, reordering, and reparsing the reordered one or more elements occurs until it is determined that the parsing resulted in a valid parse of the name or that reparsing is not to be done.","In certain embodiments, access to multiple parsing techniques for parsing name elements into one or more types of elements is enabled, where the multiple parsing techniques include separate parsing techniques that respectively correspond to at least one of multiple known cultures; for the at least one name, an indication of at least one culture from among the multiple known cultures is accessed; and one of the multiple parsing techniques is selected based on the indication of the culture of the at least one name, wherein parsing the one or more elements of the at least one name comprises parsing the one or more elements using the selected parsing technique.","As will be appreciated by one skilled in the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.","Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, solid state memory, magnetic tape or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.","A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device.","Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.","Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package,","partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Aspects of the embodiments of the invention are described below with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational processing (e.g., operations or steps) to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","The code implementing the described operations may further be implemented in hardware logic or circuitry (e.g., an integrated circuit chip, Programmable Gate Array (PGA), Application Specific Integrated Circuit (ASIC), etc. The hardware logic may be coupled to a processor to perform operations.",{"@attributes":{"id":"p-0285","num":"0297"},"figref":"FIG. 25","b":["2500","100","900","2500","2500","2502","2504","2520","2504","2504","2505","2506"]},"Input\/Output (I\/O) devices ,  (including but not limited to keyboards, displays, pointing devices, etc.) may be coupled to the system either directly or through intervening I\/O controllers .","Network adapters  may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems, cable modem and Ethernet cards are just a few of the currently available types of network adapters .","The computer architecture  may be coupled to storage  (e.g., a non-volatile storage area, such as magnetic disk drives, optical disk drives, a tape drive, etc.). The storage  may comprise an internal storage device or an attached or network accessible storage. Computer programs  in storage  may be loaded into the memory elements  and executed by a processor  in a manner known in the art.","The computer architecture  may include fewer components than illustrated, additional components not illustrated herein, or some combination of the components illustrated and additional components. The computer architecture  may comprise any computing device known in the art, such as a mainframe, server, personal computer, workstation, laptop, handheld computer, telephony device, network appliance, virtualization device, storage controller, etc.","The flowchart and block diagrams in the figures illustrate the architecture, functionality, and operation of possible embodiments of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative embodiments, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.","The terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. As used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises\u201d and\/or \u201ccomprising,\u201d when used in this specification, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and\/or groups thereof.","The corresponding structures, materials, acts, and equivalents of all means or step plus function elements in the claims below are intended to include any structure, material, or act for performing the function in combination with other claimed elements as specifically claimed. The description of embodiments of the present invention has been presented for purposes of illustration and description, but is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art without departing from the scope and spirit of the invention. The embodiments were chosen and described in order to best explain the principles of the invention and the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated.","The foregoing description of embodiments of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the embodiments to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the embodiments be limited not by this detailed description, but rather by the claims appended hereto. The above specification, examples and data provide a complete description of the manufacture and use of the composition of the embodiments. Since many embodiments may be made without departing from the spirit and scope of the invention, the embodiments reside in the claims hereinafter appended or any subsequently-filed claims, and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["Referring now to the drawings in which like reference numbers represent corresponding parts throughout:",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 1A and 1B"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 8","FIG. 6"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIGS. 15A and 15B"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIGS. 21 and 22"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 25"}]},"DETDESC":[{},{}]}
