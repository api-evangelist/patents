---
title: Method and system for emulating a check sorter
abstract: A method for communicating between a check processing system and a non-compatible check sorter is provided that includes accessing a MICR buffer for the check sorter. The MICR buffer comprises MICR data retrieved from a check. A process buffer is generated based on the MICR buffer. The process buffer is standardized for a plurality of disparate types of check sorters. A plurality of feature instructions are received for the check based on the process buffer. The feature instructions are communicated to the check sorter for processing of the check.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06985617&OS=06985617&RS=06985617
owner: VECTORsgi, Inc.
number: 06985617
owner_city: Addison
owner_country: US
publication_date: 20000420
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["RELATED APPLICATION","TECHNICAL FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application Ser. No. 09\/553,228 is related to a co-pending application having a title of \u201cMethod and System for Online Communication Between a Check Sorter and a Check Processing System,\u201d filed Apr. 20, 2000.","This invention relates generally to the field of document processing in the financial industry and more particularly to a method and system for emulating a check sorter.","Within the financial industry, document processing is an important part of the daily management of a business. Document processing systems include sorters for physically handling and retrieving data from checks and other items and data processors for analyzing and storing the retrieved data. The sorters and data processors intercommunicate data and instructions to individually read and process each check.","Conventional check sorters for document processing, such as the IBM 3890 and 3890\/XP series of check sorters, are relatively large and expensive machines. Thus, purchasing one of these check sorters may place a great financial strain on a small business or may be unreasonable for a larger business needing to process a relatively small number of checks over the business' current capacity. Smaller and less expensive check sorters typically cannot communicate with existing data processing systems that are designed to operate in connection with the IBM 3890 and 3890\/XP series of check sorters. As a result, the smaller check sorters are not a viable solution in many applications.","Attempts to solve this problem have included customized emulators which allow a specific check sorter, which may be smaller and less expensive, to emulate the IBM 3890 and 3890\/XP series of check sorters so that the data processing system may communicate with the specific check sorter. However, these emulators are hardware-specific solutions. Thus, a different emulator must be designed, programmed and proved out for each different type of check sorter. This customization is time-consuming and expensive and is thus not a practical solution.","In accordance with the present invention, a method and system for emulating a check sorter are provided that substantially eliminate or reduce disadvantages and problems associated with previously developed systems and methods. In particular, a modular emulator for check sorters is provided that allows disparate types of check sorters to be managed by a common check processing system that is configured to work with a specific check sorter.","In one embodiment of the present invention, a method for communicating between a check processing system and a non-compatible check sorter is provided that includes accessing a MICR buffer for the check sorter. The MICR buffer comprises MICR data retrieved from a check. A process buffer is generated based on the MICR buffer. The process buffer is standardized for a plurality of disparate types of check sorters. A plurality of feature instructions are received for the check based on the process buffer. The feature instructions are communicated to the check sorter for processing of the check.","In another embodiment of the present invention, a system for handling checks is provided that includes a sorter, an emulator and a check processing system. The sorter is operable to retrieve MICR data from a plurality of checks. The emulator is coupled to the sorter. The emulator is operable to access the MICR data, to generate a process buffer based on the MICR data, and to generate a plurality of feature instructions based on the process buffer. The process buffer is standardized for a plurality of disparate types of check sorters. The check processing system is coupled to the emulator. The check processing system is operable to receive the process buffer from the emulator. The emulator is further operable to communicate the feature instructions to the sorter. The sorter is further operable to process the checks based on the feature instructions.","Technical advantages of the present invention include providing an improved method and system for emulating a check sorter. In particular, a modular emulator allows disparate types of check sorters to be managed by a common check processing system that is configured to work with a specific check sorter. Thus, the modular emulator provides a solution that is independent of one or both of the check sorter and the check processing system. As a result, a variety of smaller and less expensive check sorters may be used for excess capacity, by small businesses, or for other suitable uses.","Other technical advantages include the ability to image by item. In particular, for each check, the front and\/or the back of the check may be selected for imaging. In addition, for both the front and the back of each check, the image may be recorded in black and white, gray scale or color.","Other technical advantages will be readily apparent to one skilled in the art from the following figures, description, and claims.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["10","10","12","14","16","14","14","12","16","14","14","12","16","12","12","12","14"]},"The sorter  may be any one of a plurality of disparate types of suitable sorters. The modular emulator  thereby allows a check processing system  that is configured to communicate with a specific type of sorter to communicate with other types of sorters  that are not directly compatible. For the exemplary embodiment, the sorter  may comprise a sorter available from NCR, BancTec, Unisys, or Digital Check, or other sorter capable of reading and exchanging MICR data through standardized processes.","The sorter  comprises a MICR reader  for retrieving MICR data from the checks, an endorser  for endorsing checks, a microfilm camera  for recording microfilm images of checks, a digital camera  for recording digital images of checks and a plurality of pockets  for receiving sorted checks. The endorser  may endorse a check by printing endorsement information on the check. The endorsement information may comprise the name of the bank or other financial institution processing the check. The digital camera  may record an image of the front and\/or the back of each check and may record these images in black and white, gray scale and\/or color. Thus, different imaging data may be obtained for different checks. For example, the digital camera  may record a black and white image of the front of a first check and a gray scale image of the back of the first check and may record a color image of the front and the back of a second check. It will be understood that the digital camera  may comprise one or more devices for recording digital images of checks being processed by the system .","The sorter  also comprises a shared memory  that is shared with the emulator  and that comprises a MICR buffer . As described in more detail below in connection with , the MICR buffer  comprises the MICR data retrieved from the checks by the MICR reader . The MICR buffer  may be a copy or adaptation of the retrieved data. The MICR data in the MICR buffer  is thus in a format that is specific to the particular sorter  and need not be customized for the system .","The sorter  also comprises an interface  for interpreting emulator data provided by the emulator . This emulator data may comprise feature instructions for the sorter  regarding the features of the endorser , the microfilm camera, the digital camera  and the pockets . The interface  may be device-specific and maps instructions from the emulator  domain to the sorter  domain. Thus, based on the emulator data, the interface  determines for each check whether or not to endorse the check, record a microfilm image of the check and record a digital image of the check. The interface  also determines for each check which digital images and what types of digital images to record, if any, and which pocket  is to receive the check.","The emulator  comprises an emulator application programming interface (API) , a communication engine  and a code-executing emulator  for executing code provided by the check processing system  that is programmed in a language specific to the sorter compatible with the check processing system . For the embodiment in which the compatible sorter comprises an IBM 3890 series sorter, the code-executing emulator  comprises a stacker control instructions (SCI) emulator . The emulator  may be compiled for execution on a Windows NT, OS\/2, or other suitable platform.","The sorter  transmits a message to the API  for each check being processed by the sorter . The API  may then access the shared memory  to retrieve the MICR data for the check from the MICR buffer . Alternatively, the sorter  may pass the MICR buffer  to the emulator  for processing. The API  converts the MICR buffer  into a standardized process buffer  by reformatting the MICR data into a format that may be processed by the check processing system . The process buffer  is standardized in that the format of the process buffer  is the same regardless of the format of the MICR buffer  for the sorter . In one embodiment, the standardized process buffer  is in the same format as the data provided by a compatible sorter with which the check processing system  is designed to operate. In this embodiment, the emulator  emulates the compatible sorter for the check processing system . Thus, for the embodiment in which the compatible sorter comprises an IBM 3890 series sorter, the API  converts the MICR buffer  into the standardized process buffer  based on IBM standards for the IBM 3890 series of sorters.","After processing is completed by the check processing system  for the check, the API  updates the MICR buffer  in the shared memory  with the emulator data, which includes instructions for processing the check. The API  then notifies the sorter  that the update is complete, allowing the interface  to begin interpreting the emulator data in the MICR buffer  to complete the processing of the check.","According to one embodiment, the API  comprises logic for performing the functions described above. The logic may be encoded in hardware, such as a field-programmable gate array, an application-specific integrated circuit, or the like, and\/or software instructions stored in RAM, ROM and\/or other suitable computer-readable media for performing the functions associated with the API .","The communication engine  receives the process buffer  from the API  for each check being processed by the sorter . As used herein, each means every one of at least a subset of the identified items. As the process buffer  is passed between components of the system , it will be understood that any suitable portion of or the entire process buffer  may be passed based on the data in the process buffer  required by the receiving component.","After receiving the process buffer , the communication engine  calls a code line data match (CLDM) engine  which attempts to match an identifier for the check in the process buffer  to an identifier in a CLDM module . The CLDM module  may store any suitable identifying information as an identifier and other data such as MICR data, emulator data or any other suitable data relating to the check for each of a plurality of checks previously processed by the check processing system . Thus, for example, if a tray of checks being processed by the sorter  is dropped or if the sorter  jams or if any other situation results in the checks being re-ordered after a portion of the checks have been processed, the CLDM module  is able to provide the previously generated emulator data for each of the checks which have already been processed, thereby eliminating the need to fully process those checks a second time.","According to one embodiment, the CLDM module  is stored in a personal computer or other suitable device operable to store and process data. The CLDM module  may store any suitable number of identifiers and related data for previously processed checks. According to one embodiment, the CLDM module  may store up to 20,000 identifiers. The number of identifiers stored in the CLDM module  may be changed by the check processing system  at any suitable time. Thus, for example, the number may be changed based on the number of checks being processed by the sorter  at any particular time. If the number of identifiers to be stored has been embedded into a processing program, the embedded number may be overwritten to allow extended searching capabilities.","If the CLDM engine  finds no match in the CLDM module , the communication engine  calls the SCI emulator  which may executed SCI code stored in a SCI module . According to one embodiment, the check processing system  provides executable SCI code to the emulator  for storage in the SCI module . The SCI module  may also comprise tables of data received from the check processing system .","The SCI code in the SCI module  comprises a programming language for communicating between a check processing system  and an IBM 3890 of 3890\/XP. According to one embodiment, the check processing system  may provide new SCI code for storage in the SCI module  at any suitable time. Thus, for example, new SCI code may be provided by the check processing system  for each set of checks processed by the sorter .","When the communication engine  calls the SCI emulator , the SCI emulator  accesses the SCI module  and begins executing the SCI code stored in the SCI module . The SCI emulator  may comprise a program file  that identifies one or more auxiliary programs  in the emulator . The auxiliary programs  comprise programs in languages other than SCI code which may be easier to maintain. For example, the auxiliary programs  may be in C, C++, Cobol, Fortran, or any other suitable programming language. According to one embodiment, these auxiliary programs  provide an entry point for special endorsement. The SCI emulator  may use the data in the program file  to call any one of the auxiliary programs  instead of, or in addition to, the SCI code in the SCI module . The SCI emulator  provides the results from the execution of the SCI code and\/or the auxiliary programs  to the communication engine . According to one embodiment, these results comprise instructions for the endorser , the microfilm camera  and the digital camera .","The communication engine  incorporates the results from the SCI emulator  into the process buffer  received from the API  in accordance with a specified format for the check processing system . This format may comprise a header, trailer, and\/or any other suitable information for providing to the check processing system  a return address for the communication engine . The formatting is based on the type of communication between the check processing system  and the communication engine . According to one embodiment, this communication type is TCP\/IP. Alternatively, LU 6.2, channel connect, or any other suitable communication type may be used. However, LU 6.2 and channel connect are more expensive and complex types of communication than TCP\/IP. The communication engine  also provides online connectivity to the check processing system  which allows real-time communication between these two components  and . Real-time communication may include an instruction to disengage the pass for re-orienting or other instructions between the communication engine  and the check processing system  to dynamically change run time parameters or operations.","According to one embodiment, the communication engine  comprises logic for performing the functions described above. The logic may be encoded in hardware, such as a field-programmable gate array, an application-specific integrated circuit, or the like, and\/or software instructions stored in RAM, ROM and\/or other suitable computer-readable media for performing the functions associated with the communication engine .","According to one embodiment, the API  and the communication engine  communicate with TCP\/IP. Thus, although the embodiment shown in  illustrates the API  local to the communication engine , it will be understood that other suitable embodiments may be implemented without departing from the scope of the present invention. For example, the API  may be local to the sorter  and remote from the communication engine . As used herein, remote means that the two components may be located anywhere in the world with respect to each other and may communicate with each other over a communication link. Alternatively, the API  may be local to the communication engine  and local to the sorter . In accordance with one embodiment, the communication engine  may communicate with a plurality of APIs  that are remote from the communication engine  and each other and that are each local to a sorter . Thus, the emulator  may be used to emulate a plurality of different types of sorters  simultaneously through the use of a plurality of APIs .","The check processing system  may comprise any suitable combination of one or more of Vector:Sort, Check Processing Control System, SuperMICR, or any other suitable check processing system, and may be implemented on a mainframe. The check processing system  receives the process buffer  from the communication engine  and makes decisions as to the processing of the check based on the process buffer . The check processing system  also provides data to the CLDM module  for the CLDM engine  to use for matching.","In operation, a set of checks is provided to the sorter  for processing. As each check is passed through the sorter , the MICR reader  retrieves the MICR data from the check and copies this data to the MICR buffer  in the shared memory . The sorter  then notifies the API  that the MICR buffer  is available for processing. The API  accesses the MICR buffer  and converts the MICR data into a process buffer . The process buffer  is then provided to the communication engine . The communication engine  calls the CLDM engine  which attempts to match an identifier in the process buffer  to an identifier in the CLDM module . If a match is found, the CLDM engine  retrieves previously generated emulator data for the check and provides this information to the communication engine . However, if no match is found, the communication engine  calls the SCI emulator . The SCI emulator  then begins executing the SCI code in the SCI module  and\/or an auxiliary program  and provides the results to the communication engine .","The communication engine  includes these results in the process buffer  before providing the process buffer  to the check processing system . The check processing system  makes decisions regarding how to process the check based on the data in the process buffer .","The API  generates emulator data based on the updated process buffer  from the check processing system  and copies the emulator data into the MICR buffer  of the shared memory  for the sorter . The API  then notifies the sorter  that the emulator data is available for the check. The interface  interprets the updated MICR buffer  that includes the emulator data in order to determine how to process the check. The emulator data instructs the interface  whether or not to endorse the check, to record a microfilm image of the check and to record a digital image of the check. The interface  then signals the endorser , the microfilm camera  and\/or the digital camera  in accordance with the feature instructions. According to one embodiment, the interface  provides a signal to each of the features ,  and\/or  which are to be activated and provides no signal to the features ,  and\/or  which are not to be activated.","For the digital camera , the interface  also notifies the digital camera  which images to record (front and\/or back), what type of image (black and white, gray scale or color) to record for the front and what type of image to record for the back. The interface  also identifies a pocket  to the sorter  for the check. After any requested endorsement is performed and images are recorded, the sorter  directs the check to the pocket  identified by the interface .",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 2","b":["200","50","200","50","202","204","202","204","210","212","214","216","218","220","222","224","226","228","230","232","52","54","204","54"]},"In accordance with one embodiment, the header  comprises two field validity bytes  and . The first field validity byte  comprises a bit to indicate an end-of-file for code line data matching and seven bits to indicate a digit error in one of seven corresponding fields. The second field validity byte  comprises one bit to indicate that either the opening symbol for the first field was missing from the check or the leading edge of the check was damaged. The second field validity byte  also comprise seven bits to indicate an invalid length or a special symbol sequence error in one of seven corresponding fields. An invalid length or special symbol sequence error indicates that the opening or closing symbol for a field was either missing or incorrect or that the number of digits detected in the field was incorrect.","The header  also comprises two SCI results bytes  and . These bytes  and  both comprise data generated by the SCI emulator  through the execution of SCI code in the SCI module  and\/or an auxiliary program .","The error\/feature data byte  comprises a bit to indicate the validity of endorsement data, a bit to indicate the validity of INF data, a bit to indicate a power encoder error, a bit to indicate a time-out error, a bit to indicate an image request, a bit to indicate that an OCR3 feature was initialized \u201con\u201d and two bits for communicating any suitable data.","The feature control byte  comprises a bit to indicate that a predetermined number of checks have been recorded by the microfilm camera , causing a pause to occur while the microfilm is spaced. The feature control byte  also comprises a bit to enable a flash for lighting the check as the microfilm camera  records a microfilm image of the check. The feature control byte  also comprises a bit that may cause a one to be added to the value of a high order segment of an index number, while the low order segment is reset to zero. The feature control byte  also comprises a bit that may cause a one to be added to the low order segment of the index number. The feature control byte  also comprises a bit to inhibit the printing of endorsement data by the endorser  and a bit to inhibit the printing of INF data. Similar to the bits relating to the index number, the feature control byte  comprises a bit to increment the INF high order segment, while resetting the INF low order segment to zero, and a bit to increment the INF low order segment.","The pocket selection byte  comprises three bits for module selection, three bits for pocket selection and two bits for communicating any suitable data. The feature data byte  comprises a bit to indicate that the endorsement feature was initialized \u201con,\u201d a bit that forces the check to be directed to the first pocket of the first module, a bit to indicate that power encoding was not done or was invalid, a bit to indicate that no code line data matching was attempted by the CLDM engine , a bit to indicate that the process buffer  was modified by specified macros or functions, a bit to indicate that the microfilm camera was initialized \u201con,\u201d a bit to indicate that the INF feature was initialized \u201con\u201d and a bit to identify a first document processed after a microfilm space.","The special condition data byte  comprises a bit to indicate a hardware-detected autoselect. A hardware-detected autoselect indicates that at least one of the following conditions occurred: multiple checks, a distance between checks less than a predetermined amount, a check length greater than a predetermined amount, a check length less than a predetermined amount, a distance between the leading edges of consecutive checks less than a predetermined amount and a special symbol sequence error. The special condition data byte  also comprises a bit to indicate an invalid module-pocket code autoselect, a bit to indicate a late module-pocket code autoselect, a bit to indicate a SCI error, a bit to indicate a merged document, a bit to indicate that the CLDM engine  found no match in the CLDM module , a bit to indicate that a high order zero correction occurred and a bit to indicate that a symbol error correction occurred.","The routing\/SCI data byte  comprises four bits for a routing number self-check digit, one bit to indicate an invalid routing number self-check digit, a bit to indicate a SCI pause and two bits for communicating any suitable data. The document number byte  comprises a document sequence number for the check. According to one embodiment, this number ranges from X00 to XFF.","The header type byte  identifies the type of header  for the process buffer . According to one embodiment, the header type may comprise a document data header, an exception header, a SCI error header, a data management header or any other suitable header type.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 3","b":["10","300","14","302","14","304","20","306","20","32","30","14","40","32","308"]},"At step , the API  generates and provides a standardized process buffer , which is based on the MICR buffer , to the communication engine . The standardized process buffer is in a format that is compatible with the check sorter that is being emulated by the emulator . In one embodiment, data is mapped from a hardware-specific domain to a standard-domain. At step , decisions are made for the check based on the process buffer . At step , these decisions are provided to the communication engine .","At step , the communication engine  provides the process buffer  incorporating the decisions to the API . At , the API  updates the MICR buffer  with emulator data based on the process buffer  received back from the communication engine . In one embodiment, the emulator data is copied to predefined fields in the MICR buffer .","At step , the interface  interprets the emulator data in the MICR buffer . At step , the interface  activates the appropriate features ,  and\/or  in accordance with the emulator data. At decisional step , a determination is made regarding whether or not the endorser  has been activated. If the endorser  has been activated, the methods follows the Yes branch from decisional step  to step  where the endorser  endorses the check. However, if the endorser has not been activated, the method follows the No branch from decisional step  to decisional step .","At decisional step , a determination is made regarding whether or not the microfilm camera  has been activated. If the microfilm camera  has been activated, the method follows the Yes branch from decisional step  to step  where the microfilm camera  records a microfilm image of the check. However, if the microfilm camera  has not been activated, the method follows the No branch from decisional step  to decisional step .","At decisional step , a determination is made regarding whether or not the digital camera  has been activated. If the digital camera  has been activated, the method follows the Yes branch from decisional step  to step  where the digital camera  records one or more digital images of the check. As described in more detail above, the digital camera  may record an image of the front and\/or an image of the back of the check. In addition, each image recorded by the digital camera  may be either black and white, gray scale or color. Thus, one or more of a number of indicators may be set for the digital camera . Returning to decisional step , if the digital camera  has not been activated, the method follows the No branch from decisional step  to step .","At step , the interface  provides a pocket selection for the check. At step , the sorter  directs the check to the identified pocket . At decisional step , the sorter  makes a determination regarding whether there are more checks to process. If there are more checks to process, the method follows the Yes branch from decisional step  and returns to step  where the MICR reader  retrieves MICR data from a subsequent check. However, if there are no more checks to process, the method follows No branch from decisional step  at which point the method comes to an end. Thus, each check passing through the sorter  is individually processed by the check processing system  through the use of the emulator  that allows the check processing system  to communicate with the sorter  as though the sorter  were a different type of sorter.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 4","b":["42","14","400","40","30","14","402","40","32","50","404","40","50","42"]},"At step , the API  receives the process buffer  incorporating decisions made by the check processing system  back from the communication engine . At step , the API  generates emulator data based on the process buffer . At step , the API  provides the emulator data to the sorter  by updating the MICR buffer  in the shared memory  with the emulator data. At step , the API  notifies the sorter  that the MICR buffer  has been updated, at which point the method comes to an end.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 5","b":["16","40","500","50","40","502","42","52","50","54","504","54"]},"If a matching identifier was found, the method follows the Yes branch from decisional step  to step  where the process buffer  is updated with data stored in the CLDM module . At step , the communication engine  provides the updated process buffer  to the API , at which point the method comes to an end.","Returning to decisional step , if no matching identifier was found, the method follows the No branch from decisional step  to step . At step , the communication engine  calls the SCI emulator  which may execute SCI code stored in the SCI module  and\/or one or more auxiliary programs  identified in the program file . At step , the communication engine  incorporates results received from the SCI emulator  into the process buffer . At step , the communication engine  provides the updated process buffer  to the check processing system .","At step , the communication engine  receives decisions regarding the check from the check processing system . At step , the communication engine  incorporates the decisions received from the check processing system  into the process buffer . At step , the communication engine  provides the process buffer  to the API  and to the CLDM engine . At step , the CLDM engine  stores the process buffer  in the CLDM module  for future matching, at which point the method comes to an end.","Although the present invention has been described with several embodiments, various changes and modifications may be suggested to one skilled in the art. It is intended that the present invention encompasses such changes and modifications as fall within the scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention and its advantages, reference is now made to the following description taken in conjunction with the accompanying drawings, wherein like numerals represent like parts, in which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIG. 1"]}]},"DETDESC":[{},{}]}
