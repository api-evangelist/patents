---
title: Mesh compression process
abstract: A process for encoding an update of a polygon mesh having at least one target vertex includes defining a local index of a vertex that neighbors the target vertex, storing a global index of the target vertex, storing a number of new faces resulting from the update, storing an identity of a face of the mesh using the local index, and storing a movement status of a corner of a polygon adjacent to the target vertex.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06982715&OS=06982715&RS=06982715
owner: Intel Corporation
number: 06982715
owner_city: Santa Clara
owner_country: US
publication_date: 20020726
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DESCRIPTION"],"p":["This application relates to a process for compressing a progressive representation of a polygonal surface mesh.","A multi-resolution mesh (MRM) is a progressive representation of a polygonal surface mesh (optionally textured) that describes a three-dimensional (3D) model. The MRM represents a mesh of v vertices as a sequence of v vertex updates. This representation permits extraction of polygonal meshes with any desired vertex count r, where 3\u2266r\u2266v, in real-time. The MRM is defined by an array of v vertex positions, an optional array of t texture coordinates, and an array of v vertex update records.","An MRM is created by iteratively collapsing one vertex of a polygon into another vertex. Although the two vertices will often be connected by an edge, occasionally also unconnected vertices are collapsed. The collapsed vertex, any unused texture coordinates, and all degenerate polygons are then removed and the texture coordinate indices of the corners of some remaining polygon are changed. Each vertex update record specifies how to undo such a collapse. Undoing such a collapse is also referred to as a vertex split.","Sending an MRM over a bandwidth-limited medium can be difficult, particularly if the MRM has a large number of vertices. This is because of the extensive amount of data that may be required to define the MRM. Compression techniques may be used in order to reduce the amount of data that defines the MRM, thereby making it easier to transmit the MRM over limited-bandwidth media.","There are several different types of information that can be compressed: the array of v vertex positions, the array of t texture coordinates, and the array of v vertex update records. Generally speaking, the largest compression gain can be achieved though a compact and loss-less encoding of the array of v vertex update records.","Like reference numerals in different figures indicate like elements.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 1","FIG. 2","FIG. 2"],"b":"9"},"An example of a vertex update is shown in FIG. .  shows a close-up of the affected part of the mesh and shows only the mesh elements relevant for the vertex update.","As shown in  the mesh is updated in the sense that vertex  is introduced. This vertex update introduces two new polygons  and  and changes the vertex index from  to  for the corners , , and  of three polygons. This vertex update can be viewed at as \u201csplitting\u201d vertex .","An MRM comprised of \u201cN\u201d (N>1) vertices is incrementally constructed by applying \u201cN\u201d vertex updates to increase the resolution of the MRM from its lowest to its highest resolution. In this embodiment, compressing the MRM includes compressing these \u201cN\u201d updates. The compression processes described herein determine the minimal amount of data needed to compress each such vertex update and exploit correlations in the data for common polygon arrangements. Various prediction rules may also be employed to improve compression for less frequently occurring cases.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 4","b":["15","15","15","15","15"]},"Process  finds each split vertex and then describes how the split changes the MRM. For each vertex update, process  determines the split vertex and stores the following compression information:\n\n","Referring to , a newly-introduced vertex is called an \u201cupdate vertex\u201d . The vertex at which the MRM splits is called the \u201csplit vertex\u201d . Existing faces that are affected by this split are called \u201cupdated faces\u201d . The \u201cmoving corners\u201d  are corners of these faces that move from split vertex  to update vertex . The \u201cstaying corners\u201d  are all other corners around split vertex  that do not move during updating. The newly-introduced faces are called \u201cnew faces\u201d . New faces  are formed by split vertex , update vertex , and a \u201cthird vertex\u201d .","Depending on the \u201cwinding order\u201d of a resulting new face, the third vertex is classified as \u201cright\u201d  or \u201cleft\u201d . In this context, winding order is the order that a new face is traversed during rendering. If the winding order is \u201csplit vertex, third vertex, update vertex\u201d, process  classifies the third vertex as \u201cright\u201d. If the winding order is \u201csplit vertex, update vertex, third vertex\u201d, process  classifies the third vertex as \u201cleft\u201d.","The intuition behind \u201cright\u201d and \u201cleft\u201d is as follows: if one looks from the split vertex  to the update vertex , then the third vertex is to the right for front-facing faces with the winding order \u201csplit vertex, third vertex, update vertex\u201d and to the left for front-facing faces with the winding order \u201csplit vertex, update vertex, third vertex\u201d. In most graphics APIs (Application Programming Interfaces), a polygon is front-facing when the winding order is counterclockwise when looking at its front side.","Process  also classifies the third vertices as \u201clocal\u201d or \u201cglobal\u201d. If the third vertex is connected to the split vertex  before an update, the third vertex is defined as \u201clocal\u201d , otherwise it is defined as \u201cglobal\u201d . Process  defines the third vertex as local so that process  can address the third vertex locally as the first, second, third, etc. neighbor of the split vertex, as described below.","Various different types of MRM updates are shown in  to . These MRM updates can be described in terms of the compression information noted above.",{"@attributes":{"id":"p-0052","num":"0057"},"figref":["FIG. 3","FIG. 6","FIG. 7","FIG. 8","FIG. 9","FIG. 10","FIGS. 11"],"b":["10","27","29","30","35","37","39","15"]},"Referring to , an MRM  is shown. Each vertex of the MRM has a global index that can be used to reference the vertex. This index is implicitly determined by the vertex update that introduces the vertex. A vertex that is introduced by an ivertex update has an index i\u22121 (for i>1). For example, vertex  has a global index of 17. That means that vertex  was introduced by the 18vertex update. Similarly, vertex  has a global index of 15 and vertex  has a global index of 5, which means that they were introduced by the 16and 6vertex updates, respectively. The actual 3D positions of the vertices are stored in an array of 3D positions in the order in which they were introduced. This way, the global index of a vertex addresses its position in this array. Encoding of MRM  may be performed as follows.","Assume that process  () encodes the 29vertex update that introduces vertex , which will have the global index . The MRM, in this case, has currently only 28 vertices. Therefore, the global index of the split vertex will be a number between 0 and 27. Assume further that there is some type of neighbor mesh that allows process  to iterate over the neighboring vertices and neighboring faces (or rather their corresponding neighboring corners) of the split vertex. Such an iteration defines a unique enumeration (ordering) of the neighbors of the split vertex.","Referring to , process  encodes the update as follows. Process  locates the vertex  that is split by the vertex update. Process  encodes the vertex  that is split. That is, process  writes (i.e., stores) the global index of the split vertex , in this case , knowing that it will be a number between 0 and 27. Process  records the number of new faces introduced by this vertex update, in this case three (faces ,  and  from FIG. ).","Process  also specifies for each new face which third vertex it uses and which winding order it has, as follows: RIGHT\/LEFT specifies the winding order of the new face. RIGHT indicates that the winding order is split vertex, third vertex, update vertex. LEFT indicates that the winding order is update vertex, third vertex, split vertex.","LOCAL\/GLOBAL indicates the indexing scheme used for addressing the third vertex of the new face.","LOCAL indicates that a local indexing scheme is used, since the third vertex of the new face is currently a neighbor of the split vertex. In this case, a local index into an enumeration of the neighboring vertices of the split vertex is used to specify the third vertex. This is a number between 0 and the number of vertices that are neighbors of the split vertex minus one. In the example, split vertex  has six neighboring vertices. Hence, the local index will be a number between 0 and 5. Assume, for example, that the third vertex  appears as the fourth vertex in the enumeration of the vertices that are neighbors of the split vertex. Then, its local index is 3. Assume further, that the third vertex  appears as the second vertex in the enumeration of the vertices that are neighbors of the split vertex. Then its local index is 1. No specific order is required to define the local indices, as long as the encoder that encodes the MRM and the decoder that decodes the MRM use the same order.","GLOBAL indicates that a global indexing scheme is used, since the third vertex of the new face is not currently a neighbor of the split vertex. In this case, the global index is used to specify the third vertex. This is a number between 0 and the number of vertices in the MRM. In the example, one third vertex  is not a neighbor of split vertex . Its global index  is encoded knowing that it will be a number between 0 and 27. Writing local indices as opposed to global indices can save significant bandwidth, particularly for meshes with many vertices for which global indices would require many bits to express.","Process  also specifies which corners of the split vertex (e.g., , , ) move during the MRM vertex update from the split vertex to the update vertex and which corners of the split vertex (e.g., , , ) stay at the split vertex. To do this, process  simply loops over a list of all corners surrounding the split vertex  and records (i.e., writes\/stores) the corresponding symbol \u201cSTAY\u201d or \u201cMOVE\u201d. The corners can be listed in any order as long as encoder and decoder use the same order.","Referring to , encoding the vertex update of  using process  produces the following compression code (shown below with explanatory notes):\n\n","The coding process  described above, entitled \u201cGeneric Coding\u201d in  to , can be employed to encode any type of MRM update (examples of different MRM updates are shown  to ). Using \u201cGeneric Encoding\u201d, the \u201croman patch\u201d  of  compresses to about 35 KiloBytes (KB) for multi-resolution connectivity and positions. Modifications to the generic coding process  of  that may improve compression are described below.",{"@attributes":{"id":"p-0063","num":"0079"},"figref":"FIG. 20","b":"49","ul":{"@attributes":{"id":"ul0005","list-style":"none"},"li":{"@attributes":{"id":"ul0005-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0006","list-style":"none"},"li":["(1) TWO NEW FACES ARE INTRODUCED","(2) ONE THIRD VERTEX IS RIGHT, THE OTHER IS LEFT, BOTH THIRD VERTICES ARE LOCAL","(3) ALL CORNERS THAT ARE COUNTERCLOCKWISE (CCW) OF THE RIGHT THIRD VERTEX AND CLOCKWISE (CW) OF THE LEFT THIRD VERTEX ARE MOVING CORNERS","(4) ALL OTHER CORNERS ARE STAYING CORNERS\n\nThese qualifications mean that it is enough to specify the two third vertices of a manifold vertex update in an agreed upon order in order to encode the update. All other updates to the MRM can be inferred from this information and therefore additional symbols need not be encoded.\n"]}}}},{"@attributes":{"id":"p-0064","num":"0084"},"figref":"FIG. 21","b":["65","65","65"],"ul":{"@attributes":{"id":"ul0007","list-style":"none"},"li":{"@attributes":{"id":"ul0007-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":["(1) TWO NEW FACES ARE INTRODUCED","(2) ONE THIRD VERTEX IS LEFT AND THE OTHER RIGHT","(3) BOTH THIRD VERTICES ARE LOCAL","(4) EVERY CORNER THAT CAN BE REACHED BY MOVING COUNTERCLOCKWISE FROM THE RIGHT THIRD VERTEX IS MOVING","(5) EVERY CORNER THAT CAN BE REACHED BY MOVING CLOCKWISE FROM THE LEFT THIRD VERTEX IS MOVING","(6) ALL MOVING CORNERS ARE REACHED DURING (4) AND (5) ABOVE"]}}}},"Referring to , process  records whether the vertex update is manifold or not manifold by writing \u201cMANIFOLD\u201d or \u201cNON-MANIFOLD\u201d, respectively. If the vertex update is manifold, process  writes the local index of the right third vertex and the local index of the left third vertex. Otherwise, process  uses the generic encoding process of  to  to code the updates.","Since the process of encoding a manifold vertex update requires less data than the process of encoding a generic vertex update, and since typical meshes have a very large percentage of manifold vertex updates, it is worthwhile to write the additional \u201cMANIFOLD\u201d\/\u201cNON-MANIFOLD\u201d flag.","The encoding process for a manifold vertex updates eliminates the need to write the number of faces (e.g., it will always be two), to write the winding order (RIGHT\/LEFT) for the two new faces (one third vertex will always be RIGHT -> its index is written first, the other third vertex will always be LEFT -> its index is written second), to write the indexing method (LOCAL\/GLOBAL) for the third vertex of the two new faces (the indexing method for both third vertices will always be LOCAL), and to write the MOVE\/STAY flag for each corner around the split vertex (because all corners counterclockwise relative to a right third vertex and clockwise relative to a left third vertex move, whereas all others stay).",{"@attributes":{"id":"p-0068","num":"0094"},"figref":"FIG. 22","b":["66","65","65","67","65","65"]},"Referring to , performing process  to encode vertex updates on the MRM of the \u201croman patch\u201d model  reduces the file size to roughly 28.5 KB. This is because the MRM of the \u201croman patch\u201d model has mostly manifold vertex updates. Only 30 of the total 5600 updates are non-manifold.  shows a \u201cgunturret\u201d model  whose MRM has 120 non-manifold vertex updates of 301 vertex updates in total. These 120 vertex updates are encoded with the generic encoding process. In models with such a large percentages of non-manifold vertex updates, predictive coding may be used. Like generic encoding, predictive encoding can also encode any kind of non-manifold vertex update, but does so more efficiently on typical non-manifold vertex updates.","Referring to , mesh  falls under the non-manifold category because one of the two third vertices  is global instead of local. Nevertheless, there is a strong correlation between the staying and moving corners and the local right third vertex . All corners that are counterclockwise (ccw) (, ) of the right third vertex are moving corners and all corners that are clockwise (cw) (, ) of the right third vertex are staying corners.","The MRM update shown in  also falls under the non-manifold category because only one new face  results. But, the foregoing correlation is still there: all corners (, ) that are counterclockwise of the left third vertex  are staying corners and all corners (, ) that are clockwise of the left third vertex  are moving corners.",{"@attributes":{"id":"p-0072","num":"0098"},"figref":["FIG. 26","FIGS. 24 and 25"],"b":["87","87","89","87","87","87","87"]},"Process  records, for each third vertex, LOCAL\/GLOBAL to indicate how that vertex is indexed. If the vertex is LOCAL, the vertex is classified as a neighbor vertex. In this case, the index of the vertex is a number between 0 and the number of neighbor vertices minus 1. In a case that the vertex is GLOBAL, the index is any global MRM vertex, i.e., a number between 0 and number of MRM vertices minus 1.","Process  specifies which corners MOVE and which corners STAY. Process  also makes predictions using the local third vertices. Process  \u201cwalks\u201d counterclockwise from a right third vertex and predicts, for any corner that can be reached (before crossing another third vertex), that is moves. Process  \u201cwalks\u201d counterclockwise from a left third vertex and predicts, for any corner that can be reached (before crossing another third vertex), that is stays. If, after this, there are still unclassified corners, process  \u201cwalks\u201d clockwise from those third vertices and reverses its predictions. If there are then still unclassified corners, process  encodes the vertices as \u201cunpredicted\u201d. Correct predictions require fewer bits to encode and thus produce more efficient compression.",{"@attributes":{"id":"p-0075","num":"0101"},"figref":"FIG. 27","b":["87","25"],"ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":{"@attributes":{"id":"ul0009-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":["(1) WRITE \u201c9\u201d FOR THE GLOBAL INDEX OF THE SPLIT VERTEX. FOR COMPRESSION WE CAN EXPLOIT THE FACT THAT THE INDEX \u201c9\u201d HAS TO BE A NUMBER BETWEEN 0 AND 27.","(2) WRITE \u201c1\u201d FOR THE NUMBER OF NEW FACES (FACE  IN )","(3) WRITE \u201cLEFT\u201d, \u201cLOCAL\u201d, AND \u201c3\u201d FOR THE NEW FACE (DEFINED BY VERTICES , , ). FOR COMPRESSION WE CAN EXPLOIT THE FACT THAT THE INDEX \u201c3\u201d HAS TO BE A NUMBER BETWEEN 0 AND 5. NO PREDICTIVE RIGHT\/LEFT CODING HERE, BECAUSE THERE IS JUST ONE NEW FACE","(4) WALK COUNTERCLOCKWISE FROM THE LEFT THIRD VERTEX\u2014WRITE \u201cSTAY\u201d WITH PREDICTION \u201cSTAY\u201d (STAY|STAY)","(5) CONTINUE TO WALK COUNTERCLOCKWISE FROM THE LEFT THIRD VERTEX\u2014WRITE \u201cSTAY\u201d WITH PREDICTION \u201cSTAY\u201d (STAY|STAY)","(6) CANNOT CONTINUE TO WALK COUNTERCLOCKWISE","(7) NOT ALL CORNERS CLASSIFIED","(8) WALK CLOCKWISE FROM THE LEFT THIRD VERTEX\u2014WRITE \u201cMOVE\u201d WITH PREDICTION \u201cMOVE\u201d (MOVE|MOVE)","(9) CONTINUE TO WALK CLOCKWISE FROM THE LEFT THIRD VERTEX\u2014WRITE \u201cMOVE\u201d WITH PREDICTION \u201cMOVE\u201d (MOVE|MOVE)","(10) CANNOT CONTINUE TO WALK CLOCKWISE","(11) ALL CORNERS CLASSIFIED"]}}}},{"@attributes":{"id":"p-0076","num":"0113"},"figref":"FIGS. 28 and 29","sup":"th ","sub":"2"},"Referring to , the foregoing problem can be addressed by modifying the MRM generator. The vertex updates may be ordered into batches. If k (k>1) vertex updates can be performed on an MRM that currently has i vertices, such that the updates can be executed in the order that their corresponding split vertices appear in the vertex array, then it is possible to encode the mesh more compactly. This is because only i bits are needed to specify the split vertices of all the vertex updates that go from i vertices in the MRM to i+k vertices in the MRM (e.g., a \u201c0\u201d bit means that a vertex is not a split vertex and a \u201c1\u201d bit means that a vertex is a split vertex). Given that the fraction f=k\/(i+k) can be kept above a certain threshold, it is possible to calculate the total number of bits using a geometric series  whose first element is missing. Using a closed form solution and doing some term re-writing, the sum of the series reduces to equation . Thus, only n\/f bits may be used to specify all MRM split vertices. This is less than the nlogn bits noted above, especially as n gets large.",{"@attributes":{"id":"p-0078","num":"0115"},"figref":"FIG. 30"},"An MRM of a textured mesh also may specify what happens to texture coordinate mapping during a vertex update. In contrast to positions, which are associated with the vertices of the mesh, texture coordinates are associated with the corners of the mesh. The corners around a vertex may all reference the same texture coordinate, but often reference two, three, or four different texture coordinates, and may even all reference a different texture coordinate. A vertex update introduces new corners, namely, the corners of the new faces. The encoding process should specify for these new corners, which texture coordinate they reference. Typically, a vertex update also changes the referenced texture coordinate for some existing corners. The encoding process should specify for which corners this happens and also to which texture coordinate they reference changes.","Each corner of each face of the MRM references its associated texture coordinate with an index into an array of texture coordinates, called a texture coordinate index. The texture coordinates are stored in this array in the order that they are introduced by the vertex updates. This order implicitly determines the index with which they are referenced. A vertex update can introduce none, one, or more texture coordinates. For example, if an ivertex update of an MRM that already has j texture coordinates introduces two new texture coordinates, then these two new texture coordinates will receive the texture coordinate indices j and j+1 and, afterwards, the MRM has j+2 texture coordinates.",{"@attributes":{"id":"p-0081","num":"0118"},"figref":["FIGS. 31","FIG. 31"],"b":"41"},"Referring to , third corners  are defined as corners of new faces ,  that connect to third vertices  and  respectively. The texture coordinate index for a third corner is often found in a list of candidate texture coordinate indices. This list of candidates contains all texture coordinate indices that are currently found around the respective third vertex. If the texture coordinate index of the third corner is not in this list, it is usually a new texture coordinate index (e.g. this is the first time the referenced texture coordinate is used). Only in rare cases does it reference an old texture coordinate that is already used somewhere else in the mesh.",{"@attributes":{"id":"p-0083","num":"0120"},"figref":["FIG. 33","FIG. 33"],"b":["101","95","32"]},"Process  iterates () over third corners and classifies () them as either CAND () of notCAND (), depending on whether or not the texture coordinate index of the third corner is in its respective list of candidates. If the list of candidates is empty, this classification can be omitted, since it has to be a notCAND. If the third corner was classified as CAND (), process  stores () the local index that its texture coordinate index has in the list of candidates. The index can be omitted if the list has only one candidate. If the third corner was classified as notCAND (), process  stores an indication (NEW) that the texture coordinate index of the third corner references a new texture coordinate () or an indication (OLD) that it references an old texture coordinate (). If a new texture coordinate is referenced, process  increments the current counter of texture coordinate indices and assigns it to the third corner. In this case, process  may encode the UV coordinates of the texture coordinate () using some kind of predictive coding or any other method. Otherwise (this is typically a very rare case), process  stores the global index () of the referenced texture coordinate. This is a number between 0 and the current counter of texture coordinate indices.","Referring to , the corners around the split vertex  that DO NOT move from the split vertex  to the update vertex  are called staying corners . They already have a texture coordinate index (e.g., reference a texture coordinate), which is not affected by the vertex update.","Referring to , the corners around the split vertex  that move from the split vertex  to update vertex  are called moving corners . They already have a texture coordinate index that can potentially change. It is beneficial to encode these changes in terms of moving texture coordinate indices rather than in terms of moving corners.","Referring to , the moving texture coordinate indices  are the set of texture coordinate indices that are associated with moving corners  prior to the vertex update.",{"@attributes":{"id":"p-0088","num":"0125"},"figref":["FIG. 37","FIG. 37"],"b":["121","119","35"]},"Process  () classifies () the moving texture coordinate indices  as either CHANGE or KEEP, depending on whether or not this texture coordinate index changes during the vertex update. If a moving texture coordinate index is classified as KEEP (), it does not change. If a moving texture coordinate  is classified as CHANGE (), it usually changes to a new texture coordinate index () (e.g. this is the first time the referenced texture coordinate is used). In this case, process  stores an indication (NEW), increments the current counter of texture coordinate indices, and assigns it to all moving corners  that share this moving texture coordinate index . In this case, process  may encode the UV coordinates of the texture coordinate () using some kind of predictive coding or any other method. Only in rare cases does the moving texture coordinate change to an old texture coordinate index that is already used somewhere else in the mesh (). In this case, process  stores an indication (OLD), stores the global index () of the referenced texture coordinate, and assigns it to all moving corners  that share this moving texture coordinate index . This is a number between 0 and the current count of texture coordinate indices.","Process  () performs the classification of CHANGE or KEEP per moving texture coordinate index  rather than per moving corner . That is, if the texture coordinate index of some moving corner is A and the texture coordinate index is updated to B, then the texture coordinate indices of all moving corners that are A are updated to B. Likewise, if the texture coordinate index of some moving corner is A and it is not updated, then the texture coordinate indices of all moving corners that are A are also not updated.","In the example of , process  enters all moving texture coordinate indices into a list . In this example, there are two moving texture coordinate indices, namely \u201c35\u201d, which is used by two moving corners, and \u201c8\u201d, which is used by one moving corner. Process  classifies the moving texture coordinate index \u201c35\u201d as CHANGE. Since it will reference a new texture coordinate, process  stores an indication (NEW), increments the current counter of texture coordinate indices to \u201c49\u201d, and assigns the texture coordinate to all moving corners with a texture coordinate index of \u201c35\u201d. Process  classifies the moving texture coordinate index \u201c8\u201d as KEEP. Hence, all moving corners with a texture coordinate index of \u201c8\u201d remain unchanged. There can be at most as many CHANGE classifications as there are new faces introduced by the vertex update. If there have already been that many, process  defaults the classification of the remaining moving texture coordinate indices to KEEP.","Referring to , the corners of new faces ,  that connect to the update vertex  are called update corners .  shows a flowchart of a process  for encoding the assignment of texture coordinate indices to update corners  (FIG. ). Representative pseudocode to implement the flowchart of  is shown in Appendix C.","Process  () classifies () update corners as LIST or notLIST depending on whether or not its future texture coordinate index is among those that were generated during the encoding of the moving texture coordinate indices (e.g. whether they appear in the right column of the generated list ). If no moving texture coordinate indices were changed (, ) during encoding of the moving texture coordinate indices (e.g. in case the right column of the generated list  () is empty), process  does not store this classification explicitly, but defaults () the classification of the update corners to notLIST. But, process  indexes each list entry at least once. When the number of not-yet-indexed list entries equals the number of unprocessed update corners, the classification of all remaining update corners defaults () to LIST.","If the update corner was classified as LIST, process  stores () the local index of its texture coordinate index in the list. The index can be omitted if the list has only one entry. This index can also be omitted when the last update corner is processed and the list still has one not-yet-indexed entry.","If the update corner was classified as notLIST, process  stores usually () an indication (NEW) that the texture coordinate index of the update corner references a new texture coordinate () or sometimes an indication (OLD) that it references an old texture coordinate. In most cases a new texture coordinate is referenced, in which case process  increments the current counter of texture coordinate indices and assigns it to the updated corner. In this case, process  may encode the UV coordinates of the texture coordinate () using some kind of predictive coding or any other method. Otherwise (this is typically a rare case), process  stores the global index () of the referenced texture coordinate. This is a number between 0 and the current count of texture coordinate indices.","In the example of  the first of the two update corners has a texture coordinate index of \u201c49\u201d that is in the list. Process  classifies it as LIST. Since there is only one entry in the right column of list , no local index is necessary. The second update corner references a texture coordinate that is not in the list. Process  classifies it as notLIST and also stores () an indication (NEW) that the texture coordinate index of the update corner references a new texture coordinate. Thus, process  increments the current counter of texture coordinate indices to \u201c50\u201d, and assigns it to this update corner.","Referring to , the corners of new faces that connect to the split vertex  are called split corners .  shows a flowchart of a process  for encoding the assignment of texture coordinate indices to split corners  (FIG. ). Representative pseudocode to implement the flowchart of  is shown in Appendix D.","Process  loops over the split corners to encode which texture coordinates are referenced. Process  determines () if the update corner corresponding to the currently processed split corner (e.g. the update corner from the same face) is in the right column of the list  (see also ) generated during process  (FIG. ). If so, then the split corner is very likely to get the texture coordinate index from the left column of the same row. This is usually the case and process  writes GOOD () and assigns this texture coordinate to the currently processed split corner. Otherwise process  writes BAD () and continues.","The referenced texture coordinate might then have an index that is among a list of candidates. This candidate list is made up from the texture coordinate indices of the staying corners, all texture coordinate indices that are in the left column of a CHANGE entry in the list  () generated during process  (FIG. ), and any texture coordinate index assigned to an already processed split corner. If there is no such candidate (), the referenced texture coordinate is usually a NEW texture coordinate, but sometimes an OLD texture coordinate (). Otherwise process  indicates () if the texture coordinate referenced by the split corner is among the candidate of the list (CAND) () or not (notCAND) (). If the texture coordinate index is among the candidates () and there is more than one candidate (), process  writes () its local index within the candidate list. If the texture coordinate index is not among the candidates (), the referenced texture coordinate is usually a NEW texture coordinate, but sometimes an OLD texture coordinate (). If the referenced texture coordinate is classified as OLD, the texture coordinate index is recorded. The number recorded is between 0 and the current count of texture coordinate indices.","In the example if  there are two split corners. The corresponding update corner of the split corner processed first is in the list (namely \u201c49\u201d). Since the split corner is supposed to get the texture coordinate index from the left column of the same row in this list (namely \u201c35\u201d), process  writes GOOD. Process  determines that the corresponding update corner of the second split corner is not in the list. Process  determines that it is also not a candidate, writes notCAND, and stores an indication (NEW) that the texture coordinate index of the split corner references a new texture coordinate. Thus, process  increments the current counter of texture coordinate indices to \u201c51\u201d, and assigns it to this split corner.","It should be noted that every texture coordinate index from the left column of a CHANGE entry in the list  () generated during process  () is assigned at least once to a split corner. This can be exploited by process  to sometimes infer a GOOD case.",{"@attributes":{"id":"p-0102","num":"0139"},"figref":"FIG. 42","b":["180","180","181","182","184","185","184","186","187","181","182"]},"The MRM update encoding processes described herein are not limited to use with the hardware and software described above; they may find applicability in any computing or processing environment. The processes may be implemented in hardware, software, or a combination of the two. For example, the processes may be implemented in an encoder that includes circuitry, such as one or more of programmable logic (e.g., an ASIC), logic gates, a processor, and a memory. The inverse of the MRM update encoding processes may be performed in a decoder that includes similar circuitry.","The processes may be implemented in computer programs executing on programmable computers that each includes a processor and a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements). Each such program may be implemented in a high-level procedural or object-oriented programming language to communicate with a computer system. However, the programs can be implemented in assembly or machine language. The language may be a compiled or an interpreted language.","Each computer program may be stored on an article of manufacture, such as a storage medium (e.g., CD-ROM, hard disk, or magnetic diskette) or device (e.g., computer peripheral), that is readable by a general or special purpose programmable computer for configuring and operating the computer when the storage medium or device is read by the computer to perform the processes. The processes may also be implemented as a machine-readable storage medium, configured with a computer program, where, upon execution, instructions in the computer program cause a machine to operate in accordance with the processes.","Embodiments of the processes may be used in a variety of applications. Although the processes are not limited in this respect, the processes may be used with memory devices in microcontrollers, general purpose microprocessors, digital signal processors (DSPs), reduced instruction-set computing (RISC), and complex instruction-set computing (CISC), among other electronic components. However, it should be understood that the processes are not limited to use with these examples.","Embodiments of the processes may also be included in integrated circuit blocks referred to as core memory, cache memory, or other types of memory that store electronic instructions to be executed by a microprocessor or store data that may be used in arithmetic operations.","The claims are not limited to the embodiments described herein. For example, the processes described herein can be used on meshes other than MRMs. The processes can be used on vertex updates other than, and in addition to, those shown."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 6","b":"15"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 16","FIG. 5"]},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 17","FIG. 16 and a"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 18","b":["16","17"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 20","FIG. 3"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 21","FIG. 20 and a"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 22","b":["20","21"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 26","FIG. 25 and a"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 27","b":["25","26"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 37"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 38"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 39"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 40"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 41"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 42","FIGS. 1"],"b":"41"}]},"DETDESC":[{},{}]}
