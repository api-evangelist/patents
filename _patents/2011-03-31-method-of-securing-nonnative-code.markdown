---
title: Method of securing non-native code
abstract: A method to secure a non-native application. The non-native application is processed to obtain an application stub to be triggered within a virtual machine. The processing of the non-native application also provide a native code function upon which the application stub depends. The non-native function is part of a trusted module that extends security services from the trusted module to the virtual machine. The trusted module is a native code application that creates a trusted zone as a root of trustiness extending to the virtual machine by an execution-enabling mechanism between the application tab and the non-native function.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09460281&OS=09460281&RS=09460281
owner: Irdeto B.V.
number: 09460281
owner_city: Hoofddorp
owner_country: NL
publication_date: 20110331
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present disclosure relates generally to security in software applications. More particularly, the present disclosure relates to securing non-native applications that are executed in a virtual machine.","Virtual machines and script interpreters are known. Software applications designed for execution by a process virtual machine, or a script interpreter, are shielded from the underlying hardware and operating system of the computing platform on which they run. As such, these applications, which can be referred to as non-native applications, cannot access the security resources provided by the computing platform and, cannot use protective measures available to native applications. Additionally, many established software security and protection techniques, which are designed to protect native code (e.g., machine code), cannot be directly adapted to process non-native applications. Security approaches that provide restricted protection of a computing system (e.g., sandbox security), within which a non-native application can run, may limit this adaptation capability even further. As such, process virtual machines or script interpreters are fundamentally un-trusted and vulnerable to attacks.","In recent years, tablet computers and smart phones have been the subject of exceptional growth, as have the number of software applications available to them. Many such software applications are non-native applications that have little computing platform dependency. As an example, some applications for tablet computers and smart phones can be loaded, triggered and run within a web browser that cannot provide a native environment and acceptable security.","Therefore, improvements in protection and security of non-native applications that run on virtual machines and script interpreters are desirable.","In a first aspect, the present disclosure provides a method to secure execution of a non-native application coded in non-native code. The method comprises: modifying the non-native application to obtain a native code function and an application stub, the native code function being executable within a pre-defined trusted module, the pre-defined trusted module having one or more native environment security functions, the application stub having at least one execution dependency dependent on the native code function, the at least one execution dependency including a call to the native code function. The method further comprises packaging the application stub with the native code function.","The method can further comprise: loading the application stub within a non-native environment; loading the native code function within the pre-defined trusted module; and executing the application stub in the non-native environment, the at least one execution dependency causing the application stub to call the native code function to cause the native code function to be executed within the pre-defined trusted module in accordance with at least one of the one or more native environment security functions.","The non-native application can include a non-native code function, and modifying the non-native application can include converting the non-native code function into a counterpart native code function.","The non-native application can includes a non-native code function with a non-native code function functionality; modifying the non-native application can include converting the non-native code function into partial non-native code functions, and installing the partial non-native code functions in the non-native application stub; and the native code function can includes one or more bridge functions to bridge the partial non-native code functions to obtain bridged partial non-native code functions, the bridged partial non-native code functions having a functionality equivalent to that of the non-native code function.","The non-native application can include a non-native code function with a non-native code function functionality; modifying the non-native application can include converting the non-native code function into partial non-native code functions, installing a first portion of the partial non-native code functions in the non-native application stub, and installing a second portion of the partial non-native code functions in an application library, the application library being encompassed within the pre-defined trusted module; and the native code function can include one or more bridge functions to bridge the first and second portions of the partial non-native code functions to obtain bridged partial non-native code functions, the bridged partial non-native code functions having a functionality equivalent to that of the non-native code function.","The non-native application can include a non-native code function with a non-native code function functionality; modifying the non-native application can include converting the non-native code function into at least one partial non-native code function and at least one partial native code function, the at least one partial non-native code function being part of the non-native application stub; and the native code function can include one or more bridge functions to bridge the at least one partial non-native code function and the at least one partial native code function to obtain bridged partial native and non-native code functions, the bridged partial native and non-native code functions having a functionality equivalent to that of the non-native code function.","The non-native application can include a plurality of non-native code functions having an overall functionality; modifying the non-native application can include installing the plurality of non-native code functions in the non-native application stub; and the native code function can include one or more bridge functions to bridge the plurality of non-native code functions to obtain bridged non-native code functions, the bridged non-native code functions having a functionality equivalent to that of the overall functionality of the plurality of non-native code functions.","The non-native application stub can include a secure loader stub and the one or more native environment security functions can include a secure loader handler function.","The non-native application stub can include an integrity verification stub and the one or more native environment security functions can include an integrity verification handler function.","The one or more native environment security functions can include an anti-debug handler.","The non-native application can include a non-native code function with a non-native code function functionality; and modifying the non-native application can include: converting the non-native code function into partial non-native code functions, the partial non-native code functions having a first portion of partial non-native code functions and a second portion of partial non-native code functions; and installing the first portion of the partial non-native code functions in the non-native application stub; the method can further comprise: encrypting the second portion of the partial non-native code functions to obtain encrypted partial non-native code functions; and installing the encrypted partial non-native code functions in an application library, the application library being encompassed within the pre-defined trusted module, the encrypted partial non-native code functions to be decrypted at run-time to obtain a decrypted second portion of the partial non-native code functions, the decrypted second portion of the partial non-native code functions to be loaded in the non-native environment, the native code function including one or more bridge functions to bridge the first portion of the partial non-native code functions and the decrypted second portion of the partial non-native code functions to obtain bridged partial non-native code functions, the bridged partial non-native code functions having a functionality equivalent to that of the non-native code function.","The non-native code can includes at least one of Java code, Javascript code, C# code, Actionscript code, and Python code.","The call to the native code function can be done through a Java Native Interface.","The call to the native code function can done through a Netscape Plugin Application Programming Interface.","Other aspects and features of the present disclosure will become apparent to those ordinarily skilled in the art upon review of the following description of specific embodiments of the present disclosure in conjunction with the accompanying figures.","Generally, the present disclosure provides a method to secure a non-native application. The non-native application is processed to obtain an application stub to be triggered within a virtual machine. The processing of the non-native application also provides a native-code function upon which the application stub depends. Upon triggering of the application stub, the application stub makes a function call the native-code function. The non-native function is part of a trusted module that extends security services from the trusted module to the virtual machine. The trusted module is a native-code application that creates a trusted zone as a root of trustiness extending to the virtual machine by an execution-enabling mechanism between the non-native application stub and the non-native function.","In order to securely connect to the trusted module, certain embodiments of the present disclosure extend the virtual machine execution environment and enable the virtual machine application to use the security services provided by the trusted module, as well as enabling the trusted module to access the virtual machine in support of security related features. A virtual lock can be established to bind the virtual machine (non-native) application to the trusted module. The virtual lock provides execution interlocking between applications running on the virtual machine and the trusted module, and ensures that the applications are unable to run without the trusted module. Once the interlocking is established, the trustworthiness of the trusted module can be extended to the virtual machine application. Security features can vary based on the virtual machine application and on the virtual machine implementation.","The trusted module can support a wide range of virtual machine implementations each with a potentially different instruction set architecture. Certain embodiments of the trusted module provide a number of basic security features that protect applications in a virtual machine or in a scripting engine.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 1","FIG. 1"],"b":["20","22","24","26","22","26","22","24"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 2","FIG. 1","FIG. 2"],"b":["30","32","30","32","34","36","34","36","34","36","36"]},"The non-native application stub  and the native code function(s)  will have, at runtime, the equivalent functionality of the original non-native application . As will be described in more detail below, the interlocking tool  can add non-native application functions to the application stub  that call the native code function(s) . As a result of the modification of the non-native application , the non-native application stub  will not provide complete functionality of the non-native application  without the native code function(s) .",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 3","b":["34","36","34","38","36","40","40","42","42","38","34","40"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4","b":["44","46","48","40","42","36","38","34","50","34","34","38","52","40","42","46","38","44","48","40","52","34"]},"As disclosed above, it is possible to secure a non-native application  by modifying the non-native application  to obtain a non-native application stub  that has execution dependencies dependent on a native code function(s) , and by packaging the non-native application stub  and the native code function(s) . As will be described below, the functionality of the non-native application  can by achieved by having the non-native application stub  invoke a down call to the trusted module  to execute the native code function(s) . Execution dependencies can occur at various places within the non-native application stub  and\/or the native code function(s) and can be triggered at any appropriate stage. Rules regarding how, when, and where dependencies are created, triggered, and executed can be defined at build-time by using configuration control, and individualized at provisioning time. The original functionality of the non-native application  is preserved through the execution dependencies of the non-native application stub  on the native code function(s) .",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5","b":["32","38","32"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 6","FIG. 7","FIGS. 6 and 7","FIGS. 6 and 7"],"b":["32","32","34","40","42","32","54","42","40","32"],"sub":["1 ","2","1 ","2 ","1 ","2 ","1 ","2","1 ","2","1 ","2","1 ","2","1 ","2 ","1 ","2 ","1 ","2","1 ","2 ","1 ","2 "]},"At application runtime, a call the partial non-native function Fwill invoke a call to B via the trusted module . If Fis within the application stub  (example of ), B will transfer execution from B to F. If the partial non-native function Fis within the application library  (example of ), B will dynamically retrieve the partial non-native function Fusing a native execution mechanism. Once the partial non-native function Fis loaded into the virtual machine , the non-native code function Fcan be invoked by the native-code function B, which is in the trusted module . A return value from Fcan then be proxied back, by B, to the partial non-native code function F.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 8","FIG. 5","FIGS. 6 and 7"],"b":["32","32"],"sub":["1","2","1 ","2 ","1 ","2 ","2 ","2"]},"The partial non-native code function Fcan be installed in the non-native application stub , the partial native code function F\u2032can be installed in the application library , and the native code function B can be installed in the trusted module API . In the example of , the original execution dependency of the function F is replaced by a new execution dependency from Fto B to F\u2032. That is, Fmakes a call to function B, which makes a call to function F\u2032. B is an execution bridge between Fand F\u2032. F\u2032and B are in the trusted module . The bridged functions Fand F\u2032have a functionality equivalent to that of the non-native function F of the non-native application .","The non-native function F has been replaced by a partial non-native code function F, a partial native code function F\u2032, and bridging native code function B. Without executing B and F\u2032, the execution of Fis only a partial execution, and Fdoes not have necessary information and ability to transfer the execution directly from Fto F\u2032.","At Application runtime, a call to Finvokes a call to B via the trusted module , which executes function F\u2032within the context of the trusted module . F\u2032is a native code function which can have the partial (or complete) functionality of the non-native function F. A function return value from F\u2032can be passed back to Ffunction from the F\u2032function call through the native code function B.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 9","b":["32","38"]},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 10","b":["32","32","42","32","32"],"sub":["1 ","1","1 ","1 ","1 ","1 ","1 ","1","1 ","1","1 ","1 ","1 ","1 "]},"At Application runtime, a call to function Finvokes a down call B to the trusted module , the trusted module  then invokes an up-call to execute function G. A function return value may be passed back to Ffrom Gfunction call via the native function B in the trusted module .","Once a non-native application has been locked to a trusted module  using one or more of the above locking methods, additional security techniques can be applied. Security techniques can be based, for example, on the type of virtual machine, and on the non-native applications.","Examples of dynamic loading and bridge execution, trusted function execution, and trusted function invoking, are described below in the context of the non-native application being coded in Java source code.","Java source code is normally compiled to a byte level code for deployment and execution in a Java virtual machine. The specifications of Java byte code are standardized and are used by Java virtual machine implementers. There are existing open source and commercial tools that have features for modifying java byte code.","In some embodiments of the present disclosure, a Java implementation of the interlocking tool  of  would need to modify the Java application prior to deployment. The interlocking tool  may be capable of modifying Java byte code and or Java source code, and implementing these capabilities would be an option available to the interlocking tool provider, as one of ordinary skill in the art will appreciate.","Java has features that allow Java to call native modules. This bridge mechanism between Java and native code is called the Java Native Interface, which supports calling native C code. The Java Native Interface bridge enables down-calls (Java calling native code) and up-calls (native code calling Java code running within the Java virtual machine runtime environment). Using the Java Native Interface can allow implementation of the partial execution techniques disclosed above.","For a dynamic loading and bridge execution technique (examples at ), the non-native code of the non-native application can be modified by changing existing functions (or classes, class methods), and replacing with calls to a trusted module  via the Java Native Interface bridge. During runtime execution, the call to the trusted module  is invoked, and the trusted module  can load the function byte code from the trusted module security context, into the Java virtual machine and execute it, via the Java Native Interface bridge.","The features of the Java Native Interface bridge can also allow for implementation of the Trusted Function Execution technique (example of ). The Interlocking tool  (shown at ) would analyze the Java source code (or byte code) of the Java application, and would replace function code with calls to the trusted module , which execute equivalent functionality within the context of the trusted module .","The Java Native Interface mechanism is also applicable for Trusted Function Invocation (example of ). Calls to nested functions within functions are replaced with calls to a trusted module , as determined by the Interlocking tool  when applied to the Java source code (or byte code). During runtime, the Java Native Interface bridge enables the trusted module  to be invoked, which in turn determines the appropriate function to invoke, the trusted module  would then execute an up-call to the Java virtual machine, calling the nested function along with associated arguments etc.","As such, the Java Native Interface is an example of a mechanism that can enable the non-native application stub to call the native code function B in the examples described herein.","Web applications provide a user interface that is run within a web browser, for presentation and user interaction. Web applications are typically comprised of pages that have HTML and JavaScript functions that are delivered to a web browser, which interprets the HTML page, and transforms the page into an internal Document Object Model representation. Web browsers are software applications and most provide a bridge mechanism enabling web applications to call native code modules, and also enable native code modules to access internal web applications. A common bridge mechanism (or web browser plugin interface) is the Netscape Plugin Application Programming Interface (NPAPI) used in Firefox\u2122, Google Chrome\u2122, Safari\u2122, Opera\u2122 web browsers. The NPAPI allows web applications to invoke down calls to a native module and also allow native modules to invoke up-calls to the web browser application runtime environment. This NPAPI bridge mechanism can be used to enable the partial execution techniques disclosed herein.","For certain embodiments of the Dynamic loading and bridge execution technique, the source HTML and JavaScript functions can be modified, changing existing functions, and replacing with calls to the trusted module  via the NPAPI bridge. During runtime execution, the call to the trusted module  is invoked, and the trusted module  can load, for example, JavaScript function code from the trusted module  security context, into the web application runtime environment and execute it, via the NPAPI bridge.","The features of the NPAPI bridge in supported web browsers also allow for implementation of the Trusted Function Execution technique. The Interlocking tool  (shown at ) can analyze the web application source code replacing JavaScript function code with calls to the trusted module , which execute equivalent functionality within the context of the trusted module .","The same mechanism may also be applicable for Trusted Function Invocation (example of ) in that calls to nested JavaScript function within functions can be replaced by calls to the trusted module , as determined by the Interlocking tool  when applied to the web application source. During runtime, the NPAPI bridge enables the trusted module  to be invoked, which in turn would determine the appropriate function to invoke, the trusted module  would then execute an up-call to the web application, calling the nested JavaScript function along with associated arguments etc.","In absence of interlocking to a trusted module, when implementing a secure loader in a non-native execution environment, the application calling a trusted module to securely load the application can potentially be spoofed. That is, a rogue application could impersonate the original calling application initiating the secure loader. By interlocking the application with a trusted module, the calling application can be authenticated and verified by the trusted module. Without the interlocked trusted module, the application would fail to load. Examples of secure loading mechanisms can be found in International Patent Application Publication Number WO 2010\/1247438, and in International Patent Application Number CA2010\/001761.","Again, in absence of interlocking, when applying integrity verification techniques, possible security attacks could involve replacing the virtual machine or application with a rogue implementation in order to bypass integrity verification checks during runtime. By interlocking the application with a trusted module, the calling application and or virtual machine can be authenticated and verified by the trusted module at start up and also during runtime. Without the interlocked trusted module, the application would fail to start and or execute.","Additional security functions can be added to the interlocking execution techniques described above in relation to the examples of , to deter security breaches such as those described below. For example, the application security module  (shown at ) can support security functions, such as the following. A) Secure loading of an application, which can prevent reverse engineering attacks to the application; B) Integrity verification of an application, which can prevent static and dynamic tampering attacks to the application; C) Debug prevention of an application, which can prevent dynamic attacks using attack tools such as a debug or simulator; and, D) Dynamic encryption of an application, which can prevent static tampering and dynamic code lifting attacks. The security functions A-D are provided as examples only, and one of ordinary skill in the art will appreciate that other functions may be equally supported. Examples of security functions A-D are provided below.","In addition to security functions such as security functions A-D, the security module  can export trusted module discovery primitives and similar communication primitives to enable multiple virtual machines to use the trusted module (even simultaneously). As the trusted module  is a native application, it can use all security functions provided by the computing platform. The trusted module provides an abstraction of these security features to the virtual machine and\/or the script engine. As a separate module, the trusted module  can be replaced independently from the virtual machine and the script engine. This makes it possible to separate application trust management and the feature set provided by the virtual machine.","Securely loading of a non-native application can be used to prevent static analysis type attacks on the application and its related data before it is executed.  shows an example of how the secure loader functionality can be extended to a scripting language environment (or a virtual machine execution environment) by adding a trusted module .","Prior to the deployment of non-native application , a secure loader pre-provisioning step occurs where the non-native application sub-components (e.g., a function, a classe, a module) are identified and encrypted and stored as a secured resource(s) for input into the secure loader start-up step. These resources are encrypted so that only the trusted add-on module is able to decrypt the resources.","Integration of a Secure Loader Stub  into the non-native application  is required in order to define the trigger point for initiating the secure loading of the non-native application sub-components into the application runtime from the trusted module . The Secure Loader stub  is a non-native application sub-component that is able to invoke secure loader function(s) of the trusted module . Subsequently, the non-native application  along with the trusted module  and the encrypted sub components are deployed.","At application start-up time, the secure loader stub  is triggered by the application . This trigger calls the secure loader stub , which in turn invokes a down call  to the trusted module , signaling it to load application sub-component(s).","The trusted module  authenticates a request from the secure loader stub  component and invokes the secure loader handler , which is a native code function. If the trusted module  is unable to authenticate the calling application, the application  fails to load.","The trusted module  identifies the application sub-components and decrypts the application sub-component. Once the trusted module  has decrypted an application sub-component, it then places an up call  to the application runtime, loading the application sub-component into the application context.","The decrypted application sub-component is now available to the non-native application context. Once completed, the trusted module  may optionally return a status result the secure loader stub  down call method invocation.","Integrity verification can validate that the non-native application has not been tampered with.  shows an exemplary process for integrity verification in accordance with an embodiment of the present disclosure:","Prior to the deployment of non-native application , an integrity verification pre-provisioning step occurs where the application sub-components are identified for integrity verification purposes. During this step, a cryptographic hash value is calculated on each sub-component. The sub-component hash values  (e.g., SHA-1) are encrypted such that only the trusted module  is able to retrieve and decrypt the values.","During the pre-provisioning step, prior to the hash calculation step, integrity verification trigger points are defined in the non-native application . Integrity verification trigger points are defined in an Integrity Verification Stub , which in turn makes a down call to the trusted module . Optionally, integrity verification trigger points can be integrated with business logic, such that a down call  is required during application runtime in order to invoke some business logic (linked with the trusted module ), which in turn may invoke a integrity verification check.","Subsequently, the non-native application , the trusted module  and the encrypted hash values  are deployed. At application startup or during runtime, as determined by the integrity trigger points, the integrity verification stub  is invoked by the non-native application . The integrity verification stub  invokes a down call  to the trusted module  signaling an integrity verification check to run. The integrity verification stub  may pass application context information to the trusted module , to be utilized by the trusted module  for integrity verification.","Following this, the trusted module  authenticates a request from the integrity verification stub  component and invokes the integrity verification handler , which is a native code function. If the trusted module  is unable to authenticate the calling application, the non-native application  can invoke some application specific failure policy.","Subsequently, the trusted module  identifies the application sub-components from the non-native application context information passed to it and decrypts the internal application sub-components hash value(s) .","The trusted module  performs a dynamic integrity verification comparison check of the application sub-component by placing an up call to the application  and retrieving the in-memory sub-component representation. The trusted module  then calculates the hash value of the in-memory subcomponent and compares with the decrypted hash value deployed with the application.","If the integrity verification comparison check fails, the trusted module  may fail the non-native application , using failure policy that is determined during the application pre-provisioning step.","Once completed the trusted module  may optionally return a status result the integrity verification stub  down call method invocation.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 13"},"Prior to the deployment of the non-native application , an anti-debug policy is defined for the non-native application . The policy is enabled by the trusted module  and can be triggered in various ways, for example: a) By designated down-calls; b) By designated integrity verification checks; and, c) By designated secure loader calls, all of which can be made part of a non-native application stub associated to the non-native application .","During the non-native application execution, an anti-debug check can be triggered and launched from within the trusted module . An anti-debug handler  within the trusted module  is invoked to perform anti-debug platform and language specific checks such as: a) Time based anti-debug; b) Exception based anti-debug; and, c) Application runtime specific checks.","The present disclosure discusses the deployment of a Trusted Module that can secure virtual machine applications. As one of ordinary skill in the art will appreciate, a single trusted module can service more than one VM. Further, the present disclosure may be relevant to a wide range of widely used computing platforms.","In the preceding description, for purposes of explanation, numerous details are set forth in order to provide a thorough understanding of the embodiments. However, it will be apparent to one skilled in the art that these specific details are not required. In other instances, well-known electrical structures and circuits are shown in block diagram form in order not to obscure the understanding. For example, specific details are not provided as to whether the embodiments described herein are implemented as a software routine, hardware circuit, firmware, or a combination thereof.","Embodiments of the disclosure can be represented as a computer program product stored in a machine-readable medium (also referred to as a computer-readable medium, a processor-readable medium, or a computer usable medium having a computer-readable program code embodied therein). The machine-readable medium can be any suitable tangible, non-transitory medium, including magnetic, optical, or electrical storage medium including a diskette, compact disk read only memory (CD-ROM), memory device (volatile or non-volatile), or similar storage mechanism. The machine-readable medium can contain various sets of instructions, code sequences, configuration information, or other data, which, when executed, cause a processor to perform steps in a method according to an embodiment of the disclosure. Those of ordinary skill in the art will appreciate that other instructions and operations necessary to implement the described implementations can also be stored on the machine-readable medium. The instructions stored on the machine-readable medium can be executed by a processor or other suitable processing device, and can interface with circuitry to perform the described tasks.","The above-described embodiments are intended to be examples only. Alterations, modifications and variations can be effected to the particular embodiments by those of skill in the art without departing from the scope, which is defined solely by the claims appended hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the present disclosure will now be described, by way of example only, with reference to the attached Figures, wherein:",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
