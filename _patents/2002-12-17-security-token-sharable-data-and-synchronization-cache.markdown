---
title: Security token sharable data and synchronization cache
abstract: This invention provides a system and method for implementing a middleware caching arrangement to minimize device contention, network performance and synchronization issues associated with enterprise security token usage. The invention comprises a token API mapped to a cache API. Logic associated with the token API preferentially retrieves information from a memory cache managed by the cache API. Mechanisms are included to periodically purge the memory cache of unused information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07032067&OS=07032067&RS=07032067
owner: Activcard
number: 07032067
owner_city: Suresnes Cedex
owner_country: FR
publication_date: 20021217
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["A portion of the disclosure of this patent document contains material subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent files or records, but otherwise reserves all copyright rights whatsoever.","The present invention relates generally to a data processing system and method and more specifically to remote transaction cache associated with a security token.","Security tokens are tamper resistant hardware devices used to securely store digital credentials, cryptographic keys and other proprietary information. The tokens are packaged in a convenient and easily transportable medium and generally communicate with a host client using standardized IEEE serial communications protocols. Examples of security tokens include smart cards, integrated circuit cards, subscriber identification modules (SIM), wireless identification modules (WIM), USB token dongles, identification tokens, secure application modules (SAM), secure multi-media tokens (SMMC) and like devices.","The single input\/output nature of a serial connection is known to cause local device contentions when multiple requests to access the security token are received by the local client. In a multi-user networking environment, serial device contentions can impair network performance as each requesting remote service must wait in line for its request to be processed by a particular security token. The device contentions can be minimized to some extent by assigning priorities to the access requests. However, prioritization does not provide significant performance improvements in operating environments where a multitude of identically prioritized requests occur within a small time frame such as at the start or end of a work day where large numbers of entities are logging into or out of a network.","A second problem arises when the information contained in the security token is shared among multiple services, Information requested by one application may be altered, moved or deleted by another application resulting in application errors, system crashes and lost data. One solution known in the art is to exclusively lock the security token to a particular application until all transactions between the exclusive application and security token have been completed. This solution has limited usefulness though since exclusively locking the security token for prolonged periods may exacerbate the network performance issues described above.","Other solutions include the use of secure shared memory arrangements and caching techniques. Memory sharing is useful if the information to be shared does not require extensive security protocols to be implemented. While secure memory sharing mechanisms do exist, the increasing complexity of maintaining the integrity of the shared memory tends to be system resource intensive and inadvertent \u201csecurity holes\u201d are always a concern. Caching of information is another common technique which provides reasonable performance improvements. An example of a data object caching technique is disclosed in U.S. Pat. No. 6,304,879 to Sobeski, et al. This patent describes a reasonable caching technique suitable for data objects but is not well suited for implementation with a security token as there are no intrinsic security measures incorporated into the disclosed invention.","Thus, it would be highly advantageous to provide a reasonably secure caching mechanism suitable for implementation with a security token which addresses the limitations described in the relevant art above.","This invention addresses the limitations described above. The caching mechanism comprises a security token interface applications programming interface (API) which is mapped to a cache API and may be installed in a local client, one or more servers or co-located in both the client and server(s).","The cache API receives requests for information from the security token interface API which includes a cross reference containing a specific unique identifier associated with the security token and an encoded semantic. The unique identifier is usually a serial number masked into the security token by the token manufacturer. Information is stored in the memory cache by associating the unique security token identifier with the semantic forming a unique cache identifier. It is also envisioned that semantics related to set of security tokens may be cached as well. For example, a semantic may be defined to determine which security tokens contain a digital certificate for updating purposes.","A separate unique cache identifier is required for each instance of information stored in the memory cache to differentiate data obtained from a single security token. In the preferred embodiment of the invention, handles are used in lieu of the actual serials numbers and\/or semantics to simplify the various combinations of unique identifiers and semantics. Handles as defined herein include a pseudonym or token that a program can use to identify and access an object.","The cache API locates the particular security token record in the memory cache by using a handle related to the security token's unique identifier, a semantic or both to arrive at the unique cache identifier. If no occurrence of the requested information is included in the cache, the request is redirected to the token interface API for processing and retrieval of the information from a security token.","If the requested information is not present in the security token, a pseudo-entry is generated by the security token interface API and transferred to the cache API for storage in the memory cache. The pseudo-entry appears to the cache API as regular data entry and is used to prevent future requests for the same missing information being routed to the security token.","Once information is retrieved from the security token, the security token interface API transfers the information to the cache API for storage in the memory cache where it is available for future retrieval. The type of information to be cached is categorized as non-proprietary, proprietary and administrative. In the preferred embodiment of the invention, the memory cache is divided into three distinct components including a first component generally containing non-proprietary, a second component containing proprietary information, and a third component containing administrative information necessary to manage and utilize the information stored in the other portions of the memory cache. Dividing the memory cache into three separate components provides greater flexibility for future enhancements to the memory cache by simply adding additional cache components.","The types of information stored in the memory cache include digital certificates, public keys, password information, properties and configurations related to these datum, token management information, security state information and listings of applets installed inside the security token(s). It should be apparent to one skilled in the art that any information retrievable from a security token may be stored in the memory cache.","An additional feature of this invention includes a residence time limitation for which in formation remains in the memory cache. After a preset period without repeated access, all or the proprietary portion of the memory cache is flushed. To maintain synchronicity with the information retrieved from the security token, a counter mechanism is included to ensure that the calling application receives the latest version of information contained in the security token.","This present invention provides a system and method for caching of information retrieved from a security token to minimize local device contentions, improve network performance and maintain consistency of information stored in an associated security token.","Referring to , a security token  is shown operatively connected to a local client . The local client  may be in processing communications over a network  with one or more servers , A. The local client includes one or more applications  requiring access to information originally stored in the security token . The application  is associated with a token API . The token API  is a middleware applications programming interface which communicates with the security token  and a local cache API . Requests received from the application  usually include a unique identifier associated with a particular security token and a semantic which are converted by the token API  into a unique reference identifier for storage in the memory cache .","The invention may be installed on one or more local clients , A, one or more servers , A or both clients and servers , A, , A. Each instance of the invention operates independently of each other and may contain the same, overlapping or completely different information. The contents of each cache , A, B, C is dependent on information requests promulgated by each application , A, B, C to each token API , A, B, C and cached by each cache API , A, B, C.","For purposes of this invention, if remote caches are implemented rather than local caches, each local client provides the necessary hardware and software interfaces for the security token , A to communicate with each server , A but otherwise does not enter into the system.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1A","b":["30","35","35","5","40","65","70","65","35","65","65","45","30"]},"The cache API  controls the memory cache . The memory cache  is divided into at least three components. The first component G  of the memory cache  retrievably stores generally uncontrolled information for example, public keys, digital certificates and other non-proprietary information. The second component P  of the memory cache  retrievably stores proprietary information for example, passwords and related information.","The third component A  retrievably stores administrative information used by the cache API  to retrieve information stored in the either the general or proprietary cache components , . The third component A  of the memory cache  may exist as part of the cache or as a separate lookup table and includes unique reference numbers, cross reference information, and time stamps associated with information stored in the memory cache .",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2","b":["205","30","205","35","205"]},"The token API  includes logical instructions to first determine if the requested information  is available from the cache API  and secondly if the information stored in the cache is current  before attempting to retrieve the information from the associated security token referenced by CID[#].","Referring to , the cache API  converts the original request  into a unique reference identifier REQ[]  which is then routed to the cache API  for processing. The cache API  performs a lookup function  of unique references REQ#  contained in the administrative component  of the cache using the reference identifier . To better illustrate the lookup function, an example unique reference identifier REQ[]  is sent to the administrative component A  to determine if the requested information  has already been retrieved.","In this example, a match is found  indicating that the requested information  is already present in the memory cache . The unique cache identifiers C#  are used to both uniquely identify the requested information and also determine which cache component contains the information. In this example, cache identifiers beginning with the number 2 denotes proprietary information which is stored in the second cache component P . Cache identifiers beginning with a 1 are stored in the first cache component G  under cache identifier C# .","A new time stamp  is applied to the identified information . The time stamps  are used to define the residence time for information stored in the memory cache  and are adjustable to suit different operating conditions. If after a predetermined period has expired without repeat access to a particular piece of stored information, the unused information is flushed from the cache.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2B","b":["202","264","234","55","269","2","268","202","266","255","275","30","35"]},"Referring to , a problem could arise where a request for non-existent information causes repeat attempts to access the security token, defeating the purpose of the cache. To prevent this situation, after the first occurrence of the unavailable information, the cache API  generates a pseudo entry which is stored in the appropriate cache component ,  by the cache API . Upon receipt of an otherwise valid request REQ[] , the cache API  performs a lookup  which points  to a pseudo entry  contained  in the first cache component G  and updates the time stamp  associated with this entry.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 2D","b":["273","275","40","280"]},"Referring to , this last example depicts the case where a request for information has not previously been processed. An incoming request  REQ[] is processed by the cache API  and no match is found . A not found message NF  is generated by the cache API and sent  to the token API  which signals the token API  to retrieve the information from the security token originally identified in the received request.","In , the information is retrieved by the token API  and sent  to the cache API  for storage. A new entry  is added to the administrative cache component , a new cache ID   and a new time stamp  are assigned to the entry. The new information PW  is stored  in the proprietary cache component according to the newly generated cache identifier  .","In , the steps to implement the preferred embodiment of the invention are depicted. The process is initiated  by a request for information being received  by the token API. The token API then determines if the information contained in the memory cache is current . If the information of the cache is current  the request is routed directly to the cache API for processing . If the information is not current , the cache is first refreshed  then referred to the cache API  for processing.","The cache API determines if the requested information is available from the cache . If the information is not available from the cache  the cache API notifies the token API to retrieve the information from the associated security token . If the information is not available from the security token , the token API generates a pseudo cache entry  which is stored in the memory cache by the cache API, a not available \u201cA\u201d message is returned to the requester , a new time stamp entry is created  by the cache API, followed by processing termination .","If the information is available from the security token , the information is retrieved, a copy stored in the memory cache , the information returned to the requestor , a new time stamp entry is created  for the new entry by the cache API, followed by processing termination .","If the information is directly available from the cache , the cache API retrieves the information from the cache , the information returned to the requestor , the time stamp entry is updated  by the cache API, followed by processing termination .","The foregoing described embodiments of the invention are provided as illustrations and descriptions. They are not intended to limit the invention to precise form described. In particular, it is contemplated that functional implementation of the invention described herein may be implemented equivalently in hardware, software, firmware, and\/or other available functional components or building blocks. No specific limitation is intended to a particular security token operating environment. Other variations and embodiments are possible in light of above teachings, and it is not intended that this Detailed Description limit the scope of invention, but rather by the claims following herein."],"heading":["FIELD OF INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["The features and advantages of the invention will become apparent from the following detailed description when considered in conjunction with the accompanying drawings. Where possible, the same reference numerals and characters are used to denote like features, elements, components or portions of the invention. It is intended that changes and modifications can be made to the described embodiment without departing from the true scope and spirit of the subject invention as defined in the claims.","FIG. \u2014is a generalized block diagram illustrating the placement of the invention in various computer systems.","FIG. A\u2014is a generalized block diagram illustrating the major components included in the invention.","FIG. \u2014is a detailed block diagram illustrating the routing and data content of a request for information.","FIG. A\u2014is a detailed block diagram illustrating the initial processing of the request for information by a cache API and associated memory cache components.","FIG. B\u2014is a detailed block diagram illustrating the retrieval of the requested information from the memory cache.","FIG. C\u2014is a detailed block diagram illustrating the attempted retrieval of the requested information which is not available from an associated security token.","FIG. D\u2014is a detailed block diagram illustrating the return of a not available message from the memory cache.","FIG. \u2014is a detailed block diagram illustrating a request to retrieve information from the memory cache which has not yet been retrieved from the associated security token.","FIG. A\u2014is a detailed block diagram illustrating a newly retrieved item being stored in the memory cache and generation of associated cross references","FIG. \u2014is a flowchart illustrating the major steps involved in implementing the preferred embodiment of the invention."]},"DETDESC":[{},{}]}
