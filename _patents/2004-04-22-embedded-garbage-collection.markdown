---
title: Embedded garbage collection
abstract: An electronic system comprises a processor, memory coupled to the processor, and an application programming interface that causes an embedded garbage collection object to be active. The memory stores one or more objects that selectively have references from root objects. The embedded garbage collection object preferably uses control data to cause objects to be removed from said memory, the removed objects comprise those objects that were created while an embedded garbage collection object was active and that do not have references from root objects.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07565385&OS=07565385&RS=07565385
owner: Texas Instruments Incorporated
number: 07565385
owner_city: Dallas
owner_country: US
publication_date: 20040422
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["This application claims priority under 35 USC \u00a7 (e)(1) of European Application Number 03291506.8, filed on Jun. 19, 2003.","1. Technical Field of the Invention","The present invention relates generally to processors and more particularly to management of memory associated with processors.","2. Background Information","Many types of electronic devices are battery operated and thus preferably consume as little power as possible. An example is a cellular telephone. Further, it may be desirable to implement various types of multimedia functionality in an electronic device such as a cell phone. Examples of multimedia functionality may include, without limitation, games, audio decoders, digital cameras, etc. It is thus desirable to implement such functionality in an electronic device in a way that, all else being equal, is fast, consumes as little power as possible and requires as little memory as possible. Improvements in this area are desirable.","In some embodiments, an electronic system comprises a processor, memory coupled to the processor, and an application programming interface that causes an embedded garbage collection object to be active. The memory stores one or more objects that selectively have references from root objects. The embedded garbage collection object preferably uses control data to cause objects to be removed from said memory, the removed objects comprise those objects that were created while an embedded garbage collection object was active and that do not have references from root objects.","In other embodiments, a method comprises starting an embedded garbage collector, selecting an object to remove from memory, the memory including root objects that selectively may have references to associated objects and removing the selected object. Selecting the object to remove comprises identifying root objects whose context have changed and tracing the identified root objects to referenced objects to determine which objects are associated with a root object whose context has changed. Removing the selected object comprises removing an object that both was created while the embedded garbage collector was active and that was not determined as being associated with a root object whose context has changed.","Certain terms are used throughout the following description and claims to refer to particular system components. As one skilled in the art will appreciate, semiconductor companies may refer to a component by different names. This document does not intend to distinguish between components that differ in name but not function. In the following discussion and in the claims, the terms \u201cincluding\u201d and \u201ccomprising\u201d are used in an open-ended fashion, and thus should be interpreted to mean \u201cincluding, but not limited to . . . \u201d. Also, the term \u201ccouple\u201d or \u201ccouples\u201d is intended to mean either an indirect or direct connection. Thus, if a first device couples to a second device, that connection may be through a direct connection, or through an indirect connection via other devices and connections.","The following discussion is directed to various embodiments of the invention. Although one or more of these embodiments may be preferred, the embodiments disclosed should not be interpreted, or otherwise used, as limiting the scope of the disclosure, including the claims, unless otherwise specified. In addition, one skilled in the art will understand that the following description has broad application, and the discussion of any embodiment is meant only to be exemplary of that embodiment, and not intended to intimate that the scope of the disclosure, including the claims, is limited to that embodiment.","The subject matter disclosed herein is directed to a programmable electronic device such as a processor having memory in which computer programs associated with a stack-based language (e.g., Java) may be stored. The computer programs may be executed through a \u201cvirtual\u201d machine that may be implemented in hardware, software, or both hardware and software. The virtual machine may transform the computer program into machine code (e.g., Java bytecodes) that may perform fundamental computer operations in a portion of memory referred to as a \u201cstack\u201d. While being executed by the virtual machine. Java bytecodes may utilize the stack to store intermediate values.","In addition to the stack, a portion of memory may be reserved for storing Java objects (e.g., variables, classes, types). This portion of memory may be referred to as a \u201cheap\u201d. When a Java object is created, the object is allocating memory in the heap. The size of the memory allocated in the heap may depend upon the type (e.g., int, long, array) of the Java fields included in the created object. A virtual machine may adjust the amount of memory reserved for the heap depending upon the percentage of the heap being utilized. For example, if the heap is over-utilized, the virtual machine reserves additional memory for the heap.","Objects stored in the heap may utilize other objects stored in the heap through a mechanism referred to as a \u201creference\u201d. For example, a first object may use a variable associated with a second object. Once loaded into the heap, the first object may create a reference to the second object. Once the reference between the objects has been created, the first object can access the variable associated with the second object. A set of all references associated with an object is referred to as the \u201ccontext\u201d for that object. References are inserted and modified through a \u201cPutRef\u201d operation that corresponds to every Java bytecodes that makes a write on a reference field or on an array element. As such, the context of a Java object may change only when a PutRef operation is issued on the object.","The size of the heap may be limited by the total amount of memory associated with a system. Once the heap reaches this maximum size and becomes fully utilized, no additional objects may be created. Once this state occurs, objects currently stored in the heap that may no longer be needed are taken out of the heap by a Java process to make room for other objects. The Java process that is responsible for removing objects from a heap may be referred to as a \u201cgarbage collection\u201d process. Garbage represents the objects a garbage collection process selects to permanently remove from the heap. After a garbage collection process permanently removes objects from the heap, memory associated with these objects may be allocated for other objects.","A garbage collection process uses \u201croots\u201d to identify objects that can be permanently removed from the heap. Although the user can assign roots, generally roots are automatically assigned by the underlying object runtime. This object runtime creates the first objects of the application, which are objects not necessary viewed by the application itself, or creates stacks (memory blocks) that contains references to objects, and assigned these object as roots.","After roots are identified and assigned, a garbage collection process may examine references from the roots to other objects. For example,  illustrates exemplary heap  containing roots  and objects , , , and . Although not explicitly shown, roots  may comprise any objects stored in the heap assigned as roots by a garbage collection process. Roots  may directly reference object  through reference . Object  may further reference object  through reference . When a garbage collection process is running on heap , all references from roots  may be followed by a procedure within the garbage collection process. The procedure of following references from a root object to other objects stored in a heap may be referred to as a \u201ctrace routine\u201d. For example, a trace routine on heap  may identify Java objects  and  as being accessible by roots . Based-upon the objects identified during the trace routine, a garbage collection process may determine which objects are to be removed from the heap. Objects identified in the tracing routine typically are not removed and objects not identified in the tracing routing are removed. Since the tracing routine starts from the roots, objects identified are called \u201creachable\u201d objects from the roots and objects not identified are called \u201cunreachable\u201d objects. The rationale behind this removal technique considers objects not identified in the tracing routine as not necessary for the application running and thus may be removed. In the example of , objects  and  do not have references and thus will not be identified in the trace routine on heap . As such, a garbage collection process may remove these objects from the heap. The preferred embodiment of the invention may combine garbage collectors, such as that described above, with a preferred garbage collector described below.","The following describes the operation of the preferred embodiment of a system in which a garbage collection process may remove objects from the heap after the objects are used by a machine (e.g., processor, virtual machine). Other processor architectures and embodiments may be used and thus this disclosure and the claims that follow are not limited to any particular type of processor. Details regarding the garbage collection process follow the description of the processor and virtual machine.","The processor described herein is particularly suited for executing Java\u2122 Bytecodes, or comparable code. As is well known, Java is particularly suited for embedded applications. Java is a relatively \u201cdense\u201d language meaning that on average each instruction may perform a large number of functions compared to various other programming languages. The dense nature of Java is of particular benefit for portable, battery-operated devices that preferably include as little memory as possible to save space and power. The reason, however, for executing Java code is not material to this disclosure or the claims that follow.","Referring now to , a system  is shown in accordance with a preferred embodiment of the invention. As shown, the system includes at least two processors  and . Processor  is referred to for purposes of this disclosure as a Java Stack Machine (\u201cJSM\u201d) and processor  is referred to as a Main Processor Unit (\u201cMPU\u201d). System  may also include memory  coupled to both the JSM  and MPU  and thus accessible by both processors. At least a portion of the memory  may be shared by both processors meaning that both processors may access the same shared memory locations. Further, if desired, a portion of the memory  may be designated as private to one processor or the other. System  also includes a Java Virtual Machine (\u201cJVM\u201d) , a compiler  and a display . The JSM  preferably includes an interface to one or more input\/output (\u201cI\/O\u201d) devices such as a keypad to permit a user to control various aspects of the system . In addition, data streams may be received from the I\/O space into the JSM  to be processed by the JSM . Other components (not specifically shown) may be included as desired.","Referring still to , as is generally known, Java code comprises a plurality of \u201cBytecodes\u201d . Bytecodes  may be provided to the JVM , compiled by compiler  and provided to the JSM  and\/or MPU  for execution therein. In accordance with a preferred embodiment of the invention, the JSM  may execute at least some, and generally most, of the Java Bytecodes. When appropriate, however, the JSM  may request the MPU  to execute one or more Java Bytecodes not executed or executable by the JSM . In addition to executing Java Bytecodes, the MPU  also may execute non-Java instructions. The MPU  also hosts an operating system (\u201cO\/S\u201d) (not specifically shown), which performs various functions including system memory management, the system task management that schedules the JVM  and most or all other native tasks running on the system, management of the display , receiving input from input devices, etc. Without limitation, Java code may be used to perform any one of a variety of applications including multimedia, games or web based applications in the system , while non-Java code, which may comprise the O\/S and other native applications, may still run on the system on the MPU .","The JVM  generally comprises a combination of software and hardware. The software may include the compiler  and the hardware may include the JSM . The JVM may include a class loader, bytecode verifier, a general garbage collector that may be functionally separate from the preferred garbage collector described herein, and a bytecode interpreter loop to interpret the bytecodes that are not executed on the JSM processor .","In accordance with preferred embodiments of the invention, a garbage collection process may be embedded in a computer program through the use of an application programming interface (API). The API preferably includes a series of functions that program developers may execute to control garbage collection. Since the garbage collection process is instantiated within a program, the process runs in the same memory thread as the program executing this process. By running in the same memory thread, the embedded garbage collection process can effectively remove objects utilized by a particular program. This embedded garbage collection process may be herein referred to as an embedded garbage collector (\u201cEGC\u201d).","The embedded garbage collector API (EGC-API) preferably includes three functions to control the operation of the EGC. A first function, which is the constructor function of an EGC object, instantiates the EGC in the heap and sets up data structures used by the EGC. A second function, \u201cegc.start( )\u201d, sets the EGC to an \u201cactive\u201d state. A third function, \u201cegc.stop( )\u201d, preferably carries out the tracing routine, removes selected objects from the heap, and terminates an active EGC. The state of the EGC may be considered active anytime after the egc.start( ) function has been executed to the time the egc.stop( ) function has been executed. The egc.start( ) and egc.stop( ) are preferably within the same level of method call to remove. This may remove the need of analyzing the contents of the associated stack frame for references searching.","The EGC preferably considers for removal only objects that have been created in the heap while the EGC is active. Other garbage collectors, such that described above, may be used in combination with the EGC to remove objects from the heap not considered by the EGC. In addition, as opposed to automatically assigning the roots for the tracing routine, the EGC preferably allows a program developer to specify the roots using the constructor's parameters of the associated EGC.","Specified roots may be incorporated into the EGC by using a data structure referred to as a \u201croot array\u201d. References to objects that define the roots for the tracing routine of the EGC may be included in the root array. For example, a developer may include a reference to a particular object in the root array. All references associated with this object may be identified during the tracing routine. The objects identified during the tracing routine preferably are not removed by the EGC. Other objects created while the EGC is active, in the current or in the previous activation, and not identified in the tracing routine preferably are removed. The capacity of the EGC to allow specification of root objects affords a program developer more control in the garbage collection process than with conventional garbage collectors.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 3","FIG. 3"],"b":["350","300","302","304","306","302","304","306","308","310","312"]},"The second data variable is a status bit that may be associated with each root object to indicate whether the context of references, direct or transitive references, associated with the root object have been modified. This status bit may be referred to as a \u201cmodified\u201d bit. For example, upon execution of the egc.start( ) function, the modified bits of the roots objects may be initially set to false. If during the active state of the ECG, a reference is modified, created, or deleted from an object of the current root context, the modified bit of that root object is set to true. As shown, root objects , , and  comprise modified bits , , and , respectively.","In accordance with the preferred embodiments of the invention, the modified bit may be modified automatically by the JVM . Each time a reference is created or modified, a \u201cPutRef\u201d instruction is issued to the JVM on an object. A modification of the PutRef instruction preferably is made to set the modified bit of a root object to true if a PutRef is done on an object which is inside a root context. To determine if an object is inside a root context, a third variable, referred to as a \u201croot identifier\u201d is described below.","Lastly, the third data variable in each root object is a root identifier. The root identifier stores a reference to the root object. Accordingly root objects , , and  contain root identifiers , , and .","Referring still to , two variable arrays may be used in combination with the EGC. The first array , referred to as the \u201cheapset,\u201d preferably is used to store references to objects in the heap that are inside an EGC root context before and after the EGC is active. For example, the heapset  may contain objects that are in the heap before the EGC is started. The second array , referred to the \u201ctempset,\u201d preferably is used to store the references of objects created in the heap while the ECG is active. Heap  also may comprise heap objects . Although any number of object may be in the heap at any given time, in the example of , heap objects  comprises three objects , ,  as shown. Associated with each object , ,  is a root identifier , , and . Similar to the root identifier in the root objects, the root identifier is set to NULL when creating the object. The root identifier of a heap object preferably stores a reference to the root object that references the heap object. For example, an object may be created and inserted into the context of a root object while the EGC is active. The root identifier associated with this newly created object may contain a reference to the root object that references the object. The EGC algorithm is in charge of setting the root identifier of objects in the heap during the tracing routine to detect which roots will have their context changed.","In accordance with preferred embodiments, the root identifier may be created automatically by a JVM . Each time an object is created in the heap, a \u201cnew\u201d instruction is issued to the JVM. The \u201cnew\u201d instruction preferably creates the object and stores the object on the heap. A modification of the \u201cnew\u201d instruction preferably may be made to associate a root identifier to each new object created while the EGC is active. Initially the root identifier may be set to a NULL value.","An exemplary heap that uses the EGC will now be discussed with reference to . Five stages of execution will be shown to illustrate the functionality of the EGC. These five stages are used solely to explain the operation of the EGC. The actual operation of the EGC may use any desired number of stages. The first stage () shows the state of the heap and associated data structures during the execution of the egc.start( ) function. The second stage () shows the state of the heap and associated data structures while the EGC is active and a new object is created in the heap. The third stage () shows the state of the heap and associated data structures while the EGC is active and the context of root objects has been modified. The fourth stage () shows the state of the heap and associated data structures during the execution of the egc.stop( ) function. Lastly, the fifth stage () shows the state of the heap and associated data structures after the execution of the egc.stop( ) function.","Referring now to , heap  may be illustrated at the first stage of execution. Although any number of root objects may be included in the root array, three root objects , , and  are shown to facilitate discussion. These objects are placed into the root array  by the program developer. Modified bits , , and  are initially set to false during the egc.start( ) call. As explained above, the modified bits associated with a root object are set to true when a PutRef operation is performed on an object, which root identifier is not NULL.","The heapset data structure contains references to objects that were left on the heap by a previous instance of the EGC and that are inside a root context. For exemplary purposes, heapset  may contain references to two such objects  and . Object  is inside the root context of root  (a reference exists between the root  and object ) and object  is inside the root context of root  (a reference exists between the root  and object ). Correspondingly, objects  and  have root identifiers set to  and  respectively. The root identifiers are set during the initial egc.start( ) call and during every egc.stop( ) call. Reachsets , , and  as well as tempset  are empty at the first stage of execution. Since object  was not created while the EGC was active, it is not included in heapset  and will not be considered for removal by EGC.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5","b":["350","352","354","352","354","352","354","322"]},"Referring now to , exemplary heap  is illustrated at the third stage of execution (object context modification). For exemplary purpose, the reference of root object  changes from object  to object  (using a putref based opcode). When realizing a putref opcode on an object, the runtime uses the root identifier of that object to set the modified bit of the corresponding root object to true. On  the putref is executed on object  and the associated root identifier  is equal to object  because the object  is itself a root. Thus, the modified bit of root object  is set to true. All other data structures remain unchanged at the second stage of execution.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 7","FIG. 6"],"b":["350","304","304","352","310","352","322","322","354","328","328","328","326","302","302"]},"Lastly,  may illustrate heap  at the fifth stage of execution. Root objects preferably are cleared from the root array . All objects in the heapset remain in heap . Since object  was not created while any previous instance of the EGC was active, object  also remains in heap . All other objects are removed from heap . All data structures are now in their initial state, allowing the EGC to be activated again when the egc.start( ) is executed.","Numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications"],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY","NOTATION AND NOMENCLATURE","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more detailed description of the preferred embodiments of the present invention, reference will now be made to the accompanying drawings, wherein:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
