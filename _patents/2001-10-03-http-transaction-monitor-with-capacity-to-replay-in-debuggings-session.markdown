---
title: HTTP transaction monitor with capacity to replay in debuggings session
abstract: A system for monitoring HTTP transactions between a server and a client, including a data collector which runs on the server and collects data from HTTP requests sent by the client to the server and data from HTTP responses sent by the server to the client, a debugging controller which controls an execution mode of the server, a graphical display which displays the collected data and through which replay requests are sent to the server, each replay request specifying a prior HTTP request to be interpreted by the server, a request player which runs on the server and modifies each replay request with a portion of the collected data associated with the prior HTTP request to be interpreted by the server.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07072951&OS=07072951&RS=07072951
owner: Sun Microsystems, Inc.
number: 07072951
owner_city: Santa Clara
owner_country: US
publication_date: 20011003
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","COPYRIGHT STATEMENT","TERMINOLOGY","BACKGROUND OF INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION","Architecture Overview","Directory Structure","HTTP Transaction Monitor GUI","HTTP Transaction Monitor Client and Server-Side Functionality","Operation"],"p":["This application claims priority from provisional application Ser. No. 60\/237,823, filed Oct. 3, 2000. This application is related to original U.S. application Ser. No. 09\/730,686, filed Dec. 6, 2000.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office file or records, but otherwise reserves all copyright rights whatsoever.","The following glossary of some terms are helpful in understanding the background discussion and the detailed description of the invention.","API (Application Programming Interface)\u2014An interface for application programs and utilities to access the internal services provided by the software that comprises the API.","Applet\u2014A Java\u2122 program embedded in a HTML document and executed in a Java\u2122-enabled browser.","ASP\u2122 (Active Server Pages\u2122)\u2014A scripting environment developed by Microsoft Corporation. ASP\u2122 allows HTML, scripts, and ActiveX components to be combined to dynamically generate web pages.","Bean\u2014A JavaBeans\u2122 component.","Class\u2014A user-defined data type that defines a collection of objects that share the same characteristics. An object is one instance of the class.","Client\u2014A program, often including a user interface, which initiates contact with another program (a server) for the purposes of exchanging data. The server runs in a different process and\/or on a different host from the client.","Cookie\u2014A packet of information sent by an HTTP server to a web browser and then sent back by the browser each time the browser accesses the same resource on the server or any other set of resources that is declared by the cookie. Cookies are used to maintain state between HTTP transactions. Cookies are not visible to the browser user.","DHTML (Dynamic HTML)\u2014An extension of HTML. DHTML gives greater control over the layout of page elements and the ability to have web pages which change and interact with the user without having to communicate with the server.","Directory\u2014A simulated file folder on disk.","E-commerce (Electronic commerce)\u2014Typically implies purchasing products via the Web. It also covers electronic data interchange, in which one company's computer queries and transmits purchase orders to another company's computer.","Execution Server\u2014An HTTP server that is used by an IDE for the purposes of assisting with the processes of developing dynamic web components. The IDE uses the execution server to run JSPs and servlets, or dynamic page generation components in general.","CGI (Common Gateway Interface)\u2014A standard for running external programs from a HTTP server.","CGI Script\u2014A small program written in a script language such as Perl that can be invoked through a request to the web server.","GUI (Graphical User Interface)\u2014A graphics-based interface that incorporates, for example, icons, menus, and text entry areas and typically involves non-linear user interaction as opposed to entering input in a set order.","Hook\u2014Programming instructions that provide breakpoints for future expansion. Hooks can be used to call some outside routine or function or may be places where additional processing is added.","HTML (HyperText Markup Language)\u2014A hypertext document format used on the World Wide Web.","HTTP (Hypertext Transfer Protocol)\u2014An application-level protocol for distributed, collaborative, hypermedia information systems.","HTTP Request\u2014A message sent by a client to a server using HTTP. The first line of the request contains the method to be applied to the resource requested, the identifier of the resource, and the protocol version in use. The first line is followed by HTTP headers, lines which provide information about the client, which are optionally followed by a data stream.","HTTP Response\u2014A message sent to a client after the HTTP server receives and interprets a request message from the client. The first line of the response includes the protocol version used by the server and a success or error code. The first line is followed by HTTP headers with information about the server and about the (optional) body content that follows the headers as a data stream.","HTTP Server\u2014A server process which processes HTTP requests.","HTTP Session\u2014Part of the Java Servlet\u2122 APIs. Allows the servlet container to maintain state between different HTTP requests. The servlet container knows which session to associate with the request because the browser sends the session ID as part of the request. This can either be done with a cookie or by rewriting the request URL.","IDE (Integrated Development Environment)\u2014An application that facilitates the process of writing software. An IDE typically includes a syntax-based editor, graphical tools for program entry, and integrated support for compiling, executing, and debugging the program.","IDE Session\u2014The instance of an IDE (and all its internal states) that is created when the user starts up and uses the IDE. The session ends when the user exits the IDE instance.","Internal HTTP Server\u2014Sometimes referred to as internal server. An HTTP server that runs in the same process of an application for the purposes of providing services to it.","JavaBeans\u2122\u2014A component software architecture that runs in the Java\u2122 environment, initially developed by Sun Microsystems, Inc. JavaBeans\u2122 allows developers to create reusable components that can be assembled together using a visual application builder tool.","JSP\u2122 (JavaServer Pages\u2122)\u2014A specification to extend the Java\u2122 Servlet API to generate dynamic web pages on a web server. It includes a set of tags in XML format for creating dynamic content in web pages. In order to use JSP\u2122 on a web server, the web server needs a JSP\u2122 engine and a servlet container. The JSP\u2122 engine is responsible for generating a servlet from the JSP\u2122 page and maintaining a name convention such that the servlet is invoked when the JSP\u2122 page is processed. JSP\u2122 was developed by Sun Microsystems, Inc.","JSP\u2122 Page\u2014A text-based document that uses fixed template data and JSP\u2122 elements and describes how to process a request to create a response. The template data consists of JSP\u2122 tags embedded in static content which is typically HTML.","LRI (Local Resource Identifier)\u2014The location of a resource relative to the hierarchical structure of the server, e.g., a path relative to the server's document root if the resource is a file.","Plug-in\u2014An auxiliary program that works with a major software package to enhance its capability.","Process\u2014An executing program with its own internal data states that are not accessible to other processes.","Web Resource\u2014A network data object or service that can be identified by a URI.","Server\u2014An application program that accepts connections in order to service requests by sending back responses.","Servlet\u2014A Java\u2122 program that runs exclusively in a servlet container which is an extension to a web server.","Servlet Container\u2014\u2033A servlet container contains and manages servlets over their lifecycle. It operates in conjunction with a web server or application server to provide the network services over which requests and responses are sent, allowing the servlets to process requests and create responses.","URL (Uniform Resource Locator)\u2014A compact string representative of resources available via the network. A URL has the form <protocol>:\/\/<server name><LRI><?optional parameters>.","Virtual Machine\u2014A virtual machine for Java\u2122 is a Java\u2122 interpreter that reads and executes Java byte code.","Web Browser\u2014A client application that requests resources from a web server, usually for the purpose of displaying them. Examples of browsers are Microsoft\u00ae Internet Explorer and Netscape Navigator.","XML (eXtensible Markup Language)\u2014A mark-up language that provides a format for describing structured data.","A web application is a web site where users can access the information they need and change the state of application logic on a server through a set of web pages. Development of web applications is usually centered around tools and technologies. A web application centered around the Java\u2122 technology may include the following: JSP\u2122 pages and Java\u2122 servlets that handle HTTP requests and generate dynamic content, server-side beans that encapsulate application behavior and state, static HTML files, DHTML files, image files, sound files, and libraries with additional Java\u2122 components, such as client-side Java\u2122 applets and any Java\u2122 class files used by the other Java\u2122 components. The J2EE\u2122 specification describes a standard for how to organize such files into web modules, including describing how they are accessed. The web modules could be developed in an IDE, such as sold under the trade name Forte\u2122 for Java\u2122 by Sun Microsystems, Inc.","Now, suppose the user has identified a problem with how the input from one of the form fields in page A is processed by JSP_B, and say further that JSP_B is sufficiently complex that the cause of the problem cannot be immediately identified through inspecting the source. This means that the developer will need to employ some other tactic to identify the problem with the code. One such strategy is using a source level debugger. However, reproducing the request in a debugging section is a non-trivial task. First the user has to restart the HTTP server in debugging mode, a process that typically involves several steps. Then they have to start a debugging client and connect it to the server. Then they have to resubmit the request from Page A to the server that is now running in debugging mode. Clearly it would be desirable if the user can resubmit the request resulting from Page A without having to make a request for JSP_A and reenter the data into the resulting Page A's input fields. However, this may not be possible for several reasons. First, consider a portion of a web application that deals with entering billing and shipping addresses for the purpose of allowing the user to purchase goods or services. Assume that the web application includes page generation components JSP_A and JSP_B, respectively. Components JSP_A and JSP_B could be JSP\u2122 pages, for example. JSP_A generates a page A that displays an HTML form in a browser where the user can enter billing and shipping addresses and press a \u201cContinue\u201d button to submit the information. Pressing the \u201cContinue\u201d button causes the browser to make a HTTP request to JSP_B with the data from the form fields as request parameters. If the address information is valid, JSP_B generates a page B which displays the addresses as text and asks the user to confirm that the addresses are correct. If the address information is invalid (e.g., because of a missing phone number or a zip code which contains characters other than digits), JSP_B forwards the request back to JSP_A, which regenerates page A with some extra messages that point to invalid entries.","Now, suppose that the user has identified a problem with how the input from one of the form fields in page A is processed by JSP_B. The user will attempt to fix the bug and then re-execute JSP_B with the same input from page A. In this situation, it is clearly desirable for the user to be able to resubmit the request from page A without having to reenter the same data into the page's input fields. However, this may not be possible for several reasons. First, it is common for dynamically generated pages to include a HTTP directive which specifies that the page should not be cached (by the browser or by a proxy server). This means that the browser's \u201cBack\u201d or \u201cReload\u201d button would not populate the page's input fields with the previously entered data. Using the \u201cBack\u201d button would cause the form from which the HTTP request was created to be regenerated, losing any data that was previously entered. With reference to the example above, this means that if the user used the \u201cBack\u201d button to display page A, all the data the user previously entered on page A would be lost, so the user cannot just select the \u201cContinue\u201d button to resubmit the same request. The user can work around this by disabling the directive, but that involves extra work and remembering to enable it again later. Also, unless the developer can use the back button to redisplay Page_A with their original input, there is no simple way of making minor changes for the purposes of running the debugger with slightly different input","Once the developer has identified the problem and fixed it, they will want to return the execution server to its normal running mode to test the fix comprehensively. To do so, they will have to restart the server in normal running mode, and then send the same (and similar) requests for JSP_B again, which typically means repeating the process of invoking JSP_A and entering different input all over again.","In general, in one aspect, the invention comprises a system for monitoring HTTP transactions between a server and a client. The system comprises a data collector which runs on the server and collects data from HTTP requests sent by the client to the server and data from HTTP responses sent by the server to the client. A debugging controller controls an execution mode of the server. A graphical display that displays the collected data through which replay requests are sent to the server. Each replay request specifies a prior HTTP request to be interpreted by the server. A request player runs on the server and modifies each replay request with a portion of the collected data associated with the prior HTTP request to be interpreted by the server.","In general, in one aspect, the invention comprises a system for testing and debugging a web application. The system comprises a server which hosts the web application, a client which accesses components of the web application by sending HTTP requests to the server and receiving HTTP responses from the server. A data collector runs on the server and collects data from the HTTP requests and the HTTP responses. A debugging controller runs on the client and controls an execution mode of the server. A graphical display that displays the collected data and through which replay requests are sent to the server, each replay request specifying a prior HTTP request to be interpreted by the server. A request player runs on the server and modifies each replay request with a portion of the collected data associated with the prior HTTP request to be interpreted by the server.","In general, in one aspect, the invention comprises a method for testing and debugging a web application. The method comprises sending a requested execution mode to the debugging controller, determining an execution mode of a server, comparing the requested execution mode and the execution mode of the server, switching the execution mode of the server to match the requested execution mode, forwarding the HTTP request to the execution server, and running and modifying each reply request with a portion of the collected data associated with the portion of a prior HTTP request.","In general, in one aspect, the invention comprises a tool for testing and debugging a web application. The tool comprises means for sending a requested execution mode to the debugging controller, means for determining an execution mode of a server, means for comparing the requested execution mode and the execution mode of the server, means for switching the execution mode of the server to match the requested execution mode, means for forwarding the HTTP request to the execution server, and means for running and modifying each reply request with a portion of the collected data associated with the portion of a prior HTTP request.","Other aspects and advantages of the invention will be apparent from the following description and the appended claims.","Embodiments of the present invention provide a tool that records data relevant to the processing of HTTP requests. Further, the present invention allows the user to examine the recorded data to aid in debugging web applications. Further, the present invention allows the HTTP requests that have been previously sent to the server, to be replayed on the server. Further, the present invention allows the user to optionally configure the server to operate in a debugging mode and transparently start the debugging client. Once in debugging mode, the present invention allows the user to replay HTTP requests, edit and then replay HTTP requests, and replay a sequence of HTTP requests. Once a particular resource has been identified as containing the source of an error, e.g. there is an error within a particular servlet or JSP, the present invention allows the developer to easily reproduce the request that exposes the problem within a source level debugging session, thus simplifying the process of tracking down the problem.","The present invention allows the user to transparently replay a HTTP request while simultaneously switching the server to debugging mode and opening the debugging client. Once this occurs the error can be readily identified through source level debugging using the debugging client. Once the error has been identified and fixed, the present invention allows the user to transparently switch back to normal execution mode. In normal execution mode, the present invention allows the user to replay the HTTP request to verify that the error was fixed.","In the description of the present invention which follows, a web application which contains JSPs\u2122 and servlets is used in illustrating the principles of the invention. However, it will be understood by one of ordinary skill in the art that the principles of the invention are applicable to web applications containing other types of dynamic page generation components such as ASPs\u2122 and CGI scripts. Also, for convenience, the following description is outlined into five principal sections, including Architecture overview, Directory Structure, HTTP Transaction Monitor GUI, HTTP Transaction Monitor Client-Side and Server-Side Functionality, and Operation.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 1","b":["2","2","6","6","6","6","6","10","10","10","6"]},"In accordance with one embodiment of the invention, a HTTP transaction monitor  includes a server-side component , which collects data about HTTP transactions on the execution server , and a client-side component , which displays the collected data. The HTTP transactions can either be initiated by the IDE  or through an external HTTP client, e.g., a browser, pointed to the host and port of the execution server . The server-side component  includes a data collector  that is responsible for collecting data before and after the execution server  processes the HTTP requests. In one implementation, the IDE  includes a mechanism through which the data collector  can notify the HTTP transaction monitor  of requests processed by the execution server . This mechanism can be a HTTP server  that is built into the IDE  and configurable from the IDE . If the HTTP transaction monitor  is run as a standalone application, then the HTTP transaction monitor  is responsible for maintaining the mechanism through which it is notified when the execution server  processes a new HTTP request.","In one implementation, the data collector  runs on the execution server  and relies on hooks in the execution server  to intercept HTTP requests in order to collect data about them. In one embodiment, the data collector  uses hooks in a server plug-in (e.g., a servlet container) that is responsible for handling requests to components of the web application which generates responses dynamically to intercept HTTP requests in order to collect data about them. The server-side component  also includes a notification mechanism which notifies the client-side component  when a HTTP request has been processed so that the client-side component  can update its transaction list. In one implementation, the data collected by the data collector  is stored as one or more files in a directory  on the execution server  and managed by the server-side component . In this implementation, the notification mechanism sends the client-side component  sufficient data to display the transaction corresponding to the HTTP request. In another implementation, the data files are sent to and managed by the client-side component .","The server-side component  also includes a request player  that detects a special type of HTTP request (\u201creplay request\u201d) sent by the client-side component . The replay request indicates that a prior HTTP request should be replayed and contains sufficient information to recreate the prior HTTP request. The request player  modifies the replay request to be identical to the original request before passing the replay request. The modified request is then processed by the data collector  before control is yielded to the execution server . The request player  runs on the execution server . In one implementation, the request player  relies on hooks in the execution server  or hooks in a server plug-in (e.g., a servlet container) to intercept replay requests coming into the execution server . Alternately, the request player could be invoked by the data collector  before the data collector  collects any data. The request player  replaces all the request data, i.e., the IP address of the client from which the HTTP request originated, the HTTP method, the request URL, the protocol version, any query string and\/or parameters or other data from the request body, and all the HTTP headers, in the replay request with the corresponding data from the HTTP request that is to be replayed. The data needed to modify the replay request may be loaded directly from the directory  or may be passed in as parameters with the replay request (i.e., if the data is managed by the client-side component ). In another implementation, the request player  is invoked by the data collector . The data collector , prior to processing an HTTP request determines if the HTTP request is a replay request. If the HTTP request is a replay request, the data collector  sends a request to the request player  to modify the HTTP request, e.g., re-populate the data fields. Once this has been completed, the data collector  proceeds with processing the HTTP request.","In one implementation, the client-side component  is accessible from the IDE . The client-side component  includes a GUI  which displays the transactions for which the server-side component  has collected data. The GUI  also allows the user to send a request to the execution server  to replay a prior HTTP transaction. The client-side component  further includes a mechanism for receiving notification of new HTTP transactions, which are subsequently listed on the GUI . In one embodiment, this functionality is handled by a servlet  which runs on the internal HTTP server  and is called whenever the server-side component  records a new transaction.","The client-side component  also includes a debugging controller  that controls the execution mode of the server i.e., normal or debugging, and the mechanism for allowing transparent switching between the two modes. The normal mode corresponds to regular execution of the execution server . The debugging mode corresponds to executing the HTTP requests with a debugging session on the execution server . When the client-side component issues a reply request, it first contacts the debugging controller  to check whether the execution server  which the request is intended to run on is in the desired mode. If not, the client-side component  issues a request to the debugging controller  to switching the mode of the execution server . Once the client-side component  receives confirmation from the debugging controller  that the server is running in the desired mode, it issues the request.","In one implementation, the directory  is treated as part of the server-side component  and is installed as a web module on the execution server . In alternative embodiments, the directory  may be maintained by the client-side component . The contents of the directory  include the following: a subdirectory \u201ccurrent\u201d and a subdirectory \u201csave.\u201d The subdirectory \u201ccurrent\u201d contains files with the data from each transaction that has been recorded in the current IDE session and which has not been saved. The subdirectory \u201csave\u201d contains files with the data for each transaction that has been saved. It should be noted there could be other ways of keeping track of whether the transactions are current or saved. The current transactions may be deleted when the IDE session is terminated in order to save disk space.","For each HTTP transaction that the execution server  processes, the categories of data shown in Table 1 below are collected. The data can either be stored in a single structure file (e.g., an XML file), which is processed by the client-side component , or can be stored as several files in a directory that is specific to the transaction.",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Categories of Data Collected by Server-Side Component"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Category","List of Data Collected"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Request","The IP address of the host from which the request was sent,"]},{"entry":[{},"the HTTP method, the LRI, path information (if"]},{"entry":[{},"appropriate), the query string, the protocol version, the"]},{"entry":[{},"referrer (if appropriate), the value of any incoming"]},{"entry":[{},"parameters, the request attributes before and after the"]},{"entry":[{},"request was processed, the page attributes before and after"]},{"entry":[{},"the request was processed, and the exit status of the HTTP"]},{"entry":[{},"response."]},{"entry":["Cookies","List of incoming and outgoing cookies. For incoming"]},{"entry":[{},"cookies, the name and value is provided. For outgoing"]},{"entry":[{},"cookies, the name, value, domain, time to live, path and"]},{"entry":[{},"whether the cookie requires secure protocol."]},{"entry":["Session","Whether the session exists before and after the transaction."]},{"entry":[{},"Which attributes were set and what their values are before"]},{"entry":[{},"and after the transaction. The session\u2019s properties: its ID,"]},{"entry":[{},"when it was created, its maximum inactive interval, and"]},{"entry":[{},"when it was last accessed."]},{"entry":["Servlet","Name of the servlet as configured, its class name, its"]},{"entry":["and","package name, the description given by the developer, and"]},{"entry":["Servlet","the relative path to the servlet. The servlet\u2019s initialization"]},{"entry":["Context","parameters, if there are any. The absolute path to the"]},{"entry":["Properties","J2EE\u2009\u2122 context. The servlet container\u2019s properties (Java"]},{"entry":[{},"Development Kit and platform). The servlet context"]},{"entry":[{},"properties including context attributes."]},{"entry":["Client","The version of the HTTP protocol, the client\u2019s IP address,"]},{"entry":[{},"any other information provided through the HTTP headers"]},{"entry":[{},"such as the nature of the client, e.g., the type and version of"]},{"entry":[{},"the browser, the user\u2019s language preference, and what"]},{"entry":[{},"formats and character sets the browser can deal with."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In addition to collecting data for the purpose of displaying information about the transaction, the data collector  generates the information required to list the transaction in the GUI . This information can either be included in a single structured data file (e.g., an XML file), or the information can be stored in a separate file in a directory corresponding to the transaction. In one embodiment, this information includes the ID of the transaction, the HTTP method, the LRI of the request, and timestamp of the transaction. Additional data may be included to generate more detailed list entries.","In one implementation, the directory  is maintained as part of a web module. In this implementation, the web module includes a set of servlets which manage the directory . The servlets are invoked by the client-side component  when the user wishes to display data about a request or save or delete a request. Such a web module could run either on the execution server  as part of the server-side component  or on the internal HTTP server . In , the web module is part of the server-side component , where the servlets in the web module are indicated collectively at . The servlets  perform the following functions: serve up data from the files stored in the \u201ccurrent\u201d and \u201csave\u201d subdirectories, delete records corresponding to one or more transactions, move records up from the \u201ccurrent\u201d subdirectory to the \u201csave\u201d subdirectory, and serve up a list of all current and saved transactions.","In another implementation, the directory  is maintained directly by the client-side component , in which case there is no need for servlets  to manage the data. In this implementation, the client-side component  can use normal file operations to access the data.","The GUI  may be a software component that can be called from within the IDE  or may be a standalone application.  illustrates a possible representation of the GUI . In the figure, the GUI  includes a single frame  having a left pane  and a right pane . The GUI  displays a list of transactions on the left pane  and data for an individual transaction on the right pane . A row of buttons  above the transaction list on the left pane  allows the user to reload all transactions, to modify display parameters, and set the execution mode, e.g., normal or debugging. A button  reloads all the transactions. A button  displays the transactions in alphabetical order, by LRI. A button  displays the transactions in temporal order, last transaction last. A button  displays the transactions in reverse temporal order, last transaction first. A button  toggles whether the time stamp of the transaction is shown or not. Buttons  and  form a toggle-able pair i.e., one button is required to be selected at all times, and if one button is toggled the other button is not toggled. The buttons  and  determine whether a selected transaction is executed in the normal mode or the debugging mode. If button  is toggled then the HTTP request is executed in debugging mode. If button  is toggled then the HTTP request is executed in normal mode. The default is the normal mode, with button  toggled.","The left pane  displays one super category node \u201cAll Transactions.\u201d Under the \u201cAll Transactions\u201d node are subcategory nodes \u201cCurrent Transactions,\u201d \u201cSaved Transactions,\u201d and \u201cTransaction Sequence.\u201d Individual transactions are leaf nodes and reside in either the \u201cCurrent Transactions\u201d or the \u201cSaved Transactions\u201d node. Entries in the \u201cCurrent Transactions\u201d node are available during a current IDE session, while entries under the \u201cSaved Transactions\u201d node persist until they are deleted by the user. The entries under the \u201cCurrent Transactions\u201d and \u201cSaved Transactions\u201d nodes are obtained from the \u201ccurrent\u201d and \u201csave\u201d subdirectories in the directory  (shown in ). The \u201cTransaction Sequence\u201d node contains folders that are created and named by the user to hold sets of HTTP requests to be replayed together as a sequence. The user adds leaf nodes which correspond to individual HTTP request under these sequence folders. Like the \u201cSaved Transactions\u201d entries, the \u201cTransaction Sequence\u201d entries persist until they are deleted by the user.","Individual transaction nodes in the \u201cCurrent Transactions\u201d subcategory have six actions: \u201cDisplay,\u201d \u201cSave,\u201d \u201cCopy Request to Sequence,\u201d \u201cReplay,\u201d \u201cEdit and Replay,\u201d and \u201cDelete.\u201d In the \u201cSaved Transactions\u201d subcategory, the individual transaction nodes have five actions: \u201cDisplay,\u201d \u201cCopy Request to Sequence,\u201d \u201cReplay,\u201d \u201cEdit and Replay,\u201d and \u201cDelete.\u201d The sequence folders under the \u201cTransaction sequence\u201d node are represented by icons which have a badge that indicates whether new transactions have their HTTP requests recorded into the sequence or not. The sequence nodes have the following actions: \u201cToggle request recording,\u201d \u201cReorder,\u201d \u201cRename,\u201d \u201cReplay sequence (step),\u201d \u201cReplay sequence (to end),\u201d and \u201cDelete.\u201d In one implementation, the list of actions available under each transaction category is displayed in a pop-up menu  when the user right-clicks on a transaction.","The \u201cCopy Request to Sequence\u201d action brings up a dialog (not shown) where the user can select or create a sequence folder (under the \u201cTransaction Sequence\u201d node) into which a HTTP request may be copied.","The \u201cReplay\u201d action invokes the debugging controller  to detect if the execution server  upon which the HTTP request was originally executed on is running. If the execution server  is not running, the execution server  is started. The execution server  is started in the normal mode if button  is toggled. The execution server  is started in the debugging mode if the button  is toggled. If the execution server  is running in normal mode and button  is toggled, the execution server  is switching to debugging mode. If the execution server  is running in debugging mode and button  is toggled, the execution server  is switched to normal mode. The HTTP request is then sent to the execution server .","The \u201cEdit and Replay\u201d action brings up a dialog, which allows the user to modify the HTTP request data prior to causing it to be re-processed by the execution server . Additionally, the user can modify which execution server  the user wants to execute on through the dialog. When the user completes the editing of the HTTP request and sends the HTTP request to the execution server , the debugging controller  intercepts and examines the HTTP request. If the execution server  upon which the HTTP request is to be run is not running, the execution server  is started. The execution server  is started in the normal mode if button  is toggled. The execution server  is started in the debugging mode if the button  is toggled. If the execution server  is running in normal mode and button  is toggled, the execution server  is restarted in debugging mode. If the execution server  is running in debugging mode and button  is toggled, the execution server  is restarted in normal mode. The modified HTTP request is then sent to the execution server .","The \u201cReorder\u201d action brings up a dialog (not shown) which shows a list of the HTTP request nodes inside the sequence and allows the user to move individual nodes up or down.","\u201cReplay sequence\u201d causes the HTTP requests described by each sequence folder to be replayed one at a time in sequence. With \u201cReplay sequence (step),\u201d the output from each request is shown before moving on to the next request. With \u201cReplay sequence (to end),\u201d only the output of the last request is shown. To execute the sequence, a thread is started which attempts to execute each request in order, waiting for one to succeed before executing the next one. Each individual request has have a timeout, which can be some default number or can be set by the user. If any individual request fails, the output of that request is displayed to the user, and the user is notified of the problem. Otherwise, the output of the last request in the sequence is displayed. For each replay request within the sequence the debugging controller  intercepts and examines the HTTP request. If the execution server , upon which the HTTP request is to be run is not running, the execution server  is started. The execution server  is started in the normal mode if button  is toggled. The execution server  is started in the debugging mode if the button  is toggled. If the execution server  is running in normal mode and button  is toggled, the execution server  is switched to debugging mode. If the execution server  is running in debugging mode and button  is toggled, the execution server  is switched to normal mode. The HTTP request is then sent to the execution server .","The right pane includes a display component  having six tabs, collectively indicated at . For a transaction selected on the left pane , the six tabs  display the data collected by the server component ( in ) according to the categories shown in Table 1 above. The six tabs  have the labels \u201cRequest,\u201d \u201cCookies,\u201d \u201cSession,\u201d \u201cServlet and Server,\u201d \u201cClient,\u201d and \u201cHeaders,\u201d respectively. The \u201cRequest\u201d tab displays the request and response parameters for a selected transaction. The HTTP headers associated with the request are displayed separately in the \u201cHeaders\u201d tab. The \u201cCookies\u201d tab displays attributes of incoming and outgoing cookies for a selected transaction. The \u201cSession\u201d tab displays the session status before and after executing the selected transaction. The \u201cServlet and Server\u201d tab displays the servlet and server properties when the selected transaction was executed. The \u201cClient\u201d tab displays properties of the client making the request for the selected transaction.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 3","b":["22","6","6"]},"In the illustrated embodiment, the user can invoke the GUI  by selecting the appropriate option in the \u201cDebugging\u201d menu or \u201cView\u201d menu (see ) of the IDE . This displays the GUI  during the IDE session or until it is closed by the user. The IDE session is the period during which the user runs one instance of the IDE . The IDE session starts when the user brings up the IDE  and ends when the user exits the IDE .",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 4","b":["18","16","49","22","19","16","33","35"]},"The debugging controller , based on the aforementioned information, may send a command  to execution server , to start the execution server  in the mode specified in the GUI . Based on the command , the execution server  may be exited and may be restarted. In one implementation, debugging, for portions of the execution server , may be activated without shutting down the entire execution server . Once the mode is selected, the debugging controller  sends a confirmation to the client-side component . The client-side  subsequently sends the request to the execution server  via an internal HTTP server .","Before the execution server  processes the incoming request , the request player  intercepts the incoming request  and checks whether the incoming request  is a replay request. In one embodiment, this involves looking for a specific query string, e.g., \u201cffj_resend,\u201d in the URI of the incoming request. The query string appended to the URI may have the general form \u201cffj_resend=<id>&ffj_status={current,save,replay}.\u201d If the query string contains parameters of these names, then the request player determines that this is a replay request and retrieves the data corresponding to the original request. If the data is managed by the server-side component , it is retrieved from disk. In the implementation described in , the data is managed by the client-side component . In this case, the request player retrieves the data from the client side component by making a HTTP request to Servlet , which in turn retrieves the data from the client-side component . When the original request data has been retrieved, the request player changes the incoming request  so that it is identical with the original request (or edited version of the original request). It then yields control to the data collector . If an incoming request  does not contain the parameters above in the query string, the request is not a replay request and the request player immediately yields control to the data collector .","The data collector  intercepts the incoming request  and collects data about the request. The collected data includes information about the client making the request, the session state before the transaction, incoming cookies, servlet properties data, and all the request data except the exit status (see Table 1 above). The data collector  then yields control to the execution server . The execution server  invokes a servlet  to process the request. The servlet  generates a response . After the servlet  has generated the response , control is transferred back to the data collector . The data collector  collects, at least, the following information: the session state after the transaction, request and page context attributes after the transaction, outgoing cookies, and exit status of the response. The data collector  then notifies the client-side component ( in ) by sending a HTTP request  to the servlet , indicating that a new transaction has been processed. The servlet  subsequently updates the GUI . If the recorded data is managed by the server-side component ( in ), then the data is written to the directory . If the recorded data is managed by the client-side component ( in ), then the data is sent with the HTTP request  to the client-side component ( in ). The data collector  then yields control to the request player , which simply allows the response  to leave the execution server .","In one implementation, the debugging controller  uses a \u201cServer Integration\u201d API for controlling the server execution functionality. In this implementation, each execution server provides an implementation of the API called a server integration plugin. The server integration plugin uses proprietary methods for starting, stopping, and turning debugging on\/off on the execution server. When the debugging controller receives a request to turn on debugging, the server integration plugin turns on debugging on the execution server using proprietary methods.","For the developer, the process of developing a web application involves, among other tasks, testing each dynamic web component (in the case of a Java\u2122 application, each JSP\u2122 and servlet) to see that the component performs the correct processing and generates the appropriate output. This involves executing individual web components and also sequences of components as they would be traversed by a user who browses the web site. In the discussion that follows, the web application to be tested has been developed in an IDE, for example, the IDE  (shown in ). The developer is using the IDE to test-run and debug the web application. The developer can execute the JSP\u2122 pages or servlets from the IDE. The HTTP transaction monitor GUI ( in ) is displayed by the previously described mechanism. As shown in , the contents of a web application are displayed in a GUI  that is included in the IDE . The developer selects a resource in the web application and then asks the IDE  to execute the resource. For example, in , a JSP\u2122 page called \u201cinput\u201d has been selected. To display the page, the IDE  sends an HTTP request to the execution server ( in ). The request is executed on the execution server . The output of the execution server ( in ), i.e., the HTTP response, is displayed in the browser , which is included in the IDE .",{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 5","b":["10","6","19","100","19","10","101","10","10","102","10","10"]},"To determine if the execution server  is in the proper operating mode, the debugging controller  first determines what mode the execution server  has requested (Step ). The debugging controller  determines the requested mode by checking which button  or  (in ) is toggled. Next, the debugging controller  determines the current operating mode of the execution server  (Step ). If the current execution mode and the requested mode are the same (Step ), the debugging controller  forwards the HTTP request to the execution server  (step ). If the current execution mode and the requested mode are not the same (Step ), the debugging controller  switches to the requested mode (Step ). The debugging controller  uses the server integration plugin to turn on or off the debugger (depending on which mode is required) using proprietary methods. Once this has been completed the IDE  forwards the HTTP request to the execution server (Step ).",{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 6","b":["10","109","17","110","17","112","114","17","116"]},"The HTTP request is then forwarded to the data collector  (Step ). If it is not a replay request (Step ), the request player  performs no action on the HTTP request, and the HTTP request is forwarded to the data collector  (Step ). The data collector  then intercepts the HTTP request and collects data about it (Step ). After collecting the data, control is returned to the execution server , and the execution server  processes the request. The execution server  invokes a servlet generated from the JSP\u2122 page with the data that came in with the HTTP request (Step ). After processing, the execution server  sends the response page back to the browser . Before the response page is sent to the browser , the data collector  again intercepts the response, collects data on the response (Step ), and then forwards the output to the browser  (Step ). After collecting data, the data collector  invokes the servlet  to update the GUI  (Step ). As a result, as shown in , a \u201cGet input.jsp\u201d node has been added to \u201cCurrent Transactions\u201d subcategory on the left pane  of the GUI . The browser  displays the \u201crequest\u201d data collected by the data collector  for the \u201cGet input.jsp\u201d transaction. It should be noted that the present invention may be used in conjunction with various replay options, such as \u201creplay,\u201d \u201cedit and replay,\u201d \u201csequence replay,\u201d etc.","Using the data collected by the data collector , the developer can examine the attributes of requests coming into the execution server  and responses sent out from the execution server  through the GUI . If a problem arises, the developer is able to find the source of the problem by examining the transactions between the browser  and the server . If a particular request for a resource or set of such requests is one that the developer wants to make regularly throughout the development phase, for instance, in order to verify that the web application continues to work as intended after the changes have been made, then the corresponding transaction records can be saved. This allows the developer to replay the corresponding HTTP requests during future IDE sessions. The developer can also use the save functionality in case they wish to defer fixing a problem to a later date. The transaction or transactions corresponding to the requests that reproduce the problem can be saved, giving the developer the opportunity to examine and replay them during a future IDE session.","To replay the request, the client-side component  issues a HTTP request to the execution server  through a browser . Prior to sending the request, the client-side component  invokes the debugging controller  which verifies that the execution server  to which the request is issued is running in the desired mode.","Advantages of the present invention may include one or more of the following. The debugging controller allows the user to transparently switch between normal server execution, and server execution within a debugging session. The present invention allows the debugging controller to be easily accessed from a GUI interface. The present invention allows the debugging controller to be used in conjunction with the various other replay options, such as \u201creplay,\u201d \u201cedit and replay,\u201d \u201csequence replay,\u201d etc. Those skilled in the art can appreciate that the present invention may include other advantages and features.","While the invention has been described with respect to a limited number of embodiments, those skilled in the art, having benefit of this disclosure, will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly, the scope of the invention should be limited only by the attached claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
