---
title: Facet support, clustering for code query results
abstract: Techniques and tools are described for refining source-code query results. For example, source-code query results for a query can be generated, semantic clusters of the source-code query results can be generated, and based on a selection of a semantic cluster option, refined source-code query results can be sent. Also, for example, source-code query results can be received, selections of facet values associated with groups of the source-code query results can be sent, and based on selected facet values, a subset of the source-code query results can be received.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09348894&OS=09348894&RS=09348894
owner: Infosys Limited
number: 09348894
owner_city: Bangalore
owner_country: IN
publication_date: 20110519
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","EXAMPLE 1","Exemplary Overview","EXAMPLE 2","Exemplary System Employing a Combination of the Technologies","EXAMPLE 3","Exemplary Method of Employing a Combination of the Technologies","EXAMPLE 4","Exemplary System Employing a Combination of the Technologies","EXAMPLE 5","Exemplary Method of Employing a Combination of the Technologies","EXAMPLE 6","Exemplary Method of Employing a Combination of the Technologies","EXAMPLE 7","Exemplary System Employing a Combination of the Technologies","EXAMPLE 8","Exemplary Method of Employing a Combination of the Technologies","EXAMPLE 9","Exemplary Method of Employing a Combination of the Technologies","EXAMPLE 10","Exemplary Result-Clustering User Interface","EXAMPLE 11","Exemplary Faceted-Search User Interface","EXAMPLE 12","Exemplary Indexing of Source Code","EXAMPLE 13","Exemplary Clustering of Source-Code Query Results","EXAMPLE 14","Exemplary Semantic Cluster","EXAMPLE 15","Exemplary Semantic Cluster Option","EXAMPLE 16","Exemplary Facet Option","EXAMPLE 17","Exemplary Facet","EXAMPLE 18","Exemplary Facet Value","EXAMPLE 19","Exemplary Method of Employing a Combination of the Technologies","EXAMPLE 20","Exemplary System for Searching for Source Code Online","EXAMPLE 21","Exemplary Client User Interface","EXAMPLE 22","Exemplary Method for Refining Source-Code Query Results","EXAMPLE 23","Exemplary Method for Refining Source-Code Query Results","EXAMPLE 24","Exemplary System for Refining Source-Code Query Results Using an Index","EXAMPLE 25","Exemplary Method for Using an Index of Source Code to Determine a Source-Code Query Response","EXAMPLE 26","Exemplary Architecture for Employing a Combination of the Technologies","EXAMPLE 27","Exemplary Code Element","EXAMPLE 28","Exemplary Source-Code Query","EXAMPLE 29","Exemplary Source-Code Query Response","EXAMPLE 30","Exemplary Source-Code Query Result","EXAMPLE 31","Exemplary Refined Source-Code Query Results","EXAMPLE 32","Exemplary Generation of Source-Code Query Results","EXAMPLE 33","Exemplary Code Attributes","EXAMPLE 34","Exemplary Index Document","EXAMPLE 35","Exemplary Source Code","EXAMPLE 36","Exemplary Selection","EXAMPLE 37","Exemplary Advantages","EXAMPLE 38","Exemplary Computing Device","EXAMPLE 39","Exemplary Alternatives and Variations"],"p":["This application claims priority from Application No. 1065\/CHE\/2011, filed in India on Mar. 31, 2011, which is hereby incorporated by reference herein.","Large software systems can be difficult to maintain. There are tools and technologies that enable maintainers to analyze and fix bugs in software. However, searching large repositories of software source code can be difficult and time consuming. Source code repositories can have millions of lines of code written in various programming languages over many years by multiple source code developers. A developer searching for source code may not have knowledge of the contents of the source code repositories or the functionality of the source code stored. Traditional source code search methods can be limited by a lack of understanding of the contents of the stored source code. In many cases, irrelevant or too many hits are found, limiting the usefulness of current search tools.","In Summary, the Detailed Description presents a variety of tools and techniques related to refining source-code query results while searching for source code.","According to one implementation of the technologies described herein, source-code query results can be generated in response to a query used to search for source code. Semantic clusters of the query results can be generated. Semantic clusters can group query results according to concept similarity. Refined source-code query results can be sent based on a selection of a semantic cluster option. For example, source-code query results that are associated with a selected semantic cluster option can be returned as refined source-code query results.","In another implementation, a system can receive source-code query results in response to a source-code query. Selections of facet values associated with groups of the source-code query results can be sent. A facet value can group or be associated with source-code query results grouped based on an attribute of a segment of source code. A subset of the source-code query results can be received based on selections of facet values. For example, source-code query results that are associated with a selected facet value can be returned as refined source-code query results.","In yet another implementation, source-code query results associated with index documents can be generated in response to a query of an index of source code. Facet values and semantic clusters can be determined based on the index documents associated with the source-code query results. Refined source-code query results can be determined based on the intersection of semantic clusters and facet values. For example, source-code query results that are both associated with a facet value and a semantic cluster can be returned as refined source-code query results.","In a further implementation, a system can send a source-code query for searching a source-code repository. A query response including source-code query results and semantic cluster options included in a concept wheel can be received. The semantic cluster options can be selected. Based on the selected semantic cluster options, refined source-code query results can be received.","This Summary is not intended to be used to limit the scope of the claimed subject matter. The foregoing and other objects, features, and advantages of the technologies will become more apparent from the following Detailed Description, which proceeds with reference to the accompanying figures.","There are a variety of circumstances under which it may be desirable to search for source code. For example, a user may want to reuse source code written for a previous project to quickly advance a new project's development. Often traditional searching methods provide users a large numbers of hits when searching for source code. Searching through large numbers of results can slow down a search for relevant source code. The cluster based search and facet based search techniques described herein can be used for refining source-code query results for efficient searching of source code.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1","b":["100","100","110","130","120","130"]},"A source-code query  can be sent to query service . For example, a user searching for source code can send an original query with query terms and operators. For example, a user searching for source code can input the source-code query  into a search user interface. The source-code query  can have query terms and operators such as the query \u201cclass:foo AND function:bar.\u201d","Using source-code query , the query service  can search the index  and determine source-code query results. For example, the query service  can generate a list of query results that correspond to source code elements that conform to the user's query such as classes named foo with functions named bar.","Using the source-code query results , semantic clusters  can be determined. For example, the list of query results generated can be automatically clustered into subgroups based on concepts found in the large number of code elements associated with the clustered query results. A concept can be words common to the code elements or some other identified concept such as a business concept. For example, multiple classes relating to interest calculations (e.g., currentInterestRate, computeInterest, returnInterestTable) can be included in an identified semantic cluster.","Also, using the source-code query results , facet options  can be determined. A facet option can include facets that categorize source-code query results and facet values that are associated with groups of source-code query results categorized by facets. Facets can be used to localize source-code query results based on attributes of code elements such as classes and methods. For example, \u201cEXTENDS\u201d can be a facet that categorizes source-code elements with the attribute of extending (e.g., a class). A facet value can be associated with a subgroup of source code query results of the facet grouped based on a particular source-code attribute. For example, for source-code elements categorized by the facet \u201cEXTENDS\u201d with the attribute of extending (e.g., a class), a facet value can be associated with a subgroup of the source-code elements of the facet that extend a particular class, such as the named class \u201cabstractClass.\u201d So the facet value can be associated with a group of source-code query results that each extend the named class \u201cabstractClass.\u201d","In response to the source code query , a query response  can be provided which includes query options  and source-code query results . For example, a user can be provided the options to choose from the groupings to narrow the large number of query results. Query options  can include one or more facet options, one or more semantic cluster options or both facet options and semantic cluster options. Query options  can also include other options. In sending the query response , source-code query results  and query options  can be sent at the same time, at different times, or in parallel. In one example, semantic cluster options can be provided for selection in a results clustering user interface such as a concept wheel. In another example, facet options can be provided for selection in a faceted search user interface.","A refinement selection  can be sent to query service . A refinement selection can be the selection of one or more source-code query options such as a semantic cluster option or a facet option. For example, a user can select one of the query options  and that selection can be sent to query service . In another example, the user can choose which semantic cluster is most appropriate by viewing the concepts identified during clustering. In a further example, a user can select a facet value such as one that returns classes that extend a particular or named class.","In response to the selected refinement option, query service  can send refined query response . The refined query response  can include refined query options  and refined source-code query results . The refined options  can include refined semantic cluster options, refined facet options, or both. In one example, a user can select one of the semantic cluster options, and the source-code query results associated with the selected semantic cluster option can be returned as the refined source-code query results. In another example, a user can select one of the facet values, and the source-code query results associated with the selected facet value can be provided to the user as refined source-code query results.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2","b":["200","210"]},"At block , a query can be received. For example, a user can send a query to search for source code that is indexed.","At block , a query response can be output or sent. For example, a response of source-code search results and query options can be sent as choices for user selection.","At block  a refinement selection can be received. A refinement selection can include a selected facet option, a selected semantic cluster option or both. For example, a user selection of one or more of the query options can be received.","At block , a refined query response can be output or sent. For example, refined source code search results and query options generated based on the refined source code search results can be sent as choices for user selection.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3","b":["300","300","310","319"]},"The stored code elements A-A can be queried . Query results B-B can be determined based on the query . Each of query results B-B can be a query result corresponding to one of each of code elements A-A. For example, the source-code search result B can be used to retrieve code element A.","The source code search results can be clustered . Semantic clusters A-F of query results B-B can be determined. For sake of simplicity the elements are shown as containing similar character strings. However, in practice, any semantic clustering technique can be employed.","A semantic cluster selection  can be made. For example, a user of the system can select a semantic cluster such as semantic clusters A-F. Query results B-B can be refined based on the semantic cluster selection . For example, a user can select semantic cluster C and query results B and B can be returned as refined query results.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 4","b":["400","410"]},"At block  semantic clusters of the source-code query results can be generated. For example, subsets of the source-code query results can be created. In one example, semantic clusters can be associated with semantic cluster options that can be provided to a client in a query response along with source-code query results. The semantic cluster options and source-code query results can be rendered in a user interface at the client.","At block  refined source-code query results can be sent based on a selected cluster. For example, a user can select a semantic cluster and the cluster can be sent as refined source-code query results.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 5","b":["500","510"]},"At block , a semantic cluster option can be selected. For example, a user can select a semantic cluster option by using a concept wheel user interface.","At block , refined source-code query results can be received based on the selected semantic cluster option.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 6","b":["600","600","610","619","610","619","618"]},"Query results B-B can be determined based on the query . Each of query results B-B can be a query result corresponding to one of each of code elements A-A. For example, the source code search result B can be used to retrieve code element A.","Facet options - of the code elements A-A corresponding to query results B-B can be identified. Facet options - can include facet values such as facet value . A facet value selection  can be made. For example, a user of the system can select one or more facet values.","Query results B-B can be refined based on the semantic cluster selection . For example, a user can select facet value  which corresponds to the group of query results B and B. Then query results B and B can be returned as the refined query results .",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 7","b":["700","710","720","730"]},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 8","b":["800","810","820","830"]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 9A","b":["900","910","910","920","920","910","920","910"]},"The result-clustering UI can display cluster information such as cluster information . The cluster information  can include a cluster identifier  and a cluster percentage . The cluster percentage  can correspond to the percentage of the area of the concept wheel  that includes the cluster option A. The cluster percentage  can also indicate a percentage of the source-code query results included in a semantic cluster associated with the cluster option A.","Semantic cluster options A-D can be shown in the concept wheel  so a user can understand the dominance of concepts found by clustering the source-code query results. A concept wheel can help a user to analyze and determine modularity guidelines for a software system. For example, a semantic cluster option that includes a large wedge can indicate a dominant concept among associated source-code query results. A user can decide to look at or select a semantic cluster option for more understanding of the concept or eliminate the unwanted concepts so that the query results can be more effectively used. For example, a user can eliminate a semantic cluster option and new semantic cluster options and wheel can be created based on the elimination of the concept from the clustering.","In one example, user can look at a dominant concept by selecting the corresponding cluster option A or view its cluster information . The cluster information  can be displayed when designated. For example, the cluster information , corresponding to cluster option A, can be displayed when a cursor hovers over the cluster option . In other examples, the cluster information  can be designated using other techniques such as highlighting, selecting, or the like.","In alternative embodiments, a result clustering UI may include the use of shapes other than a wheel and wedges, such as quadrilaterals, ovals, polygons, asymmetrical shapes, and the like.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 9B","b":["950","960","960","960"]},"Each of the facets A-D can include one or more facet values , . Each of the facet values ,  can include a code element identifier A and a results indicator B. For example, the code element identifier A indicates a group of source-code query results that implement the interface \u201corg.omg.CORBA.portable.Streamable.\u201d The results indicator B indicates that there are 26 classes in the group of source-code query results that implement the interface of element identifier A. The facet values ,  can be selected individually or in groups or subgroups.","In any of the examples herein, an indexer can index source code according to the source code's structure at least by parsing source code based on the syntax of the source code written in a programming language. The indexer can parse source code into discrete segments of source code. That is to say, the indexer can divide up the source code (e.g., text of the source code) into discrete segments of source code. The segments can be functional units (e.g. a class), or portions of the text of the source code (e.g., a name of a class). In one implementation, a parser can extract information (e.g., words, phrases, text segments, code segments, values) from the text of code elements. The extracted information can be used to create indexes of the code elements. For example, for the source code segment \u201cpublic class BankingClient extends Bank,\u201d an indexer can divide up the code and extract information including the words \u201cpublic\u201d \u201cclass,\u201d and \u201cBankingClient.\u201d Because the source code segment is arranged according to a programming language, the indexer can determine that the code element is a \u201cclass\u201d and that it is a \u201cpublic\u201d class. Also, the indexer can determine that the class is named \u201cBankingClient\u201d and that the class extends the code element Bank.","In some examples, segments of source code can be code elements. For example, segments of source code can be code elements, such as classes, methods, functions and the like. The indexer can determine code elements based on source code files or from parsing the source code according to a programming language. For example, the indexer can identify that a class contained in a source code file is a code element because source code files can be organized so that a file (e.g., each file) contains one respective code element. That is to say, the indexer can use the content of individual source code files as discrete code elements rather than extracting textual code segments or statements. Additionally, the indexer can parse source code to extract information for index documents including field information, value information, source code text, attribute information, facet information, facet value information, cluster information, identifier information, dependencies between code elements, and other like information that can be stored or indexed. In a further example, once a class is indexed, a code developer wanting to reuse the class can search for the class as a code element of the source code or software. The indexing can be done before runtime or after runtime. Indexing code before runtime can speed up the process for large software repositories.","While indexing, segments of source code can be determined by parsing the source code according to a programming language's syntax. For example, an indexer parsing source code according to the Java language can extract a class as a code element because the parser can determine the boundaries (e.g., beginning, end or body) of a class based on the syntax of the Java language. The indexer can also determine the attributes of a code element by parsing sub-portions of the code of the code element. For example, a class may implement an interface and the indexer can determine that attribute. In a further example, an indexer can use the content of individual source code files as discrete code elements rather than extracted plain text code segments or statements.","When indexing source code files, relevant attributes, information, or values for each source-code file can be identified and extracted. The attribute can be reflected in the code (e.g., text) of the code element, and that attribute can be recognized and extracted by parsing according to the programming language of the code. In one exemplary embodiment of the indexer, the indexer can use the Eclipse JDT parser to parse source code. In other embodiments of an indexer some other parser can be used.","While indexing source code, the indexer can produce source-code documents and index documents. In index documents, code elements, attributes, fields, values and dependencies can be stored. The indexer can extract the values such as code segments or pieces of code including words, phrases, or a segment of the source code. The indexer can input the extracted values into fields of the index documents stored in the index. For example, an indexer can extract a class as a code element, and for the code element it can input values into an index document for the class. The values can be the name of the class, the methods of the class and other attributes of the class. The indexer can parse the class to extract attributes of the class and input values into the index document's fields based on those attributes. For example, the index document for the class can have a code field where the indexer inputs the source code for the class.","In addition to index documents the indexer can produce source-code documents that can be returned to a user searching for the source code. The produced source-code documents can be intelligently formatted HTML files including the source code or code element. The source-code documents can display the source code of the code element when rendered in a user interface (e.g., web browser user interface). In one example, the source-code documents can be used in a web component for cross navigation between source code online. In another example, the source-code documents can be locally stored formatted files that contain source code.","In any of the examples herein, source-code query results can be clustered automatically. Source-code elements corresponding to source-code query results can be input into a clustering algorithm that can automatically identify dominant concepts among the code elements based on semantic properties of the text of the code elements. The clustering can be done automatically using the source-code elements as input and can be done without considering, using, or comparing query terms entered by a user. In some implementations the clustering algorithm can use query terms entered by a user.","Semantic properties of source code elements can be words, keywords, phrases, code statements, concepts, text, or other discrete segments of code. In one example, code index documents associated with source-code query results can include fields with source code text that can be tokenized and mined for keywords dynamically such as at runtime. Concepts can be connected to words or keywords found in the text of a mined source-code element. The concepts can be based on the distribution of words among the various mined code elements. In one implementation, words that are included multiple times in a code element can be keywords. In other implementations keywords can be chosen in some other manner.","In a further example, a clustering algorithm can traverse a suffix tree containing index documents that include the source code of code elements and identify words and phrases occurring more than once in the code elements. Each word and phrase can be used to create a base cluster. Once the base clusters are created, they can be merged to form final clusters. In another example, semantic clustering can be performed based on source code that is a value in a code field in an index document.","In one example, source code query results can be ranked and a number of the highest ranked results can be clustered (e.g. top n results). The index documents associated with the source code query results can be sent to a clustering engine and the source code query results can be clustered based on similar concepts in the text of the code elements.","Clustering of source-code query results can be an unsupervised learning task which classifies a set of observations into subsets such that observations in the same subset are related. This approach can group source-code query results based on content similarity. A clustering algorithm can determine groups of content similarity from code text of code elements without using terms from a query. For example, a clustering technique can automatically determine similarities of text in different code elements and can group the code elements according to those similarities. The clustering technique does not need to use query terms, operators, or terms provided by a user (e.g., in a query field) to group the code elements. The clustering can determine the semantic groups based on properties of the text of the code elements. For example, during clustering different segments of code can be compared and determined to be similar based on their text without considering a query that produced the results that were input for clustering. For example, multiple methods relating to time (e.g., getTime, getDate, changeDateTime) can be compared and included in an identified semantic cluster because of similar concepts in the methods.","A semantic clustering algorithm can be a Suffix Tree Clustering algorithm, Lingo clustering algorithm, or some other clustering algorithm. A clustering engine can also be used for clustering of source-code query results. In one example, Carrot2 search result clustering engine can be used. In other examples, other clustering engines can be used. Semantic clustering can be done online and also in real time when results are obtained.","When semantic clusters are generated they can be cached. For example, for each of a number of semantic clusters, a number of source-code query results can be cached. This can speed up the process of cluster retrieval if the cluster is selected because the results of the clustering have been preserved. If more source-code query results are requested than the cached number of results, then clustering can be redone to return the requested source-code query results. For example, if all the source code query results are paginated in a web interface and only the first page of source-code query results of the cluster are cached, then clustering can be done again to retrieve the subsequent pages of results. However, once clustering has been done the resulting refined source-code query results can be preserved for the source code by caching the results or storing them in some other manner.","In any of the examples herein, a semantic cluster can be a group or subset of source-code query results grouped or categorized based on a similarity of concepts in the code elements of the grouped source-code query results. A semantic cluster can group source-code query results based on context or content similarity. Similar concepts can be determined based on semantic properties of the text of the code elements associated with the query results. In some examples, semantic properties of source code elements can be words, keywords, phrases, code statements, concepts, text, or other discrete segments of code. Concepts can be connected to words or keywords found in the text of a source code element based on the distribution of words among the various mined code elements. For example, a clustering technique automatically determines similarities of text in different code elements and can group the code elements according to those similarities. For example, multiple classes with text that similarly reflect a particular concept can be included in an identified semantic cluster.","Identifying common concepts in code elements can aid in the searching of source code. For example, a person searching for source code can use their knowledge of the type of code they are looking for to choose from among different semantic clusters associated with various concepts to narrow or refine search results in an attempt to find relevant code. Similarities in source code text can indicate concepts such as business concepts, technical concepts, and other concepts.","In any of the examples herein, a semantic cluster option can be an option corresponding to a semantic cluster of source-code query results. A semantic cluster option can indicate concepts determined from semantic properties of source-code elements.","A cluster option can have associated cluster information. The cluster information can include a cluster identifier (cluster ID) and a cluster percentage. A cluster identifier can identify a cluster option and indicate the concepts of the corresponding semantic cluster.","The cluster ID can be determined from one or more fields of index documents for code elements associated with the semantic cluster. For example, a semantic cluster of four source-code query results can have a cluster ID that is a combination of words, text, or concepts stored in fields of the index documents of the four code elements. In another example, if a semantic cluster includes multiple source-code query results but only a portion of the indexed code elements have common words in their respective fields (e.g. title fields), then the most common words among the fields of the multiple source-code query results can be used as the cluster ID. In yet another example, if there are two index documents that when mined are found to be similar, a common word or words from the title fields of the index documents can be chosen for use in the cluster ID. In a further example, if there are no words totally common to all of the multiple index document fields, then the most common words among the group can be used in the cluster ID for indicating a concept of the cluster.","A cluster percentage can indicate a percentage of clustered source-code query results that are included in a semantic cluster associated with the cluster option. For example, if a number of source-code query results are clustered, a cluster percentage for one of the resulting clusters can indicate what percent of the number of source-code query results clustered are associated with the resulting semantic cluster.","A semantic cluster option can be included as part of a concept wheel. Cluster options can correspond to a portion of the area of the concept wheel. Cluster options can be shown in the concept wheel so a user can understand which concepts are dominant.","A semantic cluster option can be selected. For example, a user can select a semantic cluster option in a user interface by clicking on the semantic cluster option, clicking on a semantic cluster option selection box or by some other selection method. The semantic cluster option can be associated with query terms and operators that can limit a query. For example, when a semantic cluster option is selected, semantic cluster option query terms and operators can be added to the query terms and operators that were used to generate the semantic cluster option and sent as a new query. A selection of a semantic cluster option selection can also be sent using other techniques such as sending a selection value indicating the selection or other techniques. For example, when a semantic cluster option is selected an indication of the selected semantic cluster option can be sent to a server and cached source-code query results can be returned in response to receiving the indication of the selected semantic cluster option.","In any of the examples herein, a facet option can include one or more facets and one or more facet values. For example, a facet option can include facets that categorize source-code query results and facet values that are associated with groups of source-code query results that can be categorized by facets.","In any of the examples herein, a facet can be a classification based on a distinct feature or functionality of source code. A facet can be a category or classification based on a source-code attribute. For example, a facet can be a category based on a code attribute of a code element associated with source-code query results. A source-code attribute can be extracted by parsing the code element according to a programming language. The source-code attribute can be based on the text of a code element. A facet can be used to organize or group facet values. For example, in a user interface facet values can be grouped and displayed in groups according to facets. In one implementation a facet can be listed and facet values can be listed under or as a sub listing of the facet.","A facet can be stored in a field of an index document for a code element. For example, when a parser parses a code element for indexing, it can input a facet and facet value into an identifiable field for facet options (facet field). The facet field can be used to determine a facet of the indexed code element when the index document is searched. For example, a search engine can search an index to find index documents with similar facet fields and facet field values.","Facets can be used to localize source-code query results based on attributes of code elements such as classes and methods. This faceted search of source code can use facets of code objects to easily narrow down source-code query results based on additional attributes of code elements. For example, for the Java programming language, \u201cEXTENDS\u201d can be a facet that corresponds to source-code elements with the attribute of extending (e.g., a class). Also for example, the source-code element that extends a class can have \u201cExtends\u201d as part of the syntax or text of the code that can be extracted when parsed. In other examples, a facet can be a category based on a reserved term in a programming language or based on some other syntax or textual element in source code that can be identified in the source code text by parsing the source code according to the syntax of a programming language. For example, for Java objects facets can be based on inheritance, implementing, calls, imports, or the like. These exemplary facets can be \u201cInheritance,\u201d \u201cImplementing,\u201d \u201cCalls,\u201d \u201cImports,\u201d or other facets based on the programming language. Also, facets can be associated with class dependencies.","In some examples a facet can be associated with an attribute that can be extracted from source code by a parser. For example, in the source code of code element A, a parser can encounter that code element A \u201cimplements\u201d code element B and the parser can store or input information in a value or field that indicates code element A implements code element B. For example the parser can store the indication of a code attribute in an index document or some other data store such as a database or the like. In some examples, once a facet is associated with a code element in a data store, the data store can be searched or queried to find the facets associate with the code element. For example, an index document for code element A can be searched for a field that indicates code element A implements other code elements.","A facet can be selected. For example, a user can select a facet in a user interface by clicking on an indication of the facet or by some other selection method. An indication of the facet can be a word, phrase, or user interface element that corresponds with the facet. For example, the facet \u201cimplements\u201d that is a categorization of code elements that implement other code elements can be sent to a user interface and displayed. The facet can be selected by selecting a user interface element that includes an indication of the facet such as the word \u201cimplements\u201d or some other indication that the user interface element corresponds to the facet. When the facet is selected facet values that correspond to the facet can be displayed as options. For example, if the implements facet is selected, facet values that correspond to source-code query results that retrieve code elements that implement other code elements can be displayed. A facet can include or have a sub categorization of one or more facet values.","In another example, facets can be designated for facet fields of index documents. For example, an index document for a class code element can have a facet field that is designated as \u201cclassname\u201d which can be associated with a value of the name of the class. Table 1 shows facets that can be designated for facet fields. Other facets can be determined and extracted based on the syntax of programming languages and written source code.",{"@attributes":{"id":"p-0095","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Facet Fields"},{"entry":"Facet Fields"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"calls"]},{"entry":[{},"classname"]},{"entry":[{},"creates"]},{"entry":[{},"extends"]},{"entry":[{},"implements"]},{"entry":[{},"imports"]},{"entry":[{},"methodname"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In any of the examples herein, a facet value can be associated with a group of source-code query results categorized under a facet. A facet value can be associated with a sub classification of source-code query results based on a distinct feature or functionality of source code. A facet value can be based on a source-code attribute. A facet value can group or be associated with a group of source-code query results.","A facet value can include a code element identifier and a results indicator. A code element identifier can be associated with source-code query results that include code elements with a particular attribute. For example, a code element identifier can be associated with query results corresponding to classes that implement a particular interface. The code element name, name variation or other identifier of the code element can be included in the code element identifier.","A results indicator can indicate the number of source-code query results included in the group for the facet value. For example, the results indicator can give the number of hits within source-code query results that match the category of the code element identifier.","A code attribute that can be associated with a facet value can be stored in a field of an index document for a code element. For example, when a parser parses a code element for indexing, it can input a facet and code attributes for one or more facet values into an identifiable field for facet options (facet field). The facet field can be used to determine a facet value of the indexed code element when the index document is searched in the index. The values, information, or text of the facet field can be code attributes, facets, identifiers of code elements, indications of functionality of a code element, or other information that can be used as a categorization for a facet value. For example, some of the information of the value of the facet field can be used as a code element identifier or used to match or group code elements with similar attributes for determining a facet value. In a further example, an identifier of a code element in a facet field can be used to match or group the indexed code element with other similarly attributed code elements. The identifier of the code element or a variation of it can be used as the code element identifier in the facet value displayed in a user interface.","A facet value can be selected. For example, a user can select a facet value in a user interface by clicking on the facet value, clicking on a face value selection box or by some other selection method. The facet value can be associated with query terms and operators that can limit a query. For example, when a facet value is selected the facet value query terms and operators can be added to the query terms and operators that were used to generate the facet value and sent as a new query. A facet value selection can also be sent using other techniques such as sending a selection value indicating the selection or other techniques.","More than one facet value can be selected to refine source code query results. For example, if more than one facet value is selected, the selected facet values can be used to limit the source-code search results. In yet another example, the intersection of the results associated with the facet values can be returned as the refined source-code query results. In a further example, the selected facet values can limit results in combination with selected semantic clusters, and a user entered query.",{"@attributes":{"id":"p-0102","num":"0101"},"figref":"FIG. 10","b":["1000","1010","1020","1030","1040"]},"At block , on or more semantic clusters can be generated. At block , one or more facet options can be determined. The semantic clusters and facet options can be generated or determined using different or parallel threads or using a single thread.","At block , the semantic cluster options can be sent or received. For example semantic cluster options can be sent and then received. At block , facet options can be sent or received. At block , source-code query results or refined source-code query results can be sent or received. Each of the source-code query results, the semantic cluster options, and the facet options can be sent or received in parallel or asynchronously of each other. For example, the source-code query results and semantic cluster options can be sent after the source code query results are sent.","At block , a semantic cluster option can be selected. In one exemplary implementation one semantic cluster option (e.g., only one) can be selected. In another exemplary implementation, for example more than one semantic cluster option can be selected. At block,  one or more facet options can be selected.","At block , selected options or a query can be sent. For example, a user can select a semantic cluster option or a facet option and it can be sent along with a query. A facet option can include one or more facets, and one or more facet values. The query can be the same or similar to the query that was received at  along with the option selections as limitations of the query. The query can be generated at block . For example, a user searching for source code can generate a query for source code search results.","At block , a source code query result selection can be sent or received. For example, when source code query results are received, a user can select one of the source code query results. At block , the source code corresponding to the selected source-code query result can be sent or received. For example when the user selects a source-code query result the corresponding source code is sent in a formatted html document and received for the user to view in a web browser or user interface.",{"@attributes":{"id":"p-0108","num":"0107"},"figref":"FIG. 11","b":["1100","1100","1120","1120","1130","1132","1120","1120","1140","1144","1142","1148","1140","1142"]},"The server environment  is connected to a network . For example, the network  can be a global communication network, such as the Internet. The network  can represent various network resources that are needed for end-to-end communication between the server environment  and one or more client devices (e.g., client device ). For example, the network  can represent the Internet in combination with other types of networks, such as mobile phone networks (e.g., cell phone networks), Wi-Fi networks, and the like.","The server environment provides source-code search results and options to client devices such as client device . Client device  can include a processor , memory , a web browser  (e.g., Internet Explorer\u00ae). The web browser  can receive and display source code query results , semantic cluster options , source code , and facet options . The browser  can also send source-code queries and selections of semantic cluster options and facet options.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 12A","b":["1200","1200","1210","1220","1200"]},"The client user interface  can also include windows for source-code such as source code window . The client user interface can also include windows for source-code query results such as source-code query results window  of . For example, a user can select the source code search result tab , and the window  with one or more source-code search results such as source-code query results  and  can be displayed.","The client user interface  can also have a search window  for generating and sending queries for searching source code. For example, a user can input text (e.g. query terms and operators) in a query field of the search window  and send the query by selecting the search button.","The client user interface can also have an address field for directing the client user interface to an online resource. For example, the client user interface can be implemented in web browser and the address field  can be used for an internet address that allows access to an online source-code search environment.",{"@attributes":{"id":"p-0115","num":"0114"},"figref":"FIG. 13","b":"1310"},"At block , semantic cluster identifiers are created. For example, each of the generated semantic clusters can be associated with a semantic cluster identifier that indicate a concept based on similar entries in fields of indexed documents.","At block , semantic cluster options are sent or received. For example generated semantic cluster options can be sent from a server and received by a client.","At block , cluster information is displayed. For example, the cluster information can be displayed to a user when the user activates the information for a semantic cluster. The cluster information can be activated when a cursor hovers over a semantic cluster option.","At block , a semantic cluster option can be selected. For example, a user can select a semantic cluster option by mouse clicking on the semantic cluster option displayed in a user interface.","At block , based on the selected semantic cluster option, refined source-code query results can be sent or received. For example, a user can select a semantic cluster option and then refined source-code query results that are limited by the selected semantic cluster can be received.",{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 14","b":["1400","1410"]},"At block  one or more facets can be determined by categorizing the source-code query results by code attributes based on the syntax of source-code elements. In one example, the source code query results can be categorized or grouped because they correspond to code elements that have the attribute of implementing as indicated by the syntax of code of the code element. In other examples, different facets can be determined based on code attributes based on the syntax of code elements.","At block , one or more facet values can be determined for each of the facets that categorize the source-code query results. The facet values can be determined based on the query results within each facet that have similar attributes. For example, a facet value can correspond to the source-code query results grouped under a facet that implement the same interface.","At block , facet options are sent or received. For example, a server can send facets and facet values to be received by a client.","At block , one or more facet options can be displayed. For example, facets and facet values can be displayed in a user interface.","At block , one or more facet values can be selected. For example, a user can select a facet to determine facet values grouped under the facet and the user can select one or more of the facet values and an indication of the selected facet values can be sent to a server.","At block , refined source-code query results are sent or received based on selected facet values. For example, when a server receives an indication of a selected facet value source-code query results can be refined by limiting the source code query results to the results that are associated with the selected facet value.",{"@attributes":{"id":"p-0128","num":"0127"},"figref":"FIG. 15","b":["1500","1500","1510","1520","1530","1520","1540","1545","1520"]},"The indexer  can populate index document fields by parsing source code based on a programming language. For example, source code written in a programming language can be parsed according to that language to find code elements. Those code elements can then be parsed so that values of the index document can be populated based on the code syntax and text.","The index documents  can have fields such as the fields of index document . In index document  there can be a query result field that includes text for a source-code query result that can be displayed. Also index document  can include a code field E that includes the code of the code element. The index document  can include a cluster identification field C that can include words, data, or information used in determining a cluster ID.","The index document  can have a facet field D that includes information about facets that are associated with the code element of the index document D. For example, the facet field D can list code attributes found in code of the code element of the index document. The facet field D can also include information about facet values that are associated with the code element of the index document . The index document  can include a title field A that can hold the title of a code element. The title field A can be extracted from a document title of a source-code document where source code is written, or from code element text. Variations of the extracted text can be used such as removing unnecessary words.","In the exemplary system  a query service can use the index  to refine source code-search results. A query  can be sent to the query service and the query service can use the index to return a source-code query response . A refinement selection can be sent to the query service  and the query service  can use the index  to return a refined source-code query response .",{"@attributes":{"id":"p-0133","num":"0132"},"figref":"FIG. 16","b":"1600"},"At block , source code can be indexed. For example, source code can be parsed according to a programming language and code elements can provide values for fields of index documents.","At block , the index of source code can be stored. For example, the indexed source code can be stored in an index.","At block , indexed source code can be used to determine a source code query response. For example, fields of index documents of the indexed source code can be searched or queried to determine facets, facet values, semantic clusters, cluster identifiers, source-code search results, and refined source-code search results.",{"@attributes":{"id":"p-0137","num":"0136"},"figref":"FIG. 17","b":"1700"},"In the architecture , source code  can be indexed by indexer . The indexer  can parse source code according to a programming language. In one embodiment of the indexer, the indexer  can use the Eclipse JDT parser to parse source code or some other parser can be used. Indexed code elements with attributes and dependencies can be stored in one or more indexes A-C accessible to search server . The indexer  can also produce source-code documents . The source code documents can be intelligently formatted HTML files which are used in a web component for cross navigation between the sources online. Source code documents  can be accessed by web browsers such as web browser . Also, refined source-code query results and options  can be displayed in web browser .","The search server  can search the index of code elements of source code. In one embodiment, the search server  can be implemented through Apache Solr server or some other server. In one example embodiment, the search server  can both store and retrieve the information through a common application programming interface (API) or by some other technique. The search server  can be configured to support either semantic cluster based search or facet based search or both. For example, the search server  can refine source code search results based on selected facet options or selected semantic cluster options. The search server can interact with a web server  with web platform  to be a query service and provide the functionality of a query service for refining source-code search results .","In any of the examples herein, a code element can be a portion of the text of source code that can be designated from the syntax of a programming language. For example, a code element can be a class, a method, a function, routine, a statement, or other like logical code element. Code elements can be hierarchical combinations of code elements. For example, both a designated method of a class and the class itself that includes the method can be different code elements. Also, for example, code element can be source code comments which are designated by a comment marker. A code element can be a combination of other code elements. For example, a code element can be a comments section of a class, the class, or both the comments and the class. A source code element can be created for the contents of a source code file or a portion of the contents. For example, a class that is written in a source code file or document can indexed as a code element.","A code element can be determined, identified, or extracted by parsing source code according to the syntax of a programming language. A code element can have attributes that can be identified or determined by and indexer. For example, an indexer can parse source code written in the C++ programming language according to the syntax of the language to extract code elements, such as classes, functions and the like. Attributes of the code elements can be used to create index documents with information about the code elements. In one implementation, code elements can be identified and extracted because a parser can identify the beginning, end and body of a class based on the syntax of the programming language. In another example, code elements can be discrete segments of source code that can be searched for by a user.","In any of the examples herein, a source-code query can include query terms operators and limiters. Query terms can be text, words, phrases, or character strings. A source-code query can include operators, such as Boolean operators such as \u201cAND,\u201d \u201cOR,\u201d and \u201cNOT,\u201d or other operators. In one example of a query, a user searching for source code can enter the query \u201cclassname:server AND methodname:send.\u201d This query can return classes with the word server in the class name and that have a method with send in the method name. In other examples, other queries can be created using different query terms and query syntaxes.","The source-code query terms can be arranged according to a syntax. For example, if a user wanted to search for a class named Foo the query for the search can be classname:Foo. Where classname indicates a code element type and Foo separated by a colon can indicate the name of the class or a textual portion of the class. Other textual arrangements or syntaxes can be used however. For example, a query that matches text terms can be used.","Query terms, operators, or limiters for a source-code query can be entered by a user, or automatically. For example, a user can enter query terms into a text or query field of a user interface to search for source code.","In another example, query terms, operators, or limiters can be automatically entered into a source-code query. For example, a user can select a facet option or a semantic cluster option and a query term, operator, or limiter indicating the selection can be automatically added to a source-code query.","In one example, when a facet value is selected an indication of the selected facet value and corresponding facet can be added to a query as query terms that further limit the query. For example, for a facet value that implements interface foo, the automatic query terms and operators can be \u201cAND Implements:foo.\u201d These query terms and operators can limit the source-code search results for the query to results that correspond to code elements that implement the interface foo.","In another example, when a cluster option is selected an indication of the selected semantic cluster option can be added to a query as query terms that further limit the query.","In any of the examples herein, a source-code query response or query response can include source-code query results, facet options, semantic cluster options, facet values, or facets. For example, in response to a query from a user searching for source code, a source-code query response can be sent including source-code query results, semantic cluster options, and facet options as choices for selection by the user.","In any of the examples herein, a source-code query result can be a result determined in response to a source-code query. A source-code query result can be used to retrieve or reference source code, a code element, or an index document. For example, a user can select a source code query result by mouse clicking on the source-code query result and the selection can retrieve the associated code element.","The source-code query result can be displayed in a user interface at a client. In one implementation, source-code query results can be implemented in part as links in a in a web page displayed in a web browser or user interface using internet technologies such as HTML, hyperlinks or other internet technologies. A source code query result can include an identifier of the source code or element that it can retrieve. Also, a source code query results can include a portion or all of the text of the code element. For example, the code structure query result can display the first 100 characters of the source code element so that a user can preview the source code. A source code query result can include a hyperlink to retrieve a html document containing the source code or code element. Also, for example a user searching for source code can view or scroll through source-code query results to view available source code hits.","A source-code query result can be ranked and displayed or listed in an order of relevance. An order of relevance can be determined by a ranking based on a heuristic that determines relevance. For example, source-code query results can be ranked based on an algorithm such as a statistical algorithm or some other algorithm where a query is matched with source code or a source code element. Source-code query results can be paginated and displayed in various pages that can be accessed by selecting a pagination option, such as a next page, numbered page, or the like. Also, source-code query results can be displayed in a single page or window.","In any of the examples herein, refined source-code query results can be a subset, subgrouping, categorization, group, or limited combination of source-code query results from a larger group of source-code query results. For example, if a query produces a large number of source-code query results, the results can be refined to a smaller number of those results. In some examples, refining source-code query results can be based on facets, facet values, semantic clusters, semantic cluster options, or a combination of the factors. In other examples, source-code query results can be refined based on other considerations, such as those described herein.","Refined source-code query results can be based on one or more selected semantic cluster options and one or more selected facet value selections. For example, a facet value can be selected and a semantic cluster option can be selected and the refined source-code query results returned can be the intersection of the results associated with the selected facet value and the selected semantic cluster option.","In any of the examples herein, source-code query results can be generated based on a source-code query or selected options such as facet options or semantic cluster options. Source-code query results can correspond to a limited number of results that conform to the limitations of a query. For example, a search server can search indexed source code to identify source code that conforms to the limitations of the query and return the associated source-code search results. The limitations can be determined by query terms and operators. Also indications of selections can limit source-code search results such as in refined source-code search results.","In any of the examples herein, a code attribute can be an attribute of a code element that can be determined from parsing the text of the code element according to a programming language. For example, a method can have the attribute of calling another method. This can be determined from the text of the code element because the first method can have code text that calls the second method or indicates that it can call the second method.","A code attribute can be associated with some functionality or identifier of the source-code or code element. For example, one code attribute can be that the code element implements some functionality. Another example code attribute can be that the code element calls another code element (e.g. a class, method, function). Another code attribute can be that the code element is a class or method identified by a class or method name. Other examples of code attributes can be that a code element has functionality that creates, extends, or imports a specific code element or function. Other code attributes can be determined by a parser depending on the source code and the programming language it is written in.","In any of the examples herein, an index document can be an index of a code element. An index document can include fields with field values. An index document can include a query results field that includes a source-code query result. An index document for a code element can have fields for facets, facet values, cluster identifiers, the text of the code element, an identifier of the code element, dependencies of the code element, and other attributes of the code element. For example, an index document can include a cluster identification field that can include words, data, or information used in determining a cluster ID for a cluster that includes the source-code search result of the index document. An index document can include other fields such as a title field, cluster ID field, facet field, code field, and other fields of the like.","In any of the examples herein, source code can be any software source code or portion of source code written according to an object-oriented programming language or a non-object-oriented programming language. For example, source code can be written in C, C++, C#, Java, Basic, Fortran, Lisp, Prolog, Perl, scripting languages, and the like.","In some examples, source code can be represented by a model, an intermediate representation of the source code, or the like. A representation of the source code can be used in place of the source code in any of the examples herein.","In any of the examples herein, a selection can be a selection of a facet option, semantic cluster option, facet, or facet value. A selection can be sent. For example, an indication of a selection can be sent in a query as one or more query terms, one or more operators, or a combination of query terms and operators. In one example, when a facet value is selected an original query is augmented to include query terms and operators that limit and refine source-code query results. These refined results can be the intersection of the source-code query results determined from the original query terms and operators and the augmented terms of the facet value selection.","Also, for example, a selected option can be sent by other techniques such as with a selection value, or some other technique. For example, when a semantic cluster option is selected an indication of the selected semantic cluster option can be sent to a server and cached source-code query results can be returned in response to receiving the indication of the selected semantic cluster option.","Narrowing query results using facets and semantic clusters offers users an efficient and comprehensive way to search source code. Searching source code using faceted search and semantic cluster based search can easily narrow down query results. The results classification and clustering help the user to make better judgments about the code elements found. The user need not re-tune the query repeatedly. The user can focus on query results instead of query construction.","Faceted search can group query results dynamically into categories. The grouped query results can then be provided to a user as options for drilling down into the query results. For example, a user can choose from different facet values so that a large number of results can be narrowed down based on code attributes and a user's knowledge of the source code desired. Selection of facets and facet values allows users to narrow the results of a query by applying constraints to the query provided by the user.","Semantic cluster based search can also group query results dynamically into categories. The semantic cluster options can be provided to a user as options for refining source code query results based on concepts automatically identified among the clustered results.","The techniques and solutions described herein can be performed by software and\/or hardware of a computing environment, such as a computing device. For example, computing devices include server computers, desktop computers, laptop computers, notebook computers, netbooks, tablet devices, mobile devices, and other types of computing devices (e.g., devices such as televisions, media players, or other types of entertainment devices that comprise computing capabilities such as audio\/video streaming capabilities and\/or network access capabilities). The techniques and solutions described herein can be performed in a cloud computing environment (e.g., comprising virtual machines and underlying infrastructure resources).",{"@attributes":{"id":"p-0166","num":"0165"},"figref":"FIG. 18","b":["1800","1800"]},"With reference to , the computing environment  includes at least one central processing unit  and memory . In , this most basic configuration  is included within a dashed line. The central processing unit  executes computer-executable instructions. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power and as such, multiple processors can be running simultaneously. The memory  may be volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory, etc.), or some combination of the two. The memory  stores software  that can, for example, implement the technologies described herein. A computing environment may have additional features. For example, the computing environment  includes storage , one or more input devices , one or more output devices , and one or more communication connections . An interconnection mechanism (not shown) such as a bus, a controller, or a network, interconnects the components of the computing environment . Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment , and coordinates activities of the components of the computing environment .","The storage  may be removable or non-removable, and includes magnetic disks, magnetic tapes or cassettes, CD-ROMs, CD-RWs, DVDs, or any other tangible storage medium which can be used to store information and which can be accessed within the computing environment . The storage  stores computer-executable instructions for the software , which can implement technologies described herein.","The input device(s)  may be a touch input device, such as a keyboard, keypad, mouse, pen, or trackball, a voice input device, a scanning device, or another device, that provides input to the computing environment . For audio, the input device(s)  may be a sound card or similar device that accepts audio input in analog or digital form, or a CD-ROM reader that provides audio samples to the computing environment . The output device(s)  may be a display, printer, speaker, CD-writer, or another device that provides output from the computing environment .","The communication connection(s)  enable communication over a communication medium (e.g., a connecting network) to another computing entity. The communication medium conveys information such as computer-executable instructions, compressed graphics information, or other data in a modulated data signal.","Although the operations of some of the disclosed methods are described in a particular, sequential order for convenient presentation, it should be understood that this manner of description encompasses rearrangement, unless a particular ordering is required by specific language set forth below. For example, operations described sequentially may in some cases be rearranged or performed concurrently. Moreover, for the sake of simplicity, the attached figures may not show the various ways in which the disclosed methods can be used in conjunction with other methods.","Any of the disclosed methods can be implemented as computer-executable instructions stored on one or more computer-readable media (tangible computer-readable storage media, such as one or more optical media discs, volatile memory components (such as DRAM or SRAM), or nonvolatile memory components (such as hard drives)) and executed on a computing device (e.g., any commercially available computer, including smart phones or other mobile devices that include computing hardware). By way of example, computer-readable media include memory  and\/or storage . As should be readily understood, the term computer-readable media does not include communication connections (e.g., ) such as modulated data signals.","Any of the computer-executable instructions for implementing the disclosed techniques as well as any data created and used during implementation of the disclosed embodiments can be stored on one or more computer-readable media. The computer-executable instructions can be part of, for example, a dedicated software application or a software application that is accessed or downloaded via a web browser or other software application (such as a remote computing application). Such software can be executed, for example, on a single local computer (e.g., any suitable commercially available computer) or in a network environment (e.g., via the Internet, a wide-area network, a local-area network, a client-server network (such as a cloud computing network), or other such network) using one or more network computers.","For clarity, only certain selected aspects of the software-based implementations are described. Other details that are well known in the art are omitted. For example, it should be understood that the disclosed technology is not limited to any specific computer language or program. For instance, the disclosed technology can be implemented by software written in C++, Java, Perl, JavaScript, Adobe Flash, or any other suitable programming language. Likewise, the disclosed technology is not limited to a particular type of hardware. Certain details of suitable computers and hardware are well known and need not be set forth in detail in this disclosure.","Furthermore, any of the software-based embodiments (comprising, for example, computer-executable instructions for causing a computing device to perform any of the disclosed methods) can be uploaded, downloaded, or remotely accessed through a suitable communication means. Such suitable communication means include, for example, the Internet, the World Wide Web, an intranet, software applications, cable (including fiber optic cable), magnetic communications, electromagnetic communications (including RF, microwave, and infrared communications), electronic communications, or other such communication means.","The disclosed methods, apparatus, and systems should not be construed as limiting in any way. Instead, the present disclosure is directed towards all novel and nonobvious features and aspects of the various disclosed embodiments, alone and in various combinations and subcombinations with one another. The disclosed methods, apparatus, and systems are not limited to any specific aspect or feature or combination thereof, nor do the disclosed embodiments require that any one or more specific advantages be present or problems be solved. Rather, the scope of the invention is defined by the following claims. We therefore claim as our invention all that comes within the scope of these claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 12A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 18"}]},"DETDESC":[{},{}]}
