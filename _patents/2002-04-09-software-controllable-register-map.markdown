---
title: Software controllable register map
abstract: Virtual registers are mapped to architectural or physical registers according to a register map that is configurable with software. In one embodiment, only privileged software can configure the register map. In another embodiment, a portion of the register map is configurable with non-privileged software, and another portion is only configurable with privileged software. In yet another embodiment the register map is fully configurable by user software. The configurable register map provides backwards compatibility to code written for hardware-defined register mapping, while allowing flexible approaches to register mapping in code generated for a processor architecture using a software controllable register map.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07065631&OS=07065631&RS=07065631
owner: Sun Microsystems, Inc.
number: 07065631
owner_city: Santa Clara
owner_country: US
publication_date: 20020409
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","STATEMENT REGARDING FEDERALLY SPONSORED RESEARCH OR DEVELOPMENT","REFERENCE TO MICROFICHE APPENDIX","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","I. Introduction","II. An Exemplary Processor","III. Register Window Emulation","IV. Register Map Access Privileges","V. An Exemplary Register Map","VI. Register Map Cache","VII. Exemplary Register Map","VIII. Register Mapping for Privileged Code","IX. Multiple Register Map(s)","X. Compatibility With Other Register Organization Techniques","XI. Method of Mapping Virtual to Architectural Registers"],"p":["Not applicable.","Not applicable.","Not applicable.","The invention relates generally to methods and apparatus for computer register memory and more particularly to mapping registers.","Computer systems use many different types of memory for storing information. Magnetic disks, optical compact disk read-only memory (\u201cCD-ROM\u201d), electronic ROM, and random-access memory (\u201cRAM\u201d) are a few examples of types of computer memory that are relatively inexpensive, in terms of the cost per bit, and capable of storing a relatively large amount of memory. However, computer systems typically have other types of memory that might not be apparent to a casual user.","A processor chip (\u201cprocessor\u201d) might have memory integrated with the logic processor to enhance operational speed. For example, the processor chip might have one or more levels of cache memory and a register file. The register file is a set of registers that is integrated with the logic processor on the central processing unit (\u201cCPU\u201d) section of the processor chip.","Generally, one level of memory is fed by another. For example, an application might call input that is loaded to the cache memory from the main memory (e.g. off-chip ROM or RAM), and then to the register file. Typically, each level provides faster access than the prior level, the fastest being the register files, which can work at the full internal processor speed. Unfortunately, this speed comes at a price.","Register memory has a relatively large \u201cfootprint\u201d compared to main memory, for example, and consumes a relatively large amount of power, so the physical size of the register file is limited. Similarly, how an application can access registers is defined by the processor hardware, and usually results in a fixed relationship between registers. Processor register architectures become fixed when they are designed. This limits software to accessing a fixed number of registers in hardware. However, it is not only the number of registers that are fixed, but the methods of accessing the registers are also fixed. This contributes to an aging of the architecture over time.","This aging can arise from the evolution of software applications and how applications access registers. The growth of modular software, increasing call-chain depths, and decreasing function size are examples of how software has been changing. At the time a processor architecture is defined, certain assumptions are made about the size and number of the registers and how they will be used, such as how many bits in an instruction string will be used to identify a register address (i.e. the \u201cregister number\u201d). Using an N-bit register number as a direct index to a register file limits software to accessing 2registers.","Various techniques, such as register windows, have been developed for accessing other numbers of registers, but these techniques often place adders or non-power-of-two modulo operations in the logic path for physical register index generation. This can create a critical timing path issue for future hardware implementations, or impose additional pipeline stage(s) on future hardware implementations. Similarly, register access methods that attempt to access other numbers of registers with an N-bit register number system by creating multiple register files (of up to 2registers each), for example, split integer and floating-point register files, typically require additional instruction encodings to address the different register files. Experimenting with other register models, for example to test compilers generating software to run on future hardware implementations, with a fixed set of registers and access methods can be inefficient and difficult. Similar problems or limitations can arise when simulating or emulating register models for other processor architectures, for example, when executing software generated for a \u201cforeign\u201d architecture. Fixed-size register windows have been used in the SPARC\u2122 architecture and variable-size register windows have been used in the IA-64 architecture.","One microprocessor implemented a \u201cframe pointer\u201d register. A fixed block of general-purpose registers was stored in a block of memory starting at a location indicated by the frame pointer, instead of putting the block of registers on-chip. The frame pointer mapped all register references to a block of memory addresses. This was a degenerate case of a register map because the frame pointer contained only one entry, instead of a separate map entry for each register. The frame pointer technique partially addressed the problems of addressing a fixed number of registers in hardware and N-bit register numbers limiting software to 2registers, but left other problems unresolved. Unfortunately, a frame pointer technique would probably provide unacceptably poor performance in current microprocessors, where memory access is typically orders of magnitude slower than on-chip register access.","Other processor architectures, such as the scalable processor architecture (\u201cSPARC\u201d\u2122) version 8 (\u201cV8\u201d), IA-64, IA-32, and 680X0, have addressed the problem of being limited to 2registers when using N-bit direct index register numbers by creating separate namespaces for different types of register, for example, integer\/general purpose and floating-point name spaces. Given N-bit register number fields in instructions, more than one set of 2registers can be addressed by restricting register number fields in each instruction to only address one set of 2registers (i.e. only one register name space at a time). However, this approach still suffers from architecture aging, not allowing applications to optimize register access, and requiring additional instruction encodings to address all the register namespaces.","The hardware technique of register re-naming, as is typically used in out-of-order processor implementations, partially addresses the problems of addressing a fixed number of registers in hardware and N-bit register numbers limiting software to 2registers, but leaves other problems unresolved. Register re-naming is a hardware technique that is invisible to software and involves use of a register map. SPARC64\u2122, PA-8000\u2122, MIPS R10000\u2122 and PENTIUM\u2122 processors include examples of processors using hardware register re-naming.","In summary, most processor architectures have provided a fixed-size array of general-purpose registers, accessible by a single access method in instructions, namely, direct index into the register array. At least one architecture has added an additional rotating register method of accessing those registers. However, even using rotating registers leaves several problems unresolved.","A processor architecture has a register map that is controllable with software. In one embodiment, the register map is controllable with user (application or non-privileged) software. In another embodiment, some or all of the register map is only controllable with privileged software, such as the operating system.","A register map that is programmable through software, rather than fixed in hardware, provides a flexible register architecture(s). The programmable register map can support various access methods and can accommodate new register organizations as software evolves. Compilers can experiment with new register organizations on existing hardware, and register-access methods can be optimized on a per-application basis. Similarly, a large physical register file can be utilized in a flexible manner and can focus on particular categories of performance needs, e.g. floating-point vs. JAVA\u2122 execution.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["10","12","14","16","18","20","11","22","24","26","28","30","32"]},"The chip  interfaces with other functional blocks of a computer system, such as main memory . Main memory is generally slower but less expensive than registers. The optimum number of registers is not fixed for all applications, and it is generally desirable to limit the number of physical registers to the anticipated maximum number needed for an application. However, it is difficult to anticipate what will be needed as application software evolves. For example, application call depth is growing, breaking prior assumptions about optimal register architecture that led to register windows. While register windows appeared to be a good solution at the time, and are still desirable for many applications, in other instances an undesirable number of runtime register spills\/fills to memory may occur. Similarly, application function size is shrinking, causing 16-register windows to be used inefficiently in some applications.","Embodiments of the present invention allow a flexible approach to register mapping. In some instances, emulation of a prior hardware-based register mapping technique is achieved. Such emulation allows code written for a processor with hardware-based register mapping to run on later processors with software-controllable register mapping. Register windows are an example of a prior hardware-based register mapping technique that may be emulated with software-controllable register mapping.","To emulate register windows using the register configuration shown in  or B, the processor requires additional register window state information. An example of the additional state information is shown in FIG. . It is assumed in this example that:\n\n","For each block of 16 architectural registers (referred to in this section as an \u201carchitectural register window block\u201d or \u201cARWB\u201d), the following information is kept:\n\n","Given the data structures in , the following pseudo-code illustrates one way a SAVE instruction could be implemented (emulated) on a processor with mapped registers:",{"@attributes":{"id":"p-0032","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#","va[] is the 32-entry Register Map array"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#","(maps virtual register #s to architectural register #s)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#","ap[] is the 256-entry Architectural register map array"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#","(maps architectural register #s to physical register #s)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#","p[] is array of physical registers"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"# Take SAVE operands from registers in the \u201cold\u201d window."]},{"entry":[{},"if (instruction.i = 1)"]},{"entry":[{},"then result <-- p[ap[va[instruction.rs1]]]"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"+ p[ap[va[instruction.rs2]]];"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else result <-- p[ap[va[instruction.rs1]]] +"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"sign_extend(instruction.simm13);"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endif"]},{"entry":[{},"# Get the index to the next register window (block of"]},{"entry":[{},"# 16 architectural registers). Use the most significant 4 bits"]},{"entry":[{},"# of one of the \u201cout\u201d registers (8-15) to generate the index"]},{"entry":[{},"# into the SR_next_save_ARWB array."]},{"entry":[{},"next_ARWB <-- SR_next_save_ARWB[va[8]<7:4>];"]},{"entry":[{},"# If the next register window (block of 16 architectural registers)"]},{"entry":[{},"# is already in use, save them to memory."]},{"entry":[{},"if(SR_ARWB_is_in_use[next_ARWB] = 1)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"then","{ spill the 16 architectural registers indicated by"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"next_ARWB to a safe location in memory }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"endif"]},{"entry":[{},"# Update the 8 \u2033in\u2033 register mapping from the old \u2033out\u2033"]},{"entry":[{},"register maps."]},{"entry":[{},"# (if register windows are truly aligned on 16-register boundaries"]},{"entry":[{},"# in the architectural register file, then only the most significant"]},{"entry":[{},"# 4 bits of each \u2033in\u2033 register mapping would need to be updated)."]},{"entry":[{},"va[31] <-- va[15];"]},{"entry":[{},"va[30] <-- va[14];"]},{"entry":[{},"va[29] <-- va[13];"]},{"entry":[{},"va[28] <-- va[12];"]},{"entry":[{},"va[27] <-- va[11];"]},{"entry":[{},"va[26] <-- va[10];"]},{"entry":[{},"va[25] <-- va[9];"]},{"entry":[{},"va[24] <-- va[8];"]},{"entry":[{},"# Update the most signficant 4 bits of \u2033local\u2033 (16-23) and"]},{"entry":[{},"# \u2033out\u2033 (8-15) register maps, from the starting register number"]},{"entry":[{},"# of the new block of architectural registers."]},{"entry":[{},"va[23]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[22]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[21]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[20]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[19]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[18]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[17]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[16]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[15]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[14]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[13]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[19]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[12]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[11]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[10]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[9]<7:4> <-- next_ARWB;"]},{"entry":[{},"va[8]<7:4> <-- next_ARWB;"]},{"entry":[{},"# Mark the \u2033window block\u2033 as \u2033in use\u2033"]},{"entry":[{},"SR_ARWB_is_in_use[next_ARWB] <-- 1;"]},{"entry":[{},"# Set the result of the SAVE instruction in the destination"]},{"entry":[{},"# register of the SAVE (which is relative to the new window)."]},{"entry":[{},"if (instruction.rd != 0)"]},{"entry":[{},"then p[ap[va[instruction.rd]]] <-- result;"]},{"entry":[{},"endif"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Note that software access privileges are not required to be uniform across all architectural registers. For example, some architectural registers may be read-only to, or not mappable at all by, nonprivileged software. In those cases, privileged software could make privileged information completely inaccessible to, accessible on a read-only basis to, or fully accessible (readable and writable) to nonprivileged software. One possible application of this is that privileged software could retain key privileged information in privileged architectural registers while nonprivileged software executes, without the potentially time-consuming operations (required in conventional register schemes) of saving and restoring that information to and from memory. Privileged software would only have to save the mapping to those registers, which itself could be saved in architectural register(s) and would not necessarily have to be saved in memory.",{"@attributes":{"id":"p-0034","num":"0039"},"figref":"FIG. 3A","b":["90","92"]},{"@attributes":{"id":"p-0035","num":"0040"},"figref":["FIG. 3B","FIG. 3A","FIG. 3B"],"b":["94","0","96","0","98","100","102","104","106"]},"A TAGS field could carry information such as a \u201cregister dirty\u201d bit (meaning that the register had been modified since the dirty bit was last set to zero), a speculative-load exception bit (which would indicated that an exception would have occurred on the last speculative load that used the register as a destination register), and\/or register condition code tags for access by branch-on-register-value operations. Live and PrevP might be used in an implementation using a conservative register renaming strategy. During instruction decode, the virtual register numbers in an instruction are mapped to physical registers via the current register map and RRM, if any. While the instruction in the cache retains reference to the original virtual register numbers, the corresponding instruction in the processor's execution pipeline would refer to the physical register number, with no notion of the original virtual register number being retained in the pipeline.","In an implementation of a two-level map (ref. ) with register renaming and short pipeline stages, there may be a concern that a two-level map could either create a critical path (lengthening cycle time) or add an extra stage to the pipeline. In an alternative embodiment, it might be possible to collapse register mapping and register renaming into a single map, but not without giving up the flexibility provided by allowing the register map to be manipulated by the user. However, in such an implementation it is possible to optimize hardware so that the privileged software model is a two-level register map, but only a single-level lookup is required while decoding each instruction.","One such optimization would be to create a 32-entry (generally (log(nAR))) register map cache (\u201cRMC\u201d) in hardware, invisible to software, that contains the current physical register number to which each virtual register is currently mapped. As each instruction is decoded, the decoder would directly read the current virtual-to-physical translation for each virtual register number from the RMC, without doing a two-level lookup through the user register map and the RRM. The RMC, or the applicable portion of it, would be updated by hardware when the register map or RRM is updated.",{"@attributes":{"id":"p-0039","num":"0044"},"figref":"FIG. 4A","b":["120","122","124","126","128","0","1","2","3","17","17"]},"A full register map in this example comprises 256 bits (shown in FIG. A and , below, as four 64-bit values). However, all or part of the map can be changed with a single instruction; for example, register window SAVE or RESTORE instructions or an instruction with a 64-bit operand that modifies the entire register map with a source register granularity of four (that is, registers are mapped in blocks of four). Other such instructions might implement register rotation, stacking registers, or variable-size register windows.",{"@attributes":{"id":"p-0041","num":"0046"},"figref":"FIG. 4B","b":["130","4","0","3","28","31"]},"It is anticipated that the time required to do a virtual-to-architectural register number mapping when decoding each instruction will be less for register mapping according to at least some embodiments of the present invention than for traditional register windowing, such as in SPARC\u2122 version 9 (\u201cV9\u201d). In SPARC\u2122 V9, each register number reference is relative to the CWP, which in most implementations means that virtual register numbers must pass through at least an adder and a modulo operation, and possibly two of each, to translate a windowed register number to an architectural register number.","A processor architecture that includes register mapping could guarantee that a minimum number of architectural registers, e.g. 64, would be available in all its implementations. Portable software would map a maximum of 64 architectural registers. An implementation with a larger architectural register file could be built, up to the limits imposed by the width of a register map entry. Although portable software would not access the additional registers, kernel code, dynamically linked libraries, JIT-compiled, and dynamically compiled\/translated code could use them.","In a further embodiment, the register map could be used to map virtual register numbers to registers on other processor cores, which might be on the same die or on a different die. Such accesses would probably incur longer latency than local accesses, and there would probably be a practical limit to the number of processor register sets that could be accessed.","Privileged (\u201ckernel\u201d) code could have its own integer register map, or part of one, such as registers -. An automatic switch to the kernel register map could occur upon a trap. The kernel register map might, for example, map virtual registers  through  into a different set of architectural registers than does the nonprivileged register map. The switch could implement a globals-per-trap-level feature that is desired by kernel software designers.","On a processor architecture with multiple register namespaces, such as separate integer and floating-point register namespaces, floating-point registers may be mapped with a floating-point register map parallel to the integer register map. The floating-point and integer registers could map into the same or separate underlying architectural register files. If they map into the same architectural register file, then integer instructions could access floating-point values and vice versa. Even if integer and floating-point registers map to different architectural register files, it might be possible to allow each to map in parts of the other's register file. For example, the most significant bit of each register map entry might be used to select the register file. However, in such a case, access by an integer instruction to a floating-point register may incur additional cycles of access latency.","A separate map might be used for each precision of floating-point registers. That is, single-, double-, and quad-precision registers would all be mapped into the same architectural register file, but the different precisions of registers would no longer (at least in a SPARC\u2122 implementation) need to be overlapped. In order to be compatible when executing SPARC\u2122 V9 code, all floating-point registers could be mapped in the overlapping manner specified by SPARC\u2122 V9. Similarly, a portion of the floating-point registers could be mapped to support unaligned FORTRAN doubles, or a portion of them could be overlapped for special code that takes advantage of the overlap.","Software-controllable register mapping, according to embodiments of the present invention, are compatible with several other register organization techniques, such as group mapping, individual mapping instructions, smaller fixed-size windows, variable-size register windows, register dirty bits, stack last-in-first-out registers, queued first-in-first-out registers, and N-bit register identifier techniques, where N can be adapted to a particular register architecture. Software-controllable register mapping allows use of various types of instructions to alter the mapping. In some instances, the processor can execute a sequence of instructions written for a different processor and register access method, or new map-altering instructions can be added.",{"@attributes":{"id":"p-0049","num":"0054"},"figref":"FIG. 5A","b":"500"},"A processor with a software-controllable register map(s) is provided (step ). The register map(s) is configured to map virtual registers in code, i.e. software such as non-privileged user code or privileged code, that is intended to be executed by the processor to access architectural registers of the processor (step ). The code is then executed by the processor (step ). In some instances, the code may be self-configuring, that is, it may contain computer-readable instructions for configuring the register map(s) before executing subsequent instructions.","In a further embodiment, after executing the code in step , the register map(s) is configured to a second configuration (mapping) of virtual registers to architectural registers (step ) and a second block of code is executed by the processor (step ). In other words, the register mapping is different between the execution of code in step  and the execution of code in step . Such re-configuring may occur more times, and may be structured as a loop back to a configuration step.","Instructions for performing the method illustrated in  can be stored on a computer-readable medium, such as magnetic disk, optical read-only memory (\u201cROM\u201d), electronic ROM, randomly addressable memory (\u201cRAM\u201d), or a combination of types of memory. The instructions are typically loaded to the processor and hence to the register map(s) through various layers of memory, as discussed in association with FIG. .",{"@attributes":{"id":"p-0053","num":"0058"},"figref":"FIG. 5B","b":["510","512","514","518","516","520"]},"While the invention has been described in conjunction with several specific embodiments, it is evident to those skilled in the art that many further alternatives, modifications, and variations will be apparent in light of the foregoing description. Thus, the invention described herein is intended to embrace all such alternatives, modifications, applications, and variations as may fall within the spirit and scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5B"}]},"DETDESC":[{},{}]}
