---
title: Reader/writer lock with reduced cache contention
abstract: A scalable locking system is described herein that allows processors to access shared data with reduced cache contention to increase parallelism and scalability. The system provides a reader/writer lock implementation that uses randomization and spends extra space to spread possible contention over multiple cache lines. The system avoids updates to a single shared location in acquiring/releasing a read lock by spreading the lock count over multiple sub-counts in multiple cache lines, and hashing thread identifiers to those cache lines. Carefully crafted invariants allow the use of partially lock-free code in the common path of acquisition and release of a read lock. A careful protocol allows the system to reuse space allocated for a read lock for subsequent locking to avoid frequent reallocating of read lock data structures. The system also provides fairness for write-locking threads and uses object pooling techniques to make reduce costs associated with the lock data structures.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08145817&OS=08145817&RS=08145817
owner: Microsoft Corporation
number: 08145817
owner_city: Redmond
owner_country: US
publication_date: 20090428
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["In multi-threaded programs running on multiprocessors, different threads may attempt to access shared data structures concurrently. Such access is generally coordinated via some form of locking: all threads acquire a lock before accessing the data structure (and hold the lock for the duration of the access). The simplest form of locking is mutual exclusion\u2014only one thread at a time can hold the lock, so only a single thread is accessing the data structure at a time. However, in many cases one can classify the operations performed on the data structure as readers and\/or writers; reader operations only read the data structure, but writer operations may update it. Several reader operations may safely run concurrently, but only one writer operation may safely run at a time. Therefore, it is useful to reflect this in the locking primitives, and the concurrent programming literature has long had the concept of reader\/writer locks. Such a lock can either be acquired in read (or shared) mode, or write (or exclusive) mode\u2014several threads may acquire the lock in read mode, but only one thread may acquire the lock in write mode. Thus, a reader\/writer lock can protect a shared data structure, and when operations on the data structure have been classified as reader or writer operations, they can acquire the lock in the corresponding mode. For many shared data structures, it is common for reader operations to be much more frequent than writer operations, so that reader\/writer locks allow significantly greater parallel scalability.","It is common for computers today to have many more processing cores than computers of just a few years ago. Where once computers with more than 2-4 cores were only found in database servers or supercomputers, even desktop computer systems can be ordered today with eight or more processor cores. The increased number of processors increases the sharing of resources such as memory, and exacerbates inefficient use of such resources, including cache faults caused by multiple processors modifying the same data.","Unfortunately, the most common implementations or reader\/writer locks include a single variable that tracks the number of readers, and sometimes a separate variable that tracks writers. With many readers executing code on different processors, the reader\/writer lock itself can quickly become a source of cache contention. For example, one common strategy in reader\/writer lock implementations is to maintain a variable representing the number of threads that have acquired the lock in read mode, updating this count variable with atomic hardware instructions. This causes cache contention, as each processor that updates the count acquires the cache line containing the count variable in exclusive mode. As the number of processors in a machine increases, contention on even one cache line can severely limit performance. The impact of contention is determined partly by the rate at which processors access the contended cache line. If N processors each execute a loop in which they acquire a read lock to execute a read operation, the rate at which the read lock is acquired, and thus the shared cache line is accessed, will depend on the duration of the operation executed within the lock\u2014the shorter the operation, the greater the contention. Thus, whereas for exclusive locks software developers generally increase parallelism by doing less inside locks, for reader\/writer locks developers often receive paradoxical guidance, recommending increases in parallelism by doing more inside locks.","A scalable locking system is described herein that allows processors in a multiprocessor system to access shared data with reduced cache contention to increase scalability. The system provides a reader\/writer lock implementation that reduces contention in scenarios in which a shared data structure is accessed in a read-only manner. The scalable lock system uses randomization and spends extra space to spread possible contention over multiple cache lines. Instead of a single variable for tracking the number of readers, the system uses multiple lock counts spread over multiple cache lines. Carefully crafted invariants allow the use of partially lock-free code in the common path of acquisition and release of a read lock. A careful protocol allows the system to reuse space allocated for a read lock for subsequent locking to avoid frequent reallocating of read lock data structures. The system avoids updates to a single shared location in acquiring\/releasing a read lock by spreading the lock count over multiple sub-counts in multiple cache lines, and hashing thread identifiers to those cache lines. The system also provides fairness for write-locking threads: a thread wishing to acquire a write lock cannot be \u201cstarved\u201d for arbitrary periods by read-locking threads. In addition, the system uses object pooling techniques to make the space\/allocation\/initialization costs associated with the lock data structures acceptable. Thus, the system provides a more highly scalable reader\/writer lock, particularly for the level of parallelism provided by modern multi-processor computer systems.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","A scalable locking system is described herein that allows many processors in a multiprocessor system to access shared data with reduced cache contention to increase scalability. The system provides a reader\/writer lock implementation that reduces contention in scenarios in which a shared data structure is accessed in a read-only manner (or nearly so). Using the techniques described herein, frequent reader operations performed on a shared data structure by multiple threads receive increased scalability, without requiring programmers to worry about the size of the operations. The scalable lock system uses randomization and spends extra space to spread possible contention over multiple cache lines. Instead of a single variable for tracking the number of readers, the system uses multiple lock counts spread over multiple cache lines. For example, the system may use a lock count per processor or other dividing scheme. Carefully crafted invariants allow the use of partially lock-free code in the common path of acquisition and release of a read lock. A careful protocol allows the system to reuse space allocated for a read lock for subsequent locking to avoid frequent reallocating of read lock data structures. For example, the system may optimistically assume that the next request will be a read lock request after the last read lock has been released.","The system has the following attributes, in some embodiments. First, the system avoids updates to a single shared location in acquiring\/releasing a read lock by spreading the lock count over multiple sub-counts in multiple cache lines, and hashing thread identifiers to those cache lines. Second, the system provides fairness for write-locking threads: a thread wishing to acquire a write lock cannot be \u201cstarved\u201d for arbitrary periods by read-locking threads. The system does this by providing a locking protocol through which a write-locking thread can prevent further read-lock acquisition, thus inserting itself \u201cin line\u201d to acquire the write lock when the current read-lock holders release the lock. Third, the system uses object pooling techniques to make the space\/allocation\/initialization costs associated with the lock data structures acceptable. Thus, the system provides a more highly scalable reader\/writer lock, particularly for the level of parallelism provided by modern multi-processor computer systems.","The system implements the reader\/writer lock as a queue of \u201cnodes,\u201d each representing the interest in one or more threads in acquiring the lock. A \u201cwriter\u201d node represents one thread attempting to acquire the lock in write (exclusive) mode, a \u201creader\u201d node one or more threads attempting to acquire the lock in read (shared) mode. The lock object contains pointers to the head and tail of this queue, and the nodes contain pointers to the next node in the queue. The thread or threads at the head of the queue currently hold the lock; new nodes are inserted after the current tail.","The major difference with previous work is in the representation of a reader node. Let N be a number equal to (or proportional to) the number of processors on the machine. A reader node contains an array of size N, each of whose elements is initialized to point to a structure containing a lock count. This structure is lockable and contains sufficient padding bytes to ensure that multiple such structures allocated sequentially have lock and count fields on different cache lines. Abstractly, the read lock is held if the head node of the queue is a reader node, and the sum of the count fields of the structures within the reader node is non-zero. To obtain the read lock, a thread uses its hash code to choose a structure from the array, and obtains the lock on that object. It then checks the \u201cnext\u201d field of the reader node\u2014if this is non-null, then another thread wishes to obtain a write lock, and the reader thread enqueues after that writer. However, if it is null, then the thread can acquire the read lock by incrementing the count field of the chosen structure.","When a write locking thread successfully enqueues a writer node after a reader node, it has closed off further read locking via that node. It also counts the number of non-zero counts in the structures in the array, and waits for its node to become the head. The last reader thread, the one that decreases the aggregate lock count to zero, wakes up the waiting writer thread.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["100","110","120","130","140","150","160"]},"The interface component  provides an interface to application code and receives requests to acquire and release locks in both a read mode and a write mode. The interface component  may provide a programmatic interface to applications through Microsoft .NET, the Microsoft Component Object Model (COM), or other common interface paradigms. The interface component  provides a class or other interface with one or more functions or application programming interfaces (APIs) that an application can invoke to use the facilities of the system  described herein.","The queue component  maintains a list of reader and writer nodes that represent requests to acquire a lock and any current holder of the lock. For example, the head of the list may currently hold the lock and each subsequent node in the list may represent a next in line request to receive the lock when the current holder of the lock releases the lock. Because the scalable lock system  uses a queue-based locking approach, the system  provides a lock that is inherently fair. Fairness in locking terminology means that one type of request (e.g., readers) will not starve or prevent another type of request (e.g., writers) from acquiring the lock. The queue component  ensures that requestors will acquire the lock in roughly the order that they request the lock. The queue component  also responds to requests within the system  to inspect the current head or tail of the list, add new reader or writer nodes to the list (e.g., upon a new acquire request), remove nodes from the list (e.g., upon a release request), and so forth.","The reader state component  maintains an indexed list of reader lock counts for one or more reader nodes in the list maintained by the queue component . The indexed list is structured so that lock counts are distributed with enough space (e.g., padding) between each count so that accessing a lock count at one index location is associated with a different cache line than accessing a lock count at any other index location. This prevents cache contention when, for example, a thread running on one processor modifies a lock count because of acquiring or releasing a read lock. The reader state component  may distribute the lock counts according to many different schemes, such as by creating one lock count per processor, creating a number of lock counts based on a number of threads using the lock, or other variations that appropriately reduce cache contention for a particular application of the scalable lock system .","The blocking component  allows threads to block waiting for the lock efficiently and wakes threads when a particular thread has acquired the lock. The blocking component  may provide some amount of spinning (e.g., testing a lock value in a loop to optimistically acquire the lock without blocking) before putting a thread to sleep to be woken when the lock is available. Too much spinning can waste processor resources, while too little spinning can lead to unnecessary delay in acquiring the lock. The block component  may allow applications or administrators to tune the amount of spinning, such as by setting a threshold number of spin loop iterations. When the lock is released by a current lock holder, the blocking component  wakes a thread of the next node in the list maintained by the queue component , indicating that the thread has the lock.","The queue lock component  is a lock that protects internal data members of the system . The queue lock component  may be a single lock or may include several layers of granularity of locks within the data structures of the system . For example, a main lock data structure may have a lock for protecting its data members along with individual data structures associated with indices within the indexed list maintained by the reader state component . The system  avoids locking internal members, particular in common code paths that are designed to reduce cache contention and promote a high degree of parallelism. However, in some cases internal locking maintains the integrity of lock data members potentially being accessed by many threads at once.","The node allocation component  allocates new reader and writer nodes for inclusion on the list maintained by the queue component . The node allocation component  may implement common techniques in the art to provide efficient creation and destruction of nodes. For example, the component  may provide an object pool of reader and\/or writer nodes that other components can quickly reuse as the system  receives new lock requests.","The computing device on which the scalable locking system is implemented may include a central processing unit, memory, input devices (e.g., keyboard and pointing devices), output devices (e.g., display devices), and storage devices (e.g., disk drives or other non-volatile storage media). The memory and storage devices are computer-readable storage media that may be encoded with computer-executable instructions (e.g., software) that implement or enable the system. In addition, the data structures and message structures may be stored or transmitted via a data transmission medium, such as a signal on a communication link. Various communication links may be used, such as the Internet, a local area network, a wide area network, a point-to-point dial-up connection, a cell phone network, and so on.","Note that as used herein, the term processor refers to a particular execution unit, typically with an associated cache. Modern trends are moving toward including many processor cores on a single processor chip. Each of these cores represents a processor as described herein, and the scalable lock system may provide a lock count associated with each processor core. Thus, when referencing situations with multiple processors herein, these situations include a single processor chip with multiple cores, multiple processor chips (each potentially having multiple processor cores), and so forth. In addition, other processing units such as a graphical processing unit (GPU) having one or more cores or operating in conjunction with a central processing unit (CPU) may be used with the facilities of the system described herein to provide reduced contention locking of data.","Embodiments of the system may be implemented in various operating environments that include personal computers, server computers, handheld or laptop devices, multiprocessor systems, microprocessor-based systems, programmable consumer electronics, digital cameras, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and so on. The computer systems may be cell phones, personal digital assistants, smart phones, personal computers, programmable consumer electronics, digital cameras, and so on.","The system may be described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, and so on that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2","b":["210","220","230","240","240","250","260","250","260","260","270","260","240","270","280","290","280"]},"The diagram also shows that in a read-only workload, the queue will include only a single reader node. Threads will add themselves as read lockers by choosing an index into the array of indexed counts, and then increment the lock count of the chosen element. If the number of elements is on the order the number of processors on the machine, and the threads spread the accesses equally over the array elements, contention will be rare (and can be controlled by controlling the ratio of array size to number of processors). The total number of read lockers is the sum of the lock counts of all the indexed counts. When this is non-zero for a reader node at the head of the queue, the lock is held in read mode by at least one thread.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3","b":["310","320","330","340","360"]},"Continuing in block  for a reader node, the system attempts to increment a reader count, as described further with reference to . For example, the system may acquire a queue lock and attempt to re-access the queue to update an indexed lock count. Continuing in decision block , if the attempt to increment the reader count failed, then the system loops to block  to try again, else the system continues at block . The increment attempt may fail, for example, if the system receives a request from a writer to acquire the lock before the reader can acquire the lock.","Continuing in block  for a writer node, the system locks the queue so that the system can safely read and update data members associated with the queue. For example, the system may use a data structure lock provided by the programming language (e.g., a Microsoft .NET monitor lock) or other lock for protecting internal data members of the read\/write lock. Continuing in block , the system adds a new reader node representing the current request to acquire a read lock to the tail of the queue. For example, the system may create the new reader node by allocating it or by removing it from an object pool. Continuing in block , the system unlocks the queue so that other waiting threads can modify the queue. For example, the system may drop the lock acquired in block , or if using a monitor lock may simply exit the scope in which the lock was acquired.","Continuing in block , the system waits for the reader node to become the head of the queue. For example, the system may wait by spinning and if spinning fails to acquire the lock in a threshold period or number of loop iterations, the system may block waiting for a prior lock holder to awaken the thread when the prior lock holder releases the lock. The reader node becomes the head of the queue when all prior nodes in the queue complete acquiring and subsequently releasing the lock. After block , these steps conclude.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4","b":"410"},"Continuing in block , the system locks the queue so that the system can safely read and update data members associated with the queue. Unlike many previous read\/write locks, locking the queue of the present system includes locking one of multiple lock counts to read (i.e., not a single shared lock count) and locking each of the counts to write. In this way, the same \u201cdistribution index\u201d determines the lock that is acquired that determines which sub-counter the system increments. Distributing the lock obtained reduces cache contention among multiple logical processors. Continuing in decision block , if there is a writer node subsequent to the current reader node, then the system continues at block , else the system continues at block . A subsequent writer node indicates that the system has received a request to acquire the write lock. To ensure that readers do not starve writer requests (i.e., fairness), the system prevents further reader requests on the same reader node, and fails the request to increment the count. Continuing in block , the system sets the result of the reader increment operation to failed, and then continues in block .","Turning to block , the system increments the indexed reader count based on the determined distribution index. The indexed reader count is in a cache line isolated from other reader counts (as is the lock that protects the reader count) to reduce cache contention produced by the act of updating the reader count. Otherwise, the next time another processor read or attempted to update the reader count, the processor would experience a cache fault to load the change made by the current processor. By distributing the reader counts, the system trades space to reduce contention and increase execution efficiency. Continuing in block , the system unlocks the queue so that other waiting threads can modify the queue. After block , these steps conclude.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 5","b":["510","520"]},"Continuing in block , the system locks the queue so that the system can safely read and update data members associated with the queue. Continuing in block , the system inspects the queue of waiting reader and writer nodes to identify the current queue tail. For example, the system may access a tail pointer of a main lock data structure and dereference the pointer to access a node data structure at the tail of the queue. Continuing in decision block , if the tail node of the queue is a reader node, then the system continues at block , else the system jumps to block . Continuing in block , the system checks a count of readers at each of multiple indices within the reader node at the tail of the queue. Because of the way the system distributes lock requests received from readers to lock count variables in multiple cache lines to reduce cache contention, the total of the lock count variables indicates the actual number of readers. To obtain the write lock, the thread acquiring the lock locks all of the locks protecting the read counts in order to install itself as the reader node's successor in the queue. Continuing in decision block , if any readers hold the lock, then the system continues at block , else the system continues at block . If any of the index counts is non-zero, then at least one reader holds the lock.","Continuing in block , the system sets a countdown associated with the reader node to a number of remaining non-zero read counts associated with the reader node holding the lock. Turning to block , if the test of block  found no remaining readers holding the lock, then the system removes the reader node from the queue. The system may leave a reader node on the queue even though no readers currently hold the lock for the optimistic case that a next request is a request to acquire a read lock, in which case the existing reader node structure can be used without the added cost of tearing it down at the previous release and setting it back up at the next acquire request. When the next request is a write request, the system may remove the reader node at that time.","Continuing in block , the system adds the new writer node representing the current request to acquire a write lock to the tail of the queue. Continuing in block , the system unlocks the queue so that other waiting threads can modify the queue. For example, the system may drop the lock acquired in block , or if using a monitor lock may simply exit the scope in which the lock was acquired to release the lock implicitly. Continuing in block , the system waits for the new writer node to become the head of the queue. For example, the system may wait by spinning and if spinning fails to acquire the lock in a threshold period or number of loop iterations, the system may block waiting for a prior lock holder to awaken the thread when the prior lock holder releases the lock. The writer node becomes the head of the queue when all prior nodes in the queue complete acquiring and subsequently releasing the lock. After block , these steps conclude.",{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 6","b":"610"},"Continuing in decision block , if the release request is for a writer node, then the system jumps to block , else the system continues at block . The system may distinguish a read lock release from a write lock release, for example, by providing separate functions for each of these two operations. Alternatively or additionally, the system may determine the appropriate type of release based on the type of node currently at the head of the queue (and thus currently holding the lock).","Continuing in block  for a reader node, the system decrements a reader count, as described further with reference to . For example, the system may acquire a queue lock and attempt to update an indexed lock count as described further herein. Continuing in decision block , if decrementing the reader count released the last reader associated with the reader node, then the system continues at block , else the system completes. As described further herein, a single reader node may represent many readers, and can be released only when each of the associated readers have released the lock. Continuing in block , the system releases the next waiting node in the queue subsequent to the current node. For example, the system may modify a variable that spinning waiting nodes will notice on the next loop iteration, or the system may call an operating system provided function to wake threads that went to sleep blocking for the lock to be available. Releasing the next waiting node may include removing the head node and make the waiting node, if any, the new head of the queue. The next waiting node is waiting for the condition of becoming the head of the queue to determine that the node's associated thread(s) hold the lock. The queue head value is the variable that spinning waiting nodes test to determine the lock status.","Continuing in block , the system deletes the current node that has been released. For example, the system may deallocate the node or return the node to a pool of nodes for later reuse. Object allocation and deallocation is often performance intensive, and particularly where objects are frequently created and destroyed can represent a large part of an application's overhead. Thus, using an object pool in conjunction with the system allows objects to be quickly reused, avoiding unnecessary setup and teardown of the objects. After block , these steps conclude.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 7","b":["710","720","720"]},"Continuing in block , the system decrements the indexed reader count based on the determined distribution index. The indexed reader count is in a cache line isolated from other reader counts to reduce cache contention produced by the act of updating the reader count. Continuing in decision block , if the decrement made the indexed reader count zero, then the system continues at block , else the system jumps to block . Continuing in decision block , if there is a writer node subsequent to the current reader node, then the system continues at block , else the system jumps to block . A subsequent writer node indicates that the system has received a request to acquire the write lock. To ensure that readers do not starve writer requests (i.e., fairness), the system prevents further reader requests on the same reader node. When the existing reader requests are finally released, the system may then wake the waiting writer.","Continuing in block , the system decrements a countdown of remaining readers associated with the reader node. Continuing in decision block , if the decrement made the countdown of remaining readers zero, then the system continues at block , else the system jumps to block . Continuing in block , the system sets information indicating that the last reader associated with the reader node has released the lock. The code that invoked these steps uses this information to wake any waiting subsequent node in the queue. Continuing in block , the system unlocks the queue so that other waiting threads can modify the queue. The system may also remove the head of the queue to allow the next node to become the head, and thus acquire the lock. After block , these steps conclude.","In some embodiments, the scalable lock system leaves the last reader node at the head of the queue after each reader represented by the node has released the lock. Reader node structures can be resource intensive to create and teardown, so if the last read lock is released with no pending write-lock requests, the system leaves the reader node in place at the head of the queue, ready to handle the next read-lock request.","In some embodiments, the scalable lock system provides writer and\/or reader fairness. Writer fairness refers to the ability of a writer to obtain the lock even though readers continue to request the lock while some readers already hold the lock. Reader fairness refers to the ability of a reader to obtain the lock when a writer holds the lock and subsequent writers are waiting to acquire the lock. The system prevents any lock acquisition request from blocking indefinitely. The system may allow some amount of unfairness to increase throughput, but only a bounded amount\u2014the system assures a waiting request of eventually acquire the lock.","In some embodiments, the scalable lock system provides lock upgradeability. A common feature of existing reader\/writer locks is the ability to acquire a lock in an upgradeable mode\u2014as a read lock that may optionally later be upgraded to a write lock, either through an additional interface function or by calling a function for acquiring a write lock on a thread that already has a read lock. Only one thread may hold the lock in upgradeable mode at a time (though other threads may hold the lock in read mode at the same time). To upgrade a lock, the system drains off any existing other readers to allow the current thread to upgrade to a write lock, potentially in advance of other write requests enqueued after the initial read request of the thread requesting the lock upgrade.","In some embodiments, the scalable lock system allows applications or administrators to configure the size and\/or number of lock count indexes to make tradeoffs between space efficiency and the level of cache contention reduced by the system. In addition, the application may have information about the cache configuration of the system, for example, that makes a particular configuration of lock count indices more efficient.","In some embodiments, the scalable lock system dynamically determines whether to use the techniques described herein versus other available locking techniques. For example, the space used for the padding described herein may be high enough to warrant choosing a simple critical section for a sufficiently low number of processors. Thus, if the system observes that the number of processors or other attributes of the environment in which the system is used do not meet a threshold, the system may select other locking techniques that provide similar lock guarantees with more favorable performance tradeoffs. In addition, the system may perform steps to reduce memory space consumed by the lock system and minimize padding (which is often large to push read counts into separate cache lines). The system may, for example, allow multiple reader nodes on the queue to share a data structure of read lock counts. Each reader node may get a separate index in the counts to keep the data of the reader nodes separate, but each reader node would not involve a new set of padding between counts, as the same padding would serve the purpose of keeping the counts in separate cache lines.","Example Implementation","The following paragraphs present an example implementation of the system described herein. The following class illustrates a typical interface for a reader-writer lock.",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class RWLock {"]},{"entry":[{},"\u2003public RWLock( );"]},{"entry":[{},"\u2003public ReadAcquire( );"]},{"entry":[{},"\u2003public ReadRelease( );"]},{"entry":[{},"\u2003public WriteAcquire( );"]},{"entry":[{},"\u2003public WriteRelease( );"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Code examples given herein use the C# programming language. However, those of ordinary skill in the art will recognize that similar techniques can be performed using various other programming languages to implement the system. In the interface above, the acquire operations block until the lock is obtained in the requested mode. The release operations do not block. This example assumes that applications properly match acquires with releases of the appropriate (read\/write) lock. Implementations of this interface may provide debugging aids to detect incorrect use of this interface, but such aids are outside the scope of this example.","The basic lock data structure is queue-based. The queue is a linked list of AccessNode objects, connected via an m_next field of that type. Each AccessNode is either a WriterNode or a ReadersNode. A WriterNode represents one thread attempting to acquire the lock in write mode, and a ReadersNode represents a set of one or more threads attempting to acquire the lock in read mode. As shown in the following code, the RWLock type maintains pointers to the head and tail of the queue. In response to new requests, the RWLock adds nodes at the tail, and the thread(s) associated with the node at the head hold the lock in the mode indicated by the type of the node.",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class RWLock {"]},{"entry":[{},"\u2003..."]},{"entry":[{},"\u2003private AccessNode m_qHead;"]},{"entry":[{},"\u2003private AccessNode m_qTail;"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A WriterNode adds no new fields or methods to AccessNode. A ReadersNode, however, has a structure shown in the following code.",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"const int CacheLineBytes = 64;"]},{"entry":[{},"..."]},{"entry":[{},"[StructLayout(LayoutKind.Sequential)]"]},{"entry":[{},"private struct ReadLockElemStruct {"]},{"entry":[{},"\u2003public int m_lockCount;"]},{"entry":[{},"\u2003\/\/ Pad with enough bytes to avoid false sharing."]},{"entry":[{},"\u2003private fixed byte"]},{"entry":[{},"\u2003\u2003m_paddingAfter[CacheLineBytes \u2212 sizeof(int)];"]},{"entry":[{},"}"]},{"entry":[{},"private class ReadLockElem {"]},{"entry":[{},"\u2003public ReadLockElemStruct m_s;"]},{"entry":[{},"}"]},{"entry":[{},"private class ReadersNode: AccessNode {"]},{"entry":[{},"\u2003private ReadLockElem[ ] m_arr;"]},{"entry":[{},"\u2003private int m_countDown;"]},{"entry":[{},"\u2003public int m_idx;"]},{"entry":[{},"\u2003..."]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"This code utilizes several features of C# and .NET that may not be familiar. The notation \u201c[StructLayout(LayoutKind.Sequential)]\u201d indicates that the struct type being defined has its fields laid out in the order indicated. Without this constraint, the runtime system is free to lay out fields in any order. The \u201cfixed\u201d notation indicates an array laid out \u201cinline\u201d in the struct. The result is a struct with one int field, then enough padding bytes to fill out a cache line. Although 64 bytes is shown as the size of the cache line in the example code, this size may vary by implementation and processor hardware used. In C# and Microsoft .NET, objects (e.g., instances of class types) contain implicit monitor locks, but struct types do not. This example assumes lockable instances of this struct type, so the ReadLockElem class is created, which has one field of this struct type. In the common case, .NET monitor locking is accomplished with reads and writes to a \u201cheader word\u201d at the start of an object. This example relies on one more feature of the Microsoft .NET implementation: if a single thread allocates several ReadLockElem instances consecutively, they are likely to be allocated contiguously in memory (and if they are not, they are highly likely to be allocated as only two contiguous sequences, with a somewhat random gap between). The ReadersNode type contains an array of ReadLockElem instances initialized with consecutively allocated instances. In each of these structures, the functions described herein are likely to access the object header word and the m_lockCount field, but the padding bytes ensure that in a contiguous sequence of ReadLockElem instances, these words will be on different cache lines for each object. The functions of the m_countDown and m_idx fields will be explained further herein.","The example implementation obeys the following rules to manage concurrency. First, a thread can only modify the m_qHead and m_qTail fields of an instance of the RWLock class when it holds the monitor lock on that instance. Second, the m_lockCount field of a ReadLockElem instance can only be accessed by a thread that holds the monitor lock on that instance. Third, the m_next field of an AccessNode is null when the node is allocated, and makes a single transition to a non-null value in its lifetime. This transition is only performed by threads that hold the monitor lock on the top-level RWLock. In addition, for a given ReadersNode instance the system ensures that the thread causing this transition hold the monitor locks on all the ReadLockElem instances pointed to by the m_arr member of the given instance. Finally, the m_countDown member of a ReadersNode instance is zero when the object is allocated. After that, m_countDown may make a single transition from zero to a non-zero value; as with the m_next field's null-to-non-null transition, only a thread that holds the locks on all the ReadLockElems of the instance performs the transition. After the transition to a non-zero value, threads may decrement the value back towards zero. The system uses atomic hardware instructions (in a loop) for these decrements. The use of these rules to justify concurrency safety is pointed out further herein.","The first method described is ReadAcquire. Following is example code for implementing this method as discussed further herein.",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public void ReadAcquire( ) {"]},{"entry":[{},"\u2003Thread curThrd = Thread.Current;"]},{"entry":[{},"\u2003while (true) {"]},{"entry":[{},"\u2003\u2003AccessNode an = m_qTail;"]},{"entry":[{},"\u2003\u2003if (an != null && an is ReadersNode) {"]},{"entry":[{},"\u2003\u2003\u2003ReadersNode rn = (ReadersNode)an;"]},{"entry":[{},"\u2003\u2003\u2003if (!rn.IncLockCountForThread(curThrd))"]},{"entry":[{},"\u2003\u2003\u2003\u2003continue;"]},{"entry":[{},"\u2003\u2003\u2003WaitUntilHead(rn);"]},{"entry":[{},"\u2003\u2003} else {"]},{"entry":[{},"\u2003\u2003\u2003ReadersNode rn = AllocReadersNode( );"]},{"entry":[{},"\u2003\u2003\u2003rn.IncLockCountForThread(curThrd);"]},{"entry":[{},"\u2003\u2003\u2003lock (this) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003an = m_qTail;"]},{"entry":[{},"\u2003\u2003\u2003\u2003if (an == null) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003m_qHead = m_qTail = rn; return;"]},{"entry":[{},"\u2003\u2003\u2003\u2003} else if (an is ReadersNode) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003rn.DecLockCountForThread(curThrd);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003DeallocReadersNode(rn);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003continue; \/\/ try again."]},{"entry":[{},"\u2003\u2003\u2003\u2003} else { \/\/ an is a writer node."]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003an.m_next = rn;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003m_qTail = rn;"]},{"entry":[{},"\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003WaitUntilHead(rn);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003return;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"As shown, acquiring the read lock includes a loop, since lock-free techniques may include retrying several times. In the loop, the function reads (with no locking) the current queue tail. If the tail is a non-null ReadersNode, the current thread will attempt to increment the lock count for its element. The danger of using the \u201cdirty read\u201d is that the node may be deleted from the queue between that read and the operations done on the node. The IncLockCountForThread operation handles that situation, as will be discussed, and returns a Boolean value indicating whether the increment was successful. If the return value is false, the ReadersNode was closed to further read locking by a subsequent write-locking thread. In this case, the function retries the loop. If the increment operation is successful, then the thread waits for the tail node in which it incremented a lock count to become the head node of the queue (the WaitUntilHead operation is described in more detail below).","If the observed tail node of the queue is not a ReadersNode, then the function allocates a new readers node to append to the queue. This node will have null m_next, zero m_countDown, and an m_arr field initialized to an array containing pointers to (contiguously allocated) ReadLockElem instances with lock count zero. No thread on the new node or its sub-objects will hold any monitor locks. The system increments the lock count for the current thread in this ReadersNode\u2014with no locking, since the newly allocated node is still thread-local. Next, the function locks the RWLock, since it is going to modify the queue structure. The function then reads the m_qTail field while holding the lock. If result is null, the queue is empty, so the function creates a one-element queue. The new ReadersNode is at the head of the queue, so the operation can return, since the current thread has acquired a read lock. Otherwise, if the locked read of the tail determines the tail now to be a ReadersNode, the function undoes the lock count increment, deallocates the node (the system may use an \u201cobject pool\u201d to speed allocation of ReadersNode instances), and re-executes the loop. Finally, if the observed head is non-null and is not a ReadersNode, it is a WriterNode, so the function sets the m_next field of that tail node to the new ReadersNode (recall that the m_next field of a WriterNode may be modified while holding the lock on the entire RWLock, which is true at this point), and updates m_qTail (which is also justified by the lock statement on the RWLock).","Following are example implementations of the IncLockCountForThread and WaitUntilHead helper functions used in the discussion above.",{"@attributes":{"id":"p-0069","num":"0068"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Helper functions"]},{"entry":[{},"public bool IncLockCountForThread(Thread t) {"]},{"entry":[{},"\u2003int id = t.GetHashCode( );"]},{"entry":[{},"\u2003int ind = id % NProcs;"]},{"entry":[{},"\u2003ReadLockElem rle = m_arr[ind];"]},{"entry":[{},"\u2003lock (rle) {"]},{"entry":[{},"\u2003\u2003\/\/ If we have a waiting writer, can't increment."]},{"entry":[{},"\u2003\u2003if (m_next != null) return false;"]},{"entry":[{},"\u2003\u2003\/\/ Otherwise..."]},{"entry":[{},"\u2003\u2003rle.m_s.m_lockCount++"]},{"entry":[{},"\u2003\u2003return true;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"private void WaitUntilHead(AccessNode an) {"]},{"entry":[{},"\u2003for (int k = 0; k < SpinCount; k++) {"]},{"entry":[{},"\u2003\u2003if (an == m_qHead) return;"]},{"entry":[{},"\u2003\u2003Spin(1);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003lock (an) {"]},{"entry":[{},"\u2003\u2003while (an != m_qHead) {"]},{"entry":[{},"\u2003\u2003\u2003Monitor.Wait(an);"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"IncLockCountForThread starts by obtaining the locking thread's hash code, which is distributed evenly over the 32-bit integers, and using a modulus operation to get an index in the interval [0::NProc), where NProc is the size of a ReadersNode instance's array of ReadLockElem structures. The function then reads the given array element, obtaining the proper ReadLockElem instance for the locking thread. The function locks this ReadLockElem instance and checks whether the ReadersNode instance's m_next field is non-null. If the m_next field is non-null, then a subsequent WriterNode already enqueued, and the current ReadersNode is closed to further read locking; the function returns false to indicate this condition. Otherwise, m_next is null, and will remain so while the lock is held (relying on the rule that all such locks are acquired in order to change the m next field of a ReadersNode). The function can therefore increment m_lockCount to increase the total number of read-locking threads (access to m_lockCount is justified by holding the lock on the containing ReadLockElem), and return true to indicate success.","The WaitUntilHead function starts with some amount of spin waiting. This loop will perform some number of iterations, each of which will perform a dirty (unlocked) read of the RWLock's m_qHead field, and test whether the current thread's node is at the head. If so the function returns; if not, the function calls Spin to do some amount of busy work, and ends the loop. Performing the dirty read of m_qHead helps performance: if a lock were forced to observe this, the locking would create a contended cache line. Fortunately, it is safe to do the dirty read here, since the predicate we are waiting to observe is \u201cstable for current thread:\u201d if it becomes true, it can only be falsified by an action of the current thread. In this case, if the current thread's AccessNode becomes the head of the queue, then it will remain at the head of the queue at least until the current thread releases its lock.","With proper tuning of the SpinCount parameter and the amount of busy work done in the Spin routine, the function can acquire many locks without blocking. Of course, spinning too much can lead to excessive wasted work, especially when there are more runnable threads than processors. These tradeoffs are standards with locks that balance spin waiting and blocking, and are familiar to those of ordinary skill in the art. When spin waiting fails, the function starts a standard monitor wait loop. The function locks the current thread's AccessNode, and then enters a loop that waits for the AccessNode to become the queue head. Again, the read here of m_qHead is dirty, as before, but is justified by the same observation. The Monitor.Wait(an) operation releases the monitor lock on the AccessNode and waits for some other thread to do a Pulse or PulseAll operation on the AccessNode (the Microsoft .NET platform calls this Pulse; other platforms use the name Notify). The system is careful that all operations that change the queue head perform this wakeup operation.","We next describe the method for acquiring a write lock; considering the operations in this order will make certain aspects of releasing a read lock clearer. The following code illustrates one implementation of a function for acquiring the write lock.",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public void WriteAcquire( ) {"]},{"entry":[{},"\u2003WriterNode wn = new WriterNode( );"]},{"entry":[{},"\u2003lock (this) {"]},{"entry":[{},"\u2003\u2003AccessNode an = m_qTail;"]},{"entry":[{},"\u2003\u2003if (an == null) {"]},{"entry":[{},"\u2003\u2003\u2003m_qHead = m_qTail = wn; return;"]},{"entry":[{},"\u2003\u2003} else if (an is WriterNode) {"]},{"entry":[{},"\u2003\u2003\u2003an.m_next = wn;"]},{"entry":[{},"\u2003\u2003\u2003m_qTail = wn;"]},{"entry":[{},"\u2003\u2003} else {"]},{"entry":[{},"\u2003\u2003\u2003ReadersNode rn = (ReadersNode)an;"]},{"entry":[{},"\u2003\u2003\u2003if (rn.InstallWriterSuccessor(wn)) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003m_qHead = m_qTail = wn;"]},{"entry":[{},"\u2003\u2003\u2003\u2003DeallocReadersNode(rn);"]},{"entry":[{},"\u2003\u2003\u2003\u2003return;"]},{"entry":[{},"\u2003\u2003\u2003} else {"]},{"entry":[{},"\u2003\u2003\u2003\u2003m_qTail = wn;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003WaitUntilHead(wn);"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The function first allocates a new WriterNode. In contrast with ReadAcquire, WriteAcquire immediately locks the RWLock and reads the queue tail. If the queue tail is null, the function sets up a single-node queue and returns, indicating that the current thread owns the write lock. Otherwise, if the non-null tail node is a WriterNode, the function makes the new WriterNode the new tail, and falls through to release the lock on the RWLock and waits until the new WriterNode is the queue head. If these tests fail, then the tail node is a ReadersNode. In this case, the function calls InstallWriterSuccessor to close the ReadersNode to further read locking, make the argument node WriterNode the successor of the ReadersNode, and return a Boolean value indicating whether the total lock count of the ReadersNode was zero. This can only be true if the ReadersNode is at the head of the queue: in ReadAcquire every ReadersNode has a total lock count greater than zero when it becomes part of the queue, and the total lock count is only decremented by lock releases, which happen only after acquires return, which happens only when the corresponding node becomes the queue head. Therefore, if InstallWriterSuccessor returns true, WriteAcquire can create a single-node queue, deallocate the former queue head, and return immediately indicating that the current thread has acquired the lock in write mode. Otherwise, if InstallWriterSuccessor returns false, WriteAcquire completes the queue append by making the WriterNode the new tail of the queue, and again falls through to release the lock and wait for the WriterNode to become the queue head.","Following is an example implementation of the InstallWriterSuccessor helper function of the ReadersNode class used in the discussion above.",{"@attributes":{"id":"p-0077","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public bool InstallWriterSuccessor(WriterNode wn) {"]},{"entry":[{},"\u2003int nonZeroLCs = 0;"]},{"entry":[{},"\u2003for (int i = 0; i < NProcs; i++) {"]},{"entry":[{},"\u2003\u2003Monitor.Enter(m_arr[i]);"]},{"entry":[{},"\u2003\u2003if (m_arr[i].m_s.m_lockCount > 0) nonZeroLCs++;"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003m_countDown = nonZeroLCs;"]},{"entry":[{},"\u2003m_next = wn;"]},{"entry":[{},"\u2003for (int i = 0; i < NProcs; i++) {"]},{"entry":[{},"\u2003\u2003Monitor.Exit(m_arr[i]);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003return (nonZeroLCs == 0);"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"InstallWriterSuccessor initializes a variable (nonZeroLCs) that will count the number of ReadLockElem instances with non-zero lock counts. Next, a loop acquires the monitor locks on all the ReadLockElem instances in the ReadersNode (in ascending index order, which prevents deadlocks if multiple threads execute this method concurrently). After the monitor lock has been acquired, the function reads the lock count (obeying the locking discipline for accessing the lock count), and if it is non-zero, increments the nonZeroLCs variable. When all the locks have been acquired, the function initializes the m_countDown and m_next fields to possibly non-zero and non-null values. Note that this code obeys the locking discipline described for these transitions since all the ReadLockElem monitor locks for the ReadersNode are held. After this, the subsequent loop releases all the ReadLockElem monitor locks (order is irrelevant here), and then the method returns a Boolean indicating whether the number of non-zero lock counts observed was zero.","The following code shows an example implementation of the ReadRelease function for releasing a read lock held by a thread.",{"@attributes":{"id":"p-0080","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public void ReadRelease( ) {"]},{"entry":[{},"\u2003ReadersNode rn = (ReadersNode) m_qHead;"]},{"entry":[{},"\u2003if (rn.DecLockCountForThread(Thread.CurrentThread)) {"]},{"entry":[{},"\u2003\u2003ReleaseHead( );"]},{"entry":[{},"\u2003\u2003DeallocReadersNode(rn);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"public bool DecLockCountForThread(Thread t) {"]},{"entry":[{},"\u2003int id = t.GetHashCode( );"]},{"entry":[{},"\u2003int ind = id % NProcs;"]},{"entry":[{},"\u2003ReadLockElem rle = m_arr[ind];"]},{"entry":[{},"\u2003lock (rle) {"]},{"entry":[{},"\u2003\u2003int lc = (\u2212\u2212rle.m_s.m_lockCount);"]},{"entry":[{},"\u2003\u2003if (lc == 0) {"]},{"entry":[{},"\u2003\u2003\u2003if (m_next != null) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003if (Interlocked.Decrement(ref m_countDown) == 0)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003return true;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003\/\/ Otherwise..."]},{"entry":[{},"\u2003return false;"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The discussion herein has assumed that releases are balanced, so that a thread executing ReadRelease has last executed a successful ReadAcquire operation on the RWLock. Therefore, ReadRelease may assume that the head node of the lock's queue is a ReadersNode whose total lock count includes a contribution from the current thread, and is therefore non-zero. The DecLockCountForThread function finds the array index for the decrementing thread, reads the corresponding ReadLockElem instance, and locks the ReadLockElem. DecLockCountForThread decrements the lock count of the ReadLockElem instance and checks whether the new lock count is zero. If the new lock count is zero, then the function checks whether the ReadersNode has a non-null m_next field. If the m_next field is non-null, then a previous execution of InstallWriterSuccessor has initialized m_next and m_countDown, thus closing this node from further read locking. The return value of the DecLockCountForThread function is true only if the ReadersNode on which it is executed has a WriterNode successor, and its total lock count is now zero, so the successor can become the new queue head. Therefore, the function uses an atomic hardware instruction to decrement m_countDown, and if the post-decrement value returned is zero, the function returns true. Otherwise, the function returns false.","In ReadRelease, if the call to DecLockCountForThread returns true, ReadRelease calls ReleaseHead to remove the head node from the queue. This general method calls PulseAll on the new queue head node, if there is one. Finally, ReadRelease deallocates the removed node (e.g., as part of an object-pooling scheme for ReadersNode instances).","The WriteRelease method is not shown, since it only includes a call to the same ReleaseHead method called by ReadRelease. The details of ReleaseHead impact performance as described further herein. The following code is an example implementation of the ReleaseHead function.",{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"private void ReleaseHead( ) {"]},{"entry":[{},"\u2003AccessNode newHead = m_qHead.m_next;"]},{"entry":[{},"\u2003if (newHead == null) {"]},{"entry":[{},"\u2003\u2003lock (this) {"]},{"entry":[{},"\u2003\u2003\u2003if (m_qTail == m_qHead) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003m_qHead = null; m_qTail = null;"]},{"entry":[{},"\u2003\u2003\u2003\u2003return;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003newHead = m_qHead.m_next;"]},{"entry":[{},"\u2003m_qHead = newHead;"]},{"entry":[{},"\u2003lock (newHead) {"]},{"entry":[{},"\u2003\u2003Monitor.PulseAll(newHead);"]},{"entry":[{},"\u2003}"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Note that only the thread that completes the release of the lock(s) corresponding to the queue head calls ReleaseHead\u2014no other thread can call this method until ReleaseHead changes the queue head. This justifies the unlocked read of m_qHead in ReleaseHead, since only the current thread can change m_qHead. The m_next field of the queue head is also read without locking. By the concurrency rules described herein, if the test of m_next determines that the next pointer is non-null, its value is stable and can be read without locking. If m_next is null, however, m_next may change to a non-null value if another thread enqueues a new node after m_next. Thus, ReleaseHead acquires the monitor lock on the RWLock in this case, which it holds in order to perform this transition by the concurrency control rules. ReleaseHead then performs a \u201cdouble-check\u201d idiom, reading the queue head and tail again while holding the lock to verify that the queue has a single element. If so, then the method resets the queue to the empty state, and the method returns. If this test fails, the queue had more than one element, so the function falls through and releases the lock\u2014when the successor of the head is then read it is guaranteed to be non-null. The function then updates the queue head. Immediately after this write, other threads doing spin waiting may observe that their node is at the head of the queue, and determine that they therefore own the lock. However, the current thread has already identified the newHead queue node whose thread(s) it is responsible for waking if they have blocked, so it pulses those objects.","From the foregoing, it will be appreciated that specific embodiments of the scalable lock system have been described herein for purposes of illustration, but that various modifications may be made without deviating from the spirit and scope of the invention. Accordingly, the invention is not limited except as by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
