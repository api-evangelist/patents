---
title: Method and system for maintaining connections between surfaces and objects in a graphics display system
abstract: A method and system are provided for controlling the algorithmic elements in 3D graphics systems via an improved 3D graphics API and for managing computing resources utilized in connection with the maintenance of connections between surfaces and objects. When multiple applications are running simultaneously, it is possible that the demand for overall computing resources may exceed supply; and it is possible that a connection between a surface and object may be lost for one or more applications. In accordance with the present invention, a check for the persistence of a connection between surface space and object space is made substantially at the time of a present function call, and thus multiple redundant checks are avoided. In one embodiment, checks made incident to function calls other than a present function call are spoofed or bypassed in order to avoid previous inefficient use of computing resources.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06874150&OS=06874150&RS=06874150
owner: Microsoft Corporation
number: 06874150
owner_city: Redmond
owner_country: US
publication_date: 20010301
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS"],"p":["The present invention provides a new and improved software interface as a layer between application developers and the graphics pipeline that renders and processes the graphics data.","For the vast majority of applications, application programmers rely on or utilize some form of software interface to interact with a computer and its associated devices. For graphics applications, developers or programmers typically utilize a graphics software interface, such as a 3D graphics application programming interface (API), to facilitate the interaction with constituent parts of a graphics system. Programmers typically rely on software interfaces to peripherals and devices so that they can focus on the specifics of their application rather than on the specifics of controlling a particular device and so that their efforts are not duplicated from application to application. However, even after generations of software interfaces, there are certain aspects of today's software interfaces that do not provide the level of performance desired and thus can be improved.","There are several reasons why previous generation graphics software interfaces do not meet the needs of today's graphics applications and systems. One type of resource contention issue that sometimes occurs is due to the demands of multiple devices and applications requiring graphics system resources simultaneously. For example, if multiple applications running simultaneously are maintaining connections to multiple surfaces from various objects of the graphics system, sometimes these connections to surfaces can become severed or disconnected. When multiple applications have connections between surfaces and objects, more system resources, such as memory space, are utilized resulting in an increased likelihood of a disconnection. For instance, while a user may generally toggle back and forth between executing applications, if the connection to surface memory for any one application is severed, a user may have to restart the application or begin certain portions of the application again in order to recreate a proper connection. Today's 3D graphics APIs check for severing of connections in a redundant fashion, wasting computing resources, and consequently there is a need for an improved technique for checking for the persistence of connections between object space and surface space.","Another reason why previous generation graphics software interfaces are inadequate is that versioning itself can create problems when each version is not rewritten from scratch, as is often the case. As any software developer has encountered, the subsequent versioning of a software product to meet the ad hoc needs of an evolving operating environment produces a scenario where once separate or merely related modules may be more efficiently placed together, rewritten or merged. A software interface between graphics application developers and rapidly evolving hardware is no less a product. For example, graphics APIs have undergone multiple evolutions to arrive at the current state of the art of graphical software interfacing. In some cases, this in turn has caused current versions of the API code to become unwieldy to developers. For example, the 3D graphics world has grown exponentially in the last decade, while the procedures for 2D applications have largely stayed the same. Initially, there was only an API that helped developers render 2D images, and while at its inception, the API was a revolutionary innovation freeing developers to create games and other 2D graphics applications, the algorithms for the creation, processing and rendering of pixels and polygons in 2D space have been largely static in recent years. On the other hand, the algorithms for the creation, processing and rendering of 3D objects on a 2D display space have grown considerably. While the creation, processing and rendering of 3D objects by a 3D API utilizes algorithms and function calls of the 2D API, a single set of APIs does not exist for the purpose of creating both 2D and 3D objects. There are thus typically multiple choices for a developer to make, when creating, processing or rendering an object, because there are multiple roads to the same result depending upon which API function calls are utilized to achieve the result.","For yet another example, there are three ways for a developer to perform a texture download depending upon the hardware involved, wherein data is transferred from the system memory surface to the display memory surface. It would be desirable to provide a single fast texture download. There are thus situations where the number of mappings from an application to various API objects is diverse, whereby multiple commands perform the same or similar actions. In essence, there is an overlapping of functionality among API objects that is not exploited. It would thus be desirable to centralize this diversity and provide a unified singular command structure, thereby reducing the number of diverse, and potentially redundant, mappings to API objects.","In addition, there are a number of instances in which existing 3D graphics APIs inconvenience the developer by requiring the developer to write substantially more complex code than is necessary in view of today's computing environments. For example, currently it requires at least five programming steps to effect a resolution change, inconveniencing the developer each time a resolution change is desired. While coding five steps is still better than interfacing directly with graphics system components, it would still be desirable to provide a single command to effect a resolution change. Thus, there are a variety of instances in which it would be desirable to unify existing API command structures into concrete, atomic algorithmic elements that ease the task of development.","Since graphics peripherals and other specialized graphics hardware and integrated circuits (ICs) are generally designed for specific tasks, they are much better than the host processor at performing certain types of functions. For example, a video card may have special purpose hardware that can copy or process pixels much faster than the CPU. A high level interface using a multi-purpose processor may not take advantage of the specialized functionality and may also include additional lines of code that in the long run can consume valuable computer resources, especially when repeated over and over as can be the case with graphics applications. Thus, one of the problems with current 3D graphics architectures is an over-reliance on general host computing resources. This over-reliance on general processing has led to major advances in specialized graphics chips designed primarily for the purpose of improving the performance of graphics applications.","Other failings in today's graphical software interfaces are due to advances in hardware technology that have enabled the ability to move functionality previously implemented in software into specialized hardware. An example of this is the way in which graphics rendering and processing functionality has been merged or pushed into specialized graphics hardware that can operate, on average, at orders of magnitude faster than previous generations. In the last two years, graphics hardware has been matching or beating the expectations of Moore's law, creating a whole new universe of high performance devices and 3D graphics chips that can perform specialized tasks at previously unheard of rates and efficiency. This in turn has left pre-existing software interfaces lagging behind the functionality of the hardware devices and the graphics community, and in certain cases, the software interfaces are currently limiting this increased hardware functionality. This can be the case, for example, when the execution of the commands of the software interface becomes the rate determining step of a graphics operation that could otherwise be performed more efficiently with hardware. Thus, in addition to the problems identified above, it would be desirable to address with software solutions the increased functionality of today's graphics hardware at various points between developers, the 3D graphics API and the new hardware.","For example, in the past, when a developer switched graphics data from one memory location to another, the developer had to deal with switching the data i.e., by destroying and recreating the data. In this regard, there are two types of \u2018containers\u2019 that today's graphics APIs present to a developer for use: one for pixels and one for polygons. Essentially, by passing arguments to the graphics API (placing data into the containers), the developers can manipulate and render various chunks of data. Once these containers are filled with data, there are various places, such as system memory or on a 3D card or chip, where this data may be stored for further manipulation. The filling and placement of the containers is achieved via various components or function calls of the graphics API. The decision as to where to place this data is generally a performance issue. Data for which fast access is not necessary can be stored in system memory, whereas data for which speed of access is more important may be stored on a graphics chip designed for ultra fast access.","As mentioned, it is sometimes desirable for a developer to switch data or chunks of data from one memory location to another memory location at different stages of processing. In the past, when a developer desired to switch data from one memory location to another, the developer had to deal with switching the data i.e., destroying the data in the old location and recreating the data in the new location. Previously, this may not have caused a performance decrease because, relative to today, the bandwidth for high performance processing on a graphics board or chip was low. This may have actually given the developer more flexibility to place data in an environment in which it would be processed most efficiently. With limited options, this task was not overly burdensome even though the developer had to custom code the switching of data for each application.","Given the complexity and high performance rewards of using today's hardware, which may have their own memory on board or on chip, it would be advantageous to be able to automatically transition data objects between memory types to enable the seamless switching of data. It would in theory be desirable to keep all data on the faster hardware chip memory to process data. However, in reality, there is little room for such on chip graphics data, sometimes as few as a hundred (high speed) registers. Thus, typically a cache managing algorithm optimizes the tradeoff between host system memory and video memory on the 3D card or chip so as to keep a maximum amount of data for processing in graphics hardware memory without causing overflow. Previously, a developer would have to write such a cache managing algorithm for every application and the cache managing algorithm would have to be individually tailored to the programming task at hand. Thus, it would be desirable to enable the software interface to hide the optimal cache managing algorithm from the developer so that the developer need not be concerned with the optimal tradeoff of system resources, and so that efficient switching of data can take place behind the scenes, thereby simplifying the developer's task.","Another area in which such a software solution is desirable in view of today's graphics devices lies in the transmission of graphics data to specialized graphics ICs and other specialized devices. For example, as mentioned, there are two types of data containers, pixel and polygon, that a developer may fill with data objects for further operation and processing. These containers correspond to data structures or formats that graphics modules, ICs and devices have come to expect for the processing and storage of graphics data, such as pixels and polygons. Currently, when a developer goes about specifying multiple data objects to fill multiple containers, these data objects are fed to a 3D chip one by one, or in a serial fashion. Thus, currently, developers are not able to feed graphics data objects in parallel to a 3D chip for processing and yet today's 3D graphics chips have evolved to function upon and\/or store multiple data objects simultaneously.","Another area in the graphics world that has rapidly evolved is in the area of procedural shading. Vertex and pixel shaders, which may be implemented with software or hardware or with a combination of both, have specialized functionality that enables the processing of pixels or vertices, so as to perform lighting operations, and other transformations upon graphics data. Vertex and pixel shaders are two types of procedural shaders that are currently implemented in specialized graphics ICs.","With current 3D APIs, the API does not provide packaged operations to be performed in connection with procedural shaders, such as vertex and pixel shaders. Invariably, a developer designs these procedural shader algorithms from scratch for each application. While there may be some crossover from application to application, the bottom line is that a developer has to implement these algorithms each time for a new application. Thus, while the core commands for use with the procedural shaders are available to the developer, the effective or efficient combination of those commands is left to the developer. Consequently, algorithms that are unique, common and useful in connection with typical 3D graphics processes, such as algorithms that are typically used in connection with procedural shaders, are designed from the ground up for each application. Conceptually, these elements for acting on procedural shaders have been customized by necessity and thus provided \u2018above\u2019 the API. With present procedural shader hardware designs, for example, a specialized set of assembly language instructions has been developed, which in part replaces or duplicates some of the custom coding currently implemented by the developer. However, there is no mechanism that exposes to the developer unique algorithmic elements for use with procedural shaders via a mechanism that is conceptually below or inside the software interface.","As is apparent from the above, advances in hardware and graphics algorithms have been revolutionizing the way graphics platforms operate. Generally speaking, however, current 3D graphics chips on the market are rigid in design and have very little flexibility in terms of their operation diversity. For example, while they provide high performance for certain operations, current chips do not necessarily have the flexibility to alter their operation via software. While EEPROM technology and the like has existed for sometime where the operation of a chip can be programmably reset, the logic of graphics chips has been typically preset at the factory. However, there are innumerable circumstances where it is desirable to take operations previously customized by a developer for an application, and make these operations downloadable to a 3D chip for improved performance characteristics. As cutting edge 3D graphics chips, still being designed in some cases, have begun to handle such programmable functionality, by including flexible on chip processing and limited on chip memory, to remove custom graphics code from the processing of the host processor and to place such programmable and downloadable functionality in a graphics chip would be of key importance in future graphics platforms. Thus, there is a need for an API that provides this ability to have a programmable 3D chip, wherein programming or algorithmic elements written by the developer can be downloaded to the chip, thereby programming the chip to perform those algorithms at improved performance levels. Related to this case where a developer may write a routine downloadable to the 3D chip, there are also a set of algorithmic elements that are provided in connection with the 3D API (routines that are not written by the developer, but which have already been programmed for the developer). Similarly, it would be desirable to be able to download these API algorithms to a programmable 3D chip for improved performance. It would thus be advantageous to have the ability to download 3D algorithmic elements to provide improved performance, greater control as well as development ease.","While 3D graphics chips are currently undergoing improvements, there are also improvements taking place on the display side of the API i.e., once data has been processed, the API facilitates the transfer of graphics data to the rasterizer. The rasterizer is a specialized display processor chip that, among other things, converts digital pixel data into an analog form appropriate for a display device, such as a monitor. While direct video memory access was previously a possibility, it is no longer a possibility, due to faster techniques employing specialized hardware. Currently, specialized or private drivers and surface formats are used in connection with very fast graphics accelerators. With direct rasterizer\/processor access to display memory surfaces, \u201cchunks\u201d of surfaces can be moved around according to the specialized surface format, and pulled for processing as efficiency dictates. Thus, the pipeline between display memory surface space and the display itself has been made more efficient, but there currently is no mechanism that makes these direct rasterizer\/processor memory access techniques seamless to the application developers via a graphics API whose applications ultimately benefit from the efficiencies of display surface data chunk manipulation.","Thus, as a consequence, the graphics APIs used as the layer that insulates game developers from the details of these changes also need to be changed to be in line with the changes in hardware. When implemented efficiently, these changes can create noticeable differences in the ease and robustness with which APIs may be used by game or other graphics developers. Additionally, the advances in hardware create an opportunity to simplify some processes by increasing maintainability, decreasing memory consumption and providing greater usability of the 3D rendering and processing pipeline.","It would be advantageous to provide an optimization that allows a developer coding an application to specify the transmission of multiple data objects, wherever originated or located at the time of operation, to a 3D chip simultaneously or in parallel. Because graphics ICs have evolved to possess functionality wherein data objects can be processed in parallel, it would be desirable to expose this functionality to developers, thereby allowing developers to specify multiple data objects upon which operations are to be performed simultaneously.","In view of the above problems, it would be beneficial to prevent the severance of connections between surfaces and objects when multiple applications maintain connections to surface memory space. It would be desirable to unify existing API command structures into concrete, atomic algorithmic elements to enable greater development ease. It would be advantageous to be able to automatically transition data objects between memory types to enable the seamless switching of data. It would be further beneficial to be able to feed graphics data objects in parallel to a 3D chip for processing. It would be further advantageous to have the ability to download 3D algorithmic elements to a 3D graphics chip. It would be still further beneficial to make today's direct rasterizer\/processor memory access techniques seamless to the application developers via a graphics API. It would be yet further advantageous to leverage the algorithmic components used for procedural shader operations provided by today's procedural shaders by exposing the components to the developer via the software interface.","In view of the foregoing, the present invention provides a method and system for controlling the algorithmic elements in 3D graphics systems via an improved 3D graphics API. In one aspect, the invention provides a more efficient technique for managing computing resources utilized in connection with the maintenance of connections between surfaces and objects. When multiple applications are running simultaneously, it is possible that the demand for overall computing resources may exceed supply. In such circumstances, it is possible that a connection between a surface and object may be lost for one or more applications. Previously, checks for the persistence of such a connection were made at many different points or times during processing and presenting of graphics data to display memory surface space. Thus, in accordance with the present invention, a check for the persistence of a connection between surface space and object space is made substantially at the time of a present function call, or other recurring or cyclical function call. The check may be made before, as a part of or after the \u2018present\u2019 call, and advantageously, multiple redundant checks are avoided. In one embodiment, checks made incident to function calls other than a present function call are spoofed or bypassed in order to avoid previous inefficient use of computing resources.","Other features of the present invention are described below.","Overview","The present invention provides a new and improved API as a layer between application developers and the current state of the art of graphics hardware and the pipeline that renders and processes the graphics data. The present invention provides a method and system for controlling the algorithmic elements in 3D graphics systems via an improved 3D graphics API. In one aspect, the invention provides a more efficient technique for managing computing resources utilized in connection with the maintenance of connections between surfaces and objects. A graphics application, or any application, may make demands for display memory surface space when executing in order to display graphics, text, figures, pictures, tables, etc. Incident thereto, a 3D graphics API may be called upon to utilize or create objects that maintain a connection to display memory surface space for purposes of the application's display processes. When multiple applications are running simultaneously, it is possible that the demand for overall computing resources may exceed supply. In such circumstances, it is possible that a connection between a surface and object may be lost for one or more applications.","Previously, checks for the persistence of such a connection were made at many different points or times during processing and presenting of graphics data to display memory surface space. Many function calls are made by the 3D graphics API and\/or objects in the control of the 3D graphics API during the course of rendering a single frame of video data. Without any particular rhyme or reason, prior art techniques make a check for the persistence of the connection between object space and surface space for an application at many different times according to many different types of function calls. Each check consumes valuable computing resources, and when redundant checks are made, i.e., when two or more checks are made during the course of rendering a single frame of video data that produce the same result, it is clear that only one check is required, and additional checks are unnecessary.","Thus, in accordance with the present invention, a check for the persistence of a connection between surface space and object space is made substantially at the time of the present function call, or other recurring or cyclical function call. The check may be made before, as a part of or after the \u2018present\u2019 call, and advantageously, multiple redundant checks are avoided. In one embodiment, checks made incident to function calls other than a present function call are spoofed or bypassed in order to avoid previous inefficient use of computing resources.","Various techniques for memory management are described in the following patents which are herein incorporated by reference: U.S. Pat. No. 5,801,717, entitled \u201cMethod and system in display device interface for managing surface memory\u201d; U.S. Pat. No. 5,844,569, entitled \u201cDisplay device interface including support for generalized flipping of surfaces\u201d; U.S. Pat. No. 6,078,942, entitled \u201cResource management for multimedia devices in a computer\u201d; and U.S. Pat. No. 6,134,602, entitled \u201cApplication programming interface enabling application programs to group code and data to control allocation of physical memory in a virtual memory system\u201d.","Exemplary Computer and Network Environments","FIG.  and the following discussion are intended to provide a brief general description of a suitable computing environment in which the invention may be implemented. Although not required, the invention will be described in the general context of computer-executable instructions, such as program modules, being executed by one or more computers, such as client workstations, servers or other devices. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations. Other well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers (PCs), server computers, hand-held or laptop devices, multi-processor systems, microprocessor-based systems, programmable consumer electronics, network PCs, minicomputers, mainframe computers, gaming platforms and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network or other data transmission medium. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.",{"@attributes":{"id":"P-00049","num":"00049"},"figref":"FIG. 1","b":["100","100","100","100"]},"With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus (also known as Mezzanine bus).","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CDROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through an non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in FIG. . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","As mentioned, a computer, such as described above, can be deployed as part of a computer network. Further, the present invention pertains to any computer system having any number of memory or storage units, and any number of applications and processes occurring across any number of storage units or volumes. Thus, the present invention may apply to both server computers and client computers deployed in a network environment, having remote or local storage. More and more, graphics applications are becoming deployed in network environments.  thus illustrates an exemplary network environment, with a server in communication with client computers via a network, in which the present invention may be employed. As shown, a number of servers , , etc., are interconnected via a communications network  (which may be a LAN, WAN, intranet or the Internet) with a number of client computers , , , etc. In a network environment in which the communications network  is the Internet, for example, servers  can be Web servers with which the clients , , etc. communicate via any of a number of known protocols such as hypertext transfer protocol (HTTP). The invention may also leverage peer to peer networking techniques. Each client computer  and server computer  may be equipped with various application program modules , other program modules  and program data , and with connections or access to various types of storage elements or objects, across which files may be stored or to which portion(s) of files may be downloaded or migrated. Each client computer  and server computer  may also be connected to additional storage elements , such as a database. Thus, the present invention can be utilized in a computer network environment having client computers for accessing and interacting with a network and server computers , , etc. for interacting with client computers.","Maintenance of Connection Between Surfaces and Objects","As mentioned in the background, a resource contention issue sometimes occurs due to the demands of multiple devices and applications requiring graphics system resources simultaneously. Current D graphics APIs sometimes improperly manage resources such that if multiple applications running simultaneously are maintaining connections to multiple surfaces from various objects of the graphics system, sometimes these connections to surfaces can become severed or disconnected. If the connection to surface memory for any one application is severed, a user may have to restart the application or begin certain portions of the application again in order to recreate a proper connection.",{"@attributes":{"id":"P-00060","num":"00060"},"figref":["FIG. 3A","FIG. 3A"],"b":["310","320","300","330","330","330","340","350","350","330","330","330","340","320","330"],"i":["a","b ","n ","a ","b ","a","b ","n ","b "]},"In accordance with the present invention, by performing a check and monitoring connections and system resources each time a frame is presented, the consumption of valuable resources between present operations according to various operations is avoided. As shown in , the connection between surface and object is treated as if it persists between present operations in accordance with the present invention, even where the connection has been lost. For example, where a typical check for the persistence of the connection between surfaces and objects includes returning a flag, such as true or false, depending upon the whether the connection persists, these operations may be skipped or spoofed such that between present operations, the flag continues to indicate that the connection persists, even if it has been lost, thus avoiding multiple, redundant checks for the persistence of the connection. As a result, operations are streamlined between present calls such that checks are made when expedient to do so. Thus, the present invention prevents wasteful consumption of computing resources due to the loss of connection between surfaces and objects when multiple devices and applications demand premium system resources simultaneously.","In an exemplary embodiment, the present invention provides a solution by unifying the command structure that previously checked for lost connections to surfaces. Previously, there were innumerable places where the application checked for and handled resource issues between present calls. This distributed the checkpoints and created multiple, if not hundreds or thousands of places throughout the application where checks occurred between present calls, creating inefficiencies and further opportunities for error due to wasteful devotion of computing resources. In accordance with the present invention, each time data is \u2018presented\u2019 to the surface memory space  according to a \u2018present\u2019 function call, the 3D API of the invention checks for these resource contention issues. Thus, instead of having many different cases occurring at different times for which the API might determine that a connection has been lost, the 3 D API of the invention checks each time a \u2018present\u2019 function call is made, thereby providing a single case for a lost connection such that resources may be newly allocated according to the same unified procedure. This check may be performed before or after the present call, or included therein. It can be appreciated that any call, such as a present function call, that is cyclical and occurs once per frame e.g., at a typical 30 or 60 frames per second, or other recurring event may also be utilized to achieve the above goals.","Unification of Previous API Command Structure into Concrete Algorithmic Elements","The subsequent versioning of a software product to meet the needs of an evolving operating environment sometimes results in inefficiencies wherein once separate or merely related modules may be more efficiently placed together, rewritten or merged. Thus, the present invention unifies existing API command structures into concrete, atomic algorithmic elements that ease the task of development.","For example, while the creation, processing and rendering of 3D objects by a 3D API utilizes algorithms and function calls of the 2D API, a single set of APIs does not exist for the purpose of creating both 2D and 3D objects. There are thus typically multiple choices for a developer to make, when creating, processing or rendering an object, which makes the developer's work more complex. For example, with reference to , there are numerous instances where the current 2D graphics API shares functionality with the current 3D graphics API, because, for example, both include the same function calls. There are also instances wherein to perform a function 410a with the 3D graphics API 410 may involve a function call to function 400a of the 2D graphics API, and vice versa. While the overlap in the figure is illustrated simply with dashed lines, the reality of current interoperation is far from simple, and leaves the developer with too many choices. The present invention thus provides a single 2D and 3D graphics API, providing a unified programming body with which developers may work.","Currently, there are no 3D graphics APIs that unify 2D and 3D graphics data types. Historically, due to the evolution of 2D and 3D graphics processing, with \u2018modern\u2019 2D graphics applications beginning as early as the 1970s and with 3D graphics applications developing in parallel fashion at a later time, 2D and 3D data types have simply been treated differently by different applications i.e., memory allocation, memory structures and memory management have been different as between 2D and 3D data types. Thus, because the present invention unifies data types and choices with respect to 2D and 3D data types, memory management techniques have been unified in accordance with the present invention, eliminating ad hoc memory management based on whether the data was a 2D data type or a 3D data type. Due to the unification of 2D and 3D data formatting, the definition of data is simplified from the perspective of the developer. Thus, a long felt need in the art for a unified 2D and 3D API is addressed by the present invention.","In the above scenario, there is an overlapping of functionality among API objects that is not exploited. There are also other instances in which the number of choices available to developers for the same or similar functionality can both complicate the development process and create a source of inefficiency. For instance, there are three ways for a developer to perform a texture download depending upon the hardware involved, wherein data is transferred from a system memory surface to a 3D display memory surface. Textures are rectangular arrays of colored pixels, which tend to be square in graphics applications, and when processed in quantity, represent a lot of data. A texture download, in this regard, is important because ultimately slow texture downloading can become a bottleneck in graphics data processing. Different texture downloads, depending upon the hardware used incident thereto, have different data transfer rates associated therewith and thus the choice of texture download made by the developer can affect the overall system performance. The optimization of this data transfer rate, if required of the developer, can involve considerable time, effort and skill.","As illustrated in , three different functions or ways , and of graphics API  are currently available to a developer for use in connection with a texture download depending upon which hardware , . . . is involved. When multiple hardware , . . . is present, and a developer has three choices to make regarding texture downloading data from a system memory surface , . . . to 3D display memory surface , the decision is undesirably time-consuming, complex and requires an understanding of the underlying hardware in order to make efficient decisions. The present invention thus provides a single fast texture download. Instead of having a plurality of mappings from an application to API objects, and multiple commands that perform the same or similar actions, the present invention provides a single mapping. The present invention thus centralizes the diversity of current texture downloads and provides a unified singular command structure, thereby reducing the number of diverse, and redundant, mappings to API texture downloads. Instead of choosing among API objects , or of , or a combination thereof, or having to write an optimization routine that optimizes the use of , or , the present invention provides a single texture download object _td for use by the developer, as shown in FIG. C.","Optimization of graphics components used incident to a texture download, such as hardware , , . . . , is thus performed by the API object _td in accordance with the present invention, thereby freeing the developer to be concerned with other aspects of the graphics application. For example, according to one optimization, the number of times used and order of hardware components , , etc. utilized in connection with a texture download is hidden from the developer. For example, in one embodiment, object _td keeps track of how well the hardware objects , , etc. are keeping up in terms of free memory (capacity) and speed of data processing and transfer. This may be configured staticly beforehand, so as to control the number and order of hardware components , , etc. that may be used and in connection with a texture download, or this may be performed dynamically based upon an evaluation of the performance of texture downloading, with feedback from the hardware components , , etc.","In addition, there are a number of instances in which existing 3D graphics APIs inconvenience the developer by requiring the developer to write substantially more complex code than is necessary in view of today's computing environments. For example, currently it requires at least five programming steps to effect a resolution change, inconveniencing the developer each time a resolution change is desired. While coding five steps is still better than interfacing directly with graphics system components, the present invention unifies the command structure of a resolution change, allowing a developer to effect a resolution change with a single API command. The present invention thus provides a single command to effect a resolution change, insulating the developer from the detailed changes that are made in the graphics system in order to effect the change. This is yet another example where current graphics APIs require the developer to have an overly detailed understanding of the underlying graphics hardware. As shown in , there are currently five steps or commands _rc, _rc, _rc, _rc and _rc that a developer Dl must enter in order to effect a graphics system resolution change RC. Each of commands _rc, _rc, _rc, _rc and _rc has an independent bearing on the graphics system which can involve overlapping functionality or redundant arguments. Thus, as  illustrates, the present invention provides a single efficient API object _rc to achieve a resolution change. Thus, in these and other instances, the present invention unifies existing API command structures into concrete, atomic algorithmic elements that ease the task of development for a developer.","Downloading of 3D Algorithmic Elements to 3D Chip and Unique Algorithmic Elements for use with Procedural Shaders","The API of the present invention enables programmability of a 3D chip, wherein programming or algorithmic elements written by the developer can be downloaded to the chip, thereby programming the chip to perform those algorithms.","Thus far, the functionality of 3D hardware chips or components has been relatively fixed from the vantage point of the developer, leaving little flexibility at the developer end to perform efficient sets of operations that are tailored to an application or that allow the developer to control the algorithmic elements that are performed by the 3D graphics chip. There are innumerable circumstances where the state of the art of graphics hardware has made it desirable to take operations previously customized by a developer for an application, and make these operations downloadable to a 3D chip for improved performance characteristics. Since 3D graphics chips have evolved to be very high performance compared to host system processing space, it would be advantageous to allow a developer to download functionality to the 3D chip.","Thus, by way of the API of the present invention, 3D algorithmic elements written by a developer can be downloaded to the 3D chip for improved performance characteristics.  illustrates this process whereby a developer D writes a routine  that may be downloaded to 3D graphics chip . Similar to this case where a developer may write a routine  downloadable to the 3D chip , there are also a set of algorithmic elements that are provided in connection with the API of the present invention (routines that do not have to be written by developer D, but which have already been programmed for the developer D), that are downloadable to the programmable chip  for improved performance. As shown in , a developer D may download preexisting API objects , , . . . to 3D graphics chip . While graphics applications generally involve a performance specification that includes fast processing and fast rendering, the ability to control 3D algorithmic elements in this fashion is very advantageous, because it allows a developer access to the fastest, highest performance portions of the graphics processing system, enabling the developer to download efficient algorithmic elements to the graphics chip  that are tailored to the application at hand.","In an exemplary embodiment, a developer adheres to a specific format for packing up an algorithmic element, or set of instructions, for implementation by a 3D graphics chip. The developer packs the instruction set into an array of numbers, by referring to a list of \u2018tokens\u2019 understood by the 3D graphics chip. This array of numbers in turn is mapped correctly to the 3D graphics chip for implementation of the algorithmic element by the 3D graphics chip. Further background, hereby incorporated by reference in its entirety, may be found in U.S. patent application Ser. No. 09\/801,079 entitled \u201cAPI Communications For Vertex And Pixel Shaders\u201d having inventors Boyd and Toelle.","With respect to unique algorithmic elements for use with procedural shaders in accordance with the present invention, some general background is instructive: rendering and displaying three dimensional graphics typically involves many calculations and computations. For example, to render a three dimensional object, a set of coordinate points or vertices that define the object to be rendered must be formed. Vertices can be joined to form polygons that define the surface of the object to be rendered and displayed. Once the vertices that define an object are formed, the vertices are transformed from an object or model frame of reference to a world frame of reference and finally to two dimensional coordinates that can be displayed on a flat display device. Along the way, vertices may be rotated, scaled, eliminated or clipped because they fall outside the viewable area, are lit by various lighting schemes, colorized, and so forth. Thus, the process of rendering and displaying a three dimensional object can be computationally intensive and may involve a large number of vertices.","A triangle has many helpful properties that make it ideal for use in rendering three dimensional surfaces. A triangle is completely defined by three vertices and a triangle also uniquely defines a plane. Thus, many systems will use a plurality of triangles to render a three dimensional surface. If each triangle is passed separately to the graphic subsystem that renders the three dimensional object, then three vertices for each triangle must be passed and processed by the graphic subsystem. However, the number of vertices that must be passed and processed by the graphic subsystem can be reduced through \u201cvertex sharing.\u201d Vertex sharing relies on a property of shared sides among triangles. Although it takes three vertices to define one triangle, it only takes four vertices to define two triangles if they share a common side. In order to take advantage of vertex sharing to reduce the number of vertices needed to render an object, pipelined systems have been developed that divide a three dimensional object into triangle strips that can then be processed and displayed efficiently. Indeed, specialized 3D software objects and\/or hardware components such as procedural shaders have been created or designed for the purpose of carrying out specialized graphics functionality upon graphics data, in order to speed the process of rendering complex graphics objects. Procedural shaders, such as vertex and pixel shaders, have traditionally been used to perform such complex transformations on pixels and\/or arrays of pixels or triangles.","However, the functionality of these procedural shading software objects or hardware components has been relatively fixed, leaving little flexibility at the developer end to perform efficient sets of operations that may be efficiently tailored to a particular graphics application or task.","Thus, with previous 3D APIs, the API did not provide the developer with flexibility as to operations that could be performed in connection with procedural shaders, such as vertex and pixel shaders. Vertex and pixel shaders, which may be implemented with software or in hardware or with a combination of both, have specialized functionality. Currently, in order to utilize useful algorithmic elements of a procedural shader, or otherwise use fixed and limited functionality of the procedural shader, a developer has to invariably design software procedural shader algorithms from scratch for each application. While the core commands for use with the procedural shaders were available to the developer, the effective or efficient combination of these commands is left to the developer. Consequently, algorithms that are unique, common and useful in connection with typical 3D graphics processes, such as for typical use in connection with procedural shaders, are developed from the ground up for each application. Conceptually, these elements for acting on procedural shaders have been customized by necessity for each application and thus provided \u2018above\u2019 the API, programmed as part of the graphics application itself. As shown in , developer D, with access to a specification for a procedural shader , programs an inflexible object  so as to work with or control the procedural shader . As  illustrates, developer D develops a shading algorithm with code. After customization by the developer D, object  interacts with shader(s)  via graphics API .","With present hardware designs of procedural shaders, however, a specialized set of assembly language instructions has been developed creating flexibility of procedural shader use. The developer still has access to the specialized set of instructions as in the past. Advantageously, with the present invention, this specialized set of instructions, or list of tokens packed as an array of numbers, can be combined in such ways as to create useful algorithmic elements. The present invention takes these useful combinations and exposes the algorithmic elements to the developer by way of the API . Conceptually, therefore, the present invention provides these useful algorithmic elements for acting on procedural shaders below or inside the API. As  illustrates, the present invention provides API objects _ps, _ps, . . . _psn, which are useful combinations of procedural shader 's instruction set for acting upon shader . In this fashion, algorithmic elements for use with procedural shader  are exposed to the developer D.","For more concrete examples of algorithmic elements that used to be customized by necessity above the API, which are now provided for use below are any of the following types of techniques, taken alone or in combination: lighting, colorizing, mapping, texturizing, surfacing, shading, enhancing, and other image processing techniques.","Some exemplary code or definitional pseudocode for a procedural shader, such as a vertex shader, is provided below. The declaration portion of an exemplary procedural shader defines the static external interface of the procedural shader. The information in the declaration includes assignments of vertex shader input registers to data streams. These assignments bind a specific vertex register to a single component within a vertex stream. A vertex stream element is identified by a byte offset within the stream and a type. The type specifies the arithmetic data type plus the dimensionality (1, 2, 3, or 4 values). Stream data that is less than four values are preferably expanded out to four values with zero or more 0.F values and one 1.F value.","The information in the declaration also includes assignment of vertex shader input registers to implicit data from the primitive tessellator. This controls the loading of vertex data which is not loaded from a stream, but rather is generated during primitive tessellation prior to the vertex shader.","Moreover, the information in the declaration also includes loading data into the constant memory at the time a procedural shader is set as the current procedural shader. Each token specifies values for one or more contiguous 4 DWORD constant registers. This allows the procedural shader to update an arbitrary subset of the constant memory, overwriting the device state (which contains the current values of the constant memory). Note that these values can be subsequently overwritten (between DrawPrimitive calls) during the time a procedural shader is bound to a device via the SetVertexShaderConstant method.","Declaration arrays are single-dimensional arrays of DWORDs composed of multiple tokens each of which is one or more DWORDs. The single DWORD token value 0xFFFFFFFF is a special token used to indicate the end of the declaration array. The single DWORD token value 0x00000000 is a NOP token with is ignored during the declaration parsing. Note that 0x00000000 is a valid value for DWORDs following the first DWORD for multiple word tokens.","[31:29] Token Type",{"@attributes":{"id":"P-00087","num":"none"},"ul":{"@attributes":{"id":"ul200001","list-style":"none"},"li":{"@attributes":{"id":"ul200002-li00002"},"ul":{"@attributes":{"id":"ul200002","list-style":"none"},"li":["0x0\u2014NOP (requires all DWORD bits to be zero)","0x1\u2014stream selector","0x2\u2014stream data definition (map to vertex input memory)","0x3\u2014vertex input memory from tessellator","0x4\u2014constant memory from shader","0x5\u2014extension","0x6\u2014reserved","0x7\u2014end-of-array (requires all DWORD bits to be 1)\n\nNOP Token (single DWORD token)\n","[31:29] 0x0","[28:00] 0x0\n\nStream Selector (single DWORD token)\n","[31:29] 0x1","[28] indicates whether this is a tessellator stream","[27:04] 0x0","[03:00] stream selector (0.15)\n\nStream Data Definition (single DWORD token)\n","Vertex Input Register Load","[31:29] 0\u00d72","[28] 0x0","[27:20] 0x0","[19:16] type (dimensionality and data type)","[15:04] 0x0","[03:00] vertex register address (0.15)\n\nData Skip (no register load)\n","[31:29] 0x2","[28] 0x1","[27:20] 0x0","[19:16] count of DWORDS to skip over (0.15)","[15:00] 0x0\n\nVertex Input Memory from Tessellator Data (single DWORD token)\n","[31:29] 0x3","[28] indicates whether data is normals or u\/v","[27:24] 0x0","[23:20] vertex register address (0.15) [19:16] type (dimensionality)","[15:04] 0x0","[03:00] vertex register address (0.15)\n\nConstant Memory from Shader (multiple DWORD token)\n","[31:29] 0x4","[28:25] count of 4*DWORD constants to load (0.15)","[24:07] 0x0","[06:00] constant memory address (0.95)\n\nExtension Token (single or multiple DWORD token)\n","[31:29] 0x5","[28:24] count of additional DWORDs in token (0.31)","[23:00] extension-specific information\n\nEnd-of-array token (single DWORD token)\n","[31:29] 0x7","[28:00] 0x1fffffff"]}}}},"The stream selector token is desirably followed by a contiguous set of stream data definition tokens. This token sequence fully defines that stream, including the set of elements within the stream, the order in which the elements appear, the type of each element, and the vertex register into which to load an element.","Streams are allowed to include data which is not loaded into a vertex register, thus allowing data which is not used for this shader to exist in the vertex stream. This skipped data is defined only by a count of DWORDs to skip over, since the type information is irrelevant.","The token sequence:",{"@attributes":{"id":"P-00139","num":"none"},"ul":{"@attributes":{"id":"ul200003","list-style":"none"},"li":["Stream Select: stream=0","Stream Data Definition (Load): type=FLOAT3; register=3","Stream Data Definition (Load): type=FLOAT3; register\u20144","Stream Data Definition (Skip): count=2","Stream Data Definition (Load): type=FLOAT2; register=7\n\ndefines stream zero to consist of four elements, three of which are loaded into registers and the fourth skipped over. Register  is loaded with the first three DWORDs in each vertex interpreted as FLOAT data. Register  is loaded with the fourth, fifth, and sixth DWORDs interpreted as FLOAT data. The next two DWORDs (seventh and eighth) are skipped over and not loaded into any vertex input register. Register  is loaded with the ninth and tenth DWORDS interpreted as FLOAT data.\n"]}},"Placing of tokens other than NOPs between the Stream Selector and Stream Data Definition tokens is disallowed.",{"@attributes":{"id":"P-d0e4470","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef enum_D3DVSD_TOKENTYPE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DVSD_TOKEN_NOP = 0,\u2003\/\/ NOP or extension"]},{"entry":[{},"D3DVSD_TOKEN_STREAM,\u2003\u2003\u2003\u2003\/\/ stream selector"]},{"entry":[{},"D3DVSD_TOKEN_STREAMDATA,\u2003\u2003\u2003 \/\/ stream data definition (map to vertex input"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"memory)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DVSD_TOKEN_TESSELLATOR,\u2003\u2003\u2003 \/\/ vertex input memory from tessellator"]},{"entry":[{},"D3DVSD_TOKEN_CONSTMEM,\u2003\u2003\u2003\/\/ constant memory from shader"]},{"entry":[{},"D3DVSD_TOKEN_EXT,\u2003\u2003\u2003\/\/ extension"]},{"entry":[{},"D3DVSD_TOKEN_END = 7,\u2003\u2003\u2003\/\/ end-of-array (requires all DWORD bits to be 1)"]},{"entry":[{},"D3DVSD_FORCE_DWORD = 0x7fffffff,\/\/ force 32-bit size enum"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"} D3DVSD_TOKENTYPE;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define D3DVSD_TOKENTYPESHIFT","29"]},{"entry":["#define D3DVSD_TOKENTYPEMASK","\u2009(7 << D3DVSD_TOKENTYPESHIFT)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#define D3DVSD_STREAMNUMBERSHIFT 0"},{"entry":"#define D3DVSD_STREAMNUMBERMASK (0xF <<"},{"entry":"D3DVSD_STREAMNUMBERSHIFT)"},{"entry":"#define D3DVSD_DATALOADTYPESHIFT 28"},{"entry":"#define D3DVSD_DATALOADTYPEMASK (0x1 <<"},{"entry":"D3DVSD_DATALOADTYPESHIFT)"},{"entry":"#define D3DVSD_DATATYPESHIFT 16"},{"entry":"#define D3DVSD_DATATYPEMASK (0xF << D3DVSD_DATATYPESHIFT)"},{"entry":"#define D3DVSD_SKIPCOUNTSHIFT 16"},{"entry":"#define D3DVSD_SKIPCOUNTMASK (0xF << D3DVSD_SKIPCOUNTSHIFT)"},{"entry":"#define D3DVSD_VERTEXREGSHIFT 0"},{"entry":"#define D3DVSD_VERTEXREGMASK (0x1F << D3DVSD_VERTEXREGSHIFT)"},{"entry":"#define D3DVSD_VERTEXREGINSHIFT 20"},{"entry":"#define D3DVSD_VERTEXREGINMASK (0xF << D3DVSD_VERTEXREGINSHIFT)"},{"entry":"#define D3DVSD_CONSTCOUNTSHIFT 25"},{"entry":"#define D3DVSD_CONSTCOUNTMASK (0xF << D3DVSD_CONSTCOUNTSHIFT)"},{"entry":"#define D3DVSD_CONSTADDRESSSHIFT 0"},{"entry":"#define D3DVSD_CONSTADDRESSMASK (0x7F <<"},{"entry":"D3DVSD_CONSTADDRESSSHIFT)"},{"entry":"#define D3DVSD_CONSTRSSHIFT 16"},{"entry":"#define D3DVSD_CONSTRSMASK (0x1FFF << D3DVSD_CONSTRSSHIFT)"},{"entry":"#define D3DVSD_EXTCOUNTSHIFT 24"},{"entry":"#define D3DVSD_EXTCOUNTMASK (0x1F << D3DVSD_EXTCOUNTSHIFT)"},{"entry":"#define D3DVSD_EXTINFOSHIFT 0"},{"entry":"#define D3DVSD_EXTINFOMASK (0xFFFFFF << D3DVSD_EXTINFOSHIFT)"},{"entry":"#define D3DVSD_MAKETOKENTYPE(tokenType) ((tokenType <<"},{"entry":"D3DVSD_TOKENTYPESHIFT) & D3DVSD_TOKENTYPEMASK)"},{"entry":"\/\/ macros for generation of CreateVertexShader Declaration token array"},{"entry":"\/\/ Set current stream"},{"entry":"\/\/ _StreamNumber [0..(MaxStreams-1)]stream to get data from"},{"entry":"\/\/"},{"entry":"#define D3DVSD_STREAM(_StreamNumber) \\"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) | (_StreamNumber))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Set tessellator stream"},{"entry":"\u2009\/\/"},{"entry":"#define D3DVSD_STREAMTESSSHIFT 28"},{"entry":"#define D3DVSD_STREAMTESSMASK (1 << D3DVSD_STREAMTESSSHIFT)"},{"entry":"#define D3DVSD_STREAM_TESS() \\"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"(D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAM) |"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(D3DVSD_STREAMTESSMASK))"},{"entry":"\/\/ bind single vertex register to vertex element from vertex stream"},{"entry":"\/\/"},{"entry":"\/\/ _VertexRegister [0..15]address of the vertex register"},{"entry":"\/\/ _Type [D3DVSDT_*]dimensionality and arithmetic data type"},{"entry":"#define D3DVSD_REG(_VertexRegister,_Type) \\"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) |\\"]},{"entry":[{},"\u2009((_Type) << D3DVSD_DATATYPESHIFT) | (_VertexRegister))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Skip_DWORDCount DWORDs in vertex"},{"entry":"\/\/"},{"entry":"#define D3DVSD_SKIP(_DWORDCount) \\"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_STREAMDATA) | 0x10000000 |\\"]},{"entry":[{},"\u2009((_DWORDCount) << D3DVSD_SKIPCOUNTSHIFT))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ load data into vertex shader constant memory"},{"entry":"\/\/"},{"entry":"\/\/ _ConstantAddress [0..95] - address of constant array to begin filling"},{"entry":"data"},{"entry":"\/\/ _Count [0..15] - number of constant vectors to load (4 DWORDs each)"},{"entry":"\/\/ followed by 4*_Count DWORDS of data"},{"entry":"\/\/"},{"entry":"#define D3DVSD_CONST(_ConstantAddress,_Count) \\"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_CONSTMEM) |\\"]},{"entry":[{},"\u2009((_Count) << D3DVSD_CONSTCOUNTSHIFT) | (_ConstantAddress))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ enable tessellator generated normals"},{"entry":"\/\/"},{"entry":"\/\/ _VertexRegisterIn [0..15] address of vertex register whose input"},{"entry":"stream"},{"entry":"\/\/ will be used in normal computation"},{"entry":"\/\/ _VertexRegisterOut [0..15] address of vertex register to output the"},{"entry":"normal to"},{"entry":"\/\/"},{"entry":"#define D3DVSD_TESSNORMAL(_VertexRegisterIn,_VertexRegisterOut) \\"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) |\\"]},{"entry":[{},"\u2009((_VertexRegisterIn) << D3DVSD_VERTEXREGINSHIFT) |\\"]},{"entry":[{},"\u2009((0x02) << D3DVSD_DATATYPESHIFT) | (_VertexRegisterOut))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ enable tessellator generated surface parameters"},{"entry":"\/\/"},{"entry":"\/\/ _VertexRegister [0..15] address of vertex register to output parameters"},{"entry":"\/\/"},{"entry":"#define D3DVSD_TESSUV(_VertexRegister) \\"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(D3DVSD_MAKETOKENTYPE(D3DVSD_TOKEN_TESSELLATOR) |0x10000000 |\\"]},{"entry":[{},"\u2009((0x01) << D3DVSD_DATATYPESHIFT) |(_VertexRegister))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Generates END token"},{"entry":"\/\/"},{"entry":"#define D3DVSD_END() 0xFFFFFFFF"},{"entry":"\/\/ Generates NOP token"},{"entry":"#define D3DVSD_NOP() 0x00000000"},{"entry":"\/\/ bit declarations for _Type fields"},{"entry":"#define D3DVSDT_FLOAT1\u2003\u20030x00\u2003\u2003\/\/ 1D float expanded to (value, 0.,"},{"entry":"0., 1.)"},{"entry":"#define D3DVSDT_FLOAT2\u2003\u2003 0x01\u2003\u2003\/\/ 2D float expanded to (value, value,"},{"entry":"0., 1.)"},{"entry":"#define D3DVSDT_FLOAT3\u2003\u20030x02\u2003\u2003\/\/ 3D float expanded to (value, value,"},{"entry":"value, 1.)"},{"entry":"#define D3DVSDT_FLOAT4\u2003\u20030x03\u2003\u2003\/\/ 4D float"},{"entry":"#define D3DVSDT_D3DCOLOR\u2003\u20030x04\u2003\u2003\/\/ 4D packed unsigned bytes mapped to"},{"entry":"0. to 1. range"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/ Input is in D3DCOLOR format (ARGB)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"expanded to (R, G, B, A)"},{"entry":"#define D3DVSDT_UBYTE4\u2003\u20030x05\u2003\u2003\/\/ 4D unsigned byte"},{"entry":"#define D3DVSDT_SHORT2\u2003\u20030x06\u2003\u2003\/\/ 2D signed short expanded to (value,"},{"entry":"value, 0., 1.)"},{"entry":"#define D3DVSDT_SHORT4\u2003\u20030x07\u2003\u2003\/\/ 4D signed short"},{"entry":"\/\/ assignments of vertex input registers for fixed function vertex shader"},{"entry":"\/\/"},{"entry":"#define D3DVSDE_POSITION\u2003\u20030"},{"entry":"#define D3DVSDE_BLENDWEIGHT\u2003\u20031"},{"entry":"#define D3DVSDE_BLENDINDICES\u2003\u20032"},{"entry":"#define D3DVSDE_NORMAL\u2003\u20033"},{"entry":"#define D3DVSDE_PSIZE\u2003\u20034"},{"entry":"#define D3DVSDE_DIFFUSE\u2003\u20035"},{"entry":"#define D3DVSDE_SPECULAR\u2003\u20036"},{"entry":"#define D3DVSDE_TEXCOORD0\u2003\u20037"},{"entry":"#define D3DVSDE_TEXCOORD1\u2003\u20038"},{"entry":"#define D3DVSDE_TEXCOORD2\u2003\u20039"},{"entry":"#define D3DVSDE_TEXCOORD3\u2003\u200310"},{"entry":"#define D3DVSDE_TEXCOORD4\u2003\u200311"},{"entry":"#define D3DVSDE_TEXCOORD5\u2003\u200312"},{"entry":"#define D3DVSDE_TEXCOORD6\u2003\u200313"},{"entry":"#define D3DVSDE_TEXCOORD7\u2003\u200314"},{"entry":"#define D3DVSDE_POSITION2\u2003\u200315"},{"entry":"#define D3DVSDE_NORMAL2\u2003\u200316"},{"entry":"\/\/ Maximum supported number of texture coordinate sets"},{"entry":"#define D3DDP_MAXTEXCOORD 8"},{"entry":";begin_internal"},{"entry":"\/\/---------------------------------------------------------------------"},{"entry":"\/\/"},{"entry":"\/\/ Pixel Shader (PS) & Vertex Shader (VS) Instruction Token Definition"},{"entry":"\/\/"},{"entry":"\/\/ *** Version Token ***"},{"entry":"\/\/ [07:00] minor version number"},{"entry":"\/\/ [15:08] major version number"},{"entry":"\/\/ [31:16]"},{"entry":"\/\/\u2003 PS 0xFFFF"},{"entry":"\/\/\u2003VS 0xFFFE"},{"entry":"\/\/"},{"entry":"\/\/ *** End Token ***"},{"entry":"\/\/ [31:00] 0x0000FFFF"},{"entry":"\/\/"},{"entry":"\/\/ *** Comment Token ***"},{"entry":"\/\/ [15:00] 0xFFFE"},{"entry":"\/\/ [30:16] DWORD Length (up to 2{circumflex over (\u2009)} 15 DWORDS = 128KB)"},{"entry":"\/\/ [31] 0x0"},{"entry":"\/\/"},{"entry":"\/\/ *** Instruction Token ***"},{"entry":"\/\/ [15:00] Opcode (D3DSIO_*)"},{"entry":"\/\/ [23:16] Opcode-Specific Controls"},{"entry":"\/\/ [29:24] Reserved 0x0"},{"entry":"\/\/ [30] Co-Issue - if set then execute this instruction with the previous"},{"entry":"instruction(s)"},{"entry":"\/\/ [31] 0x0"},{"entry":"\/\/"},{"entry":"\/\/ *** Destination Parameter Token ***"},{"entry":"\/\/ [07:00] Register Number (offset in register file)"},{"entry":"\/\/ [15:08] Reserved 0x0"},{"entry":"\/\/ [19:16] Write Mask"},{"entry":"\/\/\u2002\u2009[16] Component 0 (X;Red)"},{"entry":"\/\/\u2002\u2009[17] Component 1 (Y;Green)"},{"entry":"\/\/\u2002\u2009[18] Component 2 (Z;Blue)"},{"entry":"\/\/\u2002\u2009[19] Component 3 (W;Alpha)"},{"entry":"\/\/\u2002\u2009[23:20]"},{"entry":"\/\/\u2002\u2009PS Result Modifier"},{"entry":"\/\/\u2002\u2009VS Reserved 0x0"},{"entry":"\/\/ [27:24]"},{"entry":"\/\/\u2002\u2009PS Result Shift Scale (signed shift)"},{"entry":"\/\/\u2002\u2009VS Reserved 0x0"},{"entry":"\/\/ [30:28] Register Type"},{"entry":"\/\/\u2002\u2009[0x0] Temporary Register File"},{"entry":"\/\/\u2002\u2009[0x1] Reserved"},{"entry":"\/\/\u2002\u2009[0x2] Reserved"},{"entry":"\/\/\u2002\u2009[0x3]"},{"entry":"\/\/\u2003\u2002\u2009VS Address Register (reg num must be zero)"},{"entry":"\/\/\u2003\u2002\u2009PS Reserved"},{"entry":"\/\/\u2002\u2009[0x4]"},{"entry":"\/\/\u2002\u2009\u2003VS Rasterizer Output Register File"},{"entry":"\/\/\u2002\u2009\u2003PS Reserved"},{"entry":"\/\/\u2002\u2009[0x5]"},{"entry":"\/\/\u2002\u2009\u2003VS Attribute Output Register File"},{"entry":"\/\/\u2002\u2009\u2003PS Reserved"},{"entry":"\/\/\u2002\u2009[0x6]"},{"entry":"\/\/\u2002\u2009\u2003VS Texture Coordinate Register File"},{"entry":"\/\/\u2002\u2009\u2003PS Reserved"},{"entry":"\/\/\u2002\u2009[0x7] Reserved"},{"entry":"\/\/ [31] 0x1"},{"entry":"\/\/"},{"entry":"\/\/ *** Source Parameter Token *** "},{"entry":"\/\/ [12:00] Register Number (offset in register file)"},{"entry":"\/\/ [13]"},{"entry":"\/\/\u2002\u2009VS Relative Address"},{"entry":"\/\/\u2002\u2009PS Reserved 0x0"},{"entry":"\/\/ [14:15]"},{"entry":"\/\/\u2002\u2009VS Relative Address Register Component"},{"entry":"\/\/\u2002\u2009PS Reserved 0x0"},{"entry":"\/\/ [23:16] Source Component Swizzle"},{"entry":"\/\/\u2002\u2009[17:16] Component 0 Swizzle"},{"entry":"\/\/\u2002\u2009[19:18] Component 1 Swizzle"},{"entry":"\/\/\u2002\u2009[21:20] Component 2 Swizzle"},{"entry":"\/\/\u2002\u2009[23:22] Component 3 Swizzle"},{"entry":"\/\/ [27:24] Source Modifier"},{"entry":"\/\/\u2003[0x0] None"},{"entry":"\/\/\u2003[0x1] Negate"},{"entry":"\/\/\u2003[0x2] Bias"},{"entry":"\/\/\u2003[0x3] Bias and Negate"},{"entry":"\/\/\u2003[0x4] Sign"},{"entry":"\/\/\u2003[0x5] Sign and Negate"},{"entry":"\/\/\u2003[0x6] Complement"},{"entry":"\/\/\u2003[0x7-0xf] Reserved"},{"entry":"\/\/ [30:28] Register Type"},{"entry":"\/\/\u2002\u2009[0x0] Temporary Register File"},{"entry":"\/\/\u2002\u2009[0x1] Input Register File"},{"entry":"\/\/\u2002\u2009[0x2] Constant Register File"},{"entry":"\/\/\u2002\u2009[0x3-0x7] Reserved"},{"entry":"\/\/ [31] 0x1"},{"entry":"\/\/"},{"entry":"\/\/ The exception for source parameter tokens is with the instruction:"},{"entry":"\/\/ D3DSIO_DEF c#,f0,f1,f2,f2"},{"entry":"\/\/ Here, the source parameter tokens (f#) are each taken as 32 bit floats."},{"entry":"\/\/"},{"entry":";end_internal"},{"entry":"\/\/"},{"entry":"\/\/ Instruction Token Bit Definitions"},{"entry":"\/\/"},{"entry":"#define D3DSI_OPCODE_MASK\u2003\u20030x0000FFFF"},{"entry":"typedef enum_D3DSHADER_INSTRUCTION_OPCODE_TYPE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DSIO_NOP","= 0,","\/\/ PS\/VS"]},{"entry":[{},"D3DSIO_MOV",",","\/\/ PS\/VS"]},{"entry":[{},"D3DSIO_ADD",",","\/\/ PS\/VS"]},{"entry":[{},"D3DSIO_SUB",",","\/\/ PS"]},{"entry":[{},"D3DSIO_MAD",",","\/\/ PS\/VS"]},{"entry":[{},"D3DSIO_MUL",",","\/\/ PS\/VS"]},{"entry":[{},"D3DSIO_RCP",",","\/\/ VS"]},{"entry":[{},"D3DSIO_RSQ",",","\/\/ VS"]},{"entry":[{},"D3DSIO_DP3",",","\/\/ PS\/VS"]},{"entry":[{},"D3DSIO_DP4",",","\/\/ PS\/VS"]},{"entry":[{},"D3DSIO_MIN",",","\/\/ VS"]},{"entry":[{},"D3DSIO_MAX",",","\/\/ VS"]},{"entry":[{},"D3DSIO_SLT",",","\/\/ VS"]},{"entry":[{},"D3DSIO_SGE",",","\/\/ VS"]},{"entry":[{},"D3DSIO_EXP",",","\/\/ VS"]},{"entry":[{},"D3DSIO_LOG",",","\/\/ VS"]},{"entry":[{},"D3DSIO_LIT",",","\/\/ VS"]},{"entry":[{},"D3DSIO_DST",",","\/\/ VS"]},{"entry":[{},"D3DSIO_LRP",",","\/\/ PS"]},{"entry":[{},"D3DSIO_FRC",",","\/\/ VS"]},{"entry":[{},"D3DSIO_M4x4",",","\/\/ VS"]},{"entry":[{},"D3DSIO_M4x3",",","\/\/ VS"]},{"entry":[{},"D3DSIO_M3x4",",","\/\/ VS"]},{"entry":[{},"D3DSIO_M3x3",",","\/\/ VS"]},{"entry":[{},"D3DSIO_M3x2",",","\/\/ VS"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"D3DSIO_TEXCOORD","= 64, \/\/ PS"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DSIO_TEXKILL",",","\/\/ PS"]},{"entry":[{},"D3DSIO_TEX",",","\/\/ PS"]},{"entry":[{},"D3DSIO_TEXBEM",",","\/\/ PS"]},{"entry":[{},"D3DSIO_TEXBEML",",","\/\/ PS"]},{"entry":[{},"D3DSIO_TEXREG2AR",",","\/\/ PS"]},{"entry":[{},"D3DSIO_TEXREG2GB",",","\/\/ PS"]},{"entry":[{},"D3DSIO_TEXM3x2PAD",",","\/\/ PS"]},{"entry":[{},"D3DSIO_TEXM3x2TEX",",","\/\/ PS"]},{"entry":[{},"D3DSIO_TEXM3x3PAD",",","\/\/ PS"]},{"entry":[{},"D3DSIO_TEXM3x3TEX",",","\/\/ PS"]},{"entry":[{},"D3DSIO_TEXM3x3DIFF",",","\/\/ PS"]},{"entry":[{},"D3DSIO_TEXM3x3SPEC",",","\/\/ PS"]},{"entry":[{},"D3DSIO_TEXM3x3VSPEC",",","\/\/ PS"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DSIO_EXPP",",","\/\/ VS"]},{"entry":[{},"D3DSIO_LOGP",",","\/\/ VS"]},{"entry":[{},"D3DSIO_CND",",","\/\/ PS"]},{"entry":[{},"D3DSIO_DEF",",","\/\/ PS"]},{"entry":[{},";begin_internal"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"D3DSIO_RESERVED0","= 96, \/\/ PS"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DSIO_RESERVED1",",","\/\/ PS"]},{"entry":[{},"D3DSIO_RESERVED2",",","\/\/ PS"]},{"entry":[{},"D3DSIO_RESERVED3",",","\/\/ PS"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":";end_internal"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DSIO_COMMENT\u2003\u2003= 0xFFFE,"]},{"entry":[{},"D3DSIO_END\u2003\u2003\u2003= 0xFFFF,"]},{"entry":[{},"D3DSIO_FORCE_DWORD = 0x7fffffff, \/\/ force 32-bit size enum"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} D3DSHADER_INSTRUCTION_OPCODE_TYPE;"},{"entry":"\/\/"},{"entry":"\/\/ Co-Issue Instruction Modifier - if set then this instruction is to be"},{"entry":"\/\/ issued in parallel with the previous instruction(s) for which this bit"},{"entry":"\/\/ is not set."},{"entry":"\/\/ "},{"entry":"#define D3DSI_COISSUE\u2003\u2003\u20030x40000000"},{"entry":"\/\/"},{"entry":"\/\/ Parameter Token Bit Definitions"},{"entry":"\/\/"},{"entry":"#define D3DSP_REGNUM_MASK\u2003\u2003\u20030x00000FFF"},{"entry":"\/\/ destination parameter write mask"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define D3DSP_WRITEMASK_0","0x00010000 \/\/ Component 0 (X;Red)"]},{"entry":["#define D3DSP_WRITEMASK_1","0x00020000 \/\/ Component 1 (Y;Green)"]},{"entry":["#define D3DSP_WRITEMASK_2","0x00040000 \/\/ Component 2 (Z;Blue)"]},{"entry":["#define D3DSP_WRITEMASK_3","0x00080000 \/\/ Component 3 (W;Alpha)"]},{"entry":["#define D3DSP_WRITEMASK_ALL","\u20030x000F0000 \/\/ All Components"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ destination parameter modifiers"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define D3DSP_DSTMOD_SHIFT","20"]},{"entry":["#define D3DSP_DSTMOD_MASK","\u20090x00F00000"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef enum_D3DSHADER_PARAM_DSTMOD_TYPE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DSPDM_NONE\u2003= 0<<D3DSP_DSTMOD_SHIFT, \/\/ nop"]},{"entry":[{},"D3DSPDM_SATURATE= 1<<D3DSP_DSTMOD_SHIFT, \/\/ clamp to 0. to 1. range"]},{"entry":[{},"D3DSPDM_FORCE_DWORD = 0x7fffffff, \/\/ force 32-bit size enum"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} D3DSHADER_PARAM_DSTMOD_TYPE;"},{"entry":"\/\/ destination parameter shift"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define D3DSP_DSTSHIFT_SHIFT","24"]},{"entry":["#define D3DSP_DSTSHIFT_MASK","\u2002\u20090x0F000000"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ destination\/source parameter register type"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define D3DSP_REGTYPE_SHIFT","28"]},{"entry":["#define D3DSP_REGTYPE_MASK","\u2002\u20090x70000000"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"typedef enum_D3DSHADER_PARAM_REGISTER_TYPE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DSPR_TEMP","= 0<<D3DSP_REGTYPE_SHIFT, \/\/ Temporary Register File"]},{"entry":[{},"D3DSPR_INPUT","= 1<<D3DSP_REGTYPE_SHIFT, \/\/ Input Register File"]},{"entry":[{},"D3DSPR_CONST","= 2<<D3DSP_REGTYPE_SHIFT, \/\/ Constant Register File"]},{"entry":[{},"D3DSPR_ADDR","= 3<<D3DSP_REGTYPE_SHIFT, \/\/ Address Register (VS)"]},{"entry":[{},"D3DSPR_TEXTURE","= 3<<D3DSP_REGTYPE_SHIFT, \/\/ Texture Register File"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"(PS)"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DSPR_RASTOUT = 4<<D3DSP_REGTYPE_SHIFT, \/\/ Rasterizer Register File"]},{"entry":[{},"D3DSPR_ATTROUT = 5<<D3DSP_REGTYPE_SHIFT, \/\/ Attribute Output Register"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"File"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"D3DSPR_TEXCRDOUT= 6<<D3DSP_REGTYPE_SHIFT, \/\/ Texture Coordinate Output"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Register File"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"D3DSPR_FORCE_DWORD = 0x7fffffff, \/\/ force 32-bit size enum"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} D3DSHADER_PARAM_REGISTER_TYPE;"},{"entry":"\/\/ Register offsets in the Rasterizer Register File"},{"entry":"\/\/"},{"entry":"typedef enum_D3DVS_RASTOUT_OFFSETS"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DSRO_POSITION = 0,"]},{"entry":[{},"D3DSRO_FOG,"]},{"entry":[{},"D3DSRO_POINT_SIZE,"]},{"entry":[{},"D3DSRO_FORCE_DWORD = 0x7fffffff,\u2003\u2003\u2003\u2003\/\/ force 32-bit size enum"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} D3DVS_RASTOUT_OFFSETS;"},{"entry":"\/\/ Source operand addressing modes"},{"entry":"#define D3DVS_ADDRESSMODE_SHIFT 13"},{"entry":"#define D3DVS_ADDRESSMODE_MASK (1 << D3DVS_ADDRESSMODE_SHIFT)"},{"entry":"typedef enum_D3DVS_ADDRESSMODE_TYPE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DVS_ADDRMODE_ABSOLUTE = (0 << D3DVS_ADDRESSMODE_SHIFT),"]},{"entry":[{},"D3DVS_ADDRMODE_RELATIVE = (1 << D3DVS_ADDRESSMODE_SHIFT), \/\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Relative to register A0"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"D3DVS_ADDRMODE_FORCE_DWORD = 0x7fffffff, \/\/ force 32-bit size enum"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} D3DVS_ADDRESSMODE_TYPE;"},{"entry":"\/\/ Source operand swizzle definitions"},{"entry":"\/\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define D3DVS_SWIZZLE_SHIFT","16"]},{"entry":["#define D3DVS_SWIZZLE_MASK","\u2002\u20090x00FF0000"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ The following bits define where to take component X:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define D3DVS_X_X","(0 << D3DVS_SWIZZLE_SHIFT)"]},{"entry":["#define D3DVS_X_Y","(1 << D3DVS_SWIZZLE_SHIFT)"]},{"entry":["#define D3DVS_X_Z","(2 << D3DVS_SWIZZLE_SHIFT)"]},{"entry":["#define D3DVS_X_W","(3 << D3DVS_SWIZZLE_SHIFT)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ The following bits define where to take component Y:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define D3DVS_Y_X","(0 << (D3DVS_SWIZZLE_SHIFT + 2))"]},{"entry":["#define D3DVS_Y_Y","(1 << (D3DVS_SWIZZLE_SHIFT + 2))"]},{"entry":["#define D3DVS_Y_Z","(2 << (D3DVS_SWIZZLE_SHIFT + 2))"]},{"entry":["#define D3DVS_Y_W","(3 << (D3DVS_SWIZZLE_SHIFT + 2))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ The following bits define where to take component Z:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define D3DVS_Z_X","(0 << (D3DVS_SWIZZLE_SHIFT + 4))"]},{"entry":["#define D3DVS_Z_Y","(1 << (D3DVS_SWIZZLE_SHIFT + 4))"]},{"entry":["#define D3DVS_Z_Z","(2 << (D3DVS_SWIZZLE_SHIFT + 4))"]},{"entry":["#define D3DVS_Z_W","(3 << (D3DVS_SWIZZLE_SHIFT + 4))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ The following bits define where to take component W:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["#define D3DVS_W_X","(0 << (D3DVS_SWIZZLE_SHIFT + 6))"]},{"entry":["#define D3DVS_W_Y","(1 << (D3DVS_SWIZZLE_SHIFT + 6))"]},{"entry":["#define D3DVS_W_Z","(2 << (D3DVS_SWIZZLE_SHIFT + 6))"]},{"entry":["#define D3DVS_W_W","(3 << (D3DVS_SWIZZLE_SHIFT + 6))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Value when there is no swizzle (X is taken from X, Y is taken from Y,"},{"entry":"\/\/ Z is taken from Z, W is taken from W"},{"entry":"\/\/"},{"entry":"#define D3DVS_NOSWIZZLE (D3DVS_X_X|D3DVS_Y_Y|D3DVS_Z_Z|"},{"entry":"D3DVS_W_W)"},{"entry":"\/\/ source parameter swizzle"},{"entry":"#define D3DSP_SWIZZLE_SHIFT 16"},{"entry":"#define D3DSP_SWIZZLE_MASK 0x00FF0000"},{"entry":"#define D3DSP_NOSWIZZLE\\"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"((0 << (D3DSP_SWIZZLE_SHIFT + 0))|\\"]},{"entry":[{},"\u2009(1 << (D3DSP_SWIZZLE_SHIFT + 2)) |\\"]},{"entry":[{},"\u2009(2 << (D3DSP_SWIZZLE_SHIFT + 4))|\\"]},{"entry":[{},"\u2009(3 << (D3DSP_SWIZZLE_SHIFT + 6)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ pixel-shader swizzle ops"},{"entry":"#define D3DSP_REPLICATEALPHA\\"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"((3 << (D3DSP_SWIZZLE_SHIFT + 0))|\\"]},{"entry":[{},"\u2009(3 << (D3DSP_SWIZZLE_SHIFT + 2))|\\"]},{"entry":[{},"\u2009(3 << (D3DSP_SWIZZLE_SHIFT + 4))|\\"]},{"entry":[{},"\u2009(3 << (D3DSP_SWIZZLE_SHIFT + 6)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ source parameter modifiers"},{"entry":"#define D3DSP_SRCMOD_SHIFT 24"},{"entry":"#define D3DSP_SRCMOD_MASK 0x0F000000"},{"entry":"typedef enum_D3DSHADER_PARAM_SRCMOD_TYPE"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"273pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D3DSPSM_NONE = 0 << D3DSP_SRCMOD_SHIFT, \/\/ nop"]},{"entry":[{},"D3DSPSM_NEG = 1 << D3DSP_SRCMOD_SHIFT, \/\/ negate"]},{"entry":[{},"D3DSPSM_BIAS = 2 << D3DSP_SRCMOD_SHIFT, \/\/ bias"]},{"entry":[{},"D3DSPSM_BIASNEG = 3 << D3DSP_SRCMOD_SHIFT, \/\/ bias and negate"]},{"entry":[{},"D3DSPSM_SIGN = 4 << D3DSP_SRCMOD_SHIFT, \/\/ sign"]},{"entry":[{},"D3DSPSM_SIGNNEG = 5 << D3DSP_SRCMOD_SHIFT, \/\/ sign and negate"]},{"entry":[{},"D3DSPSM_COMP = 6 << D3DSP_SRCMOD_SHIFT, \/\/ complement"]},{"entry":[{},"D3DSPSM_FORCE_DWORD = 0x7fffffff, \/\/ force 32-bit size enum"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} D3DSHADER_PARAM_SRCMOD_TYPE;"},{"entry":"\/\/ pixel shader version token"},{"entry":"\u2002\u2009#define D3DPS_VERSION(_Major,_Minor) (0xFFFF0000|((_Major)<<8)|(_Minor))"},{"entry":"\/\/ vertex shader version token"},{"entry":"\u2002\u2009#define D3DVS_VERSION(_Major,_Minor) (0xFFFE0000|((_Major)<<8)|(_Minor))"},{"entry":"\/\/ extract major\/minor from version cap"},{"entry":"\u2002\u2009#define D3DSHADER_VERSION_MAJOR(_Version) (((_Version)8)&0xFF)"},{"entry":"\u2002\u2009#define D3DSHADER_VERSION_MINOR(_Version) (((_Version)0)&0xFF)"},{"entry":"\/\/ destination\/source parameter register type"},{"entry":"\u2002\u2009#define D3DSI_COMMENTSIZE_SHIFT 16"},{"entry":"\u2002\u2009#define D3DSI_COMMENTSIZE_MASK 0x7FFF0000"},{"entry":"\u2002\u2009#define D3DSHADER_COMMENT(_DWordSize)\\"},{"entry":"((((_DWordSize) << D3DSI_COMMENTSIZE_SHIFT)&D3DSI_COMMENTSIZE_MASK)|"},{"entry":"D3DSIO_COMMENT)"},{"entry":"\u2002\u2009\/\/ pixel\/vertex shader end token"},{"entry":"\u2002\u2009#define D3DPS_END() 0x0000FFFF"},{"entry":"\u2002\u2009#define D3DVS_END() 0x0000FFFF"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"While the above exemplary computer-executable instructions have been described in the context of a procedural shader, these concepts and principles may be applied to any 3D hardware rendering device utilized in connection with a graphics display system.","Improvements on the Display (Rasterizer) Side of the API","As mentioned above, while direct video memory access was once a possibility, it is no longer a possibility according to today's currently utilized graphics architectures. In accordance with today's graphics pipeline architecture, specialized or private drivers and surface formats are used in connection with very fast graphics accelerators. With direct rasterizer\/processor access to display memory surfaces, \u201cchunks\u201d of surfaces can be moved around according to the specialized surface format, and pulled for processing as efficiency dictates. Thus, the pipeline between display memory surface space and the display itself has been made more efficient. With reference to , an example of the type of modern \u2018chunk\u2019 manipulation is illustrated at a microcosmic level i.e., only 4 squares or chunks of data are illustrated. Private driver  causes chunks through to be grabbed as efficiency dictates and are subsequently manipulated with a rasterizer into an intermediate form , wherein the original image may be unrecognizable. Then, data is moved along the graphics pipeline to render the final image on display , whereby band Bof data may translate to band Bin the displayed image. These mathematical transformations, and timing thereof, have advanced algorithms for determining the efficiency of chunk grabbing and placement. In essence, many images involve redundant data, or data that can be exploited based upon temporal and spatial knowledge, and these algorithms exploit such knowledge to create an extremely efficient and fast graphics data rendering pipeline.","Without the API of the present invention, however, display memory surface space must be set up properly by the developer to work with this privatized format.  illustrates API 340 in accordance with the present invention. The API object of the present invention hides the efficiencies gained from the privatized driver format and rasterizer operation as described above from applications and developers. As far as the developer D writing application is concerned, the display memory surface receives a rectangular image that is then rendered upon the display , when in fact many efficient operations and data manipulations take place behind the scenes. The present invention thus implements API object such that it exposes more of these efficient pipeline operations to the developer D so that developer D need be less concerned with the performance of hidden operations, such as locking and unlocking the privatized formats pursuant to various commands and function calls over which the developer has no control.","Currently, when data is stored in hardware memory, the data is implemented in the privatized format illustrated in FIG. A. When graphics data is stored in main memory, it is stored in the public, more easily understood format. The privatized driver performs this transition. However, previously when graphics data stored in the hardware memory was asked for pursuant to some command or function call, the data was shuffled back to the public format, and then transmitted according to the private format for hardware purposes. Thus, upon an \u2018unlock\u2019 command, the data was copied to system memory in the public format, and then the data was transformed to the privatized format where necessary. Unfortunately, a problem arises wherein the same data may be \u2018unlocked\u2019 from hardware memory according to multiple function calls or commands, and consequently, multiple copies of the same data may be copied to the system memory. The present invention addresses this problem by only allowing data to be copied into system memory space when the developer specifically makes such a request, and thus ensuring that only copies that the developer knows about are resident in the system. Reductions in performance as a result of multiple copies resident in main memory, when unnecessary, are thus avoided. In recognition that the data does not always need to be accessed from system memory space, the present invention thus allows the developer more freedom to command when data is copied to system memory when stored in the privatized format associated with hardware memory.","Optimal Switching of Data Objects among Memory Locations","As described in the background, there are generally two types of containers or data structures that the API presents to a developer for use: one for pixels and one for polygons. Essentially, through passing arguments to the API (placing data into the containers), the developers can manipulate various graphics data structures. Once these containers are filled with data, there are various places, such as system memory or on a 3D card or chip, where this data may stored for further manipulation. The decision as to where to place this data is generally a performance issue. For instance, data for which fast access is not necessary can be stored in system memory, whereas data for which speed of access is the most important may be stored on a chip designed for ultra fast access. It is also sometimes the case that it is desirable to switch data or chunks of data from one memory location to another memory location at different stages of processing.","As illustrated in , in the past, when a developer switched data from one memory location to another, the developer had to code the switching the data i.e., by destroying the data in the old location and recreating the data in the new location. Developer D, after creating a data container  or deleting and recreating a data container  via graphics API , has the decision to make regarding where to place the new data container . While a developer may choose into which of system memory , graphics chip memory  and other memory  data container  is placed, oftentimes, a developer D may write a custom cache managing algorithm for application in an effort to efficiently manage resources. In theory, the cache managing algorithm would try to account for all of the system parameters and attempt to manage memory based upon data location, frequency of accessing or processing the data, and processing times associated with certain locations. However, this is a great inconvenience to developer D who has to custom build each cache managing algorithm for each new application , and who through oversight may not manage resources as efficiently as possible.","As shown in , in accordance with the present invention, the switching of data containers  from one location to another is performed automatically by an API object _cm. Thus, polygon or pixel data objects  are automatically transitioned between memory types such that the switching is seamless. It appears as if the data chunks\/containers  last forever to the developer, whereas in reality, the API hides the fact that the data is being transitioned to optimize system performance. For example, it would in theory be desirable to keep all data on the faster hardware chip memory to process data. However, in reality, there is little room for such on chip data, sometimes as few as a hundred registers. Thus, typically a cache managing algorithm optimizes the tradeoff between host system memory and video memory on the 3D card so as to keep a maximum amount of data for processing in graphics hardware memory without causing overflow. As alluded to above, currently, a developer has to write such a cache managing algorithm for every application that is individually tailored to the programming task at hand. The API  of the present invention hides an optimal cache managing algorithm from developer D so that developer D need not be concerned with the optimal tradeoff of system resources, and so that efficient switching of data can take place \u2018behind the scenes\u2019 simplifying the developer's task. Data containers  are thus efficiently placed in storage to maximize data processing rates, and storage space, whether a data container  is newly created, or switched from one location to another.","Parallel Feeding of Data Objects to 3D Chip for Processing","There are also current issues with respect to the transmission of data containers , either pixel and polygon, to a 3D chip. Currently, when a developer goes about specifying multiple data objects to fill multiple containers, these data objects are fed to the 3D chip one by one, or in a serial fashion. As illustrated in , currently, to feed two data containers and to graphics chip memory , developer D must feed the objects serially to memory . In the figure, t1<t2. At t1, container is retrieved from wherever stored or is created and at t2, it is fed to 3D graphics chip memory . In a typical representation of a pixel with eight bits, x, y, z and w may be utilized for the spatial position of the pixel and four more o1, o2, o3 and o4 may be utilized to represent the orientation of the surface, or color etc. at that position. When the position and location of graphics data is constantly changing, serial transmission or loading of graphics chip memory may not reduce performance significantly. However, when there is redundancy of data e.g., when only the orientation of a pixel changes while the spatial position stays the same, opportunity to exploit the redundancy is lost. Thus, serialized data in container is fed to 3D graphics chip memory  is fed to 3D graphics chip memory . As will become evident, Even when performed very fast, the serial transmission of data containers and is not as fast as a parallel transmission when there is some redundancy or other reason to transmit data in parallel.","Thus, an optimization in accordance with the present invention is that a developer coding an application may specify that multiple of these data objects wherever originated or located at the time of operation, may be fed to the 3D chip simultaneously or in parallel. As illustrated in , both containers and may be fed to 3D graphics chip memory  at the same time. At t1, the data containers and are retrieved or created, and at t2, containers and are fed to 3D graphics chip memory in parallel. While  illustrates the parallel transmission of two data containers to 3D graphics chip memory , any number of data containers up to the maximum storage of 3D graphics chip memory  may be fed in parallel. Thus, in the case of the above example where data is being transmitted to 3D graphics chip memory , wherein the data includes the same spatial position of pixel(s), but only the orientation or color is changing, the data may be loaded into two separate containers and , with a header description understood by the graphics chip and implemented by graphics API , whereby a single copy of the position data can be loaded into container , and the changing color or orientation data may be loaded into container . Thus, when received by the graphics chip , the data is loaded correctly into register space and processed according to the header description. In an exemplary implementation, up to 8 data objects , , etc. may be fed in parallel to the graphics chip . In such a configuration, the exploitation of redundancies may be performed in connection with any of the 8 values utilized to represent a pixel's location, orientation, etc. The present invention thus supplements previous systems in which data could only be fed serially to a graphics chip with parallel feeding of graphics data.","The term graphics data as used herein is intended to cover not only video and\/or audio data in any pre-processed, processed or compressed form, but is additionally intended to cover communications of data of any kind along the graphics pipeline among the developer, the software interface of the present invention and various hardware and\/or software components utilized incident to the graphics system.","The various techniques described herein may be implemented with hardware or software or, where appropriate, with a combination of both. Thus, the methods and apparatus of the present invention, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. In the case of program code execution on programmable computers, the computer will generally include a processor, a storage medium readable by the processor (including volatile and non-volatile memory and\/or storage elements), at least one input device, and at least one output device. One or more programs are preferably implemented in a high level procedural or object oriented programming language to communicate with a computer system. However, the program(s) can be implemented in assembly or machine language, if desired. In any case, the language may be a compiled or interpreted language, and combined with hardware implementations.","The methods and apparatus of the present invention may also be embodied in the form of program code that is transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, or via any other form of transmission, wherein, when the program code is received and loaded into and executed by a machine, such as an EPROM, a gate array, a programmable logic device (PLD), a client computer, a video recorder or the like, the machine becomes an apparatus for practicing the invention. When implemented on a general-purpose processor, the program code combines with the processor to provide a unique apparatus that operates to perform the indexing functionality of the present invention. For example, the storage techniques used in connection with the present invention may invariably be a combination of hardware and software.","While the present invention has been described in connection with the preferred embodiments of the various figures, it is to be understood that other similar embodiments may be used or modifications and additions may be made to the described embodiment for performing the same function of the present invention without deviating therefrom. For example, while exemplary embodiments of the invention are described in the context of graphics data in a PC with a general operating system, one skilled in the art will recognize that the present invention is not limited to the PC, and that a 3D graphics API may apply to any computing device, such as a gaming console, handheld computer, portable computer, etc., whether wired or wireless, and may be applied to any number of such computing devices connected via a communications network, and interacting across the network. Furthermore, it should be emphasized that a variety of computer platforms, including handheld device operating systems and other application specific operating systems are contemplated, especially as the number of wireless networked devices continues to proliferate. Therefore, the present invention should not be limited to any single embodiment, but rather construed in breadth and scope in accordance with the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The system and methods for controlling the algorithmic elements in 3D graphics systems are further described with reference to the accompanying drawings in which:",{"@attributes":{"id":"P-00024","num":"00024"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00025","num":"00025"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00026","num":"00026"},"figref":"FIG. 3A"},{"@attributes":{"id":"P-00027","num":"00027"},"figref":"FIG. 3B"},{"@attributes":{"id":"P-00028","num":"00028"},"figref":"FIG. 4A"},{"@attributes":{"id":"P-00029","num":"00029"},"figref":"FIG. 4B"},{"@attributes":{"id":"P-00030","num":"00030"},"figref":"FIG. 4C"},{"@attributes":{"id":"P-00031","num":"00031"},"figref":"FIG. 4D"},{"@attributes":{"id":"P-00032","num":"00032"},"figref":"FIG. 4E"},{"@attributes":{"id":"P-00033","num":"00033"},"figref":"FIG. 5"},{"@attributes":{"id":"P-00034","num":"00034"},"figref":"FIG. 6A"},{"@attributes":{"id":"P-00035","num":"00035"},"figref":"FIG. 6B"},{"@attributes":{"id":"P-00036","num":"00036"},"figref":"FIG. 7A"},{"@attributes":{"id":"P-00037","num":"00037"},"figref":["FIG. 7B","FIG. 7A"]},{"@attributes":{"id":"P-00038","num":"00038"},"figref":"FIG. 8A"},{"@attributes":{"id":"P-00039","num":"00039"},"figref":"FIG. 8B"},{"@attributes":{"id":"P-00040","num":"00040"},"figref":"FIG. 9A"},{"@attributes":{"id":"P-00041","num":"00041"},"figref":"FIG. 9B"}]},"DETDESC":[{},{}]}
