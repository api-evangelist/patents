---
title: Compiler compiler system with syntax-controlled runtime and binary application programming interfaces
abstract: A compiler compiler system with a design paradigm different from traditional compiler compiler systems in many aspects. First, instead of parsing tree, compiler compiler runtime and binary are designed according to compiler compiler parsing model. Second, any semantics processing is totally separated from syntax processing. Third, the whole compilation process is defined as syntax processing and semantics processing followed by syntax processing performed under compiler compiler management supervision. Fourth, syntax processing has two phases: building compiler compiler runtime, and converting compiler compiler runtime into compiler compiler binary with available option to convert back compiler compiler binary to compiler compiler runtime. Fifth, compiler compiler runtime and binary syntax-controlled APIs are defined in terms of syntax. Sixth, there are formal methods de-compiling compiler compiler runtime and/or binary into original program text accordingly to syntax. Seventh, compiler compiler runtime and binary with their syntax-controlled APIs serve as a multiplatform for obfuscation, security, binary files processing, and program-to-program communication.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08464232&OS=08464232&RS=08464232
owner: 
number: 08464232
owner_city: 
owner_country: 
publication_date: 20101227
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The present invention relates to information technology, and more specifically, to the generation of source code from formal descriptions that can be compiled and linked, creating an executable program.","In applications performing compiler constructions those formal descriptions are defined in terms of context-free grammars. Such tools take a definition of context-free grammar usually in Backus-Naur Form (BNF) and generate a source code of compiler components; and that compiler is able to process source code according to the input grammar definition. Such tools are called compiler compilers or compiler generators. One of the earliest and still most common form of compiler compiler is a parser generator. In this case, the compiler compiler takes a grammar definition and generates parser source code. Also, a traditional compiler compiler generating parser source code from a grammar specification has another component that takes regular expressions and generates a tokenizer capable of processing specified tokens as a sequence of characters.","Compiler compilers as parser and tokenizer generators have been implemented since the late 1960's.","When a generated parser executes its actions during parsing a source program in accordance with a language grammar, it builds some form of parsing tree. A developer who implements a compiler based on conventional compiler compiler technology is responsible for writing code in terms of a parsing tree and some attributes assigned to parsing tree nodes.","An ideal compiler compiler is supposed to take an input grammar specification and generate source code in automatic mode without any further manual procedures. Unfortunately this is far from what current information technology can offer in compiler compiler products available for developers.","According to one embodiment of the present invention, a compiler compiler system includes compiler compiler executable program, compiler compiler management, compiler compiler runtime, compiler compiler binary, compiler compiler generator, compiler compiler source grammar definition language, and compiler compiler parsing model.","In another embodiment of the present invention, parsing results processing is totally separated from any subsequent semantics processing; parsing results are not represented in the form of any parsing tree; and parsing results are represented in the form of compiler compiler runtime that can be formally converted into\/from compiler compiler binary.","In another embodiment of the present invention, target language defined in compiler compiler source grammar definition language as a source file is compiled by compiler compiler executable program, and a target parser and related source files are generated totally automatically providing to the target compiler a basic set of compile and de-compile operations.","In another embodiment of the present invention, the compiler compiler runtime and binary have a common compiler compiler parsing model that considers parsing results to be represented in the form of entities such as Context, Name, Symbol, and Rule and their relationships. That model itself is another embodiment of the present invention, i.e., an alternative view to a traditional parsing tree. The compiler compiler runtime implements the model in efficient form required by parser performing create, update, search, and other low level operations in terms of Context, Name, Symbol, and Rule classes and their relationships. The compiler compiler binary implements the model in efficient form providing read only operations having all data allocated in a vector of Tag instances but still is logically equivalent to the compiler compiler runtime.","In another embodiment of the present invention, a compiler compiler binary is a multiplatform data exchange protocol that allows interaction between programs running on different platforms, running on different operating systems, and built using different programming languages such as C, C++, C#, Java, Objective C, Ruby, Pyton, Perl, and others.","In another embodiment of the present invention, a compiler compiler system can be used for binary files processing. In this case, a corresponding binary file format has to be designed in the form of compiler compiler source grammar definition language specification. After that, a custom convertor from binary file format into compiler compiler runtime format is implemented. Having a compiler compiler runtime built for a binary file with a given format allows all other compiler compiler phases to work automatically without any extra code development.","In another embodiment of the present invention, an input compiler compiler binary can be formally transformed using a transformation algorithm into\/from an output compiler compiler binary providing generic operations for applications such as obfuscation, security\/access control, and content management. The transformation algorithm may be any suitable transformation algorithm typically used for obfuscation, access control, content management, or any other suitable algorithm as appropriate to the application. Consider a credit card account number represented in compiler compiler source grammar definition language as a sequence of digits, each of them represented as an integerToken. Then at the compiler compiler binary level the account number will be represented as a sequence of integerToken tokens. A simple obfuscation algorithm can transform those integerToken token values into different values in the output compiler compiler binary before transmitting output compiler compiler binary over the wire, protecting the account number, with subsequent de-obfuscation on the receiving side. Those algorithms can be changed dynamically also. For security control, compiler compiler binary can be transformed by adding user information with subsequent validation. Consider an audio or video file to be converted into compiler compiler binary. After that conversion, any custom transformations are possible including security control and obfuscation for content protection. Also, any kind of advertising incorporated into compiler compiler binary is possible with programmed options enabling\/disabling ads.","In another embodiment of the present invention, compiler compiler management, generator, runtime and binary source code are compiled into a compiler compiler foundation library that is used in compiler compiler executable program and any other target compiler built by means of a compiler compiler system.","In another embodiment of the present invention, for any compiler compiler source grammar language description, the compiler compiler executable program generates code that is compiled into a generated library and a target compiler executable program is compiled and built with the compiler compiler foundation library and generated library. Built this way, the target compiler executable program has default compile and de-compile operations ready. All semantics processing can be done as independent subsequent operations implemented using a compiler compiler binary application programming interface (API).","In another embodiment of the present invention, the compiler compiler source grammar definition language is defined using the same source grammar definition language that allows a bootstrapping method to be used for implementing compiler compiler executable program using itself. In other words, the compiler compiler generated code for a given meta grammar description is compiled into a generated library and a newly created compiler compiler executable program is compiled and built with compiler compiler foundation library and generated library. Built this way, the newly created compiler executable program has compile and de-compile operations ready. All semantics processing in this case is done as a code generation for parser and related generated source files implemented using compiler compiler binary API. If the abbreviation CCSGDL stands for compiler compiler source grammar definition language, then meta grammar is CCSGDL for CCSGDL.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 1","b":["107","106","105","104","103","102"]},"The input file for parser generator  contains a grammar definition in the form of a few sections such as implementation language declarations, compiler compiler declarations, compiler compiler grammar rules specification, and additional implementation language code. For YACC and GNU BISON the implementation language is C language.","The compiler compiler grammar rules specification is a sequence of individual grammar rules. Each grammar rule is defined as a non-terminal on the left side and a potentially empty sequence of terminals and non-terminals on the right side followed by actions. The grammar rule actions are specified as implementation language code with additional features the compiler compiler can understand and convert into implementation language code during generation. Those additional features are related to attributes attached to parsing tree nodes. Usually those attributes have a prefix \u2018$\u2019 and the compiler compiler acts like a specialized preprocessor that for each rule finds all occurrences of \u2018$\u2019 and generates corresponding implementation language code based on compiler compiler executing environment rules for processing parsing results.","For each grammar rule specified actions are executed every time the parser recognizes that the rule is supposed to be invoked during parsing.","The input file for the tokenizer generator mainly consists of language tokens definitions in the form of token name and token regular expression specifying a valid set of characters comprising the token.","To summarize, the prior art compiler compiler system model forces a compiler developer to define compilation tasks in the form of individual grammar rule actions for the isolated parsing tree context identified with the given rule invocation. As a result, when parsing is done a parsing tree is built along with a custom environment implemented by the compiler developer. Subsequent compilation phases followed by parsing are implemented in terms of that parsing tree and custom environment.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 2","b":["205","201","2","1","202","201","205","202","2","1","201"],"i":["a ","b"]},"Compiler compiler executable program  for meta grammar  performs phase .generating compiler compiler binary  for compiler compiler runtime . The phase .is implemented as a formal procedure that converts compiler compiler runtime  into compiler compiler binary . Compiler compiler executable program  has an option to de-compile meta grammar from generated compiler compiler binary  into a text file (not shown) containing meta grammar executing phase .. This newly de-compiled meta grammar as a text is identical to meta grammar  except for some differences related to supported indentation rules. Compiler compiler executable program  has an option to re-create a compiler compiler runtime that is identical to original compiler compiler runtime  having compiler compiler binary  executing phase .","Compiler compiler executable program  performs phase . creating a compiler compiler generated code  corresponding to meta grammar . The compiler compiler source grammar definition language consists of a grammar name section followed by a sequence of rules where the first rule is also a grammar axiom. As used herein, the grammar name section consists of a single identifier that defines a name of grammar. As an example, when C++ compiler compiler executable program  takes the following meta grammar source file:",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(meta"},{"entry":"\u2002(grammar ::="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u20020 =\u201c METAACTBEG( );\u201d="},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002\u2018(\u2019 grammarNameDef"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003{ rule }"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2002\u2018)\u2019"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u20020 =\u201c METAACTEND( );\u201d="},{"entry":")"},{"entry":"(grammarNameDef ::=\u2003 identifier"},{"entry":")"},{"entry":"(rule ::= \u2003\u2002\u2018(\u2019 nterm \u2018::=\u2019 right \u2018)\u2019"},{"entry":")"},{"entry":"(nterm \u2003\u2003::= \u2003identifier"},{"entry":")"},{"entry":"(right ::= \u2003{ element }"},{"entry":")"},{"entry":"(element ::=\u2003\u2003 identAlt | alternative | identMiss | iteration | action"},{"entry":")"},{"entry":"(action \u2003\u2003::=\u2003 integerToken \u2018=\u2019 { stringToken } \u2018=\u2019"},{"entry":")"},{"entry":"(actions ::= \u2018=\u2019 { action } \u2018=\u2019"},{"entry":")"},{"entry":"(identAlt ::= ntermtermact { Altpart }"},{"entry":")"},{"entry":"(Altpart ::= \u2002\u2018|\u2019 ntermtermact"},{"entry":")"},{"entry":"(ntermtermact \u2002::=\u2003\u2003 ntermterm [ actions ]"},{"entry":")"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(ntermterm","::= \u2003\u2002nterm | termToken"]},{"entry":")"},{"entry":["(alternative","::= \u2003\u2002\u2018(\u2019 identAlt \u2018)\u2019"]},{"entry":")"},{"entry":["(identMiss","::= \u2003\u2002\u2018[\u2019 identAlt \u2018]\u2019"]},{"entry":")"},{"entry":["(iteration","::= \u2003\u2002\u2018{\u2019 iterItemact iterItems \u2018}\u2019"]},{"entry":")"},{"entry":["(iterItems","::= \u2003\u2002{ altIterItem }"]},{"entry":")"},{"entry":["(altIterItem","::= \u2003\u2002\u2018|\u2019 iterItemact"]},{"entry":")"},{"entry":["(iterItemact","::=\u2003\u2002 iterItem [ actions ]"]},{"entry":")"},{"entry":["(iterItem","::= \u2003\u2002nterm | maybeNterm"]},{"entry":")"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(maybeNterm \u2003::= \u2003\u2018<\u2019 nterm \u2018>\u2019"},{"entry":")"},{"entry":")"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["2","3"]},"metaGenerator.h","metaKeyWordDefinition.h","metaParser.h","metaGenerator.cc","metaKeyWordDefinition.cc","metaParser.cc","metaMakeGenerators.cc","Note, that the \u2018meta\u2019 prefix in file names corresponds to the grammar name\u2014the first section identifier in source grammar definition language. Note also that","0=\u201cMETAACTBEG( );\u201d=","0=\u201cMETAACTEND( );\u201d=","are used as a special macro substitution actions defined in form of integer number followed by sequence of string literals enclosed in \u2018=\u2019 and \u2018=\u2019. Further elements and rules are explained in the following paragraphs.","The compiler compiler source grammar definition language elements such as \u2018(\u2019 and \u2018)\u2019 are grammar terminals defined as a string literal with enclosed single quotes.","The compiler compiler source grammar definition language element such as","{rule}","is BNF extension called iteration meaning that enclosed by { and} non-terminal is actually may occur zero or any other number of times.","Note, that, e.g., rule",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(iterationExample ::= { element } )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(iterationExample ::= element iterationExample )"]},{"entry":[{},"(iterationExample ::= )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0076","num":"0075"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(rule ::= \u2003\u2003\u2018(\u2019 nterm \u2018::=\u2019 right \u2018)\u2019"]},{"entry":[{},"\u2002)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(nterm \u2003\u2003::=\u2003 identifier"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0080","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(right ::=\u2003 { element }"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0082","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(element ::=\u2003\u2003 identAlt | alternative | identMiss | iteration | action"},{"entry":")"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":[{},{},{},{},{},{},{}]},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(action \u2003\u2003::=\u2003 integerToken \u2018=\u2019 { stringToken } \u2018=\u2019"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(actions ::= \u2018=\u2019 { action } \u2018=\u2019"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0088","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(identAlt ::= ntermtermact { Altpart }"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0090","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(Altpart ::=\u2003 \u2018|\u2019 ntermtermact"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0092","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(ntermtermact\u2003::=\u2003\u2003ntermterm [ actions ]"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0093","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(ommitedElementExample ::= A [ W ])"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0094","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(ommitedElementExample ::= A Welement )"]},{"entry":[{},"(Welement::= W )"]},{"entry":[{},"(Welement::= )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0096","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(ntermterm ::=\u2003\u2003nterm | termToken"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":[{},{}]},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0098","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(alternative ::=\u2003\u2003\u2018(\u2019 identAlt \u2018)\u2019"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0100","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(identMiss\u2002::=\u2003\u2003\u2018[\u2019 identAlt \u2018]\u2019"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0102","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(iteration\u2003::=\u2003\u2003\u2018{\u2019 iterItemact iterItems \u2018}\u2019"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0104","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(iterItems\u2003::=\u2003\u2003{ altIterItem }"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0106","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(altIterItem ::=\u2003\u2003\u2018|\u2019 iterItemact"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0108","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(iterItemact ::=\u2003\u2003iterItem [ actions ]"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0110","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(iterItem\u2003\u2003::=\u2003\u2003nterm | maybeNterm"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"The compiler compiler source grammar definition language rule",{"@attributes":{"id":"p-0112","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(maybeNterm\u2003\u2003::=\u2003\u2003\u2018<\u2019 nterm \u2018>\u2019"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0113","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(anotherIterationExampe :: = { A | B | <X> | <Z> } )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0114","num":"0113"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(anotherIterationExampe :: = elem anotherIterationExampe )"]},{"entry":[{},"(anotherIterationExampe :: = )"]},{"entry":[{},"(elem ::= A | B | X | Z )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"If phase . is performed for newly compiler compiler generated code corresponding to meta grammar , then a new default version of compiler compiler executable program  is created with default \u2018metaGenerator.cc\u2019 that has empty implementation. When that default version of compiler compiler executable program  is running it has all phase ., phase ., phase ., phase ., and phase .available to be executed.","The phase . is actually implemented in the \u2018<prefix>Generator.cc\u2019 file. In case of the C++ compiler compiler system mentioned above, seven files are created automatically without any manual intervention from the developer, not only for meta grammar but also for any other grammar defined in the compiler compiler source grammar definition language. In other words, compiler compiler semantics processing is performed by phase . and it is done by the \u2018<prefix>Generator.cc\u2019 file. That code is actually implemented on top of the generated initial default version.",{"@attributes":{"id":"p-0117","num":"0116"},"figref":"FIG. 3","b":["205","301","3","1","302","205","302","3","1","301"],"i":["a ","b"]},"Compiler compiler executable program  performs phase .generating compiler compiler binary  for target language grammar compiler compiler runtime . The phase .is implemented as a formal procedure that converts compiler compiler runtime  into compiler compiler binary . Compiler compiler executable program  has an option to de-compile target language grammar from generated compiler compiler binary  into a text file containing compiler compiler source grammar definition language source text defining target language grammar executing phase .. This newly de-compiled target language grammar as a text is identical to target language grammar  except for some differences related to supported indentation rules. Compiler compiler executable program  has an option to create compiler compiler runtime  having compiler compiler binary  executing phase .","Compiler compiler executable program  performs phase . creating compiler compiler generated code  corresponding to target language grammar  directly from . When C++ compiler compiler executable program  takes target language grammar source file  the following C++ source files are generated:","<Prefix>Generator.h","<Prefix>KeyWordDefinition.h","<Prefix>Parser.h","<Prefix>Generator.cc","<Prefix>KeyWordDefinition.cc","<Prefix>Parser.cc","<Prefix>MakeGenerators.cc","Note, that the <Prefix> prefix in file names corresponds to the grammar name\u2014the first section identifier in source grammar definition language.","If phase . is performed for newly compiler compiler generated code corresponding to target language grammar , then a new default version of target language compiler executable program  is created with a default \u2018<Prefix>Generator.cc\u2019 that has empty implementation. When that default version of target language compiler executable program  is running, it has all phase ., phase ., phase ., phase ., and phase .available to be executed. The phase . is actually implemented in \u2018<Prefix>Generator.cc\u2019 file corresponding to target language grammar . In the case of the C++ compiler compiler system mentioned above, seven files are created automatically without any manual intervention from the developer, not only for meta grammar but also for any other grammar defined in the compiler compiler source grammar definition language. In other words, compiler compiler semantics processing is performed by phase ., and it is done by the \u2018<Prefix>Generator.cc\u2019 file corresponding to the target language compiler. That code is implemented on top of the generated initial default version with no manual actions. So, phase . performs the same steps as phase ., but phase . is related to semantics processing of the target language compiler.",{"@attributes":{"id":"p-0128","num":"0127"},"figref":["FIG. 4","FIG. 3","FIG. 2"],"b":["305","305","401","4","1","402","401","305","205","305","402","4","1","401"],"i":["a ","b"]},"Target language compiler executable program  performs phase .generating compiler compiler binary  for compiler compiler runtime . Phase .is implemented as a formal procedure that converts compiler compiler runtime  into compiler compiler binary . Target language compiler executable program  has an option to de-compile source text from generated compiler compiler binary  into a source text file in accordance with target language grammar  executing phase .. This newly de-compiled target language source text is identical to original target language source text  except for some differences related to supported indentation rules. The target language compiler executable program  has an option to create compiler compiler runtime  having compiler compiler binary  executing phase .","The target language compiler executable program  performs phase ., a target compiler semantics processing  based on compiler compiler binary .","To summarize , , and , compiler compiler management, generator, runtime and binary source code are compiled into a compiler compiler foundation library that is used when compiler compiler executable program compiles compiler compiler source grammar definitions and when target compiler executable program compiles target language programs.",{"@attributes":{"id":"p-0132","num":"0131"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0133","num":"0132"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0134","num":"0133"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0135","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#ifdef_CPPCC_TAG_32BITS"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef unsigned long","UnsignedTag;"]},{"entry":[{},"typedef long\u2003\u2003Tag;"]},{"entry":[{},"typedef float","Real;"]},{"entry":[{},"struct TypeInstance {"]},{"entry":[{},"\u2003UnsignedTag","symbolID:10;"]},{"entry":[{},"\u2003UnsignedTag","ruleID:22;"]},{"entry":[{},"};"]},{"entry":[{},"#else"]},{"entry":[{},"typedef unsigned long long","UnsignedTag;"]},{"entry":[{},"typedef long long","Tag;"]},{"entry":[{},"typedef double","Real;"]},{"entry":[{},"struct TypeInstance {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003UnsignedTag","symbolID:16;"]},{"entry":[{},"\u2003UnsignedTag","ruleID:48;"]},{"entry":[{},"};"]},{"entry":[{},"#endif"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Along with Tag, UnsignedTag, Real, and TypeInstance are defined the same way. For 32 bit computer architecture all those types occupy a four-byte word; for 64 bit computer architecture all those types occupy an eight-byte word. TypeInstance instance in many cases is represented as a Tag value with subsequent fields packing\/unpacking operations.","The Parser class instantiates some simple data members such as file name as a string class instance, as well as Boolean flags such as debugging flag, XML token indicator flag, etc. . . . shown in .","The Parser class shown on  also instantiates other important members such as runtime_ of type SyntaxControlledRuntime, a binary_ of type SyntaxControlledBinary, a tokenizer of type Tokenizer_, and a generator_ of type Generator.",{"@attributes":{"id":"p-0139","num":"0138"},"figref":"FIG. 8"},"As described in the following paragraphs with reference to , the compiler compiler runtime syntax-controlled API, including various inner classes, is designed to perform the following set of operations to be invoked from any parser generated by compiler compiler system:","Create new \u2018Context\u2019 instance returning \u2018ContextID\u2019.","Create new \u2018Rule\u2019 instance for the current \u2018Context\u2019 instance having \u2018SymbolID\u2019, returning \u2018Tag\u2019 instance actually mapped to \u2018TypeInstance\u2019 class instance with packed \u2018symbolID\u2019 and \u2018ruleID\u2019.","Return \u2018Symbol\u2019 instance reference for the current \u2018Context\u2019 instance having \u2018SymbolID\u2019.","Return \u2018Rule\u2019 instance for the current \u2018Context\u2019 instance having \u2018Tag\u2019 instance actually mapped to \u2018TypeInstance\u2019 class instance with packed \u2018symbolID\u2019 and \u2018ruleID\u2019.","Modify \u2018Rule\u2019 instance dynamic part for the current \u2018Context\u2019 instance having \u2018Rule\u2019 instance reference and vector reference representing dynamic part.","Modify \u2018Rule\u2019 instance fixed part for the current \u2018Context\u2019 instance having \u2018Rule\u2019 instance reference and vector reference representing fixed part.","Create identifier representation having string representing identifier and returning identifier index.",{"@attributes":{"id":"p-0148","num":"0147"},"figref":"FIG. 9"},"Consider a definition like this:","int z, a, b, w;","If a compiler builds a map from a string representing object name to object instance, then it would be easy and efficient to manipulate those objects by finding them by name. However, the original order of z, a, b, w would disappear since in the map they are ordered differently. MapVectorContainer is designed to provide both effective operations by name and preserving original sequence in the way objects were originally defined having direct access by name (object key) and by index (object sequential number).","On  MapVectorContainer template class takes two formal arguments, <D> representing object type and <K> representing object key type. MapVectorContainer defines three inner types such as MapVectorContainer::Map, MapVectorContainer::Vector, and MapVectorContainer::Data. The MapVectorContainer::Map type is defined as std::map<K, Tag>. The MapVectorContainer::Vector Map type is defined as std::vector<K>. MapVectorContainer::Data type is defined as std::vector<D>. MapVectorContainer template class instantiates name2index_instance of type MapVectorContainer::Map, index2name_instance of type MapVectorContainer::Vector, and index2data_instance of type MapVectorContainer::Data.",{"@attributes":{"id":"p-0152","num":"0151"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0153","num":"0152"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0154","num":"0153"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0155","num":"0154"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0156","num":"0155"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0157","num":"0156"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0158","num":"0157"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0159","num":"0158"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0160","num":"0159"},"figref":["FIG. 18","FIG. 18"]},"Logically each compiler compiler runtime context maintains its own collection of symbols ordered by symbolID with direct access by symbolID.","Logically each compiler compiler runtime symbol maintains its own collection of rules representing each rule invocation during parsing for a given symbol.","Actually, compiler compiler runtime logical view and compiler compiler binary logical view are the same since compiler compiler runtime and compiler compiler binary are interchangeable. However, compiler compiler runtime is designed to be an effective environment for processing parsing results during parsing itself, and compiler compiler binary is designed to be an effective environment for processing final parsing results in read only mode serving as a multiplatform interchange format.","In other words,  shows one form of compiler compiler parsing model with entities such as Context, Name, Symbol, and Rule with their relationships.","As described in the following paragraphs with reference to , the compiler compiler binary syntax-controlled API, including various inner classes, is designed to perform the following set of operations to be invoked from any application responsible for any semantics processing based on compiler compiler system:","Get const pointer to \u2018SyntaxControlledBinary::Context::BinaryHeader\u2019.","Get pointer to \u2018SyntaxControlledBinary::Context::BinaryHeader\u2019.","Get identifier as a const char* having its sequential number.","Get identifier as a const char* having its alphabetic number.","Get identifier sequential number having its alphabetic number.","Get pointer to \u2018SyntaxControlledBinary::Context::BinarySymbol\u2019 having symbol sequential number.","Get pointer to \u2018SyntaxControlledBinary::Context::BinarySymbol\u2019 having \u2018SymbolID\u2019.","Get pointer to char having offset in \u2018memory_\u2019 data member.","Get const pointer to char having offset in \u2018memory_\u2019 data member.","Return aligned size of anything to \u2018Tag\u2019 size with given initial size.","Get pointer to \u2018SyntaxControlledBinary::Context::BinaryRule\u2019 having \u2018SyntaxControlledBinary::Context:: BinarySymbol\u2019 instance pointer and rule instance number given for that symbol.","Populate \u2018SyntaxControlledBinary::Context::BinaryRuleContent\u2019 by its reference having \u2018SyntaxControlledBinary::Context:: BinarySymbol\u2019 instance pointer and \u2018SyntaxControlledBinary::Context::BinaryRule\u2019 instance pointer.","Get rule fixed part as a pointer to \u2018Tag\u2019 having \u2018SyntaxControlledBinary::Context::BinaryRule\u2019 instance pointer.","Get rule fixed part as a reference to \u2018TypeInstance\u2019 having \u2018SyntaxControlledBinary::Context::BinaryRule\u2019 instance pointer and rule instance number.","Get rule dynamic part as a pointer to \u2018Tag\u2019 having \u2018SyntaxControlledBinary::Context::BinaryRule\u2019 instance pointer.","Get rule dynamic part as a reference to \u2018TypeInstance\u2019 having \u2018SyntaxControlledBinary::Context::BinaryRule\u2019 instance pointer and rule instance number.","Write binary into file having file name.","Read binary from file having file name.",{"@attributes":{"id":"p-0184","num":"0183"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0185","num":"0184"},"figref":"FIG. 20"},"SyntaxControlledBinary shown in  can be converted into a single binary object specified by the following Backus-Naur Form (BNF):","(1) SyntaxControlledBinary::=header catalog elements","(2) header::=headerSize headerTotal headerCatalogOffset headerElementsOffset","(3) headerSize::=integerToken","(4) headerTotal::=integerToken","(5) headerCatalogOffset::=integerToken","(6) headerElementsOffset::=integerToken","(7) catalog::={catalogElement}","(8) catalogElement::=catalogElementContextID catalogElementOffset catalogElementSize","(9) catalogElementContextID::=integerToken","(10) catalogElementOffset::=integerToken","(11) catalogElementSize::=integerToken","(12) elements::=SyntaxControlledBinaryContext)","(13) SyntaxControlledBinaryContext::=","BinaryContextHeader","BinaryContextSequentialNames","BinaryContextAlphabeticalNames","BinaryContextNames","BinaryContextSymbols","BinaryContextRules","BinaryContextRuleElements","(13.1) BinaryContextHeader::=","BinaryContextHeaderLength","BinaryContextHeaderCurrent","BinaryContextHeaderAxiom","BinaryContextHeaderNumberOfIdentifiers","BinaryContextHeaderStartOfIdentifiersMap","BinaryContextHeaderNumberOfSymbol","BinaryContextHeaderStartOfSymbols","(13.1.1) BinaryContextHeaderLength::=integerToken","(13.1.2) BinaryContextHeaderCurrent::=integerToken","(13.1.3) BinaryContextHeaderAxiom::=integerToken","(13.1.4) BinaryContextHeaderNumberOfIdentifiers::=integerToken","(13.1.5) BinaryContextHeaderStartOfIdentifiersMap::=integerToken","(13.1.6) BinaryContextHeaderNumberOfSymbol::=integerToken","(13.1.7) BinaryContextHeaderStartOfSymbols::=integerToken","(13.2) BinaryContextSequentialNames::={BinaryContextSequentionalNameOffset}","(13.2.1) BinaryContextSequentionalNameOffset::=integerToken","(13.3) BinaryContextAlphabeticalNames::=BinaryContextAlphabeticalName)","(13.3.1) BinaryContextAlphabeticalName::=","BinaryContextAlphabeticalNameOffset","BinaryContextAlphabeticalNameID","(13.3.1.1) BinaryContextAlphabeticalNameOffset::=integerToken","(13.3.1.2) BinaryContextAlphabeticalNameID::=integerToken","(13.4) BinaryContextNames::=BinaryContextNameAligned","(13.4.1) BinaryContextNameAligned::=stringToken","(13.5) BinaryContextSymbols::=BinaryContextSymbol","(13.5.1) BinaryContextSymbol::=","BinaryContextSymbolNumberOfRuleInstances","BinaryContextSymbolID","BinaryContextSymbolStart","(13.5.1.1) BinaryContextSymbolNumberOfRuleInstances::=integerToken","(13.5.1.2) BinaryContextSymbolID::=integerToken","(13.5.1.3) BinaryContextSymbolStart::=integerToken","(13.6) BinaryContextRules::={BinaryContextRule}","(13.6.1) BinaryContextRule::=","BinaryContextRuleFixed","BinaryContextRuleDynamic","BinaryContextRuleStart","(13.6.1.1) BinaryContextRuleFixed::=integerToken","(13.6.1.2) BinaryContextRuleDynamic::=integerToken","(13.6.1.3) BinaryContextRuleStart::=integerToken","(13.7) BinaryContextRuleElements::={BinaryContextRuleElement}","(13.7.1) BinaryContextRuleElement::=","BinaryContextRuleElementFixed\\BinaryContextRuleElementDynamic","(13.7.1.1) BinaryContextRuleElementFixed::=integerToken","(13.7.1.2) BinaryContextRuleElementDynamic::=integerToken where memory_data member of SyntaxControlledBinary::BinaryContext class is represented by rule (13) SyntaxControlledBinaryContext.","Note, that this BNF is extended by special extensions such as iteration when some non-terminal is enclosed with \u2018{\u2019 and \u2018}\u2019 meaning that that non-terminal can occur zero or unlimited number of times; alternative when some non-terminals are separated by \u2018|\u2019 meaning that one of them can occur; \u2018integerToken\u2019 is used to represent 4 bytes integer or 8 bytes integer; \u2018stringToken\u2019 is used to represent string literal properly aligned. So, BinaryContextRuleElements::={BinaryContextRuleElement} is equivalent to\n\nBinaryContextRuleElements::=BinaryContextRuleElement BinaryContextRuleElements BinaryContextRuleElements::=\n\nSo,\n\nBinaryContextRuleElement::=\n","BinaryContextRuleElementFixed\\BinaryContextRuleElementDynamic","is equivalent to","BinaryContextRuleElement::=BinaryContextRuleElementFixed","BinaryContextRuleElement::=BinaryContextRuleElementDynamic",{"@attributes":{"id":"p-0212","num":"0211"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0213","num":"0212"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0214","num":"0213"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0215","num":"0214"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0216","num":"0215"},"figref":["FIG. 25","FIG. 7"]},{"@attributes":{"id":"p-0217","num":"0216"},"figref":["FIG. 26","FIG. 18"]},{"@attributes":{"id":"p-0218","num":"0217"},"figref":"FIG. 27"},"The LineReader class is an abstract base class. The FileLineReader and StringLineReader classes are derived from LineReader. The FileLineReader class provides implementation for reading source text of compiled program from a file, it also maintains the corresponding listing as a file. The StringLineReader class provides implementation for reading source text of compiled program from a std::string as a sequence of lines separated by a given delimiter, it also maintains the corresponding listing. Any other line reader classes can be implemented as derived from LineReader abstract base class.","The LineReader class comprises the following pure virtual functions or their equivalents:","\u2018get\u2019 returning argument by reference, the next line as a string to be processed by \u2018Tokenize\u2019.","\u2018put\u2019 having const reference to string to be put into listing by \u2018Tokenizer\u2019.","boolean \u2018hasListing\u2019 returning true if listing is maintained.","boolean \u2018isEof\u2019 indicating end of source lines to be processed.","\u2018start\u2019 having file name and listing file name.","\u2018start\u2019 having const reference to string to be processed as a sequence of lines and boolean flag if listing is required.","The Language class is an abstract base class. The LanguageMeta and LanguageXML classes are derived from the Language class. The LanguageMeta class implements tokens set and Language interface for compiler compiler source grammar definition language. The LanguageXML class implements tokens set and Language interface for XML type of languages.",{"@attributes":{"id":"p-0228","num":"0227"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0229","num":"0228"},"figref":"FIG. 29"},"The \u2018Language\u2019 abstract class comprises the following pure virtual functions or their equivalents from the set of functions defining the ILanguage interface:","\u2018getCharacter\u2019 populating \u2018Tokenizer\u2019 \u2018currentCharacter\u2019.","\u2018getIdentifier\u2019 populating \u2018Tokenizer\u2019 \u2018currentIdentifier\u2019 and \u2018currentKeyWord\u2019.","\u2018getNumeric\u2019 populating \u2018Tokenizer\u2019 \u2018currentDoubleValue\u2019 or \u2018currentIntegerValue\u2019 depending on token value, and \u2018Tokenizer\u2019 \u2018currentKeyWord\u2019.","\u2018getString\u2019 populating \u2018Tokenizer\u2019 \u2018currentStringValue\u2019 and \u2018currentKeyWord\u2019.","\u2018getNextToken\u2019 populating \u2018Tokenizer\u2019 next token and \u2018currentKeyWord\u2019.","In addition, the \u2018Language\u2019 class comprises generic functions common to all languages as derived classes from the \u2018Language\u2019 class; those generic functions are:","\u2018populateTerminals\u2019 populating \u2018SymbolID\u2019 for each token defined in \u2018terminalTokens_\u2019, \u2018terminalKeyWords_\u2019, and \u2018nonTerminals_\u2019.","\u2018isDefinedToken\u2019 returning true or false depending on check of all tokens defined in \u2018terminalTokens_\u2019 if that token matches the sequence of characters starting from \u2018Tokenizer\u2019 \u2018currentCharacter\u2019.","\u2018isKeyWord\u2019 returning true or false depending on check if a given formal parameter is defined in corresponding name to index container of \u2018terminalKeyWords_\u2019.","\u2018setNextToken\u2019 setting \u2018Tokenizer\u2019 \u2018currentKeyWord\u2019 by performing loop for each token size \u2018k\u2019 starting from maximum size while \u2018k\u2019 greater than zero reducing \u2018k\u2019 by one","by performing loop for each token \u2018t\u2019 in \u2018terminalTokens_\u2019","checking if \u2018k\u2019 equals to token \u2018t\u2019 size and token \u2018t\u2019 is Token predicate is true then executing token \u2018t\u2019 \u2018flushToken\u2019 function (see description of the Token class below); setting \u2018Tokenizer\u2019 \u2018currentKeyWord\u2019 as token \u2018t\u2019 \u2018SymbolID\u2019.","\u2018getToken\u2019 having a formal argument as an input with token \u2018SymbolID\u2019 returning corresponding reference to \u2018Token\u2019 class instance.","\u2018skipToken\u2019 having a first formal argument as an input with token \u2018SymbolID\u2019 and a second formal argument as an output with token reference to \u2018Tag\u2019 actually mapped to \u2018TypeInstance\u2019 class instance with token \u2018SymbolID\u2019 and token \u2018RuleID\u2019; performing call to \u2018getToken\u2019 with the first formal argument as an input with token \u2018SymbolID\u2019 getting reference \u2018t\u2019 to \u2018Token\u2019 class instance; performing call to method \u2018skipToken\u2019 with the first formal argument as an input with token \u2018SymbolID\u2019 and the second formal argument as an output with token reference to \u2018Tag\u2019; performing call to \u2018getNextToken\u2019.","\u2018getTerminalString\u2019 setting \u2018Tokenizer\u2019 \u2018currentTerminalStringValue\u2019 and related \u2018Tokenizer\u2019 data members processing sequence of input characters enclosed with single quotes representing language defined terminal as a sequence of characters enclosed with single quotes.",{"@attributes":{"id":"p-0244","num":"0243"},"figref":"FIG. 30"},"The Token class is an abstract base class that is derived from abstract base class IToken that consists of a set of pure virtual functions defining its interface. The Token class has a reference tokenizer_ to Tokenizer class instance. The Token class has a data member symbol_ that is actually corresponds to SymbolID of Symbol related to the given Token. The Token class has data members token_ and name_ of std::string type.","The \u2018Token\u2019 class comprises pure virtual functions or their equivalents from the set of pure virtual functions defining the IToken interface, such as:","\u2018isToken\u2019 predicate returning true or false depending on if \u2018Tokenizer\u2019 sequence of characters starting from \u2018Tokenizer\u2019 \u2018currentCharacter\u2019 matches given token \u2018token_\u2019 data member.","\u2018flushToken\u2019 checking if \u2018isToken\u2019 predicate returns true, then advancing \u2018Tokenizer\u2019 \u2018currentCharacter\u2019 to the next one beyond the given token sequence of characters; and executing \u2018Tokenizer\u2019 \u2018flushBlanks\u2019 function skipping white space characters such as blank, tabulation, etc.",{"@attributes":{"id":"p-0249","num":"0248"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0250","num":"0249"},"figref":"FIG. 32"},"\u2018decompileRuntime\u2019 having file name as a formal argument where runtime content is de-compiled.","\u2018decompileBinary\u2019 having file name as a formal argument where binary content is de-compiled.","\u2018generateFromRuntime\u2019 having file name as a formal argument that is used to generate output based on runtime content.","\u2018generateFromBinary\u2019 having file name as a formal argument that is used to generate output based on binary content.","The Generator class implements IGenerator interface; i.e., implements the foregoing functions or their equivalents. The Generator class has a reference parser_ to the Parser instance. The Generator class has a data member tokenizerSet_ of enumerated type LanguageTokenizerSet. The Generator class instantiates runtime_ as GeneratorRuntime* and binary_ as GeneratorBinary*. Pointer to GeneratorRuntime, GeneratorRuntime*, and Pointer to GeneratorBinary, GeneratorBinary*, will be replaced by std::shared_ptr<GeneratorRuntime> and","std::shared_ptr<GeneratorBinary> when std::shared_ptr will be widely available as C++ standard library class. The GeneratorBinary class is a base class derived from IBinaryGenerator abstract base class that consists of a set of pure virtual functions defining its interface. The GeneratorRuntime class is a base class derived from IRuntimeGenerator abstract base class that consists of a set of pure virtual functions defining its interface.",{"@attributes":{"id":"p-0257","num":"0256"},"figref":"FIG. 33"},"The IBinaryGenerator abstract base class consists of the following pure virtual functions or their equivalents:","makeAlignment having formal argument token as a reference to Token returning void;","decompile having formal argument filename as a const reference to string returning void.","generate having formal argument filename as a const reference to string returning void.","The IRuntimeGenerator abstract base class consists of the following pure virtual functions or their equivalents:","makeAlignment having formal argument token as a reference to Token returning void;","decompile having formal argument filename as a const reference to string returning void;","generate having formal argument filename as a const reference to string returning void.","The IRuntimeGeneratorStyle abstract base class consists of the following pure virtual functions or their equivalents:","makeAlignment having formal argument token as a reference to Token returning void.","The IBinaryGeneratorStyle abstract base class consists of the following pure virtual functions or their equivalents:","makeAlignment having formal argument token as a reference to Token returning void.",{"@attributes":{"id":"p-0270","num":"0269"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0271","num":"0270"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0272","num":"0271"},"figref":["FIG. 36","FIG. 36","FIG. 4"],"b":["36","1","36","1","3603","3605"],"i":["c ","d "]},{"@attributes":{"id":"p-0273","num":"0272"},"figref":["FIG. 37","FIG. 37","FIG. 36","FIG. 37"]},"While the invention has been described with respect to certain preferred embodiments, as will be appreciated by those skilled in the art, it is to be understood that the invention is capable of numerous changes, modifications and rearrangements and such changes, modifications and rearrangements are intended to be covered by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 34"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 35"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 37"}]},"DETDESC":[{},{}]}
