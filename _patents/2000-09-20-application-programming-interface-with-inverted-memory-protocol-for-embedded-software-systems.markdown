---
title: Application programming interface with inverted memory protocol for embedded software systems
abstract: A system and method is provided for enabling the reuse of algorithms in multiple application frameworks with no alterations required of the algorithm once it is developed. An inverted memory allocation mechanism enables various algorithm modules to be integrated into a single application without modifying the source code of the algorithm modules. An algorithm module is designed in a manner that renders the algorithm module reentrant within a preemptive environment. Each data access instruction of the algorithm module is coded in a manner that renders the algorithm module and all of the data access instructions relocatable. A memory interface is provided within the algorithm module that supports both design-time object instantiation and dynamic object instantiation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06968438&OS=06968438&RS=06968438
owner: Texas Instruments Incorporated
number: 06968438
owner_city: Dallas
owner_country: US
publication_date: 20000920
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","REFERENCE TO COMPUTER PROGRAM LISTING APPENDIX ON COMPACT DISC","TECHNICAL FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application claims priority to provisional application Ser. No. 60\/154,777, provisional application Ser. No. 60\/154,657, and provisional application Ser. No. 60\/154,656, filed on Sep. 20, 1999 and is related to U.S. Pat. No. 6,546,477 and application Ser. No. 09\/667,393.","Appendix A containing a computer program listing is submitted on two identical compact discs. Each compact disc contains the file \u201cTI-29688 APP A ASCII.txt.\u201d The compact disc file was created on Jan. 14, 2005 and is 40 KBytes in size. The compact disc Appendix A is hereby incorporated herein by reference.","The present invention relates to embedded software systems, and more particularly to component and object-oriented programming models for embedded systems.","Advances in digital signal processor (DSP) technology in the application areas of telephony, imaging, video, and voice are often results of years of intensive research and development. For example, algorithm standards for telephony have taken years to develop. The implementation of these DSP algorithms is often very different from one application system to another because systems have, for example, different memory management policies and I\/O handling mechanisms. Because of the lack of consistent system integration or programming standards, it is generally not possible for a DSP implementation of an algorithm to be used in more than one system or application without significant reengineering, integration, and testing.","Digital Signal Processors (DSPs) are often programmed like \u201ctraditional\u201d embedded microprocessors. That is, they are programmed in a mix of C and assembly language, directly access hardware peripherals, and, for performance reasons, almost always have little or no standard operating system support. Thus, like traditional microprocessors, there is very little use of Commercial Off-the-Shelf (COTS) software components for DSPs.","However, unlike general-purpose embedded microprocessors, DSPs are designed to run sophisticated signal processing algorithms and heuristics. For example, they may be used to detect DTMF digits in the presence of noise, to compress toll quality speech by a factor of 20, or for speech recognition in a noisy automobile traveling at 65 miles per hour.","Such algorithms are often the result of many years of doctoral research. However, because of the lack of consistent standards, it is not possible to use an algorithm in more than one system without significant reengineering. Since few companies can afford a team of DSP PhDs and the reuse of DSP algorithms is so labor intensive, the time-to-market for a new DSP-based product is measured in years rather than months.","Most modern DSP system architectures can be logically partitioned into algorithms, core run-time support and a framework that integrates the algorithms with the hardware and software comprising the system. The framework defines a component model with which the algorithms must comply. The framework includes a device independent I\/O sub-system and specifies how algorithms interact with this sub-system. For example, does the algorithm call functions to request data or does the framework call the algorithm with data buffers to process? The framework also defines the degree of modularity within the application; i.e., what components can be replaced, added, removed, and when components can be replaced (compile time, link time, or real-time). Unfortunately, for performance reasons, many DSP system architectures do not enforce a clear line between algorithm code and the framework. Thus, it is not possible to easily use an algorithm in more than one system.","Even within the telephony application space, there are a number of different frameworks available and each is optimized for a particular application segment; e.g., large volume client-side products and low volume high-density server-side products. Given the large number of incompatibilities between these various frameworks and the fact that each framework has enjoyed success in the market, any model for algorithm reuse should ideally make few requirements on existing frameworks.","Careful inspection of the various frameworks in use reveals that, at some level, they all have \u201calgorithm components\u201d. While there are differences in each of the frameworks, the algorithm components share many common attributes: algorithms are C callable; algorithms are reentrant; algorithms are independent of any particular I\/O peripheral; and, algorithms are characterized by their memory and instruction processing rate (MIPS) requirements. In approximately half of the known available frameworks, algorithms are also required to simply process data passed to the algorithm. The others assume that the algorithm will actively acquire data by calling framework-specific hardware independent I\/O functions. Generally, algorithms are designed to be independent of the I\/O peripherals in the system.","Given the similarities between the various frameworks, a need has arisen to create a model permitting simple reuse at the level of the algorithm. Moreover, there is real benefit to the framework vendors and system integrators from such a model: algorithm integration time will be reduced; it will be possible to easily comparison shop for the \u201cbest\u201d algorithm; and more algorithms will be available.","A huge number of DSP algorithms are needed in today's marketplace, including modems, vocoders, speech recognizers, echo cancellation, and text-to-speech. It is not easy (or even possible) for a product developer who wants to leverage this rich set of algorithms to obtain all the necessary algorithms from a single source. On the other hand, integrating algorithms from multiple vendors is often impossible due to incompatibilities between the various implementations. To break this catch-22, algorithms from different vendors must inter-operate.","Dozens of distinct third-party DSP frameworks exist in the telephone vertical market alone. Each vendor has hundreds and sometimes thousands of customers. Yet, no one framework dominates the market. To achieve the goal of algorithm reuse, the same algorithm must be usable in all frameworks with minor impact on the framework implementation.","Marketplace fragmentation by various frameworks has a legitimate technical basis. Each framework optimizes performance for an intended class of systems. For example, client systems are designed as single-channel systems with limited memory, limited power, and lower-cost DSPS. As a result, they are quite sensitive to performance degradation. Server systems, on the other hand, use a single DSP to handle multiple channels, thus reducing the cost per channel. As a result, they must support a dynamic environment. Yet, both client-side and server-side systems may require exactly the same vocoders.","Algorithms must be deliverable in binary form both to protect the vendor's intellectual property and to improve the reusability of the algorithm. If source code were required, all frameworks would require re-compilation. This would destabilize the frameworks and version control for the algorithms would be close to impossible.","Each particular implementation of a system (such as a speech detector) represents a complex set of engineering trade-offs between code size, data size, MIPS, and quality. Moreover, depending on the system designed, the system integrator may prefer an algorithm with lower quality and a smaller footprint to one with higher quality detection and a larger footprint (such as an electronic toy doll vs. a corporate voice mail system). Thus, multiple implementations of exactly the same algorithm sometimes make sense. There is no single best implementation of many algorithms.","Unfortunately, the system integrator is often faced with choosing all algorithms from a single vendor to ensure compatibility between the algorithms and to minimize the overhead of managing disparate APIs. Moreover, no single algorithm vendor has all the algorithms for all their customers. The system integrator is, therefore, faced with selecting a vendor that has \u201cmost\u201d of the required algorithms and negotiating with that vendor to implement the remaining algorithms.","Most modern DSP hardware architectures include both on-chip data memory and off-chip memory. The performance difference between these is so large that algorithm vendors design their code to operate within the on-chip memory as much as possible. Since the performance gap is expect to increase dramatically in the next 3\u20135 years, this trend will continue for the foreseeable future.","While the amount of on-chip data memory in a given DSP architecture may be adequate for each algorithm in isolation, the increased number of MIPS available on modern DSPs enables the creation of complex software systems that perform multiple algorithms concurrently on a single chip. There may not be enough on-chip memory to allow all algorithms to have their full, required complement of data memory resident in on-chip memory concurrently. There is a need for a method to permit efficient sharing of this resource among the algorithms. Generally, prior art methods for memory sharing in a complex system have required that an algorithm be partially or substantially rewritten each time it was used in a new framework. This situation makes it very costly, both in time and money, for a third party algorithm vendor to provide algorithms for multiple frameworks.","An illustrative embodiment of the present invention seeks to provide a system and method for enabling the reuse of algorithms in multiple application frameworks with no alterations required of the algorithm once it is developed. Aspects of the invention are specified in the claims.","In an embodiment of the present invention, an algorithm component model enables many of the benefits normally associated with object-oriented and component-based programming but with little or no overhead. An inverted memory allocation mechanism enables various algorithm modules to be integrated into a single application without modifying the source code of the algorithm modules. The embodiment also includes naming conventions to prevent external name conflicts, a uniform method for initializing algorithms, a uniform trace and diagnostic interface, and a uniform packaging specification.","In this embodiment of the present invention, a method is provided for creating an algorithm module that can be used without change in a plurality of frameworks. An algorithm module is designed in a manner that renders the algorithm module reentrant within a preemptive environment. Each data access instruction of the algorithm module is coded in a manner that renders the algorithm module and all of the data access instructions relocatable. A memory interface is provided within the algorithm module that supports both design-time object instantiation and dynamic object instantiation.","In another embodiment of the present invention, a method is provided for converting an existing algorithm to an algorithm module that can be used without change in a plurality of frameworks. An existing algorithm module is revised in a manner that renders the algorithm module reentrant within a preemptive environment. Each data access instruction of the algorithm module is checked to verify that it is coded in a manner that renders the algorithm module and all of the data access instructions relocatable. A memory interface is provided within the algorithm module that supports both design-time object instantiation and dynamic object instantiation;","In the following description, specific information is set forth to provide a thorough understanding of the present invention.","These and other features of the invention that will be apparent to those skilled in the art from the following detailed description of the invention, taken together with the accompanying drawings.","Corresponding numerals and symbols in the different figures and tables refer to corresponding parts unless otherwise indicated.","Many modern DSP software system architectures can be partitioned along the lines depicted in . Algorithms  are \u201cpure\u201d data transducers; i.e., they simple take input data buffers  and produce some number of output data buffers . Core run-time support  includes functions that copy memory, functions to enable and disable interrupts, and real-time debugging aids. Framework  is the \u201cglue\u201d that integrates algorithms  with real-time data sources  and sinks  using core run time support , to create a complete DSP sub-system. Framework  in essence defines a component model with which algorithms  must comply. Framework  interacts with any real-time peripherals (including other processors in the system) and defines the I\/O interfaces for the algorithms .","It has now been discovered that several technical issues have prevented the creation of such a method. One major issue is that algorithm implementations to date have been responsible for managing their own memory usage. If an algorithm is to be used in a variety of applications, the framework rather than the algorithm must make decisions about memory usage and preemption. This is referred to as an inverted memory protocol herein.","The algorithms and framework are implemented using a software development system that provides an assembler, compiler, linker, debugger, and other tools. Associated with the compiler will be language run-time support that will be incorporated into an application when it is constructed with the linker. For DSP software development, the development system may also include a DSP operating system to be used when creating an embedded software system. This operating system would be incorporated into the embedded software system when it is constructed with the linker. Once the embedded software system is constructed, it is downloaded onto a target DSP hardware system to be debugged. A debug environment in the software development system connects high level debugging software executing on a host computer to a low level debug interface supported by a target device.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 1B","b":["106","107","108"]},"Development Host  is a computer, for example a PC, running a DSP specific software debugger as one of its tasks. The debugger allows the user to issue high level commands such as \u201cset breakpoint at location 0x6789\u201d, \u201cstep one instruction\u201d or \u201cdisplay the contents of memory from 0x1000 to 0x1048\u201d. An example host system is described fully in U.S. Pat. No. 5,329,471.","Access Adapter  is a hardware component that connects development host  to a target system. It utilizes one or more hardware interfaces and\/or protocols to convert messages created by user interface commands to the debug command. This component could be a Texas Instruments XDS 510WS controller, for example, connected to the target system debug interface and to the PC through a SCSI port. An alternate configuration is a Texas Instruments XDS 510 controller installed in a PC connected to the target system debug interface. An example access adapter is described fully in U.S. Pat. No. 5,329,471.","Target System  is comprised of one or more DSPs. The DSP(s) contain hardware designed explicitly to ease the chore of debugging. It is the lowest element of the system debug environment. The DSP debug facilities allow the user to control the program execution, examine the state of the system, memory, and core resources in both real-time and stop mode debug modes. Target System  may be a cellular telephone, for example. Once a software program is written, compiled, linked and loaded onto the target system, it is then debugged and refined. Advantageously, a software program that embodies the present invention can be developed in a manner that minimizes debugging and redesign.","By enabling system integrators to \u201cplug-replace\u201d one algorithm for another, the time to market is reduced because the system integrator can choose algorithms from multiple vendors. A huge catalog of inter-operable parts from which any system can be built and can be easily created.","These algorithms must meet the following requirements:\n\n","Table 1 defines various terms that will be used herein.",{"@attributes":{"id":"p-0067","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Term Definitions"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Abstract","An interface defined by a C header whose functions are"]},{"entry":["Interface:","specified by a structure of function pointers. By"]},{"entry":[{},"convention these inter-face headers begin with the"]},{"entry":[{},"letter \u201ci\u201d and the interface name begins with \u201cI\u201d."]},{"entry":[{},"Such an interface is abstract because, in general, many"]},{"entry":[{},"modules in a system implement the same abstract interface;"]},{"entry":[{},"i.e., the interface de-fines abstract operations"]},{"entry":[{},"supported by many modules."]},{"entry":["Algorithm:","Technically, an algorithm is a sequence of operations,"]},{"entry":[{},"each chosen from a finite set of well-defined operations"]},{"entry":[{},"(for example, computer instructions), that halts in a finite"]},{"entry":[{},"time, and computes a mathematical function. In this"]},{"entry":[{},"specification, however, we allow algorithms to employ"]},{"entry":[{},"heuristics and do not require that they always produce"]},{"entry":[{},"a correct answer."]},{"entry":["API:","Acronym for application programming interface. A"]},{"entry":[{},"specific set of constants, types, variables, and functions"]},{"entry":[{},"used to programmatically interact with a piece of software."]},{"entry":["Client:","The term client denotes any piece of software that uses a"]},{"entry":[{},"function, module, or interface. For example, if the function"]},{"entry":[{},"a( ) calls the function b( ), a( ) is a client of b( )."]},{"entry":[{},"Similarly, if an application App uses module MOD, App is"]},{"entry":[{},"a client of MOD."]},{"entry":["Concrete","An interface defined by a C header whose functions are"]},{"entry":["Interface:","implemented by a single module within a system. This is"]},{"entry":[{},"in contrast to an abstract interface where multiple modules"]},{"entry":[{},"in a system can implement the same abstract interface. The"]},{"entry":[{},"header for every module defines a concrete interface."]},{"entry":["Critical","A critical section of code is one in which data that can be"]},{"entry":["Section:","accessed by other threads are inconsistent. At a higher"]},{"entry":[{},"level, a critical section is a section of code in which a"]},{"entry":[{},"guarantee you make to other threads about the state of some"]},{"entry":[{},"data may not be true. If other threads can access these data"]},{"entry":[{},"during a critical section, your pro-gram may not behave"]},{"entry":[{},"correctly. This may cause it to crash, lock up, or produce"]},{"entry":[{},"incorrect results. In order to insure proper system"]},{"entry":[{},"operation, other threads are denied access to inconsistent"]},{"entry":[{},"data during a critical section (usually through the"]},{"entry":[{},"use of locks). Poor system performance could be the result"]},{"entry":[{},"if some of your critical sections are too long."]},{"entry":["Endian:","Refers to which bytes are most significant in multi-byte"]},{"entry":[{},"data types. In big-endian architectures, the leftmost"]},{"entry":[{},"bytes (those with a lower ad-dress) are most significant."]},{"entry":[{},"In little-endian architectures, the rightmost bytes are"]},{"entry":[{},"most significant. HP, IBM, Motorola 68000, and SPARC"]},{"entry":[{},"systems store multi-byte values in big-endian order,"]},{"entry":[{},"while Intel 80x86, DEC VAX, and DEC Alpha systems"]},{"entry":[{},"store them in little-endian order. Internet standard"]},{"entry":[{},"byte ordering is also big-endian. The TMS320C6000 is"]},{"entry":[{},"bi-endian because it supports both systems."]},{"entry":["Frame:","Algorithms often process multiple samples of data at a"]},{"entry":[{},"time, referred to as a frame. In addition to improving"]},{"entry":[{},"performance, some algorithms require specific minimum"]},{"entry":[{},"frame sizes to operate properly."]},{"entry":["Framework:","Part of an application that is designed to remain invariant"]},{"entry":[{},"while selected software components are added, removed,"]},{"entry":[{},"or modified. Very general frameworks are sometimes"]},{"entry":[{},"described as application-specific operating systems"]},{"entry":["Instance:","The specific data allocated in an application that defines"]},{"entry":[{},"a particular object."]},{"entry":["Interface:","A set of related functions, types, constants, and variables."]},{"entry":[{},"An interface is often specified with a C header file."]},{"entry":["Interrupt","The maximum time between when an interrupt occurs and"]},{"entry":["Latency:","its corresponding interrupt service routine"]},{"entry":[{},"(ISR) starts executing."]},{"entry":["Method:","A synonym for a function that is part of an interface."]},{"entry":["Module:","A module is an implementation of one (or more) interfaces."]},{"entry":[{},"In addition, all modules follow certain design elements that"]},{"entry":[{},"are common to all XDAIS compatible software"]},{"entry":[{},"components. Roughly speaking, a module is a C language"]},{"entry":[{},"implementation of a C++ class."]},{"entry":["Multi-","Multithreading is the management of logically concurrent"]},{"entry":["threading:","threads within the same program or system. Most operating"]},{"entry":[{},"systems and modern computer languages also support"]},{"entry":[{},"multithreading."]},{"entry":["Preemptive:","A property of a scheduler that allows one task to"]},{"entry":[{},"asynchronously interrupt the execution of the currently"]},{"entry":[{},"executing task and switch to another task. The interrupted"]},{"entry":[{},"task is not required to call any scheduler functions to enable"]},{"entry":[{},"the switch."]},{"entry":["Reentrant:","A property of a program or a part of a program in its"]},{"entry":[{},"executable version, that can be entered repeatedly, or can"]},{"entry":[{},"be entered before previous executions have been completed."]},{"entry":[{},"Each execution of such a pro-gram is independent of all"]},{"entry":[{},"other executions."]},{"entry":["Scratch","Memory that can be overwritten without loss; i.e., prior"]},{"entry":["Memory:","contents need not be saved and restored after each use."]},{"entry":[{},"Scratch Register: A register that can be overwritten"]},{"entry":[{},"without loss; i.e., prior contents need not be saved and"]},{"entry":[{},"restored after each use."]},{"entry":["Thread:","The program state managed by the operating system that"]},{"entry":[{},"defines a logically independent sequence of program"]},{"entry":[{},"instructions. This state may be as small as the program"]},{"entry":[{},"counter (PC) value but often includes a large portion of"]},{"entry":[{},"the CPUs register set."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0068","num":"0073"},"figref":"FIG. 2","b":["1","201"]},"Level   describes software techniques to enable all algorithms to operate harmoniously within a single system. The present invention is most concerned with this level, presenting solutions to technical problems that previously made the creation of algorithms usable across multiple frameworks impossible.","Level   deals with guidelines for specific families of DSPs. Level   is concerned with various vertical markets. These levels are outside the scope of the present invention as they do not need to be addressed in order to implement the present invention.","For algorithms to satisfy the minimum requirements of reentrancy, I\/O peripheral independence, and debuggability, they must rely on a core set of services that is always present. Since most algorithms are still produced using assembly language, many of the services provided by this core must be accessible and appropriate for assembly language.","In an embodiment of the present invention, the core set of services includes a subset of a DSP operating system together with some additions to support atomic modification of control\/status registers. It also includes a subset of standard C language run-time support libraries; e.g., memcpy, strcpy, etc.","The DSP operating system is a collection of twelve modules:\n\n","Of these modules, only SWI, PRD, and IDL are directly related to thread scheduling. Table 2 describes which operations are callable. Unless otherwise noted, any operation that does not appear in this table must not be called.",{"@attributes":{"id":"p-0075","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Callable Operations"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Allowed or",{},{},{}]},{"entry":["Disallowed","Module","Typical Functions in Category","Notes"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["allowed","CLK","CLKgethtime, CLKgetltime","1"]},{"entry":["allowed","HST","HSTgetpipe","1"]},{"entry":["allowed","HWI","HWIdisable, HWIenable,","2"]},{"entry":[{},{},"HWIrestore"]},{"entry":["disallowed","HWI","HWIenter, HWIexit"]},{"entry":["allowed","LOG","LOGevent, LOGprintf,","1"]},{"entry":[{},{},"LOGerror, etc."]},{"entry":["allowed","PIP","PIPalloc, PIPget, PIPput, PIPfree","1"]},{"entry":["allowed","PRD","PRDgetticks"]},{"entry":["disallowed","PRD","PRDstart, PRDtick"]},{"entry":["allowed","RTC","RTCdisable, RTCenable, RTCquery","3"]},{"entry":["allowed","STS","STSadd, STSdelta, STSset, etc.","1"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":"Notes:"},{"entry":"All operations provided by this module are callable by algorithms"},{"entry":"These operations are the only way to create critical sections within an algorithm and provide a processor independent way of controlling preemption."},{"entry":"RTCenable and RTCdisable take a mask that should be configurable; i.e., hard constants should not be used."}]}}]}},"br":{}},"Table 3 summarizes the C language run-time support library functions that may be referenced in an embodiment of the present invention.",{"@attributes":{"id":"p-0077","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Run-Time Support Library Functions"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Allowed or",{},"Typical functions",{}]},{"entry":["Disallowed","Category","in category","Notes"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["allowed","String","strcpy, strchr, etc.","1"]},{"entry":[{},"functions"]},{"entry":["allowed","Memory-","memcpy, memmove, memset, etc.","2"]},{"entry":[{},"moving"]},{"entry":[{},"functions"]},{"entry":["allowed","Integer",{"sub":["\u2014","\u2014","\u2014","\u2014"]},"2"]},{"entry":[{},"math"]},{"entry":[{},"support"]},{"entry":["allowed","Floating",{"sub":["\u2014","\u2014","\u2014","\u2014"]},"2,3"]},{"entry":[{},"point",{"sub":["\u2014","\u2014","\u2014"]}]},{"entry":[{},"support",{"sub":"\u2014"}]},{"entry":["allowed","Conversion","atoi, ftoi, itof, etc.","2"]},{"entry":[{},"functions"]},{"entry":["disallowed","Heap","malloc, free, realloc, alloc, etc.","5"]},{"entry":[{},"management"]},{"entry":[{},"functions"]},{"entry":["disallowed","I\/O functions","printf, open, read, write, etc.","4"]},{"entry":["disallowed","Misc. non-","printf, sprintf, ctime, etc.","5,6"]},{"entry":[{},"reentrant"]},{"entry":[{},"functions"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":"Notes:"},{"entry":"Exceptions: strtok is not reentrant, and strdup allocates memory with malloc."},{"entry":"The compiler issues some of these automatically for certain C operators."},{"entry":"The errno paradigm isn't reentrant. Thus, errno must not be used."},{"entry":"Algorithms are not allowed to perform I\/O (except via DSP\/BIOS APIs)."},{"entry":"Algorithms must not allocate memory."},{"entry":"Algorithms must be reentrant and must, therefore, only reference reentrant functions."}]}}]}}},"All algorithms must follow certain programming rules:\n\n","The most basic software component is the module. In this embodiment, all algorithms are implemented as modules. A module is an implementation of one (or more) interfaces. An interface is simply a collection of related type definitions, functions, constants, and variables. In the C language, a header file typically specifies an interface. It is important to note that not all modules implement algorithms, but all algorithm implementations must be modules.","All modules must follow the following conventions:\n\n","For example, consider . Suppose a module called FIR, which consists of functions that create and apply finite impulse response filters to a data stream, is created. Interface  to this module is declared in the single C header file fir.h. Any application that wants to use the functions provided by implementation  in the FIR module must include the header fir.h. Although Interface  is declared as a C header file, the module may be implemented entirely in assembly language (or a mix of both C and assembly). Since interfaces may build atop other interfaces, all header files are required to allow for the possibility that they might be included more than once by a framework.","The general technique for insuring this behavior for C header files is illustrated in the code in Table 4.",{"@attributes":{"id":"p-0083","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sample Header File Code for Multiple Inclusion"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/*"]},{"entry":[{},"* ======== fir.h ========"]},{"entry":[{},"*\/"]},{"entry":[{},"#ifndef FIR"]},{"entry":[{},"#define FIR"]},{"entry":[{},". . ."]},{"entry":[{},"#endif \/* FIR\u2003*\/"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0084","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Assembly Language Header"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},";"]},{"entry":[{},"; ======== fir.h54 ========"]},{"entry":[{},";"]},{"entry":[{},".if ($isdefed(\u201cFIR\u201d) = 0)"]},{"entry":[{},"FIR .set 1"]},{"entry":[{},". . ."]},{"entry":[{},".endif"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Since multiple algorithms and system control code are often integrated into a single executable, the only external identifiers defined by an algorithm implementation (i.e., symbols in the object code) should be those specified by the algorithm application program interface (API) definition. Unfortunately, due to limitations of traditional linkers, an identifier must sometimes have external scope even though it is not part of the e algorithm API. Thus, to avoid namespace collisions, vendor selected names must not conflict. All external identifiers defined by a module's implementation must be prefixed by \u201c<module><vendor><name>\u201d, where <module> is the name of the module (containing only alphanumeric characters), <vendor> is the name of the vendor (containing only alphanumeric characters), and <name> is the unique name of the identifier (containing only alphanumeric characters). For example, for a vendor \u201cTI\u201d, TI's implementation of the FIR module must only contain external identifiers of the form FIRTI<name>. If there are external identifiers that are common to all implementations, the <vendor> component may be eliminated. For example, if the FIR module interface defined a constant structure that is used by all implementations, its name would have the form FIR<name>.","In addition to the symbols defined by a module, the symbols referenced by all modules must be defined. All undefined references must refer either to the C run-time support library functions or to operations in the DSP operating system modules or to other modules that comply with the rules of this embodiment.","All modules must follow the naming conventions summarized in Table 6. Note that the naming conventions only apply to external identifiers. Internal names and existing code need not change unless an identifier is externally visible to a framework.",{"@attributes":{"id":"p-0088","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Naming Conventions"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Convention","Description","Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Variables and","Variables and functions begin with","LOGprintf ( )"]},{"entry":["functions","lower case (after the prefix)"]},{"entry":["Constants","Constants are all uppercase","G729FRAMELEN"]},{"entry":["Types","Data types are in title case (after","LOGObj"]},{"entry":[{},"the prefix)"]},{"entry":["Structure fields","Structure fields begin with","Buffer"]},{"entry":[{},"lowercase"]},{"entry":["Macros","Macros follow the conventions of","LOGgetbuf ( )"]},{"entry":[{},"constants or functions as"]},{"entry":[{},"appropriate"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In addition to these conventions, multi-word identifiers should never use the \u2018\u2019 character to separate the words. To improve readability, use title case; for example, LOGgetBuffer( ) should be used in lieu of LOGgetbuffer ( ). This avoids ambiguity when parsing module and vendor prefixes.","Before a module can be used by an application, it must first be \u201cinitialized\u201d; i.e., the module's init( ) method must be run. Similarly, when an application terminates, any module that was initialized must be \u201cfinalized\u201d i.e., its exit( ) method must be executed. Initialization methods are often used to initialize global data used by the module that, due to the limitations of the C language, cannot be statically initialized. Finalization methods are often used to perform run-time debug assertions. For example, a finalization method might check for objects that were created but never deleted. The finalization method of a non-debug version of a module is often the empty function.","Although some modules have no need for initialization or finalization, it is easier for frameworks to assume that all modules have them. Thus, frameworks can easily implement well-defined startup and shutdown sequences, for example.","Modules optionally manage instance objects. In this embodiment of the present invention, all algorithm modules manage instance objects. Objects simply encapsulate the persistent state that is manipulated by the other functions (or methods) provided by the module.","A module manages only one type of object. Thus, a module that manages objects roughly corresponds to a C++ class that follows a standard naming convention for its configuration parameters, interface header, and all external identifiers.",{"@attributes":{"id":"p-0094","num":"0121"},"figref":"FIG. 4","b":["401","402","403","403"]},"Many embedded systems are very static in nature. Memory, MIPS (millions of instructions per second), and I\/O peripherals are statically partitioned among a fixed set of functions that operate continuously until power is removed. Static systems permit a number of performance optimizations that simply are not possible in dynamic systems. For example, a memory manager is not required in a static system and general data structures, such as linked lists, can often be replaced with much simpler and more efficient structures, such as fixed length arrays. These optimizations obviously reduce the system's code size requirements and, they may have a significant effect on the execution performance of the system.","When designing a system that is very cost sensitive, must operate with limited power, and\/or has limited MIPS, designers look for portions of the system that can be fixed at design time (i.e., made static). Even if the entire system cannot be static, often certain sub-systems can be fixed at design time. It is important, therefore, that all modules efficiently support static system designs. In practice, this simply means that all functions that are only required for run-time object creation be placed either in separate compilation units or separate COFF (Common Object File Format) output sections that can be manipulated by the linker. Ideally, every function should be in a separate compilation unit so the system integrator can eliminate run-time support that is unnecessary for a static system. An example that illustrates this \u201cdesign-time\u201d object creation for static systems is presented later in this specification.","Modules may optionally support run-time object creation and deletion. In some applications, run-time creation and deletion is a requirement. Without the ability to remove unneeded objects and reuse memory, the physical constraints of the system make it impossible to create rich multi-functions applications.","Run-time creation of objects is valuable even in systems that do not support or require run-time deletion of these objects. The precise nature of the objects, the number of objects, and even the type of objects created may be a function of parameters that are only available at run-time. For example, a programmer may want to create a single program that works in a variety of hardware platforms that differ in the amount of memory available and the amount is determinable at run-time. Note that the algorithms conforming to an embodiment of the present invention are modules of a special type, which are referred to as algorithm modules herein. How the algorithm modules support run-time object creation is another embodiment of the present invention described later in this specification.","In an ideal world, a module that implements an API can be used in any system that requires the API. As a practical matter, however, every module implementation must make trade-offs among a variety of performance metrics such as program size, data size, MIPS, and a variety of application specific metrics such as recognition accuracy, perceived audio quality, and throughput. Thus, a single implementation of an API is unlikely to make the right set of tradeoffs for all applications.","Therefore, any framework that wishes to incorporate modules following the specification herein must support multiple implementations of the same API. In addition, each module has one or more \u201cglobal configuration\u201d parameters that can be set at design time by the system integrator to adjust the behavior of the module to be optimal for its execution environment.","Suppose, for example, that a module that implements digital filters exists. There are several special cases for digital filters that have significant performance differences such as all-pole, all-zero, and pole-zero filters. Moreover, for certain DSP architectures if one assumes that the filter's data buffers are aligned on certain boundaries, the implementation can take advantage of special data addressing modes and significantly reduce the time required to complete the computation. A filter module may include a global configuration parameter that specifies that the system will only use all-zero filters with aligned data. By making this a design-time global configuration parameter, systems that are willing to accept constraints in their use of the API are rewarded by faster operation of the module that implements the API.","Modules that have one or more \u201cglobal\u201d configuration parameters should group them together in a C structure, called XYZConfig, and declare this structure in the module's header. In addition, the module should declare a static constant structure named XYZ of type XYZConfig that contain the module's current configuration parameters.",{"@attributes":{"id":"p-0103","num":"0130"},"figref":"FIG. 5"},"As discussed above, the first two operations that must be supported by all modules are the init( ) and exit( ) functions. The init( ) function is called during system startup while the exit( ) function is called during system shutdown. These entry points, shown in code block , exist to allow the module to perform any run-time initialization necessary for the module as a whole. More often than not, these functions have nothing to do and are simply empty functions.","The create entry point, shown in code block , creates and initializes an object; i.e., a C structure. The object encapsulates all the state necessary for the other functions to do their work. All of the other module entry points (functions) are passed a pointer to this object as their first argument. If the functions only reference data that is part of the object (or referenced within the object), the functions will naturally be reentrant. In this example, code block  would create and initialize the structure defined in code block  using the parameter defined in the same code block.","The delete entry point, shown in code block , should release any resource held by the object being deleted and should gracefully handle the deletion of partially constructed objects. The delete entry point may be called by the create operation. In this example, the delete operation has nothing to do.","Finally, the FIR module must provide a method for filtering a signal. This is accomplished via the apply operation shown in code block . In a real FIR module, the filter operation would be implemented in assembly language. However, because the state necessary to compute the algorithm is entirely contained in the object, this algorithm is reentrant. Thus, it is easy to use this module in multi-channel applications or in single channel applications that require more than one FIR filter.","Modern component programming models support the ability of a single component to implement more than one interface. This allows a single component to be used concurrently by a variety of different applications. For example, in addition to a component's concrete interface (defined by its header), a component might also support a debug interface that allows debuggers to inquire about the existence and extent of the component's debug capabilities. If all debuggable components implement a common abstract debug interface, debuggers can be written that can uniformly debug arbitrary components.","Support for multiple interfaces is generally incorporated into the development environment, the programming language itself, or both. Since this embodiment is intended to only require the C language, the ability of a module to support multiple interfaces is, at best, awkward.","However, several significant benefits make this approach worthwhile:\n\n","As stated previously, header files define interfaces, and each header file defines a single interface. A module's header file defines a concrete interface. The functions defined in the header uniquely identify a specific (or concrete) implementation within a system. A special type of interface header is used to define abstract interfaces. Abstract interfaces define functions that are implemented by more than one module in a system. An abstract interface header is identical to a normal module interface header except that it declares a structure of function pointers named XYZfxns. A module ABC is said to implement an abstract interface XYZ if it declares and initializes a static structure of type XYZFxns named ABCXYZ. By convention, all abstract interface headers begin with the letter \u2018i\u2019. This static structure, referred to subsequently as the v-table, is the mechanism through which a framework can manage an instance of the algorithm. As illustrated in , v-table  is a table of pointers to the functions implemented by algorithm  that framework  must use to execute the functions of algorithm .","In this embodiment of the present invention, all algorithm modules must implement an abstract interface that is described later in this specification. This abstract interface is called IALG.","Although all algorithm modules are required to implement the IALG interface, it is important to note that almost all of them must implement a more specific interface as well. They must implement functions specific to the algorithm. For example, a G.729 encoder algorithm module must not only implement IALG; it must also implement an \u201cencode\u201d function that is specific to the algorithm.","In this common case, a new interface is defined that \u201cderives from\u201d or \u201cinherits from\u201d the IALG interface. Interface inheritance is implemented by simply defining the new interface's v-table or \u201cFxns\u201d structure so that its first field is the v-table or \u201cFxns\u201d structure from which the interface is inherited. Thus, any pointer to the new interface's \u201cFxns\u201d structure can be treated as a pointer to the inherited interface's \u201cFxns\u201d structure. In the case of the G.729 encoder implementation, this simply means that the first field of the G729EFxns structure is an IALGFxns structure.","The previous paragraphs have described the structure shared by all modules. Table 7 summarizes the common design elements for a module named XYZ.",{"@attributes":{"id":"p-0116","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Common Module Design Elements"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Element","Description","Required?"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["XYZinit ( )","Module initialization and","yes"]},{"entry":[{},"finalization functions"]},{"entry":"XYZexit ( )"},{"entry":["xyz.h","Module's interface definition","Yes"]},{"entry":["XYZconfig","Structure type of all module","Only if module has"]},{"entry":[{},"configuration parameters","global configuration"]},{"entry":[{},{},"parameters"]},{"entry":["XYZ","Constant structure of all module","Only if module has"]},{"entry":[{},"configuration parameters","global configuration"]},{"entry":[{},{},"parameters"]},{"entry":["XYZFxns","Structure type defining all","Only if the interface"]},{"entry":[{},"functions necessary to implement","is an abstract"]},{"entry":[{},"the XYZ interface","interface definition"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Table 8 summarizes the common elements of all modules that manage one or more instance objects.",{"@attributes":{"id":"p-0118","num":"0149"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Common Elements of Modules Managing Instance Objects"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Element","Description","Required?"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Struct XYZObj","Module's object definition; normally not","yes"]},{"entry":[{},"defined in the module's header"]},{"entry":["XYZHandle","Handle to an instance object; synonym for","yes"]},{"entry":[{},"struct XZYObj"]},{"entry":["XYZParams","Structure type for all module object","yes"]},{"entry":[{},"creation parameters"]},{"entry":["XYZPARAMS","Constant structure for all default","yes"]},{"entry":[{},"object creation parameters"]},{"entry":["XYZcreate ( )","Run-time creation and initialization of","no"]},{"entry":[{},"an module's object"]},{"entry":["XYZdelete ( )","Run-time deletion of a module's object","no"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In this embodiment of the present invention, algorithm modules are modules that implement the abstract interface IALG. IALG defines a framework independent interface for the creation of algorithm instance objects. The algorithm module must declare and initialize a structure of type IALGFxns, the structure must have global scope, and its name must be XYZIALG where XYZ is the unique module-vendor prefix as defined previously. The IALG interface allows algorithm modules to define their memory resource requirements (also called memory usage requirements) and thereby enable the efficient use of memory by frameworks.","The IALG interface defines a \u201cprotocol\u201d between the framework and the algorithm module that is used to create an algorithm instance object.","This interface is designed to enable the algorithm module to be used by frameworks implementing virtually any execution environment, i.e., preemptive and non-preemptive, static and dynamic systems. Thus, it is important that algorithm modules never use any memory allocation routines (including those provided in the standard C run-time support libraries). The framework must perform all memory allocation in accordance with the inverted memory protocol. Since algorithm module implementations are modules that support object creation, and, all such modules should support design-time object creation, all algorithm modules support both run-time and design-time creation of algorithm objects. To ensure support for design-time object creation, all functions defined by the IALG interface must be independently relocatable. In practice, this means that each function should either be implemented in a separate file or placed in a separate COFF output section. By placing each of these functions in a separate file or output section, a linker can be used to eliminate those methods that are unnecessary for frameworks that do not require run-time object creation.","In some cases, it is awkward to place each function in a separate file. Doing so may require making some identifiers globally visible or require significant changes to an existing code base. The C compiler supports a pragma directive that allows specified functions to be placed in distinct COFF sections. This pragma directive may be used in lieu of placing functions in separate files.","Since the IALG interface does not define functions that can be used to actually run an algorithm, each abstract algorithm interface must extend or \u201cderive\u201d from the IALG interface. Thus, every algorithm module has considerable flexibility to define the methods that are appropriate for the algorithm.",{"@attributes":{"id":"p-0124","num":"0155"},"figref":"FIG. 7","b":["7","7","7"]},"A module implements the IALG interface if it defines and initializes a global structure of type IALGFxns as shown in code block . For the most part, this means that every function defined in this structure must be implemented and assigned to the appropriate field in this structure. Note that the first field, code line , of the IALGFxns structure is a Void * pointer. This field must be initialized to a value that uniquely identifies the module implementation. This same value must be used in all interfaces implemented by the module. Since all algorithms must implement the IALG interface, it is sufficient for algorithm modules to set this field to the address of the module's declared IALGFxns structure.","In some cases, an implementation of IALG does not require any processing for a particular method. Rather than require the module to implement functions that simply return to the caller, the function pointer may be set to NULL. This allows the framework to avoid unnecessarily calling functions that do nothing and avoids the code space overhead of these functions.","The functions defined in IALGFxns fall into several categories.\n\n","Removing memory allocation from the algorithm module complicates instance object creation. If an algorithm module is to be reusable in a variety of applications, the framework rather than the algorithm module must make decisions about memory overlays and preemption in accordance with the inverted memory protocol. Thus, it is important to give the framework as much control over memory management as possible. The functions algAlloc( ), algInit( ), and algFree( ) allow the algorithm module to communicate its memory usage requirements to the framework, let the algorithm module initialize the physical memory allocated by the framework, and allow the algorithm module to communicate the memory to be freed when an instance is no longer required, respectively. Note that these operations are not called in time critical sections of an application.","Once an algorithm instance object is created, it can be used to process data in real-time. The sub-classes of IALG define other entry points to algorithmic processing supported by algorithm modules. Prior to invoking any of these functions, frameworks are required to activate the instance object via the algActivate( ) function. The algActivate( ) function provides a notification to the algorithm instance that one or more algorithm processing functions is about to be run zero or more times in succession. After the processing methods have been run, the framework calls the algDeactivate( ) function prior to reusing any of the instance's scratch memory. The algActivate( ) and algDeactivate( ) functions give the algorithm instance a chance to initialize and save scratch memory that is outside the main algorithm-processing loop defined by its extensions of the IALG interface.","The final two functions defined by the IALG interface are algControl( ) and algMoved( ). The algControl( ) operation provides a standard way to control an algorithm instance and receive status in-formation from the algorithm instance in real-time. The algMoved( ) operation allows the framework to move an algorithm instance to physically different memory. Since the algorithm instance object may contain references to the internal buffer that may be moved by the framework, the framework is required to call the algMoved( ) function whenever the framework moves an object instance.",{"@attributes":{"id":"p-0131","num":"0165"},"figref":"FIG. 8","sub":"\u2014"},"As  illustrates, when a framework wants to execute an algorithm, it must first put the algorithm into a \u201cstart state\u201d. This is accomplished by executing step  followed by step . In step , algAlloc( ) is called to query the algorithm module about its memory requirements. In step , algInit( ) is called to initialize the memory requested via the call to algAlloc( ) in step . The algorithm instance is now ready to execute.","Execution of the algorithm instance is comprised of the four steps , , , and . In step , the framework calls algActivate( ) to notify the algorithm instance that its memory is \u201cactive\u201d and the algorithm instance processing functions in step  may be called. The framework may then optionally (the option to skip or execute this step is denoted by arrows ) execute step , calling algMoved( ) to allow the algorithm instance to update any internal references. This is only necessary when the framework has relocated the algorithm's instance object during system execution. Then, the framework may call any of the processing functions in the algorithm instance as denoted by step . The framework may execute step  repeatedly as necessary to accomplish the purpose of the algorithm. If the framework relocates the algorithm's instance object between executions of step , it must repeat step  before continuing. Once the framework has finished using the processing functions of step , it may proceed to step . In step , the algDeactivate( ) function is executed to notify the current algorithm instance that it is about to be deactivated.","Once step  is completed, two options are available to the framework. It can choose to leave the algorithm instance in its \u201cstart state\u201d pending reactivation or it can execute step . If the framework chooses to leave the algorithm instance in its \u201cstart state\u201d, it may reactivate the algorithm instance by executing the sequence described above starting with step . A framework will only execute step  if it wishes to reuse the memory that it has allocated to an algorithm instance.","In step , the function algFree( ) is called to ask the algorithm instance to identify any memory assigned to it. The framework uses this information to free up that memory for use by other algorithm instances. Once step  is executed, the algorithm instance is no longer in its \u201cstart state\u201d. If the framework wishes to use the algorithm instance again, it must restart the process with step .","Two other execution paths are available to the framework, as illustrated by arrows  and . Arrow  shows that once step  has been completed, the framework may choose to immediately go to step . Also, as per arrow , once step  is complete, the framework may choose to execute step .","Note that there is no requirement that any of the steps shown in  must be performed in a single uninterrupted execution cycle by the framework. The order of execution shown must be followed but there is no requirement on how much time may elapse or what other things the framework might choose to do between performing the steps for a given algorithm instance.","When algorithm instances are created, the framework can pass algorithm-specific parameters to the algAlloc( ) and the algInit( ) methods. To support implementation-specific extensions to standard abstract algorithm interfaces, every algorithm module's parameter structure must begin with the size field defined in the IALGParams structure shown in , code block . The framework sets this field to the size of the parameter structure (including the size field itself) that is being passed to the algorithm implementation. Thus, the implementation can \u201cknow\u201d if the framework is passing just the standard parameter set or an extended parameter set. Conversely, the framework can elect to send just the \u201cstandard\u201d parameters an implementation-specific set of parameters. Of course, if a framework uses an implementation-specific set, the framework cannot be used with a different implementation of the same algorithm.","The code fragments shown in  illustrate how a framework may use the same style of parameter passing whether passing generic parameters or implementation-specific parameters. The implementation can also easily deal with either set of parameters. The only requirement is that the generic parameters always form a prefix of the implementation-specific parameters; i.e., any implementation-specific parameter structure must always include the standard parameters as its first fields.","This same technique is used to extend the algorithm module's status structures. In this case, however, all algorithm status structures start with the IALGStatus fields (see , code block ).","Modules that implement the IALG interface enable run-time instance creation using the generic create and delete functions shown in , code block  and code block  respectively.","To implement the IALG interface, all algorithm objects must be defined with IALGObj (see , code block ) as their first field. This insures that all pointers to algorithm objects can be treated as pointers to IALGObj structures.","The framework functions outlined above are just examples of how to use the IALG functions to create simple object create and delete functions. Other frameworks might create objects very differently. For example, one can imagine a framework that creates multiple objects at the same time by first invoking the algAlloc( ) function for all objects, optimally allocating memory for the entire collection of objects, and then completing the initialization of the objects. By considering the memory requirements of all objects prior to allocation, such a framework can more optimally assign memory to the required algorithms.","Once an algorithm instance is created, it can be used to process data. However, if the algorithm module defines the algActivate( ) and algDeactivate( ) functions, they must bracket the execution of any of the algorithm modules processing functions. The function shown in  could be used, for example, to execute any implementation of the IFIR interface on a set of buffers. This implementation of FIRapply( ) assumes that all persistent memory is not shared; thus, it does not restore this data prior to calling algActivate( ) and it does not save this memory after algDeactivate( ). If a framework shares persistent data among algorithm instances, it must insure that this data is properly restored prior to running any processing methods of the algorithm instances.","If an algorithm instance's processing functions are always executed as shown in the FIRapply( ) function in , there is no need for the algActivate( ) and algDeactivate( ) functions. To save the overhead of making two function calls, their functionality would be folded into the processing functions. The purpose of algActivate( ) and algDeactivate( ) is to enable the algorithm's processing functions to be called multiple times between calls to algActivate( ) and algDeactivate( ). This allows the algorithm writer the option of factoring data initialization functions, such as initialization of scratch memory, into the algActivate( ) function. The overhead of this data movement can then be amortized across multiple calls to processing functions.","Each of the functions described above is presented in more detail below to further clarify an embodiment of the present invention. The functions are presented in alphabetic order. The descriptions include an example implementation along with detailed descriptions. Note that each of the example implementations assumes the presence of the IALG algorithm interface shown in .","The function algActivate( ), an implementation of which is shown in  code segment , initializes any of the instance's scratch buffers using the persistent memory that is part of the algorithm's instance object. The first (and only) argument to algActivate( ) is an algorithm instance handle. This handle is used by the algorithm to identify the various buffers that must be initialized prior to calling any of the algorithm's processing functions.","The implementation of algActivate( ) is optional. The algActivate( ) method should only be implemented if a module wants to factor out initialization code that can be executed once prior to processing multiple consecutive frames of data. If a module does not implement this method, the algActivate field in the module's v-table must be set to NULL. This is equivalent to the implementation in Table 9.",{"@attributes":{"id":"p-0149","num":"0183"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Non-Implementation of algActivate( )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Void algActivate(IALGHandle handle)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The following conditions must be true prior to calling this method; otherwise, its operation is undefined.\n\n","The function algAlloc( ), an example implementation of which is shown in , returns a table of memory records that describe the size, alignment, type and memory space of all buffers required by an algorithm instance (including the instance object itself). If successful, this function returns a positive non-zero value indicating the number of records initialized. This function can never initialize more memory records than the number returned by the function algNumAlloc( ). If algNumAlloc( ) is not implemented, the maximum number of initialized memory records is IALGDEFMEMRECS (see code line  in ).","The first argument to algAlloc( ) is a pointer to the creation arguments for the instance of the algorithm object to be created. The creation arguments must be in a structure of type IALGParams (see code block  in ). This pointer is algorithm-specific; i.e., it points to a structure that is defined by each particular algorithm. This pointer may be NULL, however. In this case, algAlloc( ), must assume default creation parameters and must not fail.","The second argument to algAlloc( ) is an optional output parameter. algAlloc( ) may return a pointer to another set of IALG functions to the framework. This set of IALG functions must be in a structure of type IALGFxns (see code block  in ). If this output value is set to a non-NULL value, the framework creates an instance object using this set of IALG functions. The resulting instance object must then be passed to algInit( ). algAlloc( ) may be called at any time and it must be idempotent; i.e., it can be called repeatedly without any side effects and always returns the same result.","The third argument to algAlloc( ) is an output parameter that is a structure of type IALGMemRec (see code block  in ). This memory table contains the information about the size, type, alignment, etc. of the memory blocks required by the algorithm instance.","The following conditions must be true prior to calling this method; otherwise, its operation is undefined.\n\n","The following conditions are true immediately after returning from this method.\n\n","If the operation succeeds, the return value of this operation is greater than or equal to one. Any other return value indicates that the parameters specified by params are invalid.","The function algControl( ), an implementation of which is shown in , sends an algorithm specific command, cmd, and an input\/output status buffer pointer to an algorithm module's instance object.","The first argument to algControl( ) is an algorithm instance handle. algControl( ) must only be called after a successful call to algInit( ) but may be called prior to algActivate( ). algControl( ) must never be called after a call to algFree( ).","The second and third parameters are algorithm (and possible implementation) specific values. Algorithm and implementation-specific cmd values are always less than IALGSYSCMD (see  code line ). Upon successful completion of the control operation, algControl( ) returns IALGEOK (see  code line ); otherwise it returns IALGEFAIL (see  code line ) or an algorithm-specific error return value.","In preemptive execution environments, algControl( ) may preempt a module's other functions.","The implementation of algControl( ) is optional. If a module does not implement this method, the algControl field in the module's static function table (of type IALGFxns) must be set to NULL. This is equivalent to the implementation in Table 10.",{"@attributes":{"id":"p-0163","num":"0207"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Non-Implementation of algControl( )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Int algControl(IALGHandle handle,"]},{"entry":[{},"IALGCmd cmd, IALGStatus *status)"]},{"entry":[{},"{"]},{"entry":[{},"return (IALGEFAIL);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The following conditions must be true prior to calling this method; otherwise, its operation is undefined.\n\n","The following conditions are true immediately after returning from this method.\n\n","The function algDeactivate( ), an implementation of which is shown in  code block , saves any persistent information to non-scratch buffers using the persistent memory that is part of the algorithm's instance object. The first (and only) argument to algDeactivate( ) is an algorithm instance handle. This handle is used by the algorithm instance to identify the various buffers that must be saved prior to the next cycle of algActivate( ) and processing.","The implementation of algDeactivate( ) is optional. The algDeactivate( ) function is only implemented if a module wants to factor out initialization code that can be executed once prior to processing multiple consecutive frames of data.","If a module does not implement this function, the algDeactivate field in the module's v-table must be set to NULL. This is equivalent to the implementation in Table 11.",{"@attributes":{"id":"p-0169","num":"0218"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Non-Implementation of algDeactivate"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Void algDeactivate(IALGHandle handle)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The following conditions must be true prior to calling this function; otherwise, its operation is undefined.\n\n","The following conditions are true immediately after returning from this method.\n\n","The function algFree( ), an example implementation of which is shown in , returns a table of memory records that describe the base address, size, alignment, type, and memory space of all buffers previously allocated for the algorithm instance (including the algorithm instance object) specified by handle. This function always returns a positive non-zero value indicating the number of records initialized. This function can never initialize more memory records than the value returned by algNumAlloc( ).","The following conditions must be true prior to calling this function; otherwise, its operation is undefined.\n\n","The following conditions are true immediately after returning from this function.\n\n","The function algInit( ), an example implementation of which is shown in , performs all initialization necessary to complete the run-time creation of an algorithm's instance object. After a successful return from algInit( ), the algorithm's instance object is ready to be used to process data. The first argument to algInit( ) is an algorithm instance handle. This handle is a pointer to an initialized IALGObj structure (see code block  in ). Its value is identical to the memTab[0].base.","The second argument is a table of memory records of type IALGMemRec, that describes the base address, size, alignment, type, and memory space of all buffers allocated for an algorithm instance (including the algorithm's instance object). The number of initialized records is identical to the number returned by a prior call to algAlloc( ).","The third argument is a handle to another algorithm instance object. This parameter is often NULL indicating that no parent object exists. This parameter allows frameworks to create a shared algorithm instance object and pass it to other algorithm instances. For example, a parent instance object might contain global read-only tables that are used by several instances of a vocoder.","The last argument is a pointer to algorithm-specific parameters that are necessary for the creation and initialization of the instance object. This pointer points to the same parameters passed to the algAlloc( ) operation. However, this pointer may be NULL. In this case, algInit( ), must assume default creation parameters.","The framework is not required to satisfy the IALGMemSpace (see code block  of ) attribute of the requested memory. Thus, the algorithm instance is, required to properly operate (although much less efficiently) even if it is not given memory in, say on-chip DARAM.","The following conditions must be true prior to calling this function; otherwise, its operation is undefined.\n\n","The following condition is true immediately after returning from this method: all of the instance's persistent memory is initialized and the object is ready to be used (with the exception of any initialization performed by algActivate( )).","The function algMoved( ), an example implementation of which is shown in code block  in , performs any reinitialization necessary to insure that, if an algorithm's instance object has been moved by the framework, all internal data references are recomputed. The arguments to algMoved( ) are identical to the arguments passed to algInit( ). In fact, in many cases an algorithm module may use the same function defined for algInit( ) to implement algMoved( ). However, it is important to realize that algMoved( ) is called in real-time whereas algInit( ) is not. Much of the initialization required in algInit( ) does not need to occur in algMoved( ). The framework is responsible for copying the instance's state to the new location and only internal references need to be recomputed.","Although the algorithm's parameters are passed to algMoved( ), with the exception of pointer values, their values must be identical to the parameters passed to algInit( ). The data referenced by any pointers in the params structure must also be identical to the data passed to algInit( ). The locations of the values may change but their values must not. The implementation of algMoved( ) is optional. However, it is highly recommended that this method be implemented.","If a module does not implement this method, the algMoved( ) field in the module's v-table must be set to NULL. This is equivalent to asserting that the algorithm's instance objects cannot be moved.","The following conditions must be true prior to calling this method; otherwise, its operation is undefined.\n\n","The following condition is true immediately after returning from this function. The instance object is functionally identical to the original instance object. It can be used immediately with any of the algorithm's functions.","The function algNumAlloc( ), an implementation of which is presented in  code block , returns the maximum number of memory allocation requests that the algAlloc( ) function requires. This operation allows frameworks to allocate sufficient space to call the algAlloc( ) function or fail because insufficient space exists to support the creation of the algorithm's instance object. algNumAlloc( ) may be called at any time and it must be idempotent; i.e., it can be called repeatedly without any side effects and always returns the same result.","algNumAlloc( ) is optional; if it is not implemented, the maximum number of memory records for algAlloc( ) is assumed to be IALGDEFMEMRECS (see  code line ). This is equivalent to the implementation shown in Table 12.",{"@attributes":{"id":"p-0189","num":"0262"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Non-Implementation of algNumAlloc( )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Int algNumAlloc(Void)"]},{"entry":[{},"{"]},{"entry":[{},"return (IALGDEFNUMRECS);"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"If a module does not implement this method, the algNumAlloc field in the module's v-table must be set to NULL.","The following condition is true immediately after returning from this function. The return value from algNumAlloc( ) is always greater than or equal to one and always equals or exceeds the value returned by algAlloc( ).","Trace Control Interface","To improve both the system integration efforts as well as enhance in-field diagnostics, all algorithms should implement a uniform trace and diagnostic interface. In an embodiment of the present invention, this capability is implemented as an alternate module interface as defined in subsequent paragraphs.","The real-time trace control interface (IRTC) defines an interface that, when implemented, allows a module's various trace modes to be enabled, disabled, and controlled in real time.  shows an implementation of IRTC. It would be included in a module's definition with the following line of code: #include <irtc.h>.","A module implements the IRTC interface if it defines and initializes a global structure of type IRTCFxns (see  code block ). For the most part, this means that every function defined in this structure must be implemented and assigned to the appropriate field in this structure. It is important to note that the first field of the IRTCFxns structure is a Void* pointer. This field must be initialized to a value that uniquely identifies the module implementation. This same value must be used in all interfaces implemented by the module. Since all algorithms must implement the IALG interface, it is sufficient for algorithm modules to set this field to the address of the module's declared IALGFxns structure. The subsequent paragraphs describe the functions that must be implemented in each module that includes this interface.","The function rtcBind( ) sets the module's current output log. For any module that implements the IRTC interface, there is just one output log. All instances use a single output log. The first (and only) argument to rtcBind( ) is pointer to a LOG object.","The following conditions must be true prior to calling this function; otherwise, its operation is undefined.\n\n","The following condition is true immediately after returning from this function. All subsequent output trace is redirected to the LOG object received as the argument.","The code segment in Table 13 is an example implementation of rtcBind.",{"@attributes":{"id":"p-0199","num":"0274"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example Implementation of rtcBind"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FIRTIrtcLog = NULL;"]},{"entry":[{},"Void rtcBind(LOGObj *log)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* set current output log *\/"]},{"entry":[{},"FIRTIrtcLog = log;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The function rtcGet( ) returns the current setting of the trace mask for a trace instance object. For any module that implements the IRTC interface, the module instance object is also the trace instance object.","The only argument to rtcGet( ) is a trace instance handle.","The following condition must be true prior to calling this function; otherwise, its operation is undefined: the argument must be a valid handle for the module's trace instance object.","The following condition is true immediately after returning from this method: mask is the current trace mask setting for this instance.","The code segment in Table 14 is an example implementation of rtcGet.",{"@attributes":{"id":"p-0205","num":"0280"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example Implementation of rtcGet"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct EncoderObj {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IALGObj ialgObj","\/* IALG object MUST be first field *\/"]},{"entry":[{},"Int workBuf;","\/* pointer to on-chip scratch memory *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":". . . ;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IRTCMask mask;","\/* current trace mask *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} EncoderObj;"},{"entry":"IRTCMask rtcGet(IRTCHandle handle)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"EncoderObj *inst = (EncoderObj *)handle;"]},{"entry":[{},"\/* return current trace mask *\/"]},{"entry":[{},"return (inst\u2212>mask);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The function rtcSet( ) sets a new trace mask for a trace instance object. For any module that implements the IRTC interface, the module instance object is also the trace instance object.","The first argument to rtcSet( ) is a trace instance handle and the second argument is the new setting for this instance.","The following condition must be true prior to calling this function; otherwise, its operation is undefined: handle must be a valid handle for the module's trace instance object.","The following conditions are true immediately after returning from this function.\n\n","The code segment in Table 15 is an example implementation of rtcSet.",{"@attributes":{"id":"p-0211","num":"0288"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example Implementation of rtcSet"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct EncoderObj {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IALGObj ialgObj","\/* IALG object MUST be first field *\/"]},{"entry":[{},"Int workBuf;","\/* pointer to on-chip scratch memory *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":". . . ;"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IRTCMask mask;","\/* current trace mask *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} EncoderObj;"},{"entry":"Void rtcSet(IRTCHandle handle, IRTCMask mask)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"EncoderObj *inst = (EncoderObj *)handle;"]},{"entry":[{},"\/* set current trace mask *\/"]},{"entry":[{},"inst\u2212>mask = mask;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[". . . ;","\/* enable trace modes indicated by mask *\/"]},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Once a module is developed, it must be packaged in a uniform manner to enable delivery into any framework that conforms to the component model described herein. To ensure that a single component can be used in both UNIX and Windows environments, never create two files whose names only differ in case, and always treat file names as being case-sensitive.","All of the object code files for a module should be archived into a library with the following name: <module><vers><vendor>.a<arch> where\n\n","In addition to the object code implementation of the algorithm, each module includes one or more interface headers. To ensure that no name conflicts occur, all header files must conform to the following naming conventions. C language headers should be named as follows:\n\n","A single vendor may produce more than one implementation of an algorithm module. For example, a \u201cdebug\u201d version may include function parameter checking that incurs undesirable overhead in a \u201crelease\u201d version. A vendor may even decide to provide multiple debug or release versions of a single algorithm. Each version may make different tradeoffs between time and space overhead, for example. To easily manage the common case of debug and release versions of the same algorithm, different versions of an algorithm from the same vendor must follow a uniform naming convention. If multiple versions of the same component are provided by a single vendor, the different versions must be in different libraries (as described above) and these libraries must be named as follows:\n\n","If there is only one release version of a component from a vendor, there is no need to add a variant suffix to the library name. Suppose, for example, that TI supplies one debug and one release version of the FIR module for a DSP that is referred to as a C62xx architecture. In this case, the library file names would be \u201cfirtidebug.a62\u201d and \u201cfirti.a62\u201d.","To avoid having to make changes to source code, only one header file must suffice for all variants supplied by a vendor. Since different algorithm implementations can be interchanged without re-compilation of applications, it should not be necessary to have different \u201cdebug\u201d versus \u201crelease\u201d definitions in a module's header. However, a vendor may elect to include vendor specific extensions that do require recompilation. In this case, the header must use the symbol DEBUG to select the appropriate definitions; DEBUG is defined for debug compilations and only for debug compilations.",{"@attributes":{"id":"p-0218","num":"0302"},"figref":["FIG. 23A","FIG. 8"],"b":"2310","i":"a\u2013c "},"The relationship of these interfaces to the abstract interfaces defined above is illustrated in . Abstract interfaces  correspond to API modules . API modules  provide conventional functional interfaces to any modules that implement the corresponding abstract interfaces .","The ALG module provides a generic interface used to create, delete, and invoke algorithms on data. The functions provided by this module use the IALG interface functions to dynamically create and delete algorithm objects. Any module that implements the IALG interface can be used by ALG.","Note that there may actually be several different implementations of the ALG module available in the software development environment. Each implementation would follow a different memory management policy and optimally operate in a specified environment. For example, one implementation may never free memory and should only be used in applications that never need to delete algorithm objects. An implementation of ALG would be incorporated into a framework or test program as follows: #include <alg.h>.","The interface to ALG is presented in Table 16.",{"@attributes":{"id":"p-0223","num":"0307"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 16"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"ALG Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/*---------------------------*\/"},{"entry":"\/* TYPES AND CONSTANTS *\/"},{"entry":"\/*---------------------------*\/"},{"entry":"typedef IALGHandle ALGHandle;"},{"entry":"\/*---------------------------*\/"},{"entry":"\/* FUNCTIONS *\/"},{"entry":"\/*---------------------------*\/"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ALGactivate( );","\/* initialize instance's scratch memory *\/"]},{"entry":["ALGcontrol( );","\/* send control command to algorithm *\/"]},{"entry":["ALGcreated( );","\/* create an algorithm instance object *\/"]},{"entry":["ALGdeactivated( );","\/* save instance's persistent state *\/"]},{"entry":["ALGdeleted( );","\/* delete algorithm instance's object *\/"]},{"entry":["ALGexit( );","\/* ALG module finalization *\/"]},{"entry":["ALGinit( );","\/* ALG module initialization *\/"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"ALGactivate( ) initializes any scratch buffers and shared persistent memory using the persistent memory that is part of the algorithm's instance object. In preemptive environments, it saves all shared data memory used by this instance to a shadow memory so that it can be restored by ALG-deactivate( ) when this instance is deactivated. The only argument to ALGactivate( ) is an algorithm instance handle. This handle is used by the algorithm instance to identify the various buffers that must be initialized prior to execution of any processing functions. It has no return value.","ALGcreate( ) implements a memory allocation policy and uses this policy to create an instance of the algorithm module specified in its first argument (of type IALGFxns). Its second argument is a pointer (of type IALGParams) to an algorithm-specific set of instance parameters that are required by the algorithm module to create an instance. ALGcreate( ) will return a handle to the instance if it is successful. If it is unsuccessful, it will return NULL.","The code fragment in Table 17 shows an example use of ALGcreate.",{"@attributes":{"id":"p-0227","num":"0311"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 17"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of ALGcreate and ALGdelete Use"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"#include <alg.h>"]},{"entry":[{},"#include <encode.h>"]},{"entry":[{},"Void main( )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ENCODEParams params;"]},{"entry":[{},"ALGHandle encoder;"]},{"entry":[{},"params = ENCODEPARAMS; \/* initialize to default values *\/"]},{"entry":[{},"params.frameLen = 64; \/* set frame length *\/"]},{"entry":[{},"\/* create instance of encoder object *\/"]},{"entry":[{},"encoder = ALGcreate(&ENCODETIIALG,"]},{"entry":[{},"\u2009(IALGParams*)&params);"]},{"entry":[{},"if (encoder != NULL) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/* use encoder to encode data *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/* delete encoder object *\/"]},{"entry":[{},"ALGdelete(encoder);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"ALGcontrol( ) sends an algorithm specific command and a pointer to an I\/O status buffer. The first argument to ALGcontrol( ) is an algorithm instance handle. The second two arguments, the command and the pointer to the I\/O status buffer, are interpreted in an algorithm-specific manner by the implementation. The return value of ALGcontrol( ) indicates whether the control operation completed successfully. A return value of IALGEOK indicates that the operation completed successfully; all other return values indicate failure. The code fragment in Table 18 contains an example of the use of ALGcontrol( ).",{"@attributes":{"id":"p-0229","num":"0313"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 18"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Use of ALGcontrol( )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"#include <alg.h>"},{"entry":"#include <encode.h>"},{"entry":"Void main( )"},{"entry":"}"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ALGHandle encoder;"]},{"entry":[{},"ENCODEStatus status;"]},{"entry":[{},"\/* create instance of encoder object *\/"]},{"entry":[{},"encoder = . . . ;"]},{"entry":[{},"\/* tell coder to minimize MIPS *\/"]},{"entry":[{},"status.u.mips = ENCODELOW"]},{"entry":[{},"ALGcontrol(encoder, ENCODESETMIPS, (ALGStatus *)&status);"]},{"entry":[{},". . ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"ALGdeactivate( ) saves any persistent information to non-scratch buffers using the persistent memory that is part of the algorithm's instance object. In preemptive environments, ALGdeactivate( ) also restores any data previously saved to shadow memory by ALGactivate( ). The only argument to ALGdeactivate( ) is an algorithm instance handle. This handle is used by the algorithm to identify the various buffers that must be saved prior to the next cycle of ALGactivate( ) and data processing calls.","ALGdelete( ) deletes the dynamically created object indicated by its only argument. The handle denoted by this argument should be the return value from a previous call to ALGcreate( ). If handle is NULL, ALGdelete( ) simply returns. It has no return value. Table 18 shows an example of the use of ALGdelete( ).","ALGinit( ) is called during system startup to perform any run-time initialization necessary for the algorithm module as a whole. It has no parameters and returns nothing.","ALGexit( ) is called during system shutdown to perform any run-time finalization necessary for the algorithm module as a whole. It has no parameter and returns nothing.","The RTC module provides a generic interface used to control the trace capabilities of an algorithm instance. The functions provided by this module use the IRTC interface functions to dynamically control the various trace levels supported by algorithm objects. Any module that implements the IRTC and IALG interfaces can be used by RTC. Table 19 contains an example of the RTC interface. This interface would be incorporated in the framework by the directive #include <rtc.h>.",{"@attributes":{"id":"p-0235","num":"0319"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 19"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"RTC Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/*---------------------------*\/"]},{"entry":[{},"\/* TYPES AND CONSTANTS *\/"]},{"entry":[{},"\/*---------------------------*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#define RTCENTRY","IRTCENTRY"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"#define RTCWARNING","IRTCCLASS1"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct RTCDesc {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IRTCFxns fxns; \/* trace functions *\/"]},{"entry":[{},"IALGHandle handle; \/* algorithm instance handle *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} RTCDesc;"]},{"entry":[{},"\/*---------------------------*\/"]},{"entry":[{},"\/* FUNCTIONS *\/"]},{"entry":[{},"\/*---------------------------*\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RTCbind( );","\/* bind output log to module *\/"]},{"entry":[{},"RTCcreates( );","\/* create a trace instance object *\/"]},{"entry":[{},"RTCdeleted( );","\/* delete trace instance's object *\/"]},{"entry":[{},"RTCdisable( );","\/* disable all trace levels *\/"]},{"entry":[{},"RTCenable( );","\/* (re)enable trace levels *\/"]},{"entry":[{},"RTCexit( );","\/* RTC module finalization *\/"]},{"entry":[{},"RTCget( );","\/*get trace level *\/"]},{"entry":[{},"RTCinit( );","\/* RTC module initialization *\/"]},{"entry":[{},"RTCset( );","\/* set trace level *\/"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"RTCbind( ) sets the output log of a module. This operation is typically called during system initialization and it must not preempt any other operation supported by the implementing module. Its first argument must be a pointer to a module's implementation of the IRTC interface. The second argument must be a valid pointer to a LOG object.","RTCcreate( ) initializes the trace descriptor structure. Its first argument is a pointer to a trace descriptor structure. This structure is initialized using the algorithm object and a pointer to a module's IRTC implementation functions. The second argument is pointer to an algorithm object previously created by ALGcreate( ). The third argument must be a pointer to a module's implementation of the IRTC interface. This module must also implement the IALG interface used to construct the ALGObj structure. RTCcreate performs a run-time check to insure these two interface implementations are consistent. RTCcreate( ) returns NULL if it fails; otherwise, it returns its first argument.","RTCdelete( ) deletes the trace descriptor contained in its only argument. This trace descriptor should have been initialized by RTCcreate( ). If the parameter is NULL, RTCdelete( ) simply returns. RTCdelete( ) returns nothing.","RTCdisable( ) sets the current trace bit mask for the instance object to a value the halts the real-time production of diagnostic information by the trace object. The first argument to RTCdisable( ) is a trace descriptor initialized via RTCcreate( ). If this argument is NULL, RTCdisable simply returns. RTCdisable returns nothing.","RTCenable( ) sets the current trace bit mask for the instance object to the last set value representing the level of trace and diagnostic information that should be produced in real-time by the trace object. The first argument to RTCenable( ) is a trace descriptor initialized via RTCcreate( ). If this argument is NULL, RTCenable simply returns. RTCenable returns nothing.","RTCexit( ) runs during system shutdown to perform any run-time finalization necessary for the RTC module as a whole. It has no arguments and returns nothing.","RTCget( ) returns the current setting of the trace mask for a trace descriptor. The only argument to RTCget( ) is a trace descriptor initialized via RTCcreate( ). Table 20 contains a code fragment illustrating the use of RTCget( ).",{"@attributes":{"id":"p-0243","num":"0327"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 20"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Use of RTCget"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"main( )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RTCDesc trace;"]},{"entry":[{},"ALGHandle alg;"]},{"entry":[{},"alg = . . . ;"]},{"entry":[{},"RTCcreate(&desc, alg, &FIRTIIRTC);"]},{"entry":[{},"\/* get current trace mask for alg *\/"]},{"entry":[{},"mask = RTCget(&desc);"]},{"entry":[{},". . ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"RTCinit( ) is called during system startup to perform any run-time initialization necessary for the RTC module as a whole. It has no arguments and returns nothing.","RTCset( ) sets the current trace mask for an algorithm instance specified by the descriptor pointer passed as its first argument. This pointer must be a trace descriptor initialized via RTCcreate( ). The second argument is a bit mask representing the level of trace and diagnostic information that should be produced in real-time by the trace object. This function returns nothing. Table 21 contains a code fragment illustrating the use of RTCset.",{"@attributes":{"id":"p-0246","num":"0330"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 21"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Use of RTC-set( )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"main( )"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"RTCDesc desc;"]},{"entry":[{},"ALGHandle alg;"]},{"entry":[{},"alg = . . . ;"]},{"entry":[{},"RTCcreate(&desc, alg, &FIRTIIRTC);"]},{"entry":[{},"\/* set current trace mask for alg to RTCENTER *\/"]},{"entry":[{},"RTCset(&desc, RTCENTER);"]},{"entry":[{},". . ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0247","num":"0331"},"figref":"FIG. 23B","b":["2322","2324","2326","2320"]},"Dynamic Instantiation",{"@attributes":{"id":"p-0248","num":"0332"},"figref":"FIG. 20A"},"In step , an algorithm instruction code section is encapsulated with a memory interface code section to create an algorithm module. In step , the algorithm modules are combined with a framework. Each algorithm module has a memory interface that responds to a memory allocation inquiry (or query) with the memory usage requirements of an algorithm instance. This step creates the software system. The software system is loaded on a hardware platform in step . In step , the software system is executed.","The flow graph in  illustrates the execution steps. In steps  and , client  (a framework) queries the memory interface of algorithm module  to get the memory usage requirements of an instance of the algorithm. Algorithm module  responds to the memory allocation inquiry by returning the memory usage requirements for an instance of the algorithm. In step , client  allocates physical memory for algorithm instance  based on the memory usage requirements it received. In step , algorithm module  accepts the region of memory allocated by client . Algorithm module  then initializes the region of memory to create algorithm instance  in step . Steps \u2013are is repeated for each algorithm module in the software program.","In an embodiment of the present invention, each algorithm module would be implemented as a module as described above. The memory interface of each algorithm would be provided by implementing the IALG interface shown in  (without code block  and code block  and code lines  in ) and the three required functions, algAlloc( ), algInit( ), and algFree( ). These three functions implement the basic functionality for an algorithm's memory handling capability.","The algorithm modules would then be linked with a framework that is able to call the functions of the memory interface at the appropriate times with correct parameter values. The resulting software system is then loaded on the target hardware platform and executed.","When execution begins, the framework will call algAlloc( ) for each algorithm module in turn to determine the memory usage requirements. It allocates the requested memory as defined in the memTab structure and then calls algInit( ) to initialize the memory requested in algAlloc( ). This execution sequence of algAlloc( ) followed by algInit( ) is done one time for each algorithm module in the system to allocate and initialize all memory required by the set of algorithm modules. The framework then may execute any of the algorithm-specific functions in any of the algorithm modules.","Alternatively, the framework may choose to execute the sequence of algAlloc( ) followed by algInit( ) each time it wishes to execute any of the algorithm specific functions of a given algorithm module. When the desired algorithm specific functions have completed execution, the framework can then execute algFree( ) to get the addresses and size of each memory block allocated to the algorithm module and free up that memory for use by another algorithm module.","Memory Optimization","In other embodiments of the invention, additional functionality is provided to enable optimal memory utilization. The memory interface of the above embodiment informs the framework of the amount of memory required by the algorithm module. Many DSP systems provide several memory spaces. These memory spaces include:\n\n",{"@attributes":{"id":"p-0256","num":"0343"},"figref":"FIG. 21"},"As shown in , the processor is formed of a central processing unit (CPU) , an external memory interface unit  for interfacing CPU  with external memory unit , on-chip random access memory (RAM) comprised of read only memory (ROM) , single-access RAM (SARAM) , and dual-access RAM (DARAM) , and a number of on-chip peripherals . External memory interface , ROM , SARAM , and DARAM  are connected to CPU  by CPU bus .","These memory spaces (external memory , ROM , SARAM , and DARAM ) are only the most common types used today. Other types may exist now or come into existence in the future. Extension of the present invention to include these should be obvious to one skilled in the art.","Algorithm developers will structure their implementations to take advantage of the available memory spaces to optimize performance. For example, frequently accessed data will usually be placed in on-chip memory (e.g., SARAM  and DARAM ).","For DSP system architectures that include more than one memory space (as exemplified in ), the memory interface of the inverted memory protocol is extended to include the ability to inform the framework of the desired memory space for each block of memory requested. Code lines  and  in  illustrate this embodiment. (Code block  and the first line of code line  in  are now included in IALG to define the memory space types.)","Once a memory block's size, alignment, and memory space have been specified, three independent questions must be answered before a framework can optimally manage a block of an algorithm's data memory:\n\n","The answer to the first question is determined by the implementation of the algorithm module. In an alternate embodiment, the memory interface is further extended to include the capability to adopt a model of using scratch memory versus persistent memory. This capability allows an algorithm module to divide its memory into two or more blocks. This subdivision of memory helps reduce fragmentation of physical memory and allows the framework to make more efficient use of physical memory since the area allocated to scratch memory can be shared among all algorithm modules in the application.","In this model, all physical memory is partitioned into two groups: scratch and persistent. Scratch memory may be freely used by an algorithm instance without regard to its prior contents, i.e., no assumptions about the content can be made by the algorithm instance and the algorithm instance is free to leave it in any state. Persistent memory is used to store state information while an algorithm instance is not executing. An algorithm instance can assume that the contents of persistent memory are unchanged between successive invocations. All physical memory has this behavior, but applications that share memory among multiple algorithm modules may opt to overwrite some regions of memory. The importance of making a distinction between scratch memory and persistent memory is illustrated by . Without this distinction, physical memory  would have to be strictly partitioned among algorithm instances, making the total physical memory requirement the sum of all algorithms' memory requirements. On the other hand, with this distinction, algorithm scratch memory  can be overlaid on the same physical memory . And, physical memory  can be strictly partitioned for algorithm persistent memory . Thus, the total memory requirement for a collection of algorithm instances is the sum of the size of each algorithm's persistent memory plus the maximum scratch memory size requirement of any of these algorithms.","The other two questions, regarding sharing and preemption, can only be answered by the framework. The framework decides whether preemption is required for the application and the framework allocates all memory. Thus, only the framework \u201cknows\u201d whether memory is shared among algorithm instances. Some frameworks, for example, never share any allocated memory among algorithm instances while others always share scratch memory. Since only the framework knows about sharing and preemption, the memory interface of the present invention is extended in an alternate embodiment to include a way of telling the framework if the requested memory is to be treated as scratch or persistent. Code lines  and  in  are examples of such an extension. (Code block  and the second line of code lines  in  are now added to IALG.)","The scratch versus persistent attribute of a block of memory is independent of the memory space. Thus, there are six distinct memory classes in the above embodiment of the present invention: scratch and persistent for each of the three memory spaces. For example, in , code lines  and  in combination specify that the requested memory block is to be persistent and should be located in external memory. And, code lines  and  in combination specify that the requested memory block is to be persistent and should be located in on-chip dual-access memory.","There is a special type of persistent memory that some frameworks implement, shadow memory. Shadow memory is unshared persistent memory that is used to save the contents of shared registers and memory in an application. Algorithms are not aware of shadow memory; frameworks use it to save the memory regions shared by various algorithm instances.","Because algorithm instances use persistent memory to hold state information between executions, persistent memory blocks will usually be assigned to slow external physical memory. When an algorithm instance has a frame of data to be processed, the state information needed for processing the frame should be copied into a scratch buffer in a faster on-chip memory space. An alternate embodiment of the present invention extends the capabilities of the memory interface to include functionality to execute the \u201ccopy to scratch memory\u201d operation. , in code segment , illustrates one implementation of such functionality, algActivate( ). When a framework wishes to start the execution of an algorithm instance's processing functions, it should call this function before calling any of the processing functions.","When the processing of the buffer is complete, the framework may decide to assign the scratch buffer to another instance of that algorithm or to another algorithm instance. But the current instance may need to retain some of the information in its scratch buffer. This information needs to be copied back to the persistent memory. An alternate embodiment of the present invention extends the capabilities of the memory interface to include functionality to execute the \u201ccopy to persistent memory\u201d operation. , in code segment , illustrates one implementation of such functionality, algDeactivate( ). When a framework wishes to reuse a scratch buffer, it should call this function for the last algorithm instance using the scratch buffer before allocating the buffer to another.","The framework decides if it wants to execute \u201ccopy to scratch memory\u201d and \u201ccopy to persistent memory\u201d for every frame of data, or if it wants to call \u201ccopy to persistent memory\u201d and never share the scratch memory with other algorithm instances until it calls \u201ccopy to persistent memory\u201d.","The ability to relocate or move a memory block allocated to an algorithm will further improve application designers' ability to optimize memory usage by giving them increased flexibility to move algorithm instances around at runtime. However, if a framework moves a memory block, it must make provisions for assuring that the algorithm instance can update any internal references to that memory block. An alternate embodiment of the present invention includes functionality that extends the memory interface to allow the framework to notify the algorithm instance that its memory block has been moved. Code segment  in  illustrates one implementation of this functionality, algMoved( ). An algorithm implementing this function is only responsible for updating the internal references to its memory blocks.","Existing Algorithms","As other embodiments described herein have shown, it is possible with the present invention to write algorithms that may be used in more than one system or application without significant reengineering, integration, and testing. These embodiments have dealt mostly with the creation of new algorithms. They do not address algorithms that were in existence prior to the present invention. There is a large body of such algorithms that have taken years to develop and refine.","In another embodiment of the present invention, there is a method of converting an existing algorithm to an algorithm module so that it may be used in any framework providing the defined interface. The steps of this method are shown in the flowchart in .","For purposes of illustrating this method, we assume the existence of an implementation of an encoder algorithm. In steps  and , the actual code of the algorithm is modified as required to make the existing algorithm reentrant in a preemptive environment and to make it relocatable. These modifications are considered to be good coding practice and how to accomplish them is well understood by practitioners. Other programming rules or guidelines may also be applied such as those described previously herein.","In step , code is written to implement the basic memory interface. This consists of implementing the IALG interface described previously along with the three required functions, algAlloc, algInit, and algFree. Table 22 contains an example of the algAlloc function for the example algorithm.",{"@attributes":{"id":"p-0275","num":"0365"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 22"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"algAlloc Example"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Int G723ENCTIalgAlloc(const IALGParams *algParams, IALGFxns **pf,"},{"entry":"IALGMemRec memTab[ ])"},{"entry":"{"},{"entry":"\/* Request memory for G723ENC instance object *\/"},{"entry":"memTab[0].size = sizeof(G723ENCTIObj);"},{"entry":"memTab[0].alignment = 0;"},{"entry":"memTab[0].space = IALGDARAM0;"},{"entry":"memTab[0].attrs = IALGPERSIST;"},{"entry":"return(1) \/* return number of memory blocks requested *\/"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Table 23 contains an example of the algInit function for the example algorithm.",{"@attributes":{"id":"p-0277","num":"0367"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 23"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"algInit Example"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Int G723ENCTIalgInit(IALGHandle handle, const IALGMemRec"},{"entry":"memTab[ ], IALGHandle p, const IALGParams *algParams)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"G723ENCTIObj *enc = (Void *)handle;"]},{"entry":[{},"const IG723ENCParams *params = (Void *)algParams;"]},{"entry":[{},"if (params == NULL) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"params = &IG723ENCPARAMS;","\/* set default parameters *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/* Copy creation params into the object *\/"]},{"entry":[{},"enc\u2212>workinqRate = params\u2212>rate;"]},{"entry":[{},"enc\u2212>hPFilter = params\u2212>hpfEnable;"]},{"entry":[{},"enc\u2212>VAD = params\u2212>vadEnable;"]},{"entry":[{},"g723EncInit(enc); \/* Initialize all other instance variables *\/"]},{"entry":[{},"return(IALGEOK);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Table 24 contains an example of the algFree function for the example algorithm.",{"@attributes":{"id":"p-0279","num":"0369"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 24"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"algFree Example"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Int G723ENCTIalgFree(IALGHandle handle, IALGMemRec memTab[ ])"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"G723ENCTIObj *enc = (Void *)handle;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"algAlloc(NULL, NULL, memTab);","\/* Fill the memTab struct *\/"]},{"entry":[{},"memTab[0].base = (Void *)&enc;"]},{"entry":[{},"return(1);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The algorithm code must be implemented in an object-like way to encapsulate state. This is good coding practice and motivates reentrant code since all references to the code and data will be through a pointer to the object. Consider the example of the G723ENCTIObj in Table 25.",{"@attributes":{"id":"p-0281","num":"0371"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 25"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"G723ENCTIObj Example"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct G723ENCTIObj {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IALGObj ialg;","\/* Points to the v-table *\/"]},{"entry":[{},"IG723Rate workingRate;","\/* 5.3 or 6.3 kbps *\/"]},{"entry":[{},"XDASBool hPFilter;","\/* High Pass filter on\/off *\/"]},{"entry":[{},"XDASBool VAD;","\/* Voice activity detection on\/off *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},".....................","\/* specifics to the implementation *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} G723ENCTIObj;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"sub":["\u2014","\u2014","\u2014"]},"Next, in step , the specific module interface, the IG723ENC interface, must be created. The IG723ENC interface is defined in the ig723enc.h header file. IG723ENCFxns extends IALGFxns, as seen in the excerpt from the header file in Table 26.",{"@attributes":{"id":"p-0283","num":"0373"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 26"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Excerpt From ig723enc.h"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"typedef struct IG723ENCFxns {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IALGFxns ialg;","\/* IG723ENC extends IALG *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"XDASBool (*control) (IG723ENCHandle handle, IG723Cmd cmd,"]},{"entry":[{},"IG723ENCStatus *status);"]},{"entry":[{},"XDASBool (*encode) (IG723ENCHandle handle, XDASUInt16 *in,"]},{"entry":[{},"XDASUInt16 *out);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} IG723ENCFxns;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The control( ) and encode( ) functions must be implemented to complete the module interface for the algorithm. Most often, these functions are wrappers to existing implementations, as seen in the example in Table 27 for the encode( ) function.",{"@attributes":{"id":"p-0285","num":"0375"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 27"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"encode( ) Function"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"XDASBool G723ENCTIencode(IG723ENCHandle handle, XDASUInt16 *in,"},{"entry":"XDASUInt16 *out)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"G723ENCTIObj *enc = (Void *)handle;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if(encoder(enc, in, out))","\/* do the processing *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return(XDASTRUE);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return(XDASFALSE);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The IG723ENC interface defines the default creation parameters in the ig723enc.c source file. If the framework wants to use creation parameters other than those provided in the interface, the framework makes a local copy of the default algorithm parameters and modifies the desired fields before creating an instance. The application then needs to pass this modified parameter structure to algAlloc( ) and algInit( ) to create an instance with the modified parameters.","Finally, the v-table must be defined so the framework can access the algorithm module's functions. Since IG723ENCFxns extends IALGFxns, the IG723ENC v-table must also include the functions in the IALG v-table as shown in Table 28.",{"@attributes":{"id":"p-0288","num":"0378"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 28"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"V-table Definition"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"#define IALGFXNS \\"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"&G723ENCTIIALG,","\/* module ID *\/ \\"]},{"entry":[{},"NULL,","\/* activate *\/ \\"]},{"entry":[{},"G723ENCTIalgAlloc,","\/* alloc *\/ \\"]},{"entry":[{},"NULL,","\/* control *\/ \\"]},{"entry":[{},"NULL,","\/* deactivate *\/ \\"]},{"entry":[{},"G723ENCTIalgFree,","\/* free *\/ \\"]},{"entry":[{},"G723ENCTIalgInit,","\/* init *\/ \\"]},{"entry":[{},"NULL,","\/* moved *\/ \\"]},{"entry":[{},"NULL","\/* numAlloc *\/ \\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"IG723ENCFxns G723ENCTIIG723ENC ={"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IALGFXNS,","\/* IALG functions *\/"]},{"entry":[{},"G723ENCTIcontrol,"]},{"entry":[{},"g723ENCTIencode"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"} G723ENCTIIG723ENC;"},{"entry":"asm(\u201cG723ENCTIIALG.set G723ENCTIIG723ENC\u201d);"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The first field in the v-table is the address of the table. This field is used as a unique identifier of the implementation. Notice that only the three required IALG functions and the module-specific functions are defined in the v-table. All the other function pointers are set to NULL. The asm( ) statement defines the symbol G723ENCTIIALG to be equal to G723ENCTIIG723ENC, which means that the IALG and the IG723ENC v-tables are shared.","The algorithm module is now ready for final testing and packaging for delivery (step ). A library and a header file are created as described in previously herein. The library file will be called g723encti.a62. The header file, g723encti.h, needs to declare the symbols to the v-table as shown in Table 29.",{"@attributes":{"id":"p-0291","num":"0381"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 29"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"V-table Symbol Declarations in Header File"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"extern IG723ENCFxns G723ENCTIIG723ENC;"]},{"entry":[{},"extern IALGFxns G723ENCTIIALG;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In the G723ENCTIalgAlloc( ) function, a single block of memory holds the state information and potential working buffers. An algorithm module should divide its memory requirements into several blocks for three reasons. First, it makes memory management more flexible for the framework with regards to fragmentation issues. Second, the framework can make efficient use of any scratch memory since it can be overlaid among instances of algorithms. Third, if the target hardware supports them, the memory blocks can be allocated in different types of physical memory depending on their usage. An extension to this embodiment to support specification of scratch versus persistent memory and different types of memory should be apparent from the description of a previous embodiment.","For increased flexibility in optimizing memory usage, the algorithm module should be extended to permit an algorithm instance to be activated, deactivated, and relocated by the framework at run-time. In this embodiment, this functionality is provided by implementing the functions algActivate( ), algDeactivate( ), and algMoved( ). These functions are described previously herein.","One final thing that may be done in the conversion process is to provide an interface to any debugging functionality that the DSP operating system may support. In this embodiment, this would be accomplished by implementing the IRTC interface described previously.","\u201cDesign Time\u201d Object Instantiation","The present invention allows system designers to easily integrate algorithm modules from a variety of sources (e.g., third parties, customers, etc.). However, in system design, flexibility comes with a price. This price is paid in CPU cycles and memory space, both critical in all DSP systems, but perhaps most critical in a static system. A static system is one in which no memory allocation occurs at run-time. The worst-case amount of memory needed to execute the application can be determined when the software system is designed (at \u201cdesign time\u201d) and that memory can be allocated statically among the algorithm modules in the software system. This static memory allocation is then initialized at run-time. There is no need for run-time memory allocation. Note that static systems may reuse memory. They will, for example, overlay algorithm instances in the same physical memory when its it is known that the instances are never concurrently active.","In contrast, a dynamic system is one in which the memory is allocated and initialized while the application is executing. A dynamic system takes advantage of the available physical memory by sharing it between algorithm instances, by reclaiming it when an algorithm instance is deactivated, and by reusing it when another algorithm instance is activated.","Recall from previous discussion of an embodiment of the invention that an algorithm module is a module that manages instances of a single type of object. It also supports dynamic or run-time creation of those instances. Another embodiment of the present invention is a system and method for creating algorithm instances at \u201cdesign time\u201d rather than dynamically at run-time. This method will allow an algorithm to be used effectively in a static system with limited memory.","In an embodiment described previously, an interface that allows efficient use of a large variety of algorithm modules in a large variety of systems is presented. However, the full capability of the interface may not be necessary in all systems. For a static system, a designer would want to allocate memory to any algorithm instances at design time, initialize the algorithm instances at power-on and never change anything else. In such a system, the code implementing memory allocation and de-allocation would take up valuable memory and would never be used.",{"@attributes":{"id":"p-0299","num":"0389"},"figref":["FIG. 25","FIG. 8"]},"As  illustrates, when a framework wants to execute an algorithm instance in a static system, it must first put the algorithm instance into a \u201cstart state\u201d. Since the memory for the instance has already been allocated, only initialization is required. In step , alginito is called to initialize the memory allocated to the instance at design time. The algorithm instance is now ready to execute.","Execution of the algorithm instance is comprised of the four steps , , , and . In step , the framework calls algActivate( ) to notify the algorithm instance that its memory is \u201cactive\u201d and the algorithm instance processing functions in step  may be called. The framework may then optionally (the option to skip or execute this step is denoted by arrows ) execute step , calling algMoved( ) to allow the algorithm instance to update any internal references. This is only necessary when the framework has relocated the algorithm's instance object during system execution. Then, the framework may call any of the processing functions in the algorithm instance as denoted by step . The framework may execute step  repeatedly as necessary to accomplish the purpose of the algorithm. If the framework relocates the algorithm's instance object between executions of step , it must repeat step  before continuing.","Once the framework has finished using the processing functions of step , it may proceed to step . In step , the algDeactivate( ) function is executed to notify the current algorithm instance that it is about to be deactivated. Once step  is completed, the algorithm instance is back in its \u201cstart state.\u201d Only one option is available to the framework at this point, as designated by arrow . It can reactivate the algorithm by executing the sequence described above starting with step .","Note that there is no requirement that any of the steps shown in  must be performed in a single uninterrupted execution cycle by the framework. The order of execution shown must be followed but there is no requirement on how much time may elapse or what other things the framework might choose to do between performing the steps for a given algorithm instance.","The steps to create an algorithm instance at \u201cdesign time\u201d are shown in the flowcharts in . In this embodiment, an algorithm module is instantiated and all code for interfaces that will not be needed in a static system is removed.","In the initial step, step , the desired algorithm modules are combined with a calling program that implements an interface that allows it to query the memory interface of the algorithm modules with which it is combined. This embodiment assumes that the algorithm modules are implemented as described previously.","In steps , , and , the result of step  is executed. The calling program queries the memory interface of an algorithm module, receives a response from that algorithm module as to its instance's memory usage requirements, and then instantiates the instance of that algorithm. The instantiation consists of allocating the requested memory and initializing it so that the algorithm instance is ready to execute. These three steps are repeated for each algorithm instance.","After steps - are complete, the algorithm instantiations are combined with a framework to create a software program in step . The resulting software program is then ready to be executed in a static embedded environment.",{"@attributes":{"id":"p-0308","num":"0398"},"figref":["FIGS. 26B and 26C","FIG. 26B"],"b":["2607","1","2606"]},"In step , client   calls algNumAlloc( ) to get the number of memory requests the instance may make and algorithm module  responds appropriately.","In step , client   calls algAlloc( ) to get the actual memory requests and algorithm module  responds with the information requested.","In step , client   allocates memory for the algorithm instance based on the information it received in the two previous steps.","In step , client   calls algInit( ) to initialize the instance object. In this call, it tells algorithm module  where its memory block or blocks have been allocated. In step , the algorithm module causes the memory block or blocks that have been allocated to it to be initialized to create algorithm instance . After step is executed, step is completed by algorithm module  returning an indication of successful initialization to client  .","In step , client   creates output file  that \u201cdeclares\u201d algorithm instance  as static data. Output file  is created to be appropriate input to a linker.","In , output file  has been linked with client   to create a static software system. This static software system is now ready to be loaded on the target digital system.","In another embodiment, provisions are made for excluding unneeded module interface code to make the final software system smaller. As mentioned above, each function in a module should be created such that it can be independently manipulated during the process of combining the algorithm module with a calling program. In this embodiment, functions that are only required for run-time object creation are placed either in separate compilation units or in separate COFF (Common Object File Format) output sections that can be manipulated by the linker. Ideally, every function in the module interface should be in a separate compilation unit so the system integrator can eliminate any run-time support that is unnecessary for a static system.","One way this exclusion can be accomplished is to declare each function to be a codesection in a pragma directive. When the calling program is linked with the algorithm module, the link command file can contain directives such as those shown in Table 30 to cause any interface code that will not actually be executed in the final software system to be eliminated from the load module created.",{"@attributes":{"id":"p-0317","num":"0407"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 30"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Excerpt from Link Command File"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},". . ."]},{"entry":[{},".notUsed {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"* (.text:algActivate)"]},{"entry":[{},"* (.text:algApply)"]},{"entry":[{},"* (.text:algDeactivate)"]},{"entry":[{},"* (.text:algDelete)"]},{"entry":[{},"* (.text:algExit)"]},{"entry":[{},"* (.text:algInit)"]},{"entry":[{},"* (.text:algMoved)"]},{"entry":[{},"* (.text:algNumAlloc)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"} type = NOLOAD > EXT3"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},". . ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Note that in , the functions algNumAlloc( ) and algAlloc( ) are present (see step  and step , respectively) in the load module created when client   was linked with algorithm module . In , these functions are no longer present in the load module created when client   is linked with object file  containing the static representation of algorithm instance . These functions will not be needed at run-time and the code that implemented them was excluded by the linker when the load module was created.",{"@attributes":{"id":"p-0319","num":"0409"},"figref":["FIG. 27","FIG. 21","FIG. 21"],"b":["2700","2701","2701","2702","2703","2702","2703","2704","2704","2705"]},"Typically, an application program is loaded onto the digital system at the time of manufacture by appropriate masking of a ROM within or connected to the digital system that contains an image of the application program or by programming or otherwise presetting the ROM, for example. Such an application program is referred to as an \u201cembedded program\u201d because the digital system is completely self-contained and is not connected to a mass storage device, such as common in a typical personal computer or workstation.","Thus, a system and method is provided for enabling the reuse of algorithms in multiple application frameworks with no alterations required of the algorithm once it is developed. A standardized interface (IALG) is included within each algorithm module that supports an inverted memory protocol so that each algorithm module can inform an application program of the memory usage requirements for each instance of the module. The application program, or framework, then allocates memory from a pool managed by the framework.","Advantageously, various application programs can uniformly manipulate all algorithms that provide an IALG interface.","Advantageously, all memory allocation is removed from the algorithm modules. This enables dynamic \u201copen\u201d systems as well as tiny footprint embedded systems or any combination thereof.","Advantageously, only three methods must be implemented: algAlloc\u2014return all memory allocation requests to application; algFree\u2014return pointers to all instance memory; and algInit\u2014initialize allocated instance memory.","Advantageously, multiple implementations of a same algorithm can co-exist by using a \u201cv-table\u201d to access functions.","Advantageously, object creation can be performed in a non-real-time manner. Object creation code can be overlaid and reused.","Advantageously, an activate-deactivate model allows performance and code space optimizations.","While the invention has been described with reference to illustrative embodiments, this description should not be construed in a limiting sense. Various other embodiments of the invention will be apparent to persons skilled in the art upon reference to this description. It is therefore contemplated that the appended claims will cover any such modifications of the embodiments as fall within the true scope and spirit of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIGS. 7A","FIG. 3"],"b":["7","7"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 9","FIG. 8"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 10","FIG. 3"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 11","FIG. 8"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 12","FIG. 11"]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 13","FIG. 8"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 15","FIG. 8"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 16","FIG. 8"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 17","FIG. 8"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 19","FIG. 3"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIGS. 20A and 20B","FIG. 3"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 22","FIG. 21"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 23A"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 23B"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 24","FIG. 8"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIGS. 26A","b":["26","26"]},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 27"}]},"DETDESC":[{},{}]}
