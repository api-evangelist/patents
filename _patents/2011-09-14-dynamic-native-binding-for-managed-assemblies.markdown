---
title: Dynamic native binding for managed assemblies
abstract: A method, apparatus, system, article of manufacture, and computer readable storage medium provides the ability to dynamically bind a native assembly from a managed assembly. A managed assembly (e.g., a dynamically linked library (DLL)) is obtained. In the managed assembly, native application program interface entry points are identified. For each of the entry points, intended platform(s) and associated correct native assembly(ies) are specified in the managed assembly. The managed assembly is deployed onto a computer. For example, the single collection of managed and native assemblies can be deployed to all targeted computers, which consist of varying platform environments. During runtime execution, the executing platform of the application is determined. Based on the executing platform, an intended platform is selected and the entry points are bound to the correct native assembly.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08776097&OS=08776097&RS=08776097
owner: Myspace, LLC
number: 08776097
owner_city: Beverly Hills
owner_country: US
publication_date: 20110914
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","CONCLUSION"],"p":["This application claims the benefit under 35 U.S.C. Section 119(e) of the following co-pending and commonly-assigned U.S. provisional patent application(s), which is\/are incorporated by reference herein:","U.S. Provisional Patent Application Ser. No. 61\/383,145, filed on Sep. 15, 2010, entitled \u201cDYNAMIC NATIVE BINDING FOR MANAGED ASSEMBLIES\u201d by PHILLIP KINKADE, BRANDON CUFF, and FRANKLIN WISE.","1. Field of the Invention","The present invention relates generally to computer programming, and in particular, to a method, apparatus, and article of manufacture for dynamically binding native assemblies from platform agnostic managed assemblies.","2. Description of the Related Art","Using Microsoft's .NET Framework\u2122, developers create managed assemblies, which are dynamic linked libraries (DLLs) that are executed by the .NET Framework. Managed assemblies can be compiled to be platform agnostic. This is known as an assembly that targets \u201cAny CPU\u201d. This is desirable because the same binary assembly can be deployed to any platform, such as Win32\u2122, x64\u2122, and IA64\u2122. Deployment means copying files to a target computer and installing the developer's work onto that computer. Typically, because of reflection, a managed assembly can only directly access other managed assemblies. In this regard, one managed assembly can inspect, find interface points, parameters, and other data about a single other managed assembly.","There are times when the developer needs to use code that is better suited, for whatever reason, in native assemblies. Native assemblies are traditional DLL's that are loaded and executed by the Windows\u2122 operating system. Native assemblies are practically always platform-specific.","The fact that native assemblies are platform-specific introduces the problem when a developer needs to deploy custom native assemblies along with \u201cAny CPU\u201d managed assemblies.","Microsoft\u2122 supplies a mechanism, DllImport\u2122, that performs binding to native assemblies. Binding is the process of attaching an application program interface point from one assembly to another, allowing use of the bound assembly. DllImport\u2122 is limited because it does not support run-time binding to various assemblies based on platform type. Further, to use DllImport\u2122, developers must know the exact location of the native assembly when the managed assembly is written, and either add the location to the system path or utilize specific code that identifies the location.","Prior solutions require complex, hard-to-debug code. Also, prior solutions encourage code duplication, which presents further issues in extra cost and defect risk in maintaining multiple copies of each platform interface.","The prior art may employ one or more of the following methods to dynamically bind to native assemblies from managed assemblies:","(1) DllImport (also known as System.Runtime.InteropServices.DllImport) (described above and more fully described in msdn.microsoft.com\/en-us\/library\/system.runtime.interopservices.dllimportattribute.aspx which is incorporated by reference herein). However, as described above, such a solution does not support run-time binding to various assemblies based on platform type;","(2) Avoid runtime dynamic binding by building distinct platform specific managed assemblies. This requires non-orthogonal deployment by platform type. In other words, separate source code is created for every platform;","(3) Duplicating the API (application programming interface) interface declarations in the managed code, once for each supported platform. An exemplary use of API duplication is set forth in stackoverflow.com\/questions\/1319849\/setting-dllimport-programatically-in-c which is fully incorporated by reference herein;","(4) Writing only two copies of each API interface, regardless of how many platforms are supported, but have the program write new executable code (known as emitting) and execute that emitted assembly. An exemplary use of such a solution is described in www.codeproject.com\/KB\/dotnet\/DynamicDllImport.aspx which is incorporated by reference herein. In other words, code is emitted\/written at run time which determines which assembly to bind to. Such emitted code inspects the platform the code is executed on, the processor type, etc. and a just-in-time complier complies and writes out an intermediate language to bind to the native assembly. One of the problems with such a solution is security; and","(5) Manually writing code that loads the native assembly and binds to the entry point. An exemplary use of such manual code writing is set forth at www.codeproject.com\/KB\/cs\/DynamicInvokeCSharp.aspx which is incorporated by reference herein.","Accordingly, a common practice is to utilize many distinct varieties of deployment platforms and further utilizing development platforms that may be different than deployed systems. Accordingly, there are many different code bases, one for every different platform. Prior art techniques require different deployments for the different platforms. What is needed is a method for utilizing both managed and native assemblies using a single deployment and single code base while supporting run-time binding to various assemblies based on platform type.","One or more embodiments of the invention provide the dynamic binding of native assemblies from platform agnostic managed assemblies. The concept of Microsoft's\u2122 System.Runtime.InteropServices.DllImportAttribute class is extended by replacing it with an attribute class, DynamicDllImportAttribute, that can describe native application program interface entry points and associate their containing native assemblies by platform.","During program execution a second class, DynamicDllImportBinder, examines the managed interface, finds the DynamicDllImportAttribute interfaces, and makes the connection between the managed and native assemblies. This is the binding process.","Multiple DynamicDllImportAttribute instances can be applied to any given native entry point. Each instance represents the intended platform and the correct native assembly associated with that platform.","In the following description, reference is made to the accompanying drawings which form a part hereof, and which is shown, by way of illustration, several embodiments of the present invention. It is understood that other embodiments may be utilized and structural changes may be made without departing from the scope of the present invention.","Overview","One or more embodiments of the invention provide a DynamicDllImport class that is implemented by applying an instance of it, as an attribute, to member properties of static managed classes. DynamicDllImportBinder, a companion class to DynamicDllImportAttribute is used during the static construction of the Managed class to execute the binding decisions and connect the appropriate exposed native assembly entry points to the Managed class.","Once the invention's code is referenced in a project, the developer only declares the following to achieve dynamic native assembly bindings: a prototype, assembly names, and a property. For example:",{"@attributes":{"id":"p-0031","num":"0030"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","\/\/ Bind to entry point named \u201cSomeAPIFunction1\u201d in \u201cExample.*.dll\u201d:"]},{"entry":[{},"public delegate IntPtr SomeAPIFunction1Prototype( );"]},{"entry":[{},"[DynamicDllImport(Platform.Win32, \u201cExample.Win32.dll\u201d)]"]},{"entry":[{},"[DynamicDllImport(Platform.X64, \u201cExample.x64.dll\u201d)]"]},{"entry":[{},"static public SomeAPIFunction1Prototype SomeAPIFunction1"]},{"entry":[{},"{"]},{"entry":[{},"\u2003get;"]},{"entry":[{},"\u2003private set;"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Deployment of an application that uses DynamicDllImport is simplified as the exact same set of files can be copied to any target computer, regardless of platform. The files that are not used by a specific platform are ignored at runtime by DynamicDllImport.","In addition, DynamicDllImport may be expanded to include other factors than simply the runtime platform to determine which native assembly to bind to.","Hardware Environment",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1","b":["100","102","102","102","104","104","104","106","102","114","116","128","102","132"]},"In one embodiment, the computer  operates by the general purpose processor A performing instructions defined by the computer program  under control of an operating system . The computer program  and\/or the operating system  may be stored in the memory  and may interface with the user and\/or other devices to accept input and commands and, based on such input and commands and the instructions defined by the computer program  and operating system  to provide output and results.","Output\/results may be presented on the display  or provided to another device for presentation or further processing or action. In one embodiment, the display  comprises a liquid crystal display (LCD) having a plurality of separately addressable liquid crystals. Each liquid crystal of the display  changes to an opaque or translucent state to form a part of the image on the display in response to the data or information generated by the processor  from the application of the instructions of the computer program  and\/or operating system  to the input and commands. The image may be provided through a graphical user interface (GUI) module A. Although the GUI module A is depicted as a separate module, the instructions performing the GUI functions can be resident or distributed in the operating system , the computer program , or implemented with special purpose memory and processors.","Some or all of the operations performed by the computer  according to the computer program  instructions may be implemented in a special purpose processor B. In this embodiment, the some or all of the computer program  instructions may be implemented via firmware instructions stored in a read only memory (ROM), a programmable read only memory (PROM) or flash memory within the special purpose processor B or in memory . The special purpose processor B may also be hardwired through circuit design to perform some or all of the operations to implement the present invention. Further, the special purpose processor B may be a hybrid processor, which includes dedicated circuitry for performing a subset of functions, and other circuits for performing more general functions such as responding to computer program instructions. In one embodiment, the special purpose processor is an application specific integrated circuit (ASIC).","As used herein, the computer  may be utilized within a .NET\u2122 framework available from Microsoft\u2122. The .NET framework is a software framework (e.g., computer program ) that can be installed on computers  running Microsoft\u2122 Windows\u2122 operating systems . It includes a large library of coded solutions to common programming problems and a virtual machine that manages the execution of programs  written specifically for the framework. The .NET framework can support multiple programming languages in a manner that allows language interoperability.","The computer  may also implement a compiler  which allows an application program  written in a programming language such as COBOL, Pascal, C++, FORTRAN, or other language to be translated into processor  readable code. After completion, the application or computer program  accesses and manipulates data accepted from I\/O devices and stored in the memory  of the computer  using the relationships and logic that was generated using the compiler .","The computer  also optionally comprises an external communication device such as a modem, satellite link, Ethernet card, or other device for accepting input from and providing output to other computers .","In one embodiment, instructions implementing the operating system , the computer program , and the compiler  are tangibly embodied in a computer-readable medium, e.g., data storage device , which could include one or more fixed or removable data storage devices, such as a zip drive, floppy disc drive , hard drive, CD-ROM drive, tape drive, etc. Further, the operating system  and the computer program  are comprised of computer program instructions which, when accessed, read and executed by the computer , causes the computer  to perform the steps necessary to implement and\/or use the present invention or to load the program of instructions into a memory, thus creating a special purpose data structure causing the computer to operate as a specially programmed computer executing the method steps described herein. Computer program  and\/or operating instructions may also be tangibly embodied in memory  and\/or data communications devices , thereby making a computer program product or article of manufacture according to the invention. As such, the terms \u201carticle of manufacture,\u201d \u201cprogram storage device\u201d and \u201ccomputer program product\u201d as used herein are intended to encompass a computer program accessible from any computer readable device or media.","Of course, those skilled in the art will recognize that any combination of the above components, or any number of different components, peripherals, and other devices, may be used with the computer .","Although the term \u201cuser computer\u201d or \u201cclient computer\u201d is referred to herein, it is understood that a user computer  may include portable devices such as cell phones, notebook computers, pocket computers, or any other device with suitable processing, communication, and input\/output capability.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 2","FIG. 1"],"b":["200","202","102","206","202","102","206"]},"A network  such as the Internet connects clients  to server computers . Network  may utilize ethernet, coaxial cable, wireless communications, radio frequency (RF), etc. to connect and provide the communication between clients  and servers . Clients  may execute a client application or web browser and communicate with server computers  executing web servers . Such a web browser is typically a program such as MICROSOFT INTERNET EXPLORER\u2122, MOZILLA FIREFOX\u2122, OPERA\u2122, APPLE SAFARI\u2122, etc. Further, the software executing on clients  may be downloaded from server computer  to client computers  and installed as a plug in or ACTIVEX\u2122 control of a web browser. Accordingly, clients  may utilize ACTIVEX\u2122 components\/component object model (COM) or distributed COM (DCOM) components to provide a user interface on a display of client . The web server  is typically a program such as MICROSOFT'S INTERNET INFORMATION SERVER\u2122.","Web server  may host an Active Server Page (ASP) or Internet Server Application Programming Interface (ISAPI) application , which may be executing scripts. The scripts invoke objects that execute business logic (referred to as business objects). The business objects then manipulate data in database  through a database management system (DBMS) . Alternatively, database  may be part of or connected directly to client  instead of communicating\/obtaining the information from database  across network . When a developer encapsulates the business functionality into objects, the system may be referred to as a component object model (COM) system. Accordingly, the scripts executing on web server  (and\/or application ) invoke COM objects that implement the business logic. Further, server  may utilize MICROSOFT'S\u2122 Transaction Server (MTS) to access required data stored in database  via an interface such as ADO (Active Data Objects), OLE DB (Object Linking and Embedding DataBase), or ODBC (Open DataBase Connectivity).","Generally, these components - all comprise logic and\/or data that is embodied in\/or retrievable from device, medium, signal, or carrier, e.g., a data storage device, a data communications device, a remote computer or device coupled to the computer via a network or via another data communications device, etc. Moreover, this logic and\/or data, when read, executed, and\/or interpreted, results in the steps necessary to implement and\/or use the present invention being performed.","Although the term \u201cuser computer\u201d, \u201cclient computer\u201d, and\/or \u201cserver computer\u201d is referred to herein, it is understood that such computers  and  may include portable devices such as cell phones, notebook computers, pocket computers, or any other device with suitable processing, communication, and input\/output capability.","Of course, those skilled in the art will recognize that any combination of the above components, or any number of different components, peripherals, and other devices, may be used with computers  and .","Software Embodiments","Embodiments of the invention are implemented as a software application  on a client  or server computer  and may be referred to herein as \u201cDynamicDLL Import.\u201d DynamicDLL Import works similar to the DLLImportAttribute\u2122 class offered by Microsoft\u2122 except that the DynamicDLL Import adds the ability to decide which specific native assembly to bind to at run time. Primarily, DynamicDLL Import is used to ease deployment of \u201cAny CPU\u201d managed assemblies that rely on platform-specific native assemblies.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 3","b":["302","302","304"]},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 3","FIG. 3"],"b":["306","308","304"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 4","FIG. 4"]},{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2009","using System;"]},{"entry":[{},"using MySpace.Common.Runtime.InteropServices;"]},{"entry":[{},"public static class ExampleNativeAPI"]},{"entry":[{},"{"]},{"entry":[{},"\u2003public static ExampleNativeApi( )"]},{"entry":[{},"\u2003{"]},{"entry":[{},"\u2003\u2003DynamicDLLImportBinder.Bind(typeof(ExampleNativeApi));"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003\/\/ Bind to entry point named \u201cSomeAPIFunction1\u201d in \u201cExample.*.dll\u201d;"]},{"entry":[{},"\u2003public delegate IntPtr SomeAPIFunction1Prototype( );"]},{"entry":[{},"\u2003[DynamicDllImport(Platform.Win32, \u201cExample.Win32.dll\u201d)]"]},{"entry":[{},"\u2003[DynamicDllImport(Platform.X64, \u201cExample.X64.dll\u201d)]"]},{"entry":[{},"\u2003Static public SomeAPIFunction1Prototype SomeAPIFunction1 {get; "]},{"entry":[{},"private set;}"]},{"entry":[{},"\u2003\/\/ Bind to entry point named \u201cDeleteItem\u201d in \u201cExample.*.dll\u201d, and "]},{"entry":[{},"declare marshalling;"]},{"entry":[{},"\u2003public delegate void DeleteItemPrototype ("]},{"entry":[{},"\u2003\u2003IntPtr xdb,"]},{"entry":[{},"\u2003\u2003[MarshalAs(UnmanagedType.LPArray)]"]},{"entry":[{},"\u2003\u2003byte[ ]keyValue,"]},{"entry":[{},"\u2003\u2003byte keyLength);"]},{"entry":[{},"\u2003[DynamicDllImport(Platform.Win32, \u201cExample.Win32.dll\u201d)]"]},{"entry":[{},"\u2003[DynamicDllImport(Platform.X64, \u201cExample.X64.dll\u201d)]"]},{"entry":[{},"\u2003Static public DeleteItemPrototype DeleteItem (get; private set;)"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"At step , an assembly reference is added to a managed assembly (e.g., myspace.common.dll). Such a DLL may be located in a particular folder\/location (e.g., a drop folder).","At step , a static constructor is created (e.g., for the ExampleNativeAPI class). The static constructor executes the binding decisions and connects the appropriate exposed native assembly entry points to the managed class (i.e., at run-time). In the example code above, the static constructor calls \u201cDynamicDllImportBinder.Bind( )\u201d with the type of the enclosing class as its parameter (i.e., the type of class of the ExampleNativeAPI).","At step , a delegate type is declared that defines the prototype of the static native assembly entry points. Entry points identify the locations of a function within a DLL. Marshalling attributes (i.e., moving data outside of the domain\/assembly the application is executed in to a different domain\/assembly) may be used in the declaration. As used herein, a delegate is a form of type-safe function pointer used by the .NET framework. Delegates specify a method to call and optionally, an object to call the method on. Often, delegates are used to implement callbacks.","In the exemplary code, there are two entry points (i.e., for the native assemblies): SomeAPIFunction1 and DeleteItem (which includes marshalling). The prototype method \u201cSomeAPIFuntion1Prototype( )\u201d is declared as type IntPtr (i.e., a platform-specific integer type that is used to represent a pointer or a handle). For example, the IntPtr type can be an integer whose size is platform-specific as 32-bits on 32-bit hardware\/operating systems or 64-bits on 64-bit hardware\/operating systems. Thus, in the exemplary code, the prototype function is a delegate of type IntPtr. Similarly, the DeleteItem prototype is declared as type void.","At step , one or more [DynamicDllImport] attribute declarations may be used to specify the target assembly and the corresponding assembly name. In the exemplary code, the following code is used to specify the target assemblies for Win32 and X64:",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003","[DynamicDllImport(Platform.Win32, \u201cExample.X64.dll\u201d)]"]},{"entry":[{},"[DynamicDllImport(Platform.X64, \u201cExample.X64.dll\u201d)]"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"At step , a property is declared as a type of the prototype delegate with a getter and a setter. In the above example, for each prototype delegate (i.e., SomeAPIFunction1 and DeleteItemPrototype), get and set parameters are used to declare the type of delegate.","At step , the classes using the DynamicDLL Import are deployed. When deploying such classes, care should be taken to include the native assemblies, if they are not already installed on the target computers. For example, the MSBuild\u2122 build platform generally does not automatically deploy dependent native assemblies with managed assemblies.","The following code illustrates an exemplary implementation of the DynamicDLLImportAttribute class that can be applied to member properties of static managed classes to implement one or more embodiments of the invention.",{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"namespace MySpace.Common.Runtime.Interop Services"},{"entry":"{"},{"entry":"\u2003\/\/\/ <summary>"},{"entry":"\u2003\/\/\/ DynamicDllImportAttribute allows runtime binding to native"},{"entry":"assemblies based on platform type."},{"entry":"\u2003\/\/\/ <\/summary>"},{"entry":"\u2003[AttributeUsage(AttributeTargets.Property, AllowMultiple = true)]"},{"entry":"\u2003public class DynamicDllImportAttribute : Attribute"},{"entry":"\u2003{"},{"entry":"\u2003\u2003\/\/\/ <summary>"},{"entry":"\u2003\u2003\/\/\/ TargetPlatform is used by DynamicDllImportBinder to"},{"entry":"determine the platform the element embued with this "},{"entry":"attribute is relevant for."},{"entry":"\u2003\u2003\/\/\/ <\/summary>"},{"entry":"\u2003\u2003public Platform TargetPlatform {get; private set; }"},{"entry":"\u2003\u2003\/\/\/ <summary>"},{"entry":"\u2003\u2003\/\/\/ AssemblyName identifies the path to the native assembly that"},{"entry":"represents to platform-specific native assembly. The full path isn't required "},{"entry":"as DynamicDllImport Binder will search various well-known locations to "},{"entry":"find the assembly. (Deployment directory and environment path)."},{"entry":"\u2003\u2003\/\/\/ <\/summary>"},{"entry":"\u2003\u2003public String AssemblyName {get; private set; }"},{"entry":"\u2003\u2003\/\/\/ <summary>"},{"entry":"\u2003\u2003\/\/\/ EntryPoint is optional. If unspecified, the EntryPoint is"},{"entry":"determined by the reflected name of the element that binds to the native "},{"entry":"assembly. Specify an EntryPoint if the actual entrypoint is not sytactically "},{"entry":"possible to write. For example, native assemblies may specify entry points "},{"entry":"such as \u201c_MyEntryPoint@l6\u201d, which cannot be a valid symbol name in c#."},{"entry":"\u2003\u2003\/\/\/ <\/summary>"},{"entry":"\u2003\u2003public String EntryPoint {get; set;}"},{"entry":"\u2003\u2003\/\/\/ <summary>"},{"entry":"\u2003\u2003\/\/\/ Initializes a new instance of the <see"},{"entry":"cref=\u201cDynamicDllIMportAttribute\u201d\/>class."},{"entry":"\u2003\u2003\/\/\/ <\/summary>"},{"entry":"\u2003\u2003\/\/\/ <param name=\u201dtargetPlatform\u201d>The target platform.<\/param>"},{"entry":"\u2003\u2003\/\/\/ <param name=\u201dassemblyName\u201d>Name of the native assembly"},{"entry":"for the specified platform.<\/param>"},{"entry":"\u2003\u2003public DynamicDllImportAttribute(Platform targetPlatform, string"},{"entry":"assemblyName)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003AssemblyName = assemblyName;"},{"entry":"\u2003\u2003\u2003TargetPlatform = targetPlatform;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":"namespace MySpace.Common.Runtime.Interop Services"},{"entry":"{"},{"entry":"\u2003\/\/\/ <summary>"},{"entry":"\u2003\/\/\/ DynamicDllImportBinder uses reflection to bind a native assembly "},{"entry":"\u2003to managed delegated. <see cref=\u201dDyanmicDllImportAttribute\u201d\/> "},{"entry":"\u2003depends on"},{"entry":"\u2003the binder for the attribute to function"},{"entry":"\u2003\/\/\/ <\/summary>"},{"entry":"\u2003public static class DynamicDllImportBinder"},{"entry":"\u2003{"},{"entry":"\u2003\u2003private static readonly Dictionary<string, IntPtr> Libraries = new"},{"entry":"\u2003Dictionary <string, IntPtr>( );"},{"entry":"\u2003\u2003private static readonly Platform EffectivePlatform = IntPtr.Size == 4 ?"},{"entry":"\u2003Platform.Win3s : Platform.X64;"},{"entry":"\u2003\u2003\/\/\/ <summary>"},{"entry":"\u2003\u2003\/\/\/ Binds the delegate properties of the type to native assemblies."},{"entry":"\u2003Properties bound are marked with <see"},{"entry":"\u2003cref=\u201dDynamicDllImportAttribute\u201d\/>.l Classes would normally call"},{"entry":"\u2003DynamicDllImportbinder.Bind( ) in a static constructor."},{"entry":"\u2003\u2003\/\/\/ <\/summary>"},{"entry":"\u2003\u2003\/\/\/ <param name=\u201dtype\u201d>The type that contains delegates that"},{"entry":"\u2003have the DynamicDllImport attribute applied to them. <\/param>"},{"entry":"\u2003\u2003public static void Bind(Type type)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\/\/\/ reflect over the type class find all properties that have"},{"entry":"\u2003\u2003the DynamicDllImportAttribute, and bind them to the assembly"},{"entry":"\u2003\u2003referenced."},{"entry":"\u2003\u2003\u2003var properties = type.GetProperties(BindingFlags.Static |"},{"entry":"\u2003\u2003BindingFlags.NonPublic | BindingFlags.Public);"},{"entry":"\u2003\u2003\u2003foreach (var property in properties)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003var attributes = property.GetCustomAttributes(typeof"},{"entry":"\u2003\u2003\u2003(DynamicDllIMportAttribute), falst);"},{"entry":"\u2003\u2003\u2003\u2003if (attributes.Length > 0)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003foreach (DynamicDllImportAttribute attribute in"},{"entry":"\u2003\u2003\u2003\u2003attributes)"},{"entry":"\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (attribute.TargetPlatform =="},{"entry":"\u2003\u2003\u2003\u2003\u2003EffectivePlatform)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003property.SetValue(null,"},{"entry":"\u2003GetUnmanagedDelegate(attribute.AseemblyName, attribute.Entrypoint ??"},{"entry":"\u2003property.Name, Property.PropertyType), null);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003private static Delegate GetUnmanagedDelegate(string"},{"entry":"\u2003unmanagedAssembly, string entryPoint, Type DelegateType)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003IntPtr hModule;"},{"entry":"\u2003\u2003\u2003if (Libraries.ContainsKey(unmanagedAssembly))"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003hModule = Libraries[unmanagedAssembly];"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003else"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003hModule ="},{"entry":"\u2003\u2003AttemptLoadLibrary(unmanagedAssembly);"},{"entry":"\u2003\u2003\u2003\u2003if (hModule == IntPtr.Zero)"},{"entry":"\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003throw new ApplicationException(String.Format("},{"entry":"\u2003\u2003\u2003\u201cCannot load assembly {0}with error code 0x {1.x}. Deploy"},{"entry":"\u2003\u2003\u2003this native assembly with the managed assemblies (the .NET"},{"entry":"\u2003\u2003\u2003framework may not automatically copy it for you), or that it is"},{"entry":"\u2003\u2003\u2003in the environment Path of the process.\u201d, unamangedAssembly,"},{"entry":"\u2003\u2003\u2003Marshal.GetLastWin32Error( )));"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003Libraries[unmanagedAssembly] = hModule;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003IntPtr procAddr = GetProcAddress(hModule, entryPoint);"},{"entry":"\u2003\u2003\u2003if (procAddr == IntPtr.Zero)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003throw new ApplicationException(String.Format("},{"entry":"\u2003\u2003\u2003\u201cCould not bind to entry point {0}in assembly {1}. The"},{"entry":"\u2003\u2003\u2003assembly was found, but binding to the entry point failed with"},{"entry":"\u2003\u2003\u2003code 0x {2:x}.\u201d, entryPoint, unamangedAssembly,"},{"entry":"\u2003\u2003\u2003Marshal.GetLastWin32Error( )));"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003return Marshal.GetDelegateForFurnctionPointer(procAddr,"},{"entry":"\u2003delegateType);"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003[DllImport(\u201ckernel32.dll\u201d, SetLastError = true)]"},{"entry":"\u2003\u2003private static extern IntPtr LoadLibrary(String dllName);"},{"entry":"\u2003\u2003[DllImport(\u201ckernel32.dll\u201d, SetLastError = true)]"},{"entry":"\u2003\u2003private static extern IntPtr GetProcAddress(IntPtr hModule, String"},{"entry":"\u2003procName);"},{"entry":"\u2003\u2003private static IntPtr AttemptLoadLibrary(string unmanagedAssembly)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\/\/ try to load it in the current environment PATH (normal"},{"entry":"\u2003\u2003for location native assemblies)."},{"entry":"\u2003\u2003\u2003var hModule = LoadLibrary(unmanagedAssembly);"},{"entry":"\u2003\u2003\u2003if (hModule == IntPtr.Zero)"},{"entry":"\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003ShadowCopier.CopyAssemblyFile(unamagnedAssembly);"},{"entry":"\u2003\u2003\u2003\u2003hModule = LoadLibrary(Path.Combine"},{"entry":"\u2003\u2003\u2003(AppDomain.CurrentDomain.BaseDirectory,"},{"entry":"\u2003\u2003\u2003unamangedAssembly));"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003return hModule;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 5","b":"502"},"At step , one or more native application program interface entry points are identified in the managed assembly.","At step , for each of the one or more entry points, one or more intended platforms are specified in the managed assembly. In addition, for each of the one or more intended platforms, an associated correct native assembly is also specified in the managed assembly. To specify the intended platforms and associated native assemblies, an instance of a class may be applied as an attribute to each of the entry points. Intended platforms may include a 32-bit native assembly, a 64-bit native assembly, or any other type of platform.","At step , the managed assembly is deployed onto a first computer.","Steps - are all performed during runtime execution. Further, a binding class may be used during a static construction of the managed assembly during runtime execution to perform steps -.","At step , the executing platform of the application (i.e., on the first computer) is determined.","At step , one of the one or more intended platforms is selected based on the executing platform.","At step , each of the entry points from the managed assembly is bound to the associated correct native assembly based on the selected intended platform.","This concludes the description of the preferred embodiment of the invention. The following describes some alternative embodiments for accomplishing the present invention. For example, any type of computer, such as a mainframe, minicomputer, or personal computer, or computer configuration, such as a timesharing mainframe, local area network, or standalone personal computer, could be used with the present invention.","The foregoing description of the preferred embodiment of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Referring now to the drawings in which like reference numbers represent corresponding parts throughout:",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
