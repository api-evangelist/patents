---
title: Metadata merging in agent configuration files
abstract: A technique for updating agent software which controls an agent, including how the agent adds instrumentation to an application and how the agent process data from the instrumentation. A current configuration file and an updated configuration file are evaluated in view of rules, to create a merged configuration file. The files include metadata entries. The rules can include: delete a current configuration file, not merge a current configuration file with an updated configuration file, overwrite a current configuration file with an updated configuration file, delete a metadata entry, prefer an entry in the configuration file over a corresponding entry in the updated configuration file, and prefer an entry in the updated configuration file over the corresponding entry in the configuration file. Customized entries in the current configuration file can be maintained if appropriate. Entries which are not maintained are kept in the merged configuration file as inline comments for documentation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08752015&OS=08752015&RS=08752015
owner: CA, Inc.
number: 08752015
owner_city: Islandia
owner_country: US
publication_date: 20111205
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["1. Field of the Invention","Technology for monitoring software in a computing environment is provided.","2. Description of the Related Art","The growing presence of the Internet as well as other computer networks such as intranets and extranets has brought many new applications in e-commerce, education and other areas. Organizations increasingly rely on such applications to carry out their business or other objectives, and devote considerable resources to ensuring that they perform as expected. To this end, various application management techniques have been developed. One approach involves monitoring the infrastructure of the application by instrumenting the application and using the instrumentation to collect data regarding the individual software components that are invoked in the application. This approach can use agents that essentially live in the system being monitored. For example, using the instrumentation, a thread or process can be traced to identify each component that is invoked, as well as to obtain runtime data such as the execution time of each component.","The agent software is updated from time to time, such as to provide new features and fix bugs. However, the update process is made difficult due to custom settings in the agent software which are made by the network administrator. Preserving the custom settings while updating the agent software can require extensive, time consuming manual input.","The present invention provides a technique for updating agent software which controls a configuration of the agent, including how the agent adds instrumentation to an application and how the agent process data from the instrumentation.","In one embodiment, one or more tangible processor-readable storage devices having computer readable software embodied thereon are provided for programming at least one processor to perform a method for updating a current version of a configuration file which controls an agent which monitors an application. The method includes: creating a merged version of the configuration file based on the current version of the configuration file, an updated version of the configuration file, and rules, and using the merged version of the configuration file to control the agent. The creating the merged version of the configuration file comprises: identifying an entry in the current version of the configuration file for which there is a corresponding entry in the updated version of the configuration file; selecting one of: (a) the entry in the current version of the configuration file and (b) the corresponding entry in the updated version of the configuration file, as a selected entry, based on at least one preference in the rules; and based on the selecting, adding the selected entry to the merged version of the configuration file.","In another embodiment, one or more tangible processor-readable storage devices having computer readable software embodied thereon are provided for programming at least one processor to perform a method for updating a current version of a configuration file which controls an agent which monitors an application. The method includes: accessing rules, the rules indicate whether a current version of the configuration file should be at least one of: not merged and overwritten; if the rules indicate that the current version of the configuration file should be not merged, continuing to use the current version of the configuration file to control the agent without using the updated version of the configuration file to control the agent; if the rules indicate that the current version of the configuration file should be overwritten, using the updated version of the configuration file to control the agent and discontinuing using the current version of the configuration file to control the agent; and in response to determining that the rules do not indicate that the current version of the configuration file should be not merged, and that the rules do not indicate that the current version of the configuration file should be overwritten: creating a merged version of the configuration file based on the current version of the configuration file, the updated version of the configuration file, and the rules, and using the merged version of the configuration file to control the agent.","A corresponding processor-implemented method may be provided which performs computer-implemented steps as described above. A corresponding computer system may be provided which includes one or more tangible processor-readable storage devices having computer readable software embodied thereon, and at least one processor, where the at least one processor is responsive to the one or more tangible processor-readable storage devices to update a current version of a configuration file, as described above.","In another embodiment, a computer-implemented method is provided for updating a current version of a configuration file which controls an agent which monitors an application. The computer-implemented method includes: accessing the current version of the configuration file and an updated version of the configuration file; accessing rules in one or more files; creating and storing a merged version of the configuration file based on the current version of the configuration file, the updated version of the configuration file, and rules; and using the merged version of the configuration file to control behavior of the agent, including how the agent adds instrumentation to the application and a configuration of the agent The creating the merged version of the configuration file comprises: processing entries in the current version of the configuration file; and for each entry in the current version of the configuration file: determining whether there is a corresponding entry in the updated version of the configuration file, and if there is the corresponding entry, selecting one of: (a) the entry in the current version of the configuration file and (b) the corresponding entry in the updated version of the configuration file, as a selected entry, based on at least one preference in the rules, and based on the selecting, adding the selected entry to the merged version of the configuration file.","One or more tangible processor-readable storage devices having computer readable software embodied thereon can also be provided for programming at least one processor to perform the above-mentioned method. A corresponding computer system may be provided which includes one or more tangible processor-readable storage devices having computer readable software embodied thereon, and at least one processor, where the at least one processor is responsive to the one or more tangible processor-readable storage devices to update a current version of a configuration file, as described above.","The present invention provides a technique for merging metadata of agent software. The metadata is typically provided in one or more configuration files which control a configuration of the agent, including how the agent adds instrumentation to an application and how the agent process data from the instrumentation. The technique evaluates a current configuration file and an updated configuration file in view of rules. The files include metadata entries which relate to specific features\/actions of the agent. The rules can include: delete a current configuration file, not merge a current configuration file with an updated configuration file, overwrite a current configuration file with an updated configuration file, delete a metadata entry, prefer an entry in the configuration file over a corresponding entry in the updated configuration file, and prefer an entry in the updated configuration file over the corresponding entry in the configuration file. Based on the rules, a merged configuration file is created. The process allows customized entries in the current configuration file to be maintained if appropriate. Entries which are not maintained can be kept in the merged configuration file as inline comments for documentation or later activation.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 1","b":["100","103","105","111","102","102","111","103","105","101","102","101","102","108","108"]},"For example, a corporation running an enterprise application such as a web-based e-commerce application may employ a number of application servers at one location for load balancing. Requests from users, such as from the example web browser , are received via the network , and can be routed to any of the managed computing devices. Agent software running on the managed computing devices  and , denoted by agent  and agent , respectively, gather information from an application, middleware or other software, running on the respective managed computing devices. Such information may be obtained using instrumentation, one example of which is byte code instrumentation. However, the gathered data may be obtained in other ways as well. The agents essentially live in the computing device being monitored and provide a data acquisition point. The agents organize and optimize the data communicated to the manager . In one implementation, different instances of the same application run at the managed computing devices.","The manager  can be provided on a separate computing device such as a workstation which communicates with a user interface  (see also ), such as a monitor, to display information based on data received from the agents. The manager can also access a database  to store the data received from the agents. For instance, some large organizations employ a central network operations center where one or more managers obtain data from a number of distributed agents at different geographic locations. To illustrate, a web-based e-commerce enterprise might obtain agent data from servers at different geographic locations that receive customer orders, from servers that process payments, from servers at warehouses for tracking inventory and conveying orders, and so forth. The manager  and user interface display  might be provided at a corporate headquarters location. Other applications which are not necessarily web-based or involve retail or other sales, similarly employ agents and managers for managing their systems. For example, a bank may use an application for processing checks and credit accounts. Moreover, in addition to the multi-computing device arrangements mentioned, a single computing device can be monitored as well with one or more agents.","Various approaches are known for instrumenting software to monitor its execution. For example, tracing may be used to track the execution of software. One example of tracing is discussed in U.S. Pat. No. 7,870,431, issued Jan. 11, 2011, titled \u201cTransaction Tracer,\u201d and incorporated herein by reference. In one approach discussed therein, object code or bytecode of an application to be monitored is instrumented, e.g., modified, with probes. The probes measure specific pieces of information about the application without changing the application's business or other logic. Once the probes have been installed in the bytecode of an application, it is referred to as a managed application, and a computing device on which the application runs is referred to as a managed computing device. The agent software receives information from the probes and may communicate the information to another process, such as at the manager , or process the information locally, such as to determine whether the information indicates an abnormal condition. The agent thus collects and summarizes information received from the probes. The probes collect information as defined by a directives file. For example, the information from the probes may indicate start and stop times of a transaction or other execution flow, or of individual components within a transaction\/execution flow. This information can be compared to pre-established criteria to determine if it within bounds. If the information is not within bounds, the agent can report this fact to the manager so that appropriate troubleshooting can be performed. The agents are typically aware of the software executing on the local managed computing device with which they are associated.","The probes can report a standard set of metrics which include: CORBA method timers, Remote Method Invocation (RMI) method timers, Thread counters, Network bandwidth, JDBC update and query timers, Servlet timers, Java Server Pages (JSP) timers, System logs, File system input and output bandwidth meters, Available and used memory and EJB (Enterprise JavaBean) timers. A metric is a measurement of a specific application activity. Each of these metrics can be configured by agent metadata.","An agent reports information about transactions, which identifies resources which are accessed by an application. In one approach, when reporting about transactions, the word Called designates a resource. This resource is a resource (or a sub-resource) of a parent component, which is a consumer. For example, assume that Servlet A is the first component invoked in a transaction. Under the consumer Servlet A (see below), there may be a sub-resource Called EJB. Consumers and resources can be reported by the agent in a tree-like manner. Data for a transaction can also be stored according to the tree. For example, if a Servlet (e.g., Servlet A) is a consumer of a network socket (e.g., Socket C) and is also a consumer of an EJB (e.g. EJB B), which in turn is a consumer of a JDBC (e.g., JDBC D), the tree might look something like the following:",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Servlet A"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Data for Servlet A"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Called EJB B"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Data for EJB B"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Called JDBC D"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Data for JDBC D"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Called Socket C"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Data for Socket C"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In one embodiment, the above tree is stored by the agent in a stack, called the Blame Stack. When transactions are started, they are pushed onto the stack. When transactions are completed, they are popped off the stack. In one embodiment, each transaction on the stack has the following information stored: type of transaction, a name used by the system for that transaction, a hash map or dictionary of parameters, a timestamp for when the transaction was pushed onto the stack, and sub-elements. Sub-elements are Blame Stack entries for other components (e.g., methods, process, procedure, function, thread, set of instructions, etc.) that are started from within the transaction of interest. Using the tree as an example above, the Blame Stack entry for Servlet A would have two sub-elements. The first sub-element would be an entry for EJB B and the second sub-element would be an entry for Socket Space C. Even though a sub-element is part of an entry for a particular transaction, the sub-element will also have its own Blame Stack entry. An example of an entry point to a transaction\/branch is a URL. As the tree above notes, EJB B is a sub-element of Servlet A and also has its own entry. The top (or initial) entry (e.g., Servlet A) for a transaction, is called the root component. Each of the entries on the stack is an object.","Each agent adds instrumentation to an application and is configured based on one or more configuration files. For example, agent  may use configuration files ,  and , and agent  may use configuration files ,  and . The configuration files can include an agent profile file, a probe builder directives file and a probe builder list file, for instance (e.g., files ,  and , respectively, or ,  and , respectively). One or more of each type of file may be used. See also .","A) Agent Profile File","The agent profile files are responsible for enabling\/disabling of agent features, location of server, type of communication (e.g., plain socket, SSL, HTTP, HTTP over SSL), location of configuration files and log files, metric sending frequency, and so forth. An example file location is: apm.agent.changeDetector.profile=..\/common\/change-detector.xml. As another example, consider a feature referred to as \u201cApplication Map,\u201d which is a directed graph or map that aggregates transactions and displays interactions between subsystems. This feature (referred to as feature ) could be enable by the following example code:\n\n","If an entry in the current version of the configuration file sets the feature to true, and the corresponding entry in the updated version of the configuration file sets the feature to false, the entries define a conflicting enabled\/disabled status of a feature of the agent.","Consider different types of communication which an agent can use, such as to report data obtained from instrumentation of an application to a manager. A specified protocol and host information can be used. For example, a TCP (Transmission Control Protocol) and a default host (localhost) can be specified by the following example code:\n\n","A default port # () can be specified by the following example code:\n\n","A default socket (apm.net.StandardSocketFactory) can be specified by the following example code:\n\n","If an entry in the current version of the configuration file defines a default port of , and the corresponding entry in the updated version of the configuration file defines a default port of , the entries define conflicting types of communication used by the agent.","An example of a location of a log file can be specified by the following code:\n\n","If the entry in the current version of the configuration file sets one location of a log file, and the corresponding entry in the updated version of the configuration file sets another, different location of the log file, the entries define conflicting locations of a log file of the agent.","B) Probe Builder Directives File","A probe builder directives file contains directives for the agent. Directives may contain information about the type and source of metrics to generate, e.g., by specifying at least one method of a class or set of classes to monitor and a type of information to be collected in the application, or information about a formatter for renaming a metric, and so forth. Directives can also specify at least one method of a class or set of classes to instrument. Directives are relevant for configuration files of type PBD, for instance. The following is an example of a custom tracer used for generating a metric:","#Specify Custom Tracer Mapping\u2014responsible for generating the metric\n\n","#Set optional Tracer Parameters\n\n","#Set Tracer Group\u2014primarily responsible for turning on\/off tracers\n\n","#Link a Tracer Group with a particular resource (class)\n\n","#Set up Custom Tracer directive\n\n","If an entry in the current version of a configuration file provides one directive (e.g., instrument a method A in class A) and the corresponding entry in the updated version of the configuration file provides another, conflicting directive (e.g., do not instrument the method A in the class A), the entries define conflicting directives regarding at least one method of a class or set of classes to monitor and a type of information to be collected in the application.","Another example of conflicting probe builder directives is when one file has an entry meta.data.entry.2=Blue and another file has the entry meta.data.entry.2=Orange.","C) Probe Builder Listing file","A PBL (Probe Builder Listing) configuration file is used for grouping a set of PBD files. For example:","# List Title\n\n","# List Description\n\n","# Directives Files","# One directives file name per line. Relative names","# are resolved against the location of this file.\n\n","The applications of the servers  and  can execute in an execution environment such as the JAVA runtime environment, as discussed in connection with . The JAVA runtime environment uses a Java Virtual Machine (JVM). Programs intended to run on a JVM are typically compiled into a standardized portable binary format, which usually are in the form of .class files. A program may include many classes in different files. For easier distribution of large programs, multiple class files may be packaged together in a (JAVA Archive) JAR file. The JVM runtime executes class or JAR files, emulating the JVM instruction set by interpreting it, or using a just-in-time compiler (JIT). JIT compiling, as opposed to interpreting, is often used in a JVM to achieve greater speed.",{"@attributes":{"id":"p-0072","num":"0098"},"figref":"FIG. 2A","b":["130","132"]},{"@attributes":{"id":"p-0073","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Parameters","Appears in","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["UserID","Servlet, JSP","The UserID of the end-user invoking"]},{"entry":[{},{},"the http servlet request."]},{"entry":["URL","Servlet, JSP","The URL passed through to the servlet"]},{"entry":[{},{},"or JSP, not including the Query String."]},{"entry":["URL Query","Servlet, JSP","The portion of the URL that specifies"]},{"entry":[{},{},"query parameters in the http request"]},{"entry":[{},{},"(text that follows the \u2018?\u2019 delimiter)."]},{"entry":["Dynamic","Dynamic JDBC","The dynamic SQL statement, either in a"]},{"entry":["SQL","Statements","generalized form or with all the specific"]},{"entry":[{},{},"parameters from the current invocation."]},{"entry":["Method","Blamed Method","The name of the traced method. If the"]},{"entry":[{},"timers (every-","traced method directly calls another"]},{"entry":[{},"thing but","method within the same component,"]},{"entry":[{},"Servlets, JSP's","only the \u201coutermost\u201d first"]},{"entry":[{},"and JDBC","encountered method is captured."]},{"entry":[{},"Statements)"]},{"entry":["Callable","Callable JDBC","The callable SQL statement, either in a"]},{"entry":["SQL","statements","generalized form or with all the specific"]},{"entry":[{},{},"parameters from the current invocation."]},{"entry":["Prepared","Prepared JDBC","The prepared SQL statement, either in a"]},{"entry":["SQL","statements","generalized form or with all the specific"]},{"entry":[{},{},"parameters from the current invocation."]},{"entry":["Object","All non-static","toString( ) of the this object of the"]},{"entry":[{},"methods","traced component, truncated to some"]},{"entry":[{},{},"upper limit of characters."]},{"entry":["Class Name","All","Fully qualified name of the class of the"]},{"entry":[{},{},"traced component."]},{"entry":["Param_n","All objects with","toString( ) of the nth parameter passed"]},{"entry":[{},"WithParams","to the traced method of the component."]},{"entry":[{},"custom tracers"]},{"entry":["Primary Key","Entity Beans","toString( ) of the entity bean's"]},{"entry":[{},{},"property key, truncated to some upper"]},{"entry":[{},{},"limit of characters."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Parameters can include query, cookie, post, URL and session type name\/value pairs.","In step , the system acquires a timestamp indicating the current time. In step , a stack entry is created. In step , the stack entry is pushed onto the Blame Stack. In one embodiment, the timestamp is added as part of step . The process is performed when a transaction is started. A similar process is performed when a sub-component of the transaction starts (e.g., EJB B is a sub-component of Servlet A\u2014see tree described above).",{"@attributes":{"id":"p-0076","num":"0102"},"figref":["FIG. 2B","FIG. 1"],"b":["140","142","144","146","142","148","148","146","150","150","160","162","111"]},{"@attributes":{"id":"p-0077","num":"0103"},"figref":"FIG. 2B"},"Note, in one embodiment, if the transaction tracer is off, the system will still use the Blame Stack; however, parameters will not be stored and no component data will be created. In some embodiments, the system defaults to starting with the tracing technology off. The tracing only starts after a user requests it, as described above.",{"@attributes":{"id":"p-0079","num":"0105"},"figref":["FIG. 3","FIG. 1","FIG. 1","FIG. 9"],"b":["300","300","310","320","330","340","310","350","310","330","350","350"]},"A database may be included in the storage device  when the storage device  is part of a computing device  such as an application server, manager and\/or user interfaces. The storage device  can represent one or more storage devices which store data received from one or more agents, and which can be accessed to obtain data to provide a user interface as described herein. The storage device  can represent a data store.","Further, the functionality described herein may be implemented using hardware, software or a combination of both hardware and software. For software, one or more non-transitory, tangible processor readable storage devices having processor readable code embodied thereon for programming one or more processors may be used. The non-transitory, tangible processor readable storage devices can include computer readable media such as volatile and nonvolatile media, removable and non-removable media. For example, non-transitory, tangible computer readable media may include volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Examples of non-transitory, tangible computer readable media include RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computer. In alternative embodiments, some or all of the software can be replaced by dedicated hardware including custom integrated circuits, gate arrays, FPGAs, PLDs, and special purpose processors. In one embodiment, software (stored on a storage device) implementing one or more embodiments is used to program one or more processors. The one or more processors can be in communication with one or more tangible computer readable media\/storage devices, peripherals and\/or communication interfaces.",{"@attributes":{"id":"p-0082","num":"0108"},"figref":"FIG. 4"},"A top level of the hierarchy is a domain level  named \u201cDomain.\u201d A next level of the hierarchy is a Business Service level . An example of a Business Service relates to trading a stock using a web site. Thus, \u201cTrading\u201d can be the name of a node at the Business Service level of the hierarchy. A next level of the hierarchy is a Business Transaction level. A Business Service can be made up of a number of Business Transactions. For example, for Trading, the Business Transactions can include Reports  (e.g., view a report regarding a stock or an account) and Quotes  (e.g., obtain a quote for a stock price). Further, a Business Transaction can be associated with one or more Business Transaction Components. In one approach, a Business Transaction has only one identifying component. A Business Transaction Component can be a type of component of an application which is recognizable and measurable by a server, such as a servlet or EJB. In one approach, one of the components of an application is set as a Business Transaction Component, which is an identifying transaction component for a Business Transaction.","The Business Transaction Component is the identifying transaction component for the transaction that is the identifying transaction for the Business Transaction. A transaction can represent a sequence of software components which are invoked in response to a request from a client, to provide a corresponding response to the client. For example, a Business Transaction Component can be identified by determining when component data reported by an agent match a set of rules. This definition can include, e.g., a specified URL host name, URL parameters, HTTP post parameters, cookie and\/or session manager parameters. Additionally, or alternatively, the definition may require a transaction to start with a specified URL host name. The agent or manager, for instance, can compare the component data against the set of rules to determine when a Business Transaction Component is present in a Business Transaction. If a Business Transaction Component is detected, then the associated Business Transaction is of a specified type. For example, if the Business Transaction Component  is detected, then the associated Business Transaction is Reports . If the Business Transaction Component  is detected, then the associated Business Transaction is Quotes .",{"@attributes":{"id":"p-0085","num":"0111"},"figref":["FIG. 5","FIG. 4"]},"Component-oriented programming models are useful in allowing the programmer to assemble an application or other program from building blocks referred to as components. Each component can perform a specific function which fits in with an overall functionality of the software. Furthermore, a component can call other components, as well as calling itself, in a recursive call, so that a sequence of components is invoked in a program. One example of a component oriented programming model is J2EE, which can employ components such as a Java Server Page, an EJB, a servlet, and a Java Database Connectivity (JDBC) component. JDBC is an Application Programming Interface (API) for the JAVA\u2122 programming language that defines how a client may access a database. It provides methods for querying and updating data in a database. However, other component oriented programming models such as the MICROSOFT CORP. \u201c.NET\u201d Framework may also be used. Moreover, the programming model need not be object oriented.","This example provides details of the Reports and Quotes Business Transactions discussed previously. In one possible implementation, each component of a Business Transaction includes one or more class-method pairs. For example, a servlet is a JAVA class. It is an object that receives a request and generates a corresponding response. A class-method pair can be represented by the notation class.method. For example, Reports could include a component C () which displays a reports screen on a user interface (UI) to receive a user's input regarding a desired report. An example format of a class-method pair for C is ServletA1.DisplayReportScreen. C is under a root . Thus, whenever an agent detects that C has been invoked, it concludes that the current transaction is part of Reports, and associates its component data with Reports.","C can call C () which relates to a requested report. C could include a class-method pair such as ServletA2.RequestedReport which processes a user input of a requested report. This processing could include checking the format of the request, for instance, and, if the format is valid, making a call to a component C (), which receives the report request. For instance, this call may be a cross-process, cross-thread transaction or cross-subsystem call. If the format is invalid, the control flow returns to C, which may call C to display an error message, for instance.","An example format of a class-method pair for C is ServletA3.ReceiveReportRequest. C can call C () to access a database and\/or C () to access a database, such as based on the type of the report request. For example, C and C can each include a JDBC driver call which invokes one or more SQL statements. The control flow then returns to C, then to C and then to C. Subsequently, C calls C () which relates to providing a display, such as a display of the requested report based on data retrieved from the databases. The control flow then returns to C.","Also, under the root , a component C () can be provided which displays a quotes screen on a user interface (UI) to receive a user's input regarding a desired quote. C can call C () which relates to a requested report. C can process the user input by checking the format of the request, for instance, and if the format is valid, obtaining the requested quote, such as from a data source which is local to subsystem. If the format is invalid, the control flow returns to C, which may call C to display an error message, for instance. The control flow then returns to C. C can call C (), which relates to providing a display, such as a display of the requested quote based on the data retrieved from the data source.","Note that a component can continue executing after calling another component, which begins executing, in an asynchronous, multi-thread or multi-process mode. Or, a component can temporarily pause until the called component has finished executing, in a synchronous, single-thread or single-process mode. A component which is pausing can be considered to be in a wait interval, while a component which is executing can be considered to be in an active, executing mode. Also, a component may be invoked more than once during a transaction.",{"@attributes":{"id":"p-0092","num":"0118"},"figref":["FIG. 6","FIG. 5","FIG. 9"]},"The transaction trace of  involves components C, C, C and C, represented by graph portions , ,  and , respectively. C starts executing at t and ends or stops at t. C, which is called by C, starts executing at t and ends at t. C, which is called by C, starts executing at t and ends at t. C, which is called by C, starts executing at t and ends at t. The time increments are not necessarily equidistant.",{"@attributes":{"id":"p-0094","num":"0120"},"figref":["FIG. 7","FIG. 1"],"b":["700","720","730","702","704","706","708","710","712","708","710","712"]},"The registers include a program counter (pc), which keeps track of where in the memory it should be executing instructions. The program counter identifies the next byte code to be executed. The frame register contains a pointer to the execution environment of the current method in the operand stack. The operand top (optop) register contains a pointer to the top of the operand stack, and is used to evaluate arithmetic expressions. The variable (vars) register contains a pointer to local variables.","The operand stack supplies parameters to methods and operations and receives results back from them. All byte code instructions take operands from the stack, operate on them, and return results to the stack. The operand stack includes a stack frame of an executing method. The stack frame holds the state, e.g., local variables, and intermediate results of calculations, for a particular invocation of a method. Specifically, each JVM thread has a private JVM stack, created at the same time as the thread. A JVM stack stores frames, holds local variables and partial results, and plays a part in method invocation and return. A frame is thus used to store data and partial results, as well as to perform dynamic linking, return values for methods, and dispatch exceptions. A new frame is created each time a method is invoked. A frame is destroyed when its method invocation completes, whether that completion is normal or abrupt (it throws an uncaught exception). Frames are allocated from the JVM stack of the thread creating the frame. Each frame has its own array of local variables, its own operand stack, and a reference to the runtime constant pool of the class of the current method.","The heap or memory allocation pool is garbage collected. The heap is the runtime data area from which memory for all class instances and arrays is allocated. The heap is created on virtual machine start-up, and heap storage for objects is reclaimed by an automatic storage management system known as a garbage collector. Specifically, each program running in the Java runtime environment has a garbage-collected heap assigned to it. Moreover, each class in the heap has a constant pool associated with it. Because constants do not change, they are usually created at compile time. Items in the constant pool encode all the names used by any method in a particular class. The class contains a count of how many constants exist, and an offset that specifies where a particular listing of constants begins within the class description.","The method area stores byte code instructions that are associated with methods in the compiled code, and a symbol table which the execution environment needs for dynamic linking Any debugging or additional information that might need to be associated with a method is stored in this area as well. The program counter always points to, e.g., contains the address of, some byte in the method area. The program counter is used to keep track of the thread of execution. After a byte code instruction has been executed, the program counter will contain the address of the next instruction to execute.","The method area is shared among all JVM threads, and stores per-class structures such as the runtime constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and instance initialization and interface type initialization. The method area is created on virtual machine start-up. A runtime constant pool is a per-class or per-interface runtime representation of the constant pool table in a class file. It contains several kinds of constants, ranging from numeric literals known at compile time, to method and field references that must be resolved at run time. Each runtime constant pool is allocated from the JVM's method area. The runtime constant pool for a class or interface is constructed when the class or interface is created by the JVM.",{"@attributes":{"id":"p-0100","num":"0126"},"figref":["FIG. 8A","FIG. 1"],"b":["820","815","815","815"]},"If the application byte code matches rules (directives)  at a decision block , the transformer  adds probes in the form of tracer byte code. If the application byte code does not matches the rules  at the decision block , the transformer  does not add instrumentation to the byte code. The transformer  and the decision block  may be considered to be part of a probe builder .","In this implementation, the rules  are a set of typically static rules that identify portions of the managed application which are to be instrumented. The rules are usually implemented when a class is defined in a virtual machine for the first time. A class can be loaded multiple times while being defined only once. For example, there can be multiple class loaders loading the same class. Further, components such as classes may be instrumented based on whether they are named a certain way, whether they implement a certain interface, whether they extend a certain subclass or super class, and so forth. Such components are selected to be instrumented because it is believed they might provide performance data which is useful or otherwise interesting.","For instance, a rule may indicate that all servlets should be instrumented since it is believed that at least some of the servlets may provide interesting data. In this case, the rules  may indicate that all components that are subclasses of the JAVA class HttpServlet should be instrumented. HttpServlet is an abstract class from which all servlets depend. However, not all components can be instrumented, and there is a tension in that over-inclusive instrumentation results in excessive overhead costs and possibly impairing the operation of the application, while under-inclusive instrumentation results in the omission of important performance data.",{"@attributes":{"id":"p-0104","num":"0130"},"figref":"FIG. 8B"},"Moreover, the CLR is an implementation of a Common Language Infrastructure (CLI) which provides a language-neutral platform for application development and execution, including functions for exception handling, garbage collection, security, and interoperability. The CLI includes the core class libraries, Common Type System, and the Common Intermediate Language (CIL). As with JAVA byte code, CIL is another example of intermediate byte code. JAVA and .NET provide example implementations only, as other implementations are possible.","Here, the process may be implemented by an agent, in one possible approach. In one possible scenario, some process in the .NET framework references a class by name, and the CLR  finds the class, shows it to a transformer  (if any) and uses the resultant CIL. In particular, if the class matches rules  at a decision block , instrumentation is added. If the class does not match the rules  at the decision block , instrumentation is not added. The transformer  and the decision block  may be considered to be part of a probe builder .",{"@attributes":{"id":"p-0107","num":"0133"},"figref":["FIG. 9","FIG. 5","FIG. 6"],"b":["900","904","904","906","904","906","904","906"]},{"@attributes":{"id":"p-0108","num":"0134"},"figref":["FIG. 10","FIGS. 11A to 15B"],"b":["1004","1000","1002","1006","1008","1010"]},"As mentioned, agent metadata is typically provided in one or more configuration files which control a configuration of the agent. The performance of an application can be monitored by collecting metrics with the help of agents. The type of metrics generated, the recipient of these metrics and other aspects of agent behavior are controlled by metadata information contained within the set of configuration files used by the agent. Metadata entries can indicate many aspects of how the agent operates, such as how the agent adds instrumentation to an application. Examples of how the agent adds instrumentation to an application include directives which specify at least one method of a class or set of classes to monitor and a type of information to be collected in the application. These directives can be in the PBD files mentioned, for instance. Another example of how the agent is configured includes enabling or disabling a feature of the agent, setting a location of a server on which the agent runs, setting a type of communication used by agent to report data to a manager (e.g., plain socket, SSL, HTTP, HTTP over SSL), setting a location of configuration files used by the agent, setting a location of log files used by the agent, and setting a metric sending period\/frequency, e.g., how often data obtained from instrumentation of the managed application is sent to the manager. Different types of data can have different sending frequencies. Other configurations regarding metrics can relate to a time period used for a running average, high and low threshold levels which are used to set an alarm or error condition and so forth.","In one approach, the configuration files include one or more agent profile files, Probe Builder Directive (PBD) files and Probe Builder List (PBL) file. However, this is an example only as these types of configuration files need not be used and other types of configuration files can be used additionally or alternatively. A software update for the agent can occur alone or in connection with a release of related Application Management (APM) software. An agent upgrade can include, e.g., one or more of agent JAR files, extension JAR files, dynamic-link library (DLL) files and configuration files (agent Profile, PBD and PBL). The software update can be as minor as enabling or disabling a property in a configuration file or major as a complete deployment of a new agent release.","To upgrade the agent software, the application server is stopped, the agent artifact(s) are updated, and the server is restarted. However, the process can be time-consuming and problematic when there are many agents to be upgraded. This can be compounded by the use of different operating systems and application servers. A major upgrade usually involves the introduction of new agent metadata, a change in existing metadata settings and\/or removal of existing metadata one some occasions. The metadata information is contained within multiple configuration files, and the network administrator usually changes some of the agent metadata to customize it to better suit their application environment. During an upgrade, a network administrator has to manually merge all the existing configuration files with the updated\/new configuration files to maintain the custom settings to the extent possible, while ensuring compatibility with the updated software. This process of manually merging can be time consuming and error-prone.","A solution provided herein reduces the complexity involved in merging different types of agent metadata while maintaining custom settings.","In one approach, a rule to not merge the current configuration file with the corresponding updated configuration file is set, e.g., by default or based on an input from the network administrator. In this case, the current configuration file is not merged with, or overwritten by, the corresponding updated metadata file, and the current configuration file continues to be used, as represented by output block . In another approach, a rule to overwrite the current configuration file with the corresponding updated configuration file is set, e.g., by default or based on an input from the network administrator. In this case, the current configuration file is overwritten by, e.g., replaced by, the corresponding updated metadata file, as represented by output block . In another approach, neither the rule to not merge, nor the rule to overwrite, is set. In this case, the current configuration file and the corresponding updated metadata file are merged to provide a merged configuration file, as represented by output block . Another type of rule can specifically delete a configuration file. Note that different outputs may be obtained for different current configuration file.","Regarding the rules for the metadata entries, these can include a rule to delete a metadata entry, and a rule to prefer a metadata entry in an updated configuration file over a corresponding metadata entry in a current configuration file, or to prefer a metadata entry in a current configuration file over a corresponding metadata entry in an updated configuration file, as discussed further below. One or more instances of each rule can be used. The rules can be deployed in one or more files and executed on a computing device which has access to the current and updated configuration files. Moreover, the process depicted in  can occur during the upgrade of an agent or by using a merging utility tool, for instance. A merging utility tool allows the network administrator to create the configuration files which can be used to upgrade an agent without actually performing the upgrade, such as for evaluation or study purposes.","The rules of , A and A can be created manually.",{"@attributes":{"id":"p-0116","num":"0142"},"figref":["FIG. 11A","FIG. 10","FIG. 12A","FIG. 12B"],"b":["1100","1102","1104","1110","1110","1100","1110","1112","1102","1106","1106","1108","1106","1114","1114","1108"]},"If decision step  is false, decision step  determines whether there is a rule to overwrite the current configuration file with the corresponding updated configuration file.  provides an example of such a rule. If decision step  is true, the current configuration file is overwritten by the corresponding updated configuration file (or the current configuration file is otherwise not used by the agent and the updated configuration file is used by the agent), at step . If decision step  is false, step  is reached, where the metadata entries are read from the current configuration file. At step , the metadata entries are read from the corresponding updated configuration file. Step  creates a new, merged configuration file of the same name and type as the current and updated configuration files. The merged configuration file may initially be empty, e.g., have no header or description block or metadata entries. Step  copies the header from the updated configuration file to the merged configuration file. This can include adding at least one of a header block and a description block from the updated version of the configuration file, but not from the current version of the configuration file, to the merged version of the configuration file. Step  copies a description block, if any, from the updated configuration file to the merged configuration file. See , B and B for examples. The flowchart continues at \u201cB\u201d in .",{"@attributes":{"id":"p-0118","num":"0144"},"figref":["FIG. 11B","FIG. 11A","FIG. 14A"],"b":["1130","1132","1134","1150","1150","1130"]},"If decision step  is false, decision step  determines whether there is a corresponding metadata entry in the corresponding updated configuration file. For example, the entry in the current version of the configuration file can comprise a key-value pair (e.g., key-value), where the corresponding entry in the updated version of the configuration file also comprises a key-value pair (e.g., key-value), where the keys are the same (e.g., key) and the values are different (e.g., value, value). If decision step  is false, step  adds the metadata entry from the current configuration file to the corresponding merged configuration file (created at step  in ). Additionally, the commented state of the metadata entry from the current configuration file is unchanged.","In one commented state, a metadata entry is a comment such as a line comment, also referred to as inline comment. A line comment can start with a comment delimiter (e.g., \u201c#\u201d or \u201c\/\/\u201d), and continue until the end of the line, or in some cases, start at a specific column (character line offset) in the source code, and continue until the end of the line. An example of such a metadata entry is \u201c#meta.data.entry2=Yellow\u201d in  as entry CME. In another commented state, the metadata entry is a compilable instruction, which does not have a comment delimiter. An example of such a metadata entry is \u201cmeta.data.entry2=Blue\u201d in  as entry CME. Example of metadata entries which are handled according to step  include CME to CME in , CME to CME, CME and CME in , and CME to CME in .","An entry which includes an executable or compilable instruction can be changed to a line comment in different situations. For example, there may be multiple entries to choose from, but only one entry applies (or fewer than all entries apply) to a specific situation. Consider the following entries, where each line applies to a respective computing platform:\n\n","In this case, one of the entries can be edited so that it is not a comment (e.g., by removing the \u201c#\u201d), according to the appropriate computing platform being used. In another situation, an entry is changed to a comment by adding the comment delimiter when the function provided by the entry is not desired at a certain time, and can be later activated again by removing the comment delimiter. The adding and removing of the comment delimiter can be performed manually, in one approach.","If decision step  is true, decision step  determines whether there is a rule to prefer one of the entries over the other (e.g., to prefer the entry in the updated configuration file over the entry in the current configuration file\u2014path , or to prefer the entry in the current configuration file over the entry in the updated configuration file, or no preference\u2014path ).  provide an example of such a rule. If there is no such preference, or if the metadata entry in the current configuration file is preferred, step  adds the metadata entry from the current configuration file to the merged configuration file. Additionally, the commented state of the metadata entry from the current configuration file is unchanged, as in step . Furthermore, step  adds the metadata entry from the updated configuration file to the merged configuration file. However, the metadata entry from the updated configuration file is added as an inline comment, regardless of the comment state of the metadata entry from the updated configuration file. Thus, if the metadata entry from the updated configuration file is an inline comment in the updated configuration file, it maintains this state in the merged configuration file. If the metadata entry from the updated configuration file is a compilable instruction in the updated configuration file, it is changed to a line comment in the merged configuration file.","Step  allows a custom setting of the entry in the current configuration file, if present, to be maintained (e.g., a setting of the entry as a comment or compilable instruction). Moreover, by including the entry from the updated configuration file as an inline comment, the entry can be later activated, e.g., by the network administrator manually removing the comment delimiter and adding a comment delimiter to the corresponding entry from the current configuration file. Further, the existence of the entry from the updated configuration file is documented in the merged configuration file. For examples of metadata entries which are handled according to step , see step , discussed above. An example of a metadata entry which is handled according to step  includes UME in .","If decision step  indicates that the rule prefers the metadata entry in the updated configuration file, step  adds the metadata entry from the updated configuration file to the merged configuration file, with an unchanged comment state. Step  adds the metadata entry from the current configuration file to the merged configuration file as an inline comment, analogous to step . Thus, if the metadata entry from the current configuration file is an inline comment in the current configuration file, it maintains this state in the merged configuration file. If the metadata entry from the current configuration file is a compilable instruction in the current configuration file, it is changed to a line comment in the merged configuration file.","If decision step  is false, any remaining metadata entries from the updated configuration file are added to the merged configuration file, with an unchanged commented state, at step . Step  overwrites the current configuration file with the merged configuration file (or otherwise uses the merged configuration file to control the agent in place of the current configuration file). The control flow can proceed via \u201cC\u201d to step  in  to process a next configuration file.",{"@attributes":{"id":"p-0127","num":"0160"},"figref":["FIG. 12A","FIG. 10"],"b":"1004"},"The first line is: <?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d?>. Xml version=\u201c1.0\u201d indicates the version of the Extensible Markup Language (XML) which is used. Encoding=\u201cUTF-8\u201d indicates that 8-bit multibyte character encoding is used.","The second line is: <rules xmlns=\u201c \u201d, where <rules is the opening tag, and the xmlns attribute specifies the XML namespace for a document.","The third line is: xmlns:xsi=\u201chttp:\/\/www.w3.org\/2001\/XMLSchema-instance,\u201d where xmlns:xsi references a schema in an XML document and http:\/\/www.w3.org\/2001\/XMLSchema-instance specifies the default namespace declaration. This declaration tells a schema-validator that all the elements used in this XML document are declared in this namespace.","The fourth line is:\n\n","The fifth line is: <delete-file type=\u201cpbd\u201d name=\u201cSampleFile.pbd\u201d\/>, where delete-file is the name of the rule, pbd is the type of configuration file to delete, and SampleFile.pbd is the name of the configuration file to delete.","The sixth line is: <\/rules>, which is the closing tag.","Lines 1-4 are the same in , A and A.",{"@attributes":{"id":"p-0135","num":"0170"},"figref":["FIG. 12B","FIG. 10"],"b":"1004"},{"@attributes":{"id":"p-0136","num":"0171"},"figref":["FIG. 12C","FIG. 10"],"b":"1004"},{"@attributes":{"id":"p-0137","num":"0172"},"figref":["FIG. 12D","FIG. 10"],"b":"1004"},{"@attributes":{"id":"p-0138","num":"0173"},"figref":["FIG. 13","FIG. 10"],"b":["1300","1320","1310","1","1"]},"The third line of the file is: #1st type metadata entry, which is a comment describing the entry in the next line. In the fourth line, CME denotes the current (C) configuration file, metadata entry (ME), first entry (1) of this type. The entry is: Meta.data.entry.1=Red, a key-value pair in which \u201cRed\u201d is the value assigned to the key of Meta.data.entry.1.","The fifth line of the file is: #2nd type metadata entry, which is a comment describing the entry in the next line. In the sixth line, CME denotes the second entry (2) of this type. The entry is: Meta.data.entry.2=Blue, a key-value pair in which \u201cBlue\u201d is the value assigned to the key of Meta.data.entry.2. CME is compilable code. In the seventh line, CME denotes the third entry (3) of this type. The entry is: #Meta.data.entry.2=Yellow, a key-value pair in which \u201cYellow\u201d is the value assigned to the key of Meta.data.entry.2. CME is an inline comment.","The eighth line of the file is: #3rd type metadata entry, which is a comment describing the entry in the next line. In the ninth line, CME denotes the fourth entry (4) of this type. The entry is: Meta.data.entry.3=Green, a key-value pair in which \u201cGreen\u201d is the value assigned to the key of Meta.data.entry.3. CME is compilable code.","Red, Blue, Yellow and Green and the other colors used are symbolic examples of values used for metadata entries. For example, Red could be a numerical value in seconds of a period for transmitting a first metric, Blue and Yellow could be numerical values in seconds of different periods for transmitting a second metric, and Green could be a numerical value in seconds of a period for transmitting a third metric. These are metric sending periods, e.g., how often data obtained from instrumentation of the managed application is sent to the manager. The colors could alternatively represent values for other types of agent metadata, such as the type of metrics generated, the recipient of these metrics, directives which specify at least one method of a class or set of classes to monitor and a type of information to be collected in the application, enabling or disabling a feature of the agent, setting a location of a server on which the agent runs, setting a type of communication used by agent to report data to a manager (e.g., plain socket, SSL, HTTP, HTTP over SSL), setting a location of configuration files used by the agent, and setting a location of log files used by the agent.","If the entry in the current version of the configuration file provides one period and the corresponding entry in the updated version of the configuration file provides another, different period, the entries define conflicting periods at which the agent reports a metric obtained from the application.","In the updated configuration file , UHB denotes the updated (U) configuration file, header block (HB), first entry (1) of this type. UHB includes a first line of: # Sample.profile ver. 2.0, and a second line of: #App. Monitoring, ver. 9.1. Thus, the version of the App. Monitoring software is the same as the current configuration file but the version of the Sample.profile file is a later version, 2.0 vs. 1.0.","The third line of the file is: #4th type metadata entry, which is a comment describing the entry in the next line. In the fourth line, UME denotes the updated (U) configuration file, metadata entry (ME), first entry (1) of this type. The entry is: Meta.data.entry.4=Purple, a key-value pair in which \u201cPurple\u201d is the value assigned to the key of Meta.data.entry.4. UME is compilable code. The fifth line of the file is: #5th type metadata entry, which is a comment describing the entry in the next line. In the sixth line, UME denotes the second entry (2) of this type. The entry is: Meta.data.entry.5=Pink, a key-value pair in which \u201cPink\u201d is the value assigned to the key of Meta.data.entry.5. UME is compilable code.","In the merged configuration file , the header block UHB of the updated configuration file is copied to the merged configuration file to provide MHB. MHB denotes the merged (M) configuration file, header block (HB), first entry (1) of this type. The entries CME to CME exist only in the current configuration file (there are no corresponding entries in the updated configuration file) and are copied to the merged configuration file as MME to MME, respectively, regardless of their commented state. Thus, both the compilable instructions CME and CME and the inline comment CME are moved to the merged configuration file . Similarly, UME and UME exist only in the updated configuration file and are copied to the merged configuration file as MME and MME, respectively. In this example, there are no conflicting entries in the current and updated configuration files.",{"@attributes":{"id":"p-0147","num":"0182"},"figref":["FIG. 14A","FIG. 10"],"b":"1004"},"In creating a merged version of a configuration file, if the rules indicate that another entry (CME) in the current version of the configuration file  should be deleted, the another entry in the current version of the configuration file is not included in the merged version of the configuration file  and a corresponding entry (UME), if any, in the updated version of the configuration file , is also not included in the merged version of the configuration file.",{"@attributes":{"id":"p-0149","num":"0184"},"figref":["FIG. 14B","FIG. 10","FIG. 14A"],"b":["1","1","1","1400","1420","1410","1","1","1","1","1","2","3","5","6","1","5","1","2","3","5","6","1","2","3","5","7"]},"Entry CME or UME (j2ee.pbd) is not copied to the merged PBL since it is intended for deletion per the entry deletion rule. Entry UME (appmap.pbd) only exists in the updated configuration file (there is no corresponding entry in the current configuration file) and is copied to the merged configuration file as MME.",{"@attributes":{"id":"p-0151","num":"0186"},"figref":["FIG. 15A","FIG. 10"],"b":"1004"},{"@attributes":{"id":"p-0152","num":"0187"},"figref":["FIG. 15B","FIG. 10","FIG. 15A"],"b":["1500","1520","1510","1","1520","1","1","1","2","3","1","2","3","2","3","1","4","1","2","3"]},"The entry meta.data.entry.3 exists in both the current configuration file (as CME) and the updated configuration file (as UME and UME), but preference is given to the updated entry per the rule, so that UME and UME are copied to provide MME and MME, respectively. Additionally, CME is copied as an inline comment to provide MME. That is, the comment state of CME is changed from a compilable instruction to an inline comment, since the corresponding entry (UME and UME) in the updated configuration file is preferred by the rule: <preferred-entry type=\u201cprofile\u201d preference=\u201cU\u201d name=\u201cmeta.data.entry.3\u201d\/>. Entries meta.data.entry.4 (UME) and meta.data.entry.5 (UME) exist only in the updated configuration file and are copied to the merged configuration file as MME and MME, respectively.","Thus, a process includes creating a merged version of the configuration file  based on the current version of the configuration file , an updated version of the configuration file , and rules , and using the merged version of the configuration file to control the agent. The creating the merged version of the configuration file comprises: identifying an entry (CME, CME; CME) in the current version of the configuration file for which there is a corresponding entry (UME; UME, UME) in the updated version of the configuration file; selecting one of: (a) the entry in the current version of the configuration file and (b) the corresponding entry in the updated version of the configuration file, as a selected entry, based on at least one preference in the rules (in this case, CME and CME are preferred over UME, and UME and UME are preferred over CME); and based on the selecting, adding the selected entry (CME, CME; UME, UME) to the merged version of the configuration file (as MME, MME; MME, MME, respectively).","The foregoing detailed description of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. The described embodiments were chosen in order to best explain the principles of the invention and its practical application, to thereby enable others skilled in the art to best utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the claims appended hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 7","FIG. 1"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 11A","FIG. 10"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 11B","FIG. 11A"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 12A","FIG. 10"],"b":"1004"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 12B","FIG. 10"],"b":"1004"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 12C","FIG. 10"],"b":"1004"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 12D","FIG. 10"],"b":"1004"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 13","FIG. 10"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 14A","FIG. 10"],"b":"1004"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 14B","FIG. 10","FIG. 14A"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 15A","FIG. 10"],"b":"1004"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 15B","FIG. 10","FIG. 15A"]}]},"DETDESC":[{},{}]}
