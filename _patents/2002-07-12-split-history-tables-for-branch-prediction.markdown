---
title: Split history tables for branch prediction
abstract: An apparatus and method are provided for accurately predicting the outcome of branch instructions prior to their execution by a pipeline microprocessor. The apparatus includes a first table, a second table, and selection logic. The first table stores branch histories for a first set of branch instructions where the first set, when executed, exhibits a bias toward a first outcome. The second table stores second branch histories for a second set of branch instructions, where, the second set, when executed, exhibits a bias toward a second outcome. The selection logic is coupled to the first and second tables. The selection logic selects a particular branch history from either of the first or second tables. Thus, a branch prediction is made based upon contents of a branch history that is selected from a table containing branch histories for other branch instructions that exhibit the same outcome tendency as the particular branch instruction, thereby reducing the negative effects of aliasing.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06928537&OS=06928537&RS=06928537
owner: IP-First, LLC
number: 06928537
owner_city: Fremont
owner_country: US
publication_date: 20020712
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is a continuation of U.S. patent application Ser. No. 09\/434,096 now U.S. Pat. No. 6,546,481, entitled SPLIT HISTORY TABLES FOR BRANCH PREDICTION, having a common assignee, common inventors, and filed on Nov. 5, 1999. This application is related to the following co-pending U.S. Patent Applications: Ser. No. 09\/203,844 , entitled, METHOD AND APPARATUS FOR SPECULATIVELY UPDATING GLOBAL BRANCH HISTORY AND RESTORING SAME UPON BRANCH MISPREDICTION DETECTION; Ser. No. 09\/203,900, entitled, METHOD AND APPARATUS FOR PREDICTING CONDITIONAL BRANCH INSTRUCTION OUTCOME BASED ON BRANCH CONDITION TEST TYPE; and Ser. No. 09\/203,884, entitled, METHOD AND APPARATUS FOR PERFORMING BRANCH PREDICTION COMBINING STATIC AND DYNAMIC BRANCH PREDICTORS; all of the aforementioned applications having the same assignee and being filed prior to this application.","1. FIELD OF THE INVENTION","This invention relates in general to the field of instruction execution in computers, and more particularly to an apparatus and method for predicting the outcome of branch instructions in a pipeline microprocessor.","2. DESCRIPTION OF THE RELATED ART","An application program for execution on a microprocessor consists of a structured series of macro instructions that are stored in sequential locations in memory. A current instruction pointer within the microprocessor points to the address of the instruction currently being executed and a next instruction pointer within the microprocessor points to the address of the next instruction for execution. During each clock cycle, the length of the current instruction is added to the contents of the current instruction pointer to form a pointer to a next sequential instruction in memory. The pointer to the next sequential instruction is provided to logic that updates the next instruction pointer. If the logic determines that the next sequential instruction is indeed required for execution, then the next instruction pointer is updated with the pointer to the next sequential instruction in memory. Thus, macro instructions are fetched from memory in sequence for execution by the microprocessor.","Obviously, because a microprocessor is designed to execute instructions from memory in the sequence that they are stored, it follows that a program configured to execute macro instructions sequentially from memory is one that will run efficiently on the microprocessor. For this reason, most application programs are designed to minimize the number of instances where macro instructions are executed out of sequence. These out-of-sequence instances are known as jumps, or branches.","A program branch presents a problem because most conventional microprocessors do not simply execute one instruction at a time. Rather, a present day microprocessor consists of a number of pipeline stages, each stage performing a specific function. Instructions, inputs, and results from one stage to the next are passed in synchronization with a pipeline clock. Hence, several instructions may be executing in different stages of the microprocessor pipeline within the same clock cycle. Consequently, when logic within a given stage determines that a program branch is to occur, then instructions in previous stages of the pipeline must be cast out so that control of the microprocessor can be transferred to the instruction directed by the branch, or the branch target instruction. This casting out of instructions in previous pipeline stages is known as flushing the pipeline.","A conditional branch is a branch that may or may not occur, depending upon an evaluation of some specified condition. And this evaluation is typically performed in later stages of the microprocessor pipeline. To preclude wasting many clock cycles associated with flushing and refilling the pipeline, present day microprocessors also provide logic in an early pipeline stage that predicts whether a conditional branch will occur or not, that is, whether it will be taken or not taken. If it is predicted that a conditional branch will be taken, then only those instructions prior to the early pipeline stage must be flushed, including those in the instruction buffer. Even so, this is a drastic improvement; correctly predicted branches are executed in roughly two clock cycles. But an incorrect prediction takes many more cycles to execute than if no branch prediction mechanism had been provided in the first place. The accuracy of branch predictions in a pipeline processor significantly impact the processor's performance, for better or worse.","Present day branch prediction mechanisms primarily predict the outcome of a given conditional branch instruction in an application program based upon outcomes obtained when the conditional branch instruction was previously executed within the same instance of the application program. This historical branch prediction, or dynamic branch prediction, is effective because conditional branch instructions tend to exhibit repetitive outcome patterns.","In a conventional microprocessor, the historical outcome data is stored in a single branch history table that is accessed using the address of a conditional branch instruction\u2014a unique identifier for the instruction. A corresponding entry in the branch history table contains the historical outcome data associated with the conditional branch instruction. A dynamic prediction of the outcome of the conditional branch instruction is made based upon the contents of the corresponding entry in the branch history table.","Yet, because most present day microprocessors have address ranges on the order of gigabytes, it is not practical for a branch history table to be as large as the microprocessor's address range. Because of this, smaller branch history tables are provided, on the order of kilobytes, and only the low-order bits of a conditional branch instruction's address are used as an index into the table. But this presents another problem: because low-order address bits are used to index the branch history table, two or more conditional branch instructions can index the same entry. This is known as aliasing. As such, the outcome of a more recently executed conditional branch instruction will influence the historical outcome record of a formerly executed conditional branch instruction that is aliased to the same table entry. If the former conditional branch instruction is encountered again, its historical outcome information is biased, for better or for worse, toward the outcome of the more recently executed conditional branch instruction.","The present inventors have observed that the outcomes of conditional branch instructions, when observed on pipeline microprocessor executing today's predominant desktop computer application programs exhibit a bias toward one outcome or the other as a function of static indicators such as the type of conditional test performed, regardless of historical outcome data associated with the instructions. Some conditional branch instructions indeed exhibit a very strong bias toward an outcome, virtually independent of execution history in the application program. Thus, execution of an application program is negatively impacted when it has a significant number of conditional branch instructions having conflicting outcome biases that are aliased to the same historical outcome records: predictions for instructions biased toward being taken are negatively influenced by instructions that are biased toward being not taken that are aliased to the same historical outcome record, and vice versa.","Thus, the accuracy of branch predictions is degraded on the whole in a microprocessor that allows the outcomes of conditional branch instructions exhibiting a certain outcome bias to impact the historical outcome data for conditional branch instructions that exhibit a conflicting outcome bias.","Therefore, what is needed is an apparatus for predicting the outcomes of branch instructions that is more accurate than has heretofore been provided.","In addition, what is needed is a branch prediction mechanism in a microprocessor that separately maintains historical outcome records for conditional branch instructions as categorized by outcome bias.","Furthermore, what is needed is an apparatus in a microprocessor for predicting branches that precludes outcomes associated with conditional branch instructions having a certain outcome bias from influencing branch predictions for other branch instructions that exhibit a bias toward a different outcome.","Moreover, what is needed is a method for separating historical outcome data for conditional branch instructions that improves the accuracy of their associated branch predictions.","To address the above-detailed deficiencies, it is an object of the present invention to provide a branch prediction apparatus that provides accurate branch predictions by segregating outcome records for conditional branch instructions according to their observed outcome bias.","Accordingly, in the attainment of the aforementioned object, it is a feature of the present invention to provide a branch prediction apparatus. The branch prediction apparatus includes a first table, a second table, and selection logic. The a first table stores first branch histories for a first set of branch instructions, where the first set, when executed, exhibits a bias toward a first outcome. The second table stores second branch histories for a second set of branch instructions, where, the second set, when executed, exhibits a bias toward a second outcome. The selection logic is coupled to the first and second tables. The selection logic selects a particular branch history from either of the first or second tables.","In an additional aspect, it is a feature of the present invention to provide an apparatus in a microprocessor for performing branch prediction. The apparatus includes a bias indicator and a dynamic branch predictor. The a bias indicator is configured to receive a branch instruction, and to provide an output indicating a particular outcome bias category for the branch instruction. The dynamic branch predictor is coupled to the bias indicator. The dynamic branch predictor receives the output, and predicts an outcome for the branch instruction based upon contents of an entry in a particular branch history table. The particular branch history table corresponds to the particular outcome bias category. The dynamic branch predictor maintains a plurality of branch history tables, and the plurality of branch history tables are categorized according to outcome biases for conditional branch instructions.","An advantage of the present invention is that more accurate branch predictions are generated in a microprocessor than have heretofore been obtained.","Another object of the present invention is to an apparatus in a microprocessor to predict branch outcomes for conditional branch instructions exhibiting a particular outcome bias based upon historical outcome data for conditional branch instructions that exhibit the same particular outcome bias.","In another aspect, it is a feature of the present invention to provide a branch prediction mechanism for performing branch predictions in a microprocessor. The branch prediction mechanism has a bias indicator, a dynamic branch predictor, and branch history update logic. The a bias indicator receives a branch instruction from an instruction buffer, and to provides an output indicating a particular outcome bias category for the branch instruction. The dynamic branch predictor is coupled to the bias indicator. The dynamic branch predictor receives the output, and predicts an outcome for the branch instruction based upon contents of an entry in a particular branch history table, where the particular branch history table corresponds to the particular outcome bias category, and where the particular branch history table is one of a plurality of branch history tables, each of the plurality of branch history tables being categorized according to corresponding outcome bias categories. The branch history update logic is coupled to the dynamic branch predictor, and is configured to update the entry following resolution of the branch instruction.","Another advantage of the present invention is that execution speed of an application program is improved because unnecessary pipeline flushes due to incorrect branch predictions are reduced.","A further object of the invention is to provide an apparatus in a microprocessor for predicting branches that precludes outcomes associated with conditional branch instructions having a certain outcome bias from influencing branch predictions for other branch instructions that exhibit a bias toward a different outcome.","In a further aspect, it is a feature of the present invention to provide a branch prediction apparatus. The branch prediction apparatus includes a bias indicator and a dynamic branch predictor. The a bias indicator provides an output indicating a particular outcome bias category for a particular branch instruction. The dynamic branch predictor is coupled to the bias indicator, and is configured to direct a next instruction pointer to indicate a next sequential instruction address or a branch target address. The dynamic branch predictor has a plurality of branch history tables. The plurality of branch history tables are categorized according to outcome biases for conditional branch instructions, where each of the plurality of branch history tables is configured to receive an instruction pointer and to maintain corresponding branch outcome data, and where a particular branch history table contains particular branch outcome data associated with the particular outcome bias category.","A further advantage of the present invention is that application programs having significant numbers of program branches execute more efficiently.","Yet another object of the present invention is to provide a method for separating historical outcome data for conditional branch instructions that improves the accuracy of their associated branch predictions.","In yet another aspect, it is a feature of the present invention to provide a method for performing branch prediction in a microprocessor. The method includes maintaining a plurality of branch history tables containing historical outcome records for branch instructions, each of the plurality of branch history tables being indexed by an instruction pointer; categorizing the plurality of branch history tables according to outcome biases for conditional branch instructions; employing a specific outcome bias category to identify a specific branch history table for a specific branch instruction; and predicting an outcome of the specific branch instruction based upon contents of a specific historical outcome record corresponding to the specific outcome bias category.","Yet another advantage of the present invention is that a method is provided to reduce the confusion created in a branch history table by intermixing results of conditional branch instructions having a given outcome bias with results of conditional branch instructions having a conflicting outcome bias.","In light of the above background on techniques for predicting the outcome of a branch instruction in a pipeline microprocessor, several related art examples will now be discussed with reference to . These examples illustrate the problematic nature of present day branch prediction techniques, in particular when these present day techniques are employed during the execution of application programs in a desktop computer. Following this discussion, a detailed description of the present invention will be provided with reference to . Use of the present invention provides more accurate branch outcome predictions than those obtained via conventional techniques, thus allowing desktop computer applications to run faster than has been previously achieved.","Referring to , a block diagram is presented of a related art pipeline microprocessor . The microprocessor  includes a fetch stage , translate stage , register stage , address stage , data\/ALU stage , and write back stage .","Operationally, the fetch stage  fetches instructions from memory (not shown) that are to be executed by the microprocessor . The translate stage  translates, or decodes, the fetched instructions into associated micro instructions, each micro instruction directing the microprocessor  to perform a specific subtask related to accomplishment of an overall operation prescribed by a fetched macro instruction. The register stage  retrieves operands specified by the micro instructions from a register file (not shown) for use by later stages in the pipeline. The address stage  calculates memory addresses specified by the micro instructions to be used in data storage and retrieval operations. The data\/ALU stage  either performs arithmetic logic unit (ALU) operations on data retrieved from the register file, or reads\/writes data from\/to memory using the memory address calculated in the address stage . The write back stage  writes the result of a data read operation, or an ALU operation, to the register file. Thus, macro instructions are fetched by the fetch stage  and are decoded into micro instructions by the translate stage , and the micro instructions proceed through subsequent stages - for execution.","Micro instructions move through successive stages of the microprocessor pipeline in synchronization with a microprocessor clock. Optimally, while any given stage in the pipeline is executing a micro instruction, the previous stage should be executing the next micro instruction. If a stage in the pipeline requires more than one cycle of the pipeline clock to execute a given micro instruction, flow of micro instructions through the microprocessor pipeline is effectively stalled: preceding stages in the pipeline are precluded from forwarding associated results down the pipeline and succeeding stages, having completed execution of a current micro instruction, sit idle. A stall in the pipeline is referred to as a slip, or a void. Slips are unwanted because they cause delays. In the absence of techniques to diminish the negative effects of slips, it follows then that the speed at which the microprocessor  executes a particular application program is significantly influenced by the number of pipeline slips that are encountered during its execution. For this reason, present day microprocessors employ various techniques to minimize the number of pipeline voids. One such technique, branch prediction, is described with reference to FIG. .","Referring to , a block diagram of a portion of a related art pipeline microprocessor  is presented illustrating conventional mechanisms for predicting the outcome of branch instructions. The microprocessor  includes fetch stage logic , translate stage logic , and interlock control . For clarity of discussion, remaining stages of the microprocessor  are not shown.","The fetch stage logic  has an instruction fetcher  that provides sequential macro instructions to an instruction buffer  so that the sequential macro instructions are available for retrieval by the translate stage logic  during each clock cycle.","The translate stage logic  has an instruction decoder , or translator , that receives macro instructions provided by the instruction buffer . The translate stage logic  also includes a branch history table (BHT)  which provides a take branch output signal .","The interlock control  spans the fetch and translate stages of the microprocessor . The interlock control  interfaces to the fetch stage logic  via flush signal . Interface to the translate stage logic  is achieved via flush signal .","Operationally, a sequential block of macro instructions is retrieved by the instruction fetcher  from external memory (not shown) or an instruction cache (not shown) and the macro instructions are provided to the instruction buffer . The instruction buffer  stores several sequential macro instructions that are designated for execution. During each cycle of the pipeline clock, a macro instruction is retrieved from the instruction buffer  and is provided to the instruction decoder  for translation into associated micro instructions for execution by succeeding stages of the microprocessor .","Application programs chiefly execute macro instructions sequentially. That is, execution of a first macro instruction stored in a first address in memory is followed by execution of a second macro instruction stored in a second address. The second address is offset from the first address in memory by a number of bytes, L, where L is the number of bytes required to store the first macro instruction. The number of bytes, L, is also called the length of an instruction. Execution of the second macro instruction is followed by execution of a third macro instruction stored in a third address that follows the second address, and so on.","In addition, a macro instruction is uniquely identified by its corresponding location in memory. The corresponding location of the macro instruction provided each cycle for translation is designated by a current instruction pointer . Because macro instructions vary in size, the instruction decoder  provides an instruction length output to be used by the fetch stage logic  to determine the address of a next sequential instruction. A sum of the current instruction pointer and the current instruction length designates the location of the next sequential instruction, or next sequential instruction pointer (NSIP). The NSIP is one of the inputs provided to a mux  in the fetch stage logic . If it is determined that the next instruction to be executed is the next sequential instruction, then a next instruction pointer (NIP) control (CTRL) signal directs the mux  to provide the NSIP to a next instruction pointer . The instruction fetcher  fetches macro instructions based upon the contents of the next instruction pointer . Hence, macro instructions continue to execute sequentially until a program control transfer instruction is executed.","A program control transfer instruction performs the function that its name implies: sequential instruction execution is temporarily halted and control of the microprocessor  is transferred to another area of the application program where, most likely, sequential execution of macro instructions will continue. There are two basic types of program control transfer instructions. One type unconditionally causes program control flow to be transferred to a different area of memory. Instructions of this type are known as unconditional control transfer instructions, unconditional jump instructions, unconditional branch instructions, or call\/return instructions. The other type of program control transfer instructions transfers program control flow to a different area of memory as a result of some condition being met. Instructions of this type are known as conditional program control transfer instructions, conditional jump instructions, or conditional branch instructions.","A conditional branch instruction is a commonly used program control transfer instruction. For example, a program operating at location X in memory may test an input to the microprocessor . If the input satisfies some condition as prescribed by the particular conditional jump instruction being employed, then program control is transferred to location Y. Else, program execution continues to a next sequential macro instruction that follows location X.","Conditional jump micro instructions are evaluated, or resolved, in the data\/ALU stage of the microprocessor . Yet, by the time a conditional jump micro instruction proceeds through the data\/ALU stage, a next sequential micro instruction is present in the address stage, a micro instruction following the next sequential micro instruction is in the register stage, and so forth. Moreover, because the presumption is that sequential instruction execution will continue following evaluation of the conditional jump micro instruction, in the absence of branch prediction mechanisms, the instruction buffer  would also be filled with macro instructions that sequentially follow the conditional jump instruction.","If the evaluation of the condition specified by the conditional branch instruction does not result in the jump, or branch, being taken, then sequential instruction execution continues uninterrupted. If, on the other hand, the condition evaluation results in the branch being taken, then, because sequential instructions have been queued up for execution, several clock cycles are consumed with casting out, or flushing, the undesired sequential instructions from the pipeline and the instruction buffer  and thereafter filling the pipeline with sequential instructions beginning with the instruction that is the target of the conditional branch. Such an instruction is called a branch target instruction, or branch target. Resolution of the conditional branch instruction in the data\/ALU stage also results in the location of the branch target instruction, or resolved target address, being definitively provided to the mux . When resolution of a conditional branch causes the branch to be taken, the NIP CTRL, signal causes the resolved target address to be provided to the next instruction pointer  so the instruction fetcher  can begin fetching sequential instructions from the resolved target address.","To recap, a conditional branch instruction is evaluated in the data\/ALU stage. If a condition specified by the instruction is not met, then program control continues to the next sequential instruction. If the condition is met, then program control is transferred to the branch target instruction. To execute the branch, the pipeline must be flushed prior to fetching the branch target instruction. The interlock control  asserts the flush signals ,  to accomplish the flush of the fetch stage logic  and translate stage logic . Following the flush, the pipeline is refilled with sequential instructions beginning with the branch target.","Branch prediction techniques are utilized in the microprocessor  to minimize the number of clock cycles that are wasted when a conditional branch is taken. In the translate stage, the branch history table  maintains an historical record of the outcomes of previously executed conditional jump instructions so that future outcomes of the conditional jump instructions can be predicted. It is well understood in the art that the outcome of a particular branch instruction executed at a particular instant in an application program is highly correlated to previous outcomes of the particular branch instruction in the application program and to the outcomes of more recently executed branch instructions by the application program. Hence, by evaluating the historical record of the particular jump instruction in the branch history table , the translate stage logic can provide an accurate prediction of its outcome at the particular instant.","Recall that the contents of the current instruction pointer  uniquely identify an instruction that is being executed. Thus, to access a historical record, or entry, the current instruction pointer (CIP)  is provided to the branch history table . In principle, the entry corresponding to a particular CIP value can be evaluated and an accurate prediction for an associated branch instruction can be provided via the take branch output signal .","However, to maintain a one-to-one correspondence between all locations in memory (i.e., potential locations for conditional branch instructions) and corresponding branch history table entries would require that the branch history table  be equal in address range to the memory. This is simply not feasible in a present day microprocessor  having an address range on the order of gigabytes. As a compromise then, various N: mapping schemes are employed to balance the functional and performance requirements of branch prediction with the size, complexity, and power requirements of the branch history table . One common approach uses low-order bits of the CIP  to index entries in a branch history table  that is on the order of kilobytes in size. Several mapping schemes of this type are specifically discussed in copending U.S. patent application Ser. No. 09\/203,844, entitled METHOD AND APPARATUS FOR SPECULATIVELY UPDATING GLOBAL BRANCH HISTORY, having common inventors and having the same assignee, which is hereby incorporated by reference.","The low-order bits of the CIP  are used to access a particular branch history table entry to predict, based upon previous executions of a corresponding branch instruction, whether it is probable that execution of the corresponding conditional branch instruction will result in a branch being taken or not being taken. If the particular branch history table entry indicates that the branch will be taken, then the take branch output signal  is asserted. If the particular branch history table entry indicates that the branch will not be taken, then the take branch output signal  is not asserted. Because the branch prediction is based upon previous executions of the corresponding branch instruction during execution of an application program, it is referred to as a dynamic prediction.","Yet, because only the low-order address bits of the CIP  are used to index into the branch history table , it is noted that more than one conditional branch instruction can be mapped to the same branch history table entry. This phenomenon is called aliasing. More specifically, a given branch history table entry may be associated with the outcomes of two or more conditional branch instructions having the same low-order address. If a dynamic prediction is made for one of the conditional branch instructions, the branch history table entry to which it is mapped may reflect the outcomes of other branch instructions that are also mapped to the same entry. Therein lies the balance: a cheaper, less-complex branch history table  is obtained at the expense of aliasing. Aliasing produces less than accurate branch predictions for a given branch instruction because its corresponding branch history table entry may also be influenced by outcomes of other, uncorrelated conditional branch instructions.","Once a branch prediction is made, the take branch output signal  directs the microprocessor either to speculatively take a corresponding branch to a branch target instruction or to continue execution of sequential instructions. If the branch is predicted to be taken, the translate stage logic  also provides a predicted target address indicating the location in memory for the branch target instruction. The predicted target address is provided to the mux . For execution of a speculative branch, i.e., a branch that is predicted taken, the NIP CTRL signal directs the mux  to provide the predicted target address to the next instruction pointer .","It is significant that the branch prediction, because it is made in the translate stage, cannot deterministically indicate whether or not a branch will be taken or not. This is because the associated branch condition is not evaluated until the data\/ALU stage. For this reason a branch that is predicted to be taken by the translate stage logic  is called a speculative branch.","One skilled in the art will appreciate that different microprocessors utilize different macro instructions to implement conditional branches. Also, as is alluded to above, there are several different techniques used to speculate whether a conditional branch will be taken or not. Furthermore, one skilled will understand that that methods for providing a branch target address vary. A comprehensive discussion of conventional branch prediction methodologies is beyond the scope of this application. It suffices to note that most present day microprocessors employ some form of branch prediction logic in the translate stage to minimize the number of clock cycles that are associated with performing a conditional branch.","If a conditional branch is predicted to be taken, then the take branch output signal  and target address are provided to the fetch stage logic. . As a result, the fetch stage logic  flushes the contents of the instruction buffer  and begins fetching sequential instructions from the predicted target address. If the conditional branch is predicted not taken, then sequential instructions following the conditional branch instruction are allowed to proceed through the pipeline.","As a conditional branch instruction proceeds through the data\/ALU stage, its associated condition is evaluated and a result of the evaluation determines the true outcome of the conditional branch instruction. The true outcome is also known as a resolved outcome. The resolved outcome of a conditional branch instruction is fed back to BHT update logic  via bus  so that the resolved outcome can be added to the historical outcome data in the branch history table entry to which the conditional branch instruction was mapped. The BHT update logic  updates the branch history table entry associated with the resolved outcome.","In addition to providing historical outcome data, it is equally important to note that resolution of the conditional branch instruction either confirms or contradicts the prediction provided by translate stage logic . Correctly predicting that a conditional branch will occur typically allows a conditional jump instruction to be executed in only two clock cycles: one cycle to flush the instruction buffer  and one cycle to fill it  with macro instructions beginning with a branch target instruction at the predicted target address. On the contrary, incorrectly predicting a conditional jump requires more cycles to execute than would have been required if no branch prediction technique had been used in the first place: A 1-cycle penalty is required to flush early stages in the microprocessor  in order to begin fetching at the predicted target address as a result of the speculative branch being directed by the branch prediction signal . Then, when resolution of the conditional branch instruction contradicts the prediction, the pipeline stages must be flushed again, this time up to the data\/ALU stage. Further delay is required to refill the pipeline with the correct instructions. Because the delays caused by an inaccurate branch prediction are worse than the delays incurred in the absence of any prediction at all, it is extremely important that a branch prediction be accurate. Accurate branch predictions can result in significant performance gains. On the other hand, inaccurate branch predictions gravely impact the performance of the microprocessor .","Aliasing diminishes the accuracy of branch predictions. For instance, if a given branch history table entry contains historical outcome data corresponding to two aliased conditional branch instructions, a first instruction exhibiting a bias toward being taken and a second instruction exhibiting a bias toward being not taken, then a dynamic prediction for either instruction based upon the resolved outcomes of the other instruction would be inaccurate. One skilled in the art will observe that the tendencies, or biases, of conditional branch instructions toward being taken or not taken contribute to the overall accuracy of branch predictions in the microprocessor . How these tendencies negatively impact the performance of a microprocessor  having conventional branch prediction mechanisms is more specifically discussed with reference to FIG. .","Referring to , a table  is provided illustrating the effects of predicting branches with the microprocessor  of FIG. . The table traces the execution of two x86-compatible conditional branch instructions: jump if sign flag not set, designated by JNS, and jump if zero flag set, designated by JZ. The JNS instruction has been observed to exhibit a bias toward being taken. The JZ instruction exhibits a bias toward being not taken. The sign flag and the zero flag refer to bits in a flags register in the x86-compatible microprocessor  that reflect the result of a previously executed arithmetic operation. Execution of the instructions are traced with respect to times T through T, time T being later than time T. Contents of the column entitled BHT Pred denote the output  of the branch history table , contents of the column entitled Rslvd Outcome denote the resolved outcome of the conditional branch instruction, contents of the column entitled Effect portray the effect of the resolved outcome in view of the action directed by the output , and contents of the column entitled BHT Update denote the how the branch history table  is updated as a result of the conditional branch instruction being resolved.","At time T, conditional branch instruction JNS is provided to the translate stage logic . The low-order bits of the CIP  are used to access a corresponding branch history table entry for the JNS instruction. The branch history table  provides a dynamic branch prediction of taken (T) via the take branch output signal . Thus, the microprocessor  is directed to take a speculative branch to a branch target instruction associated with the JNS instruction. Resolution of the JNS instruction prior to time T confirms the branch prediction. Following resolution of the JZ instruction, the resolved outcome, taken (T), is provided to the BHT update logic  so that the branch history table entry corresponding to JNS can reflect the recent outcome. In the branch prediction scheme used in this example, such an update will result in a dynamic branch prediction of taken (T) the next time the corresponding branch history table entry is accessed. In an alternative embodiment, the BHT update logic  is speculatively updated prior to resolution of the JZ instruction, so that subsequent references will be accurately predicted.","At time T, conditional branch instruction JZ is provided to the translate stage logic . And although the JZ instruction resides at a different address in memory than the JNS instruction, its low-order address is the same as that for the JNS instruction. Hence, the JZ instruction aliases into the same entry in the branch history table  as the JNS instruction. As a result, the branch history table  provides a dynamic branch prediction of taken (T) via the take branch output signal . Thus, the microprocessor  is directed to take a speculative branch to a branch target instruction prescribed by the JZ instruction. Yet, resolution of the JZ instruction prior to time T contradicts the branch prediction. The effect is that the microprocessor pipeline must be flushed and refilled with instructions beginning with the next sequential instruction following the JZ instruction. Following resolution of the JZ instruction, the resolved outcome, not taken (NT), is provided to the BHT update logic  so that the corresponding branch history table entry for the JZ instruction will reflect the recent outcome.","At time T, conditional branch instruction JZ is again provided to the translate stage logic . Its corresponding entry in the branch history table  is accessed, and because the entry contents indicate that the branch will be not taken, the take branch output signal  is not asserted. Consequently, the microprocessor  is directed to continue execution of sequential instructions. Resolution of the JZ instruction prior to time T confirms the previous prediction and there is thus no detrimental effect on microprocessor performance. Following resolution of the JZ instruction, the resolved outcome, NT, is provided to the BHT update logic . The BHT update logic  updates the corresponding branch history table entry with the resolved outcome, NT.","At time T, conditional branch instruction JNS is provided again to the translate stage logic . This time, because contents of the aliased branch history table entry reflect the outcome of the previously executed JZ instruction, the take branch output signal  is not asserted, indicating a not taken prediction. Hence, the microprocessor  continues execution of sequential instructions. Yet, when the JNS instruction is resolved, the not taken prediction is contradicted and the pipeline must be flushed and refilled with instructions beginning with the target instruction prescribed by the JNS instruction.","It is significant to note that the accuracy of the prediction for either of the two conditional branch instructions is negatively influenced by virtue of the presence of historical outcome data corresponding to the other conditional branch instruction. When the JZ instruction is fetched during time T, its corresponding branch history table entry contains data pertaining to the execution of the JNS instruction during time T. When the JNS instruction is fetched during time T, its corresponding branch history table entry contains data pertaining to the execution of the JZ instruction during time T.","Various solutions have been offered to limit the amount of aliasing in a branch history table . One technique drastically increases the size of the branch history table . Another technique causes the branch history table  to function similar to a memory cache: only one branch instruction is allowed to access and update an entry in the branch history table . As a result, prediction accuracies are improved for those instructions fortunate enough to have table entries. But, because the table  is limited in size, once it  is filled, then predictions for subsequent branch instructions cannot be dynamically provided. Fallback predictive techniques must be used that utilize static attributes of branch instructions to predict their outcome. Such static attributes include the test type or branch direction prescribed by the branch instruction. This kind of prediction is called a static prediction because it relies on attributes of a branch instruction that do not change as it is executed in a given application program.","Other approaches to dynamic prediction in the presence of aliasing employ an agree\/disagree scheme wherein outcome information is maintained in the branch history table  regarding whether a subsequent dynamic prediction should agree or disagree with a static prediction based upon a current resolved outcome. These approaches are described in co-pending U.S. patent application Ser. No. 09\/203,884 (Docket CNTR.1393), entitled METHOD AND APPARATUS FOR PERFORMING BRANCH PREDICTION COMBINING STATIC AND DYNAMIC BRANCH PREDICTORS, having common inventors and having the same assignee, which is hereby incorporated by reference.","There are various techniques used to generate the dynamic branch predictions and static branch predictions. Several of these techniques are described in co-pending U.S. patent application Ser. No. 09\/203,900 (DocketCNTR.1392), entitled METHOD AND APPARATUS FOR PREDICTING CONDITIONAL BRANCH INSTRUCTION OUTCOME BASED ON BRANCH CONDITION TEST TYPE, having common inventors and having the same assignee, which is hereby incorporated by reference.","In spite of all the approaches discussed above, no unified mechanism has been provided that takes into account the outcome bias of branch instructions to discriminate where their corresponding historical outcome data is recorded in the branch history table . In the prior art, if two or more aliased branch instructions have the same outcome bias, then their corresponding branch table entry most probably will provide an accurate dynamic prediction when any of the branch instructions is executed. However, such a case is simply serendipitous. In contrast, the example of  is equally probable where two branch instructions having opposite outcome biases are aliased to the same entry. In this instance, the effects on the execution speed of the microprocessor  are more detrimental than if no branch prediction technique had been used in the first place.","One skilled in the art will appreciate that the accuracy of dynamic predictions for aliased branch instructions is seriously affected when those branch instructions do not exhibit a similar outcome bias tendency. This problem can cause extensive performance degradation for an application program having a significant number of branch history table entries.","The present invention overcomes the problem of diminished branch prediction accuracy by providing a mechanism for maintaining historical outcome records for aliased branch instructions that exhibit a bias toward one outcome separate from those aliased branch instructions that exhibit bias toward another outcome. By doing so, the negative effects of aliasing are precluded in a branch history table while the positive effects are preserved. The present invention is more particularly described with reference to .","Referring to , a table  is presented illustrating empirical conditional branch instruction outcomes as observed in predominant desktop application programs. The table  depicts percentages of branches taken for various test types of x86-compatible conditional branch instructions. The table  reflects data collected by the present inventors regarding execution of the x86-compatible conditional branch instructions on an x86-compatible microprocessor that is running present day predominant desktop application programs such as Microsoft\u00ae Excel, Word, PowerPoint, and Access, as well as Lotus\u00ae 1-2-3, WordPerfect\u00ae, and Netscape\u00ae Communicator. The present inventors have advantageously observed that test types of x86-compatible conditional jump instructions can be categorized according to their exhibited bias toward one outcome or the other.","The test types for which data were collected correspond to x86 architecture test types and are designated in table  according to commonly recognized x86 instruction mnemonics. The test types are overflow (JO), not overflow (JNO), carry (JC), not carry (JNC), zero (JZ), not zero (JNZ), carry or zero (J(C|Z)), not carry or zero (JN(C|Z)), sign (JS), not sign (JNS), parity (JP), not parity (JNP), sign and overflow not equal (J(S^O)), sign and overflow equal (JN(S^O)), sign and overflow not equal or zero (J(S^O)|Z), sign and overflow equal or zero (JN(S^O)|Z), and CX register zero (JCXZ). The test types correspond to status flag bits in the EFLAGS register of an x86-compatible microprocessor. Although x86-compatible test types are used for this example, it is noted that a given microprocessor may support other test types. One skilled in the art will appreciate that the present invention is not restricted to a particular set of test types as shown in ; empirical outcome data for any set of conditional branch instructions may be obtained and evaluated to determine outcome bias.","For each test type, the percentage of branches taken is shown. As may be observed, a first subset of the test types, JNO, JNS and J(C|Z), exhibit a marked bias toward being taken. A second subset of the test types, JNC, JZ, JN(C|Z), J(S^O), and J(S^O)|Z, exhibit a marked bias toward being not taken. The remaining test types exhibit a marginal bias toward one outcome or the other. These observations serve as the basis for providing branch predictions in accordance with the present invention.","For example, in one embodiment, the present invention employs two branch history tables: a taken branch history table and a not taken branch history table. Historical outcome data associated with conditional branch instructions exhibiting a bias toward being taken, as presented in the table , is recorded in the taken branch history table. Historical outcome data associated with conditional branch instructions exhibiting a bias toward being not taken is recorded in the not taken branch history table. Since conditional branch instructions that exhibit a bias toward being taken are more likely to produce a resolved outcome of taken, it follows then that the outcomes of aliased conditional branch instructions within the taken table will tend to reinforce taken predictions for one another. Similarly, the outcomes of aliased conditional branch instructions within the not taken table will reinforce not taken predictions for one another. Segregating historical outcome records for aliased conditional branch instructions according to their outcome bias tendencies fundamentally produces more accurate predictions.","Now referring to , a diagram is presented of a portion of a related art pipeline microprocessor  according to the present invention for predicting the outcome of branch instructions. The microprocessor  includes fetch stage logic , translate stage logic , and interlock control . For clarity of discussion, remaining stages of the microprocessor  are not shown. The microprocessor  incorporates elements similar to those described with reference to FIG. . Like elements have like references with the hundreds digit replaced by a . In addition, the microprocessor  according to the present invention includes a bias indicator . In place of the branch history table , the microprocessor  has a split dynamic branch predictor  that has branch history tables ,  that are categorized according to outcome biases for conditional branch instructions. In one embodiment, the split dynamic branch predictor  has a taken (T) table  and a not taken (NT) table . In another embodiment, the split dynamic branch predictor  has more than two branch history tables that are categorized to finer degrees of outcome bias for conditional branch instructions. The bias indicator  provides a bias indication output  to the split dynamic branch predictor and also to subsequent stages in the microprocessor . In addition, the bias indication output  associated with a particular conditional branch instruction is provided to the BHT update logic  so that the appropriate branch history table,  or , can be updated following resolution of the particular conditional branch instruction.","For execution of sequential instructions, the microprocessor  according to the present invention functions similar to the microprocessor  of FIG. . Improved performance is realized for execution of conditional branch instructions. The present invention can be employed in a microprocessor  that utilizes any of the dynamic branch prediction schemes alluded to above where less than accurate branch predictions are obtained as a result of conditional branch instructions exhibiting contradictory outcome biases being aliased to the same branch table entry.","When a conditional branch instruction is fetched from the instruction buffer , its CIP  is provided to the split dynamic branch predictor . Low-order bits of the CIP  index into both branch history tables , . Concurrently, the conditional branch instruction itself is provided to the bias indicator . The bias indication output  is asserted if the conditional branch instruction falls within the taken category of outcome bias. The bias indication output  is not asserted if the conditional branch instruction falls within the not taken category of outcome bias. The low-order bits of the CIP  cause two historical outcome records to be provided in the split dynamic branch predictor : an entry from the T table  and an entry from the NT table . The bias indication output  directs a mux  to provide either the entry from the T table  or the NT table . The selected entry is then evaluated to determine whether a speculative branch should be taken or not. The take output  is asserted if a speculative branch is indicated. The take output is not asserted if sequential instruction execution is indicated.","The resolved outcome of a conditional branch instruction is fed back to the BHT update logic  via bus  so that the resolved outcome can be added to the historical outcome record in the branch history table to which the conditional branch instruction was mapped. The proper branch history table is selected by the state of the bias indication output  that corresponds to the conditional branch instruction. If the conditional branch instruction is in the taken bias category, then the T table  is selected for update. If the conditional branch instruction is in the not taken bias category, then the NT table  is selected for update. Hence, the outcome results of conditional branch instructions having dissimilar outcome biases are precluded from diminishing the accuracy of entries in the split dynamic branch predictor . Thus, the negative effects of aliasing are reduced in a microprocessor  according to the present invention. As a result, the overall accuracy of branch predictions is improved, thus boosting the performance of the microprocessor . How performance is boosted in the presence conditional branch instructions exhibiting contradictory outcome biases is more specifically described with reference to FIG. .","Referring to , a table  is provided illustrating the effects of predicting branches with the microprocessor  of FIG. . The table  traces the execution of two x86-compatible conditional branch instructions: jump if sign flag not set, designated by JNS, and jump if zero flag set, designated by JZ. As discussed with reference to , the JNS instruction exhibits a bias toward being taken and the JZ instruction exhibits a bias toward being not taken. Execution of the instructions are traced with respect to times T through T, time T being later than time T. Column headings and contents in the table  correspond to headings and contents as described with reference to  with the exception that the state of the bias indication output  is portrayed in the column entitled Bias Indication.","At time T, conditional branch instruction JNS is provided to the translate stage logic . The low-order bits of the CIP  are used to access two corresponding branch history table entries for the JNS instruction: one from the T table  and one from the NT table . In addition, the JNS instruction itself is provided to the bias indicator  and a resulting bias indication output  indicates an outcome bias of taken (T). Consequently, the bias indication output  directs the mux  in the split dynamic branch predictor  to evaluate the entry from the T table . The T table  provides a taken prediction and the microprocessor  is thus directed to take a speculative branch to a branch target instruction associated with the JNS instruction. Resolution of the JNS instruction prior to time T confirms the branch prediction. Following resolution of the JNS instruction, the resolved outcome, taken (T), is provided to the BHT update logic  so that the branch history table entry corresponding to JNS can reflect the recent outcome. In the branch prediction scheme used in this example, such an update will result in a dynamic branch prediction of taken (T) the next time the corresponding branch history table entry is accessed.","At time T, conditional branch instruction JZ is provided to the translate stage logic . Low-order bits of its CIP  are provided to the split dynamic branch predictor  in addition to the instruction itself being provided to the bias indicator . Because the low-order address for the JZ instruction is the same as that for the JNS instruction, the JZ instruction is aliased to the JNS instruction. But, because the JZ instruction exhibits an outcome bias toward being not taken, the bias indication output  directs the mux  to select a historical outcome record from the NT table  rather than the T table . As a result, the NT table  provides a dynamic branch prediction of not taken (NT). Thus, in contrast to the example of , the microprocessor  according to the present invention is directed to continue sequential instruction execution. Resolution of the JZ instruction prior to time T confirms the branch prediction obtained from the NT table . Following resolution of the JZ instruction, the resolved outcome, not taken (NT), is provided to the BHT update logic  along with the bias indication output  so that the branch history table entry corresponding to the JZ instruction can reflect the recent outcome.","At time T, conditional branch instruction JZ is again provided to the translate stage logic . Its corresponding entry in the NT table  is accessed, and because the entry contents indicate that the branch will be not taken, the take branch output signal  is not asserted. Consequently, the microprocessor  is directed to continue execution of sequential instructions. Resolution of the JZ instruction prior to time T confirms the previous prediction. Following resolution of the JZ instruction, the resolved outcome, not taken (NT), is provided to the BHT update logic  along with the bias indication output  so that the branch history table entry corresponding to the JZ instruction can reflect the recent outcome. The BHT update logic  updates the corresponding branch history table entry in the NT table  with the resolved outcome, NT.","At time T, conditional branch instruction JNS is provided again to the translate stage logic . The bias indication output  directs the split dynamic branch predictor to select the historical record from the T table . As such, because the contents of the T table entry do not reflect the outcome of the previously executed JZ instruction, a taken prediction is made in accordance with the resolved outcome obtained during time T. Hence, the microprocessor  continues execution of sequential instructions. Yet, when the JNS instruction is resolved, the not taken prediction is contradicted and the pipeline must be flushed and refilled with instructions beginning with the target instruction prescribed by the JNS instruction.","In contrast to the similar example discussed with reference to , the microprocessor  according to the present invention does not require that clock cycles be consumed with pipeline flushes for aliased conditional branch instructions having tendencies toward opposite outcomes. Because their historical outcome records are segregated, the outcome of one instruction does not influence the outcome of the other instruction.","It is noted that to implement a two-table design would require twice the number of storage bits over a single table design. However, indexing logic and record retrieval logic can be shared between multiple history tables. One skilled in the art is aware that some branch history tables in conventional microprocessors comprise multiple bits for each outcome record. In an alternate embodiment of the present invention, the two-table scheme can be implemented by devoting half the number of bits in a conventional scheme to a record for taken bias and the other half for not taken bias.","Now referring to , flow chart  is presented of a method according to the present invention for predicting the outcome of branch instructions in a pipeline microprocessor.","Flow begins at block  where an instruction is fetched from an instruction buffer and provided to translate stage logic in the microprocessor. Flow then proceeds to decision block .","At decision block , the instruction is evaluated to determine if it is a conditional branch instruction. If it is, then flow is directed to decision block . If it is not a conditional branch instruction, then no branch prediction is required. Thus, flow proceeds to block .","At decision block , the conditional branch instruction is evaluated to determine its outcome bias. If it is biased toward a TAKEN outcome, then flow proceeds to block . If it is biased toward a NOT TAKEN outcome, then flow proceeds toward block .","At block , because it has been determined that the conditional branch instruction exhibits a TAKEN bias, a corresponding entry in a TAKEN branch history table is retrieved and evaluated. As a result of the evaluation, a branch prediction is generated for the conditional branch instruction. Flow then proceeds to block .","At block , because it has been determined that the conditional branch instruction exhibits a NOT TAKEN bias, a corresponding entry in a NOT TAKEN branch history table is retrieved and evaluated. As a result of the evaluation, a branch prediction is generated for the conditional branch instruction. Flow then proceeds to block .","At block , the outcome bias of the conditional branch instruction, TAKEN or NOT TAKEN, is stored for later reference. Flow then proceeds to block .","At block , the conditional branch instruction executed such that its outcome is resolved. Flow then proceeds to decision block .","At decision block , the outcome bias of the conditional branch instruction is recalled in order to determine which branch history table to update. If the outcome bias is TAKEN, then flow proceeds to block . If the outcome bias is NOT TAKEN, then flow proceeds to block .","At block , because the outcome bias of the conditional branch instruction is TAKEN, the corresponding entry in the TAKEN branch history table is updated to reflect the resolved outcome obtained in block . Flow then proceeds to block .","At block , because the outcome bias of the conditional branch instruction is NOT TAKEN, the corresponding entry in the NOT TAKEN branch history table is updated to reflect the resolved outcome obtained in block . Flow then proceeds to block .","At block , the method completes.","Although the present invention and its objects, features, and advantages have been described in detail, other embodiments are encompassed by the invention. For example, the present invention has been particularly characterized in terms of a biased indicator that bases its prediction on outcome data corresponding to test type. Yet, there are other operands within a conditional branch instruction whose state may yield more accurate indications of outcome bias. For example, many conditional branch instructions are more biased toward one outcome if the branch is backwards, i.e., the branch target instruction is stored in a lower memory address than the conditional branch instruction. Such indication can be obtained by evaluating the conditional branch instruction when it is provided to the bias indicator. The relevant aspects of the present invention include such evaluations and will thus provide a bias indication by evaluating other aspects of the conditional branch instruction as well as test type.","In the future, other statistical indicators may become relevant to determining if a conditional branch instruction has a particular outcome bias and to predicting the outcome given those indicators. For example, the particular application program that is executing on a microprocessor may be relevant. The present invention comprehends such indications. Indeed, the bias indication obtained may be based upon a number of these indicators outside of contents of a dynamic branch history table.","Furthermore, although one embodiment of the invention is described with respect to an x86-compatible microprocessor, it will be clear to one skilled in the art that the present invention may be applied to other microprocessor architectures which do not utilize the x86 instruction set. Therefore, the present disclosure is not intended to be limited to application within the x86 architecture. In addition, although embodiments are described which categorize outcomes into TAKEN and NOT TAKEN categories, the present invention is not limited to the particular subsets indicated. Rather, the present invention is directed broadly to categorization of outcome bias to support more accurate dynamic branch predications in the presence of aliasing based upon useful criteria defined by a designer, in particular the outcomes of conditional branch instructions when executed within predominately used application programs on a given microprocessor.","Those skilled in the art should appreciate that they can readily use the disclosed conception and specific embodiments as a basis for designing or modifying other structures for carrying out the same purposes of the present invention without departing from the spirit and scope of the invention as defined by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["These and other objects, features, and advantages of the present invention will become better understood with regard to the following description, and accompanying drawings where:",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3","b":"2"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 6","b":"5"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
