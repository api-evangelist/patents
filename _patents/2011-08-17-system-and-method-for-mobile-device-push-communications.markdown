---
title: System and method for mobile device push communications
abstract: Pushing data to mobile devices can be problematic because mobile platforms may support a number push services, each of which have different cost and reliability characteristics. The problem of being able to push data to multiple different types of mobile devices from a single server is solved by a push service aggregator supporting multiple push services. Upon receiving a push request, one or more push services are selected for pushing data to a client. The selection may be based on a delivery profile included with the push request, information about the client, past performance of the push services, current status of the push services, or combinations of these. The status of the push may be tracked and monitored so as to retry in the case of non-delivery.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08788881&OS=08788881&RS=08788881
owner: Lookout, Inc.
number: 08788881
owner_city: San Francisco
owner_country: US
publication_date: 20110817
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This disclosure relates generally to contacting a mobile communications device, including, more particularly, to selecting one or more push mechanisms to push a message to the mobile communications device.","There was a time when computers were so expensive that only businesses could afford such purchases. These computers had to be housed in large facilities and the number of available applications could perhaps be counted using single hand. Today, we live in a very different world. Computing devices can now fit on a desk or even in one's pocket, purse, or briefcase as in the case of smartphones and tablet computers. There are now millions of these computing devices in the hands of consumers, businesses, and governments.","Indeed, there has also been an explosion in the number of applications available. For example, the Android Market and Apple App Store each have over 100,000 applications available, with many more applications being added each and every day. These applications are sometimes referred to as \u201capps.\u201d There is a rich variety of applications. Some applications are merely for fun and entertainment. Other applications are for work. There are applications covering such diverse categories as business, games, health, recipes, shopping, sports, news, travel, and many more.","In some cases, an application developer or content provider may want to contact the computing device on which the application is installed. For example, there may be a critical software update, a new piece of information, or some other instruction or command for the device\u2014just to name a few examples.","However, contacting the device can be daunting task for the application or content provider because there are many different factors to consider. There are dozens of different types, models, and platforms of mobile communications devices. Further, there are many different operating systems, different versions, and communication networks and carriers. In some cases, because of the complexity, the provider chooses not to contact the device or the contact fails. This may be especially unfortunate where the contact is related to a matter that is urgent such as a security concern, a large financial transaction, and so forth.","Therefore, there is a need to provide systems and techniques to facilitate contacting a mobile communications device.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["100","100","105","110","115","120","125","130","125","100"]},"Communication network  may itself be comprised of many interconnected computer systems and communication links. Communication links  may be hardwire links, optical links, satellite or other wireless communications links, wave propagation links, or any other mechanisms for communication of information. Various communication protocols may be used to facilitate communication between the various systems shown in . These communication protocols may include TCP\/IP, HTTP protocols, wireless application protocol (WAP), vendor-specific protocols, customized protocols, and others. While in one embodiment, communication network  is the Internet, in other embodiments, communication network  may be any suitable communication network including a local area network (LAN), a wide area network (WAN), a wireless network, a intranet, a private network, a public network, a switched network, and combinations of these, and the like.","Distributed computer network  in  is merely illustrative of an embodiment. One of ordinary skill in the art would recognize other variations, modifications, and alternatives. For example, more than one server system  may be connected to communication network . As another example, a number of mobile client systems , , and  may be coupled to communication network  via an access provider (not shown) or via some other server system.","Mobile client systems , , and  typically request information or a service from a server system which provides the information or service. It should be appreciated, however, that data can generally flow in both directions (e.g., a backup service primarily sends data from clients to server), but the server is the service provider. Server systems by definition typically have more computing and storage capacity than mobile client systems. However, a particular computer system may act as both a client or a server depending on whether the computer system is requesting or providing services. Aspects of push communications may be embodied using a client-server environment or a cloud-computing environment.","Server  is responsible for receiving requests from mobile client systems , , and , performing processing required to satisfy the requests, and for forwarding the results corresponding to the requests back to the requesting mobile client system. The processing required to satisfy the request may be performed by server system  or may alternatively be delegated to other servers connected to communication network .","Mobile client systems , , and  enable users to access and query information or applications stored by server system . A mobile client may be referred to as a distributed mobile client. Some example mobile client systems include but are not limited to portable electronic devices (e.g., mobile communication devices) whose principle function is voice communication including the Apple iPhone\u00ae, the Apple iPad\u00ae, the Palm Pre\u2122, or any mobile device running the Apple iOS\u2122, Android\u2122 OS, Google Chrome OS, Symbian OS\u00ae, Windows Mobile\u00ae OS, Palm OS\u00ae or Palm Web OS\u2122. In a specific embodiment, a \u201cweb browser\u201d application executing on a mobile client system enables users to select, access, retrieve, or query information and\/or applications stored by server system . Examples of web browsers include the Android browser provided by Google, the Safari\u00ae browser provided by Apple, the Opera Web browser provided by Opera Software, the BlackBerry\u00ae browser provided by Research In Motion, the Internet Explorer\u00ae and Internet Explorer Mobile browsers provided by Microsoft Corporation, the Firefox\u00ae and Firefox for Mobile browsers provided by Mozilla\u00ae, and others.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 2","FIG. 2"],"b":["200","205","210","215","210","220","225","230","235","240"]},"Input device  may also include a touchscreen (e.g., resistive, surface acoustic wave, capacitive sensing, infrared, optical imaging, dispersive signal, or acoustic pulse recognition), keyboard (e.g., electronic keyboard or physical keyboard), buttons, switches, stylus, or a combination of these.","Mass storage devices  may include flash and other nonvolatile solid-state storage or solid-state drive (SSD), such as a flash drive, flash memory, or USB flash drive. Other examples of mass storage include mass disk drives, floppy disks, magnetic disks, optical disks, magneto-optical disks, fixed disks, hard disks, CD-ROMs, recordable CDs, DVDs, recordable DVDs (e.g., DVD-R, DVD+R, DVD-RW, DVD+RW, HD-DVD, or Blu-ray Disc), battery-backed-up volatile memory, tape storage, reader, and other similar media, and combinations of these.","Push communications may also be used with computer systems having different configurations, e.g., with additional or fewer subsystems. For example, a computer system could include more than one processor (i.e., a multiprocessor system, which may permit parallel processing of information) or a system may include a cache. The computer system shown in  is but an example of a computer system suitable for use with push communications. Other configurations of subsystems suitable for use with push communications will be readily apparent to one of ordinary skill in the art.","For example, in a specific implementation, the computing device is a mobile communication device such as a smartphone or tablet computer. Some specific examples of smartphones include the Droid Incredible and Google Nexus One, provided by HTC Corporation, the iPhone or iPad, both provided by Apple, and many others. Typically, these mobile or portable computing devices have less resources (e.g., memory, storage, smaller screens, or processing power) than a desktop computer. Further, such mobile or portable computing devices are designed to be powered primarily by a battery, rather than being constantly plugged in to a power outlet as in the case of a desktop computer. So, given these differences between portable and non-portable computing devices, it is generally desirable that applications on portable computing devices be small and lightweight (e.g., consume relatively fewer resources as compared to non-portable computing devices). The computing device may be a laptop or a netbook. In another specific implementation, the computing device is a non-portable computing device such as a desktop computer or workstation.","A computer-implemented or computer-executable version of the program instructions useful to practice push communications may be embodied using, stored on, or associated with an intransient computer-readable medium. An intransient computer-readable medium may include any medium that participates in providing instructions to one or more processors for execution. Such a medium may take many forms including, but not limited to, nonvolatile, volatile, and transmission media. Nonvolatile media includes, for example, flash memory, or optical or magnetic disks. Volatile media includes static or dynamic memory, such as cache memory or RAM. Transmission media includes coaxial cables, copper wire, fiber optic lines, and wires arranged in a bus. Transmission media can also take the form of electromagnetic, radio frequency, acoustic, or light waves, such as those generated during radio wave and infrared data communications.","For example, a binary, machine-executable version, of the software useful to practice push communications may be stored or reside in RAM or cache memory, or on mass storage device . The source code of this software may also be stored or reside on mass storage device  (e.g., flash drive, hard disk, magnetic disk, tape, or CD-ROM). As a further example, code useful for practicing push communications may be transmitted via wires, radio waves, or through a network such as the Internet. In another specific embodiment, a computer program product including a variety of software program code to implement features of push communications is provided.","Computer software products may be written in any of various suitable programming languages, such as C, C++, C#, Pascal, Fortran, Perl, Matlab (from MathWorks, www.mathworks.com), SAS, SPSS, JavaScript, CoffeeScript, Objective-C, Objective-J, Ruby, Python, Erlang, Lisp, Scala, Clojure, and Java. The computer software product may be an independent application with data input and data display modules. Alternatively, the computer software products may be classes that may be instantiated as distributed objects. The computer software products may also be component software such as Java Beans (from Oracle) or Enterprise Java Beans (EJB from Oracle).","An operating system for the system may be the Android operating system, iPhone OS (i.e., iOS), Symbian, BlackBerry OS, Palm web OS, bada, MeeGo, Maemo, Limo, or Brew OS. Other examples of operating systems include one of the Microsoft Windows family of operating systems (e.g., Windows 95, 98, Me, Windows NT, Windows 2000, Windows XP, Windows XP x64 Edition, Windows Vista, Windows 7, Windows CE, Windows Mobile, Windows Phone 7), Linux, HP-UX, UNIX, Sun OS, Solaris, Mac OS X, Alpha OS, AIX, IRIX32, or IRIX64. Other operating systems may be used.","Furthermore, the mobile device or portable computer device may be connected to a network and may interface to other computers using this network. The network may be an intranet, internet, or the Internet, among others. The network may be a wired network (e.g., using copper), telephone network, packet network, an optical network (e.g., using optical fiber), mobile network, or a wireless network, or any combination of these. For example, data and other information may be passed between the mobile device or portable computer and components (or steps) of a system useful in practicing push communications using a mobile network employing a protocol such as code division multiple access (CDMA), Global System for Mobile Communications\/General packet radio service (GSM)\/(GPRS), Worldwide Interoperability for Microwave Access (WiMAX), or 3GPP Long Term Evolution (LTE) or a wireless network employing a protocol such as Wi-Fi (IEEE standards 802.11, 802.11a, 802.11b, 802.11e, 802.11g, 802.11i, and 802.11n, just to name a few examples). For example, signals from a computer may be transferred, at least in part, wirelessly to components or other computers, or from mobile communications devices to other mobile communications devices.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 3","b":["305","310","315","320","325","330","335"]},"Users interact with their mobile devices via application programs  on the devices. An application program may be referred to as an \u201capp.\u201d Such applications are developed or provided by application developers or content providers. These applications are typically made available for the client via a marketplace such as the Android Market and Apple App Store.","There are hundreds of thousands of application programs available for the clients. For example, the Android Market and Apple App Store each have over 100,000 applications available for download, with many more applications being added each and every day. There are applications covering such diverse categories as business, education, entertainment, finance, health & fitness, news, music, shopping, sports, travel, weather, and many more.","A specific example of an application is Lookout Mobile Security, provided by Lookout Inc. of San Francisco, Calif. Lookout Mobile Security is a lightweight application designed to protect a smartphone against phishing, malware, and spyware. There are over 8 million Lookout users and the company has received awards and recognition from PCWorld, BusinessWeek, The New York Times, CNET.com, The Wall Street Journal, CNN, and many others.","Other examples of applications that may be found on a client device include browser programs (e.g., Android Browser, Dolphin Browser, Firefox Mobile, Opera Mobile, or Safari), text message (e.g., Short Message Service (\u201cSMS\u201d) or Multimedia Messaging Service (\u201cMMS\u201d) programs (e.g., Handcent), and map, Global Positioning System (GPS), or navigation programs (e.g., Google Maps). When the application is installed on the device, an icon to the application may be placed on the home screen or application menu of the device. The application can be accessed or launched by touching the icon on the screen.","In some cases, an application developer provides the application for free, i.e., without cost or charge to the user. Users of free applications may be referred to as a non-paying customers. In other cases, the application must be purchased by the user. There can be an initial or one-time purchase cost, a recurring cost (e.g., monthly subscription fee), or both. Users who purchase applications may be referred to as paying customers.","Push mechanism providers  provide services or mechanisms for application developers to send information from application servers  to the users and application programs on the devices. Some examples of push mechanisms include Android Cloud to Device Messaging (C2DM), Apple Push Notification Service (APNS), SMS Push, Lookout Cloudpush, BlackBerry Push Service, long poll (i.e., a persistent connection from client to server which allows the server to notify the client when needed), and others. Typically, the information includes a lightweight message (e.g., 1024 characters or less) that instructs the client application program to connect to the application server to receive further information, instructions, commands, or updates (e.g., bug fixes, patches, new e-mails, news items, social networking status updates, current weather, stock quotes and alerts, and so forth).","Push service system  facilitates or solves the problem of being able to push information or requests to different types of client devices from a single server. Some advantages of the push service system include: (1) providing a flexible signaling depending on the device\u2014support for a variety of devices, (2) providing fault tolerant delivery for the application server, (3) providing a single point for analytics of various push backend mechanisms to compare their performance, and (4) allowing for loose coupling between the application server and notification mechanisms. This helps to make the application program more maintainable.","More particularly, some push mechanisms are device-specific. The Android C2DM application programming interface (API), provided by Google, allows content or application providers to push messages to Android client devices, but not to iPhone devices. Conversely, APNS, the Apple Push Notification Service provided by Apple, allows push messages to be sent to iPhone client devices, but not to Android devices.","Selecting a suitable or appropriate push mechanism can be complicated because there are many factors to consider. In addition to type of device (e.g., Android versus iPhone), different push mechanisms offer different delivery options and message handling, and different pricing options and plans. Some push mechanisms are free or without cost to the application provider or user. Other push mechanisms may require a payment for pushing the message. There can be different payment options and pricing models (e.g., message bundling or subscriptions). Options may vary depending upon country. For example, a push mechanism provider may offer free SMS messages delivered to North America, but require a payment for delivery to regions outside North America (e.g., Russia). Some push mechanisms are more reliable than other push mechanisms. Some push mechanisms provide delivery confirmations while others do not. As an example, Android C2DM makes no guarantee about the delivery of messages.","The presence of all these different factors make it very difficult for the application provider to decide and select a push mechanism. Further, an application provider may desire different push mechanisms depending upon the information to be sent to the client. For example, if an update is a critical security update the application provider may desire a highly reliable push mechanism even if the mechanism is very expensive. If however, the information is less critical, the application provider may desire a less expensive push mechanism even though that push mechanism may not be as reliable as the more expensive push mechanism.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 4","FIG. 3","FIG. 4"],"b":["402","410","404","406","415"]},"In an embodiment, push service system  includes a push request receiver , a decision module , a routing module , a tracking or monitoring module , and a performance analysis and reporting module . The system further includes a push mechanism current status reporting unit , a database  to store push mechanism provider performance history, a database  to store client information, a database  to store policies, a database  to store push mechanism provider details, and a policy builder module . The push service system may be referred to as a push service aggregator or a push mechanism aggregator. The push service system or push service or mechanism aggregator need not contain all of the components shown in . Other embodiments are possible.","In brief, the push request receiver receives  a push request from an application server. The application server may be referred to as a caller of the push service. The push request may be referred to as a job request.  shows a block diagram of an example of a push request . In an embodiment, the push request may include a message , delivery profile , client contact information , other information , or combinations of these.","The message includes the information that is to be pushed to the client device. The delivery profile indicates the push delivery requirements for the message, e.g. such as cost, reliability, timing, etc. The client contact information includes information to identify the client (e.g., a phone number). Some examples of other information that may be included in the push request include a push token. In an embodiment, a push token is an alternate client contact information\u2014analogous to a phone number over a different service. It should be appreciated that  is merely an example of some of the information that may be included in a push request and a push request does not necessarily include all the information shown in .","For example, in various specific implementations, a request includes the message and client contact information, but other information, delivery profile, or both are omitted. In this specific implementation, the other information, delivery profile, or both may be stored on the push service system and may be identified or cross-referenced using the client contact information. In another specific implementation, a request includes the message, client contact information, and delivery profile. Further discussion of the push request including the delivery profile is provided later in this application below.","Referring now to , the request is forwarded  to the decision module. The decision module analyzes and evaluates the request to select one or more push mechanism providers from among the set of mechanisms to fulfill the request. The decision module, in making the decision, may consult one or more databases, such as the push mechanism provider history database, client information database, policy database, push mechanism provider details database, or combinations of these. The decision on which push mechanism to use is forwarded  to the routing module which packages, formats, and routes  the message to the selected push mechanism which, in turn, attempts to push  the message to the client. The tracking module tracks the delivery and status of the push and can report  to the application server that originated or initiated the push request.","In other words, in a specific implementation, an application server is communicating to clients or mobile client devices using any number of different messaging mechanisms. A mechanism (e.g., Android C2DM, Apple Push Notifications, SMS, Lookout Cloudpush) may provide different service guarantees such as reliability and latency. In this environment, there can be several types of devices, which each support a subset of the mechanisms. There can be several types of messages to be sent, which may have different requirements for service delivery. In this specific implementation, the push service provides a general device-contacting service, which allows a message to be delivered to a device via one or more configured messaging mechanisms. When the server (e.g., application server) has a message to communicate to a device, the push service can aggregate several messaging mechanisms to provide the required level of service while optimizing or balancing various parameters (e.g., minimizing or reducing cost, maximizing or improving reliability). This can be achieved by choosing an appropriate mechanism or multiple mechanisms (i.e., two or more) and additional logic such as retries or parallel delivery.","Push mechanism performance database  stores information about the past performance of the push mechanisms to help decision module  select one or more appropriate push mechanisms based on the push request. The service tracks any number of parameters to analyze performance of mechanisms. The performance information of a push mechanism can include qualitative information (e.g., \u201cpoor,\u201d \u201cfair,\u201d \u201cgood,\u201d or \u201cexcellent\u201d), quantitative information (e.g., numerical values, or percentage values), statistical information, quality of service (QoS) metrics, grade of service (GoS) metrics, ratings, grades, latency, ratios, key performance indicators (KPIs), or combinations of these. The information can be collected from an external source, internal source (e.g., via the tracking module), or both.","In a specific implementation, the service tracks message delivery success rates and message delivery latency. Table A below shows some of the information that may be collected in the push mechanism performance database.",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE A"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Success",{},"Variation in"]},{"entry":[{},"Rate","Latency","Latency"]},{"entry":["Push Mechanism","(percent)","(seconds)","(milliseconds)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Android C2DM","97.7","3.2","40"]},{"entry":["APNS","95.2","3.1","42"]},{"entry":["Clickatel SMS","89.3","4.3","45"]},{"entry":["BlackBerry Push","98.4","2.9","39"]},{"entry":"Service"},{"entry":["Microsoft Push","94.8","2.8","50"]},{"entry":"Notification Service"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Table A includes columns \u201cPush Mechanism,\u201d \u201cSuccess Rate,\u201d \u201cLatency,\u201d and \u201cVariation in Latency.\u201d The \u201cPush Mechanism\u201d column lists the various push mechanisms. The \u201cSuccess Rate\u201d indicates the average success rate of the corresponding push mechanism. For example, the value of \u201c97.7\u201d percent for the mechanism \u201cAndroid C2DM\u201d can indicate that pushes via \u201cAndroid C2DM\u201d are successful 97.7 percent of the time. Alternatively, the success rate may be expressed as a ratio to assess the percentage of messages sent versus the percentage of messages received by the intended recipients. The \u201cLatency\u201d can indicate the amount of time for the mechanism to push the message to the client. For example, the value of 3.2 seconds for the mechanism \u201cAndroid C2DM\u201d can indicate that a time period of 3.2 seconds elapsed from when the push message was transmitted from the push service system to the \u201cAndroid C2DM\u201d mechanism and to the client. Such metrics may be calculated over any time period such as by quarter, month, week, day, or hour. The \u201cVariation in Latency\u201d is measured as a standard deviation in milliseconds (ms) and is sometimes referred to as jitter. Other metrics that may be tracked instead of or in addition to the metrics shown in Table A include data about how long it takes to detect a failure, a retry success rate, or both.","In a specific implementation, the push service system tracks the parameters as a function of location of a device (e.g., which country), connectivity of device (e.g., which network provider, operator, or carrier), device type, or combinations of these. This allows for a very detailed and granular analysis of which push mechanism would be appropriate for pushing the message to the client. For example, some push mechanisms may be more reliable in some countries than in other countries. Some network carriers may have better message delivery success rates than other network carries, and so forth.","Push mechanism provider details database  stores various attributes of the push mechanisms. Some examples of attributes include pricing details, whether or not delivery confirmation is provided (e.g., result notification), reliability guarantees, message size or payload limits (e.g., 8 kB payload allowed), supported push protocols (e.g., WAP PAP 2.2), supported requests (e.g., \u201csubmit push,\u201d \u201ccancel push,\u201d \u201cquery for status,\u201d or \u201cquery for device capabilities\u201d), submission modes (e.g., \u201cpoint-to-point\u201d for submitting a push to a single client, \u201cmulticast\u201d for submitting a push to a list of clients, or \u201cbroadcast\u201d for submitting a push to all clients for a registered application), expiry time (e.g., length of time push mechanism will store push requests), quality of service options (e.g., \u201cmessage reached application,\u201d \u201cmessage reached port on device,\u201d or no acknowledgements (\u201cfire and forger\u201d)), and so forth.","Client information database  stores information about the various clients or users that may be pushed messages via one or more of the push mechanism providers. In other words, in a specific implementation, client information is persistently stored on the push service system. Table B below shows some of the information that may be collected in the client information database.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE B"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Device Type or","Operating",{}]},{"entry":["Client Identification (ID)","Model","System","Carrier"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["8675309","Nexus One","Android","Sprint"]},{"entry":["7410143","iPhone","iOS","AT&T"]},{"entry":["9438822","iPhone","iOS","Verizon"]},{"entry":["6829843","Nokia X6","Symbian","T-Mobile"]},{"entry":["7251096","BlackBerry","BlackBerry","Verizon"]},{"entry":[{},"Torch","OS"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"This Table includes columns for client ID, device type, operating system, and carrier. The client ID is a code to help identify the particular client (or application on the client) that is to receive the push. The client ID may include, for example, a phone number associated with the client (e.g., mobile device telephone number). The ID may be referred to as personal identification number (\u201cPIN\u201d) or registration ID. The ID may include letters, numbers, or alphanumeric characters. The device type column can help to identify the device model. The operating system column lists the operating system on the device. The carrier column indicates the provided carrier. Other information that may collected in the client information database instead of or in addition to what is shown in Table B include a push token (e.g., mechanism specific token such as a C2DM token), device token, authentication token, application key, operating system key, client device platform version, push notification ID, user information (e.g., user's first and last name, street address, city, state, zip code, country, or e-mail), codes identifying the country, network, or both that the mobile device is usually or most recently connected to, a time and date of the last connection, or combinations of these. The client information may be referred to as profile information.","Storing such client information on the push service system can help to relieve the burden on the application server (or application developer) to store the information. Another benefit is that the push request from the application server can be kept lightweight which helps to reduce network traffic and congestion. For example, the push request may simply specify the client device or user to be contacted and the push service system can cross-reference the information in the push request with the client information database to retrieve any other additional information that may be desired. Alternatively, in another specific information, the push request includes further client details such as the push token and device type. In a specific implementation, a push request includes at least a delivery profile.","In a specific implementation, the client information is gathered from the application developer (or from the application server). For example, in some cases, when a user installs an application on the client (e.g., Google Android device), the application registers with a push mechanism (e.g., Google C2DM service) so that push messages can be received at the client. The push mechanism responds with a registration ID that represents a specific client. The application forwards the registration ID to the application server. When the application server wishes to send a push message to the specific client, that specific client can be identified via the registration ID. In this specific implementation, the registration ID is included as client information gathered from the application developer. The client information gathered from the application developer (or application server of the application developer) may be gathered when the application developer registers with the push service system.","In another specific implementation, the application developer or application server does not register with the push service for a device. Rather, the application server merely sends the request to push with all of the relevant information. In this specific implementation, the push service does not need to know\/remember about clients that do not have a live push request, although information may be cached about them.","Push mechanism current status reporting unit  provides status updates to the decision module. Such status updates may be real-time status updates and can indicate whether there are any issues or problems with a push mechanism. That is, in a specific implementation, the push service keeps track of the status of each mechanism provider, such as current response latencies and whether the service is down so that this data can be used to optimally or efficiently use the mechanisms given their current status and past performance. The current status reporting unit can provide information as to whether the mechanism is operating or is online, is down or offline, is experiencing heavy traffic, and so forth. Such status updates may be obtained by querying or polling the push mechanism. In a specific implementation, a status update is obtained by analyzing the performance of pushes sent through the mechanism. In this specific implementation, the analysis includes having the application server confirm delivery when a device connects (round trip). This may be referred to as an out-of-band (OOB) mechanism or technique. The out-of-band technique can use a full round trip response from the application server to confirm receipt of the push.","Policies database  stores policies that determine the routing of a push request. In a specific implementation, delivery is according to configurable policies. That is, the policies are configurable such as by an administrator of the push service system. The routing of a push request to one or more particular push mechanisms may be chosen based on required reliability for a message, cost that the application server (or content provider) is willing to pay, type of device and available mechanisms, current status of back-end mechanism (e.g., if a mechanism is down or behaving poorly, another mechanism may be chosen), or combinations of these.","Policy builder module  provides an interface to policies stored in policies database . In a specific implementation, policy builder module includes a graphical user interface (GUI) for creating, defining, authoring, editing, or altering policies. This allows an administrator to easily add new policies or modify existing policies. In this specific implementation, the push service system includes a graphical user interface (GUI) for displaying a list of policies. The administrator can select a policy from the list of policies to edit the policy. Editing a policy may include changing an existing policy statement, adding a new statement, replacing an existing statement with a new statement, deleting an existing statement, or combinations of these. There can be a policy builder tool having a drag-and-drop interface that allows administers to create and edit policies by dragging and dropping policy objects or components on a policy configuration window provided by the GUI. In another specific implementation, the policy is embodied in code.","Tracking module  tracks the status of the push message transmitted to the push mechanisms. For example, when the push service tries to perform a message delivery using a particular mechanism, the push service may receive an immediate failure result from the mechanism or a pending result. This response is tracked by the tracking module which may then update the push mechanism performance history database. While the message delivery is in progress, the originating application server can query the push service (e.g., tracking module) for the current status; or the originating application server may wait for a callback response from the push service.","More particularly, a mechanism may provide synchronous feedback to the push service in response to a request, in which case the push service can immediately update the message state. A mechanism may provide asynchronous feedback via callback or other means when the message delivery status changes; in this case, the push service can update the message state. Any time the message state changes, the push service may perform a callback to inform the application server that the message state has changed. A mechanism may not provide definitive confirmation that a message has been delivered. In this case one way or approach for the push service to determine that a message was actually delivered is via out-of-bound means.","In a specific implementation, performance analysis and reporting module  provides an interface to query details of the performance of the push mechanisms. The information can be used for tuning or adjustment of policies, audit of the backend mechanisms, or both. A report may include a trend analysis to show the direction in which the various mechanisms are trending. The report can include graphs and charts (e.g., line chart, bar chart, or pie chart).",{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIG. 6","b":"605"},"In a step  the push service system receives a push request from an application server and forwards the request to the decision module. Receiving the request by the push service may be referred to as posting a message send request to the push service. The push request may include a message, prioritization criteria, and information about the client device to receive the message. In a specific implementation, the push request includes the message to be pushed to the client device and a delivery profile. The delivery profile may be referred to as a symbolic delivery profile or a service requirement profile.","The profile can include one or more attributes or parameters to indicate the message delivery requirements or message delivery constraints. For example, the profile can include information such as reliability and latency required, cost willing to pay to deliver the message, or combinations of these. Table C below lists some examples of attributes and provides a corresponding description for each attribute.",{"@attributes":{"id":"p-0077","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE C"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Attribute","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["minimize_cost","Instructs the push service system to prioritize cost when"]},{"entry":[{},"selecting a push mechanism (e.g., select a push mechanism"]},{"entry":[{},"having the lowest cost)."]},{"entry":["minimize_latency","Instructs the push service system to prioritize delivery time"]},{"entry":[{},"when selecting a push mechanism."]},{"entry":["maximize_reliability","Instructs the push service system to prioritize reliability"]},{"entry":["or critical","when selecting a push mechanism."]},{"entry":["cost","Cost, such as a dollar figure or value (e.g., $0.03 or 3"]},{"entry":[{},"cents) that the application developer is willing to pay to"]},{"entry":[{},"have the message pushed to the client device."]},{"entry":["deliver_within","Specifies a time period (e.g., 4 hours) within which the"]},{"entry":[{},"message should be delivered by. Alternatively, an attribute"]},{"entry":[{},"may specify a time and date at which the message should"]},{"entry":[{},"have been pushed to the client device."]},{"entry":["free","Instructs the push service system to select a free push"]},{"entry":[{},"mechanism. If no free push mechanism is available, the"]},{"entry":[{},"system may wait until a free mechanism is available and"]},{"entry":[{},"then deliver the message to the free mechanism. If multiple"]},{"entry":[{},"free mechanisms are available, the system may select more"]},{"entry":[{},"than one of the free mechanisms to help ensure that the"]},{"entry":[{},"message is pushed."]},{"entry":["security_high or","Instructs the push service system to select a push"]},{"entry":["encrypt","mechanism that uses high security measures when pushing"]},{"entry":[{},"a message to a device (e.g., encryption). Such a delivery"]},{"entry":[{},"constraint may prevent an SMS push mechanism from"]},{"entry":[{},"being selected because such mechanisms typically do not"]},{"entry":[{},"encrypt push messages."]},{"entry":["priority","Indicates the priority level of the message to be pushed"]},{"entry":[{},"(e.g., high, medium, or low)."]},{"entry":["customer_type","Indicates whether the user who is to receive the push"]},{"entry":[{},"message is a paying customer or a non-paying customer."]},{"entry":["preferential_customer","Indicates whether the user who is to receive the push"]},{"entry":[{},"message is a preferential customer or non-preferential customer."]},{"entry":["retry strategy","Specifies the activities to be performed if the selected push"]},{"entry":[{},"mechanism fails to push the message to the client device."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"One or more of these attributes may be referred to as prioritization criteria (e.g., prioritize speed or prioritize low cost). Any of the attributes listed in Table C above may instead be stored in client information database  of the push service system rather than being specified in the delivery profile of the push request. The system can correlate other information in the push request, such as client contact information, to determine, for example, whether the customer is a paying or non-paying customer. The determination may include cross-referencing one or more other tables of the system. Specifically, there can be an application provider table that stores profile information of each of the application providers. The application provider profile information can indicate push preferences of the corresponding application providers.","For example, the profile information for an application provider may specify that non-paying customers are only to be serviced by (i.e., receive push messages from) push mechanisms that are without charge, whereas paying customers may receive push messages from push mechanisms that charge for the pushes. The push request may specify the client contact information and client application that is to receive the push message. The system may then correlate the client contact information and client application with the client information table and application provider table to determine whether the client user is a paying customer of the application or a non-paying customer of the application.","In a specific implementation, the delivery profile includes a single attribute. For example, there can be a \u201cno-cost\u201d delivery profile to indicate that free push mechanisms are to be selected and push mechanisms which charge for pushes are not to be selected. In other words, the profile may simply be a name of a profile which is used to reference another set of parameters or push mechanism selection criteria. The delivery profile may be a name of a previously stored delivery profile. Other examples of a profile include a reliable least-cost delivery profile which can indicate that the least expensive push mechanism that is generally reliable (e.g., has a \u201cfair\u201d reliability rating) should be selected.","In another specific implementation, the delivery profile includes multiple attributes (e.g., two or more attributes). Multiple attributes may be ranked such as from most important to least important. This allows the application developer to indicate those attributes that the developer considers most important for the push service system to consider. For example, the application provider may indicate in the delivery profile that \u201ccost\u201d of the push mechanism is the most important attribute followed by \u201creliability.\u201d Alternatively, the delivery profile may indicate that \u201creliability\u201d is the most important attribute followed by \u201ccost.\u201d","In a specific implementation, the request includes the type of device being contacted, such as whether the device is an Android or iPhone device, contact information for available mechanisms (e.g., phone number, Apple push notification ID, Android C2DM token, Lookout cloudpush ID), or both. In another specific implementation, the request includes contact information for the client device (e.g., phone number), but the request does not include the device type. Rather, in this specific implementation, the system identifies the type of device by correlating the device contact information with the device type information that is stored in the client information database.","After receiving the message to be pushed, the push service may respond with an identifier (e.g., a unique identifier) for the message so the application server can reference this message in the future. That is, in response to the server push request, the push service system may respond to the server with a unique push identifier for the received push request. In this specific implementation, the push service exposes a messaging application programming interface (API) to be used by the one or more application servers. The API provides an ID that uniquely identifies a message from an application server to a specific device. In this specific implementation, this unique ID is generated when the message is posted to the push service and returned to the application server.","In a step , the decision module selects or chooses from among a set of push mechanisms (e.g., two or more push mechanisms) one or more push mechanisms to fulfill the push request.  shows a flow  of substeps of a specific implementation of selecting one or more push mechanisms to push the message to the client device. As shown in , in a step  the decision module receives the push request which in a specific implementation includes the message, delivery profile, and client contact information. In a step , the decision module fetches the client information stored in client information database  () by cross-referencing the client contact information.","In a step , the decision module fetches one or more policies stored in policies database  (). Which policy to fetch may be based on information in the delivery profile, client contact information, client information, or combinations of these. In a specific implementation, selection of a policy is based on an attribute in the delivery profile. That is, the delivery profile includes a specific attribute and a corresponding policy is selected based on the specific attribute. For example, when the delivery profile includes an attribute to \u201cminimize_cost,\u201d the decision module selects a corresponding \u201cminimize cost\u201d policy.","A policy may be tagged with a label or other metadata so that the corresponding policy can be selected by matching the delivery profile attribute with the label. There can be a default policy which can be evaluated if a policy corresponding to the delivery profile attribute cannot be found.","In a step , the decision module evaluates the policy so that the message to be pushed can be routed to one or more appropriate push mechanisms. In a specific implementation, a policy includes directions, instructions, logic, rules, or protocols on how the decision module should select one or more push mechanisms. The policy can include one or more statements, clauses, conditional statements, expressions, threshold values, variables, operators such as comparison or relational operators, logical operators, arithmetic operators, or combinations of these. Examples of relational operators include \u201c=\u201d (equal to), \u201c!=\u201d (not equal to), \u201c>\u201d (greater than), \u201c<\u201d (less than), \u201c>=\u201d (greater than or equal to), and \u201c<=\u201d (less than or equal to). Examples of logical operators include \u201cNOT,\u201d \u201cAND,\u201d and \u201cOR.\u201d Examples of arithmetic operators include \u201c+\u201d (addition), \u201c\u2212\u201d (subtraction), \u201c*\u201d (multiplication), and \u201c\/\u201d (division).","As shown in , evaluation of a policy may include reviewing the performance history of a push mechanism (step ), comparing the push mechanism details with any requirements specified in the policy, delivery profile, or both (step ), obtaining the current status of a push mechanism (step ), or combinations of these. As described in the discussion accompanying , push mechanism performance history is stored in database , push mechanism details are stored in database , and the current status of a push mechanism may be obtained from push mechanism current status reporting unit .","Below are some examples of policies (stored in policy database ) that may be evaluated by the decision module when deciding which push mechanism (or mechanisms) to select. The policies are written using pseudo code to help understand the principles, operation, and aspects of the policies and policy evaluation in connection with selecting a push mechanism. It should be appreciated that a policy may be written using any language, syntax, or format (e.g., Extensible Markup Language (XML) format).",{"@attributes":{"id":"p-0090","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Policy 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT push_mechanism WHERE push_mechanism.cost = 0.00"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In the example above, \u201cpolicy \u201d may be selected when the delivery profile includes the attribute \u201cminimize_cost.\u201d This policy includes a statement \u201cpush_mechanism.cost=0.00.\u201d The statement includes a variable, i.e., \u201cpush_mechanism.cost\u201d which indicates the cost to use the push mechanism and a value, i.e., \u201c0.00\u201d for the variable. This policy instructs the decision module to select a push mechanism where the cost for pushing a message is \u201c0.00,\u201d i.e., the mechanism is free or is without cost. Details of the push mechanism, such as any associated costs for pushing a message, may be stored in push mechanism provider details database . This policy shows an example of comparing push mechanism details with requirements specified in a policy (step , ).","A policy may include multiple expressions to be evaluated:",{"@attributes":{"id":"p-0093","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Policy 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT push_mechanism WHERE push_mechanism.cost = 0.00"]},{"entry":[{},"AND push_mechanism.status = \u201cactive\u201d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In the example above, \u201cpolicy \u201d includes a first expression, i.e., \u201cpush_mechanism.cost=0.00\u201d and a second expression, i.e., \u201cpush_mechanism.status=\u2018active.\u2019\u201d This policy instructs the decision module to select a push mechanism where both expressions evaluate to \u201ctrue,\u201d i.e., the cost for pushing a message is \u201c0.00\u201d and the current status of the push mechanism is \u201cactive.\u201d The current status of the push mechanism may be obtained from push mechanism current status reporting unit  ().","In another specific implementation, a push mechanism may be selected even if the current status of the push mechanism is not operating, inactive, non-active, or down. For example:",{"@attributes":{"id":"p-0096","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Policy 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT push_mechanism WHERE push_mechanism.cost = 0.00"},{"entry":"IF (push_mechanism.status = \u201cactive\u201d AND push_mechanism.cost ="},{"entry":"0.00) = FALSE, THEN WAIT"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"This example of a policy may result in the selection of a push mechanism even if the push mechanism is currently down, as long as there is no cost to push the message, i.e., the push mechanism is free. In this specific implementation, if there is no free mechanism available the system waits for a free mechanism to become available and then transmits the message to be pushed to the free mechanism. For example, if there is no free mechanism available, the system may place the message in a queue and upon determining that a free mechanism is available, the system can remove the message from the queue and transmit the message to the available free mechanism. Such a policy may be used in cases where the delivery profile indicates that the message to be pushed is non-critical and that a free push mechanism should be used. In a specific implementation, the system waits indefinitely for a free mechanism to become available. In another specific implementation, the system waits for a specified period of time for a free mechanism to become available. If the time expires and a free mechanism is still not available, the system may select a mechanism that charges for pushes or the system may return a notification to the originating application server indicating that the push has failed because there are no free mechanisms available.",{"@attributes":{"id":"p-0098","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Policy 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT push_mechanism WHERE push_mechanism.cost <="]},{"entry":[{},"delivery_profile.maxium_cost"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In the example above, \u201cpolicy \u201d includes the variable \u201cdelivery_profile.maxium_cost\u201d where the value may be specified in the delivery profile. This value indicates the cost that the application server is willing to pay to have the message pushed to the client device. This policy instructs the decision module to select a push mechanism where the cost for pushing the message is less than or equal to the maximum cost as specified in the delivery profile.",{"@attributes":{"id":"p-0100","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Policy 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT push_mechanism WHERE push_mechanism.reliability ="},{"entry":"\u201cexcellent\u201d"},{"entry":"IF push=fail THEN WAIT 1 minute AND RETRY push_mechanism"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In the example above, \u201cpolicy \u201d includes the variable \u201cpush_mechanism.reliability\u201d which indicates the required reliability of the push mechanism. As shown in the policy example, the push mechanism should have a reliability rating of \u201cexcellent\u201d as provided in push mechanism performance history database  (). The policy further includes a conditional statement indicating that if the push fails, the system should wait a period of time (e.g., 1 minute) and after the period of time has elapsed, send another request to the same push mechanism for the push mechanism to retry the push. This policy shows an example of reviewing push mechanism performance history (step , ).","In a specific implementation, push service system  implements a more complex retry, such as an exponential back-off, which may or may not be specified in the policy. Further details of the exponential back-off are provided later in this application.",{"@attributes":{"id":"p-0103","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Policy 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT first_push_mechanism WHERE"]},{"entry":[{},"first_push_mechanism.reliability = \u201cexcellent\u201d"]},{"entry":[{},"IF push = fail THEN SELECT second_push_mechanism WHERE"]},{"entry":[{},"second_push_mechanism.reliability = \u201cexcellent\u201d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In the example above, \u201cpolicy \u201d is similar to \u201cpolicy .\u201d However, \u201cpolicy \u201d includes a different conditional statement for a failed push. The conditional statement indicates that if the push fails, the system should select a different push mechanism (i.e., a second push mechanism) which also has a reliability rating of \u201cexcellent\u201d to attempt the push to the client device. Policies  and  are examples of a policy that may be selected where the delivery profile includes the attribute \u201cmaximize_reliability.\u201d",{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Policy 7"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"SELECT push_mechanism WHERE push_mechanism.latency = \u201clowest\u201d"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In the example above, \u201cpolicy \u201d specifies that the push mechanism having the \u201clowest\u201d latency should be selected. The decision module can compare latency times associated with each of the push mechanisms and select that push mechanism having the lowest latency time to push the message. \u201cPolicy \u201d is an example of a policy that may be selected where the delivery profile includes the attribute \u201cminimize_latency.\u201d",{"@attributes":{"id":"p-0107","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Policy 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SELECT first_push_mechanism WHERE"]},{"entry":[{},"first_push_mechanism.reliability = \u201cexcellent\u201d"]},{"entry":[{},"AND SELECT second_push_mechanism WHERE"]},{"entry":[{},"second_push_mechanism.reliability = \u201cexcellent\u201d"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In the example above, \u201cpolicy \u201d specifies that more than one push mechanism (e.g., two push mechanisms) should be selected to push the message to the client device. This is an example of parallel delivery. That is, in this specific implementation, the push service chooses a plurality of delivery mechanisms (i.e., two or more mechanisms). \u201cPolicy \u201d is an example of a policy that may be selected where the delivery profile includes the attribute \u201ccritical.\u201d","As an example, there may be a critical security update that the application server should provide to the application on the client. As another example, the client (e.g., smartphone) may have been stolen by a thief or misplaced by the user and the application server needs to instruct a security application on the client to delete or wipe out all data on the client, sound an alarm, transmit location information, lock the smartphone, or combinations of these. Details of such a security application are described in U.S. patent application Ser. No. 12\/372,719, filed Feb. 17, 2009, which is hereby incorporated in full by this reference along with all other references cited herein. As another example, an application server associated with a financial application on the client may have a very important update or alert for the user, such as information on a margin call.","Having multiple push mechanisms attempt to push the message to the client helps to ensure that the client receives at least one of the pushes. For example, if one of the first or second push mechanisms fails to push the message then another of the first or second push mechanisms may be able to push the message. In other words, while one push mechanism may fail, it is less likely that both push mechanisms will fail.","In a specific implementation of multiple push mechanisms (or push service mechanisms) in parallel, a method includes selecting first and second push mechanisms to push a message to a client and delivering the message send request to the first and second push mechanisms. The message send request may be delivered to the second push mechanism before a response is received from the first push mechanism. The message send request may be delivered to the second push mechanism before or after a push pending response is received from the first push mechanism. If, for example, the push service system receives an indication of a successful push by one of the first or second push mechanisms, the push service system may cancel, abort, or otherwise stop the other of the first or second push mechanisms (or any other remaining chosen mechanism) from pushing the message to the client. This helps to ensure that the client does not receive multiple push messages and can help to reduce network traffic.",{"@attributes":{"id":"p-0112","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Policy 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"IF CUSTOMER_TYPE = \u201cpaying\u201d THEN SELECT push_mechanism"},{"entry":"WHERE push_mechanism.reliability = \u201cexcellent\u201d"},{"entry":"ELSE IF CUSTOMER_TYPE = \u201cnon-paying\u201d THEN SELECT"},{"entry":"push_mechanism WHERE push_mechanism.reliabilty ="},{"entry":"\u201cgood\u201d AND push_mechanism.cost = \u201c0.00\u201d"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"\u201cPolicy \u201d above shows an example of differing levels of service being provided based on whether the customer (e.g., user of the client device) is a paying customer or a non-paying customer. In this example, a paying customer of an application program receives preferential service by the push service system selecting a push mechanism having a reliability of \u201cexcellent.\u201d Using such a push mechanism may result in a charge for the push by the selected push mechanism. The charge may be assessed against the push service system which may pass the charge along to the application provider. If the customer is a non-paying customer the push service system selects a push mechanism that has a somewhat less desirable reliability rating, but where the cost for using the push mechanism is without charge.","A policy may include simple rules for selecting a push mechanism based upon a single criteria such as the cost to push a message. Alternatively, there can be more powerful policies having multiple criteria for the decision module to consider, decision trees having multiple paths (e.g., \u201cyes\u201d and \u201cno\u201d paths), multiple decisions, multiple loops, complex conditional statements, nested statements, various lookups, and so forth. When there are multiple criteria, requirements, attributes, or factors to consider, such elements may be weighted according to a weighting algorithm or formula.","For example, a first push mechanism may be associated with a first attribute specifying a success rate of the first push mechanism, and a second attribute specifying a latency of the first push mechanism. A second push mechanism may be associated with a third attribute specifying a success rate of the second push mechanism, and a fourth attribute specifying a latency of the second push mechanism. In this specific implementation, the decision module uses the weighting algorithm to weight the first, second, third, and fourth attributes based on, for example, information in the message send request delivery profile. If the profile information indicates that success rate has a higher priority or is more important than latency, then the first and third attributes that specify success rates may be weighted more heavily than the second and fourth attributes that specify latency. Thus, in some cases, the first push mechanism is selected. In other cases, the second push mechanism is selected.","A policy may include a reference to another policy. A policy may also include a retry strategy. Alternatively, a retry strategy may be specified in the delivery profile. A retry strategy can specify the procedures or actions to be performed when a chosen push mechanism fails to push the message to the client device. For example, the retry strategy can specify criteria for selecting a next push mechanism such as the reliability rating for the next push mechanism, whether multiple push mechanisms should be selected for parallel pushes, timing requirements, and so forth. Specifying the retry strategy in the policy removes the responsibility from the application developer of having to detail the actions to be performed if a push fails. Some developers, however, may desire to have more control over the actions. So, a feature of the push service system is its flexibility in allowing the retry strategy to be specified by the application developer in the send request delivery profile.","It should be appreciated that an implementation of the push service system allows for retry strategies to be specified in both delivery profiles and policies. Thus, application developers who desire more control may specify the retry strategy in the delivery profile. Other application developers may desire to offload the implementation details by relying on a retry strategy as specified in the policy. If the retry strategy is specified in both the delivery profile and policy, in a specific implementation, the push service system defers to the application developer by defaulting to using the retry strategy as specified in the delivery profile. That is, the delivery profile retry strategy overrides the policy retry strategy. In another specific message send request implementation, the policy retry strategy overrides the delivery profile retry strategy.","Referring now to , after the decision module selects one or more push mechanisms based on the message send request delivery profile and policy, in a step  the decision module forwards the decision to routing module  (). In a step , the routing module packages and delivers or transmits the message to be pushed to the selected push mechanism. In a specific implementation, delivery work is done as a job. Each push mechanism may have different requirements or protocols for what a request to push a message must include. In other words, different push mechanisms may have different contact information (e.g., phone number for SMS versus push token for a service). The protocol in general will be a specific API for any provider. The routing module can package the push message as appropriate so that the message can be properly received by the push mechanism.","As a specific example, if the delivery profile indicates that the message should be encrypted, the routing module can encrypt the message before delivering the message to the selected push mechanism. That is, the message may be in an unencrypted format and the routing module can encrypt the message into an encrypted format.","In a step , tracking module  () tracks, monitors, and reports on the status of the delivery. If there is an indication of a failed push, in some cases the system may request that the previously selected push mechanism retry the push, select another push mechanism by repeating the push mechanism selection process (as indicated by line ), or both.","More particularly,  shows an overall flow  for scheduling and tracking push message deliveries. In step , as described in the discussion accompanying , the routing module delivers the message to be pushed to the selected push mechanism. In a step , the tracking module determines whether a response has been received from the push mechanism regarding the delivery. If a response has been received, in a step , the tracking module determines whether the response indicates a failed push or a pending push.","If the response indicates a failed push, in a step , the tracking module marks or records the push as failed. For example, an entry may be made in push mechanism performance history database  (), an update may be made in a delivery tracking table indicating that the push failed, or both. If a push fails, the system may request that the selected push mechanism retry the push to the client (step ), select a different push mechanism to push the message to the client (step ), or terminate or end the process (step ). In a specific implementation, if the push service receives an immediate failure result, the push service may either retry that mechanism after a period of time or try a next mechanism. Instructions as to whether the push service should retry the same mechanism or a different mechanism may be specified in a policy. The criteria for determining whether to use the same mechanism or a different mechanism may be based on the mechanism behavior or type of failure. For example, if there is an indication that the failure was critical or that the mechanism will be permanently inactive or inactive for a long period of time (e.g., several hours), a different mechanism may be used. If a given mechanism fails, the system may immediately perform the next step unless there is a timeout required (e.g., delay between retries).","The delay between retries may be about 10 seconds, but can range from about 3 seconds to about 30 seconds. This includes, for example, about 5, 10, 15, 20, 25, 29.9 seconds, or more than 30 seconds. The period of time may be less than 3 seconds. Having a delay between retries can help to prevent overloading of the push mechanism. The buffer of a push mechanism may have been filled with other push requests so waiting for a brief period of time before retrying the mechanism can provide some time for the buffer to clear, empty (or at least partially empty). Further, a particular provider may require a retry policy like exponential backoff; this is in part to avoid overwhelming the mechanism provider if it is having problems. The delay between retries may be specified in the message send request delivery profile or pre-determined by the system such as specified in a policy. Alternatively, upon receiving an immediate failure result, the push service system may immediately retry the push mechanism without waiting for a brief period of time.","In a specific implementation, a message send request delivery profile specifies a retry timeout that is an exponential backoff. The exponential backoff may indicate that progressively longer timeouts or delays between retries should be used. For example, the delay between first and second retries may be about 0.5 seconds, but the delay between second and third retries may be about 1 second, the delay between third and fourth retries about 2 seconds, the delay between fourth and fifth retries about 5 seconds, and so forth.","As shown in step , after determining that a push via a selected push mechanism has failed, the system may instead select a different push mechanism from among the set of push mechanism to push the message to the client device. The selection process of a different push mechanism may be similar to step  as shown in  and described in the discussion accompanying .","Retrying the push via the same push mechanism or selecting a different push mechanism to push provides a fallback strategy or plan to help ensure that a message is pushed to a client device. This can be beneficial in cases where the delivery profile indicates that the message is critical. Rather than relying on a single push mechanism to push the message, this feature allows for one or more backup push mechanisms to be selected. Thus, even if the single push mechanism is down, a critical message may still be able to be pushed to a device using a different push mechanism. This process of selecting the push mechanisms can occur automatically or without any intervention from the originating application server. For example, the application server can simply indicate that the message to be pushed is critical and the push service system will handle the routing to the appropriate push mechanism (or mechanisms) and any push failures. The push service system can implement the procedures and backup procedures, if needed, to help ensure that the message is pushed to the client.","Referring now to step , there can be several techniques for determining that a push has failed or that the selected push mechanism is unable to push the message to the mobile client device. As discussed above, one technique is the system having received an immediate failure result from the selected mechanism. Another technique for determining that a push has failed includes determining that the system has not received a response within a specified timeout period. For example, there may be a case where the system expects to receive a \u201csuccess\u201d notification. If the \u201csuccess\u201d notification is not received after a period of time (i.e., the system fails to receive a successful push notification from the selected push service during the time period), the system may move on to the next push mechanism () or retry the push attempt with the same mechanism (). In a specific implementation, if no response is received and the scheduled timeout job runs on the push service, the push service either schedules the next step, or marks the message as failed if there are no next steps.","The timeout period is a pre-determined time period that provides a trigger for other activities to occur in the event that the system does not receive a response. In this specific implementation, upon delivering the push message to the push mechanism, the system sets a timer or clock. If the system does not receive a response within the pre-determined time period, i.e., the pre-determined time period lapses or expires without a response being received, the system determines that the push has failed. The time period may be user-configurable such as by an administrator.","The length of time or duration of the timeout period may vary based on factors such the as the delivery profile, policy information, client device information, carrier or network operator, network type, or combinations of these. The timeout period may be about 5 minutes, but can range from about 1 minute to about 30 minutes. This includes, for example, about 10, 15, 20, 25, 29.9 minutes, or more than 30 minutes. The timeout period may be less than 1 minute. The timeout period can act as a safeguard against delivery failures. For example, if the delivery profile accompanying the push request from the application server indicates that the push request is critical or urgent, there may be a short timeout period as compared to a delivery profile indicating that the push request is non-critical. This allows the system to quickly determine that a push has failed so that the system can move forward with any other contingency plans to contact the client device. As another example, some networks may be faster than other networks. For example, 4G networks are generally considered to be faster than 3G networks. Thus, the timeout period may be longer for a 3G network than a 4G network in order to provide additional time for the push to travel through the 3G network.","Referring now to step , the push service system may instead receive an indication that the push message delivered to the push mechanism is pending. In a specific implementation, if a given mechanism accepts a message for delivery, the system schedules a job in the future so that the system can time out if the delivery takes too long. In a specific implementation, the system counts forward, similar to a stopwatch, from when the push message is delivered to the push mechanism to determine when the timeout period expires. In another specific implementation, the system counts backwards, similar to a countdown timer, starting at the end of the timeout period to determine when the timeout period expires.","In a step , the push service system schedules a first job to be executed upon expiration of a time period. That is, the job is to be performed at some time in the future to handle the case where the message is not delivered or pushed in the period of time. If the time period expires or lapses without any status update being received on the push (step ), the system in a step  executes or performs the scheduled first job. Performing the job may include marking the push as failed, requesting that push mechanism retry the push, or selecting a different push mechanism to perform the push.","Alternatively, in a step , before the time period expires, the tracking module may receive a status update on the push. The push status update may be received from the push mechanism. Alternatively, the push status update may be received from the application server that either initiated the message send request, or is related to the application server that initiated the message send request. For example, upon a successful push to the client, the client may connect to the application server, and the application server may then notify the push service system.","Having received the status update, in a step , the system invalidates the first job. Based on the status update, the system may mark the message as successful or delivered, mark the message as failed, request that the push mechanism retry the push, select a different push mechanism to attempt the push, or end the process. Specifically, if the status update indicates that the push has been successful, the system may end or abort the process. The process may also be ended if the status update indicates the push failed. Aborting the process can prevent any pushing of the message by the remaining chosen push delivery mechanisms.","If the push has failed, rather than ending the process, the system may instead request that the push mechanism retry the push, or select a different push mechanism to attempt the push. For example, in a specific implementation, based on a status update of a failed push, in a step , the system re-delivers the message to a push mechanism so that another attempt can be made to push the message to the client. The push mechanism may be the same push mechanism that was originally or initially selected or the push mechanism may be a different push mechanism. In a step , a second job is scheduled to be performed upon expiration of a time period. As discussed above, scheduling the job allows the system to time out if delivery takes too long. Steps  and  are shown in broken lines to indicate that these steps are optional. For example, these steps may not be performed if, for example, the status update indicates a successful push of the message to the client.","In other words, if the system receives status either from the push mechanism or from the application server before the timeout, the system may either cancel the first job or take steps to make sure that when the first job runs, it does not do anything. Cancelling a job can be expensive depending on the job queuing system so it may be preferable to let the timeout job run but detect that there is nothing to do. For example, it may take longer to search for the job in a queue and remove it than to mark metadata that the job will refer to when executed.","In a specific implementation, the system sets information on a message request for the push service to determine which timeout jobs are valid. If the push service tries to send a command via mechanism A, scheduling a timeout job for that mechanism, but before the timeout is reached the mechanism sends a status update to the push service indicating that the message cannot be delivered, the push service may then send a message using mechanism B, scheduling a timeout job for mechanism B. In this case, mechanism A's timeout job is still scheduled. If it is infeasible to remove the scheduled job for mechanism A, it is possible to leave it scheduled, but set data on the message indicating what timeout jobs are currently valid so that the timeout for mechanism A is ignored, but the timeout for mechanism B is accepted. The information could include a time of the next expected timeout (any timeout jobs that occur before that time are ignored). Alternatively, the system can queue each timeout job with an identifier and store a list of valid timeout identifiers on the message request, so that the system can simply modify the list of valid timeouts for a given request.","Thus, in a specific implementation, invalidating the job (step ) includes canceling the job. In another specific implementation, a different technique is used to invalidate the job. In this specific implementation, a method includes delivering a message to a first push mechanism for the first push mechanism to push the message to a client. Scheduling a first timeout job associated with the message, where the first timeout job is to be performed upon expiration of a first time period. Before the expiration of the first time period, receiving a status update of a failed push from the first push mechanism. Delivering the message to a second push mechanism for the second push mechanism to push the message to the client. Scheduling a second timeout job associated with the message, where the second timeout job is to be performed upon expiration of a second time period.","In this specific implementation, a technique to invalidate the first timeout job includes marking metadata associated with the message to indicate that the second timeout job is valid. The method may further include marking the metadata to indicate that the first timeout job is invalid. In another specific implementation, the first timeout job is associated with a first identifier. The second timeout job is associated with a second identifier. In this specific implementation, a method to invalidate the first timeout job includes storing a list of valid timeout identifiers associated with the message. The list of valid timeout identifiers includes the second identifier associated with the second timeout job. The first identifier associated with the first timeout job is omitted from the list of valid timeout identifiers.",{"@attributes":{"id":"p-0139","num":"0138"},"figref":["FIGS. 9-11","FIG. 9","FIG. 10","FIG. 11"],"b":["905","1005","1105"]},"Referring to , in a step , the tracking module receives feedback on the push from the push mechanism. In a step , the push service system updates the message state. The system may change the message state from a first state to a second state, different from the first state. For example, the first state may indicate that the message has been delivered to the push mechanism. The second state may indicate that the push mechanism has pushed the message to the client or that the push mechanism has failed to push the message to the client.","In a step , the system informs the application server of the updated message state. The system may send a notification to the application server. The notification may be an e-mail, text message, or any suitable notification. Notifications may be implemented as callbacks via registered handlers, such as an HTTP callback. In a step , based on the message status, the push service system may re-deliver the message such as in the case where the message push has failed. Alternatively, the push service system may stop scheduled jobs to re-deliver message such as in the case where the message push as succeeded.","It should be appreciated that the originating application server may query the push service system at any time for status updates. A feature of the system provides a level of fault tolerance to the application server. The push service system can notify if there are terminal errors preventing the message from being sent, and optionally on each step of the process. The system can re-deliver or retry if individual requests fail with no intervention from server. While the message delivery is in progress, the originating server can query the push service for the current status; or it may wait for a callback response from the push service.","Specifically, asynchronously, the push service can receive a response from the mechanism that specifies delivery status, e.g., specifies a successful push to the client. The application server may have confirmation of message delivery (e.g., the message is an indication for the client device to connect to the application server) and perform an HTTP callback informing the push service that the message has been delivered. In this case, the push service marks the message as delivered. The push service system may receive delivery confirmation from the application server. After receiving a message, the client device may contact the application server directly. At this point, the application server can notify the push service to provide confirmation of message delivery, thereby stopping further attempts to retry delivering the message or delivering the message via other mechanisms.",{"@attributes":{"id":"p-0144","num":"0143"},"figref":["FIG. 10","FIG. 9","FIG. 10"],"b":["1010","1015","1020"]},{"@attributes":{"id":"p-0145","num":"0144"},"figref":["FIG. 11","FIGS. 9-10","FIG. 11"],"b":["1110","1115","1120","1125"]},{"@attributes":{"id":"p-0146","num":"0145"},"figref":"FIG. 12","b":["310","1210","1215","1210","1220"]},"One benefit is that if the persistent push mechanism uses encryption, the push service system can cache transport layer security (TLS) parameters per-device to avoid having to re-negotiate them when a device temporarily disconnects. Another benefit is the ability to automatically tune network parameters, such as keep-alive parameters, based on network information the persistent push mechanism determines about a given device or information provided by the device. For example, different network operators may have different optimal network configurations because of different firewall settings, proxy settings, and so forth. In a specific implementation, the persistent push mechanism is referred to as the Lookout Cloudpush as provided by Lookout, Inc. of San Francisco, Calif.","If a push mechanism has the ability to determine presence, the push service system may request device presence before delivering the message to be pushed. A flow for interacting with a persistent push mechanism may be as follows:","Step 1 (A): Receive push request from application server .","Step 2 (B): Request presence information regarding the client device from the persistent push mechanism.","Step 3 (C): Receive presence information response from the persistent push mechanism.","In a specific implementation, if a persistent push mechanism is available and the client device is \u201cpresent\u201d the push service system selects the persistent push mechanism to push the message. However, this is not necessarily always the case. For example, there may be a cost to use the persistent push mechanism. Thus, if the push request delivery profile indicates that a free push mechanism should be used, the push service system will not select such a persistent push mechanism.","This disclosure contemplates several embodiments of the push service system. In a first embodiment, the push mechanisms are external to the push service system. In a second embodiment, at least one of the push mechanisms is internal to or integrated with the push service system. In a specific implementation, the at least one push mechanism is a persistent push mechanism and may be referred to as the Lookout Cloudpush.",{"@attributes":{"id":"p-0154","num":"0153"},"figref":"FIG. 13"},"As shown in , an environment  includes a first application server , a second application server , push service system , push mechanism providers , and a client . The client includes a first application program  and a second application program . The first application program is associated with the first application server. The first application program and server may be referred to a consumer of location-based information. For example, the first application program may be a credit card application program and the first application server may facilitate the processing of credit card transactions by the credit card application program. As shown in , a push service system may include several modules and data stores. For ease of explanation, such components are not shown in the example of .","The second application program is associated with the second application server. The second application program and server may be referred to as a provider of location-based information. For example, the second application program may include client device locating services, e.g., Global Positioning System (GPS) related services and the second application server may facilitate such location-determining services. A specific example of such an application program and server is described in U.S. patent application Ser. No. 12\/372,719, filed Feb. 17, 2009, which is incorporated by reference. A flow may be as follows:","Step 1 (A): The first application program on the client is used to make a purchase and the first application program sends a request to the first application server to verify the location of the client in order to authorize the purchase.","Step 2 (B): The push service system receives a request from the first application server for assistance in determining the location of the client.","Step 3 (C): The push service system selects a push mechanism provider and transmits a message to be pushed by the selected push mechanism provider to the client (or second application program on the client) instructing the client to connect to the second application server.","Step 4 (D): The push mechanism pushes the message to the client.","Step 5 (E): The client receives the message and connects to the second application server as instructed in the message. Upon connection, the second application server instructs the client via the second application program to determine its location and transmit the location to the second application server. The second application program receives the client location information.","Step 6 (F): The second application server transmits the client location information to the first application server which, based on the location information, determines whether or not the purchase should be authorized.","In specific embodiments, there is an application programming interface (API) that is provided. The API is referred to as a push messaging API. The Push Service exposes a messaging API to be used by one or more servers. The API provides an id that uniquely identifies a message from a server to a specific device; this unique ID is generated when the message is posted to the push service and returned to the server.","The push service may collapse a new request into an existing message in flight if it is directed from the same server to the same device with a service requirement that will be covered by the existing message. This allows the server to queue multiple messages with different service requirement profiles, letting the push service handle the logic to determine how to deliver them or to not deliver a given message to avoid sending too many messages to a given device. The server can make queries to the push service about a message by unique ID. For example, the application server may have a low-priority message to deliver, and may separately decide to send a high-priority message while the first is in transit.","Thus, in a specific implementation, a method includes receiving, by the push service system, a new push request including both a message to be pushed to a client device and prioritization criteria, determining by the system whether the new received push request matches any pending push requests having the same requester, the same mobile device and whether the prioritization criteria of the new received push request is met by the prioritization criteria of the pending push request, selecting by the system to combine the new received push request with the matching pending push request, and delivering by the system the message from the new received push request to be combined with the message from the matching pending push request to a delivery mechanism for an attempt at pushing the messages to the client device.","In a specific implementation, the API is REST-ful and may include one or more of: (1) creating a new message with specified destination device and service profile, (2) reading the status of an existing message, (3) updating a message to provide additional information, such as round trip delivery feedback, (4) deleting a message to cancel delivery. The push service can also provide status notifications. For example, the server can provide contact information to receive callbacks from push service. Callbacks may be made when the message reaches a terminal state (either success or failure).","Referring now to , in some cases, a client device may only support a single push mechanism. Below is an example flow of an application server sending to one mechanism:","(1) Application server posts a message send request to the push service asking for a message to be delivered to a device which supports only a single mechanism (e.g., iPhone via cloudpush).","(2) The push service returns a response to the server indicating an identifier for the message.","(3) The push service transmits the message to the supported mechanism.","(4) If the mechanism returns status immediately, update the message state to failed (with any details attached) and perform an HTTP callback to inform the server.","(5) If the mechanism responds asynchronously with status, update the message state and perform an HTTP callback to the server.","(6) If the mechanism does not respond with status but can be queried, poll the mechanism provider at a later point in time and perform an HTTP callback to the server if there is a state change.","(7) After successful round trip delivery and connection of the device to the server, the server may perform an HTTP callback to the push service to confirm delivery.","Alternatively, in other cases, a client device supports multiple mechanisms. Below is an example of an application server sending to multiple mechanisms:","(1) Server posts a message send request via HTTP to the push service asking for a message to be delivered to a device which supports more than one mechanism (e.g., an Android device supporting C2DM and SMS). The message send request specifies a reliable least-cost delivery profile.","(2) The push service returns a response to the server indicating an identifier for the message.","(3) The push service chooses the least expensive mechanism for initial delivery.","(4) The push service transmits the message to the chosen mechanism.","(5) If the mechanism responds with failure (synchronously or asynchronously), choose the next possible mechanism for delivery; return to step (4).","(6) If the mechanism does not respond within the required time window, choose the next possible mechanism for delivery; return to step (4).","(7) After each response from a mechanism, optionally perform an HTTP callback to the server to provide an update.","(8) If the message is confirmed to be delivered (e.g., if the mechanism supports this or the server receives a notification from the device), move message to a terminal success state and do not continue trying to send.","In the description above and throughout, numerous specific details are set forth in order to provide a thorough understanding of the disclosure. It will be evident, however, to one of ordinary skill in the art, that the disclosure may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form to facilitate explanation. The description of the preferred an embodiment is not intended to limit the scope of the claims appended hereto. Further, in the methods disclosed herein, various steps are disclosed illustrating some of the functions of the disclosure. One will appreciate that these steps are merely exemplary and are not meant to be limiting in any way. Other steps and functions may be contemplated without departing from this disclosure."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":["This disclosure is illustrated by way of example and not limitation in the figures of the accompanying drawings, in which like references indicate similar elements, and in which:",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
