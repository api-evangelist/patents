---
title: Method and apparatus for breaking down computing tasks across a network of heterogeneous computer for parallel execution by utilizing autonomous mobile agents
abstract: A method and apparatus is provided for breaking down computing tasks within a larger application and distributing such tasks across a network of heterogeneous computers for simultaneous execution. The heterogeneous computers may be connected across a wide or local area network. The invention supports mobile agents that are self-migrating and can transport state information and stack trace information as they move from one host to another, continuing execution where the mobile agents may have left off. The invention includes a server component for providing an execution environment for the agents, in addition to sub-components which handle real-time collaboration between the mobile agents as well as facilities monitoring during execution. Additional components provide realistic thread migration for the mobile agents. Real-time stack trace information is stored as the computing tasks are executed, and if over-utilization of the computing host occurs, execution of the computing task can be halted and the computing task can be transferred to another computing hosts where execution can be seamlessly resumed using the stored, real-time state information and stack trace information.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07082604&OS=07082604&RS=07082604
owner: Mobile Agent Technologies, Incorporated
number: 07082604
owner_city: Delray Beach
owner_country: US
publication_date: 20010420
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","OBJECTS AND SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["1. Field of the Invention","The present invention relates to a method and apparatus for providing parallel execution of computing tasks in heterogeneous computing environments using autonomous mobile agents. More specifically, the invention allows a multitude of computing tasks to be broken down into smaller tasks, distributed across a variety of nodes, and computed in parallel by such nodes. Computing tasks can be distributed to a plurality of nodes by self-migrating, autonomous mobile agents that are capable of carrying state information from one host to another host. Execution of computing tasks can be interrupted at a first host and transferred to a second host, where execution can then be seamlessly completed. The invention provides a means for collaborating the agents in real time, facility monitoring means for the agents, debugging means for allowing realistic thread migration of the agents, and dispatching means capable of breaking down given computing tasks into smaller tasks to be executed by a plurality of agents simultaneously executed across heterogenous, networked computing environments.","2. Related Art","Since the dawn of the computer age, scientists, academic researchers, engineers and programmers have attempted to design, develop, and refine systems to provide increasingly optimized uses of available computing resources. While attempting to achieve these goals, such efforts have sought to continually lower the overall cost of each mathematical or logical instruction executed within a program. Ultimately, these endeavors sought to create a computer program and\/or system that was more reliable and less subject to network failures.","In the 1970's, remote procedure calls gained acceptance in the IBM mainframe environment. This was the result of improved communications technologies and protocols that enabled a secondary computer system to invoke a program written and executed on an IBM mainframe host, and to return the results of computation to the secondary computer.","In the late 1980's, the concept of client\/server computing gained popularity, and in a broad sense, supported the notion of remote programming. This technique, whereby a set of instructions could be passed to a server for execution thereon, created a new architecture based upon a two tier computing model. One example of this is a Structured Query Language (\u201cSQL\u201d) statement that can be created on one computer and then executed by a remote server. Typically, the SQL code is created via a graphical user interface located at the client.","In the 1990's, a major shift in programming paradigms occurred. The structure of computer programs began to move from the traditional procedural model to object-oriented models. Additionally, there was a renewed vigor to develop distributed computing technologies that would allow computer programs to be broken up and executed across two or more machines connected via a network.","Companies such as Microsoft, Sun Microsystems, and Visigenics have produced products, language facilities, and operating system enhancements that allow an object residing on one machine on a computer network to remotely call the methods within another object located on a second computer system. Microsoft's technology, Distributed Component Object Model (\u201cDCOM\u201d), was originally proprietary and could only be used within the Windows\u00ae environment. Sun Microsystems created two new programming API's for its Java\u00ae programming language, namely Remote Method Invocation (\u201cRMI\u201d) and Enterprise Java Beans (\u201cEJB\u201d). Visigenic implemented specifications set forth by the Object Management Group (\u201cOMG\u201d) to provide a distributed computing technology called Common Object Request Broker Architecture (\u201cCORBA\u201d).","All of the above technologies required remote objects to be installed on the computer systems where such technologies were to be run. Additionally, variation of client-side stubs and server-side skeletons was required to effectuate the marshalling and unmarshalling of returned data and parameter values. Accordingly, the limitations and shortcomings inherent in the above technologies have precipitated the need to create object-oriented software programs that can transport themselves from one machine to another without requiring a user to install software on the remote computers and without requiring any modification of virtual machines residing thereon. Further, the need arises for such programs to traverse a heterogeneous network of computing devices that may be connected via potentially unreliable communication channels.","To date, organizations undertaking the monumental challenge of developing and introducing mobile agent technologies to address the above needs have achieved very limited success. This is due to both the radical shift in computing paradigms inherent in distributed computing and a lack of viable architectural designs and methodologies. Some of the more notable projects in the academic realm pertaining to mobile agent technologies include \u201cAgent TCL\u201d developed at Dartmouth and Tacoma developed at Cornell University. In the corporate realm there are such products as IBM's Aglet workbench, Mitsubishi's Concordia, and General Magic's Telescript\/Oddessy. As noted earlier, however, such products fail to address the need to provide easily transportable mobile agents that function efficiently in heterogeneous computing environments.","An additional need exists in the mobile agent technology realm; namely, the need to provide mobile agents that support real-time thread migration. Prior to the present invention only mobile agent systems written in languages other than Java, such as TCL or Telescript, could support thread migration. In the late 1990's, thread migration using the Java programming language could be achieved only by modifying the virtual machine itself, which severely reduced the attractiveness of a mobile agent product by requiring a proprietary Java virtual machine. The present invention, by contrast, provides realistic thread migration using a standard, off-the-shelf Java Virtual machine, without requiring the modification of the virtual machine or the creation of a proprietary virtual machine.","None of the previous efforts of others, either alone or in combination, disclose or teach the benefits of the method and apparatus of the present invention for providing parallel execution of computing tasks in heterogeneous computing environments using autonomous mobile agents, nor do they teach or suggest all of the elements thereof.","It is a primary object of the present invention to provide for improved distributed computing over a plurality of computing systems.","It is another object of the present invention to provide for improved parallel processing of computing tasks over a variety of distributed computing systems.","It is yet another object of the present invention to provide for improved processing of computing tasks by a plurality of computing systems regardless of the underlying operating systems and hardware of such computing systems.","It is still another object of the present invention to provide an improved distributed computing system wherein computing tasks are accomplished by a plurality of virtual machines residing in nodes connected to the distributed computing system, without requiring a user to install software at the nodes or to modify the virtual machines.","It is another object of the present invention to provide a collaboration environment wherein a plurality of mobile agents can communicate with each other in real time.","It is also an object of the present invention to provide a dispatching system wherein complex computational tasks are broken down into smaller computational tasks and distributed to a plurality of computing systems using mobile agents.","It is yet another object of present invention to provide a monitoring system wherein status information corresponding to mobile agents can be recorded and monitored.","It is a further object of the present invention to provide a debugging system for a computing host wherein the execution stack for running mobile agents can be maintained, reconstructed, and traced.","It is still another object of the present invention to provide improved thread migration for mobile agents, wherein a plurality of mobile agents can be migrated from one computing system to another and withstand interrupted execution.","It is yet an additional object of the present invention to provide improved thread migration without requiring a user to install software at a plurality of computing nodes or to modify virtual machines located therein.","It is an object of the present invention to provide improved dynamic distribution of mobile agent processing code from a web server to plurality of client virtual machines so that mobile agents can be executed on clients not having mobile agent processing code.","A method and apparatus is provided for breaking down computing tasks within a larger application and distributing such tasks across a network of heterogeneous computers for simultaneous execution. The heterogeneous computers may be connected across a wide or local area network. The invention uses mobile agents that can be self-migrating and can transport real-time state information as they move from one host to another, thereby allowing for continued execution where the mobile agents may have left off. The invention includes a server component for providing an execution environment for the agents, in addition to sub-components for handling real-time collaboration between the mobile agents and providing facilities monitoring during execution. A dispatcher that facilitates the break down of a complex computational task into smaller, more optimized parts is provided. Execution code can be dynamically transferred to remote nodes so that the mobile agents can execute in virtual machines located therein, without requiring modification to the virtual machines.","Additional components provide realistic thread migration and a collaboration environment for the mobile agents. Realistic thread migration is provided through the storage and later serialization of state information and execution stack trace information prior to migration of an agent from one host to a secondary host. The state information and execution stack trace information is then utilized by the secondary host to reconstruct the agent's state of execution prior to migration to the secondary host, so that seamless execution of the agent can be achieved across more than one host.","A collaboration environment allows the mobile agents to exchange data and messages while executing. Conference rooms provide a virtual workspace for the mobile agents, and a registration subsystem selectively assigns the mobile agents to the conference rooms. The conference room monitors and moderates communication between the mobile agents, also allowing them to share results of computations.","The methodologies, software components, architecture, and flowcharts of the present invention constitute a complete system that is capable of systematic breakdown of a computationally intensive task into smaller parts for distribution across a network. In addition, the invention provides autonomous mobile agents that have the ability to migrate freely across a network of computers having a multitude of operating systems. The entire system of the present invention can be executed using a plurality of commercially-available virtual machines residing in remote computer systems, without requiring modification by the user of such virtual machines.","To assist the reader, the following glossary of terms used in this document is provided. The definitions in this glossary are not exhaustive and are not to be used to limit the scope of the present invention.","Glossary of Terms","AddObserver( ) Method: a function within the standard Java Observable class which allows for the addition of Observer objects.","Admin class: a proprietary class that contains methods to perform administrative tasks such as registering a management console.","Agent: A computer program that acts on behalf of a user or set of data or instructions provided by the user.","Autonomous Mobile Agent: An agent that is not bound to the system where it originates, and is capable of transporting itself from one machine to another machine residing on a network.","Bytecodes: A compiled version of instructions written in the Java programming language.","Class: An association of objects, data, and procedures commonly known in the object-oriented programming art.","ClassLoader: a standard Java abstract class that can be used to define policies for loading Java classes into a runtime environment.","Class Loading Mechanism: a facility that provides desired functionality for specific policies within an implementation of the ClassLoader class.","ClassNotFoundException: a standard Java exception created when a class loader is unable to load a specified class.","DefaultMutableTreeNode: a general-purpose node in a tree data structure, which may have at most one parent and zero or more children. DefaultMutableTreeNode provides operations for examining and modifying a node's parent and children, in addition to operations for examining the tree to which the node belongs. A node's tree is the set of all nodes that can be reached by starting at the node and following all possible links to parents and children. A node with no parent is the root of its tree; a node with no children is a leaf. A tree may consist of many subtrees, each node acting as the root for its own subtree.","GetResults( ): a method within an AgentMessage class that retrieves the results of an RMI method call or the results of computation returned from a remotely-executing mobile agent.","GetRunningAgentNames( ): a method within the Admin class that obtains a list of names representing agents currently running on an agent server.","GoToWork( ): a method within the Agent class that is used to launch a mobile agent.","Instantiate: The process of creating an object to be used by a program.","IOException: a standard Java exception created when a runtime error occurs during an input or output stream operation performed on a file or socket connection.","Listening Thread: A computing process that waits for one or more actions to occur in a computing environment, and alerts another process when a desired action occurs. Often used to describe a server-side component that waits for an incoming socket connection originating from a client initiating a request to submit.","LoadClass: a method within the ClassLoader class that loads a class using a policy defined within the ClassLoader class.","MalformedURLException: a Java language exception created during the instantiation of a URL object if a parameter passed to the constructor of the object does not represent a valid URL.","NotifyObservers( ): a method within the Java Observable class which notifies observers that a property of an observable object has changed.","Push stack event: a process by which the name of a method to be invoked and its associated parameters are placed on an execution stack.","Realistic Thread Migration: The process by which the current execution state of a mobile agent can be captured prior to migration of the agent across a network, and reconstructed at a remote server host when the agent has successfully relocated to the remote server host. Additionally, a process by which the simulated serialization of a thread and its movement between two distinct virtual machines, can be accomplished without modifying the runtime environment or using a programming language other than Java.","Remote Method Invocation (\u201cRMI\u201d): a process by which one program running on one machine can invoke a procedure within a program running on a secondary machine.","SetChanged( ): a method within the Java Observable class that records changes in an observable object.","Skeleton: A server-side implementation of a stub.","SocketException: a Java language exception created when a socket connection cannot be created.","Stack trace: A set of function calls and the parameters passed to them which are invoked as a computer program executes and organized in the chronological sequence in which they are called; also referred to as \u201cexecution stack trace.\u201d","State Information: Information regarding the execution status of a mobile agent.","Stub: A client-side software component, oftentimes automatically generated by a distributed computing tool, which handles the marshalling and unmarshalling of data through a socket connection when communicating to a remotely-deployed object.","Swing Components: Components within the Java programming language that allow a programmer to implement Graphical User Interface (\u201cGUI\u201d) components such as buttons, lists, menus, and text areas.","Thread: A single sequential flow of control within a computing process. The process may have multiple, concurrently executing threads.","Thread Migration: The capability of a mobile agent, in the midst of execution, to transport itself from one server node to another, and upon arrival at the secondary node, to continue executing at the point at which it left off.","Update( ): a Java language construct that denotes a named method within a class for receiving incoming events that are initiated or delivered from other components within a system.","Virtual Machine: A program that operates as a separate computing environment, may be implemented across a variety of hardware and software architectures, and is capable of executing instructions written in a programming language.","A preferred embodiment of the present invention comprises a number of agent servers interconnected via a TCP\/IP network, wherein there are two distinct types of servers. The first type is designed to be an intermediary that can participate in the actual launching or migration of agents onto other specified servers. The second type is an end node that is capable of receiving and executing agents, but is not capable of launching or migrating agents. Both servers provide an environment in which autonomous mobile agents may be independently executed.","The agent servers function as software building blocks that allow the creation of additional, highly-specific system components. An agent dispatcher subsystem that breaks down computationally intensive tasks is built upon an agent server. This subsystem is responsible for breaking down a computing task, identifying appropriate agent servers, launching the agents and processing or reassembling the intermediate results. An agent monitor, which includes a management display console, is built on top of an agent server. The display console visually depicts those machines working as agent servers within the system. Additionally, the console visually displays agents as they initialize, begin execution, run, and stop execution, in real-time. In a preferred embodiment of the invention, the console is implemented as a Java application having a user interface developed with Swing components.","Two integral subsystems of the invention that are not built into the agent server but form part of the invention are the agent collaborator and agent debugger. The agent collaborator works as a virtual meeting room in which information can be shared between all of the executing mobile agents in attendance. The agent debugger monitors the execution of all active agent processes running on a specific host. It automatically stores a complete stack trace of all executing agents in real-time. The debugger may or may not reside on the same host as the agents it monitors. The facilities available as a result of the agent debugger allow for realistic thread migration, whereby an agent can migrate from one host to another and begin execution in a new environment at virtually the same point where the agent terminated execution prior to migration.","An industry-standard component utilized by the present invention is a standard web server which utilizes the Hypertext Transfer Protocol (\u201cHTTP\u201d) to transfer data. The web server, in an embodiment of the invention, is used as a storage facility for mobile agent classes. Via a network-aware class loading mechanism, bytecodes for any mobile agent or dependent class can be downloaded to a local agent server from the closest or least-used web server. This approach significantly reduces network traffic and agent travel times, as opposed to other approaches contemplated in the art.","The present invention implements a proprietary, lightweight, and highly portable form of RMI that is used internally by the system but can also be used by those who create software programs with the present invention. The most common implementations of RMI known in the art require the creation of related classes known as \u201cstubs\u201d and \u201cskeletons.\u201d These classes, which are usually generated by an automated tool, handle low-level socket communications. Additionally, they provide for the marshalling and unmarshalling of requests made from the client to the server. The most common RMI-related implementations in the art require a universal name space, such as Java's JNDI. Importantly, the implementation of RMI achieved by the present invention does not require the creation of stubs and skeletons, nor is any type of object discovery service required.","Referring to the accompanying drawings, in which like reference numerals refer to like parts,  is a system-level diagram of the present invention. Agent dispatcher  breaks down a computationally-intensive task and then distributes it in the form of mobile agents , , , to carry out a portion of the task. A network comprising one or more routers  and a plurality of hubs  connects a plurality of computer systems and can be based upon theTCP\/IP protocol. Connected to hub  are one or more computer systems of various manufacture running different operating systems but all having a Java 1.1 or higher virtual machine installed and available.","All mobile agents run within an environment known as an \u201cagent server\u201d of which there are two types, end node  and intermediate node . An agent server, agent console, agent collaborator, and agent dispatcher can operate on any computer system  presently known in the art and capable of supporting a Java virtual machine bearing version numbers 1.1 or higher.","Built upon the agent servers are other, more complex subsystems. Agent dispatcher , described above, breaks down a computing task into smaller parts for simultaneous execution. Additionally, agent console  provides a real time management display as the agents traverse the network. Agent collaborator  provides the agents with a place to meet and exchange information, regardless of where the agent is located on the network.","Agent debugger  stores the stack traces of agents as they execute within the agent server environment. This subsystem provides a major technological advantage, namely realistic thread migration. Prior to the present invention, all Java-based mobile agent systems seeking to provide thread migration had to implement custom modifications to the virtual machine in order to do so. Significantly, the present invention provides such thread migration without requiring modifications to the underlying virtual machine.","Web server  is used to store the compiled bytecodes of the mobile agents. The agent servers make HTTP calls to the web server to download the bytecodes as necessary. Web server  transfers compiled bytecodes  to any mobile agents executing on remote systems and requiring such bytecodes for remote execution. Importantly, web server  allows compiled bytecodes  to be downloaded using a customized class loading mechanism and the industry-standard HTTP protocol.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":["FIG. 2","FIG. 3"],"i":["a ","a. "],"b":["2","42","44","46","48","18"]},{"@attributes":{"id":"p-0112","num":"0111"},"figref":["FIG. 2","FIG. 3"],"i":["b ","d. "],"b":["1","66","1","64","68","1","6"]},{"@attributes":{"id":"p-0113","num":"0112"},"figref":"FIG. 3","i":"a ","b":["18","34","36","38","78","78","80"]},"Listening threads , , ,  contain logic to receive and process either an agent message or a mobile agent instance that has migrated from a remote server. It is to be understood that additional listening threads can exist, depending upon the number of entries in a disk based properties file. Encapsulated within listening threads , , ,  are pieces of information indicating whether a mobile agent should be manufactured or a local method should be invoked. In response to the pieces of information, the server pools the listening threads. In the pool, each thread sits idle while awaiting a connection request. When the connection is accepted, a thread is removed from the waiting pool and allowed to process the request. Upon completing this task, the thread is returned to the waiting pool.",{"@attributes":{"id":"p-0115","num":"0114"},"figref":"FIG. 3","i":"b ","b":["80","80","100","98","92","96","94","96"]},{"@attributes":{"id":"p-0116","num":"0115"},"figref":"FIG. 3","i":"c ","b":["16","34","36","34","38"]},"The server core  is of the same design as an agent server. Registration subsystem  handles all of the live connections with agents, no matter where they are located within the network. Additionally, registration subsystem  also informs the agents of all active conferences occurring in real time.","Conference rooms  provide a virtual workspace in which one or more agents can collaborate and share information, including partial or complete results from computations. This component is responsible for starting, stopping, monitoring and or moderating all conference proceedings. In conference rooms , agents from any part of the system can meet in a virtual environment without ever having to physically reside on the same computer system. Instant messenger component  allows two agents to establish a private channel of communications between themselves at any point in time. This approach allows one agent to communicate with another agent located anywhere on the network. The agent being contacted has the ability to accept or decline.","Message delivery subsystem  is responsible for ensuring that all data and communications by one or more collaborating agents is both transmitted and received by the appropriate parties. Message delivery can be guaranteed if necessary. In an embodiment of the invention, a standard message queue allows all messages to be placed on the queue and then read and removed by those with the correct permission. Other guaranteed communications methodologies supported by the invention are \u201cpublish\u201d and \u201csubscribe.\u201d With this approach, one agent registers itself as a listener requesting all messages for a certain topic. Another agent can register itself as a publisher, providing content relating to one or more established topics.",{"@attributes":{"id":"p-0120","num":"0119"},"figref":["FIG. 3","FIG. 28","FIG. 29"],"i":"d ","b":["6","6","18","6","58","56","58","58","56","56"]},{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 3","i":"e ","b":["5","5","5","34","36","38","93","83","5"]},"Object manager  tracks the creation of all mobile agent objects as they are instantiated and allowed to execute within the agent server environment. Event monitor component  receives events generated by the agent server environment. The events are filtered to allow only those events denoting the preparation of a class (object creation) as well as method entry points being reached. Class prepare events are passed on to object manager , while events denoting method entry points being reached are passed to agent state machine . Agent state machine  stores stack trace information for all running agents. When a method entry point event is reached and the name of the function is migrated, then agent state machine  determines that the agent needs to be transported to another remote server, with execution continuing at the point where it left off. Upon such transfer, the running agent is frozen, such that its currently executing thread is stopped. The agent is then serialized and moved to another remote host where information stored in agent state machine  is used to reconstruct the agent's previous state, so that execution may begin at the point at which it left off.","One embodiment of the present invention allows for the development of business application programs capable of transporting themselves, during execution while maintaining state, to alternative hosts. Such programs may reside on the same sub-net or anywhere on the Internet. Transportation of the programs may be triggered by abnormally high network traffic, possible computer hardware failure, or hostile attacks by computer hackers.",{"@attributes":{"id":"p-0124","num":"0123"},"figref":"FIG. 4","b":["106","109"]},"Icon  to the left of leftmost column  in the diagram is depicted as having already been clicked by a user, so that detailed information for \u201cServers\u201d is now displayed. The second column  displays more detailed information for a specific component. It is to be understood that second column  can display, but is not limited to, information about a plurality of components of the invention, such as server names, collaboration subsystem names, topics of conversation, and active debuggers. Last column  provides the user with the most finely-grained information about a given subsystem. For example, last column  could display the names of agents running on a given server, agents being monitored by the debugger, or agents involved in a given topic of conversation. As soon as an agent listed in last column  completes execution, it is removed from last column .",{"@attributes":{"id":"p-0126","num":"0125"},"figref":"FIG. 4","i":"a ","b":["111","112","113","114","115","116","117"]},{"@attributes":{"id":"p-0127","num":"0126"},"figref":["FIG. 5","FIG. 4"],"b":["120","122","124","126","128","130","130","134","136","138","134","140","142"],"i":"a"},"Upon completion, step  invokes step , wherein the creation of a listening thread is logged. A decision is then made in step . If the number of threads created is below a threshold determined by step , step  re-invokes step , where additional listening threads are created. If the listener threshold has been met, execution is completed in step .","Importantly, the architecture of the server allows each listening thread that is spawned to share a reference to a single server socket. This allows a connection to be made from a pool of existing listeners, rather than by directly spawning a separate thread for each accepted client connection. This provides for a more stable, high-performance server, and eliminates the need for the Java virtual machine to constantly perform garbage collection on discarded connection threads. The term \u201cgarbage collection\u201d is widely known within the object-oriented programming art, and refers generally to processes invoked by a virtual machine to free memory and other computing resources that are no longer being used.",{"@attributes":{"id":"p-0130","num":"0129"},"figref":"FIG. 6","b":["148","150","152","154","156","158","160"]},{"@attributes":{"id":"p-0131","num":"0130"},"figref":"FIG. 7"},"Beginning in step , a failure is detected during the attempt to read a serialized object. If a failure is detected in step , either an IOException  or a ClassNotFoundException  is caught. A stack trace is then sent to the standard output in step . Then, the object input stream is closed in step , and in step , the socket input stream is closed.","If no exception is thrown while reading the serialized object, a decision point is reached. In step , a test is performed to see if the object is an agent message. If it is, then step  is executed, wherein the command type and status of the agent are extracted If the object is not an agent message, step  is executed. Once the command type and status of the agent are extracted in step , another decision point is reached in step , and a check is made to see if the message type is equal to \u201cRMI.\u201d If so, execution proceeds to step , where the method to invoke and method parameters are obtained from the message.",{"@attributes":{"id":"p-0134","num":"0133"},"figref":"FIG. 8","b":["186","188","190","192","194","196","202","198","204","206"]},{"@attributes":{"id":"p-0135","num":"0134"},"figref":"FIG. 9","b":["206","208","210","212","214"]},"If the class is found in step , bytecodes are loaded from the local file system in step . The class is then resolved in step . During the process of resolving a class, the Java virtual machine will ascertain all of the dependent classes for the one currently being loaded. The virtual machine will then automatically call the loadClass method within the agent class loader for all dependent classes.","If the class is not found in step , then an attempt is made in step  to establish an HTTP connection to a web server containing the mobile agent and dependent class files. In step , the connection to the remote web server is opened for reading. Step  then invokes step , whereby the bytes representing the desired class are read via an input stream. The byte array is then returned to the calling method in step , and in step , an array of bytes is converted into a Java class object. In step , the class is resolved and a reference to it is placed in the cached hash table of agents. Finally, in step  the class itself is returned to the calling method.",{"@attributes":{"id":"p-0138","num":"0137"},"figref":"FIG. 10","b":["238","240","242","244","246","250","252","254","256","252","256","258"]},"If, in step , the size of the hash table is determined to be equal to zero, then a String array with a dimension of one is created in step  and the value set to the word \u201cnone.\u201d After setting the value for this array step  then invokes step .",{"@attributes":{"id":"p-0140","num":"0139"},"figref":"FIG. 11","b":["262","264","266","260","268","261","265","263","267"]},"After the array object is created in either steps , , or , a new agent message is instantiated in step . The message object will be used to send back the result to the management console. After this action takes place, the message type is set to \u201cRMI\u201d in step , and the command is set to \u201cResponse\u201d in step . In step  a decision point is reached and a check is made to see if the first element in the array object is an exception. If so, step  invokes step , and the agent message status is set to \u201cFailure Exception.\u201d Alternatively, check is made in step  to see if the first array element is null. If the first array element is null, then execution moves on to step , where the agent message status is set to \u201cNull Exception.\u201d If the result is negative for the decisions made in steps  and , then in step , the agent message status is set to \u201cSuccess.\u201d After the agent message status is set in either steps , , or , execution continues at step , where the results data attribute within the agent message is set to the array object. Then, in step , an output stream is created from the server side socket. An object output stream is created in step , and in step , the serializable agent message is written to the object output stream.",{"@attributes":{"id":"p-0142","num":"0141"},"figref":"FIG. 12","b":["288","294","292","290","291","288","296","298","300"]},"In step , a new agent message is created which will be used to send a status response back to the remote calling process. Then, in step , the originating host value is set to the server's IP address or host name within the response. In step , the agent's formal name is set, and in step , a mobile agent factory is created. In step , the create mobile agent facility is called within the factory object passing control to that method. Step  creates a new URL object. A test is made in step  to see if a MalformedURLException was thrown. If so, in step  it is caught and a new agent exception is created and thrown. If a MalformedURLException was not thrown, processing proceeds through the steps previously described in the detailed explanation of . Upon returning, execution continues in step in , wherein an initial instance of the class is created. If the creation of the mobile agent is determined to be successful in step , then execution continues as per the sequence of events described in below and depicted in .",{"@attributes":{"id":"p-0144","num":"0143"},"figref":["FIG. 13","FIG. 14","FIG. 14"],"b":["13","326","328","330","332","334","336","338","340","14","14"],"i":["a ","a ","b "]},"Sequence in  begins in step  by catching a class not found exception. Once this occurs a new agent exception is created and thrown in step . Processing continues in step  by sending back a message to the originating host that agent creation failed.",{"@attributes":{"id":"p-0146","num":"0145"},"figref":"FIG. 14","b":["14","342","344","346","348","350","352","354","302"],"i":"a "},"Sequence , beginning in step , starts the mobile agent. In step  an event is written to the log file indicating that an agent is being started. Next, in step , the user-defined mobile agent process executes and completes. In step , the mobile agent calls the DispatchResults( ) method of its base class. It passes in as a parameter the computational results of its efforts, which are then encapsulated as an Array object. In step , the mobile agent sets the values, within its agent message attribute, of command to \u201ccomputation\u201d and status to \u201cresult.\u201d Execution then continues to step , where the mobile agent sets its runable flag to \u201cfalse.\u201d In step , an event is written into the log file indicating that the agent has successfully completed. In the next step , a new agent object is created. Its underlying message type is set to \u201cagent message\u201d and the command is set to \u201ccomputation.\u201d In step , the status of the agent is set to \u201cresults.\u201d Then, in step , the originating host value is set to either the server name or IP address on which it just executed. In step , the agent's name is set to the name of the mobile agent that just completed execution. In step , the results attribute within the DispatchResults( ) method call, implemented within the abstract ancestor of the mobile agent, is expressly set to the Array object passed in as a parameter to the method call. In step , a handle to the event monitor is obtained. Finally, in step , a new agent utilities object is created. From that point on control passes to sequence shown in .",{"@attributes":{"id":"p-0148","num":"0147"},"figref":"FIG. 15","b":["15","382","384","386","388","390","390","392","368","394","396","398","400"],"i":"a "},{"@attributes":{"id":"p-0149","num":"0148"},"figref":"FIG. 16","b":["402","404","406","408","408","416","420","422","410","412","414"]},{"@attributes":{"id":"p-0150","num":"0149"},"figref":["FIG. 17","FIG. 5"],"b":["422","424","426","428","430","432","434","438","440"]},"In step , a list of potential servers is obtained. In step , actual process tasks that need to be carried out are identified. Then, in step , the number of server tokens is counted. In step , the next available token from the list is extracted. A decision point is reached and the token, which represents a server name, is compared to a null value in step . In step , a fully qualified Java package name is created for the agent server admin class. The following step, , sets the array to be used as the agent message parameter attribute to null. In step  an RMI request is sent to the remote server to check for process availability. When this call is made, the program on the initiating server running the agent dispatcher waits until a response is sent from the remote server indicating its availability. Sequences through are then invoked, the functioning of which are described in detail below. Once the response is received from the remote server, execution continues at step  and the command value is extracted from the agent message read via the object input stream on the server running the agent dispatcher. A decision point is then reached in step , and the command value is tested to see if it equals the response. If so, step  is invoked, wherein the status of the message is acquired. In step  a test is performed to see if the status is equal to the server available. If the server is available, its name is added to the vector of operational servers in step , and then control continues at step , wherein another decision point determines whether there are more server tokens. If the server is not available, control passes to step . When no more server tokens are available, then execution continues at step , in which the sequencing of remote agents takes place. Finally, agents are launched in step .",{"@attributes":{"id":"p-0152","num":"0151"},"figref":["FIG. 18","FIG. 28"],"b":["478","480","482","484","470","486","490","28","28","488","492","486","496","498","16","16","500","482","502","504","506","498","508","486","510"],"i":["a ","a","a","a"]},{"@attributes":{"id":"p-0153","num":"0152"},"figref":"FIG. 19","b":["512","482","514","516","518","520","522","524","526","528","530","532","532","534","536"]},{"@attributes":{"id":"p-0154","num":"0153"},"figref":"FIG. 20","b":["538","160","540","542","544","546"]},"In step  the array result object is returned by calling getResults( ) with the agent message. In the next step, , the length of the array of objects comprising the result is obtained. Next, a decision point is reached in step . If the length of the array is greater than zero, execution continues at step , wherein the result is extracted from the array object. Then, in step , a decision point is reached wherein the result is checked to see if it is an instance of an exception or one of its subclasses. If the result meets these criteria, then a complete stack trace is sent to standard output in step . An event is then logged in step , indicating that the remote agent failed to complete its task and an exception was returned. In step , another mobile agent is then launched on another available server to perform the same task as the previous task which failed to complete, on another available server. If the result is not an exception, then it represents the computational outcome of the process of a remote mobile agent. Finally in step , application-specific program logic is executed based upon and utilizing the results returned from all running agents.",{"@attributes":{"id":"p-0156","num":"0155"},"figref":"FIG. 21","b":["564","568","566","570","572","576","578","580"]},"After all of the above tasks have taken place, in step , the internal tree model data member within the console controller is set to the console model created in step . Then, the console controller is added as a listener to events propagated by the console model in step . Execution continues in step , where an agent server is created and started. In step , a desktop pane is created. In step  the pane is set to be layered. After these tasks are completed a reference to the root pane is then obtained in step . Execution then proceeds to step , where a new window closing adapter is created. In the next step, , the adapter created in the previous step is added as a window closing listener. A menu bar is created in step , to which is attached a menu created in step , and a number of menu items which are created in step . Program flow continues with step , where the title bar for the main window of the graphical interface is set to \u201cAgent Management Console.\u201d Following this event, a new menu item listener is created in step . Finally, in step  the menu item listener created in the previous step is associated to each menu item.",{"@attributes":{"id":"p-0158","num":"0157"},"figref":"FIG. 22","b":["580","612","614","618","620","622","624","626","628","630","632","634","636","638","618","640","640"]},{"@attributes":{"id":"p-0159","num":"0158"},"figref":"FIG. 23","b":["644","654","652","650","648","646","656","658","644"]},"Another test point is then reached in step . If the newly created agent is ready to launch, the process continues with step , wherein the agent's remote object name is set. In step  the method to invoke remotely is set. Parameters for the remote method invocation are set in step  and the remote method is executed in step . In a preferred embodiment, the RMI call is a synchronous blocking call. When the RMI returns in step , an agent message is received from the remote server. Once the message is available, the message status is retrieved in step . A decision point is then reached in step . If the status is equal to success then execution continues to step , wherein the Array result object is extracted from the returned message of step . If the status of the operation is not equal to success, the exception contained in the message object is extracted and the exception logged in step .",{"@attributes":{"id":"p-0161","num":"0160"},"figref":"FIG. 24","b":["682","684","568","688","690","692","694","696","698","700","700","696","700","702"]},{"@attributes":{"id":"p-0162","num":"0161"},"figref":"FIG. 25","b":["704","706","708","708","710","684","712","712","704"]},{"@attributes":{"id":"p-0163","num":"0162"},"figref":"FIG. 26","b":["7","160","712","712","714","716","716","718","580","720","722","724","726"],"i":"a"},"Another decision point is then reached in step , wherein the status value from the mess age is tested to see if it equals \u201cagent started.\u201d If so, step  is invoked, at which point the given name of the mobile agent process running on the remote machine, in addition to the host name, is extracted from the agent message. In addition, the IP address of the remote machine is also obtained from the message. In the step , the root DefaultMutableTreeNode, which is stored as member data within the agent console model, is retrieved. Thereafter, in step , an enumeration of the children of the root node is obtained. Step  cycles through all child nodes, each of which represents an agent server, and obtains their respective user object.","At step  a decision point is then reached. The user object, embodied as a String representing the name of the remote server, is compared to the server name obtained in step . If they are equal, execution continues to step , wherein a DefaultMutableTreeNode is created using the name of the agent running on the remote server. Thereafter, in step , the current count for the number of child nodes that the agent server node contains is acquired. Finally the process is completed in step , wherein the node representing the remote agent is added to the server node as the very last object.",{"@attributes":{"id":"p-0166","num":"0165"},"figref":"FIG. 27","b":["748","750","754","756","758","760"]},"In step  a decision point is reached, wherein a test is made to determine if the remote server name is equal to the user object within the server node. If the result of this test is positive, then control proceeds to step , where an enumeration of server node children are obtained. Each child in this enumeration represents a running mobile agent. The next step, , retrieves the next mobile agent node in the enumeration. Thereafter, the user object is obtained from that node in step . A decision point is then invoked in step  whereby the user object is compared to the name of the remote agent that has just finished running. If a positive comparison is made, control passes on to step . In this final step the child node representing the agent is removed from the server node.",{"@attributes":{"id":"p-0168","num":"0167"},"figref":"FIG. 28","b":["800","804","816","826","818","808","818","820","810","822","812","822","822","832","832","814"]},"If a third instance of a latent response has occurred, control is then passed to step . Step  removes the remote server from the active and available list. If processing reaches the point where a server has been rated, execution continues with step  to determine if a periodic monitoring of the server is required. If periodic monitoring is required, this network latency thread will halt for a system-defined period of time in step . Upon awakening, the thread will once again ping the remote server as indicated in step . If there is a data loss from the test performed in step , execution continues with step . A check is then performed to determine if a third instance of lost data has occurred. If so, then the server is removed from the active and available list in step . Alternatively, control passes to step , wherein the thread is put to sleep for a pre-defined period of time.",{"@attributes":{"id":"p-0170","num":"0169"},"figref":"FIG. 29","b":["840","842","844","846","856","858","860"]},"In step , an agent message is returned to the originating server, indicating that the current processor is capable of running a mobile agent task. If the test performed in step  fails, then decision point  is invoked. In step , the available memory is compared to the total system memory. If the result is greater than fifty but less than seventy-five percent, another test is made in step . In step , total system memory is checked to determine whether same is greater than 256 megabytes of Random Access Memory (RAM). If the total RAM is greater than 256 megabytes, control is passed to step , described above. If available memory is less than fifty percent of total system memory, then execution proceeds to another decision point. In step , available memory is compared once again to the total system memory. If the available memory is not greater than one third of the system memory, a status message is sent back to the originating server in step , indicating that the remote server does not have enough memory. If the available memory is greater than one third of the total system memory, a test is performed in step . CPU utilization is again examined. If the utilization is more than twenty-five percent, a status message is returned to the originating host in step , indicating that not enough resources are available on the targeted remote agent server. If CPU utilization is less than twenty-five percent, a message is returned to the originating host in step , indicating that the remote server's process is currently available to run a mobile agent process.",{"@attributes":{"id":"p-0172","num":"0171"},"figref":"FIG. 30","b":["880","882","890","894","898","904","906","908","902","900","896","892","888","886","884"]},{"@attributes":{"id":"p-0173","num":"0172"},"figref":"FIG. 31","b":["920","926","928","930","932","938","950","952","954","938","940","940","942","944","946"]},"In step , the agent debugger state machine component receives the push stack event and dynamically modifies the agent's logical stack in temporary storage. If step  determines that the method is a native method, execution is passed to step , at which point the system queries the event iterator to determine whether there are any more events available for processing. If there are still events waiting, step  is re-invoked. If step  determines that the method name is \u201cmigrate\u201d execution will continue with step . In step  the agent debugger will suspend the targeted mobile agent's primary thread of execution on the remote host. In the next step, , the stack information contained within the debuggers state machine's agent digest is transferred to the newly-migrated autonomous mobile agent paused in the debuggee's virtual machine. In the final step, , the agent debugger restarts the execution of the target mobile agent's thread.",{"@attributes":{"id":"p-0175","num":"0174"},"figref":["FIG. 32","FIG. 33"],"b":["960","962","964","976","33","978"],"i":"a"},"In step , a check is made to determine whether execution stack information is available. If such information is not available, then execution continues at entry point , described in detail below and depicted in . If such information is available, step  is invoked, whereby the value of the restart variable is checked. In step  the value of the restart variable is evaluated and compared to \u201cbeginning.\u201d If the result is true, step  is invoked, wherein all of the stack frame elements are removed. Then, in step , an iterator object is created and all of the available stack frame elements are placed into it. Thereafter, in step , the iterator is used to return the next available stack frame element. The method name and parameter objects are then extracted from the stack frame in step .","Having both the method name and parameter objects available, the autonomous mobile agent uses the Java reflection API's to execute the method in step . In step , a decision point is then reached wherein a check is made to determine whether additional stack frame elements exist. If additional elements exist, then execution resumes at step ; conversely, execution continues at entry point , described below and illustrated in . If the restart value determined in step  is not equal to \u201cbeginning,\u201d execution moves on to step , wherein the state of the restart variable is also evaluated. If its value is equal to \u201clast,\u201d execution continues at step , at which point the last stack frame element is obtained. In step , the method name and parameters are obtained from the stack frame object. The method is then executed in step , and control continues at entry point , described below. If the restart value tested in step  is not equal to \u201clast,\u201d execution continues at step , where a test is made to see if the restart value equals \u201ctarget.\u201d If so, execution continues with entry point , described below.",{"@attributes":{"id":"p-0178","num":"0177"},"figref":"FIG. 33","b":["1004","1006","1008","1010","1012","1014","1006","1012","1018","1016","1007","1009","1011","1015"]},{"@attributes":{"id":"p-0179","num":"0178"},"figref":"FIG. 34","b":["1020","1024","1022","1024","1026","1028","1030","1034","1032","1036","1040","1032","1038","1042","1044","1046"]},"Having thus described the invention in detail, it is to be understood that the foregoing description is not intended to limit the spirit and scope thereof. Accordingly, what is desired to be protected by Letters Patent is set forth in the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Other important objects and features of the present invention will be apparent from the following Detailed Description of the Invention, taken in connection with the accompanying drawings wherein like reference numerals refer to like parts, in which:",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2","i":"a "},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","i":"b "},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3","i":"a "},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 3","i":"b "},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3","i":"c "},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3","i":"d "},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 3","i":"e "},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 4","i":"a "},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIGS. 12","b":["13","14"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIGS. 24","b":"25"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 33"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 34"}]},"DETDESC":[{},{}]}
