---
title: Programmable processor and method with wide operations
abstract: A programmable processor and method for improving the performance of processors by expanding at least two source operands, or a source and a result operand, to a width greater than the width of either the general purpose register or the data path width. The present invention provides operands which are substantially larger than the data path width of the processor by using the contents of a general purpose register to specify a memory address at which a plurality of data path widths of data can be read or written, as well as the size and shape of the operand. In addition, several instructions and apparatus for implementing these instructions are described which obtain performance advantages if the operands are not limited to the width and accessible number of general purpose registers.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07301541&OS=07301541&RS=07301541
owner: Microunity Systems Engineering, Inc.
number: 07301541
owner_city: Santa Clara
owner_country: US
publication_date: 20030710
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","REFERENCE TO A \u201cSEQUENCE LISTING,\u201d A TABLE, OR A COMPUTER PROGRAM LISTING APPENDIX SUBMITTED ON A COMPACT DISK","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","CONCLUSION"],"p":["This application claims the benefit of priority to Provisional Application No. 60\/394,665 filed Jul. 10, 2002, and is a continuation of U.S. patent application Ser. No. 09\/922,319, filed Aug. 2, 2001 now U.S. Pat. No. 6,725,356, which is a continuation of U.S. patent application Ser. No. 09\/382,402, filed Aug. 24, 1999, now U.S. Pat. No. 6,295,599, which claims the benefit of priority to Provisional Application No. 60\/097,635 filed on Aug. 24, 1998, and which is a continuation-in-part of U.S. patent application Ser. No. 09\/169,963, filed Oct. 13, 1998, now U.S. Pat. No. 6,006,318, which is a continuation of U.S. patent application Ser. No. 08\/754,827, filed Nov. 22, 1996 now U.S. Pat. No. 5,822,603, which is a divisional of U.S. patent application Ser. No. 08\/516,036, filed Aug. 16, 1995 now U.S. Pat. No. 5,742,840, each of the above applications and\/or patents are herein incorporated by reference in their entirety.","The present invention relates to general purpose processor architectures, and particularly relates to wide operand architectures.","This application includes an appendix, submitted herewith in duplicate on compact disks labeled as \u201cCopy 1\u201d and \u201cCopy 2.\u201d The contents of the compact disks are hereby incorporated by reference in their entirety.","Communications products require increased computational performance to process digital signals in software on a real time basis. Increases in performance have come through improvements in process technology and by improvements in microprocessor design. Increased parallelism, higher clock rates, increased densities, coupled with improved design tools and compilers have made this more practical. However, many of these improvements cost additional overhead in memory and latency due to a lack of the necessary bandwidth that is closely coupled to the computational units.","The performance level of a processor, and particularly a general purpose processor, can be estimated from the multiple of a plurality of interdependent factors: clock rate,","gates per clock, number of operands, operand and data path width, and operand and data path partitioning. Clock rate is largely influenced by the choice of circuit and logic technology, but is also influenced by the number of gates per clock. Gates per clock is how many gates in a pipeline may change state in a single clock cycle. This can be reduced by inserting latches into the data path: when the number of gates between latches is reduced, a higher clock is possible. However, the additional latches produce a longer pipeline length, and thus come at a cost of increased instruction latency. The number of operands is straightforward; for example, by adding with carry-save techniques, three values may be added together with little more delay than is required for adding two values. Operand and data path width defines how much data can be processed at once; wider data paths can perform more complex functions, but generally this comes at a higher implementation cost. Operand and data path partitioning refers to the efficient use of the data path as width is increased, with the objective of maintaining substantially peak usage.","The last factor, operand and data path partitioning, is treated extensively in commonly-assigned U.S. Pat. Nos. 5,742,840, 5,794,060, 5,794,061, 5,809,321, and 5,822,603, herein incorporated by reference in their entirety, which describe systems and methods for enhancing the utilization of a general purpose processor by adding classes of instructions. These classes of instructions use the contents of general purpose registers as data path sources, partition the operands into symbols of a specified size, perform operations in parallel, catenate the results and place the catenated results into a general-purpose register. These patents, all of which are assigned to the same assignee as the present invention, teach a general purpose microprocessor which has been optimized for processing and transmitting media data streams through significant parallelism.","While the foregoing patents offered significant improvements in utilization and performance of a general purpose microprocessor, particularly for handling broadband communications such as media data streams, other improvements are possible.","Many general purpose processors have general registers to store operands for instructions, with the register width matched to the size of the data path. Processor designs generally limit the number of accessible registers per instruction because the hardware to access these registers is relatively expensive in power and area. While the number of accessible registers varies among processor designs, it is often limited to two, three or four registers per instruction when such instructions are designed to operate in a single processor clock cycle or a single pipeline flow. Some processors, such as the Motorola 68000 have instructions to save and restore an unlimited number of registers, but require multiple cycles to perform such an instruction.","The Motorola 68000 also attempts to overcome a narrow data path combined with a narrow register file by taking multiple cycles or pipeline flows to perform an instruction, and thus emulating a wider data path. However, such multiple precision techniques offer only marginal improvement in view of the additional clock cycles required. The width and accessible number of the general purpose registers thus fundamentally limits the amount of processing that can be performed by a single instruction in a register-based machine.","Existing processors may provide instructions that accept operands for which one or more operands are read from a general purpose processor's memory system. However, as these memory operands are generally specified by register operands, and the memory system data path is no wider than the processor data path, the width and accessible number of general purpose operands per instruction per cycle or pipeline flow is not enhanced.","The number of general purpose register operands accessible per instruction is generally limited by logical complexity and instruction size. For example, it might be possible to implement certain desirable but complex functions by specifying a large number of general purpose registers, but substantial additional logic would have to be added to a conventional design to permit simultaneous reading and bypassing of the register values. While dedicated registers have been used in some prior art designs to increase the number or size of source operands or results, explicit instructions load or store values into these dedicated registers, and additional instructions are required to save and restore these registers upon a change of processor context.","The size of an execution unit result may be constrained to that of a general register so that no dedicated or other special storage is required for the result. Specifying a large number of general purpose registers as a result would similarly require substantial additional logic to be added to a conventional design to permit simultaneous writing and bypassing of the register values.","When the size of an execution unit result is constrained, it can limit the amount of computation which can reasonably be handled by a single instruction. As a consequence, algorithms must be implemented in a series of single instruction steps in which all intermediate results can be represented within the constraints. By eliminating this constraint, instruction sets can be developed in which a larger component of an algorithm is implemented as a single instruction, and the representation of intermediate results are no longer limited in size. Further, some of these intermediate results are not required to be retained upon completion of the larger component of an algorithm, so a processor freed of these constraints can improve performance and reduce operating power by not storing and retrieving these results from the general register file. When the intermediate results are not retained in the general register file, processor instruction sets and implemented algorithms are also not constrained by the size of the general register file.","There has therefore been a need for a processor system capable of efficient handling of operands and results of greater width than either the memory system or any accessible general purpose register. There is also a need for a processor system capable of efficient handling of operands and results of greater overall size than the entire general register file.","Commonly-assigned and related U.S. Pat. No. 6,295,599, describes in detail a method and system for improving the performance of general-purpose processors by expanding at least one source operand to a width greater than the width of either the general purpose register or the data path width. Further improvements in performance may be achieved by allowing a plurality of source operands to be expanded to a greater width than either the memory system or any accessible general purpose register, and by allowing the at least one result operand to be expanded to a greater width than either the memory system or any accessible general purpose register.","The present invention provides a system and method for improving the performance of general purpose processors by expanding at least one source operand or at least one result operand to a width greater than the width of either the general purpose register or the data path width. In addition, several classes of instructions will be provided which cannot be performed efficiently if the source operands or the at least one result operand are limited to the width and accessible number of general purpose registers.","In the present invention, source and result operands are provided which are substantially larger than the data path width of the processor. This is achieved, in part, by using a general purpose register to specify at least one memory address from which at least more than one, but typically several data path widths of data can be read. To permit such a wide operand to be performed in a single cycle, a data path functional unit is augmented with dedicated storage to which the memory operand is copied on an initial execution of the instruction. Further execution of the instruction or other similar instructions that specify the same memory address can read the dedicated storage to obtain the operand value. However, such reads are subject to conditions to verify that the memory operand has not been altered by intervening instructions. If the memory operand remains current\u2014that is, the conditions are met\u2014the memory operand fetch can be combined with one or more register operands in the functional unit, producing a result. The size of the result may be constrained to that of a general register so that no dedicated or other special storage is required for the result. The size of the result for additional instructions may not be so constrained, and so utilize dedicated storage to which the result operand is placed on execution of the instruction. The dedicated storage may be implemented in a local memory tightly coupled to the logic circuits that comprise the functional unit.","The present invention extends the previous embodiments to include methods and apparatus for performing operations that both receive operands from wide embedded memories and also deposit results in wide embedded memories. The present invention includes operations that autonomously read and update the wide embedded memories in multiple successive cycles of access and computation. The present invention also describes operations that employ simultaneously two or more independently addressed wide embedded memories.","Exemplary instructions using wide operations include wide instructions that perform bit level switching (Wide Switch), byte or larger table-lookup (Wide Translate), Wide Multiply Matrix, Wide Multiply Matrix Extract, Wide Multiply Matrix Extract Immediate, Wide Multiply Matrix Floating point, and Wide Multiply Matrix Galois.","Additional exemplary instructions using wide operations include wide instructions that solve equations iteratively (Wide Solve Galois), perform fast transforms (Wide Transform Slice), compute digital filter or motion estimation (Wide Convolve Extract, Wide Convolve Floating-point), decode Viterbi or turbo codes (Wide Decode), general look-up tables and interconnection (Wide Boolean).","Another aspect of the present invention addresses efficient usage of a multiplier array that is fully used for high precision arithmetic, but is only partly used for other, lower precision operations. This can be accomplished by extracting the high-order portion of the multiplier product or sum of products, adjusted by a dynamic shift amount from a general register or an adjustment specified as part of the instruction, and rounded by a control value from a register or instruction portion. The rounding may be any of several types, including round-to-nearest\/even, toward zero, floor, or ceiling. Overflows are typically handled by limiting the result to the largest and smallest values that can be accurately represented in the output result.","When an extract is controlled by a register, the size of the result can be specified, allowing rounding and limiting to a smaller number of bits than can fit in the result. This permits the result to be scaled for use in subsequent operations without concern of overflow or rounding. As a result, performance is enhanced. In those instances where the extract is controlled by a register, a single register value defines the size of the operands, the shift amount and size of the result, and the rounding control. By placing such control information in a single register, the size of the instruction is reduced over the number of bits that such an instruction would otherwise require, again improving performance and enhancing processor flexibility. Exemplary instructions are Ensemble Convolve Extract, Ensemble Multiply Extract, Ensemble Multiply Add Extract, and Ensemble Scale Add Extract. With particular regard to the Ensemble Scale Add Extract Instruction, the extract control information is combined in a register with two values used as scalar multipliers to the contents of two vector multiplicands. This combination reduces the number of registers otherwise required, thus reducing the number of bits required for the instruction.","A method of performing a computation in a programmable processor, the programmable processor having a first memory system having a first data path width, and a second memory system and a third memory system each of the second memory system and the third memory system having a data path width which is greater than the first data path width, may comprise the steps of: copying a first memory operand portion from the first memory system to the second memory system, the first memory operand portion having the first data path width; copying a second memory operand portion from the first memory system to the second memory system, the second memory operand portion having the first data path width and being catenated in the second memory system with the first memory operand portion, thereby forming first catenated data; copying a third memory operand portion from the first memory system to the third memory system, the third memory operand portion having the first data path width; copying a fourth memory operand portion from the first memory system to the third memory system, the fourth memory operand portion having the first data path width and being catenated in the third memory system with the third memory operand portion, thereby forming second catenated data; and performing a computation of a single instruction using the first catenated data and the second catenated data.","In the method of performing a computation in a programmable processor, the step of performing a computation may further comprise reading a portion of the first catenated data and a portion of the second catenated data each of which is greater in width than the first data path width and using the portion of the first catenated data and the portion of the second catenated data to perform the computation.","The method of performing a computation in a programmable processor may further comprise the step of specifying a memory address of each of the first catenated data and of the second catenated data within the first memory system.","The method of performing a computation in a programmable processor may further comprise the step of specifying a memory operand size and a memory operand shape of each of the first catenated data and the second catenated data.","The method of performing a computation in a programmable processor may further comprise the step of checking the validity of each of the first catenated data in the second memory system and the second catenated data in the third memory system, and, if valid, permitting a subsequent instruction to use the first and second catenated data without copying from the first memory system.","The method of performing a computation in a programmable processor may further comprise performing a transform of partitioned elements contained in the first catenated data using coefficients contained in the second catenated data, thereby forming a transform data, extracting a specified subfield of the transform data, thereby forming an extracted data and catenating the extracted data.","An alternative method of performing a computation in a programmable processor, the programmable processor having a first memory system having a first data path width, and a second and a third memory system having a data path width which is greater than the first data path width, may comprising the steps of: copying a first memory operand portion from the first memory system to the second memory system, the first memory operand portion having the first data path width; copying a second memory operand portion from the first memory system to the second memory system, the second memory operand portion having the first data path width and being catenated in the second memory system with the first memory operand portion, thereby forming first catenated data; performing a computation of a single instruction using the first catenated data and producing a second catenated data; copying a third memory operand portion from the third memory system to the first memory system, the third memory operand portion having the first data path width and containing a portion of the second catenated data; and copying a fourth memory operand portion from the third memory system to the first memory system, the fourth memory operand portion having the first data path width and containing a portion of the second catenated data, wherein the fourth memory operand portion is catenated in the third memory system with the third memory operand portion.","In the alternative method of performing a computation in a programmable processor the step of performing a computation may further comprise the step of reading a portion of the first catenated data which is greater in width than the first data path width and using the portion of the first catenated data to perform the computation.","The alternative method of performing a computation in a programmable processor may further comprise the step of specifying a memory address of each of the first catenated data and of the second catenated data within the first memory system.","The alternative method of performing a computation in a programmable processor may further comprise the step of specifying a memory operand size and a memory operand shape of each of the first catenated data and the second catenated data.","The alternative method of performing a computation in a programmable processor may further comprise the step of checking the validity of each of the first catenated data in the second memory system and the second catenated data in the third memory system, and, if valid, permitting a subsequent instruction to use the first catenated data without copying from the first memory system.","In the alternative method of performing a computation, the step of performing a computation may further comprise the step of performing a transform of partitioned elements contained in the first catenated data, thereby forming a transform data, extracting a specified subfield of the transform data, thereby forming an extracted data and catenating the extracted data, forming the second catenated data.","In the alternative method of performing a computation, the step of performing a computation may further comprise the step of combining using Boolean arithmetic a portion of the extracted data with an accumulated Boolean data, combining partitioned elements of the accumulated Boolean data using Boolean arithmetic, forming combined Boolean data, determining the most significant bit of the extracted data from the combined Boolean data, and returning a result comprising the position of the most significant bit to a register.","The alternative method of performing a computation in a programmable processor may further comprise manipulating a first and a second validity information corresponding to first and second catenated data, wherein after completion of an instruction specifying a memory address of first catenated data, the contents of second catenated data are provided to the first memory system in place of first catenated data.","A programmable processor according to the present invention may comprise: a first memory system having a first data path width; a second memory system and a third memory system, wherein each of the second memory system and the third memory system have a data path width which is greater than the first data path width; a first copying module configured to copy a first memory operand portion from the first memory system to the second memory system, the first memory operand portion having the first data path width, and configured to copy a second memory operand portion from the first memory system to the second memory system, the second memory operand portion having the first data path width and being catenated in the second memory system with the first memory operand portion, thereby forming first catenated data; a second copying module configured to copy a third memory operand portion from the first memory system to the third memory system, the third memory operand portion having the first data path width, and configured to copy a fourth memory operand portion from the first memory system to the third memory system, the fourth memory operand portion having the first data path width and being catenated in the third memory system with the third memory operand portion, thereby forming second catenated data; and a functional unit configured to perform computations using the first catenated data and the second catenated data.","In the programmable processor, the functional unit may be further configured to read a portion of each of the first catenated data and the second catenated data which is greater in width than the first data path width and use the portion of each of the first catenated data and the second catenated data to perform the computation.","In the programmable processor, the functional unit may be further configured to specify a memory address of each of the first catenated data and of the second catenated data within the first memory system.","In the programmable processor, the functional unit may be further configured to specify a memory operand size and a memory operand shape of each of the first catenated data and the second catenated data.","The programmable processor may further comprise a control unit configured to check the validity of each of the first catenated data in the second memory system and the second catenated data in the third memory system, and, if valid, permitting a subsequent instruction to use each of the first catenated data and the second catenated data without copying from the first memory system.","In the programmable processor, the functional unit may be further configured to convolve partitioned elements contained in the first catenated data with partitioned elements contained in the second catenated data, forming a convolution data, extract a specified subfield of the convolution data and catenate extracted data, forming a catenated result having a size equal to that of the functional unit data path width.","In the programmable processor, the functional unit may be further configured to perform a transform of partitioned elements contained in the first catenated data using coefficients contained in the second catenated data, thereby forming a transform data, extract a specified subfield of the transform data, thereby forming an extracted data and catenate the extracted data.","An alternative programmable processor according to the present invention may comprise: a first memory system having a first data path width; a second memory system and a third memory system each of the second memory system and the third memory system having a data path width which is greater than the first data path width; a first copying module configured to copy a first memory operand portion from the first memory system to the second memory system, the first memory operand portion having the first data path width, and configured to copy a second memory operand portion from the first memory system to the second memory system, the second memory operand portion having the first data path width and being catenated in the second memory system with the first memory operand portion, thereby forming first catenated data; a second copying module configured to copy a third memory operand portion from the third memory system to the first memory system, the third memory operand portion having the first data path width and containing a portion of a second catenated data, and copy a fourth memory operand portion from the third memory system to the first memory system, the fourth memory operand portion having the first data path width and containing a portion of the second catenated data, wherein the fourth memory operand portion is catenated in the third memory system with the third memory operand portion; and a functional unit configured to perform computations using the first catenated data and the second catenated data.","In the alternative programmable processor the functional unit may be further configured to read a portion of the first catenated data which is greater in width than the first data path width and use the portion of the first catenated data to perform the computation.","In the alternative programmable processor the functional unit may be further configured to specify a memory address of each of the first catenated data and of the second catenated data within the first memory system.","In the alternative programmable processor the functional unit may be further configured to specify a memory operand size and a memory operand shape of each of the first catenated data and the second catenated data.","The alternative programmable processor may further comprise a control unit configured to check the validity of the first catenated data in the second memory system, and, if valid, permitting a subsequent instruction to use the first catenated data without copying from the first memory system.","In the alternative programmable processor the functional unit may be further configured to transform partitioned elements contained in the first catenated data, thereby forming a transform data, extract a specified subfield of the transform data, thereby forming an extracted data and catenate the extracted data, forming the second catenated data.","In the alternative programmable processor the functional unit may be further configured to combine using Boolean arithmetic a portion of the extracted data with an accumulated Boolean data, combine partitioned elements of the accumulated Boolean data using Boolean arithmetic, forming combined Boolean data, determine the most significant bit of the extracted data from the combined Boolean data, and provide a result comprising the position of the most significant bit.","The alternative programmable processor may further comprise a control unit configured to manipulate a first and a second validity information corresponding to first and second catenated data, wherein after completion of an instruction specifying a memory address of first catenated data, the contents of second catenated data are provided to the first memory system in place of first catenated data.","Processor Layout","Referring first to , a general purpose processor is illustrated therein in block diagram form. In , four copies of an access unit are shown, each with an access instruction fetch queue A-Queue -. Each access instruction fetch queue A-Queue - is coupled to an access register file AR -, which are each coupled to two access functional units A -. In a typical embodiment, each thread of the processor may have on the order of sixty-four general purpose registers (e.g., the AR's - and ER's -). The access units function independently for four simultaneous threads of execution, and each compute program control flow by performing arithmetic and branch instructions and access memory by performing load and store instructions. These access units also provide wide operand specifiers for wide operand instructions. These eight access functional units A - produce results for access register files AR - and memory addresses to a shared memory system -.","In one embodiment, the memory hierarchy includes on-chip instruction and data memories, instruction and data caches, a virtual memory facility, and interfaces to external devices. In , the memory system is comprised of a combined cache and niche memory , an external bus interface , and, externally to the device, a secondary cache  and main memory system with I\/O devices . The memory contents fetched from memory system - are combined with execute instructions not performed by the access unit, and entered into the four execute instruction queues E-Queue -. For wide instructions, memory contents fetched from memory system - are also provided to wide operand microcaches - by bus . Instructions and memory data from E-queue - are presented to execution register files -, which fetch execution register file source operands. The instructions are coupled to the execution unit arbitration unit Arbitration , that selects which instructions from the four threads are to be routed to the available execution functional units E  and , X  and , G - and -, and T . The execution functional units E  and , the execution functional units X  and , and the execution functional unit T  each contain a wide operand microcache -, which are each coupled to the memory system  by bus .","The execution functional units G - and - are group arithmetic and logical units that perform simple arithmetic and logical instructions, including group operations wherein the source and result operands represent a group of values of a specified symbol size, which are partitioned and operated on separately, with results catenated together. In a presently preferred embodiment the data path is 128 bits wide, although the present invention is not intended to be limited to any specific size of data path.","The execution functional units X  and  are crossbar switch units that perform crossbar switch instructions. The crossbar switch units  and  perform data handling operations on the data stream provided over the data path source operand buses -, including deals, shuffles, shifts, expands, compresses, swizzles, permutes and reverses, plus the wide operations discussed hereinafter. In a key element of a first aspect of the invention, at least one such operation will be expanded to a width greater than the general register and data path width.","The execution functional units E  and  are ensemble units that perform ensemble instructions using a large array multiplier, including group or vector multiply and matrix multiply of operands partitioned from data path source operand buses - and treated as integer, floating point, polynomial or Galois field values. Matrix multiply instructions and other operations utilize a wide operand loaded into the wide operand microcache  and .","The execution functional unit T  is a translate unit that performs table-look-up operations on a group of operands partitioned from a register operand, and catenates the result. The Wide Translate instruction utilizes a wide operand loaded into the wide operand microcache .","The execution functional units E , , execution functional units X-, , and execution functional unit T each contain dedicated storage to permit storage of source operands including wide operands as discussed hereinafter. The dedicated storage -, which may be thought of as a wide microcache, typically has a width which is a multiple of the width of the data path operands related to the data path source operand buses -. Thus, if the width of the data path - is 128 bits, the dedicated storage - may have a width of 256, 512, 1024 or 2048 bits. Operands which utilize the full width of the dedicated storage are referred to herein as wide operands, although it is not necessary in all instances that a wide operand use the entirety of the width of the dedicated storage; it is sufficient that the wide operand use a portion greater than the width of the memory data path of the output of the memory system - and the functional unit data path of the input of the execution functional units -, though not necessarily greater than the width of the two combined. Because the width of the dedicated storage - is greater than the width of the memory operand bus , portions of wide operands are loaded sequentially into the dedicated storage -. However, once loaded, the wide operands may then be used at substantially the same time. It can be seen that functional units - and associated execution registers - form a data functional unit, the exact elements of which may vary with implementation.","The execution register file ER - source operands are coupled to the execution units - using source operand buses - and to the execution units - using source operand buses -. The function unit result operands from execution units - are coupled to the execution register file ER - using result bus  and the function units result operands from execution units - are coupled to the execution register file using result bus .","Wide Multiply Matrix","The wide operands of the present invention provide the ability to execute complex instructions such as the wide multiply matrix instruction shown in , which can be appreciated in an alternative form, as well, from . As can be appreciated from , a wide operand permits, for example, the matrix multiplication of various sizes and shapes which exceed the data path width. The example of  involves a matrix specified by register rc having 128*64\/size bits (512 bits for this example) multiplied by a vector contained in register rb having 128 bits, to yield a result, placed in register rd, of 128 bits.","The notation used in  and following similar figures illustrates a multiplication as a shaded area at the intersection of two operands projected in the horizontal and vertical dimensions. A summing node is illustrated as a line segment connecting a darkened dots at the location of multiplier products that are summed. Products that are subtracted at the summing node are indicated with a minus symbol within the shaded area.","When the instruction operates on floating-point values, the multiplications and summations illustrated are floating point multiplications and summations. An exemplary embodiment may perform these operations without rounding the intermediate results, thus computing the final result as if computed to infinite precision and then rounded only once.","It can be appreciated that an exemplary embodiment of the multipliers may compute the product in carry-save form and may encode the multiplier rb using Booth encoding to minimize circuit area and delay. It can be appreciated that an exemplary embodiment of such summing nodes may perform the summation of the products in any order, with particular attention to minimizing computation delay, such as by performing the additions in a binary or higher-radix tree, and may use carry-save adders to perform the addition to minimize the summation delay. It can also be appreciated that an exemplary embodiment may perform the summation using sufficient intermediate precision that no fixed-point or floating-point overflows occur on intermediate results.","A comparison of  can be used to clarify the relation between the notation used in  and the more conventional schematic notation in , as the same operation is illustrated in these two figures.","Wide Operand","The operands that are substantially larger than the data path width of the processor are provided by using a general-purpose register to specify a memory specifier from which more than one but in some embodiments several data path widths of data can be read into the dedicated storage. The memory specifier typically includes the memory address together with the size and shape of the matrix of data being operated on. The memory specifier or wide operand specifier can be better appreciated from , in which a specifier  is seen to be an address, plus a field representative of the size\/2 and a further field representative of width\/2, where size is the product of the depth and width of the data. The address is aligned to a specified size, for example sixty four bytes, so that a plurality of low order bits (for example, six bits) are zero. The specifier  can thus be seen to comprise a first field  for the address, plus two field indicia  within the low order six bits to indicate size and width.","Specifier Decoding","The decoding of the specifier  may be further appreciated from  where, for a given specifier  made up of an address field  together with a field  comprising plurality of low order bits. By a series of arithmetic operations shown at steps  and , the portion of the field  representative of width\/2 is developed. In a similar series of steps shown at  and , the value of t is decoded, which can then be used to decode both size and address. The portion of the field  representative of size\/2 is decoded as shown at steps  and , while the address is decoded in a similar way at steps  and .","Wide Function Unit","The wide function unit may be better appreciated from , in which a register number  is provided to an operand checker . Wide operand specifier  communicates with the operand checker  and also addresses memory  having a defined memory width. The memory address includes a plurality of register operands A n, which are accumulated in a dedicated storage portion  of a data functional unit . In the exemplary embodiment shown in , the dedicated storage . can be seen to have a width equal to eight data path widths, such that eight wide operand portions A-H are sequentially loaded into the dedicated storage to form the wide operand. Although eight portions are shown in , the present invention is not limited to eight or any other specific multiple of data path widths. Once the wide operand portions A-H are sequentially loaded, they may be used as a single wide operand  by the functional element , which may be any element(s) from  connected thereto. The result of the wide operand is then provided to a result register , which in a presently preferred embodiment is of the same width as the memory width.","Once the wide operand is successfully loaded into the dedicated storage , a second aspect of the present invention may be appreciated. Further execution of this instruction or other similar instructions that specify the same memory address can read the dedicated storage to obtain the operand value under specific conditions that determine whether the memory operand has been altered by intervening instructions. Assuming that these conditions are met, the memory operand fetch from the dedicated storage is combined with one or more register operands in the functional unit, producing a result. In some embodiments, the size of the result is limited to that of a general register, so that no similar dedicated storage is required for the result. However, in some different embodiments, the result may be a wide operand, to further enhance performance.","To permit the wide operand value to be addressed by subsequent instructions specifying the same memory address, various conditions must be checked and confirmed:","Those conditions include:","Each memory store instruction checks the memory address against the memory addresses recorded for the dedicated storage. Any match causes the storage to be marked invalid, since a memory store instruction directed to any of the memory addresses stored in dedicated storage  means that data has been overwritten.","The register number used to address the storage is recorded. If no intervening instructions have written to the register, and the same register is used on the subsequent instruction, the storage is valid (unless marked invalid by rule #1).","If the register has been modified or a different register number is used, the value of the register is read and compared against the address recorded for the dedicated storage. This uses more resources than #1 because of the need to fetch the register contents and because the width of the register is greater than that of the register number itself. If the address matches, the storage is valid. The new register number is recorded for the dedicated storage.","If conditions #2 or #3 are not met, the register contents are used to address the general-purpose processor's memory and load the dedicated storage. If dedicated storage is already fully loaded, a portion of the dedicated storage must be discarded (victimized) to make room for the new value. The instruction is then performed using the newly updated dedicated storage. The address and register number is recorded for the dedicated storage.","By checking the above conditions, the need for saving and restoring the dedicated storage is eliminated. In addition, if the context of the processor is changed and the new context does not employ Wide instructions that reference the same dedicated storage, when the original context is restored, the contents of the dedicated storage are allowed to be used without refreshing the value from memory, using checking rule #3. Because the values in the dedicated storage are read from memory and not modified directly by performing wide operations, the values can be discarded at any time without saving the results into general memory. This property simplifies the implementation of rule #4 above.","An alternate embodiment of the present invention can replace rule #1 above with the following rule:","1a. Each memory store instruction checks the memory address against the memory addresses recorded for the dedicated storage. Any match causes the dedicated storage to be updated, as well as the general memory.","By use of the above rule 1.a, memory store instructions can modify the dedicated storage, updating just the piece of the dedicated storage that has been changed, leaving the remainder intact. By continuing to update the general memory, it is still true that the contents of the dedicated memory can be discarded at any time without saving the results into general memory. Thus rule #4 is not made more complicated by this choice. The advantage of this alternate embodiment is that the dedicated storage need not be discarded (invalidated) by memory store operations.","Wide Microcache Data Structures","Referring next to , an exemplary arrangement of the data structures of the wide microcache or dedicated storage  may be better appreciated. The wide microcache contents, wmc.c, can be seen to form a plurality of data path widths A-n, although in the example shown the number is eight. The physical address, wmc.pa, is shown as 64 bits in the example shown, although the invention is not limited to a specific width. The size of the contents, wmc.size, is also provided in a field which is shown as 10 bits in an exemplary embodiment. A \u201ccontents valid\u201d flag, wmc.cv, of one bit is also included in the data structure, together with a two bit field for thread last used, or wmc.th. In addition, a six bit field for register last used, wmc.reg, is provided in an exemplary embodiment. Further, a one bit flag for register and thread valid, or wmc.rtv, may be provided.","Wide Microcache Control\u2014Software","The process by which the microcache is initially written with a wide operand, and thereafter verified as valid for fast subsequent operations, may be better appreciated from . The process begins at , and progresses to step  where a check of the register contents is made against the stored value wmc.rc. If true, a check is made at step  to verify the thread. If true, the process then advances to step  to verify whether the register and thread are valid. If step  reports as true, a check is made at step  to verify whether the contents are valid. If all of steps  through  return as true, the subsequent instruction is able to utilize the existing wide operand as shown at step , after which the process ends. However, if any of steps  through  return as false, the process branches to step , where content, physical address and size are set. Because steps  through  all lead to either step  or , steps  through  may be performed in any order or simultaneously without altering the process. The process then advances to step  where size is checked. This check basically ensures that the size of the translation unit is greater than or equal to the size of the wide operand, so that a physical address can directly replace the use of a virtual address. The concern is that, in some embodiments, the wide operands may be larger than the minimum region that the virtual memory system is capable of mapping. As a result, it would be possible for a single contiguous virtual address range to be mapped into multiple, disjoint physical address ranges, complicating the task of comparing physical addresses. By determining the size of the wide operand and comparing that size against the size of the virtual address mapping region which is referenced, the instruction is aborted with an exception trap if the wide operand is larger than the mapping region. This ensures secure operation of the processor. Software can then re-map the region using a larger size map to continue execution if desired. Thus, if size is reported as unacceptable at step , an exception is generated at step . If size is acceptable, the process advances to step  where physical address is checked. If the check reports as met, the process advances to step , where a check of the contents valid flag is made. If either check at step  or  reports as false, the process branches and new content is written into the dedicated storage , with the fields thereof being set accordingly. Whether the check at step  reported true, or whether new content was written at step , the process advances to step  where appropriate fields are set to indicate the validity of the data, after which the requested function can be performed at step . The process then ends.","Wide Microcache Control\u2014Hardware","Referring next to , which together show the operation of the microcache controller from a hardware standpoint, the operation of the microcache controller may be better understood. In the hardware implementation, it is clear that conditions which are indicated as sequential steps in  above can be performed in parallel, reducing the delay for such wide operand checking. Further, a copy of the indicated hardware may be included for each wide microcache, and thereby all such microcaches as may be alternatively referenced by an instruction can be tested in parallel. It is believed that no further discussion of  is required in view of the extensive discussion of , above.","Various alternatives to the foregoing approach do exist for the use of wide operands, including an implementation in which a single instruction can accept two wide operands, partition the operands into symbols, multiply corresponding symbols together, and add the products to produce a single scalar value or a vector of partitioned values of width of the register file, possibly after extraction of a portion of the sums. Such an instruction can be valuable for detection of motion or estimation of motion in video compression. A further enhancement of such an instruction can incrementally update the dedicated storage if the address of one wide operand is within the range of previously specified wide operands in the dedicated storage, by loading only the portion not already within the range and shifting the in-range portion as required. Such an enhancement allows the operation to be performed over a \u201csliding window\u201d of possible values. In such an instruction, one wide operand is aligned and supplies the size and shape information, while the second wide operand, updated incrementally, is not aligned.","The Wide Convolve Extract instruction and Wide Convolve Floating-point instruction described below is one alternative embodiment of an instruction that accepts two wide operands.","Another alternative embodiment of the present invention can define additional instructions where the result operand is a wide operand. Such an enhancement removes the limit that a result can be no larger than the size of a general register, further enhancing performance. These wide results can be cached locally to the functional unit that created them, but must be copied to the general memory system before the storage can be reused and before the virtual memory system alters the mapping of the address of the wide result. Data paths must be added so that load operations and other wide operations can read these wide results\u2014forwarding of a wide result from the output of a functional unit back to its input is relatively easy, but additional data paths may have to be introduced if it is desired to forward wide results back to other functional units as wide operands.","As previously discussed, a specification of the size and shape of the memory operand is included with the low-order bits of the address. In a presently preferred implementation, such memory operands are typically a power of two in size and aligned to that size. Generally, one half the total size is added (or inclusively or'ed, or exclusively or'ed) to the memory address, and one half of the data width is added (or inclusively or'ed, or exclusively or'ed) to the memory address. These bits can be decoded and stripped from the memory address, so that the controller is made to step through all the required addresses. The number of distinct operands required for these instructions is hereby decreased, as the size, shape and address of the memory operand are combined into a single register operand value.","In an alternative exemplary embodiment described below in the Wide Switch instruction and others below, the wide operand specifier is described as containing optional size and shape specifiers. As such, the omission of the specifier value obtains a default size or shape defined from attributes of the specified instruction.","In an alternative exemplary embodiment described below in the Wide Convolve Extract instruction below, the wide operand specifier contains mandatory size and shape specifier. The omission of the specifier value obtains an exception which aborts the operation. Notably, the specification of a larger size or shape than an implementation may permit due to limited resources, such as the limited size of a wide operand memory, may result in a similar exception when the size or shape descriptor is searched for only in the limited bit range in which a valid specifier value may be located. This can be utilized to ensure that software that requires a larger specifier value than the implementation can provide results in a detected exception condition, when for example, a plurality of implementations of the same instruction set of a processor differ in capabilities. This also allows for an upward-compatible extension of wide operand sizes and shapes to larger values in extended implementations of the same instruction set.","In an alternative exemplary embodiment, the wide operand specifier contains size and shape specifiers in an alternative representation other than linearly related to the value of the size and shape parameters. For example, low-order bits of the specifier may contain a fixed-size binary value which is logarithmically related to the value, such as a two-bit field where 00 conveys a value of 128, 01 a value of 256, 10 a value of 512, and 11 a value of 1024. The use of a fixed-size field limits the maximum value which can be specified in, for example, a later upward-compatible implementation of a processor.","The following table illustrates the arithmetic and descriptive notation used in the pseudocode in the Figures referenced hereinafter:",{"@attributes":{"id":"p-0137","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"238pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["x + y","two's complement addition of x and y. Result is the same size as the operands,"]},{"entry":[{},"and operands must be of equal size."]},{"entry":["x \u2212 y","two's complement subtraction of y from x. Result is the same size as the"]},{"entry":[{},"operands, and operands must be of equal size."]},{"entry":["x * y","two's complement multiplication of x and y. Result is the same size as the"]},{"entry":[{},"operands, and operands must be of equal size."]},{"entry":["x \/ y","two's complement division of x by y. Result is the same size as the operands,"]},{"entry":[{},"and operands must be of equal size."]},{"entry":["x & y","bitwise and of x and y. Result is same size as the operands, and operands must"]},{"entry":[{},"be of equal size."]},{"entry":["x | y","bitwise or of x and y. Result is same size as the operands, and operands must"]},{"entry":[{},"be of equal size."]},{"entry":["x {circumflex over (\u2009)} y","bitwise exclusive-of of x and y. Result is same size as the operands, and"]},{"entry":[{},"operands must be of equal size."]},{"entry":["~x","bitwise inversion of x. Result is same size as the operand."]},{"entry":["x = y","two's complement equality comparison between x and y. Result is a single bit,"]},{"entry":[{},"and operands must be of equal size."]},{"entry":["x \u2260 y","two's complement inequality comparison between x and y. Result is a single"]},{"entry":[{},"bit, and operands must be of equal size."]},{"entry":["x < y","two's complement less than comparison between x and y. Result is a single bit,"]},{"entry":[{},"and operands must be of equal size."]},{"entry":["x \u2267 y","two's complement greater than or equal comparison between x and y. Result is"]},{"entry":[{},"a single bit, and operands must be of equal size."]},{"entry":["\u221a{square root over (x)}","floating-point square root of x"]},{"entry":["x \u2225 y","concatenation of bit field x to left of bit field y"]},{"entry":[{"sub":"x"},"binary digit x repeated, concatenated y times. Size of result is y."]},{"entry":["x","extraction of bit y (using little-endian bit numbering) from value x. Result is a"]},{"entry":[{},"single bit."]},{"entry":["x","extraction of bit field formed from bits y through z of value x. Size of result is -"]},{"entry":[{},"z + 1; if z > y, result is an empty string,"]},{"entry":["x?y:z","value of y, if x is true, otherwise value of z. Value of x is a single bit."]},{"entry":["x \u2190 y","bitwise assignment of x to value of y"]},{"entry":["x.y","subfield of structured bitfield x"]},{"entry":["Sn","signed, two's complement, binary data format of n bytes"]},{"entry":["Un","unsigned binary data format of n bytes"]},{"entry":["Fn","floating-point data format of n bytes"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Wide Operations","Particular examples of wide operations which are defined by the present invention include the Wide Switch instruction that performs bit-level switching; the Wide Translate instruction which performs byte (or larger) table lookup; Wide Multiply Matrix; Wide Multiply Matrix Extract and Wide Multiply Matrix Extract Immediate (discussed below), Wide Multiply Matrix Floating-point, and Wide Multiply Matrix Galois (also discussed below). While the discussion below focuses on particular sizes for the exemplary instructions, it will be appreciated that the invention is not limited to a particular width.","Wide Switch","An exemplary embodiment of the Wide Switch instruction is shown in . In an exemplary embodiment, the Wide Switch instruction rearranges the contents of up to two registers (256 bits) at the bit level, producing a full-width (128 bits) register result. To control the rearrangement, a wide operand specified by a single register, consisting of eight bits per bit position is used. For each result bit position, eight wide operand bits for each bit position select which of the 256 possible source register bits to place in the result. When a wide operand size smaller than 128 bytes is specified, the high order bits of the memory operand are replaced with values corresponding to the result bit position, so that the memory operand specifies a bit selection within symbols of the operand size, performing the same operation on each symbol.","In an exemplary embodiment, these instructions take an address from a general register to fetch a large operand from memory, a second operand from a general register, perform a group of operations on partitions of bits in the operands, and catenate the results together, placing the result in a general register. An exemplary embodiment of the format  of the Wide Switch instruction is shown in .","An exemplary embodiment of a schematic  of the Wide Switch instruction is shown in . In an exemplary embodiment, the contents of register rc specifies a virtual address apd optionally an operand size, and a value of specified size is loaded from memory. A second value is the catenated contents of registers rd and rb. Eight corresponding bits from the memory value are used to select a single result bit from the second value, for each corresponding bit position. The group of results is catenated and placed in register ra.","In an exemplary embodiment, the virtual address must either be aligned to 128 bytes, or must be the sum of an aligned address and one-half of the size of the memory operand in bytes. An aligned address must be an exact multiple of the size expressed in bytes. The size of the memory operand must be 8, 16, 32, 64, or 128 bytes. If the address is not valid an \u201caccess disallowed by virtual address\u201d exception occurs. When a size smaller than 128 bits is specified, the high order bits of the memory operand are replaced with values corresponding to the bit position, so that the same memory operand specifies a bit selection within symbols of the operand size, and the same operation is performed on each symbol.","In an exemplary embodiment, a wide switch (W.SWITCH.L or W.SWITCH.B) instruction specifies an 8-bit location for each result bit from the memory operand, that selects one of the 256 bits represented by the catenated contents of registers rd and rb.","An exemplary embodiment of the pseudocode  of the Wide Switch instruction is shown in . An exemplary embodiment of the exceptions  of the Wide Switch instruction is shown in .","Wide Translate","An exemplary embodiment of the Wide Translate instruction is shown in . In an exemplary embodiment, the Wide Translate instructions use a wide operand to specify a table of depth up to 256 entries and width of up to 128 bits. The contents of a register is partitioned into operands of one, two, four, or eight bytes, and the partitions are used to select values from the table in parallel. The depth and width of the table can be selected by specifying the size and shape of the wide operand as described above.","In an exemplary embodiment, these instructions take an address from a general register to fetch a large operand from memory, a second operand from a general register, perform a group of operations on partitions of bits in the operands, and catenate the results together, placing the result in a general register. An exemplary embodiment of the format  of the Wide Translate instruction is shown in .","An exemplary embodiment of the schematic  of the Wide Translate instruction is shown in . In an exemplary embodiment, the contents of register rc is used as a virtual address, and a value of specified size is loaded from memory. A second value is the contents of register rb. The values are partitioned into groups of operands of a size specified. The low-order bytes of the second group of values are used as addresses to choose entries from one or more tables constructed from the first value, producing a group of values. The group of results is catenated and placed in register rd.","In an exemplary embodiment, by default, the total width of tables is 128 bits, and a total table width of 128, 64, 32, 16 or 8 bits, but not less than the group size may be specified by adding the desired total table width in bytes to the specified address: 16, 8, 4, 2, or 1. When fewer than 128 bits are specified, the tables repeat to fill the 128 bit width.","In an exemplary embodiment, the default depth of each table is 256 entries, or in bytes is 32 times the group size in bits. An operation may specify 4, 8, 16, 32, 64, 128 or 256 entry tables, by adding one half of the memory operand size to the address. Table index values are masked to ensure that only the specified portion of the table is used. Tables with just 2 entries cannot be specified; if 2-entry tables are desired, it is recommended to load the entries into registers and use G.MUX to select the table entries.","In an exemplary embodiment, failing to initialize the entire table is a potential security hole, as an instruction in with a small-depth table could access table entries previously initialized by an instruction with a large-depth table. This security hole may be closed either by initializing the entire table, even if extra cycles are required, or by masking the index bits so that only the initialized portion of the table is used. An exemplary embodiment may initialize the entire table with no penalty in cycles by writing to as many as 128 table entries at once. Initializing the entire table with writes to only one entry at a time requires writing 256 cycles, even when the table is smaller. Masking the index bits is the preferred solution.","In an exemplary embodiment, masking the index bits suggests that this instruction, for tables larger than 256 entries, may be extended to a general-purpose memory translate function where the processor performs enough independent load operations to fill the 128 bits. Thus, the 16, 32, and 64 bit versions of this function perform equivalent of 8, 4, 2 withdraw, 8, 4, or 2 load-indexed and 7, 3, or 1 group-extract instructions. In other words, this instruction can be as powerful as 23, 11, or 5 previously existing instructions. The 8-bit version is a single cycle operation replacing 47 existing instructions, so these extensions are not as powerful, but nonetheless, this is at least a 50% improvement on a 2-issue processor, even with one cycle per load timing. To make this possible, the default table size becomes 65536, 2^32 and 2^64 for 16, 32 and 64-bit versions of the instruction.","In an exemplary embodiment, for the big-endian version of this instruction, in the definition below, the contents of register rb is complemented. This reflects a desire to organize the table so that the lowest addressed table entries are selected when the index is zero. In the logical implementation, complementing the index can be avoided by loading the table memory differently for big-endian and little-endian versions; specifically by loading the table into memory so that the highest-addressed table entries are selected when the index is zero for a big-endian version of the instruction. In an exemplary embodiment of the logical implementation, complementing the index can be avoided by loading the table memory differently for big-endian and little-endian versions. In order to avoid complementing the index, the table memory is loaded differently for big-endian versions of the instruction by complementing the addresses at which table entries are written into the table for a big-endian version of the instruction.","In an exemplary embodiment, the virtual address must either be aligned to 4096 bytes, or must be the sum of an aligned address and one-half of the size of the memory operand in bytes and\/or the desired total table width in bytes. An aligned address must be an exact multiple of the size expressed in bytes. The size of the memory operand must be a power of two from 4 to 4096 bytes, but must be at least 4 times the group size and 4 times the total table width. If the address is not valid an \u201caccess disallowed by virtual address\u201d exception occurs.","In an exemplary embodiment, a wide translate (W.TRANSLATE.8.L or W.TRANSLATE.8.B) instruction specifies a translation table of 16 entries (vsize=16) in depth, a group size of 1 byte (gsize=8 bits), and a width of 8 bytes (wsize=64 bits). The address specifies a total table size (msize=1024 bits=vsize*wsize) and a table width (wsize=64 bits) by adding one half of the size in bytes of the table (64) and adding the size in bytes of the table width (8) to the table address in the address specification. The instruction will create duplicates of this table in the upper and lower 64 bits of the data path, so that 128 bits of operand are processed at once, yielding a 128 bit result.","An exemplary embodiment of the pseudocode  of the Wide Translate instruction is shown in . An exemplary embodiment of the exceptions  of the Wide Translate instruction is shown in .","Wide Multiply Matrix","An exemplary embodiment of the Wide Multiply Matrix instruction is shown in . In an exemplary embodiment, the Wide Multiply Matrix instructions use a wide operand to specify a matrix of values of width up to 64 bits (one half of register file and data path width) and depth of up to 128 bits\/symbol size. The contents of a general register (128 bits) is used as a source operand, partitioned into a vector of symbols, and multiplied with the matrix, producing a vector of width up to 128 bits of symbols of twice the size of the source operand symbols. The width and depth of the matrix can be selected by specifying the size and shape of the wide operand as described above. Controls within the instruction allow specification of signed, mixed signed, unsigned, complex, or polynomial operands.","In an exemplary embodiment, these instructions take an address from a general register to fetch a large operand from memory, a second operand from a general register, perform a group of operations on partitions of bits in the operands, and catenate the results together, placing the result in a general register. An exemplary embodiment of the format  of the Wide Multiply Matrix instruction is shown in .","An exemplary embodiment of the schematics  and  of the Wide Multiply Matrix instruction is shown in . In an exemplary embodiment, the contents of register rc is used as a virtual address, and a value of specified size is loaded from memory. A second value is the contents of register rb. The values are partitioned into groups of operands of the size specified. The second values are multiplied with the first values, then summed, producing a group of result values. The group of result values is catenated and placed in register rd.","In an exemplary embodiment, the memory multiply instructions (W.MUL.MAT, W.MUL.MAT.C, W.MUL.MAT.M, W.MUL.MAT.P, W.MUL.MAT.U) perform a partitioned array multiply of up to 8192 bits, that is 64\u00d7128 bits. The width of the array can be limited to 64, 32, or 16 bits, but not smaller than twice the group size, by adding one half the desired size in bytes to the virtual address operand: 4, 2, or 1. The array can be limited vertically to 128, 64, 32, or 16 bits, but not smaller than twice the group size, by adding one-half the desired memory operand size in bytes to the virtual address operand.","In an exemplary embodiment, the virtual address must either be aligned to 1024\/gsize bytes (or 512\/gsize for W.MUL.MAT.C) (with gsize measured in bits), or must be the sum of an aligned address and one half of the size of the memory operand in bytes and\/or one quarter of the size of the result in bytes. An aligned address must be an exact multiple of the size expressed in bytes. If the address is not valid an \u201caccess disallowed by virtual address\u201d exception occurs.","In an exemplary embodiment, a wide multiply octlets instruction (W.MUL.MAT.type.64, type=NONE M U P) is not implemented and causes a reserved instruction exception, as an ensemble-multiply-sum-octlets instruction (E.MUL.SUM.type.64) performs the same operation except that the multiplier is sourced from a 128-bit register rather than memory. Similarly, instead of wide-multiply-complex-quadlets instruction (W.MUL.MAT.C.32), one should use an ensemble-multiply-complex-quadlets instruction (E.MUL.SUM.C.32).","As shown in , an exemplary embodiment of a wide-multiply-doublets instruction (W.MUL.MAT, W.MUL.MAT.M, W.MUL.MAT.P, W.MUL.MAT.U) multiplies memory [m31 m30 . . . m1 m0] with vector [h g f e d c b a], yielding products [hm31+gm27+ . . . +bm7+am3 . . . hm28+gm24+ . . . +bm4+am0].","As shown in , an exemplary embodiment of a wide-multiply-matrix-complex-doublets instruction (W.MUL.MAT.C) multiplies memory [m15 m14 . . . m1 m0] with vector [h g f e d c b a], yielding products [hm14+gm15+ . . . +bm2+am3 . . . hm12+gm13+ . . . +bm0+am1 hm13+gm12+ . . . bm1+am0].","An exemplary embodiment of the pseudocode  of the Wide Multiply Matrix instruction is shown in . An exemplary embodiment of the exceptions  of the Wide Multiply Matrix instruction is shown in .","Wide Multiply Matrix Extract","An exemplary embodiment of the Wide Multiply Matrix Extract instruction is shown in . In an exemplary embodiment, the Wide Multiply Matrix Extract instructions use a wide operand to specify a matrix of value of width up to 128 bits (full width of register file and data path) and depth of up to 128 bits\/symbol size. The contents of a general register (128 bits) is used as a source operand, partitioned into a vector of symbols, and multiplied with the matrix, producing a vector of width up to 256 bits of symbols of twice the size of the source operand symbols plus additional bits to represent the sums of products without overflow. The results are then extracted in a manner described below (Enhanced Multiply Bandwidth by Result Extraction), as controlled by the contents of a general register specified by the instruction. The general register also specifies the format of the operands: signed, mixed-signed, unsigned, and complex as well as the size of the operands, byte (8 bit), doublet (16 bit), quadlet (32 bit), or hexlet (64 bit).","In an exemplary embodiment, these instructions take an address from a general register to fetch a large operand from memory, a second operand from a general register, perform a group of operations on partitions of bits in the operands, and catenate the results together, placing the result in a general register. An exemplary embodiment of the format  of the Wide Multiply Matrix Extract instruction is shown in .","An exemplary embodiment of the schematics  and  of the Wide Multiply Matrix Extract instruction is shown in . In an exemplary embodiment, the contents of register rc is used as a virtual address, and a value of specified size is loaded from memory. A second value is the contents of register rd. The group size and other parameters are specified from the contents of register rb. The values are partitioned into groups of operands of the size specified and are multiplied and summed, producing a group of values. The group of values is rounded, and limited as specified, yielding a group of results which is the size specified. The group of results is catenated and placed in register ra.","In an exemplary embodiment, the size of this operation is determined from the contents of register rb. The multiplier usage is constant, but the memory operand size is inversely related to the group size. Presumably this can be checked for cache validity.","In an exemplary embodiment, low order bits of re are used to designate a size, which must be consistent with the group size. Because the memory operand is cached, the size can also be cached, thus eliminating the time required to decode the size, whether from rb or from rc.","In an exemplary embodiment, the wide multiply matrix extract instructions (W.MUL.MAT.X.B, W.MUL.MAT.X.L) perform a partitioned array multiply of up to 16384 bits, that is 128\u00d7128 bits. The width of the array can be limited to 128, 64, 32, or 16 bits, but not smaller than twice the group size, by adding one half the desired size in bytes to the virtual address operand: 8, 4, 2, or 1. The array can be limited vertically to 128, 64, 32, or 16 bits, but not smaller than twice the group size, by adding one half the desired memory operand size in bytes to the virtual address operand.","As shown in , in an exemplary embodiment, bits  . . .  of the contents of register rb specifies several parameters which control the manner in which data is extracted. The position and default values of the control fields allow for the source position to be added to a fixed control value for dynamic computation, and allow for the lower 16 bits of the control field to be set for some of the simpler extract cases by a single GCOPYI instruction.","In an exemplary embodiment, the table below describes the meaning of each label:",{"@attributes":{"id":"p-0178","num":"0177"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"label","bits","meaning"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"fsize","8","field size"]},{"entry":[{},"dpos","8","destination position"]},{"entry":[{},"x","1","reserved"]},{"entry":[{},"s","1","signed vs. unsigned"]},{"entry":[{},"n","1","complex vs. real multiplication"]},{"entry":[{},"m","1","mixed-sign vs. same-sign multiplication"]},{"entry":[{},"l","1","saturation vs. truncation"]},{"entry":[{},"rnd","2","rounding"]},{"entry":[{},"gssp","9","group size and source position"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"In an exemplary embodiment, the 9 bit gssp field encodes both the group size, gsize, and source position, spos, according to the formula gssp=512 4*gsize+spos. The group size, gsize, is a power of two in the range 1 . . . 128. The source position, spos, is in the range 0 . . . (2*gsize) 1.","In an exemplary embodiment, the values in the s, n, m, t, and rnd fields have the following meaning:",{"@attributes":{"id":"p-0181","num":"0180"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["values","s","n","m","I","rnd"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","unsigned","real","same-sign","truncate","F"]},{"entry":["1","signed","complex","mixed-sign","saturate","Z"]},{"entry":["2",{},{},{},{},"N"]},{"entry":["3",{},{},{},{},"C"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"In an exemplary embodiment, the virtual address must be aligned, that is, it must be an exact multiple of the operand size expressed in bytes. If the address is not aligned an \u201caccess disallowed by virtual address\u201d exception occurs.","In an exemplary embodiment, Z (zero) rounding is not defined for unsigned extract operations, and a ReservedInstruction exception is raised if attempted. F (floor) rounding will properly round unsigned results downward.","As shown in , an exemplary embodiment of a wide-multiply-matrix-extract-doublets instruction (W.MUL.MAT.X.B or W.MUL.MAT.X.L) multiplies memory [m63 m62 m61 . . . m2 m1 m0] with vector [h g f e d c b a], yielding the products","[am7+bm15+cm23+dm31+em39+fm47+gm55+hm63 . . . .","am2+bm10+cm 18+dm26+em34+fm42+gm50+hm58 am1+bm9+cm17+dm25+em33+fm41+gm49+hm57 am0+bm8+cm16+dm24+em32+fm40+gm48+hm56], rounded and limited as specified","As shown in , an exemplary embodiment of a wide-multiply-matrix-extract-complex-doublets instruction (W.MUL.MAT.X with n set in rb) multiplies memory [m31 m30 m29 . . . m2 m1 m0] with vector [h g f e d c b a], yielding the products [am7+bm6+cm15+dm14+em23+fm22+gm31+hm30 . . . am2\u2212bm3+cm10\u2212dm11+em18\u2212fm19+gm26\u2212hm27 am1+bm0+cm9+dm8+em17+fm16+gm25+hm24 am0\u2212bm1+cm8\u2212dm9+em16\u2212f17+gm24 hm25], rounded and limited as specified.","An exemplary embodiment of the pseudocode  of the Wide Multiply Matrix Extract instruction is shown in . An exemplary embodiment of the exceptions  of the Wide Multiply Matrix Extract instruction is shown in .","Wide Multiply Matrix Extract Immediate","An exemplary embodiment of the Wide Multiply Matrix Extract Immediate instruction is shown in . In an exemplary embodiment, the Wide Multiply Matrix Extract Immediate instructions perform the same function as above, except that the extraction, operand format and size is controlled by fields in the instruction. This form encodes common forms of the above instruction without the need to initialize a register with the required control information. Controls within the instruction allow specification of signed, mixed signed, unsigned, and complex operands.","In an exemplary embodiment, these instructions take an address from a general register to fetch a large operand from memory, a second operand from a general register, perform a group of operations on partitions of bits in the operands, and catenate the results together, placing the result in a general register. An exemplary embodiment of the format  of the Wide Multiply Matrix Extract Immediate instruction is shown in .","An exemplary embodiment of the schematics  and  of the Wide Multiply Matrix Extract Immediate instruction is shown in . In an exemplary embodiment, the contents of register rc is used as a virtual address, and a value of specified size is loaded from memory. A second value is the contents of register rb. The values are partitioned into groups of operands of the size specified and are multiplied and summed in columns, producing a group of sums. The group of sums is rounded, limited, and extracted as specified, yielding a group of results, each of which is the size specified. The group of results is catenated and placed in register rd. All results are signed, N (nearest) rounding is used, and all results are limited to maximum representable signed values.","In an exemplary embodiment, the wide-multiply-extract-immediate-matrix instructions (W.MUL.MAT.X.I, W.MUL.MAT.X.I.C) perform a partitioned array multiply of up to 16384 bits, that is 128\u00d7128 bits. The width of the array can be limited to 128, 64, 32, or 16 bits, but not smaller than twice the group size, by adding one-half the desired size in bytes to the virtual address operand: 8, 4, 2, or 1. The array can be limited vertically to 128, 64, 32, or 16 bits, but not smaller than twice the group size, by adding one half the desired memory operand size in bytes to the virtual address operand.","In an exemplary embodiment, the virtual address must either be aligned to 2048\/gsize bytes (or 1024\/gsize for W.MUL.MAT.X.I.C), or must be the sum of an aligned address and one-half of the size of the memory operand in bytes and\/or one half of the size of the result in bytes. An aligned address must be an exact multiple of the size expressed in bytes. If the address is not valid an \u201caccess disallowed by virtual address\u201d exception occurs.","As shown in , an exemplary embodiment of a wide-multiply-extract-immediate-matrix-doublets instruction (W.MUL.MAT.X.I. 16) multiplies memory [m63 m62 m61 . . . m2 m1 m0] with vector [h g f e d c b a], yielding the products","[am7+bm 15+cm23+dm31+em39+fm47+gm55+hm63 . . .","am2+bm10+cm 18+dm26+em34+fm42+gm50+hm58","am1+bm9+cm17+dm25+em33+fm41+gm49+hm57 am0+bm8+cm16+dm24+em32+fm40+gm48+hm56], rounded and limited as specified","As shown in , an exemplary embodiment of a wide-multiply-matrix-extract-immediate-complex-doublets instruction (W.MUL.MAT.X.I.C.16) multiplies memory [m31 m30 m29 . . . m2 m1 m0] with vector [h g f e d c b a], yielding the products [am7+bm6+cm15+dm14+em23+fm22+gm31+hm30 . . . am2\u2212bm3+cm10\u2212dm11+em18\u2212am0\u2212bm1+cm8\u2212fm19+gm26\u2212hm27 am1+bm0+cm9+dm8+em17+fm16+gm25+hm24 am0\u2212bm1+cm8\u2212dm9+em16\u2212f17+gm24\u2212hm25], rounded and limited as specified.","An exemplary embodiment of the pseudocode  of the Wide Multiply Matrix Extract Immediate instruction is shown in . An exemplary embodiment of the exceptions  of the Wide Multiply Matrix Extract Immediate instruction is shown in .","Wide Multiply Matrix Floating-Point","An exemplary embodiment of the Wide Multiply Matrix Floating-point instruction is shown in . In an exemplary embodiment, the Wide Multiply Matrix Floating-point instructions perform a matrix multiply in the same form as above, except that the multiplies and additions are performed in floating-point arithmetic. Sizes of half (16-bit), single (32-bit), double (64-bit), and complex sizes of half, single and double can be specified within the instruction.","In an exemplary embodiment, these instructions take an address from a general register to fetch a large operand from memory, a second operand from a general register, perform a group of operations on partitions of bits in the operands, and catenate the results together, placing the result in a general register. An exemplary embodiment of the format  of the Wide Multiply Matrix Floating point instruction is shown in .","An exemplary embodiment of the schematics  and  of the Wide Multiply Matrix Floating-point instruction is shown in . In an exemplary embodiment, the contents of register rc is used as a virtual address, and a value of specified size is loaded from memory. A second value is the contents of register rb. The values are partitioned into groups of operands of the size specified. The second values are multiplied with the first values, then summed, producing a group of result values. The group of result values is catenated and placed in register rd.","In an exemplary embodiment, the wide-multiply-matrix-floating-point instructions (W.MUL.MAT.F, W.MUL.MAT.C.F) perform a partitioned array multiply of up to 16384 bits, that is 128\u00d7128 bits. The width of the array can be limited to 128, 64, 32 bits, but not smaller than twice the group size, by adding one-half the desired size in bytes to the virtual address operand: 8, 4, or 2. The array can be limited vertically to 128, 64, 32, or 16 bits, but not smaller than twice the group size, by adding one-half the desired memory operand size in bytes to the virtual address operand.","In an exemplary embodiment, the virtual address must either be aligned to 2048\/gsize bytes (or 1024\/gsize for W.MUL.MAT.C.F), or must be the sum of an aligned address and one half of the size of the memory operand in bytes and\/or one-half of the size of the result in bytes. An aligned address must be an exact multiple of the size expressed in bytes. If the address is not valid an \u201caccess disallowed by virtual address\u201d exception occurs.","As shown in , an exemplary embodiment of a wide-multiply-matrix-floating-point-half instruction (W.MUL.MAT.F) multiplies memory [m31 m30 . . . m1 m0] with vector [h g f e d c b a], yielding products [hm31+gm27+ . . . +bm7+am3 . . . hm28+gm24 . . . +bm4+am0].","As shown in , an exemplary embodiment of a wide-multiply-matrix-complex-floating-point-half instruction (W.MUL.MAT.F) multiplies memory [m15 m14 . . . m1 m0] with vector [h g f e d c b a], yielding products [hm14+gm15+ . . . +bm2+am3 . . . hm12+gm13+ . . . +bm0+am1\u2212hm13+gm12+ . . . \u2212bm1+am0].","An exemplary embodiment of the pseudocode  of the Wide Multiply Matrix Floating-point instruction is shown in . Additional pseudocode functions used by this and other floating point instructions is shown in Figure FLOAT-1. An exemplary embodiment of the exceptions  of the Wide Multiply Matrix Floating-point instruction is shown in .","Wide Multiply Matrix Galois","An exemplary embodiment of the Wide Multiply Matrix Galois instruction is shown in . In an exemplary embodiment, the Wide Multiply Matrix Galois instructions perform a matrix multiply in the same form as above, except that the multiples and additions are performed in Galois field arithmetic. A size of 8 bits can be specified within the instruction. The contents of a general register specify the polynomial with which to perform the Galois field remainder operation. The nature of the matrix multiplication is novel and described in detail below.","In an exemplary embodiment, these instructions take an address from a general register to fetch a large operand from memory, second and third operands from general registers, perform a group of operations on partitions of bits in the operands, and catenate the results together, placing the result in a general register. An exemplary embodiment of the format  of the Wide Multiply Matrix Galois instruction is shown in .","An exemplary embodiment of the schematic  of the Wide Multiply Matrix Galois instruction is shown in . In an exemplary embodiment, the contents of register re is used as a virtual address, and a value of specified size is loaded from memory. Second and third values are the contents of registers rd and rb. The values are partitioned into groups of operands of the size specified. The second values are multiplied as polynomials with the first value, producing a result which is reduced to the Galois field specified by the third value, producing a group of result values. The group of result values is catenated and placed in register ra.","In an exemplary embodiment, the wide-multiply-matrix-Galois-bytes instruction (W.MUL.MAT.G.8) performs a partitioned array multiply of up to 16384 bits, that is 128\u00d7128 bits. The width of the array can be limited to 128, 64, 32, or 16 bits, but not smaller than twice the group size of 8 bits, by adding one-half the desired size in bytes to the virtual address operand: 8, 4, 2, or 1. The array can be limited vertically to 128, 64, 32, or 16 bits, but not smaller than twice the group size of 8 bits, by adding one-half the desired memory operand size in bytes to the virtual address operand.","In an exemplary embodiment, the virtual address must either be aligned to 256 bytes, or must be the sum of an aligned address and one-half of the size of the memory operand in bytes and\/or one-half of the size of the result in bytes. An aligned address must be an exact multiple of the size expressed in bytes. If the address is not valid an \u201caccess disallowed by virtual address\u201d exception occurs.","As shown in , an exemplary embodiment of a wide-multiply-matrix-Galois-byte instruction (W.MUL.MAT.G.8) multiplies memory [m255 m254 . . . m1 m0] with vector [p o n m l k j i h g f e d c b a], reducing the result modulo polynomial [q], yielding products [(pm255+om247+ . . . +bm31+am15 mod q) (pm254+om246+ . . . +bm30+am14 mod q) . . . (pm248+om240+ . . . +bm16+am0 mod q)].","An exemplary embodiment of the pseudocode  of the Wide Multiply Matrix Galois instruction is shown in . An exemplary embodiment of the exceptions  of the Wide Multiply Matrix Galois instruction is shown in .","Memory Operands of Either Little-Endian or Big-Endian Conventional Byte Ordering","In another aspect of the invention, memory operands of either little-endian or big-endian conventional byte ordering are facilitated. Consequently, all Wide operand instructions are specified in two forms, one for little-endian byte ordering and one for big-endian byte ordering, as specified by a portion of the instruction. The byte order specifies to the memory system the order in which to deliver the bytes within units of the data path width (128 bits), as well as the order to place multiple memory words (128 bits) within a larger Wide operand.","Extraction of a High Order Portion of a Multiplier Product or Sum of Products","Another aspect of the present invention addresses extraction of a high order portion of a multiplier product or sum of products, as a way of efficiently utilizing a large multiplier array. Related U.S. Pat. No. 5,742,840 and U.S. Pat. No. 5,953,241 describe a system and method for enhancing the utilization of a multiplier array by adding specific classes of instructions to a general-purpose processor. This addresses the problem of making the most use of a large multiplier array that is fully used for high-precision arithmetic\u2014for example a 64\u00d764 bit multiplier is fully used by a 64-bit by 64-bit multiply, but only one quarter used for a 32-bit by 32-bit multiply) for (relative to the multiplier data width and registers) low-precision arithmetic operations. In particular, operations that perform a great many low-precision multiplies which are combined (added) together in various ways are specified. One of the overriding considerations in selecting the set of operations is a limitation on the size of the result operand. In an exemplary embodiment, for example, this size might be limited to on the order of 128 bits, or a single register, although no specific size limitation need exist.","The size of a multiply result, a product, is generally the sum of the sizes of the operands, multiplicands and multiplier. Consequently, multiply instructions specify operations in which the size of the result is twice the size of identically-sized input operands. For our prior art design, for example, a multiply instruction accepted two 64-bit register sources and produces a single 128-bit register-pair result, using an entire 64\u00d764 multiplier array for 64-bit symbols, or half the multiplier array for pairs of 32-bit symbols, or one quarter the multiplier array for quads of 16-bit symbols. For all of these cases, note that two register sources of 64 bits are combined, yielding a 128-bit result.","In several of the operations, including complex multiplies, convolve, and matrix multiplication, low-precision multiplier products are added together. The additions further increase the required precision. The sum of two products requires one additional bit of precision; adding four products requires two, adding eight products requires three, adding sixteen products requires four. In some prior designs, some of this precision is lost, requiring scaling of the multiplier operands to avoid overflow, further reducing accuracy of the result.","The use of register pairs creates an undesirable complexity, in that both the register pair and individual register values must be bypassed to subsequent instructions. As a result, with prior art techniques only half of the source operand 128-bit register values could be employed toward producing a single-register 128-bit result.","In the present invention, a high-order portion of the multiplier product or sum of products is extracted, adjusted by a dynamic shift amount from a general register or an adjustment specified as part of the instruction, and rounded by a control value from a register or instruction portion as round-to-nearest\/even, toward zero, floor, or ceiling. Overflows are handled by limiting the result to the largest and smallest values that can be accurately represented in the output result.","Extract Controlled by a Register","In the present invention, when the extract is controlled by a register, the size of the result can be specified, allowing rounding and limiting to a smaller number of bits than can fit in the result. This permits the result to be scaled to be used in subsequent operations without concern of overflow or rounding, enhancing performance.","Also in the present invention, when the extract is controlled by a register, a single register value defines the size of the operands, the shift amount and size of the result, and the rounding control. By placing all this control information in a single register, the size of the instruction is reduced over the number of bits that such a instruction would otherwise require, improving performance and enhancing flexibility of the processor.","The particular instructions included in this aspect of the present invention are Ensemble Convolve Extract, Ensemble Multiply Extract, Ensemble Multiply Add Extract and Ensemble Scale Add Extract.","Ensemble Extract Inplace","An exemplary embodiment of the Ensemble Extract Inplace instruction is shown in . In an exemplary embodiment, several of these instructions (Ensemble Convolve Extract, Ensemble Multiply Add Extract) are typically available only in forms where the extract is specified as part of the instruction. An alternative embodiment can incorporate forms of the operations in which the size of the operand, the shift amount and the rounding can be controlled by the contents of a general register (as they are in the Ensemble Multiply Extract instruction). The definition of this kind of instruction for Ensemble Convolve Extract, and Ensemble Multiply Add Extract would require four source registers, which increases complexity by requiring additional general-register read ports.","In an exemplary embodiment, these operations take operands from four registers, perform operations on partitions of bits in the operands, and place the concatenated results in a fourth register. An exemplary embodiment of the format and operation codes  of the Ensemble Extract Inplace instruction is shown in .","An exemplary embodiment of the schematics , , , and  of the Ensemble Extract Inplace instruction is shown in , D, E, and F. In an exemplary embodiment, the contents of registers rd, rc, rb, and ra are fetched. The specified operation is performed on these operands. The result is placed into register rd.","In an exemplary embodiment, for the E.CON.X instruction, the contents of registers rd and rc are catenated, as c\u2225d, and used as a first value. A second value is the contents of register rb. The values are partitioned into groups of operands of the size specified and are convolved, producing a group of values. The group of values is rounded, limited and extracted as specified, yielding a group of results that is the size specified. The group of results is catenated and placed in register rd.","In an exemplary embodiment, for the E.MUL.ADD.X instruction, the contents of registers rc and rb are partitioned into groups of operands of the size specified and are multiplied, producing a group of values to which are added the partitioned and extended contents of register rd. The group of values is rounded, limited and extracted as specified, yielding a group of results that is the size specified. The group of results is catenated and placed in register rd.","As shown in , in an exemplary embodiment, bits  . . .  of the contents of register ra specifies several parameters that control the manner in which data is extracted, and for certain operations, the manner in which the operation is performed. The position of the control fields allows for the source position to be added to a fixed control value for dynamic computation, and allows for the lower 16 bits of the control field to be set for some of the simpler extract cases by a single GCOPYI.128 instruction. The control fields are further arranged so that if only the low order 8 bits are non-zero, a 128-bit extraction with truncation and no rounding is performed.","In an exemplary embodiment, the table below describes the meaning of each label:",{"@attributes":{"id":"p-0238","num":"0237"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"label","bits","meaning"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"fsize","8","field size"]},{"entry":[{},"dpos","8","destination position"]},{"entry":[{},"x","1","extended vs. group size result"]},{"entry":[{},"s","1","signed vs. unsigned"]},{"entry":[{},"n","1","complex vs. real multiplication"]},{"entry":[{},"m","1","mixed-sign vs. same-sign multiplication"]},{"entry":[{},"l","1","limit: saturation vs. truncation"]},{"entry":[{},"rnd","2","rounding"]},{"entry":[{},"gssp","9","group size and source position"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"In an exemplary embodiment, the 9-bit gssp field encodes both the group size, gsize, and source position, spos, according to the formula gssp=512\u22124*gsize+spos. The group size, gsize, is a power of two in the range 1 . . . 128. The source position, spos, is in the range 0 . . . (2*gsize)\u22121.","In an exemplary embodiment, the values in the x, s, n, m, l, and rnd fields have the following meaning:",{"@attributes":{"id":"p-0241","num":"0240"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}},{"entry":["values","x","s","n","m","l","rnd"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","group","unsigned","real","same-sign","truncate","F"]},{"entry":["1","extended","signed","complex","mixed-sign","saturate","Z"]},{"entry":["2",{},{},{},{},{},"N"]},{"entry":["3",{},{},{},{},{},"C"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}}}},"Ensemble Multiply Add Extract","As shown in , an exemplary embodiment of an ensemble-multiply-add-extract-doublets instruction (E.MULADDX) multiplies vector rc [h g f e d c b a] with vector rb [p o n m l k j i], and adding vector rd [x w v u t s r q], yielding the result vector rd [hp+x go+w fn+v em+u dl+t ck+s bj+r ai+q], rounded and limited as specified by ra . . . .","As shown in , an exemplary embodiment of an ensemble-multiply-add-extract-doublets-complex instruction (E.MUL.X with n set) multiplies operand vector rc [h g f e d c b a] by operand vector rb [p o n m l k j i], yielding the result vector rd [gp+ho go\u2212hp en+fm em\u2212fn cl+dk ck\u2212dl aj+bi ai\u2212bj], rounded and limited as specified by ra . . . . Note that this instruction prefers an organization of complex numbers in which the real part is located to the right (lower precision) of the imaginary part.","Ensemble Convolve Extract","As shown in , an exemplary embodiment of an ensemble-convolve-extract-doublets instruction (ECON.X with n=0) convolves vector rc\u2225rd [x w v u t s r q p o n m l k j i] with vector rb [h g f e d c b a], yielding the products vector rd","[ax+bw+cv+du+et+fs+gr+hq . . . as+br+cq+dp+eo+fn+gm+hl","ar+bq+cp+do+en+fm+gl+hk aq+bp+co+dn+em+fl+gk+hj], rounded and limited as specified by ra.","As shown in , an exemplary embodiment of an ensemble-convolve-extract-complex-doublets instruction (ECON.X with n=1) convolves vector rd\u2225rc [x w v u t s r q p o n m l k j i] with vector rb [h g f e d c b a], yielding the products vector rd","[ax+bw+cv+du+et+fs+gr+hq . . . as\u2212t+cq\u2212dr+eo\u2212fp+gm\u2212hn ar+bq+cp+do+en+fm+gl+hk aq\u2212br+co\u2212dp+em\u2212fn+gk+hl], rounded and limited as specified by ra . . . .","An exemplary embodiment of the pseudocode  of Ensemble Extract Inplace instruction is shown in . In an exemplary embodiment, there are no exceptions for the Ensemble Extract Inplace instruction.","Ensemble Extract","An exemplary embodiment of the Ensemble Extract instruction is shown in . In an exemplary embodiment, these operations take operands from three registers, perform operations on partitions of bits in the operands, and place the catenated results in a fourth register. An exemplary embodiment of the format and operation codes  of the Ensemble Extract instruction is shown in .","An exemplary embodiment of the schematics , , , , , , and  of the Ensemble Extract Inplace instruction is shown in , D, E, F, G, H, and I. In an exemplary embodiment, the contents of registers rd, rc, and rb are fetched. The specified operation is performed on these operands. The result is placed into register ra.","As shown in , in an exemplary embodiment, bits  . . .  of the contents of register rb specifies several parameters that control the manner in which data is extracted, and for certain operations, the manner in which the operation is performed. The position of the control fields allows for the source position to be added to a fixed control value for dynamic computation, and allows for the lower 16 bits of the control field to be set for some of the simpler extract cases by a single GCOPYI.128 instruction. The control fields are further arranged so that if only the low order 8 bits are non-zero, a 128-bit extraction with truncation and no rounding is performed.","In an exemplary embodiment, the table below describes the meaning of each label:",{"@attributes":{"id":"p-0257","num":"0256"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"label","bits","meaning"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"fsize","8","field size"]},{"entry":[{},"dpos","8","destination position"]},{"entry":[{},"x","1","extended vs. group size result"]},{"entry":[{},"s","1","signed vs. unsigned"]},{"entry":[{},"n","1","complex vs. real multiplication"]},{"entry":[{},"m","1","merge vs. extract or mixed-sign vs."]},{"entry":[{},{},{},"same-sign multiplication"]},{"entry":[{},"l","1","limit: saturation vs. truncation"]},{"entry":[{},"rnd","2","rounding"]},{"entry":[{},"gssp","9","group size and source position"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"In an exemplary embodiment, the 9-bit gssp field encodes both the group size, gsize, and source position, spos, according to the formula gssp=512 4*gsize+spos. The group size, gsize, is a power of two in the range 1 . . . 128. The source position, spos, is in the range 0 . . . (2*gsize)\u22121.","In an exemplary embodiment, the values in the x, s, n, m, l, and rnd fields have the following meaning:",{"@attributes":{"id":"p-0260","num":"0259"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}},{"entry":["values","x","s","n","m","l","rnd"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","group","unsigned","real","extract\/","truncate","F"]},{"entry":[{},{},{},{},"same-sign"]},{"entry":["1","extended","signed","complex","merge\/","saturate","Z"]},{"entry":[{},{},{},{},"mixed-sign"]},{"entry":["2",{},{},{},{},{},"N"]},{"entry":["3",{},{},{},{},{},"C"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}}}},"In an exemplary embodiment, for the E.SCAL.ADD.X instruction, bits  . . .  of the contents of register rb specifies the multipliers for the multiplicands in registers rd and rc. Specifically, bits +2*gsize\u22121 . . . 64+gsize is the multiplier for the contents of register rd, and bits +gsize\u22121 . . . 64 is the multiplier for the contents of register rc.","Ensemble Multiply Extract","As shown in , an exemplary embodiment of an ensemble-multiply-extract-doublets instruction (E.MULX) multiplies vector rd [h g f e d c b a] with vector rc [p o n m l k j i], yielding the result vector ra [hp go fn em dl ck bj ai], rounded and limited as specified by rb.","As shown in , an exemplary embodiment of an ensemble-multiply-extract-doublets-complex instruction (E.MUL.X with n set) multiplies vector rd [h g f e d c b a] by vector rc [p o n m l k j i], yielding the result vector ra [gp+ho go\u2212hp en+fm em\u2212fn cl+dk ck\u2212dl aj+bi ai\u2212bj], rounded and limited as specified by rb. Note that this instruction prefers an organization of complex numbers in which the real part is located to the right (lower precision) of the imaginary part.","Ensemble Scale Add Extract","An aspect of the present invention defines the Ensemble Scale Add Extract instruction, that combines the extract control information in a register along with two values that are used as scalar multipliers to the contents of two vector multiplicands.","This combination reduces the number of registers that would otherwise be required, or the number of bits that the instruction would otherwise require, improving performance. Another advantage of the present invention is that the combined operation may be performed by an exemplary embodiment with sufficient internal precision on the summation node that no intermediate rounding or overflow occurs, improving the accuracy over prior art operation in which more than one instruction is required to perform this computation.","As shown in , an exemplary embodiment of an ensemble-scale-add-extract-doublets instruction (E.SCAL.ADD.X) multiplies vector rd [h g f e d c b a] with rb[r] and adds the product to the product of vector rc [p o n m l k j i] with rb[q], yielding the result [hr+pq gr+oq fr+nq er+mq dr+lq cr+kq br+jq ar+iq], rounded and limited as specified by rb.","As shown in , an exemplary embodiment of an ensemble-scale-add-extract-doublets-complex instruction (E.SCLADD.X with n set) multiplies vector rd [h g f e d c b a] with rb[t s] and adds the product to the product of vector rc [p o n m l k j i] with rb[r q], yielding the result [hs+gt+pq+or gs\u2212ht+oq\u2212pr fs+et+nq+mr es\u2212ft+mq\u2212nr ds+ct+lq+kr cs\u2212dt+kq\u2212lr bs+at +jq+ir as\u2212bt+iq\u2212jr], rounded and limited as specified by rb.","Ensemble Extract","As shown in , in an exemplary embodiment, for the E.EXTRACT instruction, when m=0 and x=0, the parameters specified by the contents of register rb are interpreted to select fields from double size symbols of the catenated contents of registers rd and rc, extracting values which are catenated and placed in register ra.","As shown in , in an exemplary embodiment, for an ensemble-merge-extract (E.EXTRACT when m=1), the parameters specified by the contents of register rb are interpreted to merge fields from symbols of the contents of register rd with the contents of register rc. The results are catenated and placed in register ra. The x field has no effect when m=1.","As shown in , in an exemplary embodiment, for an ensemble-expand-extract (E.EXTRACT when m=0 and x=1), the parameters specified by the contents of register rb are interpreted to extract fields from symbols of the contents of register rd. The results are catenated and placed in register ra. Note that the value of rc is not used.","An exemplary embodiment of the pseudocode  of Ensemble Extract instruction is shown in . In an exemplary embodiment, there are no exceptions for the Ensemble Extract instruction.","Reduction of Register Read Ports","Another alternative embodiment can reduce the number of register read ports required for implementation of instructions in which the size, shift and rounding of operands is controlled by a register. The value of the extract control register can be fetched using an additional cycle on an initial execution and retained within or near the functional unit for subsequent executions, thus reducing the amount of hardware required for implementation with a small additional performance penalty. The value retained would be marked invalid, causing a re-fetch of the extract control register, by instructions that modify the register, or alternatively, the retained value can be updated by such an operation. A re-fetch of the extract control register would also be required if a different register number were specified on a subsequent execution. It should be clear that the properties of the above two alternative embodiments can be combined.","Galois Field Arithmetic","Another aspect of the invention includes Galois field arithmetic, where multiplies are performed by an initial binary polynomial multiplication (unsigned binary multiplication with carries suppressed), followed by a polynomial modulo\/remainder operation (unsigned binary division with carries suppressed). The remainder operation is relatively expensive in area and delay. In Galois field arithmetic, additions are performed by binary addition with carries suppressed, or equivalently, a bitwise exclusive or operation. In this aspect of the present invention, a matrix multiplication is performed using Galois field arithmetic, where the multiplies and additions are Galois field multiples and additions.","Using prior art methods, a 16 byte vector multiplied by a 16\u00d716 byte matrix can be performed as 256 8-bit Galois field multiplies and 16*15=240 8-bit Galois field additions. Included in the 256 Galois field multiplies are 256 polynomial multiplies and 256 polynomial remainder operations.","By use of the present invention, the total computation is reduced significantly by performing 256 polynomial multiplies, 240 16-bit polynomial additions, and 16 polynomial remainder operations. Note that the cost of the polynomial additions has been doubled compared with the Galois field additions, as these are now 16-bit operations rather than 8-bit operations, but the cost of the polynomial remainder functions has been reduced by a factor of 16. Overall, this is a favorable tradeoff, as the cost of addition is much lower than the cost of remainder.","Decoupled Access from Execution Pipelines and Simultaneous Multithreading","In yet another aspect of the present invention, best shown in , the present invention employs both decoupled access from execution pipelines and simultaneous multithreading in a unique way. Simultaneous Multithreaded pipelines have been employed in prior art to enhance the utilization of data path units by allowing instructions to be issued from one of several execution threads to each functional unit (e.g. Dean M. Tullsen, Susan J. Eggers, and Henry M. Levy, \u201cSimultaneous Multithreading: Maximizing On Chip Parallelism,\u201d Proceedings of the 22nd Annual International Symposium on Computer Architecture, Santa Margherita Ligure, Italy, June, 1995).","Decoupled access from execution pipelines have been employed in prior art to enhance the utilization of execution data path units by buffering results from an access unit, which computes addresses to a memory unit that in turn fetches the requested items from memory, and then presenting them to an execution unit (e.g. J. E. Smith, \u201cDecoupled Access\/Execute Computer Architectures\u201d, Proceedings of the Ninth Annual International Symposium on Computer Architecture, Austin, Tex. (Apr. 26 29, 1982), pp. 112-119).","Compared to conventional pipelines, the Eggers prior art used an additional pipeline cycle before instructions could be issued to functional units, the additional cycle needed to determine which threads should be permitted to issue instructions. Consequently, relative to conventional pipelines, the prior art design had additional delay, including dependent branch delay.","The present invention contains individual access data path units, with associated register files, for each execution thread. These access units produce addresses, which are aggregated together to a common memory unit, which fetches all the addresses and places the memory contents in one or more buffers. Instructions for execution units, which are shared to varying degrees among the threads are also buffered for later execution. The execution units then perform operations from all active threads using functional data path units that are shared.","For instructions performed by the execution units, the extra cycle required for prior art simultaneous multithreading designs is overlapped with the memory data access time from prior art decoupled access from execution cycles, so that no additional delay is incurred by the execution functional units for scheduling resources. For instructions performed by the access units, by employing individual access units for each thread the additional cycle for scheduling shared resources is also eliminated.","This is a favorable tradeoff because, while threads do not share the access functional units, these units are relatively small compared to the execution functional units, which are shared by threads.","With regard to the sharing of execution units, the present invention employs several different classes of functional units for the execution unit, with varying cost, utilization, and performance. In particular, the G units, which perform simple addition and bitwise operations is relatively inexpensive (in area and power) compared to the other units, and its utilization is relatively high. Consequently, the design employs four such units, where each unit can be shared between two threads. The X unit, which performs a broad class of data switching functions is more expensive and less used, so two units are provided that are each shared among two threads. The T unit, which performs the Wide Translate instruction, is expensive and utilization is low, so the single unit is shared among all four threads. The E unit, which performs the class of Ensemble instructions, is very expensive in area and power compared to the other functional units, but utilization is relatively high, so we provide two such units, each unit shared by two threads.","In , four copies of an access unit are shown, each with an access instruction fetch queue A-Queue -, coupled to an access register file AR -, each of which is, in turn, coupled to two access functional units A -. The access units function independently for four simultaneous threads of execution. These eight access functional units A - produce results for access register files AR - and addresses to a shared memory system . The memory contents fetched from memory system  are combined with execute instructions not performed by the access unit and entered into the four execute instruction queues E-Queue -. Instructions and memory data from E-queue - are presented to execution register files -, which fetches execution register file source operands. The instructions are coupled to the execution unit arbitration unit Arbitration , that selects which instructions from the four threads are to be routed to the available execution units E  and , X  and , G - and -, and T . The execution register file source operands ER - are coupled to the execution units - using source operand buses - and to the execution units - using source operand buses -. The function unit result operands from execution units - are coupled to the execution register file using result bus  and the function units result operands from execution units - are coupled to the execution register file using result bus .","Improved Interprivilege Gateway","In a still further aspect of the present invention, an improved interprivilege gateway is described which involves increased parallelism and leads to enhanced performance. In related U.S. patent application Ser. No. 08\/541,416, a system and method is described for implementing an instruction that, in a controlled fashion, allows the transfer of control (branch) from a lower privilege level to a higher privilege level. The present invention is an improved system and method for a modified instruction that accomplishes the same purpose but with specific advantages.","Many processor resources, such as control of the virtual memory system itself, input and output operations, and system control functions are protected from accidental or malicious misuse by enclosing them in a protective, privileged region. Entry to this region must be established only though particular entry points, called gateways, to maintain the integrity of these protected regions.","Prior art versions of this operation generally load an address from a region of memory using a protected virtual memory attribute that is only set for data regions that contain valid gateway entry points, then perform a branch to an address contained in the contents of memory. Basically, three steps were involved: load, then branch and check. Compared to other instructions, such as register to register computation instructions and memory loads and stores, and register based branches, this is a substantially longer operation, which introduces delays and complexity to a pipelined implementation.","In the present invention, the branch-gateway instruction performs two operations in parallel: 1) a branch is performed to the Contents of register  and ) a load is performed using the contents of register , using a specified byte order (little-endian) and a specified size (64 bits). If the value loaded from memory does not equal the contents of register , the instruction is aborted due to an exception. In addition, 3) a return address (the next sequential instruction address following the branch-gateway instruction) is written into register , provided the instruction is not aborted. This approach essentially uses a first instruction to establish the requisite permission to allow user code to access privileged code, and then a second instruction is permitted to branch directly to the privileged code because of the permissions issued for the first instruction.","In the present invention, the new privilege level is also contained in register , and the second parallel operation does not need to be performed if the new privilege level is not greater than the old privilege level. When this second operation is suppressed, the remainder of the instruction performs an identical function to a branch-link instruction, which is used for invoking procedures that do not require an increase in privilege. The advantage that this feature brings is that the branch-gateway instruction can be used to call a procedure that may or may not require an increase in privilege.","The memory load operation verifies with the virtual memory system that the region that is loaded has been tagged as containing valid gateway data. A further advantage of the present invention is that the called procedure may rely on the fact that register  contains the address that the gateway data was loaded from, and can use the contents of register  to locate additional data or addresses that the procedure may require. Prior art versions of this instruction required that an additional address be loaded from the gateway region of memory in order to initialize that address in a protected manner\u2014the present invention allows the address itself to be loaded with a \u201cnormal\u201d load operation that does not require special protection.","The present invention allows a \u201cnormal\u201d load operation to also load the contents of register  prior to issuing the branch-gateway instruction. The value may be loaded from the same memory address that is loaded by the branch-gateway instruction, because the present invention contains a virtual memory system in which the region may be enabled for normal load operations as well as the special \u201cgateway\u201d load operation performed by the branch-gateway instruction.","Improved Interprivilege Gateway\u2014System and Privileged Library Calls","An exemplary embodiment of the System and Privileged Library Calls is shown in . An exemplary embodiment of the schematic  of System and Privileged Library Calls is shown in . In an exemplary embodiment, it is an objective to make calls to system facilities and privileged libraries as similar as possible to normal procedure calls as described above. Rather than invoke system calls as an exception, which involves significant latency and complication, a modified procedure call in which the process privilege level is quietly raised to the required level is used. To provide this mechanism safely, interaction with the virtual memory system is required.","In an exemplary embodiment, such a procedure must not be entered from anywhere other than its legitimate entry point, to prohibit entering a procedure after the point at which security checks are performed or with invalid register contents, otherwise the access to a higher privilege level can lead to a security violation. In addition, the procedure generally must have access to memory data, for which addresses must be produced by the privileged code. To facilitate generating these addresses, the branch-gateway instruction allows the privileged code procedure to rely on the fact that a single register has been verified to contain a pointer to a valid memory region.","In an exemplary embodiment, the branch-gateway instruction ensures both that the procedure is invoked at a proper entry point, and that other registers such as the data pointer and stack pointer can be properly set. To ensure this, the branch-gateway instruction retrieves a \u201cgateway\u201d directly from the protected virtual memory space. The gateway contains the virtual address of the entry point of the procedure and the target privilege level. A gateway can only exist in regions of the virtual address space designated to contain them, and can only be used to access privilege levels at or below the privilege level at which the memory region can be written to ensure that a gateway cannot be forged.","In an exemplary embodiment, the branch-gateway instruction ensures that register  (dp) contains a valid pointer to the gateway for this target code address by comparing the contents of register  (1p) against the gateway retrieved from memory and causing an exception trap if they do not match. By ensuring that register  points to the gateway, auxiliary information, such as the data pointer and stack pointer can be set by loading values located by the contents of register . For example, the eight bytes following the gateway may be used as a pointer to a data region for the procedure.","In an exemplary embodiment, before executing the branch-gateway instruction, register  must be set to point at the gateway, and register  must be set to the address of the target code address plus the desired privilege level. A \u201cL.I.64.L.A r0=r1,0\u201d instruction is one way to set register , if register  has already been set, but any means of getting the correct value into register  is permissible.","In an exemplary embodiment, similarly, a return from a system or privileged routine involves a reduction of privilege. This need not be carefully controlled by architectural facilities, so a procedure may freely branch to a less-privileged code address. Normally, such a procedure restores the stack frame, then uses the branch-down instruction to return.","An exemplary embodiment of the typical dynamic-linked, inter-gateway calling sequence  is shown in . In an exemplary embodiment, the calling sequence is identical to that of the inter-module calling sequence shown above, except for the use of the B.GATE instruction instead of a B.LINK instruction. Indeed, if a B.GATE instruction is used when the privilege level in the lp register is not higher than the current privilege level, the B.GATE instruction performs an identical function to a B.LINK.","In an exemplary embodiment, the callee, if it uses a stack for local variable allocation, cannot necessarily trust the value of the sp passed to it, as it can be forged. Similarly, any pointers which the callee provides should not be used directly unless it they are verified to point to regions which the callee should be permitted to address. This can be avoided by defining application programming interfaces (APIs) in which all values are passed and returned in registers, or by using a trusted, intermediate privilege wrapper routine to pass and return parameters. The method described below can also be used.","In an exemplary embodiment, it can be useful to have highly privileged code call less-privileged routines. For example, a user may request that errors in a privileged routine be reported by invoking a user-supplied error-logging routine. To invoke the procedure, the privilege can be reduced via the branch-down instruction. The return from the procedure actually requires an increase in privilege, which must be carefully controlled. This is dealt with by placing the procedure call within a lower-privilege procedure wrapper, which uses the branch-gateway instruction to return to the higher privilege region after the call through a secure re-entry point. Special care must be taken to ensure that the less-privileged routine is not permitted to gain unauthorized access by corruption of the stack or saved registers, such as by saving all registers and setting up a new stack frame (or restoring the original lower-privilege stack) that may be manipulated by the less-privileged routine. Finally, such a technique is vulnerable to an unprivileged routine attempting to use the re-entry point directly, so it may be appropriate to keep a privileged state variable which controls permission to enter at the re-entry point.","Improved Interprivilege Gateway\u2014Branch Gateway","An exemplary embodiment of the Branch Gateway instruction is shown in . In an exemplary embodiment, this operation provides a secure means to call a procedure, including those at a higher privilege level. An exemplary embodiment of the format and operation codes  of the Branch Gateway instruction is shown in .","An exemplary embodiment of the schematic  of the Branch Gateway instruction is shown in . In an exemplary embodiment, the contents of register rb is a branch address in the high-order 62 bits and a new privilege level in the low-order 2 bits. A branch and link occurs to the branch address, and the privilege level is raised to the new privilege level. The high-order 62 bits of the successor to the current program counter is catenated with the 2-bit current execution privilege and placed in register .","In an exemplary embodiment, if the new privilege level is greater than the current privilege level, an octlet of memory data is fetched from the address specified by register , using the little-endian byte order and a gateway access type. A GatewayDisallowed exception occurs if the original contents of register  do not equal the memory data.","In an exemplary embodiment, if the new privilege level is the same as the current privilege level, no checking of register  is performed.","In an exemplary embodiment, an AccessDisallowed exception occurs if the new privilege level is greater than the privilege level required to write the memory data, or if the old privilege level is lower than the privilege required to access the memory data as a gateway, or if the access is not aligned on an 8-byte boundary.","In an exemplary embodiment, a ReservedInstruction exception occurs if the rc field is not one or the rd field is not zero.","In an exemplary embodiment, in the example in , a gateway from level 0 to level 2 is illustrated. The gateway pointer, located by the contents of register rc (1), is fetched from memory and compared against the contents of register rb (0). The instruction may only complete if these values are equal. Concurrently, the contents of register rb (0) is placed in the program counter and privilege level, and the address of the next sequential address and privilege level is placed into register rd (0). Code at the target of the gateway locates the data pointer at an offset from the gateway pointer (register ), and fetches it into register , making a data region available. A stack pointer may be saved and fetched using the data region, another region located from the data region, or a data region located as an offset from the original gateway pointer.","In an exemplary embodiment, this instruction gives the target procedure the assurances that register  contains a valid return address and privilege level, that register  points to the gateway location, and that the gateway location is octlet aligned. Register  can then be used to securely reach values in memory. If no sharing of literal pools is desired, register  may be used as a literal pool pointer directly. If sharing of literal pools is desired, register  may be used with an appropriate offset to load a new literal pool pointer; for example, with a one cache line offset from the register . Note that because the virtual memory system operates with cache line granularity, that several gateway locations must be created together.","In an exemplary embodiment, software must ensure that an attempt to use any octlet within the region designated by virtual memory as gateway either functions properly or causes a legitimate exception. For example, if the adjacent octlets contain pointers to literal pool locations, software should ensure that these literal pools are not executable, or that by virtue of being aligned addresses, cannot raise the execution privilege level. If register  is used directly as a literal pool location, software must ensure that the literal pool locations that are accessible as a gateway do not lead to a security violation.","In an exemplary embodiment, register  contains a valid return address and privilege level, the value is suitable for use directly in the Branch down (B.DOWN) instruction to return to the gateway callee.","An exemplary embodiment of the pseudocode  of the Branch Gateway instruction is shown in . An exemplary embodiment of the exceptions  of the Branch Gateway instruction is shown in .","Group Add","In accordance with one embodiment of the invention, the processor handles a variety fix-point, or integer, group operations. For example,  presents various examples of Group Add instructions accommodating different operand sizes, such as a byte (8 bits), doublet (16 bits), quadlet (32 bits), octlet (64 bits), and hexlet (128 bits).  illustrate an exemplary embodiment of a format and operation codes that can be used to perform the various Group Add instructions shown in . As shown in , in this exemplary embodiment, the contents of registers rc and rb are partitioned into groups of operands of the size specified and added, and if specified, checked for overflow or limited, yielding a group of results, each of which is the size specified. The group of results is catenated and placed in register rd. While the use of two operand registers and a different result register is described here and elsewhere in the present specification, other arrangements, such as the use of immediate values, may also be implemented.","In the present embodiment, for example, if the operand size specified is a byte (8 bits), and each register is 128-bit wide, then the content of each register may be partitioned into 16 individual operands, and 16 different individual add operations may take place as the result of a single Group Add instruction. Other instructions involving groups of operands may perform group operations in a similar fashion.","Group Set and Group Subtract","Similarly,  presents various examples of Group Set instructions and Group Subtract instructions accommodating different operand sizes.  illustrate an exemplary embodiment of a format and operation codes that can be used to perform the various Group Set instructions and Group Subtract instructions. As shown in , in this exemplary embodiment, the contents of registers rc and rb are partitioned into groups of operands of the size specified and for Group Set instructions are compared for a specified arithmetic condition or for Group Subtract instructions are subtracted, and if specified, checked for overflow or limited, yielding a group of results, each of which is the size specified. The group of results is catenated and placed in register rd.","Ensemble Convolve, Divide, Multiply, Multiply Sum","In the present embodiment, other fix-point group operations are also available.  presents various examples of Ensemble Convolve, Ensemble Divide, Ensemble Multiply, and Ensemble Multiply Sum instructions accommodating different operand sizes.  illustrate an exemplary embodiment of a format and operation codes that can be used to perform the various Ensemble Convolve, Ensemble Divide, Ensemble Multiply and Ensemble Multiply Sum instructions. As shown in , in this exemplary embodiment, the contents of registers rc and rb are partitioned into groups of operands of the size specified and convolved or divided or multiplied, yielding a group of results, or multiplied and summed to a single result. The group of results is catenated and placed, or the single result is placed, in register rd.","Ensemble Floating-Point Add, Divide, Multiply, and Subtract","In accordance with one embodiment of the invention, the processor also handles a variety floating-point group operations accommodating different operand sizes. Here, the different operand sizes may represent floating point operands of different precisions, such as half-precision (16 bits), single-precision (32 bits), double-precision (64 bits), and quad-precision (128 bits).  illustrates exemplary functions that are defined for use within the detailed instruction definitions in other sections and figures. In the functions set forth in , an internal format represents infinite-precision floating-point values as a four-element structure consisting of (1) s (sign bit): 0 for positive, 1 for negative, (2) t (type): NORM, ZERO, SNAN, QNAN, INFINITY, (3) e (exponent), and (4) f: (fraction). The mathematical interpretation of a normal value places the binary point at the units of the fraction, adjusted by the exponent: (\u22121)^*(2^)*f. The function F converts a packed IEEE floating-point value into internal format. The function PackF converts an internal format back into IEEE floating-point format, with rounding and exception control.",{"@attributes":{"id":"p-0329","num":"0328"},"figref":["FIGS. 30A and 31A","FIGS. 30B-C","FIGS. 30B-C"],"b":["31","31"]},"In the present embodiment, the operation is rounded using the specified rounding option or using round-to-nearest if not specified. If a rounding option is specified, the operation raises a floating-point exception if a floating-point invalid operation, divide by zero, overflow, or underflow occurs, or when specified, if the result is inexact. If a rounding option is not specified, floating-point exceptions are not raised, and are handled according to the default rules of IEEE 754.","Ensemble Scale-Add Floating-point","A novel instruction, Ensemble-Scale-Add improves processor performance by performing two sets of parallel multiplications and pairwise summing the products. This improves performance for operations in which two vectors must be scaled by two independent values and then summed, providing two advantages over nearest prior art operations of a fused-multiply-add. To perform this operation using prior art instructions, two instructions would be needed, an ensemble-multiply for one vector and one scaling value, and an ensemble-multiply-add for the second vector and second scaling value, and these operations are clearly dependent. In contrast, the present invention fuses both the two multiplies and the addition for each corresponding elements of the vectors into a single operation. The first advantage achieved is improved performance, as in an exemplary embodiment the combined operation performs a greater number of multiplies in a single operation, thus improving utilization of the partitioned multiplier unit. The second advantage achieved is improved accuracy, as an exemplary embodiment may compute the fused operation with sufficient intermediate precision so that no intermediate rounding the products is required.","An exemplary embodiment of the Ensemble Scale-Add Floating-point instruction is shown in . In an exemplary embodiment, these operations take three values from registers, perform a group of floating-point arithmetic operations on partitions of bits in the operands, and place the concatenated results in a register. An exemplary embodiment of the format  of the Ensemble Scale-Add Floating-point instruction is shown in .","In an exemplary embodiment, the contents of registers rd and rc are taken to represent a group of floating-point operands. Operands from register rd are multiplied with a floating-point operand taken from the least-significant bits of the contents of register rb and added to operands from register rc multiplied with a floating-point operand taken from the next least-significant bits of the contents of register rb. The results are rounded to the nearest representable floating-point value in a single floating-point operation. Floating-point exceptions are not raised, and are handled according to the default rules of IEEE 754. The results are catenated and placed in register ra.","An exemplary embodiment of the pseudocode  of the Ensemble Scale-Add Floating-point instruction is shown in . In an exemplary embodiment, there are no exceptions for the Ensemble Scale-Add Floating-point instruction.","Performing a Three-Input Bitwise Boolean Operation in a Single Instruction (Group Boolean)","In a further aspect of the present invention, a system and method is provided for performing a three-input bitwise Boolean operation in a single instruction. A novel method is used to encode the eight possible output states of such an operation into only seven bits, and decoding these seven bits back into the eight states.","An exemplary embodiment of the Group Boolean instruction is shown in . In an exemplary embodiment, these operations take operands from three registers, perform boolean operations on corresponding bits in the operands, and place the concatenated results in the third register. An exemplary embodiment of the format  of the Group Boolean instruction is shown in .","An exemplary embodiment of a procedure  of Group Boolean instruction is shown in . In an exemplary embodiment, three values are taken from the contents of registers rd, rc and rb. The ih and il fields specify a function of three bits, producing a single bit result. The specified function is evaluated for each bit position, and the results are catenated and placed in register rd. In an exemplary embodiment, register rd is both a source and destination of this instruction.","In an exemplary embodiment, the function is specified by eight bits, which give the result for each possible value of the three source bits in each bit position:",{"@attributes":{"id":"p-0341","num":"0340"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"d","1 1 1 1 0 0 0 0"]},{"entry":[{},"c","1 1 0 0 1 1 0 0"]},{"entry":[{},"b","1 0 1 0 1 0 1 0"]},{"entry":[{},"f(d,c,b)","ffffffff"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In an exemplary embodiment, a function can be modified by rearranging the bits of the immediate value. The table below shows how rearrangement of immediate value fcan reorder the operands d,c,b for the same function.",{"@attributes":{"id":"p-0343","num":"0342"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"operation","immediate"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"f(d,c,b)","ffffffff"]},{"entry":[{},"f(c,d,b)","ffffffff"]},{"entry":[{},"f(d,b,c)","ffffffff"]},{"entry":[{},"f(b,c,d)","ffffffff"]},{"entry":[{},"f(c,b,d)","ffffffff"]},{"entry":[{},"f(b,d,c)","ffffffff"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In an exemplary embodiment, by using such a rearrangement, an operation of the form: b=\u0192(d,c,b) can be recoded into a legal form: b=\u0192(b,d,c). For example, the function: b=\u0192(d,c,b)=d?c:b cannot be coded, but the equivalent function: d=c?b:d can be determined by rearranging the code for d=\u0192(d,c,b)=d?c: b, which is 11001010, according to the rule for \u0192(d,c,b)\u0192(c,b,d), to the code 11011000.","Encoding","In an exemplary embodiment, some special characteristics of this rearrangement is the basis of the manner in which the eight function specification bits are compressed to seven immediate bits in this instruction. As seen in the table above, in the general case, a rearrangement of operands from \u0192(d,c,b) to \u0192(d,b,c).(interchanging rc and rb) requires interchanging the values of fand fand the values of fand f.","In an exemplary embodiment, among the 256 possible functions which this instruction can perform, one quarter of them (64 functions) are unchanged by this rearrangement. These functions have the property that f=fand f=f. The values of rc and rb (Note that rc and rb are the register specifiers, not the register contents) can be freely interchanged, and so are sorted into rising or falling order to indicate the value of f. (A special case arises when rc=rb, so the sorting of rc and rb cannot convey information. However, as only the values f, f, f, and fcan ever result in this case, f, f, f, and fneed not be coded for this case, so no special handling is required.) These functions are encoded by the values of f, f, f, f, and fin the immediate field and fby whether rc>rb, thus using 32 immediate values for 64 functions.","In an exemplary embodiment, another quarter of the functions have f=1 and f=0. These functions are recoded by interchanging rc and rb, fand f, fand f. They then share the same encoding as the quarter of the functions where f=0 and f=1, and are encoded by the values of f, f, f, f, f, and fin the immediate field, thus using 64 immediate values for 128 functions.","In an exemplary embodiment, the remaining quarter of the functions have f=fand f\u2260f. The half of these in which f=1 and f=0 are recoded by interchanging rc and rb, fand f, fand f. They then share the same encoding as the eighth of the functions where f=0 and f=1, and are encoded by the values of f, f, f, f, and fin the immediate field, thus using 32 immediate values for 64 functions.","In an exemplary embodiment, the function encoding is summarized by the table:",{"@attributes":{"id":"p-0351","num":"0350"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"18"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"12","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"13","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"14","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"15","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"16","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"17","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"18","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"18","align":"center","rowsep":"1"}}},{"entry":["f","f","f","f","f","f","f","f","trc > trb","ih","il","il","il","il","il","il","rc","rb"]},{"entry":{"@attributes":{"namest":"1","nameend":"18","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"f",{},{},{},"f",{},"f","0","0","f","f","f","f","f","trc","trb"]},{"entry":[{},{},"f",{},{},{},"f",{},"~f","0","0","f","f","f","f","f","trb","trc"]},{"entry":[{},{},"f",{},{},"0","1",{},{},"0","1","f","f","f","f","f","trc","trb"]},{"entry":[{},{},"f",{},{},"1","0",{},{},"0","1","f","f","f","f","f","trb","trc"]},{"entry":[{},"0","1",{},{},{},{},{},{},"1","f","f","f","f","f","f","trc","trb"]},{"entry":[{},"1","0",{},{},{},{},{},{},"1","f","f","f","f","f","f","trb","trc"]},{"entry":{"@attributes":{"namest":"1","nameend":"18","align":"center","rowsep":"1"}}}]}}}}},"In an exemplary embodiment, the function decoding is summarized by the table:",{"@attributes":{"id":"p-0353","num":"0352"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"16"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"12","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"13","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"14","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"15","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"16","colwidth":"21pt","align":"center"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"16","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ih","il","il","il","il","il","il","rc > rb","f","f","f","f","f","f","f","f"]},{"entry":["0","0",{},{},{},{},{},"0","il","il","il","il","il","0","0","il"]},{"entry":["0","0",{},{},{},{},{},"1","il","il","il","il","il","1","1","il"]},{"entry":["0","1",{},{},{},{},{},{},"il","il","il","il","il","0","1","il"]},{"entry":["1",{},{},{},{},{},{},{},"il","0","1","il","il","il","il","il"]},{"entry":{"@attributes":{"namest":"1","nameend":"16","align":"center","rowsep":"1"}}}]}}}}},"From the foregoing discussion, it can be appreciated that an exemplary embodiment of a compiler or assembler producing the encoded instruction performs the steps above to encode the instruction, comparing the f6 and f5 values and the f2 and f1 values of the immediate field to determine which one of several means of encoding the immediate field is to be employed, and that the placement of the trb and trc register specifiers into the encoded instruction depends on the values of f2 (or f1) and f6 (or f5).","An exemplary embodiment of the pseudocode  of the Group Boolean instruction is shown in . It can be appreciated from the code that an exemplary embodiment of a circuit that decodes this instruction produces the f2 and f1 values, when the immediate bits ih and il5 are zero, by an arithmetic comparison of the register specifiers rc and rb, producing a one (1) value for f2 and f1 when rc>rb. In an exemplary embodiment, there are no exceptions for the Group Boolean instruction.","Improving the Branch Prediction of Simple Repetitive Loops of Code","In yet a further aspect to the present invention, a system and method is described for improving the branch prediction of simple repetitive loops of code. In such a simple loop, the end of the loop is indicated by a conditional branch backward to the beginning of the loop. The condition branch of such a loop is taken for each iteration of the loop except the final iteration, when it is not taken. Prior art branch prediction systems have employed finite state machine operations to attempt to properly predict a majority of such conditional branches, but without specific information as to the number of times the loop iterates, will make an error in prediction when the loop terminates.","The system and method of the present invention includes providing a count field for indicating how many times a branch is likely to be taken before it is not taken, which enhances the ability to properly predict both the initial and final branches of simple loops when a compiler can determine the number of iterations that the loop will be performed. This improves performance by avoiding misprediction of the branch at the end of a loop when the loop terminates and instruction execution is to continue beyond the loop, as occurs in prior art branch prediction hardware.","Branch Hint","An exemplary embodiment of the Branch Hint instruction is shown in . In an exemplary embodiment, this operation indicates a future branch location specified by a register.","In an exemplary embodiment, this instruction directs the instruction fetch unit of the processor that a branch is likely to occur count times at simm instructions following the current successor instruction to the address specified by the contents of register rd. An exemplary embodiment of the format  of the Branch Hint instruction is shown in .","In an exemplary embodiment, after branching count times, the instruction fetch unit presumes that the branch at simm instructions following the current successor instruction is not likely to occur. If count is zero, this hint directs the instruction fetch unit that the branch is likely to occur more than 63 times.","In an exemplary embodiment, an Access disallowed exception occurs if the contents of register rd is not aligned on a quadlet boundary.","An exemplary embodiment of the pseudocode  of the Branch Hint instruction is shown in . An exemplary embodiment of the exceptions  of the Branch Hint instruction is shown in .","Incorporating Floating Point Information into Processor Instructions","In a still further aspect of the present invention, a technique is provided for incorporating floating point information into processor instructions. In related U.S. Pat. No. 581,2439, a system and method are described for incorporating control of rounding and exceptions for floating-point instructions into the instruction itself. The present invention extends this invention to include separate instructions in which rounding is specified, but default handling of exceptions is also specified, for a particular class of floating-point instructions.","Ensemble Sink Floating-Point","In an exemplary embodiment, a Ensemble Sink Floating-point instruction, which converts floating-point values to integral values, is available with control in the instruction that include all previously specified combinations (default-near rounding and default exceptions, Z round-toward-zero and trap on exceptions, N\u2014round to nearest and trap on exceptions, F\u2014floor rounding (toward minus infinity) and trap on exceptions, C\u2014ceiling rounding (toward plus infinity) and trap on exceptions, and X\u2014trap on inexact and other exceptions), as well as three new combinations (Z.D\u2014round toward zero and default exception handling, F.D\u2014floor rounding and default exception handling, and C.D\u2014ceiling rounding and default exception handling). (The other combinations: N.D is equivalent to the default, and X.D\u2014trap on inexact but default handling for other exceptions is possible but not particularly valuable).","An exemplary embodiment of the Ensemble Sink Floating-point instruction is shown in . In an exemplary embodiment, these operations take one value from a register, perform a group of floating-point arithmetic conversions to integer on partitions of bits in the operands, and place the concatenated results in a register. An exemplary embodiment of the operation codes, selection, and format  of Ensemble Sink Floating-point instruction is shown in .","In an exemplary embodiment, the contents of register rc is partitioned into floating-point operands of the precision specified and converted to integer values. The results are catenated and placed in register rd.","In an exemplary embodiment, the operation is rounded using the specified rounding option or using round-to-nearest if not specified. If a rounding option is specified, unless default exception handling is specified, the operation raises a floating-point exception if a floating-point invalid operation, divide by zero, overflow, or underflow occurs, or when specified, if the result is inexact. If a rounding option is not specified or if default exception handling is specified, floating-point exceptions are not raised, and are handled according to the default rules of IEEE 754.","An exemplary embodiment of the pseudocode  of the Ensemble Sink Floating-point instruction is shown in . An exemplary embodiment of the exceptions  of the Ensemble Sink Floating-point instruction is shown in .","An exemplary embodiment of the pseudocode  of the Floating-point instructions is shown in .","Crossbar Compress, Expand, Rotate, and Shift","In one embodiment of the invention, crossbar switch units such as units  and  perform data handling operations, as previously discussed. As shown in , such data handling operations may include various examples of Crossbar Compress, Crossbar Expand, Crossbar Rotate, and Crossbar Shift operations.  illustrate an exemplary embodiment of a format and operation codes that can be used to perform the various Crossbar Compress, Crossbar Rotate, Crossbar Expand, and Crossbar Shift instructions. As shown in , in this exemplary embodiment, the contents of register rc are partitioned into groups of operands of the size specified, and compressed, expanded, rotated or shifted by an amount specified by a portion of the contents of register rb, yielding a group of results. The group of results is catenated and placed in register rd.","Various Group Compress operations may convert groups of operands from higher precision data to lower precision data. An arbitrary half-sized sub-field of each bit field can be selected to appear in the result. For example,  shows an X.COMPRESS rd=rc,16,4 operation, which performs a selection of bits  . . .  of each quadlet in a hexlet. Various Group Shift operations may allow shifting of groups of operands by a specified number of bits, in a specified direction, such as shift right or shift left. As can be seen in , certain Group Shift Left instructions may also involve clearing (to zero) empty low order bits associated with the shift, for each operand. Certain Group Shift Right instructions may involve clearing (to zero) empty high order bits associated with the shift, for each operand. Further, certain Group Shift Right instructions may involve filling empty high order bits associated with the shift with copies of the sign bit, for each operand.","Extract","In one embodiment of the invention, data handling operations may also include a Crossbar Extract instruction.  illustrate an exemplary embodiment of a format and operation codes that can be used to perform the Crossbar Extract instruction. As shown in , in this exemplary embodiment, the contents of registers rd, rc, and rb are fetched. The specified operation is performed on these operands. The result is placed into register ra.","The Crossbar Extract instruction allows bits to be extracted from different operands in various ways. Specifically, bits  . . .  of the contents of register rb specifies several parameters which control the manner in which data is extracted, and for certain operations, the manner in which the operation is performed. The position of the control fields allows for the source position to be added to a fixed control value for dynamic computation, and allows for the lower 16 bits of the control field to be set for some of the simpler extract cases by a single GCOPYI.128 instruction (see appendix). The control fields are further arranged so that if only the low order 8 bits are non-zero, a 128-bit extraction with truncation and no rounding is performed.",{"@attributes":{"id":"p-0380","num":"0379"},"chemistry":{"@attributes":{"id":"CHEM-US-00001","num":"00001"},"img":{"@attributes":{"id":"EMI-C00001","he":"10.84mm","wi":"61.98mm","file":"US07301541-20071127-C00001.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"The table below describes the meaning of each label:",{"@attributes":{"id":"p-0382","num":"0381"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"label","bits","meaning"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"fsize","8","field size"]},{"entry":[{},"dpos","8","destination position"]},{"entry":[{},"x","1","reserved"]},{"entry":[{},"s","1","signed vs. unsigned"]},{"entry":[{},"n","1","reserved"]},{"entry":[{},"m","1","merge vs. extract"]},{"entry":[{},"l","1","reserved"]},{"entry":[{},"rnd","2","reserved"]},{"entry":[{},"gssp","9","group size and source position"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"The 9-bit gssp field encodes both the group size, gsize, and source position, spos, according to the formula gssp=512\u22124*gsize+spos. The group size, gsize, is a power of two in the range 1 . . . 128. The source position, spos, is in the range 0 . . . (2*gsize)\u22121.","The values in the s, n, m, l, and rnd fields have the following meaning:",{"@attributes":{"id":"p-0385","num":"0384"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"7pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["values","s","n","m","l","rnd"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","unsigned",{},"extract",{},{}]},{"entry":["1","signed",{},"merge"]},{"entry":"2"},{"entry":"3"},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}}}},"As shown in , for the X.EXTRACT instruction, when m=0, the parameters are interpreted to select a fields from the catenated contents of registers rd and rc, extracting values which are catenated and placed in register ra. As shown in , for a crossbar-merge-extract (X.EXTRACT when m=1), the parameters are interpreted to merge a fields from the contents of register rd with the contents of register rc. The results are catenated and placed in register ra.","Shuffle","As shown in , in one embodiment of the invention, data handling operations may also include various Shuffle instructions, which allow the contents of registers to be partitioned into groups of operands and interleaved in a variety of ways.  illustrate an exemplary embodiment of a format and operation codes that can be used to perform the various Shuffle instructions. As shown in , in this exemplary embodiment, one of two operations is performed, depending on whether the rc and rb fields are equal. Also,  and the description below illustrate the format of and relationship of the rd, rc, rb, op, v, w, h, and size fields.","In the present embodiment, if the rc and rb fields are equal, a 128-bit operand is taken from the contents of register rc. Items of size v are divided into w piles and shuffled together, within groups of size bits, according to the value of op. The result is placed in register rd.","Further, if the rc and rb fields are not equal, the contents of registers rc and rb are catenated into a 256-bit operand. Items of size v are divided into w piles and shuffled together, according to the value of op. Depending on the value of h, a sub-field of op, the low 128 bits (h=0), or the high 128 bits (h=1) of the 256-bit shuffled contents are selected as the result. The result is placed in register rd.","As shown in , an example of a crossbar 4-way shuffle of bytes within hexlet instruction (X.SHUFFLE.128 rd=rcb,8,4) may divide the 128-bit operand into 16 bytes and partitions the bytes 4 ways (indicated by varying shade in the diagram below). The 4 partitions are perfectly shuffled, producing a 128-bit result. As shown in , an example of a crossbar 4-way shuffle of bytes within triclet instruction (X.SHUFFLE.256 rd=rc,rb,8,4,0) may catenate the contents of rc and rb, then divides the 256-bit content into 32 bytes and partitions the bytes 4 ways (indicated by varying shade in the diagram below). The low-order halves of the 4 partitions are perfectly shuffled, producing a 128-bit result.","Changing the last immediate value h to 1 (X.SHUFFLE.256 rd=rc,rb,8,4,1) may modify operation to perform the same function on the high-order halves of the 4 partitions. When rc and rb are equal, the table below shows the value of the op field and associated values for size, v, and w.",{"@attributes":{"id":"p-0393","num":"0392"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"op","size","v","w"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","4","1","2"]},{"entry":[{},"1","8","1","2"]},{"entry":[{},"2","8","2","2"]},{"entry":[{},"3","8","1","4"]},{"entry":[{},"4","16","1","2"]},{"entry":[{},"5","16","2","2"]},{"entry":[{},"6","16","4","2"]},{"entry":[{},"7","16","1","4"]},{"entry":[{},"8","16","2","4"]},{"entry":[{},"9","16","1","8"]},{"entry":[{},"10","32","1","2"]},{"entry":[{},"11","32","2","2"]},{"entry":[{},"12","32","4","2"]},{"entry":[{},"13","32","8","2"]},{"entry":[{},"14","32","1","4"]},{"entry":[{},"15","32","2","4"]},{"entry":[{},"16","32","4","4"]},{"entry":[{},"17","32","1","8"]},{"entry":[{},"18","32","2","8"]},{"entry":[{},"19","32","1","16"]},{"entry":[{},"20","64","1","2"]},{"entry":[{},"21","64","2","2"]},{"entry":[{},"22","64","4","2"]},{"entry":[{},"23","64","8","2"]},{"entry":[{},"24","64","16","2"]},{"entry":[{},"25","64","1","4"]},{"entry":[{},"26","64","2","4"]},{"entry":[{},"27","64","4","4"]},{"entry":[{},"28","64","8","4"]},{"entry":[{},"29","64","1","8"]},{"entry":[{},"30","64","2","8"]},{"entry":[{},"31","64","4","8"]},{"entry":[{},"32","64","1","16"]},{"entry":[{},"33","64","2","16"]},{"entry":[{},"34","64","1","32"]},{"entry":[{},"35","128","1","2"]},{"entry":[{},"36","128","2","2"]},{"entry":[{},"37","128","4","2"]},{"entry":[{},"38","128","8","2"]},{"entry":[{},"39","128","16","2"]},{"entry":[{},"40","128","32","2"]},{"entry":[{},"41","128","1","4"]},{"entry":[{},"42","128","2","4"]},{"entry":[{},"43","128","4","4"]},{"entry":[{},"44","128","8","4"]},{"entry":[{},"45","128","16","4"]},{"entry":[{},"46","128","1","8"]},{"entry":[{},"47","128","2","8"]},{"entry":[{},"48","128","4","8"]},{"entry":[{},"49","128","8","8"]},{"entry":[{},"50","128","1","16"]},{"entry":[{},"51","128","2","16"]},{"entry":[{},"52","128","4","16"]},{"entry":[{},"53","128","1","32"]},{"entry":[{},"54","128","2","32"]},{"entry":[{},"55","128","1","64"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"When rc and rb are not equal, the table below shows the value of the opfield and associated values for size, v, and w: Opis the value of h, which controls whether the low-order order or high-order half of each partition is shuffled into the result.",{"@attributes":{"id":"p-0395","num":"0394"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"op4..0","size","v","w"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"0","256","1","2"]},{"entry":[{},"1","256","2","2"]},{"entry":[{},"2","256","4","2"]},{"entry":[{},"3","256","8","2"]},{"entry":[{},"4","256","16","2"]},{"entry":[{},"5","256","32","2"]},{"entry":[{},"6","256","64","2"]},{"entry":[{},"7","256","1","4"]},{"entry":[{},"8","256","2","4"]},{"entry":[{},"9","256","4","4"]},{"entry":[{},"10","256","8","4"]},{"entry":[{},"11","256","16","4"]},{"entry":[{},"12","256","32","4"]},{"entry":[{},"13","256","1","8"]},{"entry":[{},"14","256","2","8"]},{"entry":[{},"15","256","4","8"]},{"entry":[{},"16","256","8","8"]},{"entry":[{},"17","256","16","8"]},{"entry":[{},"18","256","1","16"]},{"entry":[{},"19","256","2","16"]},{"entry":[{},"20","256","4","16"]},{"entry":[{},"21","256","8","16"]},{"entry":[{},"22","256","1","32"]},{"entry":[{},"23","256","2","32"]},{"entry":[{},"24","256","4","32"]},{"entry":[{},"25","256","1","64"]},{"entry":[{},"26","256","2","64"]},{"entry":[{},"27","256","1","128"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"Wide Solve Galois","An exemplary embodiment of the Wide Solve Galois instruction is shown in .  illustrates the present invention with a method and apparatus for solving equations iteratively. The particular operation described is a wide solver for the class of Galois polynomial congruence equations L*S=W (mod z**2T), where S, L, and W are polynomials in a galois field such as GF(256) of degree 2T, T+1, and T respectively. Solution of this problem is a central computational step in certain error correction codes, such as Reed-Solomon codes, that optimally correct up to T errors in a block of symbols in order to render a digital communication or storage medium more reliable. Further details of the mathematics underpinning this implementation may be obtained from (Sarwate, Dilip V. and Shanbhag, Naresh R. \u201cHigh-Speed Architectures for Reed-Solomon Decoders\u201d, revised Jun. 7, 2000, Submitted to IEEE Trans. VLSI Systems, accessible from http:\/\/icims.csl.uiuc.edu\/\u02dcshanbhag\/vips\/publications\/bma.pdf and hereby incorporated by reference in its entirety.)","The apparatus in  contains memory strips, Galois multipliers, Galois adders, muxes, and control circuits that are already contained in the exemplary embodiments referred to in the present invention. As can be appreciated from the description of the Wide Matrix Multiply Galois instruction, the polynomial remainder step traditionally associated with the Galois multiply can be moved to after the Galois add by replacing the remainder then add steps with a polynomial add then remainder step.","This apparatus both reads and writes the embedded memory strips for multiple successive iterations steps, as specified by the iteration control block on the left. Each memory strip is initially loaded with polynomial S, and when 2T iterations are complete (in the example shown, T=4), the upper memory strip contains the desired solution polynomials L and W. The code block in  describes details of the operation of the apparatus of , using a C language notation.","Similar code and apparatus can be developed for scalar multiply-add iterative equation solvers in other mathematical domains, such as integers and floating point numbers of various sizes, and for matrix operands of particular properties, such as positive definite matrices, or symetrix matrices, or upper or lower triangular matrices.","Wide Transform Slice","An exemplary embodiment of the Wide Transform Slice instruction is shown in .  illustrates a method and apparatus for extremely fast computation of transforms, such as the Fourier Transform, which is needed for frequency-domain communications, image analysis, etc. In this apparatus, a 4\u00d74 array of 16 complex multipliers is shown, each adjacent to a first wide operand cache. A second wide operand cache or embedded coefficient memory array supplies operands that are multiplied by the multipliers with the data access from the wide embedded cache. The resulting products are supplied to strips of atomic transforms\u2014in this preferred embodiment, radix-4 or radix-2 butterfly units. These units receive the products from a row or column of multipliers, and deposit results with specified stride and digit reversal back into the first wide operand cache.","A general register ra contains both the address of the first wide operand as well as size and shape specifiers, and a second general register rb contains both the address of the second wide operand as well as size and shape specifiers.","An additional general register rc specifies further parameters, such as precision, result extraction parameters (as in the various Extract instructions described in the present invention).","In an alternative embodiment, the second memory operand may be located together with the first memory operand in an enlarged memory, using distinctive memory addressing to obtain either the first or second memory operand.","In an alternative embodiment, the results are deposited into a third wide operand cache memory. This third memory operand may be combined with the first memory operand, again using distinctive memory addressing. By relabeling of wide operand cache tags, the third memory may alternate storage locations with the first memory. Thus upon completion of the Wide Transform Slice instruction, the wide operand cache tags are relabeled to that the result appears in the location specified for the first memory operand. This alternation allows for the specification of not-in-place transform steps and permits the operation to be aborted and subsequently restarted if required as the result of interruption of the flow of execution.","The code block in  describes the details of the operation of the apparatus of , using a C language notation. Similar code and apparatus can be developed for other transforms and other mathematical domains, such as polynomial, Galois field, and integer and floating point real and complex numbers of various sizes.","In an exemplary embodiment, the Wide Transform Slice instruction also computes the location of the most significant bit of all result elements, returning that value as a scalar result of the instruction to be placed in a general register rc. This is the same operand in which extraction control and other information is placed, but in an alternative embodiment, it could be a distinct register. Notably, this location of the most significant bit may be computed in the exemplary embodiment by a series of Boolean operations on parallel subsets of the result elements yielding vector Boolean results, and at the conclusion of the operation, by reduction of the vector of Boolean results to a scalar Boolean value, followed by a determination of the most significant bit of the scalar Boolean value.","By adding the values representing the extraction control and other information to this location of the most significant bit, an appropriate scaling parameter is obtained, for use in the subsequent stage of the Wide Transform Slice instruction. By accumulating the most significant bit information, an overall scaling value for the entire transform can be obtained, and the transformed results are maintained with additional precision over that of fixed scaling schemes in prior art.","Wide Convolve Extract","An exemplary embodiment of the Wide Convolve Extract instruction is shown in . A similar method and apparatus can be applied to either digital filtering by methods of 1-D or 2-D convolution, or motion estimation by the method of 1-D or 2-D correlation. The same operation may be used for correlation, as correlation can be computed by reversing the order of the 1-D or 2-D pattern and performing a convolution. Thus, the convolution instruction described herein may be used for correlation, or a Wide Correlate Extract instruction can be constructed that is similar to the convolution instruction herein described except that the order of the coefficient operand block is 1-D or 2-D reversed.","Digital filter coefficients or a estimation template block is stored in one wide operand memory, and the image data is stored in a second wide operand memory. A single row or column of image data can be shifted into the image array, with a corresponding shift of the relationship of the image data locations to the template block and multipliers. By this method of partially updating and moving the data in the second embedded memory, The correlation of template against image can be computed with greatly enhanced effective bandwidth to the multiplier array. Note that in the present embodiment, rather than shifting the array, circular addressing is employed, and a shift amount or start location is specified as a parameter of the instruction.",{"@attributes":{"id":"p-0413","num":"0412"},"figref":["FIGS. 37A and 37B","FIGS. 37A and 37B"]},"The wide-convolve-extract instructions (W.CONVOLVE.X.B, W.CONVOLVE.X.L) perform a partitioned array multiply of a maximum size limited only by the extent of the memory operands, not the size of the data path. The extent, size and shape parameters of the memory operands are always specified as powers of two; additional parameters may further limit the extent of valid operands within a power-of-two region.","In an exemplary embodiment, as illustrated in , each of the wide operand specifiers specifies a memory operand extent by adding one-half the desired memory operand extent in bytes to the specifiers. Each of the wide operand specifiers specifies a memory operand shape by adding one-fourth the desired width in bytes to the specifiers. The heights of each of the memory operands can be inferred by dividing the operand extent by the operand width. One-dimensional vectors are represented as matrices with a height of one and with width equal to extent. In an alternative embodiment, some of the specifications herein may be included as part of the instruction.","In an exemplary embodiment, the Wide Convolve Extract instruction allows bits to be extracted from the group of values computed in various ways. For example, bits  . . .  of the contents of general register rb specifies several parameters which control the manner in which data is extracted. The position and default values of the control fields allows for the source position to be added to a fixed control value for dynamic computation, and allows for the lower 16 bits of the control field to be set for some of the simpler cases by a single GCOPYI instruction. In an alternative embodiment, some of the specifications herein may be included as part of the instruction.",{"@attributes":{"id":"p-0417","num":"0416"},"chemistry":{"@attributes":{"id":"CHEM-US-00002","num":"00002"},"img":{"@attributes":{"id":"EMI-C00002","he":"10.84mm","wi":"61.98mm","file":"US07301541-20071127-C00002.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"The table below describes the meaning of each label:",{"@attributes":{"id":"p-0419","num":"0418"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"label","bits","meaning"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"fsize","8","field size"]},{"entry":[{},"dpos","8","destination position"]},{"entry":[{},"x","1","extended vs. group size result"]},{"entry":[{},"s","1","signed vs. unsigned"]},{"entry":[{},"n","1","complex vs. real multiplication"]},{"entry":[{},"m","1","mixed-sign vs. same-sign"]},{"entry":[{},{},{},"multiplication"]},{"entry":[{},"l","1","saturation vs. truncation"]},{"entry":[{},"rnd","2","rounding"]},{"entry":[{},"gssp","9","group size and source position"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"The 9-bit gssp field encodes both the group size, gsize, and source position, spos, according to the formula gssp=512\u22124*gsize+spos. The group size, gsize, is a power of two in the range 1 . . . 128. The source position, spos, is in the range 0 . . . (2*gsize)\u22121.","The values in the x, s, n, m, l, and rnd fields have the following meaning:",{"@attributes":{"id":"p-0422","num":"0421"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"14pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}},{"entry":["values","x","s","n","m","l","rnd"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["0","group","unsigned","real","same-sign","truncate","F"]},{"entry":["1","extended","signed","complex","mixed-sign","saturate","Z"]},{"entry":["2",{},{},{},{},{},"N"]},{"entry":["3",{},{},{},{},{},"C"]},{"entry":{"@attributes":{"namest":"1","nameend":"7","align":"center","rowsep":"1"}}}]}}}}},"Bits  . . .  of the contents of general register rb specifies several parameters which control the selection of partitions of the memory operands. The position and default values of the control fields allows the multiplier zero length field to default to zero and the multiplicand origin position field computation to wrap around without overflowing into any other field by using 32-bit arithmetic.",{"@attributes":{"id":"p-0424","num":"0423"},"chemistry":{"@attributes":{"id":"CHEM-US-00003","num":"00003"},"img":{"@attributes":{"id":"EMI-C00003","he":"10.75mm","wi":"45.38mm","file":"US07301541-20071127-C00003.TIF","alt":"embedded image","img-content":"chem","img-format":"tif"}}}},"The table below describes the meaning of each label:",{"@attributes":{"id":"p-0426","num":"0425"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"label","bits","meaning"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"mpos","32","multiplicand origin position"]},{"entry":[{},"mzero","32","multiplier zero length"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"The 32-bit mpos field encodes both the horizontal and vertical location of the multiplicand origin, which is the location of the multiplicand element at which the zero-th element of the multiplier combines to produce the zero-th element of the result. Varying values in this field permit several results to be computed with no changes to the two wide operands. The mpos field is a byte offset from the beginning of the multiplicand operand.","The 32-bit mzero field encodes a portion of the multiplier operand that has a zero value and which may be omitted from the multiply and sum computation. Implementations may use a non-zero value in this field to reduce the time and\/or power to perform the instruction, or may ignore the contents of this field. The implementation may presume a zero value for the multiplier operand in bits dmsize\u22121 . . . dmsize\u2212(mzero*8), and skip the multiplication of any multiplier obtained from this bit range. The mzero field is a byte offset from the end of the multiplier operand.","The virtual addresses of the wide operands must be aligned, that is, the byte addresses must be an exact multiple of the operand extent expressed in bytes. If the addresses are not aligned the virtual address cannot be encoded into a valid specifier. Some invalid specifiers cause an \u201cOperand Boundary\u201d exception.","Z (zero) rounding is not defined for unsigned extract operations, so F (floor) rounding is substituted, which will properly round unsigned results downward.","An implementation may limit the extent of operands due to limits on the operand memory or cache, or of the number of values that may be accurately summed, and thereby cause a ReservedInstruction exception.","As shown in , as an example with specific register values, a wide-convolve-extract-doublets instruction (W.CONVOLVE.X.B or W.CONVOLVE.X.L), with start in rb=24, convolves memory vector rc [c31 c30 . . . c1 c0] with memory vector rd [d15 d14 . . . d1 d0], yielding the products [c16d15+c17d14+ . . . +c30d1+c31d0 c15d15+c16d14+ . . . +c29d1+c30d0 . . . c10d15+c11d14+ . . . c24d1+c25d0 c9d15+c10d14+ . . . +c23d1+c24d0], rounded and limited as specified by the contents of general register rb. The values c8 . . . c0 are not used in the computation and may be any value.","As shown in , as an example with specific register values, a wide-convolve-extract-doublets instruction (W.CONVOLVE.X.L), with mpos in rb=8 and mzero in rb=48 (so length=(512\u2212mzero)*dmsize\/512=13), convolves memory vector rc [c31 c30 . . . c1 c0] with memory vector rd [d15 d14 . . . d1 d0], yielding the products [c3d12+c4d11+ . . . +c14d1+c15d0 c2d12+c3d11+ . . . +c13d1+c14d0 . . . c29d12+c30d11+ . . . +c8d1+c9d0 c28d12+c29d11+ . . . +c7d1+c8d0]rounded and limited as specified. In this case, the starting position is located so that the useful range of values wraps around below c0, to c31 . . . 28. The values c27 . . . c16 are not used in the computation and may be any value. The length parameter is set to 13, so values of d15 . . . d13 must be zero.","As shown in , as an example with specific register values, a wide-convolve-extract-doublets-two-dimensional instruction (W.CONVOLVE.X.B or W.CONVOLVE.X.L), with mpos in rb=24 and vsize in rc and rd=4, convolves memory vector rc [c127 c126 . . . c31 c30 . . . c1 c0] with memory vector rd [d63 d62 . . . d15 d14 . . . d1 d0], yielding the products [c113d63+c112d62+ . . . +c16d15+c17d14+ . . . +c30d1+c31d0 c112d63+c111d62+ . . . +c15d15+c16d14+ . . . +c29d1+c30d0 . . . c107d63+c106d62+ . . . +c10d15+c11d14+ . . . +c24d1+c25d0 c106d63+c105d62+ . . . +c9d15+c10d14+ . . . +c23d1+c24d0], rpunded and limited as specified by the contents of general register rb.","As shown in , as an example with specific register values, a wide-convolve-extract-complex-doublets instruction (W.CONVOLVE.X.B or W.CONVOLVE.X.L with n set in rb), with mpos in rb=12, convolves memory vector rc [c15c14 . . . c1 c0] with memory vector rd [d7 d6 . . . d1 d0], yielding the products [c8d7+c9d6+ . . . +c16d1+c15d0 c7d7+c8d6+ . . . +c13d1+c14d0 c6d7+c7d6+ . . . +c11d1+c12d0], rounded and limited as specified by the contents of general register rb.","Wide Convolve Floating-Point","A Wide Convolve Floating-point instruction operates similarly to the Wide Convolve Extract instruction described above, except that the multiplications and additions of the operands proceed using floating-point arithmetic. The representation of the multiplication products and intermediate sums in an exemplary embodiment are performed without rounding with essentially unbounded precision, with the final results subject to a single rounding to the precision of the result operand. In an alternative embodiment, the products and sums are computed with extended, but limited precision. In another alternative embodiment, the products and sums are computed with precision limited to the size of the operands.","The Wide Convolve Floating-point instruction in an exemplary embodiment may use the same format for the general register rb fields as the Wide Convolve Extract instruction, except for sfields which are not applicable to floating-point arithmetic. For example, the fsize, dpos, s, m, and l fields and the spos parameter of the gssp field may be ignored for this instruction. In an alternative embodiment, some of the remaining information may be specified within the instruction, such as the gsize parameter or the n parameter, or may be fixed to specified values, such as the rounding parameter may be fixed to round-to-nearest. In an alternative embodiment, the remaining fields may be rearranged, for example, if all but the mpos field are contained within the instruction or ignored, the mpos field alone may be contained in the least significant portion of the general register rb contents.","Wide Decode","Another category of enhanced wide operations is useful for error correction by means of Viterbi or turbo decoding. In this case, embedded memory strips are employed to contain state metrics and pre-traceback decision digits. An array of Add-Compare-Swap or log-MAP units receive a small number of branch metrics, such as 128 bits from an external register in our preferred embodiment. The array then reads, recomputes, and updates the state metric memory entries which for many practical codes are very much larger. A number of decision digits, typically 4-bits each with a radix-16 pre-traceback method, is accumulated in a the second traceback memory. The array computations and state metric updates are performed iteratively for a specified number of cycles. A second iterative operation then traverses the traceback memory to resolve the most likely path through the state trellis.","Wide Boolean","Another category of enhanced wide operations are Wide Boolean operations that involve an array of small look up tables (LUTs), typically with 8 or 16 entries each specified by 3 or 4 bits of input address, interconnected with nearby multiplexors and latches. The control of the LUT entries, multiplexor selects, and latch clock enables is specified by an embedded wide cache memory. This structure provides a mean to provide a strip of field programmable gate array that can perform iterative operations on operands provided from the registers of a general purpose microprocessor. These operations can iterate over multiple cycles, performing randomly specifiable logical operations that update both the internal latches and the memory strip itself.","Transfers Between Wide Operand Memories","The method and apparatus described here are widely applicable to the problem of increasing the effective bandwidth of microprocessor functional units to approximate what is achieved in application-specific integrated circuits (ASICs). When two or more functional units capable of handling wide operands are present at the same time, the problem arises of transferring data from one functional unit that is producing it into an embedded memory, and through or around the memory system, to a second functional unit also capable of handling wide operands that needs to consume that data after loading it into its wide operand memory. Explicitly copying the data from one memory location to another would accomplish such a transfer, but the overhead involved would reduce the effectiveness of the overall processor.",{"@attributes":{"id":"p-0445","num":"0444"},"figref":"FIG. 38"},"Having fully described a preferred embodiment of the invention and various alternatives, those skilled in the art will recognize, given the teachings herein, that numerous alternatives and equivalents exist which do not depart from the invention. It is therefore intended that the invention not be limited by the foregoing description, but only by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIGS. 10 and 11"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIGS. 12A-12D"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIGS. 13A-13D"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIGS. 14A-14E"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIGS. 15A-15F"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIGS. 16A-16E"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIGS. 17A-17E"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIGS. 18A-18D"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIGS. 19A-19G"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIGS. 20A-20J"},{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIGS. 21A-21B"},{"@attributes":{"id":"p-0074","num":"0073"},"figref":"FIGS. 22A-22B"},{"@attributes":{"id":"p-0075","num":"0074"},"figref":"FIGS. 23A-23C"},{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIGS. 24A-24C"},{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIGS. 25A-25C"},{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIGS. 26A-26C"},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIGS. 27A-27C"},{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIGS. 28A-28C"},{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIGS. 30A-30C"},{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIGS. 31A-31C"},{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIGS. 32A-32D"},{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIGS. 33A-33D"},{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIGS. 34A-34E"},{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIGS. 35A-35B"},{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIGS. 36A-36B"},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIGS. 37A-37K"},{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 38"}]},"DETDESC":[{},{}]}
