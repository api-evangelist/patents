---
title: Method and system for performing backward-driven path-sensitive dataflow analysis
abstract: In general, in one aspect, the invention relates to a method for static analysis. The method includes: obtaining source code; constructing a control flow graph (CFG) corresponding to the source code, by identifying control structures within the source code, creating a set of graph nodes of the CFG, and creating a set of directed graph edges of the CFG connecting the set of graph nodes; assigning a first Boolean flow value to a selected node of the set of graph nodes; backward traversing the CFG from the selected node to a target node; computing, by a computer processor and while backward traversing the CFG, disjoint predicate expressions representing flow values at the set of directed graph edges; computing, based on the disjoint predicate expressions, a resulting disjoint predicate expression; and identifying, based on the resulting disjoint predicate expression, a potential program property in the source code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08893102&OS=08893102&RS=08893102
owner: Oracle International Corporation
number: 08893102
owner_city: Redwood Shores
owner_country: US
publication_date: 20110727
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Static code analysis (i.e., static analysis) techniques involve analysis of source code without executing the source code. Some static analysis methods require an analysis of the potential execution paths of source code. One method of modeling such paths is to generate a control flow graph (CFG). A CFG represents potential execution paths using directed edges connecting basic blocks of source code. Other modeling techniques involving varying degrees of abstraction are also used by some static analysis algorithms.","By identifying defects and other properties of source code using static analysis tools, software reliability improvements have been made to many phases of the software development lifecycle. Analysis of the impact of software defects, for example, has shown potentially high costs associated with memory leaks, deadlocks, and other hazardous program states. In some cases, small investments in analysis tools earlier in the lifecycle can show dividend gains in the form of lower maintenance costs and prevention of potentially costly redesign later.","In general, in one aspect, the invention relates to a method for static analysis. The method includes: obtaining source code; constructing a control flow graph (CFG) corresponding to the source code, by identifying control structures within the source code, identifying, based on the control structures, a set of basic blocks of reachable code within the source code, creating a set of graph nodes of the CFG representing the set of basic blocks, and creating, based on the control structures, a set of directed graph edges of the CFG connecting the set of graph nodes; assigning a first Boolean flow value to a selected node of the set of graph nodes; backward traversing the CFG from the selected node to a target node of the CFG; computing, by a computer processor and while backward traversing the CFG, disjoint predicate expressions representing flow values at the set of directed graph edges; computing, by the computer processor and based on the disjoint predicate expressions, a resulting disjoint predicate expression representing a resulting flow value at the target node; and identifying, based on the resulting disjoint predicate expression, a potential program property in the source code.","In general, in one aspect, the invention relates to a system for static analysis. The system includes: a processor and a memory; a model generator residing in the memory, executing on the processor, and having functionality to construct a control flow graph (CFG) corresponding to source code, by: identifying control structures within the source code, identifying, based on the control structures, a set of basic blocks of reachable code within the source code, creating graph nodes of the CFG representing the set of basic blocks, and creating, based on the control structures, a set of directed graph edges of the CFG connecting the graph nodes; and a static analysis tool residing in the memory, executing on the processor, and having functionality to: obtain the source code, assign a first Boolean flow value to a selected node of the graph nodes, backward traverse the CFG from the selected node to a target node of the CFG, compute, while backward traversing the CFG, a set of disjoint predicate expressions representing flow values at the set of directed graph edges, compute, based on the set of disjoint predicate expressions, a resulting disjoint predicate expression representing a resulting flow value at the target node, and identify, based on the resulting disjoint predicate expression, a potential program property in the source code.","In general, in one aspect, the invention relates to a computer-readable storage medium storing instructions for static analysis. The instructions include functionality to: obtain source code; construct a control flow graph (CFG) corresponding to the source code, by: identifying control structures within the source code, identifying, based on the control structures, a set of basic blocks of reachable code within the source code, creating graph nodes of the CFG representing the set of basic blocks, and creating, based on the control structures, a set of directed graph edges of the CFG connecting the graph nodes; assign a first Boolean flow value to a selected node of the graph nodes; backward traverse the CFG from the selected node to a target node of the CFG; compute, while backward traversing the CFG, a set of disjoint predicate expressions representing flow values at the set of directed graph edges; compute, based on the set of disjoint predicate expressions, a resulting disjoint predicate expression representing a resulting flow value at the target node; and identify, based on the resulting disjoint predicate expression, a potential program property in the source code.","Other aspects of the invention will be apparent from the following description and the appended claims.","Specific embodiments of the invention will now be described in detail with reference to the accompanying figures. Like elements in the various figures are denoted by like reference numerals for consistency.","In the following detailed description of embodiments of the invention, numerous specific details are set forth in order to provide a more thorough understanding of the invention. However, it will be apparent to one of ordinary skill in the art that the invention may be practiced without these specific details. In other instances, well-known features have not been described in detail to avoid unnecessarily complicating the description.","In general, embodiments of the invention provide a method and system for performing a path-sensitive static analysis on source code. In general, embodiments of the invention generate a control flow graph (CFG) model of source code, where a backward traversal of the CFG is performed. During the traversal, a set of predicate expressions are computed and propagated through the CFG. A program property may then be identified based on a resulting predicate expression.","A path-sensitive algorithm is one that is able to distinguish between behavior along different paths through a program. A path through a CFG is a list of program blocks from an entry point through an exit point of the CFG.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 1","FIG. 1"],"b":["199","100","105","110","120","125","135"]},"In one or more embodiments of the invention, the static analysis tool () is a software application. The static analysis tool () may be an application subroutine, a software module, a library, a job and\/or any type of software component in accordance with one or more embodiments of the invention disclosed herein. For example, the static analysis tool () may be a software application executable from a command line interface. Alternatively, the static analysis tool () may be a hardware device, and\/or a component of a hardware device.","In one or more embodiments of the invention, the static analysis tool () includes functionality to obtain source code. Source code may be any software code written in one or more programming languages (e.g., C\/C++, Java\u2122, Python, Ruby, Personal Home Page (PHP) scripting language, Practical Extraction and Report Language (Perl), Linux\u00ae\/UNIX\u00ae shell script, etc) including compiled languages as well as interpreted languages of any order. Examples of source code may also include assembly code, byte code, and\/or instructions outputted by a compiler or other entity. Source code may be a fully functional program and\/or a subset of a program such as a function, class, library, statement, instruction, user-defined type, and\/or any code segment. Source code may reference one or more outside classes, objects, files, libraries (e.g., a dynamically linked library) and\/or application programming interfaces (APIs).","In one or more embodiments of the invention, the static analysis tool () is configured to receive the source code from a software development application. The static analysis tool () may be operatively connected to one or more software applications including, but not limited to, a concurrent versioning system, a web-based applications development platform, a distributed database of managed source code, and\/or any software application or device capable of storing and\/or transferring source code.","In one or more embodiments of the invention, the static analysis tool () includes a user interface. In one or more embodiments of the invention, the static analysis tool () includes functionality to receive the source code from a user of the user interface. The user of the user interface may be an end user of a computer system, a software engineer, a designer, an applications developer, a system administrator, and\/or any person or entity communicatively coupled with the static analysis tool (). In one or more embodiments of the invention, the static analysis tool () is configured to import the source code periodically for batch processing of a managed code base.","In one or more embodiments of the invention, the static analysis tool () includes functionality to obtain one or more program property definitions. A program property definition may be used to identify one or more program properties within source code. The static analysis tool () may obtain the one or more program property definitions from the static analysis repository (), a software application communicatively connected to the static analysis tool (), a user of the static analysis tool (), an author of the source code, and\/or any authorized entity in accordance with one or more pre-defined security credentials. Alternatively or additionally, the static analysis tool () may be pre-configured and\/or designed with the one or more program property definitions and\/or security credentials.","A program property may be any type of computer coding impact, data flow, error, vulnerability, inefficiency, or other property related to source code. For example, a program property may cause an unintended state of a computer program and\/or a computer system executing the source code. Examples of a program property may include but are not limited to a specified data flow, data flow impact on a program object, an arithmetic defect (e.g., division by zero, arithmetic underflow or overflow, loss of arithmetic precision due to rounding, etc.), a syntax defect (e.g., use of the assignment operator instead of the equality operator, etc.), a multi-threading programming defect (e.g., deadlock, race condition, concurrency error in critical\/atomic section, mutual exclusion, etc.), a security vulnerability (i.e., memory safety, user authentication vulnerabilities, etc.), and a compiler optimization inefficiency (i.e., inefficiencies in code analysis\/interpretation\/generation, etc.).","Continuing with , in one or more embodiments of the invention, the static analysis tool () is configured to receive a list of one or more program property definitions from a user and\/or authorized entity.","In one or more embodiments of the invention, the static analysis tool () includes functionality to perform a program property analysis of the source code. A program property analysis may be a procedure for identifying a program property based on a CFG model of source code. In one or more embodiments of the invention, a program property analysis is associated with an estimated running time, complexity, and\/or resource requirement(s). In one or more embodiments of the invention, a program property definition may include a sorted list of program property analyses. The static analysis tool () may be configured to sort the list of program property analyses according to one or more sort criteria including estimated running time, complexity, and\/or resource requirement(s).","In one or more embodiments of the invention, the static analysis tool () includes functionality to parse source code into a set of logical tokens and then analyze the tokens according to syntactical rules of the programming language in which the source code is written. A token may be a smallest element of recognizable syntax in the programming language.","In one or more embodiments of the invention, the static analysis tool () and the model generator () are configured to use a predefined predicate domain in construction and analysis of a CFG. In one or more embodiments of the invention, a base predicate is defined as an expression X op k where X is any program value, k is a constant, and op is one of the operations =, \u2260, <, <=, >=, >, (either signed or unsigned), bit-set-all, bit-set-any, bit-clear-all, or bit-clear-all. The bit operations bit-set-all, bit-set-any, bit-clear-all, and bit-clear-all are used for handling bit-fields, and are defined as per Table 1 below, where & is the standard C bitwise- and operator. A program value may be any value, state, or property derived from source code which can be used as an operand in the aforementioned operations.",{"@attributes":{"id":"p-0028","num":"0027"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Supported bit-field operators"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Operator","Definition"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"X bit-set-all k","(X & k) = k"]},{"entry":[{},"X bit-set-any k","(X & k) \u2260 0"]},{"entry":[{},"X bit-clear-all k","(X & k) = 0"]},{"entry":[{},"X bit-clear-all k","(X & k) \u2260 k"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In one or more embodiments of the invention, a disjoint predicate expression (i.e., predicate expression) is defined as either TRUE, FALSE, or the disjunction of 1 or more base predicates {X op kY op l . . . Z op m} such that no program value (e.g., X, Y, Z) appears more than once.","In one or more embodiments of the invention, in addition to the set of base predicates, the disjoint predicate expression may also contain the placeholder term Unsolvable, which replaces (1) any sub-expressions that would otherwise be unrepresentable with the predicate domain and\/or (2) sub-expressions that are excluded from the analysis due to complexity or other reasons. Unsolvable serves primarily as a marker that an expression (typically, a more complex expression) was removed from the predicate. In one or more embodiments of the invention, Unsolvable is treated as an alternative False value.","In one or more embodiments of the invention, the static analysis tool () is configured to designate conjunctions between distinct program values as Unsolvable. In one example, the static analysis tool () may designate the conjunction \u201c{X=0}{Y\u22600}\u201d as Unsolvable due to the fact that the program values X and Y are distinct.","In one or more embodiments of the invention, the static analysis tool () is configured to designate conjunctions or disjunctions involving the same program value that cannot be reduced to a single base predicate as Unsolvable. In one example, the static analysis tool () may designate the conjunction \u201c{X<5} v {X>10}\u201d as Unsolvable due to the fact that the base predicates cannot be reduced to a single base predicate using logical rules. In one or more embodiments of the invention, disjoint predicate expressions support the standard logical operations of disjunction and conjunction, which behave per the standard rules for Boolean logic. The operations are commutative, and distribute conjunction over disjunction. After distribution and simplification, any remaining conjunctive sub-expressions may be designated as Unsolvable, as illustrated in Table 2 (below).",{"@attributes":{"id":"p-0033","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Deduction rules for disjoint predicate expressions"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["P\u2009 \u2009P\u2009 \u2009P (Identity)","TRUE\u2009 \u2009TRUE",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00008","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"FALSE\u2009 \u2009FALSE",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00010","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{Unsolvable}\u2009 \u2009{Unsolvable}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00012","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{\u03b1}\u2009 \u2009{\u03b1}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00014","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{\u03b1\u2009 \u2009\u03b2}\u2009 \u2009{\u03b1\u2009 \u2009\u03b2}",{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00018","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00019","he":"1.44mm","wi":"1.78mm","file":"US08893102-20141118-P00003.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":["P\u2009 \u2009TRUE\u2009 \u2009TRUE","TRUE\u2009 \u2009FALSE",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00023","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"TRUE\u2009 \u2009{Unsolvable}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00025","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{\u03b1}\u2009 \u2009TRUE",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00027","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":["P\u2009 \u2009FALSE\u2009 \u2009P","FALSE\u2009 \u2009{Unsolvable}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00031","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{\u03b1}\u2009 \u2009FALSE",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00033","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":["P\u2009 \u2009 P\u2009 \u2009TRUE","{\u03b1}\u2009 \u2009{ \u03b1}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00039","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{\u03b1}\u2009 \u2009{ \u03b1\u2009 \u2009\u03b2}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00043","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":["Disjunction","{\u03b1}\u2009 \u2009{Unsolvable}",{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00045","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00046","he":"1.44mm","wi":"1.78mm","file":"US08893102-20141118-P00003.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":[{},"{\u03b1}\u2009 \u2009{\u03b2}",{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00048","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00049","he":"1.44mm","wi":"1.78mm","file":"US08893102-20141118-P00003.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":[{},"{\u03b1}\u2009 \u2009{\u03b1\u2009 \u2009\u03b2}",{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00052","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00053","he":"1.44mm","wi":"1.78mm","file":"US08893102-20141118-P00003.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":[{},"{\u03b1\u2009 \u2009Unsolvable}\u2009 \u2009{\u03b2\u2009 \u2009Unsolvable}",{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00057","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00058","he":"1.44mm","wi":"1.78mm","file":"US08893102-20141118-P00003.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00059","he":"1.44mm","wi":"1.78mm","file":"US08893102-20141118-P00003.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":["P\u2009 \u2009P\u2009 \u2009P (Identity)","TRUE\u2009 \u2009TRUE",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00063","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"FALSE\u2009 \u2009FALSE",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00065","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{Unsolvable}\u2009 \u2009{Unsolvable}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00067","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{\u03b1}\u2009 \u2009{\u03b1}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00069","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{\u03b1\u2009 \u2009\u03b2}\u2009 \u2009{\u03b1\u2009 \u2009\u03b2}",{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00073","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00074","he":"1.44mm","wi":"1.78mm","file":"US08893102-20141118-P00003.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":["P\u2009 \u2009FALSE\u2009 \u2009FALSE","TRUE\u2009 \u2009FALSE",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00078","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{\u03b1}\u2009 \u2009FALSE",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00080","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"FALSE\u2009 \u2009{Unsolvable}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00082","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":["P\u2009 \u2009TRUE\u2009 \u2009P","TRUE\u2009 \u2009{Unsolvable}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00086","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{\u03b1}\u2009 \u2009TRUE",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00088","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":["P\u2009 \u2009{Unsolvable}\u2009 \u2009{Unsolvable}","{\u03b1}\u2009 \u2009{Unsolvable}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00092","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":["P\u2009 \u2009 P\u2009 \u2009FALSE","{\u03b1}\u2009 \u2009{ \u03b1}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00098","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":["{\u03b1} {{\u03b1}\u2009 \u2009P}\u2009 \u2009{\u03b1}","{\u03b1}\u2009 \u2009{\u03b1\u2009 \u2009\u03b2}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00104","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{\u03b1}\u2009 \u2009{\u03b1\u2009 \u2009Unsolvable}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00107","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":["{\u03b1}\u2009 \u2009{\u03b2}\u2009 \u2009{Unsolvable}","{\u03b1}\u2009 \u2009{\u03b2}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00111","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{\u03b1}\u2009 \u2009{\u03b2\u2009 \u2009\u03b3}",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00114","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"{\u03b1\u2009 \u2009\u03b2}\u2009 \u2009{\u03b1\u2009 \u2009\u03b3}",{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00118","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00004.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00119","he":"1.44mm","wi":"1.78mm","file":"US08893102-20141118-P00003.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":["Merge simplification","({\u03b1} {\u03b2})\u2009 \u2009{ \u03b2}",{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00123","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00008.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00124","he":"2.12mm","wi":"1.78mm","file":"US08893102-20141118-P00009.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00125","he":"0.68mm","wi":"1.44mm","file":"US08893102-20141118-P00005.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":[{},"({\u03b1}\u2009 \u2009{\u03b2})\u2009 \u2009({\u03b1}\u2009 \u2009{ \u03b2})",{"img":{"@attributes":{"id":"CUSTOM-CHARACTER-00130","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00008.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}}]},{"entry":[{},"({\u03b1\u2009 \u2009\u03b3}\u2009 \u2009{\u03b2})\u2009 \u2009({\u03b1}\u2009 \u2009{ \u03b2})",{"img":[{"@attributes":{"id":"CUSTOM-CHARACTER-00136","he":"1.78mm","wi":"2.12mm","file":"US08893102-20141118-P00008.TIF","alt":"custom character","img-content":"character","img-format":"tif"}},{"@attributes":{"id":"CUSTOM-CHARACTER-00137","he":"2.12mm","wi":"1.78mm","file":"US08893102-20141118-P00009.TIF","alt":"custom character","img-content":"character","img-format":"tif"}}]}]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"In one or more embodiments of the invention, the model generator () includes functionality to generate a CFG model of source code. The CFG depicts one or more potential execution paths of the source code and may include one or more graph nodes connected by one or more directed graph edges.","In one or more embodiments of the invention, the model generator () includes functionality to identify one or more control structures within the source code. A control structure may be any statement which, when executed, results in a selection of a path among a set of alternative paths. Thus, in one or more embodiments of the invention, a control structure may select between two or more alternative paths based on evaluation of a conditional statement and\/or operation. The conditional statement may have a Boolean result, a numerical result, and\/or may result in any value or state which is then used by the control structure to determine an execution path.","In one or more embodiments of the invention, the model generator () is configured to identify, based on the identified control structures, a set of basic blocks of reachable code within the source code. Each basic block may include one or more statements and\/or instructions that are necessarily executed together (i.e., not separated by any control structures). Thus, in one or more embodiments of the invention, each basic block has one entry point and one exit point.","In one or more embodiments of the invention, the model generator () is configured to create a set of graph nodes representing the identified basic blocks. Each graph node is created for a corresponding basic block. The CFG may include an entry node representing a starting node of the CFG and an exit node representing an ending node of the CFG. In one or more embodiments of the invention, the set of graph nodes includes one or more branch nodes which have two or more outgoing directed graph edges. Thus, a branch node is connected to two or more dependent nodes (i.e., destination nodes connected to by the outgoing edges).","In one or more embodiments of the invention, the model generator () is configured to create, based on the identified control structures, a set of directed graph edges connecting the graph nodes. Each directed graph edge represents an execution path between a source node and a destination node. Thus, in one or more embodiments of the invention, each node of the CFG is connected to at least one other node of the CFG by a directed graph edge.","In one or more embodiments of the invention, the model generator () is configured to extract, from each control structure, two or more Boolean edge predicates. The model generator () may extract the Boolean edge predicate from a basic block's branch condition, such that the predicate is true if and only if that branch edge is taken. For example, for the control structure \u201cif (err !=0) { . . . }\u201d, we will derive \u201cerr\u22600\u201d for the TRUE case, and \u201cerr=0\u201d for the FALSE case. In one or more embodiments of the invention, the Boolean edge predicate is always representable as a base predicate.","In one or more embodiments of the invention, the model generator () is configured to assign each extracted edge predicate to a corresponding directed graph edge. The edge predicate may be evaluated based on one or more path-sensitive predicate expressions propagated through the CFG and\/or one or more data items identified in the source code, in accordance with one or more embodiments of the invention.","In one or more embodiments of the invention, the static analysis tool () includes functionality to select a graph node of the CFG as a starting point for a backward traversal of the CFG. The program property definition may include one or more criteria for selecting the graph node. Examples of a criterion may include, but are not limited to, a statement type, a syntactical element of the programming language in which the source code is written, a search string, a program value, an operation, and\/or any identifying element which may be used to identify a graph node as a starting point for traversal of the CFG. For example, in examining a CFG for a potential null pointer dereference defect, the static analysis tool () may select a graph node corresponding to a dereference operation as a starting point for the traversal. In this example, the program property definition's criteria indicates that the CFG should be traversed from the basic block containing the dereference operation.","In one or more embodiments of the invention, the static analysis tool () includes functionality to create a flow value at a selected graph node of the CFG. The flow value may be a Boolean flow value and\/or a flow value selected from a set of possible values defined by the program property definition. A flow value is a path-sensitive value representing the state of one or more program objects, values, properties, elements, and\/or attributes corresponding to a potential program property at a given location in the CFG. In one or more embodiments of the invention, the static analysis tool () uses the flow value to identify whether a program property exists within the source code. The static analysis tool () may compute flow values at one or more graph edges and\/or nodes of the CFG in order to determine whether the program property exists.","In one or more embodiments of the invention, the static analysis tool () includes functionality to perform a backward traversal of the CFG beginning at the selected graph node. The backward traversal of the CFG may be performed according to any pre-defined method of traversing a CFG. In one or more embodiments of the invention, a breadth first traversal of the CFG is used in order to propagate flow values and\/or representations of flow values to a target node of the CFG.","In one or more embodiments of the invention, the static analysis tool () is configured to select a current graph edge of the CFG for analysis. The current graph edge may be selected in accordance with the traversal method and may be connected to one or more traversed graph nodes and\/or graph edges of the CFG. For example, if all directed graph edges below a given graph edge are traversed, the given graph edge may be selected. In this example, if a dependent graph edge (i.e., a graph edge below the current graph edge in a same branch of the CFG) of the current graph edge is not yet traversed, the dependent graph edge may be selected for analysis.","In one or more embodiments of the invention, the static analysis tool () is configured to determine whether the destination graph node of the current graph edge has more than one outgoing directed graph edges. An outgoing directed graph edge may be any directed graph edge connecting the current node as a source to another graph node. In one or more embodiments of the invention, if it is determined that the destination graph node has two or more outgoing directed graph edges, the static analysis tool () is configured to compute an edge predicate expression for each outgoing graph edge. The static analysis tool () may, for each outgoing graph edge, compute a conjoined predicate expression as a conjunction of (1) the predicate expression of the outgoing edge with (2) an edge predicate of the outgoing edge. In one or more embodiments of the invention, the static analysis tool () is configured to calculate a current predicate expression of the current graph edge as a disjunction of the conjoined expressions computed for each outgoing graph edge.","In one or more embodiments of the invention, the static analysis tool () may determine that the destination graph node of the current graph edge has only one outgoing directed graph edge. In this case, the static analysis tool () may simply propagate the predicate expression of the outgoing graph edge as the current predicate expression of the current graph edge.","In one or more embodiments of the invention, the static analysis tool () may determine that the destination graph node of the current graph edge is an exit point of the traversal. In this case, the static analysis tool () may propagate a flow value assigned to the exit point as the current predicate expression of the current graph edge.","In one or more embodiments of the invention, the static analysis tool () is configured to modify the current predicate expression prior to assigning the current predicate expression to the current graph edge. The current predicate expression may be modified based on one or more source code statements (i.e., statements) in the basic block of the destination graph node. Modifying the current predicate expression may include replacing the current predicate expression with a Boolean value or simplifying the predicate expression by replacing one or more program values with Boolean values. The static analysis tool () may perform the modification based on a criteria defined by a program property definition. For example, for a memory leak program property definition, the static analysis tool () may set the current predicate expression to FALSE upon encountering a memory deallocation statement in the basic block of the destination graph node. In this example, the program property definition criteria defines a criteria identifying the memory deallocation statement, and the static analysis tool () matches the criteria to the statement in the basic block. In one or more embodiments of the invention, if a statement matching the criteria is not made, no modification to the current predicate expression is made.","In one or more embodiments of the invention, the static analysis tool () includes functionality to determine whether the CFG is traversed. Traversal of the CFG may involve traversing only a subgraph (i.e., a portion) of the CFG if the starting node of the traversal is a non-exit graph node. Thus, if the traversal of the CFG began in a middle graph node (i.e., at a non-entry and non-exit node), then the CFG is deemed to be traversed upon traversing the subgraph of the CFG connecting the middle node and a target node (e.g., the entry graph node). In one or more embodiments of the invention, the CFG may be deemed to be traversed according to the method of traversal defined by a program property definition.","In one or more embodiments of the invention, the static analysis tool () includes functionality to compute a resulting predicate expression of a target node of the CFG. The resulting predicate expression may be the disjunction of two or more conjoined predicate expressions from the graph edges connected to the target node or it may be a propagated predicate expression of a single connected graph edge. In one or more embodiments of the invention, the static analysis tool () may assign the resulting predicate expression to the target node after modifying the resulting predicate expression based on one or more statements in the basic block. Thus, in one or more embodiments of the invention, the resulting predicate expression is a result of the backward traversal.","In one or more embodiments of the invention, the static analysis tool () constructs a single resulting predicate expression based on every other predicate expression generated during the backward traversal of the CFG and reduces, evaluates, and\/or solves the resulting predicate expression during the traversal.","In one or more embodiments of the invention, the static analysis tool () includes functionality to identify a program property based on the resulting predicate expression of the target node. In one or more embodiments of the invention, the static analysis tool () may compare the resulting predicate expression to a Boolean flow value at a beginning point of the traversal in order to determine whether the program property exists. The comparison may be defined by a program property definition such that, if the resulting predicate expression and the Boolean flow value are equal, not equal, and\/or any predefined combination of Boolean values, the program property is deemed to exist or not-exist. In one or more embodiments of the invention, if the resulting predicate expression is a non-Boolean value, the static analysis tool () may determine that a program property exists (based on the program property definition).","In one or more embodiments of the invention, the static analysis tool () is configured to record one or more annotations for one or more graph edges. The annotation may be recorded based on a flow value at a graph edge to indicate that the graph edge may be part of a path potentially depicting an occurrence of the program property. For example, given that a flow value of FALSE is interpreted as an indication that a potential program property exists, the static analysis tool () may record an annotation for each graph edge generating a FALSE flow value during traversal. In one or more embodiments of the invention, the static analysis tool () also records annotations for graph edges corresponding to a flow value of Unsolvable.","In one or more embodiments of the invention, the static analysis tool () is configured to identify, based on the resulting predicate expression, a path through the CFG depicting an occurrence of the program property (hereinafter \u201cprogram property path\u201d). For example, when analyzing source code for defects, the program property path may be an error path depicting an occurrence of the defect in the source code. The program property path may be identified based on a set of annotated graph edges. Any path from the entry point to the exit point of the graph consisting solely of annotated graph edges may be deemed to be a potential program property path. In one or more embodiments of the invention, only feasible paths are identified as potential program property paths.","In one or more embodiments of the invention, the static analysis tool () is configured such that, as a result of the backward traversal of the CFG and the computed flow values and predicate expressions, only feasible paths are identified.","In one or more embodiments of the invention, the static analysis tool () includes functionality to detect interprocedural program properties through the use of function summaries, which detail the externally visible behavior of the function. The static analysis tool () initially provides predefined function summaries for a first set of library functions of a given programming language (e.g., malloc and free in the C programming language). The static analysis tool () then propagates these function summaries bottom-up through the call graph using standard methods. In various embodiments of the invention, the generated function summaries may contain any portion of the following information, expressed in terms of function arguments, return values, constants, and globals:\n\n","In one or more embodiments of the invention, the static analysis tool () includes functionality to perform an intraprocedural data flow analysis over each function that contains a potential bug. The intraprocedural data flow analysis may be performed after the function summaries are computed. At each function call-site encountered during the dataflow that may affect the bug, the static analysis tool () may update the dataflow predicates according to the function summary.","In one or more embodiments of the invention, the static analysis repository () is configured to store program property definitions, flow values, predicate expressions, predicate domains, and\/or model data corresponding to the source code. The static analysis repository () may be implemented as a relational database, a hard disk drive, a networked array of storage devices, a software component (e.g., a data structure), a portion of a random access memory, and\/or any physical or virtual storage device. Examples of model data may include one or more CFGs, graph nodes, graph edges, virtual memory models, program values, and\/or any data necessary for modeling and\/or checking of source code. In one or more embodiments of the invention, the static analysis repository () is configured to store one or more program property definitions and\/or program property analyses related to a CFG.","In one or more embodiments of the invention, the static analysis tool () includes functionality to communicate with an integrated development environment (not shown) and\/or various other components of the system through the management module () (or directly).","In one or more embodiments of the invention, the static analysis tool () is configured to obtain source code from a user. For example, the user may be a software tester, an engineer, an applications developer, an author of the source code, and\/or a user of an integrated development environment. In one or more embodiments of the invention, the static analysis tool () includes a graphical user interface configured to obtain input from the user. Thus, the user may define\/modify\/select one or more program property definitions, source code, and\/or initiate bug checking using the graphical user interface.","In one or more embodiments of the invention, the static analysis tool () includes functionality to initiate one or more periodic bug checking routines. In one or more embodiments of the invention, the static analysis tool () receives a definition of the timing and\/or scope of the bug checking routine from the user. A bug checking routine may include one or more program property definitions to be used in the routine in accordance with one or more embodiments of the invention. In one or more embodiments of the invention, the static analysis tool () is configured to receive the one or more program property definitions and\/or source code from the source code repository (). For example, bug checking routines may be executed against at least a portion of a code base of a concurrent versioning system (CVS) stored in the source code repository, including multiple source code documents authored by one or more software developers.","In one or more embodiments of the invention, the source code repository () is configured to store source code. The source code repository () may be implemented as a software repository such as a relational database, a flat file, a folder, and\/or any means of storing data on one or more hardware devices. The source code repository () may be an integrated part of a software application such as a CVS or an integrated development environment. Alternatively, the source code repository () may be implemented as a hard disk drive, a network storage device, and\/or any type of memory device.","The memory () may be a Random Access Memory (RAM), a hardware cache, flash memory, and\/or any other type of volatile or non-volatile storage medium. Further, the memory () may include functionality to store model data (i.e., graph nodes, graph edges, flow values, etc.) during generation and\/or analysis of a CFG. In one or more embodiments of the invention, if the size of the CFG grows beyond a pre-defined threshold defined by a user or other entity, the model generator () is configured to cancel the modeling process and produce an error message. The pre-defined threshold may be defined by a user within a graphical user interface of the static analysis tool (). A virtual memory space may be constructed by the model generator () within the memory () for the purpose of generating and\/or verifying the CFG. In this way, virtual memory \u201cvalues\u201d corresponding to one or more model objects may be utilized (e.g., as program values) by the static analysis tool ().","In one or more embodiments of the invention, the management module () provides interoperability, format conversion and\/or cross-compatibility among the various components of the system (), as illustrated in an exemplary form in . For example, the management module () may transfer data between the static analysis tool () and the source code repository (), and\/or vice-versa. Furthermore, the management module () may be used as a seamless integration point between any combination of components both within and outside of the system ().","In one or more embodiments of the invention, various components of the system () are optional and\/or may reside within other components or may be located on one or more physical devices.",{"@attributes":{"id":"p-0066","num":"0072"},"figref":["FIG. 2","FIG. 2","FIG. 2"]},"In STEP , source code is obtained. The source code may be obtained from a user, a software program (e.g., an integrated development environment), and\/or any other entity. In one or more embodiments of the invention, the source code may be obtained in accordance with a periodic bug checking routine (e.g., a script performing one or more bug checking tasks), which obtains a pre-defined list of computer programs and\/or portions of one or more computer programs.","In STEP , a CFG model of the source code is created. The CFG includes a set of graph nodes representing basic blocks of the source code and a set of directed graph edges connecting the graph nodes. The CFG is a model of one or more potential execution paths of the source code. The flowchart depicted by  shows a method of constructing a CFG in accordance with one or more embodiments of the invention.","In STEP , a program property definition is obtained. The program property definition may include logic for identifying a program property based on the CFG. The program property definition may include a criteria for selecting a node of the CFG as a starting point for backward traversal of the CFG. In one or more embodiments of the invention, the program property definition also includes criteria for identifying one or more statements in a basic block of the CFG. The program property definition may assign a specified flow value to a predicate expression, during a traversal of the CFG, based on identifying the statements. Thus, in one or more embodiments of the invention, the program property definition includes rules, values, and logic necessary for analysis of a CFG in order to identify a specified program property type.","In STEP , a backward traversal of the CFG is performed. In one or more embodiments of the invention, an initial flow value is created at a starting node of the traversal. During the traversal, a set of predicate expressions representing flow values at various graph edges throughout the traversal path are generated and propagated upwards through the CFG. A resulting predicate expression is then calculated at a target node (i.e., a node identified as a stopping point of the traversal based on the program property definition) of the CFG. The predicate expressions are generated based on a predefined predicate domain, in accordance with one or more embodiments of the invention.","In STEP , a program property is identified based on one or more of the predicate expressions. In one or more embodiments of the invention, a resulting predicate expression of a target graph node is evaluated in order to determine whether the program property exists. For example, a static analysis tool (e.g., static analysis tool () of , discussed above) may determine that the program property exists if the resulting predicate expression evaluates to TRUE.",{"@attributes":{"id":"p-0072","num":"0078"},"figref":["FIG. 3","FIG. 3","FIG. 3"]},"In STEP , one or more control structures are identified within source code. The control structures may be identified by parsing the source code into tokens and then matching the tokens to one or more predefined control statements defined by the programming language in which the source code is written. Each control structure, when executed, results in a selection of a path among a set of two or more alternative paths.","In STEP , a set of basic blocks of reachable code within the source code are identified based on the control structures. In one or more embodiments of the invention, by identifying the control structures, it is possible to divide the source code into basic blocks by identifying sets of statements and\/or instructions which are necessarily executed together (i.e., not separated by any control structures).","In STEP , a set of graph nodes representing the basic blocks are created. A graph node is a model object representing a basic block in the CFG. The set of graph nodes may include an entry graph node representing an entry point of the CFG and an exit graph node representing an exit point of the CFG. The set of graph nodes may also include one or more branch graph nodes, each having two or more outgoing directed graph edges. In one or more embodiments of the invention, the entry point of the traversal may be a non-entry node and the exit point of the traversal may be a non-exit node of the graph. Thus, according to the type of program property being identified, the traversal of the CFG may cover only a subset of the CFG.","In STEP , a set of directed graph edges connecting the graph nodes are created based on the identified control structures. Each directed graph edge connects a source graph node with a destination graph node according to a corresponding control structure.","In STEP , two or more edge predicates are extracted from each control structure. Each directed graph edge is assigned an edge predicate such that the predicate evaluates to true if and only if the edge would be executed during normal program execution. In this way, each edge predicate may define a condition for selecting an execution path among the alternate execution paths defined by the control structure. The edge predicates may be extracted from the control structure by parsing the control structure into tokens and identifying one or more program values. In one or more embodiments of the invention, the program values may be used to construct the base predicate and\/or simplify an expression extracted from the control structure such that the base predicate is representable in base predicate form. In STEP , each extracted edge predicate is assigned to a corresponding directed graph edge.","In one or more embodiments of the invention, the CFG is created by a model generator (e.g., model generator () of , discussed above) during a single pass or analysis of the source code. Thus, various STEPS of  may be performed concurrently and\/or may be performed iteratively as the source code is analyzed. In one or more embodiments of the invention, both the creation of the CFG and a path-sensitive analysis of the CFG are performed in a single pass of the source code. The flowchart depicted by  shows a method of performing a path-sensitive analysis of a CFG, in accordance with one or more embodiments of the invention.",{"@attributes":{"id":"p-0079","num":"0085"},"figref":["FIG. 4","FIG. 4","FIG. 4"]},"In STEP , a Boolean flow value is created at a selected node of the CFG. The Boolean flow value may be obtained from a program property definition and may represent the state of a potential program property at a beginning of a traversal through the CFG. For example, for analysis of potential memory leaks, a FALSE Boolean flow value may be created at an exit node of the CFG. In this example, according to the program property definition, a FALSE value of any flow value in the CFG indicates that, at that point in the analysis, existence of the program property has not been ruled out. In one or more embodiments of the invention, the Boolean flow value at the selected node is considered the first predicate expression among a set of predicate expressions which represent flow values throughout the CFG.","In STEP , a current graph edge is selected for analysis based on a backward traversal of the CFG. In one or more embodiments of the invention, the traversal method defined by the program property definition requires selection of a graph edge for analysis which is connected to a traversed (i.e., visited) node. A traversed node is any node for which all outgoing graph edges are also traversed. In one or more embodiments of the invention, a graph edge is said to be traversed if a predicate expression corresponding to the graph edge is calculated. Generation of the predicate expression may refer to simply propagating the predicate expression from a dependent graph edge. For example, if the process has only visited an exit graph node of the CFG at this stage (e.g., in STEP ), the next selected graph edge may be any edge connected to the exit node (according to the traversal method).","In STEP , it is determined whether a destination graph node of the current graph edge has two or more outgoing directed graph edges. In one or more embodiments of the invention, the traversal method requires that the outgoing directed graph edges be traversed. If it is determined that the destination graph node has two or more outgoing directed graph edges, the process proceeds to STEP . Conversely, if it is determined that the destination graph node has only one outgoing directed graph edge, the process proceeds to STEP .","In STEP , a conjoined predicate expression is computed, for each outgoing graph edge, as a conjunction of the predicate expression of the outgoing edge with an edge predicate of the outgoing edge. If the destination graph node of the current graph edge is a starting node of the traversal, the predicate expression may be a flow value assigned to the starting node. In one or more embodiments of the invention, the predicate expression, as with any predicate expression calculated during the analysis, may be simplified at each relevant STEP using one or more logical deduction rules (e.g., the deduction rules shown in Table 2, above).","In STEP , a current predicate expression representing a flow value at the current graph edge is computed as a disjunction of the conjoined predicate expressions. In one or more embodiments of the invention, the current predicate expression represents a path-sensitive flow value at the current graph edge.","In STEP , a predicate expression is propagated from the only outgoing graph edge as a current predicate expression representing a flow value at the current graph edge.","In STEP , the current predicate expression is modified based on one or more source code statements in the basic block of the destination node. Modifications may include simplifying the predicate expression based on one or more criteria defined by the program property definition or replacing the predicate expression entirely with a new expression and\/or value. In one or more embodiments of the invention, the predicate expression depicts the state of the potential program property. Accordingly, the modification may indicate that the potential program property is verified to not exist at the current location in the CFG and\/or any dependent locations. In one or more embodiments of the invention, in STEP  it may be determined that the basic block of the destination node does not contain any statements matching the criteria of the program property definition, in which case the flow value at the current graph node remains unchanged.","In one or more embodiments of the invention, STEP  occurs prior to the execution of STEPS  and . Thus, the current predicate expression may not be calculated until the modification of STEP  is completed on the propagated predicate expressions. In one or more embodiments of the invention, irrespective of the order of these STEPS, the current predicate expression does not represent the flow value at the current graph edge until the modification (if any) of STEP  is performed.","In one or more embodiments of the invention, all directed graph edges having the same destination graph node are assigned the same predicate expression. Thus, STEPS - may be performed only once for directed graph edges having the same destination graph node.","In STEP , it is determined whether the CFG is traversed. If it is determined that the CFG is not yet traversed, the process proceeds to STEP . If it is determined, based on the predefined traversal method, that the CFG is traversed, the process proceeds to STEP . In one or more embodiments of the invention, upon traversing a target graph node identified by the program property definition, the CFG is deemed to be traversed.","In STEP , a program property is identified in the source code based on a flow value at a target graph node of the CFG. In one or more embodiments of the invention, the program property is identified using a criteria of the program property definition, which may include instructions for interpreting the resulting flow value.","In a first example, a use-after-free program property definition is directed towards the detection of use-after-free bugs (i.e., cases where a pointer variable is dereferenced after the memory allocation has been freed). In this example, the static analysis tool begins by creating a Boolean flow value at a selected graph node of a CFG model of source code. The Boolean flow value is initialized to TRUE to indicate that a possible use-after-free bug is not yet detected, and subsequent flow values are set to FALSE upon encountering a use of a possibly deallocated pointer during a backward traversal of the CFG. If a predicate expression other than TRUE is backward propagated to a deallocation statement of the possibly-freed value, the static analysis tool reports a use-after-free bug.","In a second example, a path reachability program property definition is directed towards determining whether there exists a feasible path in a CFG model of source code from a designated source node, to a sink node (i.e., whether it is possible for the program to execute the source node's basic block, and then subsequently execute the sink node's basic block). The source node is a non-entry node of the CFG and the sink node is a non-exit node of the CFG.","In this example, a static analysis tool performs two data flow passes. For the first pass, the static analysis tool initializes a Boolean flow-value at the exit node of the CFG to TRUE (in this case to indicate that there is no path between the source and sink nodes), and assigns a value of FALSE to any subsequent flow value when the sink node is reached in the backward traversal. The static analysis tool computes a first resulting predicate expression at the source node as a path predicate. If the path predicate after data flow propagation is TRUE, then there is no feasible path between the two nodes. Conversely, if the predicate is FALSE, then we know that every path from the source node must reach the sink node.","Continuing the example, if the predicate has any other value, then the reachability may be dependent on branch conditions prior to the source node. To check for this possibility, the static analysis tool performs a second data flow pass, this time setting the flow-value to the previously determined path predicate at the source node, and ignoring the sink node. The static analysis tool again performs the backward traversal from the source node to the entry node and extracts a second resulting predicate expression at the entry node. If the disjunction of this predicate and the previous path predicate is TRUE, then again there is no feasible path between the source and sink; otherwise, a path may exist.",{"@attributes":{"id":"p-0095","num":"0101"},"figref":"FIG. 5A","b":"599"},{"@attributes":{"id":"p-0096","num":"0102"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sample pseudocode corresponding to FIGS. 5A and 5B"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1","void example ( ) {"]},{"entry":[{},"2","\u2003\u2003\u2003int err = 0, fd;"]},{"entry":[{},"3","\u2003\u2003\u2003int *tmp = allocateMemory ( ... );"]},{"entry":[{},"4","\u2003\u2003\u2003fd = open( \u201cfile.txt\u201d );"]},{"entry":[{},"5","\u2003\u2003\u2003if ( fd equals \u22121 ) {"]},{"entry":[{},"6","\u2003\u2003\u2003\u2003\u2003\u2003err = 1;"]},{"entry":[{},"7","\u2003\u2003\u2003\u2003\u2003\u2003goto cleanup;"]},{"entry":[{},"8","\u2003\u2003\u2003}"]},{"entry":[{},"9","\u2003\u2003\u2003close( fd );"]},{"entry":[{},"10","\u2003\u2003\u2003free( tmp );"]},{"entry":[{},"11","cleanup:"]},{"entry":[{},"12","\u2003\u2003\u2003if( err not equal to 0 ) {"]},{"entry":[{},"13","\u2003\u2003\u2003\u2003\u2003\u2003free( tmp );"]},{"entry":[{},"14","\u2003\u2003\u2003\u2003\u2003\u2003tmp = NULL;"]},{"entry":[{},"15","\u2003\u2003\u2003}"]},{"entry":[{},"16","}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In a third example, a static analysis tool (e.g., static analysis tool () of , discussed above) obtains source code represented by the pseudocode in Table 3 (above). In this example, the static analysis tool is a bug checker that is executed by a command line interface.","Continuing the example, the static analysis tool proceeds to identify basic blocks of the source code and to generate the CFG () depicted by  based on the basic blocks. As shown in , the static analysis tool creates a set of graph nodes representing the basic blocks (graph nodes , , , , , and ). The graph nodes are connected by graph edges depicting potential execution paths of the source code. Based on the CFG () alone, it is not possible to determine which paths are feasible and which are infeasible. For purposes of illustration, the feasible paths of the CFG () are depicted in  as solid lines while the infeasible paths are depicted as dashed lines. The two feasible paths, in execution order of the graph nodes in  are: \u2192\u2192\u2192 and \u2192\u2192\u2192\u2192. The infeasible paths shown in  are: \u2192\u2192\u2192\u2192 and \u2192\u2192\u2192.","Continuing the example, the static analysis tool identifies the exit graph node () of the CFG () as a starting node of a backward traversal. The exit graph node is identified based on a memory leak program property definition. Also based on the program property definition, as shown in , the static analysis tool assigns a Boolean flow value of FALSE to the exit graph node ().","Continuing the example, the static analysis tool begins the backward traversal of the CFG () by visiting the graph edge connecting graph nodes  and . As depicted in , the static analysis tool simply propagates the value FALSE from the exit node to both of these edges. The static analysis tool then selects the graph edge connecting graph nodes  and  for analysis as the current graph edge. First, the static analysis tool propagates the FALSE predicate expression value from the lower graph edge (i.e., the edge connecting graph nodes  and ). Prior to assigning the same value to the current graph edge, the static analysis tool identifies a memory deallocation statement (i.e., \u201cfree( . . . )\u201d) in the basic block of graph node . This statement is present on line 13 of the example pseudocode of Table 3 (above). Thus, the current predicate expression is modified, based on the program property definition, to TRUE and assigned to the current graph edge.","Continuing the example, the static analysis tool then selects the graph edge connecting graph nodes  and  for analysis. The destination node of this graph edge is identified as node  and the outgoing graph edges of the destination node () are the graph edges connecting node  to nodes  and . The first outgoing graph edge (\u2192) of the destination node () is analyzed, and a conjoined predicate expression is calculated as a conjunction of the predicate expression for the first outgoing graph edge (\u201cFALSE\u201d) and the edge predicate \u201cerr=0\u201d. The conjoined predicate expression is computed to be \u201cFALSE(err=0)\u201d. A conjoined predicate expression for the second outgoing graph edge (\u2192) of the destination graph node () is similarly calculated as \u201cTRUE(err\u22600)\u201d. The current predicate expression of the current graph edge (\u2192) is then calculated as the disjunction of the conjoined predicate expressions: \u201c[FALSE(err=0)][TRUE(err\u22600)])\u201d. The static analysis tool simplifies this predicate expression to \u201cerr\u22600\u201d based on a set of deductive rules for disjoint predicate expressions (e.g., see Table 2, above). This current predicate expression is also propagated to every graph edge having the same destination graph node () as the current graph edge (\u2192). Thus, graph edge \u2192 is also assigned the predicate expression \u201cerr\u22600\u201d as shown in .","Continuing the example, the static analysis tool selects graph edge \u2192 as the current graph edge for analysis. The only outgoing graph edge of the destination node for this current graph edge (\u2192) is graph edge \u2192. The static analysis tool also identifies, based on the program property criteria, a \u201cfree\u201d statement on line  of the basic block of the destination node (). The static analysis tool modifies the current predicate expression to \u201cTRUE\u201d as a result of identifying the statement. The \u201cfree\u201d statement indicates that memory has been deallocated and, thus, the potential for memory leak does not exist (for the specified allocation of memory). Next, the static analysis tool selects graph edge \u2192 as the current graph edge for analysis (based on the traversal method). The predicate expression of graph edge \u2192 is propagated upward and is then modified based on the source code statement on line 6 of the source code (in the basic block of the destination node ()). The source code statement of line 6 is an assignment \u201cerr=1\u201d and thus guarantees the propagated predicate expression \u201cerr\u22600\u201d to equal TRUE. Again, the source code statement is identified and the modification is performed based on criteria defined by the program property definition.","Continuing the example, the two \u201cTRUE\u201d predicate expressions of graph edges \u2192 and \u2192 are disjoined as \u201cTRUETRUE\u201d and a resulting predicate expression is calculated as \u201cTRUE\u201d. Note that, in the example, the static analysis tool only identified source code statements which required modification of predicate expression values for graph nodes , , and , although the check was performed during the traversal of each graph node (except the exit graph node ()). The static analysis tool determines, based on the resulting predicate expression (\u201cTRUE\u201d), that a memory leak defect does not exist within the source code.",{"@attributes":{"id":"p-0104","num":"0110"},"figref":"FIG. 6","b":"699"},{"@attributes":{"id":"p-0105","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sample pseudocode corresponding to FIG. 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1","void example( ) {"]},{"entry":[{},"2","\u2003\u2003\u2003int err = 0, fd, len;"]},{"entry":[{},"3","\u2003\u2003\u2003int *tmp = allocateMemory ( ... );"]},{"entry":[{},"4","\u2003\u2003\u2003fd = openFile( \u201cfile.txt\u201d );"]},{"entry":[{},"5","\u2003\u2003\u2003if( fd equals \u22121 ) {"]},{"entry":[{},"6","\u2003\u2003\u2003\u2003\u2003\u2003err = 1;"]},{"entry":[{},"7","\u2003\u2003\u2003\u2003\u2003\u2003goto cleanup;"]},{"entry":[{},"8","\u2003\u2003\u2003}"]},{"entry":[{},"9","\u2003\u2003\u2003result = readFile( fd );"]},{"entry":[{},"10","\u2003\u2003\u2003if( result equals \u22121 ) {"]},{"entry":[{},"11","\u2003\u2003\u2003\u2003\u2003\u2003goto cleanup;"]},{"entry":[{},"12","\u2003\u2003\u2003}"]},{"entry":[{},"13","\u2003\u2003\u2003close( fd );"]},{"entry":[{},"14","\u2003\u2003\u2003free( tmp );"]},{"entry":[{},"15","cleanup:"]},{"entry":[{},"16","\u2003\u2003\u2003if( err not equal to 0 ) {"]},{"entry":[{},"17","\u2003\u2003\u2003\u2003\u2003\u2003free( tmp );"]},{"entry":[{},"18","\u2003\u2003\u2003\u2003\u2003\u2003tmp = NULL;"]},{"entry":[{},"19","\u2003\u2003\u2003}"]},{"entry":[{},"20","}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"In a fourth example, a memory leak defect analysis is performed on the source code depicted by the sample pseudocode of Table 4 (above).  shows predicate expressions representing flow values at each directed graph edge of the CFG () as well as an initial Boolean flow value of \u201cFALSE\u201d at exit node  and a resulting predicate expression of \u201c(result\u2260\u22121)(fd=\u22121)\u201d at entry node . In accordance with one or more embodiments of the invention, a backward traversal of the CFG () was performed in order to generate these predicate expressions. The feasible paths \u2192\u2192\u2192\u2192, \u2192\u2192\u2192, and \u2192\u2192\u2192\u2192 are identified by solid lines while the infeasible paths \u2192\u2192\u2192\u2192 and \u2192\u2192\u2192 are identified by dashed lines.","In this example, the static analysis tool determines, based on the resulting predicate expression not being equal to \u201cTRUE\u201d, that the defect exists within the source code. In this example, a feasible program property path of the CFG () is identified as \u2192\u2192\u2192. The feasible program property path is shown in  as a heavy solid line. Due to the path sensitive generation of the resulting predicate expression and the other predicate expressions in the CFG (), the identified program property path is guaranteed to be a feasible path. Furthermore, the program property path can be identified based solely on the resulting predicate expression by identifying graph edges which are annotated (during traversal) as potentially corresponding to a program property path. For example, by identifying annotations recorded against blocks , , , and , we see that \u2192\u2192\u2192 is the only feasible execution path. In this example, the static analysis tool constructed the CFG () and computed the predicate expressions in a single pass over the source code.","Embodiments of the invention may be implemented on virtually any type of computer regardless of the platform being used. For example, as shown in , a computer system () includes one or more processor(s) () (such as a central processing unit (CPU), integrated circuit, hardware processor, etc.), associated memory () (e.g., random access memory (RAM), cache memory, flash memory, etc.), a storage device () (e.g., a hard disk, an optical drive such as a compact disk drive or digital video disk (DVD) drive, a flash memory stick, etc.), and numerous other elements and functionalities typical of today's computers (not shown). The computer system () may also include input means, such as a keyboard (), a mouse (), or a microphone (not shown). Further, the computer system () may include output means, such as a monitor () (e.g., a liquid crystal display (LCD), a plasma display, or cathode ray tube (CRT) monitor). The computer system () may be connected to a network () (e.g., a local area network (LAN), a wide area network (WAN) such as the Internet, or any other type of network) via a network interface connection (not shown). Those skilled in the art will appreciate that many different types of computer systems exist, and the aforementioned input and output means may take other forms. Generally speaking, the computer system () includes at least the minimal processing, input, and\/or output means necessary to practice embodiments of the invention.","Further, in one or more embodiments of the invention, one or more elements of the aforementioned computer system () may be located at a remote location and connected to the other elements over a network. Further, embodiments of the invention may be implemented on a distributed system having a plurality of nodes, where each portion of the invention (e.g., static analysis tool ( of ), model generator ( of ), static analysis repository ( of ), source code repository ( of ), etc.) may be located on a different node within the distributed system. In one embodiment of the invention, the node corresponds to a computer system. Alternatively, the node may correspond to a processor with associated physical memory. The node may alternatively correspond to a processor or micro-core of a processor with shared memory and\/or resources. Further, software instructions in the form of computer readable program code to perform embodiments of the invention may be stored, temporarily or permanently, on a non-transitory computer readable storage medium, such as a compact disc (CD), a diskette, a tape, memory, or any other tangible computer readable storage device.","One or more embodiments of the invention have one or more of the following advantages. By utilizing a predefined predicate domain to generate one or more predicate expressions, the maximum size of the predicate expressions may be linear in the size of the CFG, and the predicate expressions may be amenable to solving via the use of substitution, logic, and integer arithmetic, without requiring an external theorem prover or constraint solver. This may lead to increased scalability of an analysis algorithm, in accordance with one or more embodiments of the invention.","Furthermore, source code may be represented in static single assignment (SSA) form. Source code having an intermediate representation in SSA form, when utilized in conjunction with one or more of the systems and\/or methods disclosed herein, may improve the performance and\/or precision of the aforementioned systems or methods.","Furthermore, while utilizing a predefined predicate domain may reduce the theoretical power of the analysis algorithm, in certain applications the predicate domain does not significantly impact the precision of the framework, as the predicate domain may be defined in a manner consistent with the way in which programmers typically manage control flow within programs. That is, in certain applications, the program may contain one or more flag variables which are set to different constant values according to the operations performed by the program, such that appropriate cleanup (i.e., release of resources) can be performed at the end of the program. By focusing on representing the flag variables, an analysis algorithm may spend reduced time considering values or predicates that are incidental to this purpose, in accordance with one or more embodiments of the invention.","While the invention has been described with respect to a limited number of embodiments, those skilled in the art, having benefit of this disclosure, will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly, the scope of the invention should be limited only by the attached claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIGS. 2-4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
