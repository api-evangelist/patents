---
title: Permutation nuances of the integration of processes and queries as processes at queues
abstract: A program that includes expressions written in a process-based language for representing protocol-based applications as processes is disclosed. A process kernel executes the expressions in the program. The process kernel parses an expression to obtain syntactical elements that represent a queue, a set of queue delimiters, a query, a sequence delimiter, and other actions. The process kernel further translates the expression as a process whose first action is submitting the query as another process to the queue and after which the process continues with other actions. The query includes an organization scheme formed from a customizable, tag-based language that contains data and describes data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07055142&OS=07055142&RS=07055142
owner: Microsoft Corporation
number: 07055142
owner_city: Redmond
owner_country: US
publication_date: 20021122
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT","APPENDIX","Semantics","Structural Equivalence","Reduction Rules","Discussion","Match","Cut","Tensor-Par","With-Plus","Read","Copy","Discard","Context","Cleanup","Comm","Par","New","Lift","Equiv"],"p":["This application claims the benefit of U.S. Provisional Application No. 60\/379,864, filed May 10, 2002, entitled \u201cProcess Programming Language,\u201d which is expressly incorporated herein by reference.","The present invention relates generally to an artificial language, and more particularly, to a programming language that can be used to define a sequence of instructions that can ultimately be processed and executed by a concurrent, distributed network of computing resources.","Natural language is a language spoken or written by humans, as opposed to a programming language or a machine language. A programming language is any artificial language that can be used to define a sequence of instructions that can ultimately be processed and executed by a computer. Defining what is or is not a programming language can be tricky, but general usage implies that the translation process\u2014from the source code which is expressed using the programming language, to the machine code, which is the code that the computer needs to work with\u2014be automated by means of another program, such as a compiler. Both natural languages and programming languages are systematic means of communicating information and instructions from one entity to another, such as man to man or man to machine. Unfortunately, prior programming languages have been an imperfect way of communicating information and instructions from man to machine.","For example, early in the computing era, assembly languages were used to form low-level programming languages. Assembly languages use abbreviations or mnemonic codes in which each statement corresponds to a single machine instruction. Along with the advantage of high efficiency due to direct programmer interaction with system hardware and resources came the undesirable consequence of having to manually update ad hoc organizational schemes, such as data structures, when even slight changes were made to an assembly language program. The high-level languages of today, which provide a level of abstraction above the underlying machine language, evolved from assembly languages. High-level language statements generally use keywords (usually in English) that are translated into more than one machine-language instruction. High-level languages have built-in support for data structures and define a set of syntactic and semantic rules that define the structure of the language. When a slight change is made to a program written in a high-level language, a compiler, which transforms the program into object code by following a predetermined set of syntactic and semantic rules, either reflows the object code as necessary to correspond with the change made to the program or unabashedly informs a programmer of the apparent programming error.","Programmers have leveraged the ability of a compiler to detect errors in the invocation of application programming interfaces (APIs) by checking the signature of an invoking API against the corresponding signature of a defined API. An API is an interface of a program that defines the sort of inputs the program will accept to perform a desired task and the sort of outputs the program will return after the performance of the desired task. APIs allow programs to cooperate together to provide greater functionality than each could provide alone.","An API only specifies what must be provided to the API and what will be returned from the API\u2014not the behaviors of the program underlying the API. For example, to properly cooperate, an \u201cinitialization\u201d program must be called before a \u201cdo work\u201d program is called, and correspondingly, the \u201cdo work\u201d program must be called before a \u201cclean up\u201d program is called. APIs do not capture this ordering idea, or any other ideas that express how programs should cooperate. As a result, like the laborious tasks of maintaining the assembly programs of yesteryear, programmers must once again fit square pegs into round holes by working within the limit of the expressiveness of present high-level languages to ensure that programs correctly cooperate.","The foregoing problem is exacerbated with the proliferation of Web services, which are basically programs located on any number of computing devices interconnected by the Internet. Whereas the specification and the laborious verification of the cooperation of programs within a single computing device can be undertaken\u2014albeit arduously\u2014the task of verifying the intricate ballet associated with the cooperation of multiple Web services (which send multiple messages from multiple computing devices) is an insurmountable problem because of the lack of the expressiveness of present high-level languages. What is needed is a programming language that can express the cooperative dimensions of programs or services, such as ordering and timing, among other things, so that such cooperative dimensions can be programmatically verified.","One partial solution is the use of \u03c0-calculus, which is a mathematical language for describing processes in interactive, concurrent systems, such as a system  shown in . The system  includes a client , which is a computer that accesses shared network resources being provided by another computer, such as a server , on a local area network or a wide area network, such as the Internet . A number of Web services ,  are statically stored as programs on the client  and the server .","Early operating systems allowed users to run only one program at a time. Users ran a program, waited for it to finish, and then ran another one. Modern operating systems allow users to execute (run) more than one program at a time or even multiple copies of the same program at the same time. A thread is the basic unit used by the operating system to allocate processor time to a program. A thread can include any part of the programming code, including parts currently being executed by another thread. A processor is capable of executing only one thread at a time. However, a multi-tasking operating system, i.e., an operating system that allows users to run multiple programs, appears to execute multiple programs at the same time. In reality, a multi-tasking operating system continually alternates among programs, executing a thread from one program, then a thread from another program, etc. As each thread finishes its sub-task, the processor is given another thread to execute. The extraordinary speed of the processor provides the illusion that all of the threads execute at the same time.","While the terms multi-tasking and multi-processing are sometimes used interchangeably, they have different meanings. Multi-processing requires multi-processors. If a machine has only one processor, the operating system can multi-task, but not multi-process. If a single machine has multiple processors or there are multiple machines (the client  and the server ), each of which has a processor, the operating system of the single machine or the operating systems of multiple machines can both multi-task and multi-process. Both a single machine having multiple processors and multiple machines, each having a processor, define a concurrent system. This is an object of interest for \u03c0-calculus.","The core of \u03c0-calculus consists of systems of independent, parallel processes (such as Web services , ) that communicate via links (such as a link ). Links can be any of the following: APIs that become as remote procedure calls; hypertext links that can be created, passed around, and removed; and object references (e.g., \u201crose\u201d) passed as arguments of method invocations in object-oriented systems. The possibilities of communication for a process with other processes depends on its knowledge of various different links. Links may be restricted so that only certain processes can communicate on them. What sets the \u03c0-calculus apart from other process languages is that the scope of a restriction (the context in which a link may be used) may change during execution. For example, when the Web Service  sends a restricted name, such as an API previously known only to the Web Service , as a message to the Web service , which is outside the scope of the restriction, the scope is expanded (or extruded in the mathematic idiom of \u03c0-calculus). This means that the scope of the API is enlarged to embrace the Web service  receiving the API. In other words, the Web service  can now invoke the function represented by the API whereas before the Web service  had no knowledge of the API, hence was unable to invoke the API. This procedure allows the communication possibilities of a process to change over time within the framework of \u03c0-calculus. A process can learn the names of new links via scope extrusion. Thus a link is a transferable quantity for enhancing communication.","What has been central, foundational, and unchanging about \u03c0-calculus is its intense focus on names, such as \u201crose,\u201d and the passing of names as messages over links. In particular, \u03c0-calculus places great emphasis on pure names, each of which is defined to be only a bit pattern. One example of a pure name is the 128-bit space GUID (Globally Unique Identifier) that uniquely identifies an interface or an implementation in the COM component model. Another example of a pure name is a function signature or an API as described above. For additional emphasis, consider the above-discussed problem in this light: suppose there are three APIs (\u201cinitialization,\u201d \u201cdo work,\u201d and \u201cclean up\u201d) sent to the Web service  from the Web service , but the Web service  must invoke these three APIs only in a particular order (e.g., \u201cinitialization\u201d and then \u201cdo work\u201d and then \u201cclean up\u201d). While existing \u03c0-calculus and its variants allow the three APIs to be sent over the link  to reach the Web service  from the Web service , the existing \u03c0-calculus and its variants lack a way for the Web service  to express to the Web service  the particular order in which the three APIs are to be invoked. In this sense, existing \u03c0-calculus and its variants cannot completely express the cooperative dimensions of programs or services, such as ordering and timing, among other things, so that such cooperative dimensions can be programmatically verified.","One Elizabethan poet succinctly provided this adage, metaphorical in form but embodying a timeless observation: \u201cWhat's in a name? That which we call a rose by any other name would smell as sweet.\u201d This observation made long ago precisely points to a present problem of \u03c0-calculus and its variants\u2014a lack of tolerance for the passage of structured data on named links (such as the link ). In fact, \u03c0-calculus unfavorably refers to structured data as \u201cimpure names,\u201d which is a negative linguistic construction. Pureness is desirable while impurity is abhorred. Thus impure names in the context of \u03c0-calculus are data with some kind of recognizable structure, such as an extensible markup language (XML) document. In practice, it is useful (and at times necessary) for one process to communicate structured data to another process.","Without a flow of data, it is difficult to facilitate communication between processes\u2014except in a very indirect way\u2014to represent mobility or dynamism among processes. To solve this problem, computer scientists have investigated the possibility of allowing processes to flow in communication over links. For example, a process  may send to the process  a message which represents a third process (not shown). This is known as higher-order \u03c0-calculus. Because of the rigidity with which \u03c0-calculus handles pure names, instead of sending a process over a link, even higher-order \u03c0-calculus variants send a name, which gives access to a desired process, instead of sending the process itself.","Sending a name, rather than a process, can be likened to the traditional programming technique of passing by reference, i.e., passing an address of a parameter from a calling routine to a called routine, which uses the address to retrieve or modify the value of the parameter. The main problem with employing the passing by reference technique in higher-order \u03c0-calculus variants is that the technique can inhibit the ability of a concurrent system to become distributed. There are many implementations of \u03c0-calculus, namely PICT, Nomadic PICT, TyCO, Oz, and Join, among others. However, these other implementations are either not distributed (PICT) or are not higher-order forms of the \u03c0-calculus (Nomadic PICT, TyCo, Oz, and Join).","Thus there is a need for better methods and systems for allowing processes in concurrent, distributed computing networks to interact while avoiding or reducing the foregoing and other problems associated with existing \u03c0-calculus and its variants.","In accordance with this invention, a method and computer-readable medium for processing programs written in a process-based language is provided. In accordance with this invention, a method form of the invention comprises parsing the expression to obtain syntactical elements that represent a queue, a set of queue delimiters, a query, a sequence delimiter, and other actions. The method translates the expression as a process whose first action is submitting the query as another process to the queue and after which the process continues with other actions. The query includes an organization scheme formed from a customizable, tag-based language that contains data and describes data.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","b":["200","200","200"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well-known computing systems, environments and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention is described in the general context of computer-executable instructions, such as program modules being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc., that perform particular tasks or implement particular abstract data types.","The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media, including memory storage devices.","The computing system environment illustrated in  includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such bus architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus, also known as Mezzanine bus.","Computer  typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer-readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer-readable instructions, data structures, program modules, or other data. Computer storage media include, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tapes, magnetic disk storage or other magnetic storage devices, or any other computer storage media. Communication media typically embody computer-readable instructions, data structures, program modules or other data in a modulated data signal, such as a carrier wave or other transport mechanism that includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired media, such as a wired network or direct-wired connection, and wireless media, such as acoustic, RF infrared, and other wireless media. A combination of any of the above should also be included within the scope of computer-readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory, such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates the hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, the magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD-ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital videotapes, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface, such as interface , and the magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer-readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices, such as a keyboard  and pointing device , the latter of which is commonly referred to as a mouse, trackball, or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port, or universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices, such as speakers  and printer , which may be connected through an input\/output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device, or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such network environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the input\/output peripheral interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are for illustrative purposes only and other means of establishing a communication link between the computers may be used.","A system , which is a collection of component elements that work together to perform one or more computing tasks, is illustrated in . One example is a hardware system , which can comprise a number of computing devices, such as a personal digital assistant , a cellular phone , and a desktop computer , each comprising a microprocessor, its allied chips and circuitry, input and output devices, and peripheral devices (not shown). For ease of illustration, the only depicted computing devices in subsequent figures are personal digital assistants (PDAs).","The system  includes an operating system , comprising a set of programs and data files, such as an operating system kernel A, one or more device drivers B, and a process kernel C. Subjacently coupled to the operating system  is a hardware abstraction layer . The hardware abstraction layer  is an application programming interface for use by programmers to access devices of the hardware system  (such as the computing device , the cellular phone , and the desktop computer ). The operating system kernel A is the core of the operating system  and is designed to manage memory, files, and peripheral devices (via the hardware abstraction layer ); maintain the time and date; launche applications, such as a Web service A; and allocate system resources. Device drivers B are separate components that permit the Web service A to communicate with a device, such as the computing device . The process kernel C represents the Web service A as a process B, manages the process B, and facilitates the communication of the process B with other processes (described below). The operating system kernel A, the device drivers B, and the process kernel C reside in the kernel-mode portion of the operating system  while the Web service A and the process B reside in a user-mode portion  of the operating system . Alternatively, the process kernel C can reside in the user-mode portion  when it is superjacently coupled to other system software components ,  (), such as COM (Component Object Model).","The term \u201cprocess\u201d used in accordance with the present invention means a dynamic representation of one or more computation entities that have the capability to evolve by performing actions or that allow other processes to evolve. In other words, the term \u201cprocess\u201d represents one of a duality of natures of a computation entity. When a computation entity is at rest, it can be examined, such as by viewing a program. When a computation entity is mobile (as a process), it cannot be seen, but its behaviors can be expressed and verified by a programming language  formed in accordance with the present invention (described below).","The Web service A is designed to specialize in a certain service. To obtain greater functionality, the Web service A can enlist the help of other Web services that can provide services not within the scope of the Web service A. To track down other Web services, the Web service A can communicate with a directory framework . The directory framework  is a platform-independent piece of software (a directory framework) that provides a way to locate and register Web services on the Internet. The directory framework  includes a store  containing a number of registered Web services and including detailed technical information about these Web services. A discovery component  of the directory framework  acts as a broker between the process B and the store  to locate a desired Web service.","Once the directory framework  finds an appropriate Web service requested by the Web service A, the Web service A can begin to interact with the discovered Web service to accomplish a desired task.  illustrates a discovered Web service A. The process kernel C represents the Web service A as a process B, which interacts with the process B over a communication means, such as a queue , to accomplish tasks of Web services A, A.","The queue  through which processes communicate can take various forms, such as databases, channels, or other suitable structured stores. Because the computing devices ,  can be located at geographic locations well away from each other, processes B, B cannot communicate via shared memory. Suitable communication means, such as the queue , include technology that enables processes B, B while running at different times to communicate across heterogeneous networks and systems that may be temporarily offline. Processes B, B send messages to communication means, and read messages from communication means. Communication means can provide guaranteed message delivery, efficient routing, security, and priority-based messaging. Additionally, communication means can be used to implement solutions for both asynchronous and synchronous scenarios requiring high performance. As indicated above, specific examples of suitable communication means include channels, queues, or databases, among other structured stores. When the queues \u2013 are databases, they are files composed of records, each containing fields together with a set of operations for searching, sorting, recombining, and other processing functions, organized in multiple tables, each of which are data structures characterized by rows and columns, with data occupying or potentially occupying each cell formed by a row-column intersection.","The internal architecture of process kernels C, C include process virtual machines C, C, which contain software components for defining processes and for governing interactions among processes; query virtual machines C, C, which contain software components for defining queries and for governing the interactions among queries and queues; reaction virtual machines C, C, which contain software components for governing the interactions among queries, queues, and processes; and transition virtual machines C, C, which contain software components for isolating the process kernels C, C from the specifics of system software components ,  (such as COM and the operating system, among others) on computing devices , .","Computing devices ,  interact, communicate, and exchange information over a local area network, wide area network, or wireless network . Processes B, B communicate over a queue  to exchange messages, such as a message . Unlike prior systems implementing \u03c0-calculus and its variants, the system  formed in accordance with the invention allows messages, such as the message , to be represented as processes by process kernels C, C in the exchange between processes B, B. This allows cooperative dimensions of programs or Web services, such as the invocation ordering of APIs, among many other things, to be expressed between processes B, B.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 3C","b":["300","302","304","306","308","300","300","302","304","306","308","302","308"]},"Processes B\u2013B cooperate to express to each other information sent as messages or queries to queues \u2013. Pieces of information sent over a communication means include ordering of execution, timing of data, quality of service, and passing of, among processes B\u2013B, an organizational scheme formed from a customizable, tag-based language that contains data and describes data in such a way as to facilitate the interpretation of data or the performance of operations on data. While one suitable customizable, tag-based language is extensible mark-up language (XML), the invention is not limited to this language. Other customizable, tag-based languages can be used.","Cooperative communication between processes B\u2013B is provided by the programming language  () formed in accordance with this invention. The language  is a high-order variant of the \u03c0-calculus. In other words, the language  is a process-based language. More specifically, in addition to other properties discussed below, the language  has the ability to programmatically detect \u201cliveness.\u201d Liveness is an indication that a process is alive. This quality needs to be programmatically verified in order for a program to be trusted to do the things it is designed to do. A program, such as the Web service A written in the language  can be programatically verified for \u201cliveness.\u201d Other properties include the ability to analyze the security of processes B\u2013B and resource access run-time errors. Security problems include the protection of computing devices \u2013 and their data from harm or loss. One major focus of security, especially for non-centralized networks, such as the system , that are accessed by many people through multiple queues , , , , is the prevention of access by unauthorized individuals. The Web service A written in the language  can be verified to detect security problems induced by untrustworthy Web programs or untrustworthy computing devices.","The formal mathematical definition of the language  is given in the Appendix. The language  includes the grammar, the rules for structural equivalents, and the rules for operational semantics. The grammar of the language  is the system of rules that define the way in which the syntactical elements of queries and processes are put together to form permissible programming statements. In other words, unless one can express correctly in the grammar of the language , one cannot communicate concepts, such as the invocation of APIs, from one process to another process. Once an expression is correctly formed, the rules of semantics connect the expression with meanings. Because processes are dynamic, the language  uses operational semantics to couple meanings to processes. In other words, processes evolve by acting or interacting with other processes. Understanding the meaning of an expression of the language  relates directly to understanding its operations. The rules for structural equivalence allow the operational semantics of the language  to be simplified in that an expression can be likened to another expression. Thus, the number of rules for operational semantics can be kept small since these rules can be applied to permutations of expressions.","The language  has several major syntactical categories: a queue syntax , which represents queues, databases, communication channels, or any structured stores that allow processes running at different times or at the same time to communicate via messages; a query syntax , which represents instructions written in a data manipulation language to assemble and disassemble messages, manipulate structured stores represented by the queue syntax , and detect message patterns; and a process syntax , which represents a dynamic aspect of a computation entity that can exchange not only names, such as an API, but also processes as messages over structured stores represented by the queue syntax . The queue syntax , the query syntax , and the process syntax  together form the major syntactical elements of the language . Syntactical elements - of the language  can be used alone or can be combined in permutations to express cooperating nuances among processes, such as processes B\u2013B. The syntactical rules (described in detail with reference to  and Section 1.1 of the Appendix), the structural equivalent rules (discussed in greater detail below with reference to  and section 2.1 of the Appendix), and the operational semantics rules (discussed in greater detail below with reference to  and section 3.1 of the Appendix) in connection with queries are placed in the query virtual machines C, C. The syntactical rules (described in detail with reference to  and Section 1.2 of the Appendix), the structural equivalence rules (discussed in greater detail below with reference to  and section 2.2 of the Appendix), and the operational semantics rules (discussed in greater detail below with reference to  and section 3.2 of the Appendix) in connection with processes are placed in the process virtual machines C, C. The reaction virtual machines C, C contain operational semantics rules that define a method by which queues, queries, and processes react to each other.","The programming language  allows expressions to be formed for describing processes, such as processes B\u2013B, that run in parallel and interact over communication means, such as the queues \u2013. Mathematically, if T and P are processes, the expression T|P describes that processes T, P are running in parallel, possibly communicating with each other or with the outside world along communication means.","Queues \u2013 are represented by names (which correspondingly, are \u201cX,\u201d \u201cY,\u201d \u201cZ,\u201d and \u201cW.\u201d). The programming language  allows the passage of certain classes of processes, such as processes \u2013, among other things, to be expressed as messages over queues \u2013. The processes \u2013 embody an organizational scheme formed from a customizable, tag-based language that contains data and describes data in a way that facilitates the interpretation of data or the performance of operations on data. One exemplary organizational scheme includes a query. Another exemplary organizational scheme includes a message. A further exemplary organizational scheme includes an XML document.","A query contains data and information to manipulate data. Consider this example: the computing device  represents a computer at a publisher and the computing device  represents a computer at a bookstore. Both the publisher and the bookstore have the independent ability to define, in XML, their own tags for information about authors, titles, and publication dates of books. Such book information can be organized into XML documents with appropriate tags. The information is exchanged by the computing device  at the publisher or the computing device  at the bookstore transforming the XML documents into queries, which is represented by process kernels C\u2013C as processes, such as the process  to be communicated over the queue  between the process B and the process B.","Prior \u03c0-calculus variants do not allow structured information, such as XML documents, to be communicated over communication means, such as the queue . However, the actual performance of applications at times requires some exchange of structured information. A case in point includes structured information that expresses the invocation ordering of APIs. Another case in point is the example discussed above between the publisher and the bookstore. The programming language  allows multi-dimensional data (data structures) to be embodied in processes, such as processes \u2013, to be communicated as messages passed among processes B\u2013B. The language  allows the creation of an environment for facilitating the exchange of an organizational scheme (which is expressed in a customizable, tag-based language that contains data and describes data in such a way as to facilitate the interpretation of data or the performance of operations on data) among processes over queues in a non-centralized network that is concurrent and distributed.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 5","b":["310","504","506","302","304","310","316","502","500","302","304","310","302","500","500","500","310","5001","302","308","400","500","310","500","500","500","500","304","310"],"sub":["0","1"]},"The programming language  provides a set of query operations that are used to assemble and disassemble queries, manipulate queues, and detect patterns in queries. Other query operations are used to put messages into queues, get messages from the queues, and build new messages from existing messages. A query comprises two portions: a head and a body. The head of a query defines a set of parameters and their corresponding types. The body is a set of bindings. A query is invoked by binding its parameters to arguments and activating its sets of bindings. A binding defines a relation between two terms. Not all terms can be bound together. A valid binding exists when the binding binds a term of some type to a term of its complementary type. A query can be likened to a traditional procedure; the head of the query is like the signature of the procedure; the body of the query is like the set of programming statements of the procedure; and each binding is a programming statement that uses the data stored in the parameters of the signature of the procedure or places data into the parameters of the signature of the procedure.","Mathematically, the relationship among the queue , a query B, and a process B can be syntactically expressed as X[Q].P, where X is the queue ; Qis the query B; and P represents the process B, which is a point of continuation after the query Qhas been written to the queue X. Thus linguistically, the mathematical expression X[Q].P describes the process of depositing the query B at the queue  after which the process is continued with the execution of the process B. In the framework of the programming language , both Qand P are processes in the mathematical notation X[Q].P. The programming language  identifies a subset (or certain classes) of processes that can be passed as messages over the queue X. This subset contains queries, each of which is correlated to customizable, tag-based data structures, such as those contained in XML documents.","One major aspect of the language  is its collection of equational laws for determining structural equivalence among queries and processes. The process of determining structural equivalence with these equational laws of the language  disencumbers minor differences between two programmatic documents, such as two programs or two software specifications, to ascertain whether they conform in every relevant respect. These laws of structural equivalence allow the operational semantics of the language  to be simplified as described above.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 6A","b":["602","602","0","0","0","602","0","1","1","0","1"]},"Another program  is similar to the program  in many respects, but there are some differences. One difference is the test condition of the IF statement of the program , which contains a variable B instead of the variable A. Another difference is that the child process P is initiated with the first invocation of the fork( ) function before the invocation of the child process P. Despite these differences, the logic flow in both programs ,  will ultimately reach the fork( ) statements of both programs ,  if the test conditions of both IF statements are true. Thus the difference in the names of the variables A, B are negligible, and do not affect the logic structure of programs , . Moreover, because child processes P, P run in parallel, the sequence of their invocation is also negligible.","The program , as discussed above, can be written by many different programming languages, each containing different and diverse grammatical constructions that hinder structural equivalent analysis. Using the language , the program  can be expressed by a quality apart from the grammatical specifics of the program . For example, the essence of the program  is the execution of child processes P, P in parallel. This essence can be expressed by the language  by translating the program  into a specification A. The parallel execution of processes P, P is expressed in the program A as \u201cP|P.\u201d The statement \u201cP|P\u201d is nested between a tag <I_DO> and its corresponding ending tag <\/I_DO>.","Suppose the process B requires a service in which the child process P is desired to be executed in parallel with another child process P. This requirement is captured by a statement \u201cP|P\u201d as indicated in a specification D written in the language . The statement \u201cP|P\u201d is situated between a tag <I_NEED> and its corresponding ending tag <\/I_NEED>. Suppose further that the process B obtains the specification A from the discovery component  to determine whether the program  is suited for the task that the process B wishes to accomplish. Using structural equivalence analysis, the process B can quickly determine that the program A will not be able to provide the requested service as specified by the specification D. This is the case because the program  executes child processes P, P in parallel whereas the process B requires child processes P, P running in parallel instead.","One equational law from the set of equational laws of the language  allows seemingly separate queues to be fused so that one queue can be substituted for another queue in operation. This is called substitution equivalence in section 2.2 of the Appendix. As shown in , the process B uses the queue  (queue X) for sending and receiving messages (or writing and reading queries). Instead of using the queue , the process B communicates with a queue  (queue X\u2032) for sending and receiving messages (or writing and reading queries). Suppose a query is placed at the queue  in which the name X is bound to the name X\u2032 (name X:=:name X\u2032), where the operator :=: is a binding operator, in the idiom of the language . This denotes that the queue  is essentially fused with the queue , hence allowing processes B\u2013B to operate or communicate on the same queue, such as the queue . See . Using the equational laws of the language , processes B, B can discover a new way of accessing a queue (or database, or channel, among other structured stores).","The input\/output mechanism (I\/O) of prior variants of \u03c0-calculus is asymmetric. Consider the following mathematical example: \u016aX.P|U(Y).Q, where \u016a and U refer to the same link, but \u016a denotes that the link is outputting something, such as X, and U denotes that the link is inputting something, such as Y; X is output data; Y is input data; and P, Q are processes, which continue after the expressions \u016aX and |U(Y) have been executed. The asymmetry arises from the fact that X as output data is not bound to the channel U whereas Y as input data is bound to the channel U. The term \u201cbound\u201d means that the operative scope of Y is restricted to the link for which Y is bound. In other words, after the Web service  (\u016a) has communicated to the Web service  the API with which the Web service  is to invoked, the Web service  lost its knowledge of the API . Asymmetric I\/O inhibits the formation of a distributed network topology, such as the system . The present invention overcomes or reduces the above problems by providing symmetric I\/O.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 8","b":["300","302","302","310","312","316","306","304","304","310","312","314","308","310","310","310","312","312","316","314","316","314","312","316","314","316","306","314","308"]},"The language , in addition to its syntax, has a set of rules for describing the evolution of processes. In other words, these rules define the operational semantics of the language . The operational semantics of the language  describe the relationship between the syntactical elements \u2013 and their intended meanings. Thus a program statement written in the language  can be syntactically correct, but semantically incorrect. In other words, a statement written in the language  can be in an acceptable form, but still convey the wrong meaning. One example of the operational semantics of the language  is the communication reduction rule, which is pictorially illustrated by  (implemented in the reaction virtual machines C, C). A query A (Q) is ready to be submitted to the database  (V) by the process B (T).","For ease of discussion, the query A is shown as a database form. A form contains data as well as a \u201chole\u201d that can potentially be filled when the data is computed by the database . For example, a query can be likened to a question that has information for the question to be answered. Thus, the information is the data in the form and the answer is the data to fill the hole in the form. As another example, a form can be likened to a linear simultaneous equation that can be algebraically solved if sufficient information is available. After the submission of the query A to the database , the process continues with the execution of the process B (S). Mathematically, the process of submitting the form A to the database  and continuing at the process B can be described as follows: V[Q].S, where V represents the database , Qrepresents the form A, and S represents the process B.","Suppose that instead of submitting the form A to the database  and continuing at the process B, the process submits a form C to the database  and afterward continues at the process B. Mathematically, this can be described as follows: V[Q].R, where V represents the database , Qrepresents the form C, and T represents the process B.","In the presence of such a choice between executing the process V[Q].S and executing the process V[Q].R, such a choice can be reduced to a form A (Q) being submitted to the database , and afterward both processes B, B will run in parallel. See . Mathematically, this result is expressed as V[Q].(S|R). The formation of the form A is caused by the joining of forms A, A in a way such that the query A is in canonical form (described below). Whereas before only one selection can be made between two alternatives (V[Q].S or V[Q].R), with the formation of the query A from two separate and distinct forms A, C, a single form A can be submitted to the database  and both processes B, B become alive and execute in parallel. One way to understand this is to liken the form A to a first linear simultaneous equation having three terms and to liken the form C to a second linear simultaneous equation having three terms. From the mathematics of linear algebra, one can conclude that there is not yet a solution to the two linear simultaneous equations, but the two linear simultaneous equations can be computed to a form such that when additional data is given (another linear simultaneous equation), all terms can be solved. The form A represents a computation of the two forms A, C for which no further computation can be carried out without more data.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIGS. 10A\u201310C","FIG. 11U","FIG. 10A","FIG. 11U"],"b":["302","1006","904","1006","904","306","904","1002","1002","302","302","1006","904","904","302","1006","302","1002","302"]},"A system  is shown in C showing multiple computing devices dispersed over a number of geographic areas. The process B is executed on the computing device  in the San Francisco geographic area . The process B is executed on the computing device  in the Seattle geographic area  and the process B is executed on the computing device  in the Portland geographic area . The process B has obtained the help of the process B to perform certain tasks. Unbeknownst to the process B, the process B cannot accomplish all the tasks specified by the process B. Thus the process B has contracted the help of the process B to perform tasks that are not within the scope of the process B. With the issuance of a query, such as the query A, to the database , messages coming from the process B, such as a message , to the database  will be automatically forwarded to the database  so that the process B can perform required tasks. Alternatively, the process B can directly communicate with the database  to exchange messages. However, the process B need not do so and can continue to communicate with the database .",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIGS. 11A\u201311V","FIGS. 3A\u20133C"],"b":["1100","302","302","302","302","400","1100","302","400","400","302","1100","300"]},"From a start block, the method  proceeds to a set of method steps , defined between a continuation terminal (\u201cterminal A\u201d) and an exit terminal (\u201cterminal B\u201d). The set of method steps  runs the program against the syntactical rules governing the structure and content of query statements formed from the queue syntax . From terminal A (), the method  proceeds to a block  where the process kernel C obtains a query expression (Q) from the program A. Next, at decision block , the process kernel C decides whether the query Q expression has the syntactical form <T*>(C*).","Each query written in the language  has the syntactical form <T*>(C*), where the syntactical element <T*> denotes the head of the query and the syntactical element (C*) denotes the body of the query. Each query written in the language  has a head and a body. The head declares the number of parameters and their respective types. The body contains a set of bindings. The query can be likened to a traditional programming procedure in that a query is a named sequence of statements (although unnamed queries can be expressed using the language ) with associated constants, data types, and variables, that usually performs a single task. For example, the head of the query is similar to the signature of a procedure whereas the body of the query is similar to the sequence of statements contained inside a procedure. Contained inside the head delimiters <> is a symbol T*, which denotes zero or more query terms (defined below). Contained inside the body delimiters ( ) is the symbol C*, which denotes zero or more constraints (described below).","If the answer is NO to the test at decision block , which means that the query Q has not been written in a syntactical form recognized by the language , the method  finishes execution and terminates. If the answer is YES, the method  proceeds to another decision block  where the process kernel C determines whether each constraint C in the body of the query has the syntactical form T:=:T, where T as described above and further described below is a query term, and the symbol :=: denotes a binding that defines a relation between two query terms. If the answer is NO, which means one constraint of the body of the query has not been written in the form acceptable to the language , the method  finishes execution and terminates. Otherwise, the answer at decision block  is YES, and the method proceeds to another decision block .","At decision block , the process kernel C determines whether the query term T is a literal (hereinafter, \u201cTOP\u201d). A literal is a value, used in a program that is expressed as itself rather than as a variable or the result of an expression. Examples of literals include the numbers 25 and 32.1, the character a, the string Hello, and the Boolean value TRUE. If the answer at decision block  is YES, the method  proceeds to another continuation terminal (\u201cterminal A\u201d). From terminal A the method  proceeds to decision block  where the process kernel C determines whether there is another query expression to analyze. If the answer is NO, the method  proceeds to another continuation terminal (\u201cterminal B\u201d). Otherwise, the answer at decision block  is YES, and the method  loops back to block  to obtain another query expression from the program A for analysis.","At decision block , if the answer is NO, the method  proceeds to another decision block  where the process kernel C determines whether the query term T is a complimentary literal (hereinafter \u201cbottom\u201d). Complimentary literals are inversions of literals. If the answer at decision block  is YES, the method  proceeds to terminal A (described above). If instead, the answer at decision block  is NO, the method  proceeds to another decision block . Here, the process kernel C determines whether the query term T is a discarder (delimited by the symbol \u201c_\u201d). A discarder is a query that takes in only input parameters and provides no output parameters. If the answer at decision block  is YES, the method  proceeds to the terminal A described above. At decision block , if the answer is NO, the method  proceeds to another continuation terminal (\u201cterminal A\u201d).","From terminal A () If the answer is NO, the method  proceeds to decision block  where the process kernel C verifies whether the query term T is a name (or a literal string, such as \u201chello\u201d). Preferably, an alphabetic letter is treated syntactically by the language  as a variable, which is a named storage location capable of containing data that can be modified during program execution. If an alphabetic letter is preceded by a \u201cname\u201d in the language , the alphabetic letter is treated by the language  as a literal string instead of a variable. If the answer at decision block  is YES, the method  proceeds to the terminal A (described above). At decision block , if the answer is NO, the method  proceeds to another decision block  where the process kernel C determines whether the query term T is a variable (such as X). If the answer is YES, the method  proceeds to the terminal A (described above).","At decision block , if the answer is NO, the method proceeds to decision block  where the process kernel C determines whether the query term T is a local variable with the form \u201cX^\u201d. The form X^ contains the term X, which denotes a variable in a program written in the language ; the caret, which is a small, up-pointing symbol (^) typically found over the 6 key on the top row of a microcomputer keyboard, denotes that the variable X is a local variable (in the idiom of computer science, a local variable means a variable whose scope is limited to a given block of code, usually a subroutine, but in the present invention, the scope of a local variable is limited to a process); and the term X^ denotes the creation, in a process, of a local variable X, which is capable of exporting information to be consumed in a continuation process. If the answer is YES at decision block , the method  proceeds to the terminal A (described above).","At decision block , if the answer is NO, the method proceeds to decision block  where the process kernel C determines whether the query term T is a local variable with the form \u201c^X\u201d. The form ^X contains the term X, which denotes a variable; the term ^ is a caret; and the term ^X denotes, in a process, a local variable X, which is capable of importing information (to be consumed) from the computing environment in which the process evolves. If the answer is YES at decision block , the method  proceeds to the terminal A (described above). Otherwise, the decision is NO, and the method  proceeds to another continuation terminal (\u201cterminal A\u201d).","From the terminal A, the method flow proceeds to decision block  where the process kernel C checks the query term T to see whether it is an inversion (delimited by the \u02dc symbol). If the decision is YES, method flow proceeds to the terminal A (described above). Otherwise, the decision is NO, and the method  enters decision block . At decision block , the process kernel C determines whether the query term T is a tuple, which is a set of ordered elements. There are two symbols in the language  for signifying tuples: the syntactical symbol \u201c\u2605\u201d and the syntactical symbol \u201c#\u201d. If the answer at decision block  is YES, method flow proceeds to the terminal A (described above). Otherwise, if the decision is NO, the method  proceeds to decision block . Here, the process kernel C checks to see whether the query terminal T is of the form <X*>(Q,Q), where X* denotes one or more variables and Q denotes a query. Thus the process expression <X*>(Q,Q) denotes zero or more variables in the head of the query and two other queries in the body of the query which are separated by a comma. If the decision is YES at decision block , the method flow proceeds to terminal A (described above). If the decision is NO, the method  proceeds to decision block . Here, the process kernel C checks whether the query term T is a left injection (INR(X)). Traditionally, the left injection operator \u201cinl( )\u201d is used to indicate the source of an element in a union of two sets. For example, suppose a set A is summed with a set B (which is denoted as A+B). Each element of the set A+B is, in effect, tagged with the label inl to indicate that the element originated in set A (visually because the alphabetic letter A is to the left of the set A+B). In the present invention, the constructor inl is preferably used to indicate operation (described below) on the left-sided Q of the body of the query expression <X*>(Q,Q). If the answer is YES to decision block , the method flow proceeds to the terminal A (described above). Otherwise, the method  enters another continuation terminal (\u201cterminal A\u201d).","From terminal A, the method  proceeds to decision block  where the process kernel C determines whether the query term T is a right injection (INR(X)). As briefly described above, in the presence of a query of the form <X*>(QQ), the left injection constructor (INL(X)) allows the variable X to be bound to the constraint Qand the right injection constructor (INR(X)) allows the variable X to be bound to the constraint Q. If the answer at decision block  is YES, the method  proceeds to the terminal A (described above). Otherwise, the method flow proceeds to decision block  where the process kernel C determines whether the query term T is of the form <X*>(Q). The method  proceeds to the terminal A if the answer at decision block  is YES. Otherwise, another decision block  is entered by the method flow. Here, the process kernel C determines whether the query term T is of the form ?T. See decision block . The operator \u201c?\u201d can be considered as a read operator that binds the term T to the first term in the head of the query Q who is contained in the body of a query <X*>(Q). If the answer is YES at decision block , the method flow proceeds to the terminal A (described above). If the answer is NO, the method determines whether the query term T is a copy operation (e.g., \u201cT@T\u201d). If the answer at decision block  is YES, terminal A is entered by the method  (described above). If instead the answer is NO, which means that the query Q has not been written in a syntactical form that is recognizable by the language , the method  finishes execution and terminates.","From terminal B () the method  proceeds to a set of processing steps  defined between a continuation terminal (\u201cterminal C\u201d) and an exit terminal (\u201cterminal D\u201d). This set of processing steps  runs the program A against the syntactical rules governing the structure and content of process statements. From terminal C () the process kernel C obtains a process expression (\u03a0) from the program A. See block . Next, at decision block , the process kernel C determines whether the process expression \u03a0 is a \u201c0\u201d which denotes a process stop or inactivity of a process. If the answer YES, the method flow proceeds to another continuation terminal (\u201cterminal C\u201d). Otherwise, the method flow proceeds to another decision block . The process kernel C decides whether the process expression \u03a0 has a form X[Q].P, where X is a variable representing a channel, a queue, a database, or other structured stores; Q denotes a query having a syntax described above and illustrated in ; X[Q] denotes that the query Q is submitted or deposited at X; the period \u201c.\u201d denotes a sequence from a process X[Q] to another process P or denotes a sequence from a portion of a process X[Q] to another portion P of the same process. If the answer at decision block  is YES, the method  proceeds to the terminal C. Otherwise, if the answer is NO, the method  proceeds to decision block . The process kernel C determines whether the process expression \u03a0 is a summation of a number of X[Q].P, such as X[Q].P+X[Q].P. The summation indicates that a process represented by the process expression \u03a0 can execute one of many alternatives. For example, with the summation of X[Q].P+X[Q].P, the process represented by \u03a0 can execute either X[Q].Por X[Q].P. If the answer at decision block  is YES, the method  proceeds to the terminal C. Otherwise, if the answer is NO, the method flow proceeds to another continuation terminal (\u201cterminal C\u201d).","From terminal C (), the method  proceeds to decision block  where the process kernel C determines whether the process expression \u03a0 is of the form (NEW X)P where NEW denotes an operator in the language  for creating a new name which is bound to some process; (NEW X) denotes the creation of a new name X in some process; and (NEW X)P denotes that a new variable X is created and is bound to a process P. If the decision at decision block  is YES, the method  continues at terminal C. If the answer is NO, decision block  is entered by the method . Here, the process kernel C determines whether the process expression \u03a0 is of the form P|P, which denotes that a process is executed in parallel with another process. If the answer is YES at decision block , the method flow proceeds to the terminal C. Otherwise, the method  proceeds to decision block . The process kernel C determines at decision block  whether the process expression \u03a0 is of the form !P, where the exclamation mark \u201c!\u201d denotes a replication operator and !P denotes an infinite composition P|P| . . . . The replication operator ! allows a developer to express infinite behaviors of processes using the language . If the decision is YES at decision block , the method  proceeds to the terminal C. Otherwise, the method  enters another continuation terminal (\u201cterminal C\u201d).","From terminal C (), the method  proceeds to decision block  where the process kernel C determines whether the process expression \u03a0 is of the form X[P]. The syntactical form X[P] indicates that a developer using the language  can deposit or submit a process P at X, which as described before includes channels, queues, and databases, among other structured stores. If the answer at decision block  is YES, the method  proceeds to the terminal C. Otherwise, the answer is NO, and the method flow proceeds to decision block . The process kernel C determines whether the process expression \u03a0 is of the form <Q>, which is a lifted query (described in further detail below). If the decision is YES at decision block , the terminal C is entered by the method . Otherwise, the answer is NO and the method  finishes execution and terminates. The reason for the termination of the method  at this point is because the process expression \u03a0 was formed in a way incompatible with the grammar of the language .","From terminal C (), the method  proceeds to decision block  where the process kernel C determines whether the program A contains other process expressions to be checked. If the answer is NO, the method flow proceeds to another continuation terminal (\u201cterminal D\u201d). Otherwise, the answer is YES, and the method  proceeds to another continuation terminal (\u201cterminal C\u201d), which loops back to block  wherein the above-described method steps are repeated.","From terminal D () the method  proceeds to a group of processing steps  where the method runs the program using a set of equational laws governing the structural equivalence of query expressions (see ). Processing steps  are defined between a continuation terminal (\u201cterminal E\u201d) and an exit terminal (\u201cterminal F\u201d).","From terminal E () the method  proceeds to block  where the process kernel C obtains two or more query expressions for structural equivalence comparison purposes. Next, the method determines whether a query context (K) is of the form K[T:=:U]. The query context K denotes multiple queries that have holes that can be adapted to be filled by one or more constraints. If the answer at decision block  is YES, the query context K is structurally equivalent to another query context K[U:=:T]. See block B. Then, the method flow proceeds to another continuation terminal (\u201cterminal E\u201d). Otherwise, if the decision at decision block A is NO, another decision block A is entered by the method . Here, the process kernel C determines whether the query context K has the form K[T:=:U, T:=:U]. If the answer is YES to decision block A, the query context K is structurally equivalent to another query context K[T:=:U, T:=:U]. See block B. Next, the method flow proceeds to the terminal E. If instead, the answer is NO at decision block A, the method  proceeds to the terminal E, which proceeds to another decision block . The process kernel C determines whether there are more query expressions in the program to analyze for structural equivalents. See block . If the answer is NO, the method  proceeds to the exit terminal F. Otherwise, the answer is YES, and the method  loops back to block  where the above-described method steps are repeated.","From terminal F (), the method  proceeds to another continuation terminal (\u201cterminal G\u201d). From terminal G (), the method  proceeds to a set of processing steps  defined between a continuation terminal (\u201cterminal H\u201d) and an exit terminal (\u201cterminal I\u201d). Among these processing steps  the method runs the program using a set of equational laws governing structural equivalence of processed statements.","From terminal H () the method  proceeds to block  where the process kernel C obtains several process expressions (\u03a0 and \u03a0) from the program A for structural equivalence analysis. Next, the method determines whether the process expression \u03a0 is of the form P|P. See decision block A. If the decision is YES, the process expression \u03a0 is structurally equivalent to the process expression \u03a0 if \u03a0 has the form P|P. See block B. Next, the method  proceeds to another continuation terminal (\u201cterminal H\u201d). If the answer is NO at decision block A, the method  proceeds to another decision block A where the process kernel C determines whether the process expression \u03a0 has the form P|0. If the answer is YES at decision block A, the process expression \u03a0 is structurally equivalent to the process expression \u03a0 if the process expression \u03a0 has the form P. See block B. Next, the method flow proceeds to the terminal H. If the answer is NO at decision block A, the method  proceeds to another decision block A. Here, the process kernel C determines whether the process expression \u03a0 has the form !P. If the answer is NO, the method  proceeds to another continuation terminal (\u201cterminal H\u201d). If the answer is YES at decision block A, the method  proceeds to yet another continuation terminal (\u201cterminal H\u201d).","From terminal H () the method  proceeds to block B where the process expression \u03a0 is determined to be structurally equivalent to the process expression \u03a0 if the process expression \u03a0 has the form P|!P. Next, the method  proceeds to the terminal H.","From terminal H (), the method  proceeds to decision block A where the process kernel C determines whether the process expression \u03a0 has the form P+P. If the answer is YES to decision block A, the process kernel C determines that the process expression \u03a0 is structurally equivalent to the process expression \u03a0 if the process expression \u03a0 has the form P+P. See block B. Next, the method flow proceeds to the terminal H. If instead the answer at decision block A is NO, the method  proceeds to another decision block A. Here, the process kernel C determines whether the process expression \u03a0 has the form P+0. If the answer is YES, the method  flows to block B where the process kernel C determines that the process expression \u03a0 is structurally equivalent to the process expression \u03a0 if the process expression \u03a0 has the form P. Next, the method  flows to the terminal H. If the answer is NO, the method flow proceeds to another decision block A. Here, the process kernel C determines whether the process expression \u03a0 has the form (NEW X)(NEW Y)P. If the answer is YES, the method  proceeds to another continuation terminal (\u201cterminal H\u201d). Otherwise, if the answer is NO, the method  proceeds to another continuation terminal (\u201cterminal H\u201d).","From terminal H (), the method  proceeds to block B where the process expression \u03a0 is determined to be structurally equivalent to the process expression \u03a0 if the process expression \u03a0 has the form (NEW Y)(NEW X)P. From terminal H (), the method  proceeds to another block A where the process kernel C determines whether the process expression \u03a0 has the form (NEW X)(NEW X)P. If the answer is YES to decision block A, the process expression \u03a0 is structurally equivalent to the process expression \u03a0 if the process expression \u03a0 has the form (NEW X)P. See block B. Next, the method  proceeds to the terminal H. If the answer at decision block A is NO, the method  proceeds to another decision block A. Here, the process kernel C determines whether the process expression \u03a0 has the form (NEW X)P|Q. If the answer is YES at decision block A, the process proceeds to block B where the process kernel C determines that the process expression \u03a0 is structurally equivalent to the process expression \u03a0 if the process expression \u03a0 has the form (NEW X)(P|Q). The name X is preferably a free name in the process Q. In other words, the name X is not bound to the process Q. Next, method  proceeds to the terminal H.","If the answer at decision block A is NO, the method  enters decision block A. Here, the process kernel C determines whether the process expression \u03a0 has the form <>({right arrow over (C)}, NAME X:=:NAME X\u2032)|P where <> denotes the head of a query that contains nothing; {right arrow over (C)} denotes a list of constraints or a set of bindings; NAME X:=:NAME X\u2032 denotes that the literal X is bound to the literal X\u2032 or that the literal X has an equivalent relation to the literal X\u2032; and <>({right arrow over (C)}, NAME X:=:NAME X\u2032)|P denotes that the head of the query <>({right arrow over (C)}, NAME X:=:NAME X\u2032) is a query running in parallel with a process P. If the answer to the test at decision block  is NO, the method  proceeds to the terminal H. If instead, the answer at decision block A is YES, the method  proceeds to another continuation terminal (\u201cterminal H\u201d).","From terminal H (), the method  proceeds to another decision block B. At decision block B, the process kernel C determines whether the query <>({right arrow over (C)}, NAME X:=:NAME X\u2032) is canonical. A query is said to be canonical, or alternatively, is in canonical form if and only if all of its constraints (the bindings in the body of the query) are irreducible and the query is not a failure. A constraint is irreducible in a query if and only if there exists a second query such that the query maps or reduces to the second query, and the constraint is an element of the second query. A query is said to fail if and only if the query is mapped or reduced to another query and the other query contains a failure. A constraint of the form L:=:Lis a failure if Lis not equivalent to the complement of Lwhere L, Lare literals.","If the answer at decision block B is YES, the method  proceeds to block C. Here, the process kernel C determines that the process expression \u03a0 is structurally equivalent to the process constituent \u03a0 if the process expression \u03a0 has the form <>({right arrow over (C)}, NAME X:=:NAME X\u2032)|P{X\u2032\/X}. The process expression P{X\u2032\/X} denotes that whenever in the process P there is an occurrence of the name X, such an occurrence can be replaced with the name X\u2032. In this regard, it should be recallable that the processing steps A\u2013C programmatically describe the substitution equivalent, which was discussed above in connection with . Next, the method  proceeds to the terminal H.","If the answer at decision block B is NO, the method  proceeds to the terminal H. From terminal H, the method  proceeds to another decision block  where the process kernel C checks to see whether there are more process expressions for structural equivalence analysis. If the answer is NO at decision block , the method flow proceeds to the exit terminal I. Otherwise, the method  proceeds to a continuation terminal (\u201cterminal H\u201d). From terminal H () the method  loops back to block  and the above-described method steps are repeated.","From the exit terminal I (), the method  proceeds to a set of processing steps  where the method runs the program A against the operational symatics rules governing the meanings of query statements in the program A. The set of processing steps  are defined between a continuation terminal (\u201cterminal J\u201d) and an exit terminal (\u201cterminal K\u201d). In the language , operational symantics rules are basically a series of evolving relations of processes. A process by its nature is dynamic so that from one point in time to the next the process is continually changing or evolving. The operational symantics rules of language  provide a carefully guided evolution of processes expressed in the language . It is through the syntactical rules described above in  that a developer can express the nuances in which processes evolve through the operational symantics of the language .","From terminal J () the method  proceeds to block  where the process kernel C obtains a binding from query expressions in the program. Next, at decision block A the process kernel C determines whether the binding B contains a binding TOP:=:BOTTOM. If the answer is YES, the process kernel C reduces the binding B is to nothing. See block B. Next, the method flow proceeds to a continuation terminal (\u201cterminal J\u201d). If instead the answer is NO, the method flow proceeds to decision block A where the process kernel C determines whether the binding B contains bindings X:=:T, U:=:X. If the answer is YES, the process kernel C reduces the binding B to a binding T:=:U. See block B. Next, the method flow proceeds to terminal J. If the answer is NO, the method  proceeds to another continuation terminal (\u201cterminal J\u201d).","From terminal J (), the method  proceeds to another decision block A where the process kernel C determines whether the binding B contains T\u2605T:=:U#U. If the answer is YES, the process kernel C reduces the binding B to T:=:U, T:=:U. See block B. Next, the method flow proceeds to the terminal J. If the answer is NO at decision block A, the method  proceeds to another decision block A. The process kernel C determines whether binding B contains a binding <{right arrow over (X)}>(<T:{right arrow over (T)}><{right arrow over (C)}>, <T:{right arrow over (T)}>({right arrow over (C)})):=:INL(U). If the answer at decision block A is YES, the process kernel C reduces the binding B to T:=:U,{right arrow over (X)}:=:{right arrow over (T)}, {right arrow over (C)}. See block B. Next, the method  proceeds to the terminal J. If the answer is NO to decision block A, the method  proceeds to another decision block A.","If the answer at decision block A is NO, the method  proceeds to another decision block A. The process kernel C determines whether the binding B contains <{right arrow over (X)}>(<T:{right arrow over (T)}><{right arrow over (C)}>, <T:{right arrow over (T)}>({right arrow over (C)})):=:INR(U). If the answer at decision block A is YES, the method  proceeds to block B where the process kernel C reduces the binding B to T:=:U,{right arrow over (X)}:=:{right arrow over (T)},{right arrow over (C)}. Next, the method flow proceeds to the terminal J. If the answer at decision block A is NO, the method  proceeds to another continuation terminal (\u201cterminal J\u201d).","From terminal J, the method  proceeds to another decision block A. Here, the process kernel C determines whether the binding B contains <{right arrow over (X)}>(<T:{right arrow over (T)}>({right arrow over (C)})):=:?U. If the answer is YES, the process kernel C reduces the binding B to T:=:U,{right arrow over (X)}:=:{right arrow over (T)},{right arrow over (C)}. See block B. Next, the method  proceeds to the terminal J. If the answer at decision block A is NO, the method  proceeds to another decision block A. The process kernel C determines whether the binding B contains <{right arrow over (X)}>(<T:{right arrow over (T)}>(C)):=:U@V. If the answer at decision block A is YES, the process kernel C reduces the binding B to <{right arrow over (X)}>(<T:{right arrow over (T)}>(C)):=:U,<{right arrow over (X)}>(<T:{right arrow over (T)}>({right arrow over (C)})):=:V,{right arrow over (X)}:=:{right arrow over (X)}@{right arrow over (X)}. See block B. Next, the method  proceeds to the terminal J. If the answer to decision block A is NO, the method  proceeds to another decision block A. The process kernel C determines whether the binding B contains <{right arrow over (X)}>(<T:{right arrow over (T)}>({right arrow over (C)})):=:_. In other words, the query <{right arrow over (X)}>(<T:{right arrow over (T)}>({right arrow over (C)})) is bound with a discarder operator. If the answer is YES at decision block A, the process kernel C reduces the binding B to the following bindings: X:=:_, . . . , X:=:_. In other words, each term of the list {right arrow over (X)} in the head of the query <{right arrow over (X)}>(<T:{right arrow over (T)}>({right arrow over (C)})) is bound to the discarder operator. Next, the method  proceeds to the terminal J. If the answer is NO at decision block A, another continuation terminal (\u201cterminal J\u201d) is entered by the method flow.","From terminal J (), the method  proceeds to another decision block A where the process kernel C determines whether the binding B has the form <{right arrow over (T)}>({right arrow over (C)},{right arrow over (C)},{right arrow over (C)}). In other words, the process kernel C determines whether binding B is in a form of a query with the list {right arrow over (T)} in the head and three constraint lists in the body, which include {right arrow over (C)},{right arrow over (C)},{right arrow over (C)}. If the answer at decision block A is YES, the process kernel C further determines whether the list {right arrow over (C)} can be reduced to {right arrow over (C\u2032)}. See decision block B. If the answer is YES to decision block B, the binding B is reduced to a query <{right arrow over (T)}>({right arrow over (C)},{right arrow over (C\u2032)},{right arrow over (C)}). See block C. The method flow proceeds to the terminal J.","If the answer at decision blocks A, B is NO, the method  proceeds to another decision block A. The process kernel C determines whether the binding B contains the following query <{right arrow over (T)}>(U:=:X,{right arrow over (C)}). If the answer at decision block A is YES, the binding B is reduced to a query <{right arrow over (T)}{U\/X}>({right arrow over (C)}). See block B. In other words, if the name U is bound to the name X in the body of a query, everywhere in the list {right arrow over (T)} where there is a name X, the name X can be replaced with the name U. Next, the method flow proceeds to the terminal J. Otherwise, the answer at decision block A is NO, and the method flow proceeds to the terminal J, which proceeds to another decision block . Here, the process kernel C determines whether there is another query expression to apply the semantic rules of the language . If the answer is NO, the method  proceeds to the exit terminal K. If the answer at decision block  is YES, the method  proceeds to another continuation terminal (\u201cterminal J\u201d). From terminal J, the method  loops back to block  where the above-described method steps are repeated.","From the exit terminal K (), the method  proceeds to a set of processing steps  where the method runs the program A against the operational semantics rules governing the meanings of process expressions. The set of processing steps  are defined between a continuation terminal (\u201cterminal L\u201d) and an exit terminal (\u201cterminal M\u201d).","From terminal L (), method  proceeds to a block  where the process kernel C obtains a process expression (\u03a0) in the program A. Next, at decision block A, the process kernel C determines whether the process expression \u03a0 contains a summation X[Q].P+ . . . +X[Q].P+ . . . . If the answer is YES at decision block A, the method  proceeds to another decision block B. Here, the process kernel C determines whether there is a binding of a form \u03c3(Q):=:\u03c3(Q) that is reducible to another query Q canonically. Both \u03c3, \u03c3define a permutation that maps or reduces a term (see Definition 3.2.1 in Section 3.2 of the Appendix). Both \u03c3, \u03c3are preferably interpreted as a database join. If the answer at decision block B is YES, process kernel C reduces the process expression \u03a0 to a process X[Q].(P|P), which denotes that the reduced query Q is submitted to a structured store X and afterward both processes P, Pexecute in parallel. See block C. Processing steps A\u2013C are discussed above in connection with . Next, from block C, the method  proceeds to another continuation terminal (\u201cterminal L\u201d).","If the answer at decision blocks A, B is NO, the method  proceeds to another decision block A. The process kernel C determines whether the process expression \u03a0 contains P|P\u2033. If the answer is YES, the method  proceeds to another decision block B where the process kernel C determines whether the process P can be reduced to a process P\u2032. If the answer at decision block B is YES, the method  proceeds to another continuation terminal (\u201cterminal L\u201d). If the answer at decision blocks A, B is NO, the method  proceeds to another continuation terminal (\u201cterminal L\u201d).","From terminal L (), the method  proceeds to block C where process kernel C reduces the process expression \u03a0 to P|P\u2032. Next, the method flow proceeds to the terminal L. From terminal L (), the method  proceeds to another decision block A where the process kernel C determines whether the process expression \u03a0 contains (NEW X)P. If the answer is YES, the method flow proceeds to decision block B where the process kernel C determines whether the process P can be reduced to P\u2032. If the answer at decision block B is YES, process kernel C reduces the process expression \u03a0 to (NEW X)P\u2032. See block C. Next, the method  proceeds to the terminal L. If the answer at decision blocks A, B is NO, the method flow proceeds to another decision block A. Here the process kernel C determines whether the process expression \u03a0 contains X[P]. If the answer is YES, the method  proceeds to another decision block B. The process kernel C determines whether the process P can be reduced to another process P\u2032. See decision block B. If the answer at decision block B is YES, the method flow proceeds to another continuation terminal (\u201cterminal L\u201d). If the answer at decision blocks A, B is NO, the method  proceeds to another continuation terminal (\u201cterminal L\u201d).","From terminal L, the method  proceeds to block C where process kernel C reduces the process expression \u03a0 to X[P\u2032]. Next, the method flow proceeds to terminal L. From terminal L (), the method flow proceeds to another decision block A, where the process kernel C determines whether the process expression \u03a0 contains a process X[Q].P. If the answer at decision block A is YES, the process kernel C determines at decision block B whether the query Q has an equivalent relation with another query of a form <>({right arrow over (C)},{right arrow over (X^)}:=:{right arrow over (V)}). The term <>({right arrow over (C)},{right arrow over (X^)}:=:{right arrow over (V)}) means a query that has nothing in its head (no terms are contained in the head of the query). Its body contains the term {right arrow over (C)}, which denotes a list of constraints or binding relationships (such as conditions that bind ports to ports), or the term {right arrow over (X^)}:=:{right arrow over (V)}, which denotes binding relationships among a list of local variables to a list of values associated with the list of local variables.","If the answer is YES to decision block B, the process kernel C further determines whether the query Q is in canonical form. See decision block C. If the test at decision block C is YES, process kernel C reduces the process expression \u03a0 to a process of the form <Q\u2032>|P{{right arrow over (V)}\/{right arrow over (^X)}}. See block D. The term <Q\u2032> is a lifted query, which is equivalent to <>({right arrow over (C)}), and was previously discussed above in . A lifted query <>({right arrow over (C)}) is a query that contains no terms in the head and its body contains binding relationships, which are described in the list of constraints {right arrow over (C)}, which are globally known. The term P{{right arrow over (V)}\/{right arrow over (^X)}} is a process, which subsitutes each local variable in the list of local variables {right arrow over (^X)} with a corresponding value in the list of values {right arrow over (V)} during the time the constraint terms in the list of contraints {right arrow over (C)} are lifted. In sum, if the query Q in the process X[Q].P is equivalent to <>({right arrow over (C)},{right arrow over (X^)}:=:{right arrow over (V)}) and additionally the query Q is in canonical form, the process X[Q].P can be evolved to a process of a form <Q\u2032>|P{{right arrow over (V)}\/{right arrow over (^X)}}. Next, the method  proceeds to the terminal L.","If the answer at decision blocks A\u2013C is NO, another decision block A is entered by the method . The process kernel C determines whether the process expression \u03a0 contains P, which has an equivalent relation to P\u2032. See decision block A. If the answer is YES, the method  proceeds to another continuation terminal (\u201cterminal L\u201d). If the answer to decision block A is NO, the method  proceeds to the terminal L.","From the terminal L (), the method  proceeds to decision block B where the process kernel C determines whether P\u2032 can be reduced to P\u2032. If the answer is YES, the process kernel C determines whether the process P\u2032 has an equivalent relation with a process P. See decision block C. If the test at decision block C is YES, the process kernel C reduces the process Pto the process P. See block D. Next, the method  proceeds to the terminal L. If the answer at decision blocks B, C is NO, the method  also proceeds to the terminal L.","From the terminal L (), the method  proceeds to another decision block  where the process kernel C checks to see whether there are more process expressions to be analyzed under the operational semantic rules of the language . If the answer is NO, the method flow proceeds to the exit terminal M. If the answer at decision block  is YES, the method  proceeds to another continuation terminal (\u201cterminal L\u201d). From terminal L, the method  loops back to block  where the method steps discussed above are repeated.","While the preferred embodiment of the invention has been illustrated and described, it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention.","The semantics for the language is presented in an SOS style set of reduction rules. For brevity, a more compact, entirely infix version of the syntax, often called a calculus, is introduced. Over this syntax a set of equivalence rules is imposed because the syntax makes distinction amongst processes that are too fine. The reduction rules are closed over this equivalence.",{"@attributes":{"id":"p-0120","num":"0119"},"maths":[{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mstyle":{"mtext":"Calculus-style Syntax"}}},{"@attributes":{"id":"MATH-US-00001-2","num":"00001.2"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mi":"P"},{"mstyle":{"mtext":"\u2237="}},{"mn":"0"}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"mrow":{"mi":"x","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"Q"}},"mo":"\u00b7","mi":"P"}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mi":["new","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},"mo":"\u2062","mi":"P"}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"munder":{"mo":"\u2211","mn":"1"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":{"mi":"x","mo":"\u2061","mrow":{"mo":["[","]"],"msub":{"mi":"Q","mn":"1"}}},"mo":"\u00b7","msub":{"mi":"P","mn":"1"}}}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"mi":["P","P"],"mo":"|"}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"mo":"|","mrow":{"mo":"!","mi":"P"}}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"mo":["\u2329","\u232a"],"mi":"Q"}}]}]}}}]},"The correspondence between the syntax the programmmer sees (the program-level syntax) and the infix (model-level) syntax should be obvious, but is given in the following table for completeness. Note that the prefix syntax tries to work around its verbosity by providing syntactic sugar like the block form. This form allows the programmer to specify a prefix of several actions to be executed sequentially before the continuation. Rather than write out the full compilation of these forms, the table below simply provides the minimal information to infer the compilation. This choice amounts to making the left hand column be the translation of the right hand column.",{"@attributes":{"id":"p-0122","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Program-level syntax","Model-level syntax"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{}","0"]},{"entry":[{},"sequence {block {x[Q];}P }","x{Q}.P"]},{"entry":[{},"new (x){P}","(new x)P"]},{"entry":[{},{}]},{"entry":[{},"select {case x[Q]:P}",{"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":"\u2062","mrow":{"mrow":{"mi":"x","mo":"\u2061","mrow":{"mo":["[","]"],"msub":{"mi":["Q","i"]}}},"mo":"\u00b7","msub":{"mi":["P","i"]}}}}}}]},{"entry":[{},{}]},{"entry":[{},"parallel {PP}","P|P"]},{"entry":[{},"schedule S (...){... call S(...);}","!P"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Note bene: the lifted query form is not currently made available at the user level in the prefix syntax. But, in subsequent versions it will be.",{"@attributes":{"id":"p-0124","num":"0123"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mi":"Q"},{"mstyle":{"mtext":"\u2237="}},{"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"msup":{"mi":["T","\u2605"]}},{"mo":["(",")"],"msup":{"mi":["C","\u2605"]}}],"mo":"\u2062"}}]},{"mtd":[{"mi":"C"},{"mstyle":{"mtext":"\u2237="}},{"mrow":{"mi":["T","T"],"mo":["\u2062","\u2062"],"mstyle":{"mtext":":=:"}}}]},{"mtd":[{"mi":"T"},{"mstyle":{"mtext":"\u2237="}},{"mrow":{"mstyle":{"mtext":"top"},"mo":"|","mrow":{"mstyle":[{"mtext":"bottom"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mrow":{"mo":["\uf603","\uf604"],"mi":"_"},"mi":["name","y"]}}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mi":"x"}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"msup":{"mi":"x","mo":"\u22c0"}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"msup":{"mo":["\u2009","\u22c0"]},"mo":"\u2062","mi":"x"}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"mo":"\u223c","mi":"T"}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mi":"T\u2605T"}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"mi":["T","#","T"],"mo":["\u2062","\u2062"]}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"msup":{"mi":["x","\u2605"]}},{"mo":["(",")"],"mrow":{"mi":["Q","Q"],"mo":","}}],"mo":"\u2062"}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"mi":"inl","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"mi":"inr","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"x"}}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"msup":{"mi":["x","\u2605"]}},{"mo":["(",")"],"mi":"Q"}],"mo":"\u2062"}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"mo":"?","mi":"T"}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"|"},{"mrow":{"mi":["T","T"],"mo":"@"}}]}]}}}},{"@attributes":{"id":"p-0125","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Program-level syntax","Model-level syntax"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"( T\u2605 ) { C\u2605 }","<T\u2605>(C\u2605)"]},{"entry":[{},"T :=: T;","T: =: T"]},{"entry":[{},"x","x"]},{"entry":[{},"x{circumflex over (\u2009)}","x{circumflex over (\u2009)}"]},{"entry":[{},"{circumflex over (\u2009)}x","{circumflex over (\u2009)}x"]},{"entry":[{},"~T","~T"]},{"entry":[{},"T \u2605 T","T \u2605 T"]},{"entry":[{},"T#T","T#T"]},{"entry":[{},"( x\u2605 ) [ left: Q | right: Q ]","( x\u2605 ) (Q,Q)"]},{"entry":[{},"in (left,x) in(right,x)","inl(x) inr(x)"]},{"entry":[{},"( x\u2605 ) [ Q ]","< x\u2605 > (Q)"]},{"entry":[{},"?T","?T"]},{"entry":[{},"T@T","T@T"]},{"entry":[{},"top \/ bottom \/ _ \/ port y","top|bottom|_|name y"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"As mentioned before the syntax makes too many distinctions. It makes no difference, for example, on which side of the \u201c:=:\u201d a term appears. We introduce structural equivalence to eliminate these unnecessary distinctions.","For queries we do this using a query context, which is just a query with a place in it to insert a condition. For processes we do this explicitly.",{"@attributes":{"id":"p-0128","num":"0127"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mi":"K","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":["t","u"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}}},{"mo":"\u2261"},{"mrow":{"mi":"K","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":["u","t"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":="},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}}}]},{"mtd":[{"mrow":{"mi":"K","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mrow":[{"msub":[{"mi":"t","mn":"0"},{"mi":"u","mn":"0"}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"msub":[{"mi":"t","mn":"1"},{"mi":"u","mn":"1"}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":","}}}},{"mo":"\u2261"},{"mrow":{"mi":"K","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mrow":[{"msub":[{"mi":"t","mn":"1"},{"mi":"u","mn":"1"}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"msub":[{"mi":"t","mn":"0"},{"mi":"u","mn":"0"}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":","}}}}]},{"mtd":[{"mrow":{"msub":[{"mi":"P","mn":"0"},{"mi":"P","mn":"1"}],"mo":"|"}},{"mo":"\u2261"},{"mrow":{"msub":[{"mi":"P","mn":"1"},{"mi":"P","mn":"0"}],"mo":"|"}}]},{"mtd":[{"mrow":{"mi":"P","mo":"|","mn":"0"}},{"mo":"\u2261"},{"mi":"P"}]},{"mtd":[{"mrow":{"mo":"!","mi":"P"}},{"mo":"\u2261"},{"mrow":{"mi":"P","mo":"|","mrow":{"mo":"!","mi":"P"}}}]},{"mtd":[{"mrow":{"msub":[{"mi":"P","mn":"0"},{"mi":"P","mn":"1"}],"mo":"+"}},{"mo":"\u2261"},{"mrow":{"msub":[{"mi":"P","mn":"1"},{"mi":"P","mn":"0"}],"mo":"+"}}]},{"mtd":[{"mrow":{"mi":"P","mo":"+","mn":"0"}},{"mo":"\u2261"},{"mi":"P"}]},{"mtd":[{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mstyle":[{"mtext":"new"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062"],"mi":"x"}},{"mo":["(",")"],"mrow":{"mstyle":[{"mtext":"new"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062"],"mi":"y"}}],"mo":["\u2062","\u2062"],"mi":"P"}},{"mo":"\u2261"},{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mstyle":[{"mtext":"new"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062"],"mi":"y"}},{"mo":["(",")"],"mrow":{"mstyle":[{"mtext":"new"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062"],"mi":"x"}}],"mo":["\u2062","\u2062"],"mi":"P"}}]},{"mtd":[{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mstyle":[{"mtext":"new"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062"],"mi":"x"}},{"mo":["(",")"],"mrow":{"mstyle":[{"mtext":"new"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062"],"mi":"x"}}],"mo":["\u2062","\u2062"],"mi":"P"}},{"mo":"\u2261"},{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mstyle":[{"mtext":"new"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062"],"mi":"x"}},"mo":"\u2062","mi":"P"}}]},{"mtd":[{"mrow":{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mstyle":[{"mtext":"new"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062"],"mi":"x"}},"mo":"\u2062","mi":"P"},"mo":"|","mi":"Q"}},{"mo":"\u2261"},{"mrow":{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"mstyle":[{"mtext":"new"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062"],"mi":"x"}},{"mo":["(",")"],"mrow":{"mi":["P","Q"],"mo":"|"}}],"mo":"\u2062"},{"mi":"x","mo":"\u2209","mrow":{"mi":"FN","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"Q"}}}],"mo":","}}]}]}}}},"For the reader familiar with process algebras, these equations are the usual suspects. The one interesting case is the one below. When a query is in canonical form, and there are conditions in its body, it will be the case that those conditions are equations between ports, or equations between local variables and their values. At the time of lifting, the local variables are substituted with their values into the continuations. The equations between ports, when present in a lifted query, act as a process that implements a kind of explicit substitution.",{"@attributes":{"id":"p-0130","num":"0129"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":{"mrow":[{"mo":["\u2329","\u232a"]},{"mo":["(",")"],"mrow":{"mover":{"mi":"c","mo":"\u2192"},"mo":",","mrow":{"mi":["name","x","name"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["x","\u2032"]}}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["in","canonical","form"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"mrow":[{"mo":["\u2329","\u232a"]},{"mo":["(",")"],"mrow":{"mover":{"mi":"c","mo":"\u2192"},"mo":[",","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mi":["name","name"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["x","\u2032"]}}}}],"mo":"\u2062"}},{"mo":"\uf603","mrow":{"mi":"P","mo":"\u2261","mrow":{"mo":"\u2329","mrow":{"mrow":[{"mo":["\u2329","\u232a"]},{"mo":"(","mrow":{"mover":{"mi":"c","mo":"\u2192"},"mo":","}}],"mo":"\u2062"}}}}],"mo":"\u2062"}}},{"mtd":{"mrow":{"mrow":[{"mrow":{"mrow":{"mrow":{"mi":["name","x","name"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["x","\u2032"]}},"mo":")"},"mo":"\u232a"},"mo":"\uf604"},{"mo":["{","}"],"mrow":{"msup":{"mi":["x","\u2032"]},"mo":"\/","mi":"x"}}],"mo":["\u2062","\u2062"],"mi":"P"}}}]}}}}},{"@attributes":{"id":"p-0131","num":"0130"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mo":["(",")"],"mi":"match"}},{"mrow":{"mrow":{"mrow":{"mi":["top","bottom"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":"\u2192"},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}}]},{"mtd":[{"mrow":{"mo":["(",")"],"mi":"cut"}},{"mrow":{"mrow":[{"mi":["x","t"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mrow":[{"mi":["u","x"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mi":["t","u"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":"\u2192"}],"mo":","}}]},{"mtd":[{"mrow":{"mo":"(","mstyle":{"mtext":"tensor-par)"}}},{"mrow":{"mrow":[{"mrow":[{"msub":[{"mi":"t","mn":"0"},{"mi":"t","mn":"1"},{"mi":"u","mn":"0"},{"mi":"u","mn":"1"}],"mo":["*","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"#"},{"msub":[{"mi":"t","mn":"0"},{"mi":"u","mn":"0"}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":"\u2192"},{"msub":{"mi":"t","mn":"1"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"u"}],"mo":","}}]},{"mtd":[{"mstyle":{"mtext":"(with-1plus)"}},{"mrow":{"mrow":{"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"mover":{"mi":"x","mo":"\u2192"}},{"mo":["(",")"],"mrow":{"mrow":[{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"msub":{"mi":"t","mn":"0"},"mo":":","mover":{"msub":{"mi":"t","mn":"0"},"mo":"\u2192"}}},{"mo":["\u2329","\u232a"],"mover":{"msub":{"mi":"c","mn":"0"},"mo":"\u2192"}}],"mo":"\u2062"},{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"msub":{"mi":"t","mn":"1"},"mo":":","mover":{"msub":{"mi":"t","mn":"1"},"mo":"."}}},{"mo":["(",")"],"mover":{"msub":{"mi":"c","mn":"1"},"mo":"\u2192"}}],"mo":"\u2062"}],"mo":","}},{"mi":"inl","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"u"}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":"\u2192"},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mrow":{"mrow":[{"msub":{"mi":"t","mn":"0"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"u"},{"mover":[{"mi":"x","mo":"\u2192"},{"msub":{"mi":"t","mn":"0"},"mo":"\u2192"}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}]}],"mo":[",",","],"mover":{"msub":{"mi":"c","mn":"0"},"mo":"\u2192"}}}]},{"mtd":[{"mstyle":{"mtext":"(with-rplus)"}},{"mrow":{"mrow":{"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"mover":{"mi":"x","mo":"\u2192"}},{"mo":["(",")"],"mrow":{"mrow":[{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"msub":{"mi":"t","mn":"0"},"mo":":","mover":{"msub":{"mi":"t","mn":"0"},"mo":"\u2192"}}},{"mo":["(",")"],"mover":{"msub":{"mi":"c","mn":"0"},"mo":"\u2192"}}],"mo":"\u2062"},{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"msub":{"mi":"t","mn":"1"},"mo":":","mover":{"msub":{"mi":"t","mn":"1"},"mo":"\u2192"}}},{"mo":["(",")"],"mover":{"msub":{"mi":"c","mn":"1"},"mo":"\u2192"}}],"mo":"\u2062"}],"mo":","}},{"mi":["inr","u"],"mo":["(",")"]}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":"\u2192"},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mrow":{"mrow":[{"msub":{"mi":"t","mn":"1"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"u"},{"mover":[{"mi":"x","mo":"\u2192"},{"msub":{"mi":"t","mn":"1"},"mo":"\u2192"}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}]}],"mo":[",",","],"mover":{"msub":{"mi":"c","mn":"1"},"mo":"\u2192"}}}]},{"mtd":[{"mrow":{"mo":["(",")"],"mi":"read"}},{"mrow":{"mrow":[{"mrow":[{"mrow":[{"mo":["\u2329","\u232a"],"mover":{"mi":"x","mo":"\u2192"}},{"mo":["(",")"],"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"mi":"t","mo":":","mover":{"mi":"t","mo":"\u2192"}}},{"mo":["(",")"],"mover":{"mi":"c","mo":"\u2192"}}],"mo":"\u2062"}},{"mstyle":[{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","?"],"mi":"u"}],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":["t","u"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":"\u2192"},{"mover":[{"mi":"x","mo":"\u2192"},{"mi":"t","mo":"\u2192"}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}]}],"mo":[",",","],"mover":{"mi":"c","mo":"\u2192"}}}]},{"mtd":[{"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mo":"\u2062","mrow":{"mo":["(",")"],"mi":"copy"}}},{"mrow":{"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"mover":{"mi":"x","mo":"\u2192"}},{"mo":["(",")"],"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"mi":"t","mo":":","mover":{"mi":"t","mo":"\u2192"}}},{"mo":["(",")"],"mover":{"mi":"c","mo":"\u2192"}}],"mo":"\u2062"}},{"mi":["u","v"],"mo":"@"}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":"\u2192"}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mrow":{"mrow":{"mrow":{"mo":["\u2329","\u232a"],"mover":{"mi":"x","mo":"\u2192"}},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"msup":{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"mi":"t","mo":":","mover":{"mi":"t","mo":"\u2192"}}},{"mo":["(",")"],"mover":{"mi":"c","mo":"\u2192"}}],"mo":"\u2062"}},"mi":"L"},"mstyle":[{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"u"},"mo":","}}]},{"mtd":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mrow":{"mrow":{"mrow":{"mo":["\u2329","\u232a"],"mover":{"mi":"x","mo":"\u2192"}},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"msup":{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"mi":"t","mo":":","mover":{"mi":"t","mo":"\u2192"}}},{"mo":["(",")"],"mover":{"mi":"c","mo":"\u2192"}}],"mo":"\u2062"}},"mi":"R"},"mstyle":[{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"v"},"mo":","}}]},{"mtd":[{"mrow":{"mstyle":[{"mtext":{}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mo":"\u2062"}},{"mrow":{"mover":{"mi":"x","mo":"\u2192"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"msup":[{"mover":{"mi":"x","mo":"\u2192"},"mi":"L"},{"mover":{"mi":"x","mo":"\u2192"},"mi":"R"}],"mo":["@","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}}]},{"mtd":[{"mrow":{"mo":["(",")"],"mi":"discard"}},{"mrow":{"mrow":[{"mrow":[{"mrow":[{"mo":["\u2329","\u232a"],"mover":{"mi":"x","mo":"\u2192"}},{"mo":["(",")"],"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"mi":"t","mo":":","mover":{"mi":"t","mo":"\u2192"}}},{"mo":["(",")"],"mover":{"mi":"c","mo":"\u2192"}}],"mo":"\u2062"}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"_"},{"msub":{"mi":"x","mn":"0"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"_"}],"mo":"\u2192"},{"msub":{"mi":["x","n"]},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"_"}],"mo":[",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}]},{"mtd":[{"mstyle":{"mtext":"(context)"}},{"mfrac":{"mrow":[{"mover":[{"mi":"c","mo":"\u2192"},{"msup":{"mi":["c","\u2032"]},"mo":"\u2192"}],"mo":"\u2192"},{"mrow":[{"mrow":[{"mo":["\u2329","\u232a"],"mover":{"mi":"t","mo":"\u2192"}},{"mo":["(",")"],"mrow":{"mover":[{"msub":{"mi":"c","mn":"0"},"mo":"\u2192"},{"mi":"c","mo":"\u2192"},{"msub":{"mi":"c","mn":"1"},"mo":"\u2192"}],"mo":[",",","]}}],"mo":"\u2062"},{"mrow":[{"mo":["\u2329","\u232a"],"mover":{"mi":"t","mo":"\u2192"}},{"mo":["(",")"],"mrow":{"mover":[{"msub":{"mi":"c","mn":"0"},"mo":"\u2192"},{"msup":{"mi":["c","\u2032"]},"mo":"\u2192"},{"msub":{"mi":"c","mn":"1"},"mo":"\u2192"}],"mo":[",",","]}}],"mo":"\u2062"}],"mo":"\u2192"}]}}]},{"mtd":[{"mrow":{"mo":"(","mstyle":{"mtext":"cleanup)"}}},{"mrow":{"mrow":[{"mrow":[{"mrow":[{"mo":["\u2329","\u232a"],"mover":{"mi":"t","mo":"\u2192"}},{"mo":["(",")"],"mrow":{"mrow":{"mi":["u","x"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":",","mover":{"mi":"c","mo":"\u2192"}}}],"mo":"\u2062"},{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"mover":{"mi":"t","mo":"\u2192"},"mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mi":["u","x"],"mo":"\/"}}}},{"mo":["(",")"],"mover":{"mi":"c","mo":"\u2192"}}],"mo":"\u2062"}],"mo":"\u2192"},{"mi":"x","mo":["\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"not\u00a0\u00a0constrained\u00a0\u00a0by\u00a0\u00a0"}],"mover":{"mi":"c","mo":"\u2192"}}],"mo":","}}]}]}}}},"The match rule is really a rule schema. Whenever a literal and its dual come together, they evaporate. This is interpreted as a success as no more checking is required.","An identifier may be thought of, intuitively, as a wire. When two terms occur on each end of a wire, you eliminate the wire and plug the two terms together directly. At this point it is worth calling out that the linear types ensure that in well-typed terms identifiers occur exactly twice.","When an offer of a tuple meets an [sic ] demand for a tuple, the corresponding positions get wired together.","When a offer of a menu (the withClaim form) meets a demand for a selection (the injectClaim form), the selection is made. This causes the selected choice to be wired to the constraints of the demand.","When an offer of a recording (the ofCourseClaim) meets a demand for a replay (the whyNotClaim) the data on the recording is wired to the constraints of the demand.","When an offer of recording meets a demand for a copy (the contractClaim) separate copies are wired to the separate contraints of the demand.","When an offer of recording meets a demand to discard the recording (the \u201c_\u201d) the recording is discarded.","If a collection of conditions evolves in a certain way, then may evolve that way in the context of the body of a query.","When one end of a wire, i.e., one occurrence of a [sic] identifier, is occurs in (some term in) the head of a query, and the other in the body then term to which the identifier is bound in the body may be substituted into the head.","Definition 3.2.1. Let \u03c3:n\u2192n be a permutation, <t, . . . , t>({right arrow over (c)}) a query. We take \u03c3(<t, . . . , t>({right arrow over (c)}))=<t, . . . , t>({right arrow over (c)}).","Definition 3.2.2. Let Q=<t, . . . , t>({right arrow over (C)}) and Q=<u, . . . , u>({right arrow over (C)}). We take Q:=:Q=<t, . . . , t,u, . . . , u>(t:=:u,{right arrow over (C)}, {right arrow over (C)}).","Definition 3.2.3. A constraint of the form l:=:lon literals, l,l, is a failure if l\u2260\u02dcl.","Definition 3.2.4. A query, Q, fails iff Q\u2192*Q\u2032 and Q\u2032 contains a failure.","Definition 3.2.5. A constraint c is irreducible in a query Q iff \u2200Q\u2032.Q\u2192*Q\u2032.c\u2208Q\u2032.","Definition 3.2.6. A query, Q, is canonical (alternatively, in canonical form) iff all of its constraints are irreducible and Q is not a failure.",{"@attributes":{"id":"p-0147","num":"0146"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mo":["(",")"],"mstyle":{"mtext":"comm"}}},{"mfrac":{"mrow":[{"mrow":[{"mo":"\u2203","msub":{"mi":"\u03c3","mn":"0"}},{"mrow":[{"mrow":[{"msub":{"mi":"\u03c3","mn":"1"},"mo":"\u00b7","mrow":{"msub":{"mi":"\u03c3","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":"Q","mn":"0"}}}},{"msub":{"mi":"\u03c3","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":"Q","mn":"1"}}}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mo":"*","mi":"Q"}],"mo":"\u2192"},{"mi":"Q","mo":["\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"in\u00a0\u00a0\u00a0canonical\u00a0\u00a0\u00a0form"}]}],"mo":[",",","]},{"mrow":[{"mrow":{"mi":"x","mo":"\u2061","mrow":{"mo":["[","]"],"msub":{"mi":["Q","o"]}}},"mo":"\u00b7","msub":{"mi":"P","mn":"0"}},{"mi":"\u22ef","mo":"\u2062","mrow":{"mo":"\uf603","mrow":{"mrow":[{"mrow":{"mrow":{"mi":"x","mo":"\u2061","mrow":{"mo":["[","]"],"msub":{"mi":"Q","mn":"1"}}},"mo":"\u00b7","msub":{"mi":"P","mn":"1"}},"mo":"+","mi":"\u22ef"},{"mrow":[{"mi":"x","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"Q"}},{"mo":["(","\uf604"],"mrow":{"msub":{"mi":"P","mn":"0"},"mo":"\u2062","mrow":{"mo":["\uf603",")"],"msub":{"mi":"P","mn":"1"}}}}],"mo":"\u00b7"}],"mo":"\u2192"}}}],"mo":"+"}]}}]},{"mtd":[{"mrow":{"mo":["(",")"],"mi":"par"}},{"mfrac":{"mrow":[{"mi":"P","mo":"\u2192","msup":{"mi":["P","\u2032"]}},{"mi":"P","mo":["\u2062","\u2062"],"mrow":{"mo":["\uf603","\uf604"],"mrow":{"msup":[{"mi":["P","\u2033"]},{"mi":["P","\u2032"]}],"mo":"\u2192"}},"msup":{"mi":["P","\u2033"]}}]}}]},{"mtd":[{"mrow":{"mo":["(",")"],"mi":"new"}},{"mfrac":{"mrow":[{"mi":"P","mo":"\u2192","msup":{"mi":["P","\u2032"]}},{"mrow":[{"mrow":{"mo":["(",")"],"mrow":{"mi":["new","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},"mo":"\u2062","mi":"P"},{"mrow":{"mo":["(",")"],"mrow":{"mi":["new","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},"mo":"\u2062","msup":{"mi":["P","\u2032"]}}],"mo":"\u2192"}]}}]},{"mtd":[{"mrow":{"mo":["(",")"],"mi":"lift"}},{"mfrac":{"mrow":[{"mrow":[{"mi":"Q","mo":"\u2261","mrow":{"mrow":[{"mo":["\u2329","\u232a"]},{"mo":["(",")"],"mrow":{"mover":{"mi":"c","mo":"\u2192"},"mo":",","mrow":{"mover":[{"mover":{"mi":"x","mo":"^"},"mo":"\u2192"},{"mi":"v","mo":"\u2192"}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":=:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}}],"mo":["\u2062","\u2062"],"mstyle":{"mtext":"in\u00a0\u00a0canonical\u00a0\u00a0form"}}},{"msup":{"mi":["Q","\u2032"]},"mo":"\u2261","mrow":{"mrow":[{"mo":["\u2329","\u232a"]},{"mo":["(",")"],"mover":{"mi":"c","mo":"\u2192"}}],"mo":"\u2062"}}],"mo":","},{"mrow":[{"mrow":{"mi":"x","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"Q"}},"mo":"\u00b7","mi":"P"},{"mrow":[{"mo":["\u2329","\u232a"],"msup":{"mi":["Q","\u2032"]}},{"mo":"\uf603","mrow":{"mi":"P","mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mover":[{"mi":"v","mo":"\u2192"},{"mover":{"mi":"x","mo":"^"},"mo":"\u2192"}],"mo":"\/"}}}}],"mo":"\u2062"}],"mo":"\u2192"}]}}]},{"mtd":[{"mrow":{"mo":["(",")"],"mi":"equiv"}},{"mfrac":{"mrow":[{"mrow":[{"msub":{"mi":"P","mn":"0"},"mo":"\u2261","msubsup":{"mi":["P","\u2032"],"mn":"0"}},{"msubsup":[{"mi":["P","\u2032"],"mn":"0"},{"mi":["P","\u2032"],"mn":"1"}],"mo":"\u2192"},{"msubsup":{"mi":["P","\u2032"],"mn":"1"},"mo":"\u2261","msub":{"mi":"P","mn":"1"}}],"mo":[",",","]},{"msub":[{"mi":"P","mn":"0"},{"mi":"P","mn":"1"}],"mo":"\u2192"}]}}]}]}}}},"If two queries have terms that match at some position in their heads, respectively, and the corresponding cut query evolves to a query that cannot make anymore progress, but is not a failure, then two processes which have placed these queries into the same queue will communicate. Their respective continuations will both wait on the completion of the reduced query.","If a process can make progress on its own, then it may still make that progress in parallel composition with another process.","If a process can make progress on its own, then it may still make that progress if one of its ports is no longer available for outside interaction.","A query with no terms in its head only hasd conditions which bind ports to ports to ports or local variables to values, if it has any bindings at all in its body. Such a query may be lifted. At the time of lifting the local variables are substituted out of the body of the continuation.","The equations remaining, after the local variables have been substituted away, are between ports. Such a query then becomes a process that acts as a kind of explicit substitution, or a wire between equated ports.","Evolution is closed over the equivalence relation."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same become better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIGS. 3A\u20133C"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 6A\u20136B"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 7A\u20137B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 9A\u20139B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 10A\u201310C"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 11A\u201311V"}]},"DETDESC":[{},{}]}
