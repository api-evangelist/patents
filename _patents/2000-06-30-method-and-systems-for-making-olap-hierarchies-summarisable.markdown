---
title: Method and systems for making OLAP hierarchies summarisable
abstract: A method, a computer system and a computer program product for a computer system for transforming general On-line Analytical Processing (OLAP) hierarchies into summarizable hierarchies whereby pre-aggregation is disclosed, by which fast query response times for aggregation queries without excessive storage use is made possible even when the hierarchies originally are irregular. Pre-aggregation is essential for ensuring adequate response time during data analysis. Most OLAP systems adopt the practical pre-aggregation approach, as opposed to full pre-aggregation, of materializing only select combinations of aggregates and then re-use these for efficiently computing other aggregates. However, this re-use of aggregates is contingent on the dimension hierarchies and the relationships between facts and dimensions satisfying stringent constraints. The present invention significantly extends the scope of practical pre-aggregation by transforming irregulare dimension hierarchies and fact-dimension relationships into well-behaved structures that enable practical pre-aggregation.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07133865&OS=07133865&RS=07133865
owner: 
number: 07133865
owner_city: 
owner_country: 
publication_date: 20000630
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","DESCRIPTION OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENT","DETAILED DESCRIPTION OF THE INVENTION","EXAMPLE 1","EXAMPLE 2","EXAMPLE 3","EXAMPLE 4","EXAMPLE 5","EXAMPLE 6","EXAMPLE 7","EXAMPLE 8","EXAMPLE 9","EXAMPLE 10","Table 4: Dimension and Group Tables for Aggregation","REFERENCES"],"p":["The present invention relates to a method, a computer system, and a computer programme product for a computer system for transforming general On-line Analytical Processing (OLAP) hierarchies into summarisable hierarchies whereby pre-aggregation is enabled. Thereby, fast query response times for aggregation queries without excessive storage use are made possible even when the hierarchies originally are irregular.","On-line Analytical Processing (OLAP) systems, which aim to ease the process of extracting useful information from large amounts of detailed transactional data, have gained widespread acceptance in traditional business applications as well as in new applications such as health care. These systems generally offer a dimensional view of data, in which measured values, termed facts, are characterised by descriptive values, drawn from a number of dimensions; and the values of dimension are typically organised in a containment-type hierarchy. A prototypical query applies an aggregate function, such as average, to the facts characterised by specific values from the dimensions.","Fast response times are required from these systems, even for queries that aggregate large amounts of data. The perhaps most central technique used for meeting this requirement is termed pre-aggregation, where the results of aggregate queries are pre-computed and stored, i.e., materialised, for later use during query processing. Pre-aggregation has attracted substantial attention in the research community, where it has been investigated how to optimally use pre-aggregated data for query optimisation [7,3] and how to maintain the pre-aggregated data when base data is updated [19, 24]. Further, the latest versions of commercial RDBMS products offer query optimisation based on pre-computed aggregates and automatic maintenance of the stored aggregate when base data is updated [30].","The fastest response times may be achieved when materialising aggregate results corresponding to all combinations of dimension values across all dimensions, termed full (or eager) pre-aggregation. However, the required storage space grows rapidly, to quickly become prohibitive, as the complexity of the application increases. This phenomenon is called data explosion [4, 21, 27] and occurs because the number of possible aggregation combinations grows rapidly when the number of dimensions increase, while the sparseness of the multidimensional space decreases in higher dimension levels, meaning that aggregates at higher levels take up nearly as much space as lower-level aggregates. In some commercial applications, full pre-aggregation takes up as much as 200 times the space of the raw data [21]. Another problem with full pre-aggregation is that it takes too long to update the materialised aggregates when base data changes.","With the goal of avoiding data explosion, research has focused on how to select the best subset of aggregation levels given space constraints [1, 9, 11, 26, 28, 32] or maintenance time constraints [10], or the best combination of aggregate data and indices [8]. This approach is commonly referred to as practical (or partial or semi-eager [5, 11, 29]) pre-aggregation. Commercial OLAP systems now also exist that employ practical pre-aggregation, e.g., Microsoft Decision Support Services (Plato) [18] and Informix MetaCube [13].","A new database operator that generalises aggregations for the N-dimensional data space is disclosed by Jim Gray et al. \u201c---1, 1997, and solutions are proposed on how to integrate this operator on the execution and SQL-language level. It is mentioned that irregular dimension hierarchies renders the pre-aggregation impossible but no solution to this problem is provided.","The premise underlying the applicability of practical pre-aggregation is that lower-level aggregates can be re-used to compute higher-level aggregates, known as summarisability [16]. Summarisability occurs when the mappings in the dimension hierarchies are onto (all paths in the hierarchy have equal lengths), covering (only immediate parent and child values can be related), and strict (each child in a hierarchy has only one parent); and when also the relationships between facts and dimensions are many-to-one and facts are always mapped to the lowest levels in the dimensions [16]. However, the data encountered in many real-world applications fail to comply with this rigid regime. This motivates the search for techniques that allow practical pre-aggregation to be used for a wider range of applications, the focus of the present invention.","Motivated by the increasing use of OLAP systems in many different applications, including in business and health care, the present invention provides transformation techniques for multidimensional databases that leverage the existing, performance-enhancing technique, known as practical, or partial or semi-eager, pre-aggregation, by making this technique relevant to a much wider range of real-world applications.","Current pre-aggregation techniques assume that the dimensional structures are summarisable. Specifically, the mappings in dimension hierarchies must be onto, covering, and strict, the relationships between facts and dimensions must be many-to-one, and the facts must always be mapped to the lowest categories in dimensions.","The present invention presents novel transformation techniques that render dimensions with hierarchies that are non-onto, non-covering, and non-strict summarisable. The transformations have practically low computational complexity, they may be implemented using standard relational database technology, and it is also disclosed how to integrate the transformed hierarchies in current OLAP systems, transparently to the user.","The present description also disclose how to apply the transformations according to the invention to the cases of non-summarisable relationships between facts and dimensions, which also occur often in real-world applications. Finally, it is shown how to modify the algorithms to incrementally maintain the transformed hierarchies when the underlying data is modified. To our knowledge, this work is the first to present algorithms to automatically achieve summarisability for non-covering and non-onto hierarchies. The research reported here is also the first to demonstrate techniques and algorithms for achieving summarisability in non-strict hierarchies The integration of the techniques into current systems, transparently to the user, we believe is a novel feature.","The multidimensional databases or objects are, as the term indicates, comprised of a plurality of dimensions each being a hierarchy and the basic of the invention is to transform dimensions being irregular, that is being non-covering and\/or non-onto and\/or non-strict, into dimensions that are at least partly aggregation normalised, for most practical cases preferably fully aggregation normalised, to enable practical pre-aggregation of the dimensions. Thus, the present invention relates to a method for by means of a computer to at least partly aggregation normalise a dimension having dimension values organised into categories of dimension values based on a partial ordering, the dimension comprising mappings of links between dimension values, the method comprising the steps of\n\n","Most important for a preferred embodiment of the present invention is to transform the dimension to a aggregation strict dimension, thus the step of creating new dimensional values and modifying the mapping preferably comprises the step of\n\n","The step of creating new dimensional values and modifying the mapping may further comprise the step of\n\n","Additionally or alternatively, the step of creating new dimensional values and modifying the mapping may comprise the step of\n\n","The make-strict procedure comprises in a preferred embodiment of the invention the steps of, starting from the bottom category and successively proceeding towards the top category,\n\n","According to an even more preferred embodiment, the make-strict procedure comprises the successive steps of","(i) setting the bottom category of the dimension as the child category,","(ii) for each category being a direct predecessor of the child category of which category at least one dimension value of the child category is linked to a dimension value of, setting said category as the parent category and performing the steps of:",{"@attributes":{"id":"p-0019","num":"0000"},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":{"@attributes":{"id":"ul0011-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0012","list-style":"none"},"li":["(iia) ending the make-strict procedure for the parent category in case the parent category is the top category of the dimension,","(iib) ending the make-strict procedure for the parent category in case no dimension value of the parent category is linked to a dimension value of a higher category,","(iic) creating a new fused category in the dimension immediately below the parent category in case at least one of the dimension values of the child category is linked to more than one dimension value of the parent category,","(iid) for each dimensional value of the child category, performing the steps of: creating a new dimension value of the new fused category representing the one or more values of the parent category to which the dimensional value of the child category is linked and creating links from said new dimension value to said values in the parent category, the creation of the new dimension value being conditioned that no dimension value of the new fused category already exists having exactly such link(s), and","for each category being a direct predecessor of the parent category of which category at least one dimension value of the parent category is linked to a dimension value of, setting said category as a grandparent category and creating links from the new dimension value to the one or more dimension values of the grandparent category to which said one or more dimensional values of the parent category are linked,","(iie) removing the links from the parent category to the one or more grandparent categories, whereby the grandparent categories no longer are direct predecessors of the parent category,","(iif) creating links from each dimensional value of the child category to the dimension value of the new fused category having the same links to the dimension values of the parent category whereby the new fused category becomes a direct predecessor of the child category, and removing the links from the dimension values of the child category to the parent category, whereby the parent category no longer is a direct predecessor of the child category, and","(iig) setting the new fused category as the child category and returning to step (ii). This procedure is described as a recursive process but it is within the scope of the present invention to include a similar iterative procedure which would be obvious to the person skilled in the art."]}}}},"The make-onto procedure comprises according to a preferred embodiment of the invention the steps of, starting from the to category and successively proceeding towards the bottom category,\n\n","According to an even more preferred embodiment, the make-onto procedure comprises the successive steps of","(i) setting the top category of the dimension as the parent category,","(ii) for each category immediately below the parent category and having dimension values being linked to dimension values of the parent category, setting said category as the child category and perform the steps of",{"@attributes":{"id":"p-0022","num":"0000"},"ul":{"@attributes":{"id":"ul0015","list-style":"none"},"li":{"@attributes":{"id":"ul0015-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0016","list-style":"none"},"li":["(iia) creating, for each dimension value of the parent category not being linked to any dimensional value of the child category, a new dimension value in the child category and creating a link between said new dimension value and said dimension value of the parent category,","(iib) setting the child category as parent category,","(iic) ending the make-onto procedure in case the parent category is the bottom category of the dimension, else returning to step (ii) of the make-onto procedure. As for the make-strict procedure, this procedure is described as a recursive process but it is within the scope of the present invention to include a similar iterative procedure which would be obvious to the person skilled in the art."]}}}},"The make-covering procedure comprises according to a preferred embodiment of the present invention the successive steps of\n\n","According to an even more preferred embodiment, the make-covering procedure comprises the successive steps of","(i) setting the bottom category of the dimension as the child category,","(ii) for each category immediately above the child category for which at least one link between a dimension value of said category and a dimension value of the child category exists, setting the category as the parent category and perform the steps of:",{"@attributes":{"id":"p-0025","num":"0000"},"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":{"@attributes":{"id":"ul0019-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0020","list-style":"none"},"li":["(iia) ending the make-covering procedure for the parent category in case the parent category is the top category of the dimension,","(iib) for each higher category being a direct predecessor category of the child category and being higher in the hierarchy than the parent category, performing the steps of\n        \n        ","(iic) setting the parent category as the child category and returning to step (ii).\n\nAs with the above described procedures, this procedure is also described as a recursive process but it is within the scope of the present invention to include a similar iterative procedure which would be obvious to the person skilled in the art.\n"]}}}},"The present invention further relates to a method for by means of a computer to at least partly aggregation normalise a multidimensional object including a set of facts comprising a plurality of facts mapped on a plurality of dimensions having dimension values organised into categories of dimension values based on a partial ordering, the multidimensional object comprising mappings of links between dimension values within each dimension, by means of applying the method according to previous description including the variations thereof to at least one of the dimensions of the multidimensional object. In order to handle multidimensional object comprising a plurality of facts and in which the mapping comprises links from each of the facts to at least one dimension value in each of the plurality of dimensions, the facts may be organised in the hierarchies of the dimensions so that they constitute the bottom layer of each of the dimensions of the multidimensional object where after the method is applied to the object.","According to a variation of the present invention which for may practical situations of pre-aggregation is preferred, one or more of the dimensions of the multidimensional object is only partly aggregation normalised, the performance of the partly aggregation normalisation being based on a selection of a subset of categories of the one or more dimension to be aggregation normalised. In particular, one or more of the dimensions of the multidimensional object may be only partly aggregation normalised in that the normalisation steps to be performed are selected by means of the computer based on a selection of specific aggregation functions to be performed on the multidimensional object.","The present invention relates in a yet further aspect and as an alternative to the above disclosed method of including the facts into the multidimensional object and perform the aggregation normalisation on the whole object, to a method for by means of a computer to at least partly aggregation normalise a multidimensional object including a set of facts comprising a plurality of facts mapped on an aggregation normalised plurality of dimensions having dimension values being organised into categories of dimension values based on a partial ordering, the multidimensional object comprising mappings of links between dimension values within each dimension, the method comprising the steps of\n\n","In a preferred embodiment of the yet further aspect of the present invention, the step of creating new dimensional values and modifying the mapping comprises the step of\n\n","Additionally or alternatively, the step of creating new dimensional values and modifying the mapping comprises the step of\n\n","The make-strict and make-covering procedures may within the scope of the present invention be constructed similarly to the above-described procedures with the necessary modifications which for the skilled person would be straight forward.","The method according to the yet further aspect may further comprise the initial step of making each of the plurality of dimensions aggregation normalised by means of the method described previously.","The created new dimensional values may be marked as such, e.g. be stored in a parallel new dimension or in another manner be recognisable by the computer as being new values, likewise may the changed mapping be made recognisable, where after a pre-aggregation is performed on a multidimensional object being normalised by means of the computer according to the method and the method may further comprise the step of\n\n","Multidimensional objects are often in practical use updated with new facts and it is preferred that the method is able to handle such updates, which may be very frequent, without the need to perform the above method on the entire original multidimensional object, which may be a very timely procedure. Thus, the method may further comprise the steps of","implementing, into the aggregation normalised multidimensional object, of new facts including mapping of the facts onto the dimension, of new dimension values of the dimensions, or of new mapping between some of the dimension values, by which implementation irregularities of the multidimensional object is introduced,\n\n","The present invention relates further to a computer system comprising at least one general purpose computer having data storage means associated therewith on which data storage means is stored a computer programme product suitable for adapting the computer to perform an at least partly aggregation normalisation of a multidimensional object according to the above-described method(s), the computer system comprising means for retrieving the computer programme product and perform accordingly.","The present invention relates yet further to a computer programme product suitable for adapting a general purpose computer to perform an at least partly aggregation normalisation of a multidimensional object according to the above-described method(s).","A still further aspect of the present invention relates to a computer system having data storage means associated therewith on which a multidimensional object is stored, the multidimensional object including\n\n","The query handler component may according to the computer system of the still further aspect be adapted for producing replies to aggregate queries in which replies the existence of the second plurality of dimensions is transparent. The query handler component may furthermore be adapted for transforming aggregate queries made to the first plurality of dimensions into queries for the second set of dimensions and transforming replies based on the second set of dimensions into replies as based on the first set of dimensions, thus making the existence of the second plurality of dimensions transparent in the produced reply. Additionally, the multidimensional object may be stored within the data storage means of the computer system in tables organised as a combination of star schemes for the part of the multidimensional object containing only strict mappings, and additional tables containing the non-strict part of the mappings, the query handler component makes use of said tables in transforming queries and replies.","The computer system according to the still further aspect of the present invention may suitably be combined with the above-described method(s) and comprise means adapted for performing an at least partly aggregation normalisation of a multidimensional object according to the method(s).","The invention will be described primarily as a method for making non-summarisable hierarchies in multi-dimensional databases summarisable. However, a person skilled in the art will recognise that an apparatus, such as a data processing system, including a CPU, memory, I\/O, program storage, a connecting bus, and other appropriate components, could be programmed or otherwise designed to facilitate the practice of the method of the invention. Such a system would include appropriate program means for executing the method of the invention.","Also, an article of manufacture, such as a pre-recorded disk or other similar computer program products, for use with a data processing system, could include a storage medium and program means recorded thereon for directing the data processing system to facilitate the practice of the method of the invention. Such apparatus and articles of manufacture also fall within the spirit of the invention.","We now proceed to describe the invention in detail. The next section presents a real-world clinical case study that exemplifies the non-summarisable properties of real-world applications. The following section proceeds to define the aspects of a multidimensional data model necessary for describing the new techniques, and defines also important properties rated to summarisability. Algorithms are presented for transforming dimension hierarchies to achieve summarisability, then apply the algorithms to fix non-summarisable relationships between facts and dimensions. It is also demonstrated how the techniques may be integrated into current systems, transparently to the user and how to modify the algorithms to accommodate incremental computation.","Motivation\u2014A Case Study","This section presents a case study that illustrates the properties of real-world dimension hierarchies. The case study concerns patients in a hospital, their associated diagnoses, and their places of residence. The data analysis goal is to investigate whether some diagnoses occur more often in some areas than in others, in which case environmental or lifestyle factors might be contributing to the disease pattern. An ER diagram illustrating the underlying data is seen in .","The most important entities are the patients, for which we record the name. We always want to count the number of patients, grouped by some properties of the patients. Thus, in multidimensional terms, the patients are the facts, and the other, describing, entities constitute the dimensions.","Each patient has a number of diagnoses, leading to a many-to-many relationship between facts and the diagnosis dimension. When registering diagnoses of patients, physicians use different levels of granularity, ranging from very precise diagnoses, e.g., \u201cInsulin dependent diabetes during pregnancy;\u201d to more imprecise diagnoses, e.g., \u201cDiabetes,\u201d which cover wider ranges of patient conditions. To model this, the relationship from patient to diagnoses is to the supertype \u201cDiagnosis,\u201d which then has three subtypes, corresponding to different levels of granularity, the low-level diagnosis, the diagnosis family, and the diagnosis group. Examples of these are \u201cInsulin dependent diabetes during pregnancy,\u201d \u201cInsulin dependent diabetes,\u201d and \u201cDiabetes,\u201d respectively. The higher-level diagnoses are both (imprecise) diagnoses in their own right, but also serve as groups of lower-level diagnoses.","Each diagnosis has an alphanumeric code and a descriptive text, which are specified by some standard, here the World Health Organisation's International Classification of Diseases (ICD-10) [31], or by the physicians themselves. Indeed, two hierarchies are captured: the standard hierarchy specified by the WHO, and the user-defined hierarchy, which is used for grouping diagnoses on an ad-hoc basis in other ways than given by the standard. The Type attribute on the relationships determines whether the relation between two entities is part of the standard or the user-defined hierarchy.","The hierarchy groups low-level diagnoses into diagnosis families, each of which consists of 2\u201320 related diagnoses. For example, the diagnosis \u201cInsulin dependent diabetes during pregnancy\u201d (the reason for having a separate pregnancy related diagnosis is that diabetes must be monitored and controlled particularly intensely during a pregnancy to assure good health of both mother and child) is part of the family \u201cDiabetes during pregnancy.\u201d In the WHO hierarchy, a low-level diagnosis belongs to exactly one diagnosis family, whereas the user-defined hierarchy does not have this restriction. Thus, a low-level diagnosis can belong to several diagnosis families, e.g., the \u201cInsulin dependent diabetes during pregnancy\u201d diagnosis belongs to both the \u201cDiabetes during pregnancy\u201d and the \u201cInsulin dependent diabetes\u201d family. Next, diagnosis families are grouped into diagnosis groups, consisting of 2\u201310 families, and one family may be part of several groups. For example, the family \u201cDiabetes during pregnancy\u201d may the part of the \u201cDiabetes\u201d and \u201cOther pregnancy related diseases\u201d groups.","In the WHO hierarchy, a family belongs to exactly one group. In the WHO hierarchy, a lower-level value belongs to exactly one higher-level value, making it strict and covering. In the user-defined hierarchy, a lower-level value may belong to zero or more higher-level values, making it non-strict and non-covering. Properties of the hierarchies will be discussed in more detail in the section \u201cHierarchy Properties.\u201d","We also record the addresses of the patients. If the address is located in a city, we record the city; otherwise, if the address is in a rural area, we record the county in which the address is located. A city is located in exactly one county. As not all addresses are in cities, we cannot find all addresses in a county by going through the \u201cCity located in\u201d relationship. Thus, the mapping from addresses to cities is non-covering w.r.t. addresses. For cities and counties, we just record the name. Not all counties have cities in them, so the mapping from cities to counties is into rather than onto.","In order to exemplify the data, we assume a standard mapping of the ER diagram to relational tables, i.e., one table per entity and relationship type. We also assume the use of surrogate keys, named ID, with globally unique values. The three subtypes of the Diagnosis type are mapped to a common Diagnosis table, and because of this, the \u201cbelongs to\u201d and \u201cgrouping\u201d relationships are mapped to a common \u201cGrouping\u201d table. The resulting tables with sample data are shown in Table 1 and will be used in examples throughout the paper.","If we apply pre-aggregation to the data from the case study, several problems occur. For example, if the counts of patients by City are pre-computed and we use these for computing the numbers of patients by county, an incorrect result will occur. In the data, the addresses \u201c123 Rural Road\u201d and \u201c1 Sandy Dunes\u201d (one of them is the address of a patient) are not in any city, making the mapping from City to County not covering w.r.t. addresses.","Next, if the counts of patients by Low-Level Diagnosis are pre-computed and we use these for computing the total count of patients, an incorrect result again ensues. First, patients only with lung cancer are not counted, as lung cancer is not present at the level of Low-Level Diagnosis; the mapping from Low-Level Diagnosis to Diagnosis Family is into. Second, patients such as \u201cJim Doe\u201d only have higher-level diagnoses and will no be counted; the fact-to-dimension mapping has varying granularity. Third, patients such as \u201cJane Doe\u201d have several diagnoses and will be counted several times; the relationship between facts and dimensions",{"@attributes":{"id":"p-0062","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Tables for the Case Study"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID","Name"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"1","John Doe"]},{"entry":[{},"2","Jane Doe"]},{"entry":[{},"3","Jim Doe"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Patient"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PatientID","AddressID"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"1","50"]},{"entry":[{},"2","51"]},{"entry":[{},"3","52"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"LivesAt"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID","Address"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"50","21 Central Street"]},{"entry":[{},"51","34 Main Street"]},{"entry":[{},"52","123 Rural Road"]},{"entry":[{},"53","1 Sandy Dunes"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Address"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID","Name"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"20","Sydney"]},{"entry":[{},"21","Melbourne"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"City"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PatientID","DiagnosisID","Type"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["1","9","Primary"]},{"entry":["2","5","Secondary"]},{"entry":["2","9","Primary"]},{"entry":["3","11","Primary"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Has"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ParentID","ChildID","Type"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["\u20024","5","WHO"]},{"entry":["\u20024","6","WHO"]},{"entry":["\u20029","5","User-defined"]},{"entry":["10","6","User-defined"]},{"entry":["11","9","WHO"]},{"entry":["11","10","WHO"]},{"entry":["12","4","WHO"]},{"entry":["13","14","WHO"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Grouping"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"133pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ID","Code","Text","Type"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["\u20024","O24","Diabetes during pregnancy","Family"]},{"entry":["\u20025","O24.0","Insulin dependent diabetes during pregnancy","Low-Level"]},{"entry":["\u20026","O24.1","Non insulin dependent diabetes during preg-","Low-Level"]},{"entry":[{},{},"nancy"]},{"entry":["\u20029","E10","Insulin dependent diabetes","Family"]},{"entry":["10","E11","Non insulin dependent diabetes","Family"]},{"entry":["11","E1\u2002","Diabetes","Group"]},{"entry":["12","O2","Other pregnancy related diseases","Group"]},{"entry":["13","A1\u2002","Cancer","Group"]},{"entry":["14","A11","Lung cancer","Family"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Diagnosis"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"AddressID","CityID"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"50","20"]},{"entry":[{},"51","21"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"LocatedInCity"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID","Name"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"30","Sydney"]},{"entry":[{},"31","Melbourne"]},{"entry":[{},"32","Outback"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"County"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"14pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ID","Name"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"52","31"]},{"entry":[{},"53","32"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"LocatedInRuralArea"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CityID","CountyID"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"20","30"]},{"entry":[{},"21","31"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"CityLocatedIn"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"These problems yield \u201cnon-summarisable\u201d dimension hierarchies that severely limit the applicability of practical pre-aggregation, leaving only full pre-aggregation, requirering huge amounts of storage, or no pre-aggregation, resulting in long response time for queries.","The properties described above are found in many other real-world applications. Many-to-many relationships between facts and dimensions occur between bank customers and accounts, between companies and Standard Industry Classifications (SICs), and between students and departments [15, 16]. Non-strict dimension hierarchies occur from cities to states in a Geography dimension [25] and from weeks to months in a Time dimension. In addition, hierarchies where the change over time is captured are generally non-strict. The mapping from holidays to weeks as well as organisation hierarchies of varying depth [12] offer examples of \u201cinto\u201d mappings. Non-covering relationships exist for days-holidays-weeks and for counties-cities-states, as well as in organisation hierarchies [12].","Even though many real-world cases possess the properties described above, current techniques for practical pre-aggregation require that facts are in a many-to-one relationships to dimensions and that all hierarchies are strict, onto, and covering. Thus, current techniques cannot be applied when the hierarchies has these properties.","Method Context","This section defines the aspects of a multidimensional data model that are necessary to define the techniques that enable practical pre-aggregation in applications as the one just described. The full model is described elsewhere [22]. Next, the data model context is exploited for defining properties of hierarchies relevant to the techniques.","The particular data model has been chosen over other multidimensional data models because it quite naturally captures the data described in the case study and because it includes explicit concepts of dimensions and dimension hierarchies, which is very important for clearly presenting the techniques. However, the techniques are also applicable to other multidimensional or statistical data models, as will be discussed in the section \u201cArchitectural Conext.\u201d","A Concrete Data Model Context","For each part of the model, we define the intension and the extension, and we give an illustrating example.","An n-dimensional fact schema is a two-tuple S=(F, D), where F is a fact type and D={T, i=1, . . . , n} is its corresponding dimension types.","In the case study, Patient is the fact type, and Diagnosis, Residence, and Name are the dimension types. The intuition is that everything that characterises the fact type is considered to be dimensional.","A dimension type T is a four-tuple (C, \u2266, \u2266T, \u22a5), where C={C, j=1, . . . , k} are the category types of T, \u2266is a partial order on the C's, with T\u03b5 C and \u22a5\u03b5 C being the top and bottom element of the ordering, respectively. Thus, the category types form a lattice. The intuition is that one category type is \u201cgreater than\u201d another category type if members of the formers extension logically contain members of the latter's extension, i.e., they have a larger value size. The top element of the ordering corresponds to the largest possible value size, that is, there is only one value in it's extension, logically containing all other values.","We say that Cis a category type of T, written C\u03b5T, if C\u03b5C.","Low-level diagnoses are contained in diagnosis families, which are contained in diagnosis groups. Thus, the Diagnosis dimension type has the following order on its category types: \u22a5=Low-level Diagnosis<Diagnosis Family<Diagnosis Group<T. Other examples of category types are Address, City, and County. , to be discussed in detail later, illustrates the dimension types of the case study.","A category Cof type Cis a set of dimension values e. A dimension D of type T=({C}, \u2266, T, \u22a5) is a two-tuple D=(C, \u2266), where C={C} is a set of categories Csuch that Type(C)=Cand \u2266 is a partial order on \u222aC, the union of all dimension values in the individual categories. We assume a function Pred: C 2that gives the set of direct predecessors of a category C. Similarly, we a assume a function Desc: C 2that gives the set of direct descendants of a category C. For both Pred and Desc, we \u201ccount\u201d from the category T(of type T), so that category Thas no predecessors and category \u22a5(of type \u22a5) has no descendants. Similarly, we assume a function ImmPred: C 2that gives only the set of immediate predecessors of a category C. Immediate predecessors are immediately above in the hierarchy, i.e., City is an immediate predecessor of Address, but County is not. Similarly, we a assume a function ImmDesc: C 2that gives the set of immediate descendants of a category C.","The definition of the partial order is: given two values e, ethen e\u2266eif eis logically contained in e. We say that Cis a category of D, written C\u03b5D, if C\u03b5C. For a dimension value e, we say that e is a dimensional value of D, written e \u03b5 D, if e \u03b5 \u222aC.","The category of type \u22a5in dimension of type T contains the values with the smallest value size. The category with the largest value size, with type T, contains exactly one value, denoted T. For all values e of the dimension D, e\u2266T. Value T is similar to the ALL construct of Gray et al. [6]. When the context is clear, we refer to a category of type Tas a T category, not to be confused with the T dimension value.","In our Diagnosis dimension we have the following categories, named by their type. The numbers in parentheses are the ID values from the Diagnosis table in Table 1. Low-level Diagnosis={\u201cInsulin dependent diabetes during pregnancy\u201d (5), \u201cNon insulin dependent diabetes during pregnancy\u201d (6)}, Diagnosis Family={\u201cDiabetes during pregnancy\u201d (4), \u201cInsulin dependent diabetes\u201d (9), \u201cNon insulin dependent diabetes\u201d (10), \u201cLung cancer\u201d (14)}, Diagnosis Group={\u201cDiabetes\u201d (11), \u201cOther pregnancy related diseases\u201d (12), \u201cCancer\u201d (13)}, and T={T}. We have that Pred(Low-level Diagnosis)={Diagnosis Family}. The partial order \u2266 is obtained by combining WHO and user-defined hierarchies, as given by the Grouping table in Table 1. Additionally, the top value T is greater than, i.e., logically contains, all the other diagnosis values.","Let F be a set of facts, and D=(C={C}, \u2266) a dimension. A fact-dimension relation between F and D is a set R {(f, e)}, where f\u03b5F and e\u03b5\u222aC. Thus R links facts to dimension values. We say that fact f is characterised by dimension value e, written f e, if \u2203e\u03b5D ((f, e) \u03b5R\u039be\u2266e). We require that \u2200f\u03b5F (\u2203e\u03b5\u222aC((f, e)\u03b5R)); thus, all fact maps to at least one dimension value in every dimension. The T value is used to represent an unknown or missing value, as T logically contains all dimension values, and so a fact f is mapped to T if it cannot be characterised within the particular dimension.","The fact-dimension relation R links patient facts to diagnosis dimension values as given by the Has table from the case study, so that R={(\u201cJohn Doe\u201d (1), \u201cInsulin dependent diabetes\u201d (9)), (\u201cJane Doe\u201d (2), \u201cInsulin dependent diabetes during pregnancy\u201d (5)), (\u201cJane Doe\u201d (2), \u201cInsulin dependent diabetes\u201d (9)), (\u201cJim Doe\u201d (3), \u201cDiabetes\u201d (11))}. Note that facts may be related to values in higher-level categories. We do not require that e belongs to \u22a5. For example, the fact \u201cJohn Doe\u201d (1) is related to the diagnosis \u201cInsulin dependent diabetes\u201d (5), which belongs to the Diagnosis Family category. This feature will be used later to explicitly capture the different granularities in the data. If no diagnosis was known for patient \u201cJohn Doe\u201d (1), we would have added the pair (\u201cJohn Doe\u201d (1), T) to R.","A multidimensional object (MO) is a four-tuple M=(S, F, D, R), where S=(F, D={T}) is the fact schema, F={f} is a set of facts f where Type(f)=F, D={D, i=1, . . . , n} is a set of dimensions where Type(D)=T, and R={R, i=1, . . . , n} is a set of fact-dimension relations, such that \u2200i((f, e)\u03b5R f\u03b5F\u039b\u2203C\u03b5D(e\u03b5C)).","For the case study, we get a three-dimensional MO M=(S, F, D, R), where S=(Patient, {Diagnosis, Name, Residence}) and F={\u201cJohn Doe\u201d (1), \u201cJane Doe\u201d (2), \u201cJim Doe\u201d (3)}. The definition of the diagnosis dimension and its corresponding fact-dimension relation was given in the previous examples. The Residence dimension has the categories Address (\u22a5), City, County, and T. The values of the categories are given by the corresponding tables in Table 1. The partial order is given by the relationship tables. Additionally, the only value in the Tcategory is T, which logically contains all the other values in the Residence dimension. The Name dimension is simple, i.e., it just has a Name category (=\u22a5) and a T category. We will refer to this MO as the \u201cPatient\u201d MO. A graphical illustration of the schema of the \u201cPatient\u201d MO is seen in . Because some addresses map directly to counties, County is an immediate predecessor of Address.","The facts in an MO are objects with value-independent identity. We can test facts for equality, but do not assume an ordering on the facts. The combination of dimensions values that characterise the facts of a fact set is not a \u201ckey\u201d for the fact set. Thus, several facts may be characterised by the same combination of dimension values. But, the facts of an MO is a set, so an MO does not have duplicate facts. The model formally defines quite general concepts of dimensions and dimension hierarchies, which is ideal for the presentation of our techniques. The presented techniques are not limited by the choice of data model.","Hierarchy Properties","In this section important properties of MOs that relate to the use of pre-computed aggregates are defined. The properties will be used in the following sections to state exactly what problems the proposed algorithms solve. The first important concept is summarisability, which intuitively means that higher-level aggregates may be obtained directly from lower-level aggregates.\n\nDefinition 1 Given a type T, a set S={S, j=1, . . . , k}, where S\u03b52, and a function g: 2 T, we say that g is summarisable for S if g({{g(S), . . . , g(S)}})=g(S\u222a . . . \u222aS). The argument on the left-hand side of the equation is a multiset, i.e., the same value may occur multiple times.\n","Summarisability is important as it is a condition for the flexible use of pre-computed aggregates. Without summarisability, lower-level results generally cannot be directly combined into higher-level results. This means that we cannot choose to pre-compute only a relevant selection of the possible aggregates and then use these to (efficiently) compute higher-level aggregates on-the-fly. Instead, we have to pre-compute the all the aggregate results of queries that we need fast answers to, while other aggregates must be computed from the base data. Space and time constraints can be prohibitive for pre-computing all results, while computing aggregates from base data is often inefficient.","It has been shown that summarisability is equivalent to the aggregate function (g) being distributive, all paths being strict, and the mappings between dimension values in the hierarchies being covering and onto [16]. These concepts are formally defined below. The definitions assume a dimension D=(C, \u2266) and an MO M=(S, F, D, R).","Definition 2 Given two categories, C, Csuch that C\u03b5Pred(C), we say that the mapping from Cto Cis onto iff \u2200e\u03b5C(\u2203e\u03b5C(e\u2266e)). Otherwise, it is into. If all mappings in a dimension are onto, we say that the dimension hierarchy is onto. Given an MO M, if all dimension hierarchies in M are onto, we say that M is onto.","Mappings that are into typically occur when the dimension hierarchy has varying height. In the case study, there is no low-level cancer diagnosis, meaning that some parts of the hierarchy have height , while most have height . It is thus not possible to use aggregates at the Low-level Diagnosis level for computing aggregates at the two higher levels. Mappings that are into also occur often in organisation hierarchies.","Definition 3 Given three categories, C, C, and Csuch that Type(C)<Type(C)<Type(C), we say that the mapping from Cto Cis covering with respect to Ciff \u2200e\u03b5C(\u2200e\u03b5C(e\u2266e \u2203e\u03b5C(e\u2266e\u039be\u2266e))). Otherwise, it is non-covering with respect to C. If all mappings in a dimension are covering w.r.t. any category, we say that the dimension hierarchy is covering. If all dimension hierarchies in the dimensions of M are covering and all mappings between categories in the dimensions of M are covering w.r.t. F, we say that M is covering.","Non-covering mappings occur when some of the links between dimension values skip one or more levels and map directly to a value located higher up in the hierarchy. In the case study, this happens for the \u201c1 Sandy Dunes\u201d address, which maps directly to \u201cOutback County\u201d (there are no cities in Outback County). Thus, we cannot use aggregates at the City level for computing aggregates at the County level.","Definition 4 Given an MO M=(S, F, D, R), and two categories Cand Cthat belong to the same dimension D\u03b5D such that Type(C)<Type(C), we say that the mapping from Cto Cis covering with respect to F, the set of facts, iff \u2200f\u03b5F (\u2200e\u03b5C(f e \u2203e\u03b5C(f\u039be\u2266e))).","This case is similar to the one above, but now it is the mappings between facts and dimension values that may skip one or more levels and map facts directly to dimension values in categories above the bottom level. In the case study, the patients can map to diagnoses anywhere in the Diagnosis dimension, not just to Low-level Diagnoses. This means that we cannot use aggregates at the Low-level Diagnosis Level for computing aggregates higher up in the hierarchy.","Definition 5 Given two categories, Cand Csuch that C\u03b5Pred(C), we say that the mapping from Cto Cis strict iff \u2200e\u03b5C(\u2200e, e\u03b5C(e\u2266e\u039be\u2266e e=e)). Otherwise, it is non-strict. The hierarchy in dimension D is strict if all mappings in it are strict; otherwise, it is non-strict Given an MO M=(S, F, D, R) and a category Cin some dimension D\u03b5D, we say that there is a strict path from the set of facts F to Ciff \u2200f\u03b5F(fe\u039bfe\u039be\u03b5C\u039be\u03b5C e=e). (Note that the paths to the Tcategories are always strict.) The hierarchy in dimension D is said to be aggregation strict if the following hold: if a mapping from a category C to a category P, both in D, is non-strict, then Pred(P)=\u03b8, i.e., P has no parents in the hierarchy.","Non-strict hierarchies occur when a dimension value has multiple parents. This occurs in the Diagnosis dimension in the case study where the \u201cInsulin dependent diabetes during pregnancy\u201d low-level diagnosis is part of both the \u201cInsulin Dependent Diabetes\u201d and the \u201cDiabetes during pregnancy\u201d diagnosis families, which in turn both are part of the \u201cDiabetes\u201d diagnosis group. This means that we cannot use aggregates at the Diagnosis Family level to compute aggregates at the Diagnosis Group level, since data for \u201cInsulin dependent diabetes during pregnancy\u201d would then be counted twice. Hierarchies that are aggregation strict allow practical pre-aggregation to be applied because the values in the parent category has no parents themselves. This means that double-counting of data will not occur, since the values in the parent categories containing possibly overlapping data will not be added together.","Definition 6 If the dimension hierarchy for a dimension D is onto, covering, and strict, we say that D is normalised. Otherwise, it is un-normalised. For an MO M=(S, D, F, R), if all dimensions D\u03b5D are normalised and \u2200R\u03b5R((f, e)\u03b5R e\u03b5\u22a5) (i.e., all facts map to dimension values in the bottom category), we say that M is normalised. Otherwise, it is un-normalised. If the hierarchy in a dimension D is covering, onto, and aggregation strict, we say that D is aggregation normalised. If all dimensions in an MO M are aggregation normalised and the relationships from facts to dimensions are many-to-one and only to the bottom category, we say that M is aggregation normalised.","For normalised hierarchies and MOs, all mappings are summarisable, meaning that we can pre-aggregate values at any combination of dimension levels and safely re-use the pre-aggregated values to compute higher-level aggregate results. Thus, we want to normalise the dimension hierarchies and MOs for which we want to apply practical pre-aggregation.","We proceed to describe how the normalisation of the dimension hierarchies and MOs used for aggregation is achieved. We first show how to perform transformations on dimension hierarchies, then later describe how the same techniques may be applied to eliminate the non-summarisable properties of fact-dimension relations.","Dimension Transformation Techniques","This section describes how dimensions can be transformed to achieve summarisability. Transforming dimensions on their own, separately from the facts, results in well-behaved dimensions that can be applied in a number of different systems or sold to third-party users. The transformation of the dimension hierarchies is a three-step operation. First, all mappings are transformed to be covering, by introducing extra \u201cintermediate\u201d values. Second, all mappings are transformed to be onto, by introducing \u201cplaceholder\u201d values at lower levels for values without any children. Third, mappings are made strict, by \u201cfusing\u201d values together. The three steps are treated in separate sections. None of the algorithms introduce any non-summarisable properties, so applying each once is sufficient.","In general, the algorithms take as input a set of tables Rthat specifies the mapping from dimension values in category Cto values in category C. The input needs not contain all pairs of ancestors and descendants\u2014only direct parent-child relationships are required. If there are non-covering mappings in the hierarchy, we have categories C, F, H such that {P,H}  Pred(C) and Type(P)<Type(H). In this case, the input must also contain Rtables that map P values to H values.","The algorithms are expressed using recursion. They could also easily be expressed using iteration instead.","Non-Covering Hierarchies","The first algorithm renders all mappings in a dimension hierarchy covering w.r.t. any category. When a dimension value is mapped directly to another value in a category higher than the one immediately above it in the hierarchy, a new intermediate value is inserted into the category immediately above, and the two original dimension values are linked to this new value, rather than to each other.","In the hierarchy for the Residence dimension, two links go from Address directly to County. The address \u201c123 Rural Road\u201d (52) is in \u201cMelbourne County\u201d (31), but not in a city, and the address \u201c1 Sandy Dunes\u201d (53) is in \u201cOutback County\u201d (32), which does not have any cities at all. The algorithm inserts two new dimension values in the City category, C and C, which represent Melbourne and Outback county, respectively, and links them to their respective counties. The addresses \u201c123 Rural Road\u201d and \u201c1 Sandy Dunes\u201d are then linked to C and C, respectively. This occurs in the first call of procedure MakeCovering (on the Address category; the procedure is given below). When MakeCovering is called recursively on the City, County, and T categories, nothing happens, as all mappings are already covering. The transformation is illustrated graphically in  to the left. The dotted lines show the \u201cproblematic\u201d links, and the bold-face values and thick lines show the new dimension values and links.","In the algorithm, C is a child category, P is an immediate parent category, H is a \u201chigher\u201d category, L are the non-covering links from C to H, and N are the \u201chigher\u201d dimension values in L. The  operator denotes natural join. The algorithm works as follows. Given the argument category C (initially the bottom category) in line (1), the algorithms goes through all C's immediate parent categories P (2). For each immediate parent category P, it looks for predecessor categories H of C that are \u201chigher\u201d in the hierarchy than P (4). If such an H exist, there might be links in the mapping from C to H that are not available by going through P. Line (6) finds these \u201cnon-covered\u201d links, L, in the mapping from C to H by \u201csubtracting\u201d the links that are available by going through P from all the links in the mapping from C to H. Line (7) uses L to find the dimension values N in H that participate in the \u201cnon-covered\u201d mappings. For each value in N, line (8) inserts a corresponding marked value into P; these marked values represent the N values in P. The marked values in P are then linked to the original values in H (9) and C (10). Line (12) changes the schema so that H is no longer a predecessor of C. This can be done safely as the intermediate values and links means that the values in H and C that were connected before are still connected by going through P. Line (13) contains a recursive call to the algorithm P, thus fixing mappings higher up in the hierarchy. The algorithm terminates when it reaches the T category, which has no predecessors.",{"@attributes":{"id":"p-0102","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2002(1)","procedure MakeCovering(C)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2002(2)","for each P \u2208 ImmPred(C) do"]},{"entry":["\u2002(3)","begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2002(4)","for each H \u2208 Pred(C) where Type(H) > Type(P) do"]},{"entry":["\u2002(5)","begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2002(6)","L \u2190 R\\ II(R \u2009R)"]},{"entry":["\u2002(7)","N \u2190 II(L)"]},{"entry":["\u2002(8)","P \u2190 P \u222a {Mark(h) | h \u2208 N}"]},{"entry":["\u2002(9)","R\u2190 R\u222a {(Mark(h), h) | h \u2208 N}"]},{"entry":["(10)","R\u2190 R\u222a {(c, Mark(h)) | (c, h) \u2208 L}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(11)","end"]},{"entry":["(12)","Pred(C) \u2190 Pred(C) \\ {H}"]},{"entry":["(13)","MakeCovering(P)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["(14)","end"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(15)","end"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"All steps in the algorithm are expressed using standard relational algebra operators. The general worst-case complexity of join is O(n), where n is the size of the input. However, because the input to the algorithm are hierarchy definitions, the complexity of the join in the algorithm will only be O(n log n). Thus, all the operators used can be evaluated in time O(n log n), where n is the size of the input. The Mark operation can be performed in O(1) time. The inner loop of the algorithm is evaluated at most once for each link between categories, i.e., at most k\/2 times, where k is the number af categories (if all categories are directly linked to all others). Thus, the overall big-O complexity of the algorithm is O(kn log n), where k is the number of categories and n is the size of the largest participating Rrelation. The worst-case complexity will not apply very often; in most cases, the inner loop will only be evaluated at most k times.","The algorithm inserts new values into the P category to ensure that the mappings from P to higher categories are summarisable, i.e., that pre-aggregated results for P can be directly combined into higher-level aggregate results. The new values in P mean that the cost of materialising aggregate results for P is higher for the transformed hierarchy than for the original. However, if the hierarchy was not transformed to achieve summarisability, we would have to materialise aggregates for G, and perhaps also for higher level categories. At most one new value is inserted into P for every value in G, meaning that the extra cost of materialising results for P is never greater than the cost of the (otherwise necessary) materialisation of results for G. This is a very unlikely worst-case scenario\u2014in the most common cases, the extra cost for P will be much lower than the the cost of materialising results for G, and the savings will be even greater because materialisation of results for higher-level categories may also be avoided.","The correctness argument for the algorithm has two aspects. First, the mappings in the hierarchy should be covering upon termination. Second, the algorithm should only make transformations that are semantically correct, i.e., we should get the same results when computing results with the new hierarchy as with the old. The correctness follows from Theorem 1 and 2, below. As new values are inserted in the P category, we will get aggregate values for both the new and the original values when \u201cgrouping\u201d by P. Results for the original values will be the same as before, so the original result set is a subset of the result set obtained with the transformed hierarchy.","Theorem 1 Algorithm MakeCovering terminates and the hierarchy for the resulting dimension D\u2032 is covering.","Proof: By induction in the height of the dimension lattice. Base: The height is 0, making the statement trivially true. Induction Step: We assume the statement is true for dimension lattices of height n, and consider lattices of height n+1. For termination, we note that there is a finite number of (P, H) pairs, all operations in the inner loop terminate, and the algorithm is called recursively on P, which is the root of a lattice of height n. For the covering property, we note that the insertion of intermediate, marked values into P means that the mapping from P to H is covering w.r.t. C. By the induction hypothesis, the mappings higher in the hierarchy are fixed by the recursive call of the algorithm.\n\nTheorem 2 Given dimensions D and D\u2032 such that D\u2032 is the result of running MakeCovering on D, an aggregate result obtained using D is a subset of the result obtained using D\u2032.\n\nProof: Follows easily from Lemma 1, next, as the inserted values are \u201cinternal\u201d in the hierarchy.\n\nLemma 1 For the dimension D\u2032 (C\u2032, \u2266\u2032) resulting from applying algorithm MakeCovering to dimension D (C, \u2266), the following holds: \u2200e,e\u03b5D(e\u2266\u2032e e\u2266e) (there is a path between any two original dimension values in the new dimension hierarchy iff there was a path between them in the original hierarchy).\n\nProof: By induction in the height of the dimension lattice. Base: The height is 0 making the statement trivially true. Induction Step: We assume the statement is true for dimension lattices of height n, and consider lattices of height n+1. Examing the inner loop, we see that the insertion of intermediate values into P, and the linking of values in C and H to these, only links values in C and H that were linked before. No links or values are destroyed by the inner loop. Thus, the statement is true for the links from C to P, and from C to H. By the induction hypothesis, the statement holds true for the transformations made by the recursive call on P.\n","We see that the original values in the hierarchy are still linked to exactly the same original values as before, as stated by Lemma 1, although new values might have been inserted in-between the original values. Thus, when evaluating a query using the transformed hierarchy, the results for the original values will be the same as when using the original hierarchy.","Assuming only the original result set is desired, results for the new values must be excluded, which is easy to accomplish. The new, \u201cinternal\u201d values are marked with \u201cmark=internal\u201d, whereas the original values have \u201cmark=original\u201d. In order to exclude the new, internal values from the result set, the equivalent of an SQL HAVING clause condition of \u201cmark=original\u201d is introduced into the original query.","Non-Onto Hierarchies","The second algorithm renders all mappings in hierarchies onto, i.e., all dimension values in non-bottom categories have children. This is ensured by inserting placeholder values in lower categories to represent the childless values. These new values are marked with the original values, making it possible to map facts to the new placeholder values instead of to the original values. This makes it possible to only map facts to the bottom category.","In the Diagnosis dimension, the \u201cLung cancer\u201d diagnosis family (ID=14) has no children. When the algorithm reaches the Diagnosis Family category, it inserts a placeholder value (L14) into the Low-level Diagnosis category, representing the \u201cLung cancer\u201d diagnosis, and links it to the original value. Facts mapped to the \u201cLung cancer\u201d value may then instead be mapped to the new placeholder value, ensuring that facts are mapped only to the Low-level Diagnosis Category. A graphical illustration of the transformation is seen to the right in . The bold-faced L value is the new value inserted; and the thick line between 14 and L is the new link inserted.","In the algorithm below, P is a parent category, C is a child category, and N holds the parent values with no children. The algorithm works as follows. Given a category P (initially the T category) in line (1), the algorithm goes through all categories C that are (immediate) descendants of P (2). For each C, line (4) finds the values N in P that have no children in C, by \u201csubtracting\u201d the values with children in C from the values in P. For each \u201cchildless\u201d value in N, lines (5) and (6), respectively, insert into C a placeholder value marked with the parent value, and links the new value to the original. MakeOnto is then called recursively on C (7). The algorithms terminates when it reaches the \u22a5 category, which has no descendants.",{"@attributes":{"id":"p-0112","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["(1)","procedure MakeOnto(P)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(2)","for each C \u2208 Desc(P) do"]},{"entry":["(3)","begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(4)","N \u2190 P \\ II(R)"]},{"entry":["(5)","C \u2190 C \u222a {Mark(p) | p \u2208 N}"]},{"entry":["(6)","R\u2190 R\u222a {(Mark(p),p) | p \u2208 N}"]},{"entry":["(7)","MakeOnto(C)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["(8)","end"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(9)","end"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Following the reasoning in the previous section, we find that the overall big-O complexity is O(kn log n), where k is the number of categories and n is the size of the largest participating Rrelation. However, the complexity will only be O(kn log n) for the most common cases.","The MakeOnto algorithm inserts new values into C to ensure that the mapping from C to P is summarisable. Again, this means that the cost of materialising results for C will be higher for the transformed hierarchy than for the original. However, if the new values were not inserted, we would have to materialise results for P, and perhaps also higher categories, as well as C. At most one value is inserted in C for every value in P, meaning that the extra cost for C is never greater than the cost of materialising results for P. As before, this is a very unrealistic scenario, as it corresponds to the case where no values in P have children in C. In most cases, the extra cost for C will be a small percentage of the cost of materialising results for P, and the potential savings will be even greater, because pre-aggregation for higher-level categories may be avoided.","As before, the correctness argument for the algorithm has two aspects. First, the mappings in the hierarchy should be onto upon termination. Second, the algorithm should only make transformations that are semantically correct. The correctness follows from Theorems 3 and 4, below. Again, the result set for the original values obtained using the original hierarchy will be a subset of the result set obtained using the transformed hierarchy. The results for the new values can be excluded from the result set by adding a HAVING clause condition.","Theorem 3 Algorithm MakeOnto terminates and the hierarchy for the resulting dimension D\u2032 is onto.","Proof: By induction in the height of the dimension lattice. Base: The height is 0, making the statement trivially true. Induction Step: We assume the statement is true for dimension lattices of height n, then consider lattices of height n+1. For termination, we note that there is a finite number of descendants C for each P, that all operations in the loop terminate, and that the algorithm is called recursively on C, which is the top element in a lattice of height n. For the onto property, we note that the insertion of placeholder values into C makes the mapping from C to P onto. By the induction hypothesis, the mappings further down in the lattice are handled by the recursive call.\n\nTheorem 4 Given dimensions D and D\u2032 such that D\u2032 is the result of applying algorithm MakeOnto to D, an aggregate result obtained using D is a subset of the result obtained using D\u2032.\n\nProof: Follows easily from the observation that \u201cchildless\u201d dimension values are linked to new, placeholder values in lower categories in one-to-one relationships, meaning that data for childless values will still be counted exactly once in aggregate computations that use the new dimension.\n\nNon-Strict Hierarchies\n\nThe third algorithm renders mappings in hierarchies strict, meaning that problems of \u201cdouble-counting\u201d will not occur. Non-strict hierarchies occur when one dimension value has several parent values.\n","The basic idea is to \u201cfuse\u201d a set of parent values into one \u201cfused\u201d value, then link the child value to this new value instead. The fused values are inserted into a new category in-between the child and parent categories. Data for the new fused category may safely be re-used for computation of higher-level aggregate results, as the hierarchy leading up to the new category is strict.","The fused value is also linked to the relevant parent values. This mapping is by nature non-strict, but this non-strictness is not a problem, as we prevent aggregate results for the parent category from being re-used higher up in the hierarchy. This is done by \u201cunlinking\u201d the parent category from its predecessor categories.","The categories higher up are instead reached through the fused category. This means that we can still get results for any original category, while being able to apply practical pre-aggregation throughout the hierarchy. In pre-aggregation terms, the \u201cunlinking\u201d of the parent categories means that we must prevent results for including this category from being materialised\u2014only \u201csafe\u201d categories may be materialised. This should be given as a constraint to the pre-aggregation system that chooses which levels of aggregation to materialise.","We note that the algorithm does not introduce more levels in the hierarchy, only more categories, and that the number of \u201csafe\u201d categories in the result is the same as the number of original categories. This means that the complexity of the task of selecting the optimal aggregation levels to materialise is unaffected by the algorithm.","The result of running the algorithm on the Diagnosis dimension is seen in FIG. . Because of the non-strictness in the mapping from Low-level Diagnosis to Diagnosis Family, and from Diagnosis Family to Diagnosis Group, two new category types and the corresponding categories are introduced. The third picture indicates the argument to the algorithm; and, in addition, its dotted lines indicate the links deleted by the algorithm. The fourth picture gives the result of applying the algorithm; here, the bold-face values and thick lines indicate the values and links inserted by the algorithm.","In the first call of the algorithm the three Low-level Diagnosis values\u2014\u201c(low-level) Lung cancer\u201d (L14); \u201cInsulin dependent diabetes during pregnancy\u201d (5); and \u201cNon insulin dependent diabetes during pregnancy\u201d (6)\u2014are linked to the three new fused values\u2014\u201c(low-level) Lung cancer\u201d (14); \u201cDiabetes during pregnancy, Insulin dependent diabetes\u201d (4, 9); and \u201cDiabetes during pregnancy. Non insulin dependent diabetes\u201d (4, 10)\u2014and these are in turn linked to \u201cLung Cancer\u201d (14); \u201cDiabetes during pregnancy\u201d (4); \u201cInsulin dependent diabetes\u201d (9); and \u201cNon insulin dependent diabetes\u201d (10). The these latter four values in the Diagnosis Family category are un-linked from their parents, as the Diagnosis Family category is \u201cunsafe.\u201d","When called recursively on the Set-of Diagnosis Family category, the algorithm creates the new fused values \u201cCancer\u201d (13) and \u201cDiabetes, Other pregnancy related diseases\u201d (11, 12) in the Set-of Diagnosis Group category. These new values are linked to the values \u201cCancer\u201d (13). \u201cDiabetes\u201d (11), and \u201cOther pregnancy related diseases\u201d (12) in the Diagnosis Group category, and to the T value; and the values in the Diagnosis Group category are un-linked from their parents. Note the Importance of having a T value: the values not linked to T are exactly the unsafe values, for which aggregate results should not be re-used.","The algorithm assumes that all paths in the dimension hierarchy have equal length, i.e., all direct links are from children to their immediate parents. This is ensured by the MakeCovering and MakeOnto algorithms. In the algorithm below, C is a child category, P is a parent category, G is a grandparent category, N is the new category introduced to hold the \u201cfused\u201d values, and  denotes natural join.","The algorithm takes a category C (initially the \u22a5 category) as input. I then goes through the set of immediate parent categories P of C (line (2)). Line (4) tests if there is non-strictness in the mapping from C to P and if P has any parents (4). If this test fails, there is no problem as aggregate results for P can either be safely re-used or are guaranteed not be re-used; and the algorithm in then invoked recursively, in line (20).","It the test succeeds, the algorithm creates a new fused category. First, a new, empty category N with domain is created in line (6). The values inserted into this category represent sets of values of P. For example, the value \u201c1, 2\u201d represents the set consisting of precisely 1, 2. Values in C are then linked to to new, fused values, representing their particular combination of parents in P (7). The new values are constructed using a Fuse function, that creates a distinct value for each combination of P values and stores the corresponding P values along with it.","The resulting links are used in line (8) to insert the fused values into their category N, and an \u201cUnfuse\u201d function, mapping fused values from N into the corresponding P values, is used in line (9) to map the values in N to those in P. In line (10), N is included in, and P is excluded from, the sets of predecessors of C. The set of predecessors of N is set to P in line (11), meaning that the new category N resides in-between C and P in the hierarchy.",{"@attributes":{"id":"p-0128","num":"0171"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2002(1)","procedure MakeStrict (C)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2002(2)",{},"for each P \u03b5 Pred(C) do"]},{"entry":["\u2002(3)",{},"begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2002(4)",{},"if(\u2203e\u03b5 C(\u2203e,e\u03b5 P (e\u2266 e{circumflex over (\u2009)} e\u2266 e{circumflex over (\u2009)} e\u2260 e))}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{circumflex over (\u2009)} Pred(P) \u2260 0 then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2002(5)",{},"begin"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2002(6)",{},"N \u2190 CreateCategory(2)"]},{"entry":["\u2002(7)",{},"R\u2190 {(e, Fuse({e| (e, e) \u03b5 R}))}"]},{"entry":["\u2002(8)",{},"N \u2190 II(R)"]},{"entry":["\u2002(9)",{},"R\u2190 {(e, e) | e\u03b5 N {circumflex over (\u2009)} e\u03b5 Unfuse(e)}"]},{"entry":["(10)",{},"Pred(C) \u2190 Pred(C) \u222a {N} \\ {P}"]},{"entry":["(11)",{},"Pred(N) \u2190 {P}"]},{"entry":["(12)",{},"for each G \u03b5 Pred(P) do"]},{"entry":["(13)",{},"begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(14)",{},"R\u2190 II(R|X| R)"]},{"entry":["(15)",{},"Pred(N) \u2190 Pred(N) \u222a {G}"]},{"entry":["(16)",{},"Pred(P) \u2190 Pred(P) \\ {G}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(17)",{},"end"]},{"entry":["(18)",{},"MakeStrict(N)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(19)",{},"end"]},{"entry":["(20)",{},"else MakeStrict(P)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["(21)",{},"end"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(22)","end"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"For each grandparent category G, the algorithm links values in N to values in G, in line (14), includes G in the predecessors of N, in line (15), and excludes G from the predecessors of P, in line (16), thereby also deleting the links from P to G from the hierarchy. The exclusion of the G categories from the predecessors of P means that aggregate results for P will not be re-used to compute results for the G categories.","In the end, the algorithm is called recursively on the new category, N. Note that the test for Pred(P)\u2260\u03b8 in line (4) ensures that the mapping from N to P will not be altered, as P now has no predecessors.","Following the reasoning in the previous sections, we find that the overall big-o complexity is O(pnk log n log k), where p is the number of immediate parent and children categories in the dimension type lattice, n is the size of the largest mapping in the hierarchy, and k is the maximum number of values fused together. For most realistic scenarios, p and k are small constants, yielding a low O(n log n) complexity for the algorithm.","The MakeStrict algorithm constructs a new category N and insert fused values in N to achieve summarisability for the mapping from N to P, and from N to G. The algorithm only inserts the fused values for the combinations that are actually present in the mapping from C to P. This means that the cost of materialising results for N is never higher than the cost of materialising results for C. This is a worst-case scenario, for the most common cases the cost of materialising results for N will be be close to the cost of materialising results for P. However, without the introduction of N, we would have to materialise results not only for P, but also for G and all higher-level categories. Thus, the potential savings in materialisation costs are very high indeed.","Considering correctness, the mappings in the hierarchy should be strict upon termination, and the algorithm should only make transformations that are semantically correct. More specifically, it is acceptable that some mappings be non-strict, namely the ones from the new, fused categories to the unsafe parent categories. This is so because unsafe categories do not have predecessors in the resulting hierarchy, meaning that aggregate results for these categories will not be re-used.","The correctness follows from Theorems 5 and 6, below. When evaluating queries we get the same result for original values as when evaluating on the old hierarchy. The values that are deleted by the algorithm were not linked to any facts, meaning that these values did not contribute to the results in the original hierarchy. As all the new values are inserted into new categories that are unknown to the user, the aggregate result obtained will be the same for the original and transformed hierarchy. Thus, we do not need to modify the original query.","Theorem 5 Let D\u2032 be the dimension resulting from applying algorithm MakeStrict on dimension D. Then the following hold: Algorithm MakeStrict terminates and the hierarchy for the dimension D\u2033, obtained by removing unsafe categories from D\u2032, is strict.","Proof: By induction in the height of the dimension lattice. Base: The height is 0, making the statement trivially true. Induction Step: Assuming that the statement is true for lattices of height n, lattices of height n+1 are considered. All steps in the algorithm terminate, and the algorithm is called recursively on either P (in the strict case) or N (in the non-strict case), both of which are the root of a lattice of height n, thus guaranteeing termination.","For the strictness property, there are three cases. If the mapping from C to P is already strict, this mapping is not changed, and by the induction hypothesis, the statement holds for the recursive call on P. If the mapping from C to P is non-strict, but P does not have any parents, strictness is ensured, as P is excluded from D\u2033. If the mapping is non-strict and P has parents, the resulting mapping from C to N is strict. By the induction hypothesis, the statement holds true for the recursive call on N, as the introduction of N has not increased the height of the lattice.","Theorem 6 Given dimensions D and D\u2032 such that D\u2032 is the result of applying algorithm MakeStrict to D, an aggregate obtained using D\u2032 is the same as that obtained using D.","Proof: Follows from Lemma 2, as all facts are mapped to values in the I category, which is a safe category. Thus, there will be a path from a fact f to an original dimension value e iff there was one in the original hierarchy, meaning that aggregate results computed using the original and the new hierarchy will be same.\n\nLemma 2 For the dimension D\u2032=(C\u2032, \u2266\u2032) resulting from applying algorithm MakeStrict to dimension D=(C, \u2266), the following holds. \u2200e,e\u03b5D(e\u03b5C\u039bSafe(C)\u039be\u2266\u2032e e\u2266e) (there is a path between an original dimension value in a safe category and any other original dimension value in the new dimension hierarchy iff there was a path between them in the original hierarchy).\n\nProof: By induction in the height of the dimension lattice. Base: The height of the lattice is 0, making the statement trivially true. Induction Step: If either the mapping from C to P is strict, or P does not have any parents, the algorithm does not change the mappings, and by the indiction hypothesis, the statement is true for the recursive call on P. Otherwise, we observe that the creation of fused values in N, and the linking of C, P, and G values to these, only links exactly the values in C and P, or C and G, that were linked before. Because P is not safe, the links from P to G may be deleted. By the induction hypothesis, the statement is true for the recursive call on N.\n","In the method described above, both the original and the new categories are kept in the same hierarchy. An alternative would be to keep the \u201cunsafe\u201d categories and the mappings to them in a separate hierarchy, so that only \u201csafe\u201d categories are kept in the main hierarchy.","Fact-Dimension Transformation Techniques","This section explains how the set of algorithms from the section \u201cDimension Transformation Techniques\u201d may also be applied to the relationships between facts and dimensions, thus providing a basis for enabling practical pre-aggregation on concrete MOs that include fact data.","The basic idea is to view the set of facts F as the bottom granularity in the lattice. The input to the algorithms then consists of the facts, F, the Rtables, describing the mappings from facts to dimension values, and the C and Rtables, describing the dimension categories and the mappings between them.","Only the covering and strictness properties are considered because for the fact-dimension relationships, a mapping between facts and dimension values that is into means that not all dimension values in the bottom category have associated facts, which does not affect summarisability. As before, we first apply the MakeCovering algorithm, then the MakeStrict algorithm.","The computational complexity of the algorithms will now be dominated by the size, n, of the mapping between facts and dimension values, i.e., the complexity will be O(n log n) if we assume the height of the lattice and the maximum number of values fused together to be small constants. This means that the algorithms can be applied to even very large databases.","Mixed Granularity Mappings","The first case to consider is the one where some of the mappings are non-covering w.r.t. the facts, meaning that not all facts can be reached through these mappings and thus resulting in these facts not being accounted for in aggregate computations. This occurs when some facts are mapped directly to dimension values in categories higher than the \u22a5 category, i.e., the facts are mapped to values of mixed granularities.","We use the MakeCovering algorithm to make the mappings covering, initially calling it on F, which is now the bottom of the lattice. The algorithm makes the mappings covering w.r.t. the facts by inserting new marked values, representing the parent values, in the intermediate categories, and by linking the facts to the new values instead of the parent values. As in the section \u201cNon-Covering Hierarchies,\u201d the marked values keep information about their original values, so that when new fact-dimension mappings are added, the links that are supposed to go directly to the original parent values now instead can be set to go to the marked value in the \u22a5 category.","In the case study, the mapping between Patients and Diagnoses is of mixed granularity: \u201cJohn Doe\u201d (1) and \u201cJane Doe\u201d are both mapped to the Diagnosis Family, \u201cInsulin dependent diabetes\u201d (9), \u201cJane Doe\u201d is additionally mapped to the Low-level Diagnosis, \u201cInsulin dependent diabetes during pregnancy\u201d (5), and \u201cJim Doe\u201d is mapped to \u201cDiabetes\u201d (11), a Diagnosis Group.","In the first call of the algorithm, two new Low-level Diagnoses are inserted \u201cL9,\u201d representing \u201cInsulin dependent diabetes,\u201d and \u201cL11,\u201d representing \u201cDiabetes\u201d; and the facts are mapped to these instead of the original values. In the recursive call on Low-level Diagnosis, an \u201cF11\u201d value representing \u201cDiabetes\u201d at the Diagnosis Family level is inserted between \u201cDiabetes\u201d and value \u201cL11.\u201d","The transformations are illustrated in , where dotted lines indicate links that are deleted by the algorithm and bold-face value and thick lines indicate dimension values and links inserted by the algorithm.","Many-To-Many Relationships","The second case occurs when relationships between facts and dimension values are many-to-many. This means that the hierarchy, with the facts as the bottom category, is non-strict, leading to possible double-counting of facts. It is enough to make the hierarchy partly strict, as described in the section \u201cNon-Strict Hierarchies.\u201d The MakeStrict algorithm is initially called on F, which is now the bottom of the hierarchy lattice. Because the MakeCovering algorithm has already been applied, all paths from facts to the T value have equal length, as required by the MakeStrict algorithm.","Some dimension values have no facts mapped to them, leading to an interesting side effect of the algorithm. When the algorithm fuses values and places the fused values in-between the original values, it also deletes the child-to-parent and parent-to-grandparent links. The fact-less dimension values are then left disconnected from the rest of the hierarchy, with no links to other values.","These fact-less dimension values do not contribute to any aggregate computations and are thus superfluous. To minimise the dimensions, an \u201cDelete-unconnected\u201d algorithm that deletes the fact-less dimension values by traversing the hierarchy starting at the facts is invoked in a postprocessing step. For a hierarchy of height k, this can be done in time O(kn log n), where n is the size of the mapping between facts and dimensions. Thus, the overall computational complexity is not altered.","The relationship between patients and diagnoses is many-to-many. In Example 9, the MO was transformed so that all mappings were covering, as seen in , algorithm MakeStrict is applied to this MO. The final result of the application of the algorithm is seen in . Values in italics e.g. L, and dotted lines indicate deleted values and links. Bold-face values and thick lines denote values and links inserted by the algorithm.","Three new categories are introduced: \u201cSet-of Low-level Diagnosis\u201d \u201cSet-of Diagnosis Family,\u201d and \u201cSet-of Diagnosis Group:\u201d as non-strictness occurs at all levels. Fused values are inserted into these fused categories. For example, values \u201c(low-level) Lung Cancer\u201d (L), \u201cInsulin dependent diabetes during pregnancy, (low-level) Insulin dependent diabetes\u201d (, L), and \u201c(low-level) Insulin dependent diabetes\u201d (L) are inserted into the \u201cSet-of Low-level Diagnosis\u201d category; and the original values are linked to the new values.","Values \u201c(low-level) Lung cancer\u201d (L), \u201cLung cancer\u201d (14), \u201cCancer\u201d (13), \u201cNon-insulin dependent diabetes during pregnancy\u201d (6), and \u201cNon insulin dependent diabetes\u201d (10) do not characterise any facts and are deleted by \u201cDelete-unconnected.\u201d","Architectural Context","Overview","The overall idea presented in this paper is to take un-normalised MOs and transform them into normalised MOs that are well supported by the practical pre-aggregation techniques available in current OLAP systems. Queries are then evaluated on the transformed MOs. However, we still want the users to see only the original MOs, as they reflect the users' understanding of the domain. This prompts the need for means of handling both the original and the transformed MOs. This section explores this coexistence.","A current trend in commercial OLAP technology is the separation of the front-end presentation layer from the back-end database server. Modern OLAP applications consist of an OLAP client that handles the user interface and an OLAP server that manages the data and processes queries. The client communicates with the server using a standardised application programming interface (API), e.g., Microsoft's OLE DB for OLAP [17] or the OLAP Council's MDAPI [20]. The architecture of such a system is given to the left in .","This separation of client and server facilitates our desire to have the user see the original MO while queries are evaluated against the transformed MO. Studies have shown that queries on a data warehouse consist of 80% navigational queries that explore the dimension hierarchies and 20% aggregation queries that summarise the data at various levels of detail [14]. Examples of navigational and aggregation queries are \u201cShow me the Low-Level Diagnoses contained in the Insulin-Dependent Diabetes Diagnosis Family\u201d and \u201cShow me the count of patients, grouped by Diagnosis Family,\u201d respectively. The navigational queries must be performed on the original MO, while the aggregation queries must be performed on the transformed MO. This is achieved by introducing an extra \u201cQuery Handler\u201d component between the client and the server. The OLAP client sends a query to the query handler, the primary task of which is to determine whether the query is a navigational query (internal to a dimension) or an aggregation query (involving the facts). Navigational queries are passed to one OLAP server that handles the original (navigational) data, while aggregation queries are passed to another OLAP server that manages the transformed (aggregation) data. This extended system architecture is seen to the right in .","The OLAP server for navigation data needs to support dimension hierarchies which have non-summarisable properties, a requirement not yet supported by many commercial systems today. However, relational OLAP systems using snow-fake schemas [14] are able to support this type of hierarchies, as are some other OLAP systems, e.g., Hyperion (Arbor) Ess-base [12]. If the OLAP system available does not have sufficiently flexible hierarchy support, one solution is to build a special-purpose OLAP server that conforms to the given API. This task is not as daunting as it may seem at first because only navigational queries need to be supported, meaning that multidimensional queries can be translated into simple SOL \u201clookup\u201d queries.","We note that the only data needed to answer navigational queries is the hierarchy definitions. Thus, we only need to store the fact data (facts and fact-dimension relations, in our model) once, in the aggregational data, meaning that the overall storage requirement is only slightly larger than storing just the aggregational data. Navigational queries are evaluated on the original hierarchy definitions and do not need to be re-written by the query handler.","As described in the section \u201cDimension Transformation Techniques,\u201d aggregation queries need to be rewritten slightly by adding an extra HAVING clause condition to exclude results for the new values inserted by the transformation algorithms. This can easily be done automatically by the query handler, giving total transparency for the user. Even though the added HAVING clause conditions are only necessary for the covering and onto transformations, they can also be applied to hierarchies transformed to achieve strictness; this has no effect, but simplifies the query rewriting. The new values can also be filtered out using a modified WHERE clause, by performing an inner join with a table containing only the original values, or by using nested SELECT statements as described in the next section.","Concrete Implementation","We now show how the abstract architecture described above can be implemented using standard relational database technology.","The transparency is achieved by working with two versions of each user-specified hierarchy and by using a query rewrite mechanism. This is described in detail later in this section. The overall system architecture is seen in .",{"@attributes":{"id":"p-0161","num":"0204"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"329pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DDiagnosis Dimension Table"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DiagID","Lowlevel","Family","Group"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["5","Insulin dependent diabetes during pregnancy","Diabetes during pregnancy","Diabetes"]},{"entry":["5","Insulin dependent diabetes during pregnancy","Diabetes during pregnancy","Pregnancy related"]},{"entry":["5","Insulin dependent diabetes during pregnancy","Insulin dependent diabetes","Diabetes"]},{"entry":["6","Non insulin dependent diabetes during pregnancy","Diabetes during pregnancy","Diabetes"]},{"entry":["6","Non insulin dependent diabetes during pregnancy","Diabetes during pregnancy","Pregnancy related"]},{"entry":["6","Non insulin dependent diabetes during pregnancy","Non insulin dependent diabetes","Diabetes"]},{"entry":["100","!Lowlevel!fLung Cancer","Lung cancer","Cancer"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The ROLAP client tool, in this case the ROLAP tool Synchrony, which originated from Kimball's Startracker tool [14], makes SQL requests to the ROLAP database, in this case the Oracle8 RDBMS, using the ODBC standard. We have implemented a special, query-transforming ODBC driver (QTOD) that, based on case-specific metadata, transforms the SQL requests into requests that hide the transformations from the users, returning the query results that the user would expect based on the original hierarchies. A transformed request is submitted to the OLAP DB using an RDBMS-specific ODBC driver. The QTOD component is common to all RDBMSs, so Oracle8 may be replaced by another RDBMS such as IBM DB2, Informix, or MS SQL Server. Another ROLAP tool may also be used, making the solution quite general and flexible.","We have chosen to base the prototype on an RDBMS (Oracle8) since RDBMSs are the most commonly used platform for Data Warehouse and OLAP applications. Additionally, the major RDBMSs now, like dedicated multidimensional DBMSes (MDDBs), use pre-aggregated data for faster query responses [30]. However, the approach could also be implemented using multidimensional technology, e.g., based on the Microsoft OLE DB for OLAP standard [17].","The transformation algorithms are implemented in Oracle's PUSOL programming language. The transformations are relatively fast, taking at most a few minutes, even for large dimensions. Once the dimension hierarchies have been transformed, the QTOD transforms queries and results between the original and transformed hierarchies. The OTOD is a thin layer and adds very little overhead to queries. It is implemented using GNU Flex++\/Bison++ scanner\/parser generators and the MS Visual C++ compiler.","The two types of queries, navigation queries and aggregation queries, are treated differently to give the user the illusion that the dimension hierarchies have their original form.","The multidimensional data is captured in a star schema [14]. The dimension table for the Diagnosis dimension is given in Table 2, which has one column for the low-level diagnosis ID in addition to columns for the textual descriptions of low-level diagnoses, diagnosis families, and diagnosis groups.","The hierarchy captured in the table is partially normalised, i.e., placeholder values have been introduced to balance the hierarchy (but it remains non-strict). Specifically, the \u201c!Lowlevel!Lung Cancer\u201d placeholder value has been inserted into the Low-level Diagnosis level. We prefix such values with a \u201c!\u201d and their level to indicate that they are inserted by the transformation process. Note the multiple occurrences of lower-level values caused by the non-strictness of the hierarchy. This is the table that will be used for user navigation in the hierarchy. Its name is prefixed with a \u201cD\u201d to distinguish it from another \u201cDiagnosis\u201d dimension table (described below), to be used for aggregation queries.","We now describe how to achieve transformation transparency for navigational queries. The query below retrieves all low-level diagnosis names.","SELECT DISTINCT Lowlevel","FROM Diagnosis","Navigational queries issued by ROLAP tools have exactly this format. The query is transformed by the QTOD into the query seen next, which operates against the table DDiagnosis. The transformed query returns the result seen in Table 3.","SELECT DISTINCT Lowlevel","FROM DDiagnosis","WHERE Lowlevel NOT LIKE \u2018!%\u2019",{"@attributes":{"id":"p-0170","num":"0213"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Navigational Query Result"},{"entry":"Lowlevel"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Insulin dependent diabetes during pregnancy"},{"entry":"Non insulin dependent diabetes during pregnancy"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Due to the use of DISTINCT as a quantifier, duplicates are not returned. The NOT LIKE predicate removes the placeholder values inserted into the hierarchy to balance it, which in this case is the value \u201c!Lowlevel!Lung Cancer.\u201d As desired, the result is unaffected by the translations.","For aggregation queries, it is also possible to achieve transformation transparency, although this is more difficult. For dimensions with non-strictness, a special dimension table is introduced that holds only the part of the normalised hierarchy that does not contain non-strictness. In the normalised hierarchy to the right in the left part of , this part is the Low-level Diagnosis category and the two special categories introduced by the normalisation process to hold sets of diagnosis families and sets of diagnosis groups, respectively. This part of the hierarchy is implemented in the Diagnosis dimension table seen in Table 4.",{"@attributes":{"id":"p-0173","num":"0216"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Dimension and Group Tables for Aggregation"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DiagID","Lowlevel","Family","Group"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["1000020","!Low-level Diagnosis!Lung cancer","14","13"]},{"entry":["5","Insulin dependent diabetes during","4, 9\u2002","11, 12"]},{"entry":[{},"pregnancy"]},{"entry":["6","Non insulin dependent diabetes during","4, 10","11, 12"]},{"entry":[{},"pregnancy"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Diagnosis"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Group","SGroup"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Cancer","13"]},{"entry":[{},"Diabetes","11, 12"]},{"entry":[{},"Pregnancy Related","11, 12"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"S Group"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The \u201cLowlevel\u201d column contains the normal textual diagnosis description, whereas the special \u201cFamily\u201d and \u201cGroup\u201d columns contain comma-separated ordered lists of the IDs of the sets of values that are represented by the column values. For example, value \u201c4, 9\u201d represents the set {4, 9}.","We need to capture the remaining part of the hierarchy, which consists of non-strict mappings from a \u201cset-of-X\u201d category to the \u201cX\u201d category, e.g., the mapping of the \u201cset-of-Diagnosis Group\u201d category to the \u201cDiagnosis Group\u201d category to the right in , which maps {13} to 13 (Cancer) and {11, 12} to 11 (Diabetes) and 12 (Pregnancy Related). This is done by introducing a special table for each such mapping, named by the category prefixed with an \u201cS\u201d (for Set-of). For example, for the Diagnosis Group category, table \u201cSGroup\u201d in Table 4 maps sets of diagnosis groups to the individual diagnosis groups in the sets. The \u201cGroup\u201d column represents the diagnosis group, while the \u201cSGroup\u201d column represents the associated set of diagnosis groups.","With these tables available, it is possible to obtain transformation transparency for aggregation queries. A ROLAP aggregation query has the format of the query below that computes the number of patients per diagnosis group.","SELECT Diagnosis.Group, SUM (Patient.Count)","FROM Diagnosis, Patient","WHERE Diagnosis.DiagID=Patient.DiagID","GROUP BY Diagnosis.Group","This is transformed into the more complex query given next.",{"@attributes":{"id":"p-0177","num":"0000"},"ul":{"@attributes":{"id":"ul0034","list-style":"none"},"li":["SELECT SGroup.Group, SUM(QQQQQQQ.Count)","FROM Sgroup,\n    \n    ","WHERE QQQQQQQ.Group=SGroup.SGroup AND SGroup.SGroup NOTUKE \u201c!%\u201d","GROUP BY SGroup-Sgroup"]}},"The transformed aggregation query has two parts. The nested table expression computes the number of patents per set of diagnosis group, making this available via correlation name QQQQQQQ. This part of the hierarchy is a balanced tree, so the RDBMS can safely use pre-aggregated data for optimising the query performance. The result of the nested table expression is used in the outer query, which aggregates the last part of the way up to the diagnosis groups using the \u201cSGroup\u201d table. The outer query also filters out any placeholder values inserted by the normalisation process (prefixed with a \u201c!\u201d). As a result, the client OLAP tool will retrieve the expected result.","Good query performance without the use of excessive storage for pre-aggregated data is obtained by using practical pre-aggregation for the \u201cnice\u201d part of the hierarchy captured in the \u201cDiagnosis\u201d dimension table. The query transformation exemplified here can be performed for all ROLAP aggregation queries, making the solution quite general.","Incremental Computation","When dimension hierarchies or fact data are updated, the transformed hierarchies must be updated correspondingly. One solution is to recompute the hierarchies using the new data. This straightforward solution is attractive when updating small dimension hierarchies that only change infrequently, or when large bulks of updates are processed. However, for massive hierarchies and frequent updates, and for updates of small parts of the hierarchies in general, it is desirable if the algorithms need only consider the changed parts of data, which will only be a small fraction of the total data volume. This section briefly describes how to incrementalise the algorithms.","In addition to modifying the transformed hierarchies, it is also necessary to update the actual pre-aggregated data when the underlying base data is modified. The modified hierarchies resulting from the algorithms given in this section differ only locally from the argument hierarchies. This means that the cost of updating the pre-aggregated data will not be greatly affected by the hierarchy transformations.","In the incremental algorithms, updates are modeled as deletions followed by insertions, so we consider only the latter two modification operations. We use prefix \u0394to denote inserted values, \u0394to denote deleted values, and \u0394 to denote all modifications. For example, \u0394C denotes the values inserted into C. The category and links tables in the algorithms refer to the states after modifications; and when a hierarchy value is deleted, all links to that value are also assumed to be deleted in the same set of modifications.","Covering Hierarchies","Modifications may render covering hierarchies non-covering in several ways. The the left-most table in Table 5, named \u201cCovering\u201d and discussed next, indicates whether an insertion (\u201cInsert\u201d) or a deletion (\u201cDelete\u201d) on the different parts of the input to MakeCovering may render the modified hierarchy non-covering.",{"@attributes":{"id":"p-0184","num":"0235"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Effects of Insertions and Deletions on the Covering, Onto, and"},{"entry":"Strictness Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Insert","Delete","Insert","Delete","Insert","Delete"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"6","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"9"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"8","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"9","colwidth":"28pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["C","yes","no","C","no","yes","C","no","yes"]},{"entry":["P","no","yes","P","yes","no","P","no","yes"]},{"entry":["H","no","yes","R","no","yes","G","no","yes"]},{"entry":["R","yes","no",{},{},{},"R","yes","yes"]},{"entry":["R","no","yes",{},{},{},"R","yes","yes"]},{"entry":["R","no","yes"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Covering","Onto","Strict"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Problems may arise if links are inserted into Rthat are not covered by insertions into Rand R, or if links are deleted in Ror R, but the corresponding C-to-H links are not deleted in R. If values are deleted in P or H, their links will be deleted too, which is handled by the case above. Values cannot be inserted into C without any links, as all values in the original hierarchy must at least be linked to the T value.","The incremental version of MakeCovering algorithm starts by finding (in line (6)) the links L from C to H that are not covered by the links from C to P and P to H. These links are used as the base for the rest of the transformation. Thus, line (6) of the algorithm becomes the following expression.\n\n\u222a\u03a0(\u0394 R)\u222a\u03a0( \u0394)\\\u03a0(\u0394 \u0394)\\\u0394\n\nOnto Hierarchies\n\nThe effects on the onto property of insertions and deletions are outlined in the middle table in Table 5. Insertion of values into P, deletion of values in C, and deletion of links in Rmay cause the hierarchy to become non-onto. The incremental version of the MakeOnto algorithm thus starts by finding (in line (4)) the \u201cchildless\u201d values N from P with no children in C. As a result, line (4) of the algorithm becomes the following expression.\n\n(\u0394)\\\u03a0(\u0394)\\\u03a0(\u0394)\n\nStrict Hierarchies\n\nThe case of maintaining the strictness property of hierarchies is more complicated because a new category N is introduced by the algorithm. We assume that all new categories have already been created before the incremental algorithm is used, i.e., if non-strictness is introduced in new parts of the hierarchy, we have to recompute the transformed hierarchy. The introduction of non-strictness requires major restructuring of both the hierarchy and the pre-aggregated data, so this is reasonable.\n","An overview of the effect on strictness of insertions and deletions in the input to algorithm MakeStrict is given in the right-most table in Table 5. If links are inserted into, or deleted from, Ror R, the links to N for the affected C, P, and G values must be recomputed.","Insertions into, or deletion from, C, P, or G will be accompanied by corresponding link insertions and deletions, so they are handled by the above case. The incremental MakeStrict, given below, works by finding the affected C, P, and G values, then recomputes their links to N and deletes the old links, and finally inserting the new links. As before, it is followed by a step that deletes the disconnected parts of the hierarchy.",{"@attributes":{"id":"p-0189","num":"0240"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2002(1)","procedure IncrementalMakeStrict(C)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2002(2)","for each P \u2208 Pred(C) such that Pred(P) \u2260 0 do"]},{"entry":["\u2002(3)","begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2002(4)","dC \u2190 II(\u0394R)"]},{"entry":["\u2002(5)","dR\u2190 {(c, Fuse({p | (c,p) \u2208 dC  \u2009R})}"]},{"entry":["\u2002(6)","dN \u2190 II(d)"]},{"entry":["\u2002(7)","N \u2190 N \u222a dN"]},{"entry":["\u2002(8)","R\u2190 R\\ {(c,n) | c \u2208 dC} \u222a dR"]},{"entry":["\u2002(9)","dP \u2190 II(\u0394R)"]},{"entry":["(10)","dR\u2190 {(n,p) | n \u2208 \u2002dN \u039b p \u2208 dP \u2229 UnFuse(n)}"]},{"entry":["(11)","R\u2190 R\\ {(n,p) | p \u2208 dP} \u222a dR"]},{"entry":["(12)","for each G \u2208 Pred(P) do"]},{"entry":["(13)","begin"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(14)","dG \u2190 II(\u0394R\u222a (dP  \u2009R))"]},{"entry":["(15)","R\u2190 R"]},{"entry":[{},"{(n,g) | g \u2208 dG} \u222a II(R \u2009R \u2009dG)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(16)","end"]},{"entry":["(17)","IncrementalMakeStrict(N)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["(18)","end"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(19)","end"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0190","num":"0000"},"ul":{"@attributes":{"id":"ul0037","list-style":"none"},"li":["[1] E. Baralis, S. Paraboschi, and E. Teniente. Materialized View Selection in a Multidimensional Database. In -, pp. 156\u2013165, 1997.","[2] E. F Codd. Providing OLAP (on-line analytical processing) to user-analysts: An IT mandate. 1993.","[3] S. Dar, H. V. Jagadish, A. Y. Levy, and D. Srivastava. Answering SQL Queries Using Views. In -, pp. 318\u2013329, 1996.","[4] R M. Deshpande, J. F. Naughton, K. Ramasamy, A. Shukla, K. Tufte, and Y. Zhao. Cubing Algorithms, Storage Estimation, and Storage and Processing Alternatives for OLAP. 20(1):3\u201311, 1997.","[5] C. E. Dyreson. Information Retrieval from an Incomplete Data Cube. In -, pp. 532\u2013543, 1996.","[6] J. Gray, S. Chaudhuri, A. Bosworth, A. Layman, D. Reichart, M. Venkatrao, F. Pellow, and H. Pirahesh. Data Cube: A Relational Aggregation Operator Generalizing Group-By, Cross-Tab and Sub-Totals. 1 (1):29\u201354, 1997.","[7] A. Gupta, V. Harinarayan, and D. Quass. Aggregate Query Processing in Data Warehousing Environments. In -, pp. 358\u2013369, 1995.","[8] H. Gupta, V. Harinarayan, A. Rajaraman, and J. Ullman. Index Selection for OLAP. In 208\u2013219, 1997.","[9] H. Gupta. Selection of Views to Materialize in a Data Warehouse. In , pp. 98\u2013112, 1997.","[10] H. Gupta and I. S. Mumick. Selection of Views to Materialize Under a Maintenance-Time Constraint. In , pp. 453\u2013470, 1999.","[11] V. Harinarayan, A. Rajaraman, and J. D. Ullman. Implementing Data Cubes Efficiently. In , pp. 205\u2013216, 1996.","[12] Hyperion Corporation. Hyperion Essbase OLAP Server. URL: <www.hyperion. com\/downloads\/essbaseolap.pdf>. Current as of Feb. 17, 1999.","[13] Informix Corporation. Data Warehouse Administrator's Guide: MetaCube RO-LAP Option for Informix Dynamic Server. URL: <www.informix.com\/answers\/english\/pdf_docs\/metacube\/4189.pdf>. Current as of Feb. 15, 1999.","[14] R. Kimball. . Wiley Computer Publishing, 1996.","[15] R. Kimball. Data Warehouse Architect: Help with Multi-Valued Dimension. 11(9), 1998.","[16] H. Lenz and A. Shoshani. Summarizability in OLAP and Statistical Data Bases. In , pp. 39\u201348, 1997.","[17] Microsoft Corporation. OLE DB for OLAP Version 1.0 Specification. Microsoft Technical Document, 1998.","[18] Microsoft Corporation. OLAP Services White Paper. URL: <www.microsoft.com\/sql\/70\/whpprs\/olapoverview.htm>. Current as of Feb. 9, 1999.","[19] I. S. Mumick, D. Quass, and B. S. Mumick. Maintenance of data cubes and summary tables in a warehouse. In , pp. 100\u2013111, 1997.","[20] The OLAP Council. 2.0. OLAP Council Technical Document, 1998.","[21] The OLAP Report. . URL: <www.olapreport.com\/Database-Explosion.htm>. Current as of Feb. 10, 1999.","[22] T. B. Pedersen and C. S. Jensen. Multidimensional Data Modeling for Complex Data. In 1999. Extended version available as TimeCenter Technical Report TR-37, URL: <www.cs.auc.dk\/TimeCenter>, 1998.","[23] T. B. Pedersen, C. S. Jensen, and C. E. Dyreson. Extending Practical Pre-Aggregation in On-Line Analytical Processing. In , pp. 663\u2013674, 1999. Extended version available as TR R-99\u20135004, Dept. of Comp. Sci. Aalborg University, <www.cs.auc.dk\/\u02dctbp\/articles\/R995004.ps>, 1999.","[24] D. Quass and J. Widom. On-Line Warehouse View Maintenance for Batch Updates. In , pp. 393\u2013404, 1997.","[25] M. Rafanelli and A. Shoshani. STORM: A Statistical Object Representation Model. In , pp. 14\u201329, 1990.","[26] A. Segev and J. L. Zhao. Selective View Materialization in Data Warehousing Systems. Working paper, URL: <ftp:\/\/segev.lbl.gov\/pub\/LBL_DB_PUBLICATIONS\/1997\/aggregdw.ps>. Current as of Feb. 9, 1999.","[27] A. Shukla, P. M. Deshpande, J. F. Naughton, and K. Ramasamy. Storage Estimation for Multidimensional Aggregates in the Presence of Hierarchies. In -, pp. 522\u2013531, 1996.","[28] D. Theodoratos and T. Sellis. Data Warehouse Configuration. In -, pp. 126\u2013135, 1997.","[29] J. Widom. Research Problems in Data Warehousing. In , pp. 25\u201330, 1995.","[30] R. Winter. Databases: Back in the OLAP game. 1 (4):60\u201364, 1998.","[31] World Health Organization. (ICD-10). Tenth Revision, 1992.","[32] J. Yang, K. Karlapalem, and Q. Li. Algorithms for materialized view design in a data warehousing environment. In -, pp. 136\u2013145, 1997."]}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF FIGURES","p":["The detailed description of the invention is accompanied by a set of figures of which",{"@attributes":{"id":"p-0044","num":"0087"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0045","num":"0088"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0046","num":"0089"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0047","num":"0090"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0048","num":"0091"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0049","num":"0092"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0050","num":"0093"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
