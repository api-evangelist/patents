---
title: System and method for controlling multiple computer peripheral devices using a generic driver
abstract: A method for controlling a peripheral hardware device connected to a computer system is disclosed, the computer system includes a first operating system, acting as the host operating system, running on a first processor platform, and a generic device driver operating on the combination of the first operating system and first processor platform. The method includes delivering the peripheral hardware device with an original peripheral hardware device driver file written for a second operating system or a second processor platform, handling, by the generic device driver, interfaces between the first operating system, the peripheral hardware device and a software application, all configured to interact with the original peripheral device driver file, and emulating, by the generic device driver, at least a part of the second operating system and the second processor that are required for the peripheral hardware device to operate on the first operating system and the first processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09329887&OS=09329887&RS=09329887
owner: HOB GMBH & CO. KG
number: 09329887
owner_city: Cadolzburg
owner_country: DE
publication_date: 20111019
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["A system and method for controlling multiple computer peripheral devices using a generic driver is described, specifically, a system and a method for a single generic peripheral device driver to emulate the flow of requests to and from the operating system and so control all connected peripheral devices. The present invention relates generally to digital communication between a computer system and peripheral devices and in particular to a method that allows the use of a single generic device driver to control multiple peripheral hardware devices.","Peripheral computer hardware such as printers, scanners, modems, etc, and their appropriate software are not integral parts of a computer or its operating system. As supplementary devices not integral to the system, they are not already programmed into the operating system, and so need their own specific code to allow them integrate into the system. These specific code packages are referred to as device drivers, and are delivered with the purchase of each new device. In many cases the operating system itself locates and downloads the appropriate device drivers so the users do not have to do this themselves\u2014these are known as plug and play systems, so called because you simply \u201cplug\u201d it into the system, which then locates the driver enabling the device to start to \u201cplay\u201d. This works because a large number of device drivers are bundled with the Operating System (\u201cOS\u201d) for the latest Windows OS versions in particular, and the feature for finding the driver needed automatically by searching online repositories is also included. This means that a user can simply connect a new device without having any driver, and the OS will manage to \u201cmake it run\u201d automatically without any user intervention.","Device drivers handle and control the interaction with the hardware platform and operating system with which they work. Usually one device driver can handle only a single operating system version and only a single hardware\/processor platform. Because of this limitation, whenever a device needs to be run either on a different operating system (or different version) or on a different hardware platform, a new device driver (or an update if available) is needed or the device will not run.","The great majority of device drivers are designed to work in kernel-mode, meaning that when a device driver crashes, it is very probable that the whole system will crash, generating a blue screen. Also, if malicious code is inserted within a driver and is executed once that driver has been installed, the malicious code can access all of the kernel and central processing unit (CPU) components because it is run in kernel mode. So should a driver containing a virus be installed, it is very likely to have disastrous and potentially fatal effects on the underlying platform.","To ensure that drivers installed on operating systems contain no defective, incompatible or malicious code, operating system vendors have introduced measures to control drivers that are installed on them. An example is the Microsoft\u00ae Windows\u00ae driver signing process. Microsoft\u00ae signs drivers that it deems to be 100% compatible with Microsoft\u00ae Windows\u00ae operating systems, and have no unsafe code. During installation, a device driver that is not signed is rejected. There are two problems with this approach. First, driver signing is expensive for hardware vendors. Second, hardware vendors must hand their drivers to the operating system's vendor for inspection. This can give rise to the feeling of unwanted interference by the operating system's vendor from the point of view of the hardware vendor.","In typical network environments, only users with administrator rights are allowed to install devices. This limitation is applied so that no user can install unsafe drivers that can influence the server and network experience of other users of the same server or network. As it is impossible to give administrator rights to every user for obvious security reasons, this limitation prevents users from installing their own personal peripheral devices without having to go through the administrator.","The present invention was inspired by the fact that peripheral hardware devices and the appropriate software are distributed with their own individual device drivers, which in most cases are written for a single operating system (or at most a very small number of operating systems). Yet today the list of possible devices that can be added to a modern computer system is virtually endless. Even the more basic systems set up in a user's home will probably have a number of peripheral devices added, such as printers, scanners, external hard disks, etc. Each of these devices needs a device driver. When this is expanded to a multiple user and server corporate network, the number of installed device drivers can be practically impossible to properly maintain and keep up to date. If there are frequent driver conflicts, this can seriously restrict the day to day operation of a large network.","To provide more depth as to how a solution to the above described problems can be applied, it is necessary to provide more of a context on the drivers and how they operate.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1","b":["110","100","120","140","102","105","100","170","140"]},"The host operating system () then communicates with the device driver () via system calls and kernel application programming interfaces (APIs) calls () and the driver model () to obtain the information needed to control the USB device (). Where required, function calls () are further placed to other drivers or kernel-level dynamically loaded files (.sys\/.dll) () for necessary data.","The response from the device driver () returns to the host operating system () and then back to the USB device () routed through the input\/output (I\/O) ports ().","Finally, a set of assembly instructions () specific to the processors for which it was developed that access and manipulate the underlying hardware resources, such as the processor's registers and memory, are sent from the device driver () to the host processor CPU (). The processor's instruction set allows a driver to manipulate its I\/O ports. However, in this conventional driver model, device drivers do not manipulate ports directly, as this is usually done by the underlying bus drivers.","The context of the device driver () can be defined by analyzing the entities with which it communicates and how this communication takes place. The first entities are the applications () controlling the device () (for simplicity only one application will be referred to in the text below). When a user accesses the application to impact certain features or functions of the device, it seems as if the application () is controlling the device (). However, the process is not that simple. When the user executes a function on the device, the application () forms a device request package () that contains information about the device, the data to send to the device and other relevant information. It sends this package () to the host operating system () on which it is currently running (e.g., Microsoft\u00ae Windows\u00ae) through a device Input\/Output (I\/O) Control function call that is part of the operating system's standard set of API calls. The APIs can be seen as the only way that applications can communicate with the operating system's kernel, and the only way for applications () to communicate with the CPU () resources and devices is by calling these APIs.","Once the application () sends this device request package () to the host operating system, it waits for a return value that indicates whether or not the request has been successful. Any operations performed by the kernel and any other components with which it communicates are abstracted from the application (). So from the point of view of the application, if the value returned by the device I\/O control indicates that the operation has been successful, it assumes that the attribute has been changed to the one requested. If the value indicates an unsuccessful operation, there are ways for the application () to get more information about what type of failure occurred. The host operating system () thus acts as an intermediary between the application () and the device driver (). The host operating system () presents the information that the application () inserted in the request package into a different standard package. This package then presents the information that the driver () needs to control the device (). This communication will be discussed in more detail later.","From the hardware point of view, there are instances in which a USB device () needs to communicate to the device driver () to notify the driver of an external event that has happened. As in the case of the communication between the application () and the driver () above, the host operating system () acts as intermediary between the device () and its driver (). The host operating system () enumerates events such as hardware interrupts () that can be generated by connected devices (). The USB controller () contains an enumeration of all USB devices () connected to it, and adds information indicating which USB device () generated the interrupt (i.e., the device's descriptor). The USB controller () then waits for the host operating system () to perform the appropriate action. So ultimately the device driver () is the component that controls the response actions that the device () must take.","Whenever a USB device () is connected, a similar procedure takes place when the USB controller () detects the new device (), in that it obtains information about the new device, enumerates it and then informs the operating system () about it. The reverse process happens when a USB device () is disconnected, and similar processes happen when a device () is powered on and off, set to or resumed from the sleep state.","The above scenario explains generally how hardware interrupts allow the communication from the devices to the host operating system. The reverse type of communication\u2014from the host operating system () to the USB devices ()\u2014is done through I\/O ports (). The host operating system () passes both a control instruction (i.e., the instruction for the device to execute a function) and data (the description of specific parameters necessary for the requested function) through I\/O ports (). I\/O ports () can also be used in the reverse direction (from the device to the host operating system) and data communication can also be handled by the host operating system through memory mapping. However, details about these functions are unnecessary to the understanding of the subject matter of this application. In summary, the host operating system () abstracts communication with the device driver () from the USB device () and USB controller (). This means that it does not matter which device driver () is handling a particular device () as long as the USB device () and USB controller () can communicate with the host operating system () in the standard way specified.","By looking at these two scenarios (communication to\/from the application and to\/from the device) from the device driver's point of view, one can appreciate more the abstractions offered by the operating system that allows device drivers to be built in a standardized way according to the operating system they run on and not specifically according to the device they control. Every operating system provides a driver model that simplifies driver implementation (such as the Microsoft\u00ae Windows\u00ae driver model, or WDM). The functionality of the driver is implemented within a series of dispatch routines and some other special functions. Thus, for example, there is a standard function (dispatch routine) that is called when the application calls the device I\/O control command, another standard function that is called when the device is connected, another when the operating system starts up, and so on. So from the point of view of the driver it does not make a difference if the source of the request is originating from an application, from the operating system itself, or from the hardware platform currently hosting the device.","Inside the implementation of these \u201cspecial\u201d functions, the device driver implements all of the functionality needed by the device depending on its features. However, the host operating system () provides a number of system calls or kernel-level APIs (). These are similar to the APIs used by the applications (as already described); however, unlike those used by the applications, they are only accessible at the kernel-level, as they manipulate kernel resources that are not available for applications. As a result, while the driver () is servicing a request coming from the host operating system (), it calls the host operating system () again to perform generic tasks. These tasks are mostly memory operations, such as the allocation and freeing of chunks of memory.","Apart from the kernel APIs (), drivers can also call functions from kernel level dynamically loaded libraries (), via function calls (). These libraries are not part of the kernel and can also be developed by third party developers. However, when the device driver () is loaded, the operating system () loads these libraries () inside the kernel so that their functions are available for the device driver () to call. These libraries () can even be drivers themselves. For example, most digital camera device drivers use a generic camera driver that provides general functionality for every camera.","The final line of communication happens between the device driver () and the host processor () itself. The driver's internal code is made up of a set of assembly instructions () that are specific to the processor for which it was developed. So, for example, if a device driver was developed to run on an Intel\u00aePentium processor, its internal code will be a set of Intel\u00ae x86 assembly instructions. These instructions access and manipulate the underlying hardware resources, such as the processor's registers and memory. It should be noted that the processor's instruction set allows a driver to manipulate its I\/O ports. However in the conventional driver model, device drivers do not manipulate ports directly, as this is usually done by the underlying bus drivers.","Due to the large number and variations of possible devices that can be connected to a computer system and the possible range of versions, platforms and systems with which they may be compatible, it is not possible to have dedicated device driver software for all possible devices contained within the operating system. The present invention solves this problem by providing one generic driver that handles all the interfaces involved in communication between the peripheral device and the system, therefore eliminating the need to have multiple device drivers installed for each version, platform and system in use, ensuring that while using the generic driver, the user is not putting the system's stability or security at risk in any way. If this happens, the generic driver either finds a way to obtain the same functionality without such breaches, limits its functionality, or stops the device.","The generic driver will detect whether any part of the functionality implemented within the device driver puts the underlying platform's security or stability at risk. If a security or stability risk is identified, then the action taken depends particularly on the type of stability or security risk identified. Possible actions that can be taken when such a breach is detected may include: 1) stopping the driver from performing the task that might cause the breach and showing a warning to the user (instead of allowing it to crash the whole system); or 2) taking alternative action that would allow the driver to continue performing the required task in a safe way. To do this, every type of breach would have to be analyzed individually, and the alternative action would have to be customized for every type of breach.","No research about individual cases causing these risks has yet been done, although a good idea can be obtained by looking at what Microsoft\u00ae is developing with Static Driver Verifier, Driver Verifier and Pre FAST discussed below. The main difference between these tools and the system shown here is that these tools are used by developers to help them produce better drivers\u2014i.e., having the least possible system security\/stability breaches. If a developer tests their driver and a security or stability breach is detected, then they can modify the driver code. The generic driver acts on drivers already distributed to users and hence their sources cannot be modified.","Other attempts have been made to address the situation where peripheral hardware devices should be able to run under an operating system for which no corresponding device driver is available. But these solutions are much more limited in scope than the present invention, and as such fall short of the capability of the generic driver solution that is disclosed here.","NDIS Wrappers for Linux\u00ae and BSD\u2014NDIS Wrapper is an open-source project that aims to make NDIS-compliant NICs (Network Interface Cards), whose only available driver is for Microsoft\u00ae Windows\u00ae, run on Linux\u00ae and BSD. Its scope is limited to NICs and it executes drivers' local instructions directly on the host. This means that as it does not provide emulation, and it cannot handle drivers across different hardware platforms.","WINE32\u2014WINE32 emulates Microsoft\u00ae Windows\u00ae APIs to run Microsoft\u00ae Windows\u00ae applications on Linux\u00ae and other POSIX-compliant operating systems. However it does not emulate kernel APIs and, as in the case of the NDIS Wrapper, it does not provide instruction emulation, because the hardware platform interoperability problem is not that significant for application-level programs. This means that through WINE32, an application for Microsoft\u00ae Windows\u00ae that controls a particular device can work on Linux\u00ae only if the corresponding Linux\u00ae driver is also installed on the system.","React-OS\u2014React-OS is a project whose objective is to implement an operating system containing all the interface functionality of Microsoft\u00ae Windows\u00ae. It is not intended to be a Windows\u00ae clone; instead, it attempts to imitate Windows\u00ae behavior to such an extent that any hardware and software can run on or be handled by it in an identical way as in Windows\u00ae. So theoretically, a device without a driver that can handle it on Linux\u00ae can still run on Linux\u00ae by installing React-OS on Linux\u00ae as a guest operating system, and then installing its driver on the guest. However, this involves buying and installing a whole operating system and not just what is needed to make the device work. Also this solution does not provide the instruction emulation that makes cross-hardware-platform emulation possible.","LibUSB\u2014LibUSB is an API that allows user level applications to access a USB device without needing to have a device driver actually installed on the system. It provides an interface containing a number of functions that can be called, each of which provides generic functions such as detecting plugged USB devices, transferring data packets through the USB hub to and from a USB device, etc. While it is true that some devices can work without having a driver available, only generic functionality is implemented within LibUSB, meaning that any particular functionality provided only by the device driver will not work. Again, this solution does not provide instruction emulation.","Various patents and patent applications also provide insight into what has gone before. See for example, U.S. Pat. Nos. 7,558,723; 7,437,613; 6,393,495; 6,269,408; and U.S. Patent Application Nos. 2009\/0089815; 2011\/0119666; 2008\/0028401; 2007\/0271557; and 2007\/0050765; the entireties of which are incorporated by reference herein.","An object of the invention is to present the generic driver to the host operating system as the device driver so that when the device is installed, the host operating system accepts the generic driver and allows its installation.","Another object of the invention is to analyze Microsoft\u00ae Windows\u00ae x86 drivers and other driver files that are delivered with a peripheral device, and represent them in a format that the generic driver understands, so that the generic driver can use the original driver files themselves as \u201cinstruction books\u201d to handle the devices itself.","Another object of the invention is to make the generic driver handle all the interfaces with entities (applications, operating systems and devices) that interact with all the device drivers being emulated, so that these entities believe that they are communicating with the actual device driver and not with the generic driver.","It is another object of the present invention to provide a method and system that implements one driver\u2014the generic driver\u2014handling all the interfaces mentioned in the previous section. This generic driver will be installed instead of the original device driver, but the original device driver is still needed by the generic driver in order to handle the device's functionality.","One object of the present invention is presenting the generic driver to the host operating system as the device driver so that when a device is installed, the operating system accepts the generic driver and allows its installation.","According to one embodiment of the present invention, a method is provided for controlling a peripheral hardware device connected to a computer system, the computer system comprising a first operating system, acting as the host operating system, running on a first processor platform, and a generic device driver configured to operate on the combination of the first operating system and first processor platform, the method comprising delivering the peripheral hardware device with an original peripheral hardware device driver file written for at least one of a second operating system and a second processor platform, handling, by the generic device driver, interfaces between the first operating system, the peripheral hardware devices and at least one software application, all of which are configured to interact with the original peripheral device driver file, emulating, by the generic device driver, at least a part of the second operating system and the second processor that are required for the peripheral hardware device to operate on the first operating system and the first processor.","According to one embodiment, the method further includes presenting the generic device driver to the first operating system as being a device driver best suited for a particular hardware device, in place of the original peripheral hardware device driver. By best suited is meant a device driver that can control the particular hardware device to perform the particular operations for which it was intended.","According to one embodiment, the method further includes extracting input required for operation of the generic device driver from the original peripheral hardware device driver file.","According to one embodiment, the method further includes examining, by the generic device driver functionality of the original peripheral device driver as to security and stability issues for interaction on the first operating system and processor platform. Through instruction emulation and kernel API emulation, safer execution of drivers is possible. The present invention is designed to improve execution of the drivers to reduce driver and system crashes.","According to one embodiment, the method further includes deriving input to the generic device driver from the original peripheral device driver, the step of deriving comprising the steps of parsing the original peripheral device driver file, disassembling a code section within the original peripheral device driver file using a disassembler appropriate to the combination of the operating system and processor platform for which the original peripheral device driver was written, and storing the found information in a form that is readable by, and can be interpreted by the generic device driver.","According to the present invention, the method further includes emulating all the instructions that are extracted from the original peripheral device driver using the instruction emulation functions in a virtualized guest system.","According to the present invention, the method further includes emulating all the APIs that are extracted from the original peripheral device driver using the API Forwarder\/Mapper\/Emulation functions in a host system.","According to the present invention, all the instructions that are extracted from the original peripheral device driver are emulated using the instruction emulation functions in a virtualized guest system.","According to one embodiment, all the APIs that are extracted from the original peripheral device driver are emulated using the API Forwarder\/Mapper\/Emulation functions in a host system.","According to one embodiment, the computer system has at least one universal serial bus port (USB port) for use in the input and output of data, and wherein the peripheral hardware device is connected to the computer system by means of the USB port,","According to one embodiment, the combination of the second operating system and second processor platform is the same as the combination of the first operating system and the first processor platform.","A computer program and computer system for performing the inventive methodology are also provided.","The driver model () in  refers to the communication structure between the host operating system () and device driver () specified by the operating system driver model. In particular, the driver model specifies: 1) the system and\/or device events that cause the operating system to call the driver; 2) the data that the operating system passes to the driver when calling it; and 3) the data that the driver must return to the host operating system when it finishes performing any function after a call by the operating system.","The layered driver model is the basis of the driver model for every operating system, not just Microsoft\u00ae Windows\u00ae. Although usually a device driver is referred to as the single entity that controls the device, this is not specifically true. As shown in , peripheral devices are usually controlled by a chain of drivers arranged in layers, hence the term \u201clayered driver model\u201d (elements having the same function will be referred to using the same reference numbers in each figure, and any description thereof will be omitted, except where necessary). Every layer either controls a physical component or a functional component related to the device. For example, USB devices will always have the USB bus driver () in their driver-chain. This controls the USB bus and all devices connected to it. Class (or function) drivers () are more related to the functional aspects of a device. For example, a particular hardware vendor can implement a class driver for all its devices into which some functionality common to all or most of its devices is inserted. This driver is then inserted in the chain so that the manufacturer's device drivers do not contain repetitive code. Filter drivers (both upper () and lower ()) can contain added functionality or corrective implementation. These can even be inserted into the chain after the device driver has already been installed.","The application () places the request for device use to the host operating system () via system calls (). Within the host runtime environment (), these requests are passed on from the host operating system () through the driver-models (), to the upper () and lower () filter drivers, the function driver () and the USB bus drivers () to form function calls () and then other drivers or kernel level DLL files (). The filter drivers () and (), the function driver () and the bus drivers () return information to the host operating system () via system\/kernel APIs calls (). The load\/unload function () refers to the process of creating a run-time instance of a driver or any kernel-loadable module, and \u2018installing\u2019 it within the kernel. As an example, when starting up Windows\u00ae, all device drivers and kernel modules needed to handle all of the kernel's needs (including the handling of all device currently attached to the platform) are loaded. For every such module\/driver, all of the other kernel modules () that it depends on to be able to run adequately, also need to be loaded. On Windows\u00ae shutdown, all of these are unloaded. Should a device be uninstalled, its driver, and any other drivers\/kernel modules with which it exclusively communicates are also unloaded.","From a developer's point of view, then, whenever we talk about \u201cdevice driver\u201d we are always referring to the \u201cfunction driver\u201d. However, when we talk about the process of \u201cinstalling a device driver\u201d (i.e., from a user's point of view), we are referring to the process of installing the whole chain of drivers (class drivers, filter drivers, function driver, bus driver). Thus, in a layered driver model, the device driver can be treated as the whole chain of drivers. The bus driver is usually already installed on the system. Class drivers can either be installed already or else be distributed as part of the device driver package. Filter drivers (both upper and lower) are either distributed with the device driver, or else they can be distributed and installed at a later stage on the system on which the device driver has already been installed.","In standard operating systems, for example, in Microsoft\u00ae Windows\u00ae, device drivers do not have to worry about what other drivers are layered above and below it during runtime. The driver always gets called directly by the operating system (through dispatch routines and interface functions as already described), and returns values to the operating system. The host operating system then passes data to the drivers above and below as needed.","The host operating system must identify other external drivers and kernel modules that are called by the drivers during device installation, as well as installing the whole chain of drivers controlling a device. The host operating system must first load these other drivers and modules, unless they are already loaded. On device un-install, if these drivers and modules are not used by other device drivers, the host operating system unloads them.","After analyzing the main components of the driver context, one can see that there are two major entities with which the driver interfaces\u2014the underlying operating system and the processor. A third (minor) entity consists of the kernel-level components (such as libraries and\/or drivers) that are external to the kernel. These are considered to be minor entities mainly because the operating system is in charge of identifying and loading such components. This can also be deemed to be part of the communication with the operating system.","The following are some situations where the generic driver according to the present invention would be valuable.","A user would like to migrate to a different operating system but the migration is held back by the knowledge that one or more of the peripheral devices will not work (i.e., are not supported) on the new operating system. The generic driver can be used to handle these devices and make them work on the new operating system.","A business center has an expensive device that is not supported by the operating system following an upgrade to a newer version of that same operating system. The generic driver can be used to handle this device and make it work on the new operating system.","A business center has an expensive device that it needs to continue using. However, the hardware vendor has stopped supporting it and the center would like to switch from an x86 server to a new 64-bit server based on a different architecture (for example, Itanium\u00ae). The generic driver can be used to handle this device and make it work on the hardware architecture and any further platform changes that may occur in the future, even though support is no longer available from the vendor.","A device driver running on a system is crashing the system because some of its code is defective. The device driver is emulated through the generic driver so that it is prevented from crashing the whole system and just gracefully stops the device from running whenever defective code is encountered.","An IT company uses a network in which users work remotely on the server through thin clients. A thin client (sometimes also called a lean or slim client) is a computer or a computer program that depends heavily on some other computer (its server) to fulfill its traditional computational roles. The administrator would like to enable all users to be able install and use personal devices on the server by connecting them to their thin client. However, the overall stability of the system cannot be compromised. The generic driver together with a USB Device Redirection system can be used to allow users install their devices in emulation mode from their thin client location and use these devices without being able to either bring the system down or affect the server experience of any other user.","A user has a device whose driver is not signed by the vendor of the operating system running on the system because it contains dangerous or defective code. Hence, the user cannot use this device. Using the generic driver (assuming that it is signed by the operating system vendor), the device driver can be emulated without putting the stability of the host operating system at risk. Should dangerous code be encountered during emulation, a work-around can be provided by the generic driver, or else the driver will be stopped gracefully.","It can be said that a device driver's role is that of making the device's features and functionality work on a particular combination of hardware and software platforms. The hardware platform is the processor, while the software platform is the operating system. The generic driver () is installed so that it handles the interfacing with the underlying software and hardware platforms. It then references the actual device driver's binary file\u2014which is not installed on the system\u2014in order to obtain information about how to handle the device's features and functionality and actually make it work.","A component of the generic driver () is the driver analyzer (), which is able to parse the contents of the device driver binary file, and use it as an \u201cinstruction book\u201d for handling the device. This means that the binary file is never installed directly on the system but is used exclusively by the generic driver (), and as a result no internet access is required.","As most peripheral device are delivered with drivers for Microsoft\u00ae Windows\u00ae operating systems and x86 processor platforms in the following considerations, it is assumed that the device driver is a Microsoft\u00ae Windows\u00ae driver. This assumption is only an exemplary embodiment of the present invention. For example, the device driver could be one that enables the device to operate on Apple\u00ae Macintosh\u00ae computers, or any other type of system that may be developed in the future. Persons skilled in the art should easily be able to apply various modifications and changes to implement the invention on future systems.","The generic driver () is implemented so as to be able to understand information stored within a Microsoft\u00ae Windows\u00ae x86 driver's binary file. It is then implemented and compiled to work on the target platform using the Microsoft\u00aeWindows\u00ae x86 drivers which the device needs to function. This target platform may also be a x86 processor platform with Microsoft\u00ae Windows\u00ae operating system, or it may also be a completely different platform, for example a platform with an Intel\u00ae Itanium\u00ae (64-bit) processor and BSD operating system. One objective of the generic driver () is to make the peripheral device work on an Itanium\u00ae (64-bit) BSD platform. Thus, the generic driver () is implemented and compiled for Itanium\u00ae as a hardware platform and BSD as a software platform. Intermediary solutions are also possible and useful. The following table shows possible platform scenarios where a device with a Microsoft\u00ae Windows\u00ae XP x86 driver can function:",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Same ","Different ","Different "]},{"entry":["Software Platform","Operating","Operating","Operating"]},{"entry":["Hardware Platform","System","System Version","System"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Same Processor","Windows\u2009\u00ae","Windows\u2009\u00ae","FreeBSD\/"]},{"entry":["Platform","XP","Vista\/7","Linux\u2009\u00ae ...."]},{"entry":[{},"\u00d786","....2008.....","\u00d786"]},{"entry":[{},{},"\u00d786",{}]},{"entry":["Extended Processor","Windows\u2009\u00ae","Windows\u2009\u00ae","FreeBSD\/"]},{"entry":["Platform","XP","Vista\/7","Linux\u2009\u00ae ..."]},{"entry":[{},"\u00d764",".....","\u00d764"]},{"entry":[{},{},"\u00d764",{}]},{"entry":["Different Processor","Windows\u2009\u00ae","Windows\u2009\u00ae","FreeBSD\/"]},{"entry":["Platform","XP","Vista\/7","Linux\u2009\u00ae ..."]},{"entry":[{},"Itanium\u2009\u00ae","....","Itanium\u2009\u00ae"]},{"entry":[{},{},"Itanium\u2009\u00ae"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Although the same operating system\/same processor scenario does not make a device work on a different platform, it can still be useful, mainly to solve the security issues discussed in the background section of this document. The generic driver () detects whether any part of the functionality implemented within the device driver puts the underlying platform's security or stability at risk. For example, should the device driver contain instructions that can cause a blue screen, the generic driver () only executes these instructions after performing adequate checks to ensure that this cannot occur. In server scenarios, should a device driver contain functionality detrimental to other user's experience on the server, the device driver could be stopped. This makes it possible for any user to install a personal device on the network without the administrator's intervention. The generic driver () can be installed to handle these devices and make sure that while using a device, the user is not putting the system's stability or security at risk. If this happens, it either finds a way to obtain the same functionality without such breaches, limits its functionality, or it stops the device.","The following embodiment of the present invention describes the integration of peripheral devices in a computer system in case the device driver for a given peripheral device is only available for Microsoft\u00ae Windows\u00ae operation system. This described embodiment is an example only, and in practice a plurality of variations are possible, the implementation of which is within the skill of the ordinary artisan.","The solution can be divided into the following main components: 1) presenting the generic driver to the host operating system as the device driver so that when the device is installed, it accepts the generic driver and allows its installation; 2) analyzing Microsoft\u00ae Windows\u00ae x86 drivers and representing them in a format that the generic driver understands so that it can use the drivers as an \u201cinstruction book\u201d to handle the devices itself; and 3) making the generic driver handle all the interfaces with entities that would interact with the device driver, making it seem to all these entities that they are communicating with the actual device driver and not with the generic driver.",{"@attributes":{"id":"p-0090","num":"0089"},"figref":["FIG. 3","FIG. 3","FIG. 1","FIG. 3"],"b":["350","150","350","350"]},"The application () wishing to use a USB device () sends a driver use request () to the host operating system () within the host operating system runtime environment. The USB controller () obtains information from the USB device (), enumerates it, adds in events such as hardware interrupts (), and passes this on to the operating system ().","The operating system () then communicates with the generic driver () via system and kernel APIs calls () and the driver model () to obtain the information needed to control the device (). Where required, function calls are further placed to other drivers () for necessary data.","The response from the generic driver () returns to the operating system () and then back to the device () routed through the I\/O ports () and the USB controller (). Finally, a set of assembly instructions () specific to the processor for which it was developed that access and manipulate the underlying hardware resources, such as the processor's registers and memory, are sent from the generic driver () to the host processor (CPU ). The processor's instruction set allows a driver to manipulate its I\/O ports.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 4","b":["350","350","470","480"]},"Host operating system\/kernel APIs kernel API calls () are kernel API calls from the generic driver () to the host operating system (). The guest operating system\/kernel API calls (), refer to the kernel API functions called by the emulated device driver () (the name and the arguments therefor) to the guest operating system (not shown). For more information about the relationship between the host and guest APIs, see the API subsystem section as described with respect to . The kernel API manager () might actually contain an emulation of some subsystems within the driver's target operating system, but the only interest for the inventive system is that it translates the driver's kernel API calls into corresponding implementation on the host operating system that performs the same functionality. This implementation can be as simple as calling one single host API call that performs identical functionality. It can also be as complicated as including a complete emulation of a whole guest operating system subsystem.","According to the exemplary embodiment shown in , the device driver () sends a representation of itself (D.D. representation ) through the driver analyzer () (see  for more detail) to the generic driver (). According to one embodiment, standard XML can be used, but any type of representation would work as long as it presents information in a format that is easy to parse directly by other subsystems.","Specifically, the driver analyzer () analyzes the driver's contents (involving a lot of tedious parsing of binary codes stored within the driver's \u201c.sys\u201d file, the implementation of which is within the skill of the ordinary artisan) and creates a device driver representation () of these contents in a new format that is much easier for other components of the generic driver () to understand and parse. This will be explained for an exemplary implementation below.","The information obtained from the driver model managers () (see  for more detail) via the host generic driver (HGD) interfaces () is also input into the generic driver (). The generic driver () uses the device driver representation () and the information received from the driver model managers () to send out guest operating system and kernel APIs calls () to the kernel API Manager (), which outputs the operating system and kernel APIs calls () (see  for more detail).","The guest driver can contain calls to other drivers\/kernel modules that are not part of the host operating system core\u2014which will be referred to here as \u2018external modules\u2019. These external modules have to be loaded together with the actual device driver for it to be installed directly on the host operating system. \u2018Actual device driver\u2019 refers to the guest device driver ().","The generic driver () also sends out external function calls () to the dependency manager () (see  for more detail). The generic driver () sends processor assembly instructions () through the instruction emulation subsystem () (see  for more detail).","In  diagram, external host functions () refer to the equivalent calls (if available) or emulation (if calls are not available) that perform functionality similar to the external guest functions calls (). For more information about the relationship of the guest and host functions, see the section on the dependency manager described with regard to .","The device driver guest interfaces () are the data structures used by device drivers in the guest operating system (not shown) to represent device and driver states, and for communication with the guest operating system. The device driver guest interface () functions as specified by the guest operating driver model. For more information, see the driver model manager () described with respect to .","The guest platform (i.e., guest processor and guest operating system), actually becomes a guest only when using virtualization approaches like that according to the present invention.  depict the conventional scenario\u2014hence they represent a Windows\u00ae x-86 driver when being run conventionally on a Windows\u00ae (host operating system) x-86 (host processor) platform. When this driver is used as a guest driver according to the present proposed system, say, to run it on a FreeBSD (the new host operating system according to the described exemplary embodiment) x-64 (the new host processor according to the described exemplary embodiment) platform, Windows\u00ae becomes the guest operating system and x-86 becomes the guest processor. This means that from then onwards the inventive system will never be loading or accessing in any way either the guest operating system (Windows\u00ae) or the guest processor (x-86). Conventionally, the Windows\u00ae x-86 driver communicates with its host operating system (Windows\u00ae) and host processor (x-86) using mainly Windows\u00ae kernel API calls, and x-86's instruction set, and further, external modules are used that can be loaded within Windows\u00ae.","The generic driver host interfaces () are the data structures used by device drivers (including the generic driver (), which is implemented as a device driver) on the host system to represent device and driver states, and to communicate with the host operating system (). The host device driver interfaces () function as specified by the host operating system driver model. For more information, see the section on driver model manager described with respect to .","The guest processor assembly instructions () are a sequence of assembly instructions that forms a part of the specified instruction set of the guest processor (not shown) and is contained within the emulated device driver ().","The host processor assembly instructions () are a sequence of assembly instructions that forms a part of the specified instruction set of the host processor () that is executed by the generic driver () on the host processor (). In this context, when the host processor is different from the guest processor it refers to the corresponding host instructions that perform a similar functionality to the guest instructions, but on the host. For more information on the relationship between host and guest instructions, see the section on the emulation subsystem described with respect to .",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 5","b":["400","400","310","350","100","310","100","310","520","530","310","540","550","560","415"]},"The Sys file parser () parses the device driver () and extracts all information stored within its headers, data directories and tables. The information that is extracted includes details about the software and hardware platform for which it was compiled, the kernel APIs it calls, the functions it calls from external libraries, the functions that the device driver () exports for other drivers to call, the resources it uses, base relocation information, and more, the details of which are known to those skilled in the art. In one of the headers, there is also information (pointer and size) about the section within the .sys file itself where the driver's code is stored. However, the content of the driver's code does not fall under the PE COFF specification and hence is not parsed by the Sys file parser (). The output of the Sys file parser () is a parsed PE file ().","Examples of the format of PE files and tables according to the standard PE COFF specification can be found under: www.microsoft.com\/whdc\/system\/platform\/firmware\/PECOFF.mspx.","The X86 disassembler () becomes relevant once the device driver () sys file has been parsed and stored in the parsed PE file (). As soon as the sys file parser () verifies that the device driver () has been compiled for an x86 processor and identifies the base and size of the code section, the x86 disassembler () can use this information (taken from the passed PE file ()) together with the x86 processor's instruction set specification to disassemble the instructions within the code section.","The driver's code section can be seen as a large sequence of various assembly instructions. These assembly instructions all belong to the Instruction Set Architecture\u2014part of which is a specification of a list of instructions together with an algorithm performed by each instruction\u2014of the processor for which the driver was compiled. In the presently described exemplary embodiment, the drivers are mainly those compiled for x-86. Intel's x-86 instruction set architecture is documented within official public documents. They can be downloaded from www.intel.com\/products\/processor\/manuals\/. These instructions are encoded within the driver's binary file using opcodes. The disassembler's task is to convert these opcodes into a sequence of instructions as described. Once this is done, all information has been extracted from the driver's binary file () and the x86 disassembler () outputs a fully disassembled driver file (). See also the code () shown as an example in .","In this context, the disassembly process involves the translation of binary opcodes into assembly instructions. For example, an x86 disassembler converts a chunk of binary opcodes into their corresponding x86 assembly instructions. This is a standard process, within the skill of a person with an ordinary skill in programming. When a programmer writes a program in any high-level language (such as JAVA, C++, etc.) the program instructions will be automatically converted to assembly language by the compiler (or more specifically, by the assembler). Drivers in Windows\u00ae are usually developed using C++, automatically converted to assembly instructions by the compiler (or assembler), and then encoded (again automatically, usually by an interpreter) into the binary coded .sys file.","The driver's code (the assembly code generated by the X86 disassembler (), which is a sequence of assembly instructions, for example: ADD EAX, EBX; PUSH EAX; PUSH EBX; CALL 0xf0808080) includes a large sequence of instructions that accesses the processor directly, together with branching instructions that transfer control either to the operating system's kernel or to external loaded libraries or drivers. A disassembled driver () usually is a very large file. An example of a very small part of it might be:","push ebp","mov ebp, esp","sub esp, 4","mov eax, [ebp+8]","mul 2","mov [esp+0], eax","mov eax, [ebp+12]","mov edx, [esp+0]","add eax, edx","mov esp, ebp","pop ebp","ret","The code semantics analyzer () represents the code in disassembled driver () in a manner (such as that shown in ) so that it can be accessed later more efficiently by other subsystems. The driver analyzer () creates a representation of all of the driver's information in the device driver representation file () in xml format. As xml is a \u201cmachine-understandable\u201d format, other subsystems can access the xml file and access the information they need directly and efficiently.",{"@attributes":{"id":"p-0127","num":"0126"},"figref":"FIG. 6","b":"400"},"As noted above, after analyzing the device driver's contents (which involves a lot of tedious parsing of binary codes stored within the device driver binary file ()), the driver analyzer () creates a representation of the device driver's contents into a format that is much easier to understand and be parsed by other components of the generic driver (). As part of the process, all complexities related to how the device driver's contents\u2014including tables representing how the driver communicates with other parts of the OS, as well as the x86 instructions\u2014are encoded into the binary (.sys) file on being abstracted from other parts of the generic driver () by the driver analyzer. The encoding here will be described in more detail below.","The emulation subsystem () takes every instruction in the guest processor assembly instructions () and emulates them according to the requirements of the host processor (), outputting them as host processor assembly instructions (). However, emulation is not only a process of \u201ctranslating\u201d. Emulation can also happen when the guest instruction set and the host instruction set are identical. Instruction emulation is a standard known process implemented by systems like Bochs and QEMU. When instructions are emulated, they are not allowed to access the hardware architecture directly, but are allowed to access a \u201cvirtual\u201d representation of the hardware architecture stored in memory (i.e., the guest processor).","The emulation subsystem () functionality can be sub-divided into three main areas: 1) x86 virtual guest definition (); 2) x86 instruction emulation (); and 3) guest manager ().","The x86 virtual guest () is defined such that instructions from the device driver () are not be executed directly on the host processor () for two main reasons. First, the host processor () may not actually be an x86 processor (refer to Table I above) and treating it as such might cause crashes or other difficulties. Second, it might be unsafe to execute these instructions directly on the host processor () as they can either be harmful or can cause the system to become less stable or even crash.","The first task in defining a virtual guest is the hardware emulation (). This involves defining all of the host processor's hardware\u2014registers and flags, CPU tables and structures\u2014and storing those definitions in the host's memory. Hardware emulation (more specifically \u201cprocessor emulation\u201d) is a standard process used in emulators (such as Bochs and QEMU), and it involves representing all of the hardware components into software. To emulate an x86 processor, the technical architecture specification must be analyzed and all the architectural components must be \u201cmodeled\u201d by software programmed to perform the functions of the processor. This is a straightforward process generally known to those of ordinary skill in the art. According to the present invention, a particular methodology to emulate the processor has not been used. Instead the processor components have been modeled in a way that relates as much as possible with the hardware. This emulation of the hardware means that every operation that is usually executed by the device driver () on the host processor () is now performed on an emulated processor () instead.","The second action defines the guest's memory subsystem (). A sizable number of instructions within the x86 instruction set access the memory (not shown), with the memory address space depending on the amount of memory available on the host processor (). The basic goal of the memory subsystem () is to translate an address that makes sense into the guest context, into an address that makes sense in the host context. There are various possible techniques by which memory is emulated so that the virtual guest has the impression that it has direct access to the physical memory available on the host processor. The described embodiment of the invention uses the simplest possible method for this, by assuming that the guest address is valid on the host context. To allow efficient guest memory management In the future, the protected-mode memory management subsystem available on the x86 processors may need to be extended. However, according to the one embodiment, memory access is controlled by the guest address manager (), which translates the guest virtual addresses coming from the instructions being emulated\u2014targeted for a conventional host memory subsystem\u2014into controlled host physical addresses. The method of translation used by the solution simply means that the guest address manager () treats guest address as host addresses. However, various virtual machine\/emulator solutions handle efficient memory management so even if running a lot of guests on one host, the fact that some addresses might clash should not block this solution from running. Finally, a virtual stack () is also needed to store all the addresses and parameters that the guest would be pushing on the host stack in a conventional environment.","The virtual stack () is identical to the call-stack in the conventional x86 environment. Its purpose is to store \u201cstack frames\u201d (including return addresses, data parameters and return values) so that running processes can execute called functions and return to the respective caller when functions are completed. The generic driver () is a process running on the host, and it is in turn emulating \u201cguest processes\u201d (i.e., device drivers) running in the guest environment. The instructions being emulated cannot be allowed to modify the host stack as this would interfere with the process execution control on the host, and would eventually crash the generic driver or other host processes. So, a virtual stack has to be emulated so guest instructions will act on it.","The act of x86 instruction emulation () implements the functionality of every instruction within the x86 instruction set, acting on the virtual guest () as described above, by modifying the virtual representation of the hardware components. In this way, the emulated instructions do not modify the hardware components. For example, the instruction ADD EAX, EBX should add the value of the EAX register and the value of the EBX register, and store the result in the EAX register. An emulated ADD EAX, EBX will retrieve the values of the virtual EAX and EBX registers stored somewhere in memory, add them and store the result in the memory area that is being used to emulate the EAX register. This is the component of the emulation subsystem () that interacts with generic driver () by receiving therefrom the guest processor assembly instructions ().","Whenever x86 assembly instructions contained inside the device driver () need to be emulated, the generic driver core () determines a sequence of local instructions that need to be emulated and for each instruction it calls emulator functions from the instruction emulation subsystem (). Each emulator function follows the algorithms provided in the x86 instruction set specification which is know in the art, for example the 32 2, incorporated by reference herein in its entirety. Whenever instructions need to be emulated, the generic driver () determines a sequence of local instructions. The local instructions (the greater part of the instructions) are all the instructions that perform actions on any part of the processor architecture directly. The non-local instructions are those (such as CALL) that branch to any other kernel module, driver, operating system subsystem\/API and so on, so that the called component can perform the needed actions themselves.","The third component is the guest manager (), which is in charge of managing the virtual guest's state, presenting information about its state to the generic driver () and other subsystems, synchronizing the virtual guest state to the host and vice versa when needed, and other similar tasks. All subsystems within the generic driver () interact with the guest manager () whenever they need either to obtain any information about the state of the guest, or they need the guest to perform any type of action. In the same manner that the driver analyzer () abstracts all complexities related to device drivers' binary files, the guest manager () abstracts all complexities related to managing x86 guest \u201cvirtual\u201d machines and the respective instruction set. It is also in charge of managing guests running simultaneously, distributing host resources as efficiently as possible among the guests and ensuring that concurrent guests do not disrupt each other while running. This distribution of host resources among multiple guests is a standard task in all virtualization projects, well within the skill of the person ordinary skilled in the art.","In the same manner by which the generic driver () calls the emulation subsystem () whenever local instructions from the device driver () need to be emulated, the generic driver calls the API driver subsystem () whenever branches to kernel APIs are encountered (via system calls) and their functionality needs to be accessed. The main difference between the logic behind the emulation and the API subsystems (, ) lies in the fact that while the emulation subsystem () always emulates every instruction it receives, the API subsystem () first checks whether the functionality needed can be obtained directly from the host processor (). The task of the API Manager () is to keep track of the APIs available on the host operating system () and, based on the API that needs to be called by the guest OS, to determine which of the other components to call. The following paragraph explains the possible components that can be called (API forwarder (), mapper () or emulator ()) and the context in which they should each be called.","The best-case scenario occurs when the API referenced by the device driver () is available in the host operating system (). This should be the case when the host operating system () is the same (and same version) of the operating system that the driver was compiled for\u2014that is, the guest operating system. That is where the API forwarder () comes in. The generic driver () accesses the output of the driver analyzer () to understand what kernel API needs to be called. The device driver representation () output by the driver analyzer () is easily understandable by other subsystems because it is written in a standard tagged format.","The emulation subsystem () contains a virtual stack (). Whenever an API is called, the local instructions that precede the actual CALL instruction push data parameters onto the virtual stack () that are used by the API in order to compute the needed function. Thus, when forwarding\/mapping\/emulating an API, the emulation subsystem () must be queried first, so it passes on these data parameters. The generic driver () accesses the guest manager () within the emulation subsystem () to obtain the parameters passed on from the virtual stack () following the call on the API. When these parameters have been obtained, the generic driver () calls the API forwarder (), which forwards the kernel API call that needs to be made to the host processor () and returns the return value to the generic driver (). This then passes the return value back to the Guest Manager () so the Guest Manager, () can synchronize the guest processor to enable the guest processor to continue handling the emulation.","There are cases when the host operating system () provides APIs that perform the identical functionality of APIs provided by the guest operating system (), but with some extra functionality included. This can be the case in newer versions of the same operating system, when for example added parameters are used for security reasons (and hence added functionality related to security will be performed by the called function). A similar scenario can happen when the guest and host operating systems are different but contain similar functional subsystems. In both of the above and in similar cases, the host API is called, however some additional functionality must be added before or after to take care of the differences. There could also be cases when the equivalent functionality, normally performed by the guest API, can be performed by a sequence of host APIs. Such cases are handled by the API mapper (), which assigns a sequence of host APIs to handle the additional functionality.","That functionality that cannot be mapped to host APIs goes to the API emulator (), which emulates this functionality on the host operating system (). If complete subsystems need emulation, then the guest OS subsystem emulator () is required. To illustrate, assume the guest API X performs Function A on the guest operating system, and assume Function AA is equivalent to the same logical function but performed on the host operating system (). The host operating system () might not have one single API X\u2032 that performs Function A. However, it might provide APIs Y and Z that when called in sequence can perform Function AA. The API mapper () would understand that API X on the guest processor is called to perform Function A. It understands Function A on the guest processor is equivalent to Function AA on the host processor (). Hence it calls APIs Y and Z in sequence.","The worst-case scenario in this context would occur when the guest API performs functionality that is impossible to be mapped to host APIs, in which case this functionality would have to be emulated by the API emulator () from scratch (or almost) in terms of functions, structures and lower-level kernel APIs available on the host operating system. Sometimes, to achieve this, a whole structural or functional subsystem within the guest operating system would have to be emulated on the host operating system (). In such cases, the guest operating system subsystem emulator () would need to emulate subsystems from the guest operating systems. These subsystems will then be called by the API emulator's functions. The output of the API subsystem () is the host operating system kernel API calls (). It is possible that individual APIs or whole OS subsystems would need to be emulated.",{"@attributes":{"id":"p-0144","num":"0143"},"figref":["FIG. 8","FIG. 8"],"b":["800","840","860","850","870","810","880","890","820","830"]},"While the other three subsystems covered so far all deal with data extracted from the device driver's binary file (), the driver-model manager () deals with the device-driver's runtime properties\u2014meaning that the device driver is seen as a kernel-level program that is loaded, unloaded and called by the host operating system () in order to perform a particular task. The host operating system () can either call the device driver () to perform a task initiated by a third entity such as an application or the device itself, or to perform a task initiated by the host operating system. The role of this subsystem is to abstract details about which driver is actually handling the device from the operating system. The purposes of the driver-model manager () can be summarized into two main roles: 1) During installation, it must present the generic driver () as the driver that is best-ranked to handle the device being installed, should the user want to run the device in emulation mode; and 2) once the generic driver () is assigned the role to act as the device driver, the driver-model manager () must make sure that control and data transferred to\/from the host operating system () is exactly identical to the control and data transfers that would occur if the actual device driver was installed.","Let's start with the first role. In conventional systems, an operating system uses the .inf file incorporated within the device driver package as well as some internal structures in order to give a ranking for every device driver in terms of the devices it can handle. When a new device needs to be installed, the operating system can either ask for the user to specify which driver to use, or else it can check for which device drivers are already available. It can then choose the best ranked device driver. Most criteria that determine the ranking relate to the features that directly relate to the device driver, the device itself and the hardware vendor. However, some operating systems, such as Microsoft\u00ae Windows\u00ae, add other criteria that are related specifically to themselves, such as whether the driver is or is not signed by Microsoft\u00ae. Should there not be a device driver that is ranked highly enough to be deemed fit to handle the device, the operating system forces the user to provide a new device driver (from disk or online). Newer operating systems are being distributed packed with pre-installed device drivers that can handle most conventional plug and play devices, making the cases when the user has to specify the driver manually less frequent. The driver-model manager () must provide a way to ensure it is highly-enough ranked to be chosen by the operating system to handle the devices that it should be handling. This process varies according to the host operating system on which the generic driver is running. It should also provide an interface for the user to choose whether to install the actual device driver directly\u2014bypassing the generic driver ()\u2014or whether the device should be run in emulation-mode using the generic driver (). This process also varies according to the host operating system on the generic driver () is running.","The second role of the driver-model manager () is somewhat more complex. In Microsoft\u00ae Windows\u00ae, device drivers contain a number of functions that can be called at any time. These are the dispatch routines\u2014called when a particular event or group of events take place\u2014and other special functions that are called in special circumstances such as when the driver needs to be loaded, when a new device is connected etc. Here the term interface functions as a collective term for these functions that can be called by the operating system is used. When the operating system calls such interface functions, it passes a request package that contains all of the information the driver needs to perform the needed functionality. The operating system then waits for the driver to provide a return value from a predefined set of possible return values specified beforehand.","The problem with this is that different operating systems are based on different architectures and hence have different interfaces and different types of request packages. So in the case when the host operating system is either identical to the guest operating system or, is based on the same driver model (such as different versions or variants of the same operating system), there should not be a problem. However when the guest and host operating systems are based on different driver models, the driver-model interface manager () (see ) must do the following: 1) identify the functionality for which the host operating system is asking; 2) analyze the information stored within the host operating system's request package; 3) translate the request package to a form that is understood by the device driver, and hence that is compatible with the guest operating system; 4) identify the guest interface function (or combination of guest interface functions) that should contain the same functionality that the host is asking for; and 5) call the generic driver () to emulate these guest interface function(s).","The state of a device driver and the device it controls are stored in the form of device and driver objects. DeviceObject and DriverObject are standard windows structures as can be seen at msdn.microsoft.com\/en-us\/library\/ff544174%28v=vs.85%29.aspx and msdn.microsoft.com\/en-us\/library\/dd389207%028v=vs.85%29.aspx.","The task of the driver-model object manager () is to handle and maintain the state of these objects during the runtime of all devices that are being handled by the generic driver (). Again the worst case scenario occurs when the guest and host operating systems are based on diverse driver models, because data will have to be translated directly or indirectly. Even when the guest and host operating systems are identical, the fact that the same driver is used to control various devices causes the one-to-one relationship that normally exists between a driver object and a device object to change. This problem is solved through the use of virtual driver objects, each of which is mapped to the same physical driver object and each of which handles the same device object.","The host operating system device objects and driver objects () are the data structures specified by the host operating system driver model in order to represent all of the static and dynamic properties belonging to a device driver () and the device () it represents. These are standard data structures specified by the USB protocol and listed in the USB specification.","The guest operating system device objects and driver objects () are the data structures specified by the guest operating system driver model () in order to represent all of the static and dynamic properties belonging to a device driver and the device () it represents. Even though the device () is identical on both guest and host operating systems, and hence the drivers will have very similar features, the data structures on the guest can have significant differences both in their format as well as in their content from their equivalent on the host operating system.","The guest device objects and driver objects () is the repository of guest device and driver representations () (as described in the previous descriptions) for every driver that the generic driver is emulating.","Host operating USB driver model data communications structures () are data structures used by the host operating system () to communicate with a USB device driver () whenever the host operating system () calls the USB device driver () to execute a particular function related to the USB device () it controls. Such data includes an indication of what function is needed, information needed for the required function to be performed and information about the current state of the host. The URB structure is one example of the format of this data structure.","The guest operating system USB driver model data communications structures () are data structures used by the guest operating system to communicate with a USB device driver () when the guest operating system calls the USB device driver () to execute a particular function related to the USB device () it controls. Such data includes an indication of what function is needed, information needed for the required function to be performed and information about the current state of the guest operating system. Even though data on both guest and host operating system is very similar from a logical point of view, the data structures on the guest operating system can have significant differences both in their format as well as in their content from their equivalent on the host operating system.","The host operating system USB driver model driver interface functions () are the functions of the interface that a USB device driver () provides for the host operating system () to call whenever it needs the USB device driver () to perform a certain task. The interface consists of a set of functions, each mapped to one specific event which triggers the host operating system () to call the function. The host operating system provides a specific operating system\u2014dependent set of possible events that can be handled by the USB device drivers. For example, assuming that the host operating system is FreeBSD, such events can be \u201cwrite\u201d, \u201cread\u201d, \u201copen\u201d, \u201cclose\u201d, \u201cdevice_attach\u201d, \u201cdevice_suspend\u201d, \u201cdevice_detach\u201d.","The guest operating system USB driver model driver interface functions () are the functions of the interface that the USB device driver () provides for the guest operating system to call whenever it needs the USB device driver () to perform a certain task. The interface consists of a set of functions, each mapped to one specific event which triggers the guest operating system to call the function. The guest operating system provides a specific operating system-dependent set of possible events that can be handled by the USB device drivers. This set of events can be different from the set of events provided by the host operating system (). For example, assuming that the guest operating system is Windows\u00ae, such events include all those covered by the standard windows dispatch routines (IRP_MJ_CREATE, IRP_MJ_CLOSE, IRP_MJ_POWER, IRP_MJ_PNP etc), and other standard driver entry points such as Driver_Entry, Unload, and Add_Device.",{"@attributes":{"id":"p-0158","num":"0157"},"figref":"FIG. 9","b":["900","450","910","920","930","460","940","950"]},"More specifically, the dependency manager () is called by the generic driver () while emulating the device driver () whenever the device driver () contains branches to external code that are not part of the guest operating system's kernel. In the conventional context, the libraries or drivers containing this code are dynamically loaded by the operating system when the driver is loaded. In the context according to the exemplary embodiment described herein, the driver analyzer () would have identified such external files that are used by the device driver () and provided information about them in the device driver representation () it produces. When such a call is encountered during emulation, the dependency manager () is called in the same way as the API would be called when a branch to a kernel API subsystem () is encountered. In other words by accessing the device driver representation () created by driver analyzer (), the dependency manager () can discover details of the external components (see  . . . the box titled \u201cOther Drivers . . . \u201d) used by the device driver ().","In fact, the dependency manager () can be viewed as being similar to the API subsystem (), with one fundamental difference. As in the case of the API subsystem (), the dependency forwarder () and the dependency mapper () are called by the dependency manager () whenever the device driver () calls an external function from a dynamically loaded library or from another driver, which is either available on the host operating system or which can be mapped to similar functions available on host libraries\/drivers. When these are not available on the host operating system, the dependency emulator () has two options. It can re-implement the functionality being called by the guest operating system into a host library or driver and call it directly. Alternatively, the function from the called driver or library can be emulated by the generic driver () in the same way as the device driver () itself is emulated\u2014by making the driver analyzer () create a representation of its contents, emulating its local code through the instruction emulation subsystem (), and making the API subsystem () handle its kernel calls. This process can become recursive should there be further calls to other external libraries\/drivers.",{"@attributes":{"id":"p-0161","num":"0160"},"figref":"FIGS. 10A-10D","b":["1000","1002","1004","1006"]},"At step , the first one of IF parameters is retrieved and the input parameters for that IF parameter is prepared. All assembly instructions except for external calls are then emulated (step ). The emulated assembly instructions are output as guest assembly instructions, in the form of an instruction identifier and its arguments (step ). The module then enters the instruction emulation subsystem (step ).","First, it is determined if the instruction is encountered (step ). If it is, then it is determined whether there are any more Ifs to emulate (step , ).","If the instruction being emulated is not a branch instruction as determined in step , a call is made to the guest kernel API, using a guest kernel API identifier and arguments (step ). The kernel API call is emulated (step ) and the kernel API Manager is invoked (step ) as shown in the flowchart of  illustrating an exemplary embodiment of the API emulation subsystem. Control then passes back to step , where the next assembly instruction is emulated and the other steps are executed with respect to that next assembly instruction.","If at step  it is determined that there are more IFs to emulate, control returns to step , where the next IF is retrieved and the sequence described above is repeated. If there are no more IFs to emulate at step , the guest IF data is returned (step ). Then interface mapping is performed by retrieving and computing the equivalent host return data (step ). The host IF data is returned (step ) and control is returned to the host (step ).",{"@attributes":{"id":"p-0166","num":"0165"},"figref":"FIGS. 11A-11B","b":["1100","1102","1104","1114","1122","1124","1104"]},"If the retrieved instruction is a branch instruction (step ), the branch is evaluated at step . If it is a jump instruction or a conditional jump (Jcc) instruction, the target instruction is retrieved (step ). If it is a conditional jump (Jcc) instruction, the jump condition is evaluated first. If the branch instruction at step  is an internal function call instruction, the called internal function disassembly is retrieved (step ) and control returns to step . If the branch instruction at step  is an external function call, the external call is defined by a kernel API function identifier and arguments (step ). Then, the generic driver core () is called (step ) to inform it that a kernel API has been called so it takes the necessary action before instruction emulation is resumed, and then control returns to step  to retrieve the next instruction.","If at step , the branch instruction is a return instruction, it is determined whether it is a return to an interface or an internal function (step ). If it is an internal function, control returns to step  to retrieve the next instruction. If it is an interface return, control returns to the generic driver core () (step ) to inform the generic driver core that the requested action (to emulate a particular function) has been completed.",{"@attributes":{"id":"p-0169","num":"0168"},"figref":"FIGS. 12A-12B","b":["1200","1202"]},"If the called function is available, host compatible guest parameters are defined (step ). if the called function is available, but a deprecated or new version exists, the equivalent API function is retrieved at step . Then the host compatible guest parameters are defined in step . After defining the host compatible guest parameter in step , a parameter evaluation and update is performed (step ). During this process, the program checks for any security flaws and updates any completion addresses to point to the generic driver functions. Host modified parameters are defined (step ) and the host kernel API function is called (step ). The guest return value, equal to the host return value is determined (step ) and control is then returned to the generic driver core () (step ).","If the called function is available in a deprecated or newer version (step ), the equivalent API function is obtained and control passes to step . If the function is not available, guest parameters that are not host compatible are defined (step ). The API function is then emulated (step ). This emulation is done according to the API function's documented specification and\/or source code. This is similar to NDISWrapper, LibUSB and other similar programs. The guest operating system subsystem is then emulated (step ). The guest return value (not host compatible) is then determined (step ). A host compatible return value is created based on the guest return value (step ). The host compatible return value is returned (step ) and control is then returned to the generic driver (step ).","The present invention can be configured to work in a network environment that includes a computer that is in communication, via a communications network, with one or more devices. The computer may communicate with the devices directly or indirectly, via a wired or wireless medium such as the Internet, LAN, WAN or Ethernet, Token Ring, or via any appropriate communications means or combination of communications means. Each of the devices may comprise computers, such as those based on the Intel\u00ae Pentium\u00ae or Centrino\u00ae processors, which are configured to communicate with the computer. Any number and type of machines may be in communication with the computer.",{"@attributes":{"id":"p-0173","num":"0172"},"figref":["FIG. 13","FIG. 1"],"b":["1","3","4","2","5","6","9","7","7","8","10","13","12","4","9","8"]},{"@attributes":{"id":"p-0174","num":"0173"},"figref":["FIGS. 14-16","FIG. 5","FIG. 14","FIG. 15","FIG. 16","FIG. 17"],"b":["500","540","560","560"]},"In order to implement the Sys File Parser (), Microsoft's PE-COFF-32 specification was used as a guideline in a test implementation of the invention. This specification is available from Microsoft\u00ae at msdn.microsoft.com\/en-us\/windows\/hardware\/gg463119. PE-COFF is an acronym for Portable Executable (PE) and Common Object File Format (COFF) files, respectively. The specification describes the structure of executable (image) files and object files under the WINDOWS\u00ae family of operating systems. As with other embodiments described herein, this is provided by way of example only, and is not intended to be the only way of implementing the functions described herein. Other ways are possible, within the skill of the ordinary artisan.","The extraction of static data by the PE-32 parser () and the X86 disassembler () will now be described (see ). Both are standard processes, and were re-written according to an exemplary embodiment of the invention to store the output in xml format. In order to implement the PE-32 parser, Microsoft's PE-COFF-32 specification was used as a guideline.","When parsing a driver's compiled \u2018sys\u2019 file (), once all headers section are parsed, one has an idea of which PE tables are present within the driver (PE information ). At least one section will always be the code section (), and other section such as the init section can also contain code. The presence of code within sections () is determined through section characteristics flags within the section headers (). Other sections will contain standard PE tables (sys file sections information ). As shown in , as many as 16 such tables () can be present.","However, after testing the headers of the two main test drivers as well as all the sys files currently within the test machine's drivers folder during the test implementation, it was found that typical drivers only contain the tables that are highlighted with larger text in the figure (import table -, export table -, certificate table -, base relocation table -, and import address table -). The format and specifications for those tables are known in the art. A number of drivers contained a certificate table (-), a resources table (-) and a debug section (-). Other tables included an exception table (-), an architecture section (-), a global pointer section (-), a thread local storage table (-), a load configuration table (-), a bound import table (-), a delay import descriptor table (-), a CLR runtime header (-), and a reserved table (-). Basic handling was implemented within the parser () but not all detail was extracted since it is not needed for an understanding of the present invention.","One note about the base relocation table (-): although the guest device driver () will never be loaded on the host operating system () using the described approach, this section is very important to obtain the addresses of important place-holders, such as any virtual addresses stored within the driver's code branch instructions.","Once all relevant PE information has been extracted in to the parsed PE file (), the x86 disassembler () is called as shown in . It goes through the code section (), starting from the Driver Entry\u2014which is part of the PE Information ()\u2014using the algorithm described in the above description. By the end of this process, all relevant static information would have been extracted from the device driver ().","To model the driver's code and interfaces, through the static analysis tools just described, 2 out of the 3 elements of platform interface information that one needs to implement the invention are already in hand. These are: 1) the processor instructions used by the driver (disassembled driver )\u2014obtained through the X86 code disassembler (); and 2) the kernel API functions called by the driver\u2014obtained through the PE information () in the parsed PE file (). The final needed element is the driver's primary entry points, i.e., interface functions. These are a must, when later on the GDI receives calls\u2014on behalf of the guest driver\u2014from the kernel, it will know which functions it should interpret. Such information cannot be obtained 100% statically, and is obtained by emulating the Driver_Entry function. It is standard in WDM drivers that within the Driver_Entry function, the Driver Object structure is filled up with the virtual addresses of the driver's Primary Entry Points\u2014the Add_Device, Unload and any Dispatch Routines.  gives an overview of the state of the guest driver representation after its primary interface function are identified.","Finally, the internal disassembled code within each function is modeled in terms of local code snippets through the code semantics analyzer ().  gives an example of how a function is represented within the described exemplary model. As it can be seen from , every snippet (-, -) contains a sequence of local instructions (-, -), and a branch representation (-, -). A local instruction is any x86 non-branching assembly instruction. There at least 5 standard branch instructions\u2014application program interface (-, -) (API), function call (-) (CALL), unconditional jump (-) (JMP), conditional jump (-) (Jxx), and return to caller (-) (RETURN)\u2014or a branch Target (-), meaning that it refers to an address (-) that can be branched to by a JMP or Jxx instruction. This had to be added for simplifying the implementation so that every jump branch points to the start of a snippet. The Return branch representation contains data about arguments (-) that need to be popped from the stack on return. For the API branch instructions, the target (-, -) is the program interface to which control is to be transferred. For the conditional jump (-) instruction, the target (-) is the individual snippet to which control is to be transferred if the condition is satisfied, and for the unconditional jump (-), the target (-) is also the snippet to which control is to be passed. The function call branch (-), having index () as its argument, calls function  (-), with snippet  (-) as its argument.  illustrates an exemplary embodiment of interfaces functions () that are modeled in the driver functions disassembly ().","At this stage all the relevant driver contents and properties are modeled. What is left now is to store all this information in a platform-independent and machine-understandable format. Standard XML was the natural choice for the following reasons: 1.) nested XML tags are ideal to store structural hierarchical data; 2) since strictly plain XML is being used\u2014no schemas, parameters within tags etc.\u2014storing and accessing such data can be definitely done on any platform using a miserly amount of resources; and 3) the learning effort for the notation we are using is almost none, and hence making it very easy for future improvements and additional plug-in tools to be implemented by third parties.",{"@attributes":{"id":"p-0184","num":"0183"},"figref":["FIG. 17","FIG. 15"],"b":["1700","1702","1704","1706","1708","520","1710","1712","1714","1716","1718"]},"It will be readily apparent that the various methods and algorithms described herein may be implemented by, e.g., appropriately programmed general purpose computers and computing devices. Typically a processor (e.g., one or more microprocessors) will receive instructions from a memory or like device, and execute those instructions, thereby performing one or more processes defined by those instructions. Further, programs that implement such methods and algorithms may be stored and transmitted using a variety of media in a number of manners. In some embodiments, hard-wired circuitry or custom hardware may be used in place of, or in combination with, software instructions for implementation of the processes of various embodiments. Thus, embodiments are not limited to any specific combination of hardware and software, except as otherwise explicitly stated.","A \u201cprocessor\u201d means any one or more microprocessors, central processing units (CPUs), computing devices, microcontrollers, digital signal processors, or like devices.","The term \u201ccomputer-readable medium\u201d refers to any non-transitory medium that participates in providing data (e.g., instructions) which may be read by a computer, a processor or a like device. Such a medium may take many forms, including but not limited to, non-volatile media, volatile media, and transmission media. Non-volatile media include, for example, optical or magnetic disks and other persistent memory. Volatile media include dynamic random access memory (DRAM), which typically constitutes the main memory. Transmission media include coaxial cables, copper wire and fiber optics, including the wires that comprise a system bus coupled to the processor. Transmission media may include or convey acoustic waves, light waves and electromagnetic emissions, such as those generated during radio frequency (RF) and infrared (IR) data communications. Common forms of computer-readable media include, for example, a floppy disk, a flexible disk, hard disk, magnetic tape, any other magnetic medium, a CD-ROM, any other memory chip or cartridge, or any other medium from which a computer can read.","Various forms of computer readable media may be involved in carrying sequences of instructions to a processor. For example, sequences of instruction (i) may be delivered from RAM to a processor, (ii) may be carried over a wireless transmission medium, and\/or (iii) may be formatted according to numerous formats, standards or protocols, such as Bluetooth, TDMA, CDMA, 3G.","Although various features of the invention have been described with particular embodiments. It is considered within one of ordinary skill in the art to mix and match the features in other embodiments not depicted in the figures.","The foregoing description of the specific embodiments will so fully reveal the general nature of the invention that others can, by applying current knowledge, readily modify and\/or adapt for various applications such specific embodiments without undue experimentation and without departing from the generic concept, and, therefore, such adaptations and modifications should and are intended to be comprehended within the meaning and range of equivalents of the disclosed embodiments. It is to be understood that the phraseology or terminology employed herein is for the purpose of description and not of limitation. The means, materials, and steps for carrying out various disclosed functions may take a variety of alternative forms without departing from the invention.","Thus the expressions \u201cmeans to . . . \u201d and \u201cmeans for . . . \u201d, or any method step language, as may be found in the specification above and\/or in the claims below, followed by a functional statement, are intended to define and cover whatever structural, physical, chemical or electrical element or structure, or whatever method step, which may now or in the future exist which carries out the recited function, whether or not precisely equivalent to the embodiment or embodiments disclosed in the specification above, i.e., other means or steps for carrying out the same functions can be used; and it is intended that such expressions be given their broadest interpretation."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For better understanding of the invention and additional objects and advantages thereof, reference is made to the following detailed description and accompanying drawings of embodiments.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIGS. 10A-10D"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIGS. 11A-11B"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIGS. 12A-12B"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 18"}]},"DETDESC":[{},{}]}
