---
title: Mechanism for loading plugin classes at an appropriate location in the class loader hierarchy
abstract: A set of plug-in class loaders is provided in the class loader hierarchy. A plug-in class loader is provided for each class loader in the plug-in application's class loader hierarchy. Each plug-in class loader is associated with a single application class loader and is configured such that it delegates to its associated application class loader. All plug-in class loaders are also configured with a class path such that they may load plug-in classes from a directory that is specified within a configuration file. The loading of all plug-in classes is initiated by the application using the plug-in class loaders.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07434215&OS=07434215&RS=07434215
owner: International Business Machines Corporation
number: 07434215
owner_city: Armonk
owner_country: US
publication_date: 20030911
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["1. Technical Field","The present invention relates to data processing and, in particular, to class loaders in a Java virtual machine. Still more particularly, the present invention provides a method, apparatus, and program for loading plug-in classes at an appropriate location in the class loader hierarchy.","2. Description of Related Art","Many applications allow functionality to be extended through plug-ins. For example, a Web server application may be extended with an encryption plug-in. Plug-ins are application extensions that are registered to the application through a registry or configuration file. It is the job of the application to load the appropriate plug-ins and invoke them at the appropriate times during the application life cycle.","In environments where a class loader is used to load a class (i.e. Java), the application must determine which class loader to use to initiate the loading of the plug-in classes. If the application uses the class loader that loaded the application classes to initiate the loading of the plug-in classes, this can pose several problems. To use the application's class loader structure to load plug-in classes may require the class path to be modified such that the application class loader can load the plug-in classes. This may be difficult to accomplish due to various factors, such as security, customized class loaders, and remote location of classes.","Furthermore, the manner in which the class path can be modified varies from application to application, and even within the application depending on the class loader that is used. There is no generic manner in which any or all class loaders can be configured to load the plug-in classes. Yet another problem can be encountered if the class loader delegation model is properly followed by the application's class loaders and multiple different class loaders are used to load application classes.","Therefore, it would be advantageous to provide an improved mechanism for loading plug-in classes at an appropriate location in the class loader hierarchy.","The present invention provides a set of plug-in class loaders in the class loader hierarchy. A plug-in class loader is provided for each class loader in the plug-in application's class loader hierarchy. Each plug-in class loader is associated with a single application class loader and is configured such that it delegates to its associated application class loader. All plug-in class loaders are also configured with a class path such that they may load plug-in classes from a directory that is specified within a configuration file. The loading of all plug-in classes is initiated by the application using the plug-in class loaders.","The present invention provides a mechanism for an application to initiate loading of plug-in classes at appropriate locations within a class loader hierarchy within a virtual machine. The mechanisms of the present invention may be employed in a computing device, such as a stand-alone computer, a client device, or a server. The mechanisms of the present invention may also be employed within a Java Runtime Environment using a Java Virtual Machine. As such, in order to provide a context for the description of the operational components of the present invention, a brief description of a data processing system is provided hereafter with reference to . A brief description of a Java Runtime Environment and, more particularly, a Java Virtual Machine is provided with reference to .","With reference now to the figures and in particular with reference to , a pictorial representation of a data processing system in which the present invention may be implemented is depicted in accordance with a preferred embodiment of the present invention. A computer  is depicted which includes system unit , video display terminal , keyboard , storage devices , which may include floppy drives and other types of permanent and removable storage media, and mouse . Additional input devices may be included with personal computer , such as, for example, a joystick, touchpad, touch screen, trackball, microphone, and the like.","Computer  can be implemented using any suitable computer, such as an IBM eServer computer or IntelliStation computer, which are products of International Business Machines Corporation, located in Armonk, N.Y. Although the depicted representation shows a computer, other embodiments of the present invention may be implemented in other types of data processing systems, such as a network computer. Computer  also preferably includes a graphical user interface (GUI) that may be implemented by means of systems software residing in computer readable media in operation within computer .","With reference now to , a block diagram of a data processing system is shown in which the present invention may be implemented. Data processing system  is an example of a computer, such as computer  in , in which code or instructions implementing the processes of the present invention may be located. Data processing system  employs a peripheral component interconnect (PCI) local bus architecture. Although the depicted example employs a PCI bus, other bus architectures such as Accelerated Graphics Port (AGP) and Industry Standard Architecture (ISA) may be used. Processor  and main memory  are connected to PCI local bus  through PCI bridge . PCI bridge  also may include an integrated memory controller and cache memory for processor . Additional connections to PCI local bus  may be made through direct component interconnection or through add-in boards.","In the depicted example, local area network (LAN) adapter , small computer system interface SCSI host bus adapter , and expansion bus interface  are connected to PCI local bus  by direct component connection. In contrast, audio adapter , graphics adapter , and audio\/video adapter  are connected to PCI local bus  by add-in boards inserted into expansion slots. Expansion bus interface  provides a connection for a keyboard and mouse adapter , modem , and additional memory . SCSI host bus adapter  provides a connection for hard disk drive , tape drive , and CD-ROM drive . Typical PCI local bus implementations will support three or four PCI expansion slots or add-in connectors.","An operating system runs on processor  and is used to coordinate and provide control of various components within data processing system  in . The operating system may be a commercially available operating system such as Windows XP, which is available from Microsoft Corporation. An object oriented programming system such as Java may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system . \u201cJava\u201d is a trademark of Sun Microsystems, Inc. Instructions for the operating system, the object-oriented programming system, and applications or programs are located on storage devices, such as hard disk drive , and may be loaded into main memory  for execution by processor .","Those of ordinary skill in the art will appreciate that the hardware in  may vary depending on the implementation. Other internal hardware or peripheral devices, such as flash read-only memory (ROM), equivalent nonvolatile memory, or optical disk drives and the like, may be used in addition to or in place of the hardware depicted in . Also, the processes of the present invention may be applied to a multiprocessor data processing system.","For example, data processing system , if optionally configured as a network computer, may not include SCSI host bus adapter , hard disk drive , tape drive , and CD-ROM . In that case, the computer, to be properly called a client computer, includes some type of network communication interface, such as LAN adapter , modem , or the like. As another example, data processing system  may be a stand-alone system configured to be bootable without relying on some type of network communication interface, whether or not data processing system  comprises some type of network communication interface. As a further example, data processing system  may be a personal digital assistant (PDA), which is configured with ROM and\/or flash ROM to provide non-volatile memory for storing operating system files and\/or user-generated data.","The depicted example in  and above-described examples are not meant to imply architectural limitations. For example, data processing system  also may be a notebook computer or hand held computer in addition to taking the form of a PDA. Data processing system  also may be a kiosk or a Web appliance.","The processes of the present invention are performed by processor  using computer implemented instructions, which may be located in a memory such as, for example, main memory , memory , or in one or more peripheral devices -.","With reference now to , a block diagram illustrates the relationship of software components operating within a computer system that may implement the present invention. Java-supporting system  contains platform specific operating system  that provides hardware and system support to software executing on a specific hardware platform. Java virtual machine (JVM)  is one software application that may execute in conjunction with the operating system. JVM  provides a Java run-time environment with the ability to execute Java application or applet , which is a program, servlet, or software component written in the Java programming language. The computer system in which JVM  operates may be similar to data processing system  or computer  described above. However, JVM  may be implemented in dedicated hardware on a so-called Java chip, Java-on-silicon, or Java processor with an embedded picoJava core.","At the center of a Java run-time environment is the JVM, which supports all aspects of Java's environment, including its architecture, security features, mobility across networks, and platform independence. The JVM is a virtual computer, i.e. a computer that is specified abstractly. The specification defines certain features that every JVM must implement, with some range of design choices that may depend upon the platform on which the JVM is designed to execute. For example, all JVMs must execute Java bytecodes and may use a range of techniques to execute the instructions represented by the bytecodes. A JVM may be implemented completely in software or somewhat in hardware. This flexibility allows different JVMs to be designed for mainframe computers and PDAs.","The JVM is the name of a virtual computer component that actually executes Java programs. Java programs are not run directly by the central processor but instead by the JVM, which is itself a piece of software running on the processor. The JVM allows Java programs to be executed on a different platform as opposed to only the one platform for which the code was compiled. Java programs are compiled for the JVM. In this manner, Java is able to support applications for many types of data processing systems, which may contain a variety of central processing units and operating systems architectures.","To enable a Java application to execute on different types of data processing systems, a compiler typically generates an architecture-neutral file format\u2014the compiled code is executable on many processors, given the presence of the Java run-time system. The Java compiler generates bytecode instructions that are nonspecific to a particular computer architecture. A bytecode is a machine independent code generated by the Java compiler and executed by a Java interpreter. A Java interpreter is part of the JVM that alternately decodes and interprets a bytecode or bytecodes. These bytecode instructions are designed to be easy to interpret on any computer and easily translated on the fly into native machine code. Byte codes may be translated into native code by a just-in-time compiler or JIT.","A JVM loads class files and executes the bytecodes within them. The class files are loaded by a class loader in the JVM. A class loader loads class files from an application and the class files from the Java application programming interfaces (APIs), which are needed by the application. The execution engine that executes the bytecodes may vary across platforms and implementations.","One type of software-based execution engine is a just-in-time compiler. With this type of execution, the bytecodes of a method are compiled to native machine code upon successful fulfillment of some type of criteria for jitting a method. The native machine code for the method is then cached and reused upon the next invocation of the method. The execution engine may also be implemented in hardware and embedded on a chip so that the Java bytecodes are executed natively. JVMs usually interpret bytecodes, but JVMs may also use other techniques, such as just-in-time compiling, to execute bytecodes.","When an application is executed on a JVM that is implemented in software on a platform-specific operating system, a Java application may interact with the host operating system by invoking native methods. A Java method is written in the Java language, compiled to bytecodes, and stored in class files. A native method is written in some other language and compiled to the native machine code of a particular processor. Native methods are stored in a dynamically linked library whose exact form is platform specific.","With reference now to , a block diagram of a JVM is depicted in accordance with a preferred embodiment of the present invention. JVM  includes a class loader subsystem , which is a mechanism for loading types, such as classes and interfaces, given fully qualified names. JVM  also contains runtime data areas , execution engine , native method interface , and memory management . Execution engine  is a mechanism for executing instructions contained in the methods of classes loaded by class loader subsystem . Execution engine  may be, for example, Java interpreter  or just-in-time compiler . Native method interface  allows access to resources in the underlying operating system. Native method interface  may be, for example, a Java native interface. Runtime data areas  contain native method stacks , Java stacks , PC registers , method area , and heap . These different data areas represent the organization of memory needed by JVM  to execute a program.","Java stacks  are used to store the state of Java method invocations. When a new thread is launched, the JVM creates a new Java stack for the thread. The JVM performs only two operations directly on Java stacks: it pushes and pops frames. A thread's Java stack stores the state of Java method invocations for the thread. The state of a Java method invocation includes its local variables, the parameters with which it was invoked, its return value, if any, and intermediate calculations.","Java stacks are composed of stack frames. A stack frame contains the state of a single Java method invocation. When a thread invokes a method, the JVM pushes a new frame onto the Java stack of the thread. When the method completes, the JVM pops the frame for that method and discards it. The JVM does not have any registers for holding intermediate values; any Java instruction that requires or produces an intermediate value uses the stack for holding the intermediate values. In this manner, the Java instruction set is well-defined for a variety of platform architectures.","PC registers  are used to indicate the next instruction to be executed. Each instantiated thread gets its own PC register (program counter) and Java stack. If the thread is executing a JVM method, the value of the pc register indicates the next instruction to execute. If the thread is executing a native method, then the contents of the pc register are undefined. Native method stacks  store the state of invocations of native methods. The state of native method invocations is stored in an implementation-dependent way in native method stacks, registers, or other implementation-dependent memory areas. In some JVM implementations, native method stacks  and Java stacks  are combined.","Method area  contains class data while heap  contains all instantiated objects. The JVM specification strictly defines data types and operations. Most JVMs choose to have one method area and one heap, each of which are shared by all threads running inside the JVM. When the JVM loads a class file, it parses information about a type from the binary data contained in the class file. It places this type information into the method area.","Each time a class instance or array is created, the memory for the new object is allocated from heap . JVM  includes an instruction that allocates memory space within the memory for heap  but includes no instruction for freeing that space within the memory. Memory management  in the depicted example manages memory space within the memory allocated to heap . Memory management  may include a garbage collector, which automatically reclaims memory used by objects that are no longer referenced. Additionally, a garbage collector also may move objects to reduce heap fragmentation.","In environments where a class loader is used to load a class (i.e. Java), the application must determine which class loader to use to initiate the loading of plug-in classes. If the application uses the class loader that loaded the application classes to initiate the loading of the plug-in classes, this can pose several problems. To use the application's class loader structure to load plug-in classes may require the class path to be modified such that the application class loader can load the plug-in classes. This may be difficult to accomplish due to various factors, such as security, customized class loaders, and remote location of classes.","Furthermore, the manner in which the class path can be modified varies from application to application, and even within the application depending on the class loader that is used. There is no generic manner in which any or all class loaders can be configured to load the plug-in classes. For example, to modify the class path for the boot class loader, the Java system property \u201csun.boot.class.path\u201d must be modified. To modify the class path for the extension class loader, the Java system property \u201cjava.ext.dirs\u201d must be modified. And to modify the class path for the system class loader, the Java system property \u201cjava.class.path\u201d must be modified. There is no standard mechanism to modify the class path for any application specific class loaders and there may not even be a mechanism available if the application uses non-configurable hard coded information to create the class path.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIGS. 5A-5C","FIG. 5A"],"b":["1","502","2","504","510","520","530","510","520","530"]},"Another problem may be encountered if the class loader delegation model is properly followed by the application's class loaders and multiple different class loaders are used to load application classes. If, for example, there are two classes within an application that can call plug-ins, one loaded by the system class loader and the other by the boot class loader, then both the system class loader and the boot class loader must be configured to be able to load the plug-in classes. If such is the case, then the boot class loader will always be the one to load the plug-in classes, since the system class loader will delegate to the boot class loader.","This poses no problems for the plug-ins running for the application class that was loaded by the boot class loader; however, it poses problems for the plug-ins running for the application class that was loaded by the system class loader. Since a class can only have direct access to the classes that were loaded by its class loader and its class loader's parents, the plug-ins that run for the application class loaded by the system class loader will not have the ability to directly reference any of the application classes that were loaded by a class loader higher up in the hierarchy than the boot class loader. The plug-ins can still reference the application classes indirectly through reflection; however, this makes the plug-in code very difficult to understand and maintain.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 5B","b":["1","554","1","552","1","2","564","2","562","2","2","564","2","2"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 5C","b":["3","572","1","502","3","574","4","582","2","504","4","584","3","4","3","4"]},"To solve the above mentioned problems, the present invention provides a set of plug-in class loaders in the class loader hierarchy. A plug-in class loader is provided for each class loader in the class loader hierarchy. Each plug-in class loader is associated with a single application class loader and is configured such that it delegates to its associated application class loader. All plug-in class loaders are also configured with a class path such that they can load plug-in classes from a directory that is specified with a configuration file. The loading of all plug-in classes is initiated by the application using the plug-in class loaders. Plug-in classes may then be loaded either by the plug-in class loader itself or by one of the existing application class loaders to which the initiating plug-in class loader delegates.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIGS. 6A-6C","FIG. 6A"],"b":["1","602","2","604","610","620","630","610","620","630"]},"As stated above, the present invention provides a plug-in class loader for each existing application class loader. Plug-in class loader  is provided for and delegates to application class loader  . Plug-in class loader  is provided for and delegates to application class loader  . Similarly, plug-in class loader  is provided for and delegates to system class loader ; plug-in class loader  is provided for and delegates to extension class loader ; and, plug-in class loader  is provided for and delegates to boot class loader .","An application class uses the plug-in class loader that delegates to the application class loader that loaded the application class to initiate the loading of plug-in classes. To accomplish this, the present invention maintains a mapping of each application class loader to its associated plug-in class loader.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 6B","b":["1","652","1","654","1","1","2","662","2","2","664"]},"This solution does not require any modification to any of the existing application's class paths. The class loaders of the present invention simply require one configuration value to be specified in the application configuration file to provide the path where the plug-in class loaders should look for plug-in classes. The class loader hierarchy of the present invention provides a generic manner in which any application can be configured to load plug-in classes.","Also, since the previously existing class loader hierarchy need not be utilized to load the plug-in classes, the loading of a plug-in class Plug-In, for example, can be performed by the plug-in class loader for the system class loader and the Plug-In class has direct access to all classes to which the application class AppClass has access. This eliminates the need for reflection in the plug-in classes.","An application class may also be configured such that a specific plug-in class loader is targeted to be used to load a plug-in class. A configuration file may be modified such that a plug-in class is specified to be loaded at any point at or below the application class in the application class loader hierarchy. The load point is specified by providing the name of another class that would be loaded by the desired class loader. By allowing for plug-in classes to be loaded at a different context, data can be easily shared by different plug-ins by specifying that the application should load them at a common context.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 6C","b":["2","672","610","3","682","1","602","4","692","2","604","3","684","3","682","4","694","4","692","2"]},"Both Plug-In and Plug-In are loaded by the plug-in class loader of the system class loader, because the system class loader was used to load AppClass. Since Plug-In and Plug-In are both loaded by the same class loader in the same context, these two plug-in classes are able to share data. Therefore, the plug-in classes need not construct an alternate mechanism to obtain an object handle to an object or class loaded by an alternate class loader.","However, to use this mechanism to share data, the plug-in classes can no longer have direct access to the application classes that were loaded at the level of AppClass and AppClass. Therefore, the plug-in classes must use reflection to access their corresponding application classes.","The plug-in class loaders load plug-in classes from the directory specified in the application configuration file in the plug-in directory, as well as all archive and compressed files associated with that directory. The plug-in class loaders support dynamic updating of their class path. Therefore, if any additional archive or compressed files are added to the plug-in directory, the plug-in class loaders will dynamically update their class path to add the new files, The plug-in class loaders will also be able to load plug-in classes from the directory without requiring the application to be restarted. As new files are added and the class path is updated, the plug-in class loaders share a single class path across all instances of the plug-in class loaders to ensure that if multiple different application classes invoke the same plug-in, those plug-in instances are defined using the same class data.","With reference to , a flowchart is shown illustrating the operation of an application initiating the loading of a plug-in class in accordance with a preferred embodiment of the present invention. The process begins and the application gets the class loader that loaded the application class (step ). Then, the application gets the plug-in class loader for the class loader of the application class (step ). Finally, the application loads the plug-in class using the identified plug-in class loader (step ) and the process ends.","Turning to , a flowchart illustrating the operation of an application initiating the loading of a plug-in class in a specific context is shown in accordance with a preferred embodiment of the present invention. The process begins and the application gets the class loader that loaded the application class (step ). Then, using the class loader of the application class, the application looks up a target class (step ). The application then gets the class loader that loaded the target class (step ) and gets the plug-in class loader for the class loader of the target class (step ). Thereafter, the application loads the plug-in class using the identified plug-in class loader (step ) and the process ends.","Thus, the present invention solves the disadvantages of the prior art by providing a set of plug-in class loaders in a virtual machine. A plug-in class loader is provided for each class loader in the plug-in application's class loader hierarchy. Each plug-in class loader is associated with a single application class loader and is configured such that it delegates to its associated application class loader. Thus, the present invention provides a generic mechanism for any application to load plug-in classes at an appropriate level in the class loader hierarchy.","Also, all plug-in class loaders may be configured with a class path such that they may load plug-in classes from a directory that is specified within a configuration file. Therefore, the class loader hierarchy and exemplary aspects of the present invention allow new plug-in classes to be registered at runtime without requiring the application to restart.","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media, such as a floppy disk, a hard disk drive, a RAM, CD-ROMs, DVD-ROMs, and transmission-type media, such as digital and analog communications links, wired or wireless communications links using transmission forms, such as, for example, radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system.","The description of the present invention has been presented for purposes of illustration and description, and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 5A-5C"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 6A-6C"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
