---
title: Data distribution through capacity leveling in a striped file system
abstract: A data distribution technique is configured to provide capacity leveling in a striped file system. When a new node is added to a striped volume set, the striping table is evolved to accommodate the newly added node. Each node of a cluster is illustratively associated with a capacity value that takes into account, e.g., processor speed, number of processors, hardware configuration and/or software available for the node. During the evolution process of the striping table, the technique apportions stripes of the SVS among the nodes in a manner so that they are optimally assigned to the nodes in accordance with each node's capacity value. By utilizing the evolutionary striping table that incorporates capacity values, heterogeneous nodes may be utilized to their maximum capacity within a striped volume set, thereby reducing underutilized processing resources.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08117388&OS=08117388&RS=08117388
owner: NetApp, Inc.
number: 08117388
owner_city: Sunnyvale
owner_country: US
publication_date: 20090430
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS"],"p":["The present application is related to U.S. patent application Ser. No. 11\/119,278, filed on Apr. 29, 2005, entitled STORAGE SYSTEM ARCHITECTURE FOR STRIPING DATA CONTAINER CONTENT ACROSS VOLUMES OF A CLUSTER, now published as U.S. Publication No. US2005-0192932, on Sep. 1, 2005, by Richard Jernigan et al., the contents of which are hereby incorporated by reference.","The present invention relates to striped file systems and, more particularly, to capacity leveling across a plurality of nodes of a striped file system.","A storage system typically comprises one or more storage devices into which information may be entered, and from which information may be obtained, as desired. The storage system includes a storage operating system that functionally organizes the system by, inter alia, invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including, but not limited to, a network-attached storage (NAS) environment, a storage area network (SAN) and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array, wherein the term \u201cdisk\u201d commonly describes a self-contained rotating magnetic media storage device. The term disk in this context is synonymous with hard disk drive (HDD) or direct access storage device (DASD). It should be noted that in alternative embodiments, the storage devices may comprise solid state devices, e.g., flash memory, battery backed up non-volatile random access memory, etc. As such, while this description is written in terms of disks, those embodiments should be viewed as exemplary only.","The storage operating system of the storage system may implement a high-level module, such as a file system, to logically organize the information stored on volumes as a hierarchical structure of data containers, such as files and logical units. For example, each \u201con-disk\u201d file may be implemented as set of data structures, i.e., disk blocks, configured to store information, such as the actual data for the file. These data blocks are organized within a volume block number (vbn) space that is maintained by the file system. The file system may also assign each data block in the file a corresponding \u201cfile offset\u201d or file block number (fbn). The file system typically assigns sequences of fbns on a per-file basis, whereas vbns are assigned over a larger volume address space. The file system organizes the data blocks within the vbn space as a \u201clogical volume\u201d; each logical volume may be, although is not necessarily, associated with its own file system.","A known type of file system is a write-anywhere file system that does not overwrite data on disks. If a data block is retrieved (read) from disk into a memory of the storage system and \u201cdirtied\u201d (i.e., updated or modified) with new data, the data block is thereafter stored (written) to a new location on disk to optimize write performance. A write-anywhere file system may initially assume an optimal layout such that the data is substantially contiguously arranged on disks. The optimal disk layout results in efficient access operations, particularly for sequential read operations, directed to the disks. An example of a write-anywhere file system that is configured to operate on a storage system is the Write Anywhere File Layout (WAFL\u00ae) file system available from NetApp, Inc., Sunnyvale, Calif.","The storage system may be further configured to operate according to a client\/server model of information delivery to thereby allow many clients to access data containers stored on the system. In this model, the client may comprise an application, such as a database application, executing on a computer that \u201cconnects\u201d to the storage system over a computer network, such as a point-to-point link, shared local area network (LAN), wide area network (WAN), or virtual private network (VPN) implemented over a public network such as the Internet. Each client may request the services of the storage system by issuing file-based and block-based protocol messages (in the form of packets) to the system over the network.","A plurality of storage systems may be interconnected to provide a storage system environment configured to service many clients. Each storage system may be configured to service one or more volumes, wherein each volume stores one or more data containers. Yet often a large number of data access requests issued by the clients may be directed to a small number of data containers serviced by a particular storage system of the environment. A solution to such a problem is to distribute the volumes serviced by the particular storage system among all of the storage systems of the environment. This, in turn, distributes the data access requests, along with the processing resources needed to service such requests, among all of the storage systems, thereby reducing the individual processing load on each storage system. However, a noted disadvantage arises when only a single data container, such as a file, is heavily accessed by clients of the storage system environment. As a result, the storage system attempting to service the requests directed to that data container may exceed its processing resources and become overburdened, with a concomitant degradation of speed and performance.","One technique for overcoming the disadvantages of having a single data container that is heavily utilized is to stripe the data container across a plurality of volumes configured as a striped volume set, where each volume is serviced by a different storage system, thereby distributing the load for the single data container among a plurality of storage systems. One technique for data container striping is described in the above-incorporated U.S. Publication No. US2005-0192932, entitled STORAGE SYSTEM ARCHITECTURE FOR STRIPING DATA CONTAINER CONTENT ACROSS VOLUMES OF A CLUSTER. Typically, when the striped volume set is first generated, each of the constituent nodes servicing the constituent volumes of the striped volume set utilizes the same or similar generation technology. That is, each node typically comprises the same or substantially the same hardware and\/or software configurations. Thus, the nodes may be viewed as homogeneous as each is substantially identical to each other. A noted disadvantage of such systems arises when a striped volume set is expanded at a later point in time and a customer uses later (i.e., newer) generation hardware and\/or software for the newly added nodes. As the newly added nodes utilize the most up to date hardware and\/or software, they typically have additional computational power as compared to the original nodes of a cluster. More generally, this problem may be noted when any heterogeneous cluster is formed, that is, when the nodes of a cluster utilize systems having substantially different functionality and\/or processor capabilities. In such heterogeneous systems, each node is typically utilized an equal amount for striping operations. The noted disadvantage arises as later generation nodes may have additional processor capabilities that remain under or unutilized. The advantage of using new and\/or faster nodes is thus wasted as nodes are utilized, in effect, as if they were homogeneous to the least powerful node of a cluster, i.e., the original nodes. To avoid such a waste of processing power, a user must ensure that all nodes are of a common homogeneous type. This may be accomplished by, for example, purchasing older nodes or by replacing the older nodes with newer models. Both of these solutions are not optimal and raise the total cost of ownership of a clustered storage system.","The present invention overcomes the disadvantages of the prior art by providing a data distribution technique configured to provide capacity leveling in a striped file system. A striped volume set is associated with a set of striping rules including, e.g., a striping data structure that may be implemented, e.g., as a striping table that identifies an ordered list of volumes and associated nodes to which data is striped. Each node of the cluster includes a disk element adapted to servicing a volume of the SVS and a network element adapted to redirect a data access request to any de-module of the cluster. The content of a data container is apportioned among the volumes of the SVS to thereby improve the efficiency of storage service provided by the cluster. To that end, the striping table specifies the manner in which the data container content is apportioned as stripes across a plurality of volumes. In operation, when a new node is added to a striped volume set, the striping table is evolved to accommodate the newly added node. In an illustrative embodiment, each node of a cluster is associated with a capacity value that takes into account, e.g., processor speed, number of processors, hardware configuration and\/or software available for the node. During an evolution process of the striping table, the technique apportions stripes of the SVS among the nodes in a manner so that they are optimally assigned to the nodes in accordance with each node's capacity value. For example, in a two node system, with the first node having a capacity value of 100 and the second node having a capacity value of 200, twice as many stripes should be serviced by the second node as compared to the first node for optimal performance. By utilizing the evolutionary striping table that incorporates capacity values, heterogeneous nodes may be utilized to their maximum capacity within a striped volume set, thereby reducing underutilized processing resources.","A. Cluster Environment",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","b":["200","100","200","100","200","310","350","310","200","180","140","350","130","120","200","150","100","100","200"]},"The clients  may be general-purpose computers configured to interact with the node  in accordance with a client\/server model of information delivery. That is, each client may request the services of the node, and the node may return the results of the services requested by the client, by exchanging packets over the network . The client may issue packets including file-based access protocols, such as the Common Internet File System (CIFS) protocol or Network File System (NFS) protocol, over the Transmission Control Protocol\/Internet Protocol (TCP\/IP) when accessing information in the form of files and directories. Alternatively, the client may issue packets including block-based access protocols, such as the Small Computer Systems Interface (SCSI) protocol encapsulated over TCP (iSCSI) and SCSI encapsulated over Fibre Channel (FCP), when accessing information in the form of blocks.","B. Storage System Node",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 2","FIG. 11"],"b":["200","222","224","225","226","228","230","223","230","235","1100","226","200","100","226","100"],"i":"a,b"},"Each node  is illustratively embodied as a dual processor storage system executing a storage operating system  that preferably implements a high-level module, such as a file system, to logically organize the information as a hierarchical structure of named directories, files and special types of files called virtual disks (hereinafter generally \u201cblocks\u201d) on the disks. However, it will be apparent to those of ordinary skill in the art that the node  may alternatively comprise a single or more than two processor system. Illustratively, one processor executes the functions of the N-module  on the node, while the other processor executes the functions of the D-module .","The memory  illustratively comprises storage locations that are addressable by the processors and adapters for storing software program code and data structures associated with the present invention. The processor and adapters may, in turn, comprise processing elements and\/or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system , portions of which is typically resident in memory and executed by the processing elements, functionally organizes the node  by, inter alia, invoking storage operations in support of the storage service implemented by the node. It will be apparent to those skilled in the art that other processing and memory means, including various computer readable storage media including, e.g., flash memory, solid state storage, etc., may be used for storing and executing program instructions pertaining to the invention described herein.","The network adapter  comprises a plurality of ports adapted to couple the node  to one or more clients  over point-to-point links, wide area networks, virtual private networks implemented over a public network (Internet) or a shared local area network. The network adapter  thus may comprise the mechanical, electrical and signaling circuitry needed to connect the node to the network. Illustratively, the computer network  may be embodied as an Ethernet network or a Fibre Channel (FC) network. Each client  may communicate with the node over network  by exchanging discrete frames or packets of data according to pre-defined protocols, such as TCP\/IP.","The storage adapter  cooperates with the storage operating system  executing on the node  to access information requested by the clients. The information may be stored on any type of attached array of writable storage device media such as video tape, optical, DVD, magnetic tape, bubble memory, electronic random access memory, micro-electro mechanical and any other similar media adapted to store information, including data and parity information. However, as illustratively described herein, the information is preferably stored on the disks  of array . The storage adapter comprises a plurality of ports having input\/output (I\/O) interface circuitry that couples to the disks over an I\/O interconnect arrangement, such as a conventional high-performance, FC link topology.","Storage of information on each array  is preferably implemented as one or more storage \u201cvolumes\u201d that comprise a collection of physical storage disks  cooperating to define an overall logical arrangement of volume block number (vbn) space on the volume(s). Each logical volume is generally, although not necessarily, associated with its own file system. The disks within a logical volume\/file system are typically organized as one or more groups, wherein each group may be operated as a Redundant Array of Independent (or Inexpensive) Disks (RAID). Most RAID implementations, such as a RAID-4 level implementation, enhance the reliability\/integrity of data storage through the redundant writing of data \u201cstripes\u201d across a given number of physical disks in the RAID group, and the appropriate storing of parity information with respect to the striped data. An illustrative example of a RAID implementation is a RAID-4 level implementation, although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.","C. Storage Operating System","To facilitate access to the disks , the storage operating system  implements a write-anywhere file system that cooperates with one or more virtualization modules to \u201cvirtualize\u201d the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named directories and files on the disks. Each \u201con-disk\u201d file may be implemented as set of disk blocks configured to store information, such as data, whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization module(s) allow the file system to further logically organize information as a hierarchical structure of blocks on the disks that are exported as named logical unit numbers (luns).","In the illustrative embodiment, the storage operating system is preferably the NetApp\u00ae Data ONTAP\u00ae operating system available from NetApp, Inc., Sunnyvale, Calif. that implements a Write Anywhere File Layout (WAFL\u00ae) file system. However, it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such, where the term \u201cONTAP\u201d is employed, it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 3","b":["300","325","312","314","316","315","318","320","322","324","326","318","328","330","200"]},"In addition, the storage operating system includes a series of software modules organized to form a storage server  that provides data paths for accessing information stored on the disks  of the node . To that end, the storage server  includes a file system module  in cooperating relation with a volume striping module (VSM) , a RAID system module  and a disk driver system module . The RAID system  manages the storage and retrieval of information to and from the volumes\/disks in accordance with I\/O operations, while the disk driver system  implements a disk access protocol such as, e.g., the SCSI protocol. The VSM  illustratively implements a striped volume set (SVS). As described further herein, the VSM cooperates with the file system  to enable storage server  to service a volume of the SVS. In particular, the VSM  implements a Locate( ) function  to compute the location of data container content in the SVS volume to thereby ensure consistency of such content served by the cluster.","The file system  implements a virtualization system of the storage operating system  through the interaction with one or more virtualization modules illustratively embodied as, e.g., a virtual disk (vdisk) module (not shown) and a SCSI target module . The vdisk module enables access by administrative interfaces, such as a user interface of a management framework  (see ), in response to a user (system administrator) issuing commands to the node . The SCSI target module  is generally disposed between the FC and iSCSI drivers ,  and the file system  to provide a translation layer of the virtualization system between the block (lun) space and the file system space, where luns are represented as blocks.","The file system  is illustratively a message-based system that provides logical volume management capabilities for use in access to the information stored on the storage devices, such as disks. That is, in addition to providing file system semantics, the file system  provides functions normally associated with a volume manager. These functions include (i) aggregation of the disks, (ii) aggregation of storage bandwidth of the disks, and (iii) reliability guarantees, such as mirroring and\/or parity (RAID). The file system  illustratively implements the WAFL file system (hereinafter generally the \u201cwrite-anywhere file system\u201d) having an on-disk format representation that is block-based using, e.g., 4 kilobyte (KB) blocks and using index nodes (\u201cinodes\u201d) to identify files and file attributes (such as creation time, access permissions, size and block location). The file system uses files to store meta-data describing the layout of its file system; these meta-data files include, among others, an inode file. A file handle, i.e., an identifier that includes an inode number, is used to retrieve an inode from disk.","Broadly stated, all inodes of the write-anywhere file system are organized into the inode file. A file system (fs) info block specifies the layout of information in the file system and includes an inode of a file that includes all other inodes of the file system. Each logical volume (file system) has an fsinfo block that is preferably stored at a fixed location within, e.g., a RAID group. The inode of the inode file may directly reference (point to) data blocks of the inode file or may reference indirect blocks of the inode file that, in turn, reference data blocks of the inode file. Within each data block of the inode file are embedded inodes, each of which may reference indirect blocks that, in turn, reference data blocks of a file.","Operationally, a request from the client  is forwarded as a packet over the computer network  and onto the node  where it is received at the network adapter . A network driver (of layer  or layer ) processes the packet and, if appropriate, passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write-anywhere file system . Here, the file system generates operations to load (retrieve) the requested data from disk  if it is not resident \u201cin core\u201d, i.e., in memory . If the information is not in memory, the file system  indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system ; the logical vbn is mapped to a disk identifier and disk block number (disk,dbn) and sent to an appropriate driver (e.g., SCSI) of the disk driver system . The disk driver accesses the dbn from the specified disk  and loads the requested data block(s) in memory for processing by the node. Upon completion of the request, the node (and operating system) returns a reply to the client  over the network .","It should be noted that the software \u201cpath\u201d through the storage operating system layers described above needed to perform data storage access for the client request received at the node may alternatively be implemented in hardware. That is, in an alternate embodiment of the invention, a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array (FPGA) or an application specific integrated circuit (ASIC). This type of hardware implementation increases the performance of the storage service provided by node  in response to a request issued by client . Moreover, in another alternate embodiment of the invention, the processing elements of adapters ,  may be configured to offload some or all of the packet processing and storage access operations, respectively, from processor , to thereby increase the performance of the storage service provided by the node. It is expressly contemplated that the various processes, architectures and procedures described herein can be implemented in hardware, firmware or software.","As used herein, the term \u201cstorage operating system\u201d generally refers to the computer-executable code operable on a computer to perform a storage function that manages data access and may, in the case of a node , implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel, an application program operating over a general-purpose operating system, such as UNIX\u00ae or Windows NT\u00ae, or as a general-purpose operating system with configurable functionality, which is configured for storage applications as described herein.","In addition, it will be understood to those skilled in the art that the invention described herein may apply to any type of special-purpose (e.g., file server, filer or storage serving appliance) or general-purpose computer, including a standalone computer or portion thereof, embodied as or including a storage system. Moreover, the teachings of this invention can be adapted to a variety of storage system architectures including, but not limited to, a network-attached storage environment, a storage area network and disk assembly directly-attached to a client or host computer. The term \u201cstorage system\u201d should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write any where file system, the teachings of the present invention may be utilized with any suitable file system, including a write in place file system.","D. CF Protocol","In the illustrative embodiment, the storage server  is embodied as D-module  of the storage operating system  to service one or more volumes of array . In addition, the multi-protocol engine  is embodied as N-module  to (i) perform protocol termination with respect to a client issuing incoming data access request packets over the network , as well as (ii) redirect those data access requests to any storage server  of the cluster . Moreover, the N-module  and D-module  cooperate to provide a highly-scalable, distributed storage system architecture of the cluster . To that end, each module includes a cluster fabric (CF) interface module adapted to implement intra-cluster communication among the modules, including D-module-to-D-module communication for data container striping operations described herein.","The protocol layers, e.g., the NFS\/CIFS layers and the iSCSI\/FC layers, of the N-module  function as protocol servers that translate file-based and block based data access requests from clients into CF protocol messages used for communication with the D-module . That is, the N-module servers convert the incoming data access requests into file system primitive operations (commands) that are embedded within CF messages by the CF interface module  for transmission to the D-modules  of the cluster . Notably, the CF interface modules  cooperate to provide a single file system image across all D-modules  in the cluster . Thus, any network port of an N-module that receives a client request can access any data container within the single file system image located on any D-module  of the cluster.","Further to the illustrative embodiment, the N-module  and D-module  are implemented as separately-scheduled processes of storage operating system ; however, in an alternate embodiment, the modules may be implemented as pieces of code within a single operating system process. Communication between an N-module and D-module is thus illustratively effected through the use of message passing between the modules although, in the case of remote communication between an N-module and D-module of different nodes, such message passing occurs over the cluster switching fabric . A known message-passing mechanism provided by the storage operating system to transfer information between modules (processes) is the Inter Process Communication (IPC) mechanism. The protocol used with the IPC mechanism is illustratively a generic file and\/or block-based \u201cagnostic\u201d CF protocol that comprises a collection of methods\/functions constituting a CF application programming interface (API). Examples of such an agnostic protocol are the SpinFS and SpinNP protocols available from NetApp, Inc.","The CF interface module  implements the CF protocol for communicating file system commands among the modules of cluster . Communication is illustratively effected by the D-module exposing the CF API to which an N-module (or another D-module) issues calls. To that end, the CF interface module  is organized as a CF encoder and CF decoder. The CF encoder of, e.g., CF interface on N-module  encapsulates a CF message as (i) a local procedure call (LPC) when communicating a file system command to a D-module  residing on the same node  or (ii) a remote procedure call (RPC) when communicating the command to a D-module residing on a remote node of the cluster . In either case, the CF decoder of CF interface on D-module  de-encapsulates the CF message and processes the file system command.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 4","b":["400","400","150","100","400","402","404","406","408","410","100","410","400","310","350","408","406"]},"A data container, e.g., a file, is accessed in the file system using a data container handle.  is a schematic block diagram illustrating the format of a data container handle  including a SVS ID field , an inode number field , a unique-ifier field  a striped flag field  and a striping epoch number field . The SVS ID field  contains a global identifier (within the cluster ) of the SVS within which the data container resides. The inode number field  contains an inode number of an inode (within an inode file) pertaining to the data container. The unique-ifier field  contains a monotonically increasing number that uniquely identifies the data container handle . The unique-ifier is particularly useful in the case where an inode number has been deleted, reused and reassigned to a new data container. The unique-ifier distinguishes that reused inode number in a particular data container from a potentially previous use of those fields. The striped flag field  is illustratively a Boolean value that identifies whether the data container is striped or not. The striping epoch number field  indicates the appropriate striping technique for use with this data container for embodiments where the SVS utilizes differing striping techniques for different data containers.","E. File System Organization","In the illustrative embodiment, a data container is represented in the write-anywhere file system as an inode data structure adapted for storage on the disks .  is a schematic block diagram of an inode , which preferably includes a meta-data section  and a data section . The information stored in the meta-data section  of each inode  describes the data container (e.g., a file) and, as such, includes the type (e.g., regular, directory, vdisk)  of file, its size , time stamps (e.g., access and\/or modification time)  and ownership, i.e., user identifier (UID ) and group ID (GID ), of the file. The contents of the data section  of each inode may be interpreted differently depending upon the type of file (inode) defined within the type field . For example, the data section  of a directory inode contains meta-data controlled by the file system, whereas the data section of a regular inode contains file system data. In this latter case, the data section  includes a representation of the data associated with the file.","Specifically, the data section  of a regular on-disk inode may include file system data or pointers, the latter referencing 4 KB data blocks on disk used to store the file system data. Each pointer is preferably a logical vbn to facilitate efficiency among the file system and the RAID system  when accessing the data on disks. Given the restricted size (e.g., 128 bytes) of the inode, file system data having a size that is less than or equal to 64 bytes is represented, in its entirety, within the data section of that inode. However, if the length of the contents of the data container exceeds 64 bytes but less than or equal to 64 KB, then the data section of the inode (e.g., a first level inode) comprises up to 16 pointers, each of which references a 4 KB block of data on the disk.","Moreover, if the size of the data is greater than 64 KB but less than or equal to 64 megabytes (MB), then each pointer in the data section  of the inode (e.g., a second level inode) references an indirect block (e.g., a first level L1 block) that contains 1024 pointers, each of which references a 4 KB data block on disk. For file system data having a size greater than 64 MB, each pointer in the data section  of the inode (e.g., a third level L3 inode) references a double-indirect block (e.g., a second level L2 block) that contains 1024 pointers, each referencing an indirect (e.g., a first level L1) block. The indirect block, in turn, that contains 1024 pointers, each of which references a 4 KB data block on disk. When accessing a file, each block of the file may be loaded from disk  into the memory .","When an on-disk inode (or block) is loaded from disk  into memory , its corresponding in-core structure embeds the on-disk structure. For example, the dotted line surrounding the inode  indicates the in-core representation of the on-disk inode structure. The in-core structure is a block of memory that stores the on-disk structure plus additional information needed to manage data in the memory (but not on disk). The additional information may include, e.g., a \u201cdirty\u201d bit . After data in the inode (or block) is updated\/modified as instructed by, e.g., a write operation, the modified data is marked \u201cdirty\u201d using the dirty bit  so that the inode (block) can be subsequently \u201cflushed\u201d (stored) to disk.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 7","b":["700","224","360","702","704","705","706","700","704","130"]},"A file system layout is provided that apportions an underlying physical volume into one or more virtual volumes (or flexible volume) of a storage system, such as node . An example of such a file system layout is described in U.S. Pat. No. 7,409,494, titled EXTENSION OF WRITE ANYWHERE FILE SYSTEM LAYOUT, by John K. Edwards et al., now issued on Aug. 5, 2008, and assigned to NetApp, Inc. The underlying physical volume is an aggregate comprising one or more groups of disks, such as RAID groups, of the node. The aggregate has its own physical volume block number (pvbn) space and maintains meta-data, such as block allocation structures, within that pvbn space. Each flexible volume has its own virtual volume block number (vvbn) space and maintains meta-data, such as block allocation structures, within that vvbn space. Each flexible volume is a file system that is associated with a container file; the container file is a file in the aggregate that contains all blocks used by the flexible volume. Moreover, each flexible volume comprises data blocks and indirect blocks that contain block pointers that point at either other indirect blocks or data blocks.","In one embodiment, pvbns are used as block pointers within buffer trees of files (such as file ) stored in a flexible volume. This \u201chybrid\u201d flexible volume embodiment involves the insertion of only the pvbn in the parent indirect block (e.g., inode or indirect block). On a read path of a logical volume, a \u201clogical\u201d volume (vol) info block has one or more pointers that reference one or more fsinfo blocks, each of which, in turn, points to an inode file and its corresponding inode buffer tree. The read path on a flexible volume is generally the same, following pvbns (instead of vvbns) to find appropriate locations of blocks; in this context, the read path (and corresponding read performance) of a flexible volume is substantially similar to that of a physical volume. Translation from pvbn-to-disk,dbn occurs at the file system\/RAID system boundary of the storage operating system .","In one dual vbn hybrid flexible volume embodiment, both a pvbn and its corresponding vvbn are inserted in the parent indirect blocks in the buffer tree of a file. That is, the pvbn and vvbn are stored as a pair for each block pointer in most buffer tree structures that have pointers to other blocks, e.g., level 1 (L1) indirect blocks, inode file level 0 (L0) blocks.  is a schematic block diagram of an illustrative embodiment of a buffer tree of a file  that may be advantageously used with the present invention. A root (top-level) inode , such as an embedded inode, references indirect (e.g., level 1) blocks . Note that there may be additional levels of indirect blocks (e.g., level 2, level 3) depending upon the size of the file. The indirect blocks (and inode) contain pvbn\/vvbn pointer pair structures  that ultimately reference data blocks  used to store the actual data of the file.","The pvbns reference locations on disks of the aggregate, whereas the vvbns reference locations within files of the flexible volume. The use of pvbns as block pointers  in the indirect blocks  provides efficiencies in the read paths, while the use of vvbn block pointers provides efficient access to required meta-data. That is, when freeing a block of a file, the parent indirect block in the file contains readily available vvbn block pointers, which avoids the latency associated with accessing an owner map to perform pvbn-to-vvbn translations; yet, on the read path, the pvbn is available.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 9","b":["900","902","904","906","908","910","900","900","950","950","960","930"]},"Whereas the aggregate  is analogous to a physical volume of a conventional storage system, a flexible volume is analogous to a file within that physical volume. That is, the aggregate  may include one or more files, wherein each file contains a flexible volume  and wherein the sum of the storage space consumed by the flexible volumes is physically smaller than (or equal to) the size of the overall physical volume. The aggregate utilizes a physical pvbn space that defines a storage space of blocks provided by the disks of the physical volume, while each embedded flexible volume (within a file) utilizes a logical vvbn space to organize those blocks, e.g., as files. Each vvbn space is an independent set of numbers that corresponds to locations within the file, which locations are then translated to dbns on disks. Since the flexible volume  is also a logical volume, it has its own block allocation structures (e.g., active, space and summary maps) in its vvbn space.","A container file is a file in the aggregate that contains all blocks used by a flexible volume. The container file is an internal (to the aggregate) feature that supports a flexible volume; illustratively, there is one container file per flexible volume. Similar to a pure logical volume in a file approach, the container file is a hidden file (not accessible to a user) in the aggregate that holds every block in use by the flexible volume. The aggregate includes an illustrative hidden meta-data root directory that contains subdirectories of flexible volumes:\n\n","Specifically, a physical file system (WAFL) directory includes a subdirectory for each flexible volume in the aggregate, with the name of subdirectory being a file system identifier (fsid) of the flexible volume. Each fsid subdirectory (flexible volume) contains at least two files, a filesystem file and a storage label file. The storage label file is illustratively a 4 KB file that contains meta-data similar to that stored in a conventional raid label. In other words, the storage label file is the analog of a raid label and, as such, contains information about the state of the flexible volume such as, e.g., the name of the flexible volume, a universal unique identifier (uuid) and fsid of the flexible volume, whether it is online, being created or being destroyed, etc.",{"@attributes":{"id":"p-0074","num":"0074"},"figref":"FIG. 10","b":["1000","300","380","1000","1","2","1002","1002","1004","1004","1006","1010","1012","1014","1016","1006","1020","1030","1040","1090","1020","1030"]},"In addition to being embodied as a container file having level 1 blocks organized as a container map, the filesystem file  includes block pointers that reference various file systems embodied as flexible volumes . The aggregate  maintains these flexible volumes  at special reserved inode numbers. Each flexible volume  also has special reserved inode numbers within its flexible volume space that are used for, among other things, the block allocation bitmap structures. As noted, the block allocation bitmap structures, e.g., active map , summary map  and space map , are located in each flexible volume.","Specifically, each flexible volume  has the same inode file structure\/content as the aggregate, with the exception that there is no owner map and no WAFL\/fsid\/filesystem file, storage labelfile directory structure in a hidden meta-data root directory . To that end, each flexible volume  has a volinfo block  that points to one or more fsinfo blocks , each of which may represent a snapshot, along with the active file system of the flexible volume. Each fsinfo block, in turn, points to an inode file  that, as noted, has the same inode structure\/content as the aggregate with the exceptions noted above. Each flexible volume  has its own inode file  and distinct inode space with corresponding inode numbers, as well as its own root (fsid) directory  and subdirectories of files that can be exported separately from other flexible volumes.","The storage label file  contained within the hidden meta-data root directory  of the aggregate is a small file that functions as an analog to a conventional raid label. A raid label includes physical information about the storage system, such as the volume name; that information is loaded into the storage label file . Illustratively, the storage label file  includes the name  of the associated flexible volume , the online\/offline status  of the flexible volume, and other identity and state information  of the associated flexible volume (whether it is in the process of being created or destroyed).","F. VLDB",{"@attributes":{"id":"p-0079","num":"0079"},"figref":"FIG. 11","b":["1100","300","1110","1130","1150","1110","1170","200","100"]},"The VLDB  is a database process that tracks the locations of various storage components (e.g., SVSs, flexible volumes, aggregates, etc.) within the cluster  to thereby facilitate routing of requests throughout the cluster. In the illustrative embodiment, the N-module  of each node accesses a configuration table  that maps the SVS ID  of a data container handle  to a D-module  that \u201cowns\u201d (services) the data container within the cluster. The VLDB includes a plurality of entries which, in turn, provide the contents of entries in the configuration table ; among other things, these VLDB entries keep track of the locations of the flexible volumes (hereinafter generally \u201cvolumes \u201d) and aggregates  within the cluster. Examples of such VLDB entries include a VLDB volume entry  and a VLDB aggregate entry .",{"@attributes":{"id":"p-0081","num":"0081"},"figref":["FIG. 12","FIG. 13"],"b":["1200","1200","1205","1210","1215","1205","910","1210","900","1205","1300","1300","1305","1310","1315","1305","900","100","1310","1305"]},"The VLDB illustratively implements a RPC interface, e.g., a Sun RPC interface, which allows the N-module  to query the VLDB . When encountering contents of a data container handle  that are not stored in its configuration table, the N-module sends an RPC to the VLDB process. In response, the VLDB  returns to the N-module the appropriate mapping information, including an ID of the D-module that owns the data container. The N-module caches the information in its configuration table  and uses the D-module ID to forward the incoming request to the appropriate data container. All functions and interactions between the N-module  and D-module  are coordinated on a cluster-wide basis through the collection of management processes and the RDB library user mode applications .","To that end, the management processes have interfaces to (are closely coupled to) RDB . The RDB comprises a library that provides a persistent object store (storing of objects) for the management data processed by the management processes. Notably, the RDB  replicates and synchronizes the management data object store access across all nodes  of the cluster  to thereby ensure that the RDB database image is identical on all of the nodes . At system startup, each node  records the status\/state of its interfaces and IP addresses (those IP addresses it \u201cowns\u201d) into the RDB database.","G. Storage System Architecture","A storage system architecture is provided that illustratively comprises two or more volumes  distributed across a plurality of nodes  of cluster . The volumes are organized as a SVS and configured to store content of data containers, such as files and luns, served by the cluster in response to multi-protocol data access requests issued by clients . Notably, the content of each data container is apportioned among the volumes of the SVS to thereby improve the efficiency of storage service provided by the cluster. To facilitate a description and understanding of the present invention, data containers are hereinafter referred to generally as \u201cfiles\u201d.","The SVS comprises a meta-data volume (MDV) and one or more data volumes (DV). The MDV is configured to store a canonical copy of meta-data, including access control lists (ACLs) and directories, associated with all files stored on the SVS, whereas each DV is configured to store, at least, data content of those files. For each file stored on the SVS, one volume is designated the CAV and, to that end, is configured to store (\u201ccache\u201d) certain, rapidly-changing attribute meta-data associated with that file to thereby offload access requests that would otherwise be directed to the MDV. In one embodiment described herein, determination of the CAV for a file is based on a simple rule: designate the volume holding the first stripe of content (data) for the file as the CAV for the file. Not only is this simple rule convenient, but it also provides an optimization for small files. That is, a CAV may be able to perform certain operations without having to communicate with other volumes of the SVS if the file is small enough to fit within the specified stripe width. Ideally, the first stripes of data for files are distributed among the DVs of the SVS to thereby facilitate even distribution of CAV designations among the volumes of the SVS. In an alternate embodiment, data for files is striped across the MDV and the DVs. In a further alternative embodiment, a MDV may be eliminated, with the data normally contained on the MDV distributed among the DVs of a SVS.",{"@attributes":{"id":"p-0087","num":"0087"},"figref":"FIG. 14","b":["1400","1400","1405","1410","1415","1405","1420","1430","1425","1435","1445","1440","1405"]},"In contrast, each DV ,  stores only file (F) inodes , ,  and ACL inode . Note that DV does not store directories or other device inodes\/constructs, such as symbolic links; however, each DV does store F inodes, and may store cached copies of ACL inodes, that are arranged in the same locations as their respective inodes in the MDV . A particular DV may not store a copy of an inode until an I\/O request for the data container associated with the inode is received by the D-Module serving a particular DV. Moreover, the contents of the files denoted by these F inodes are periodically sparse according to SVS striping rules, as described further herein. In addition, since one volume is designated the CAV for each file stored on the SVS , DV  is designated the CAV for the file represented by inode  and DV  is the CAV for the files identified by inodes , . Accordingly, these CAVs cache certain, rapidly-changing attribute meta-data (M) associated with those files such as, e.g., file size , as well as access and\/or modification time stamps .","Illustratively, the SVS is associated with a set of striping rules that define a stripe algorithm, a stripe width and an ordered list of volumes within the SVS (a striping data structure that is illustratively implemented as a striping table). It should be noted that while the term striping table is used herein, it should be taken to mean any form of data structure that enables a VSM to identify the order in which data is to be striped on a SVS. The striping rules for each SVS are illustratively stored as an entry of VLDB  and accessed by SVS ID.  is a schematic block diagram of an exemplary VLDB SVS entry  in accordance with an embodiment of the present invention. The VLDB entry  includes a SVS ID field  and one or more sets of striping rules . In alternative embodiments additional fields  may be included. The SVS ID field  contains the ID of a SVS which, in operation, is specified in data container handle .","Each set of striping rules  illustratively includes a stripe width field , a stripe algorithm ID field , an ordered list of volumes field  and, in alternate embodiments, additional fields . The striping rules  contain information for identifying the organization of a SVS. For example, the stripe algorithm ID field  identifies a striping algorithm used with the SVS. In one embodiment, multiple striping algorithms could be used with a SVS; accordingly, stripe algorithm ID is needed to identify which particular algorithm is utilized. Each striping algorithm, in turn, specifies the manner in which file content is apportioned as stripes across the plurality of volumes of the SVS. The stripe width field  specifies the size\/width of each stripe.","The ordered list of volumes field  contains the IDs of the volumes comprising the SVS and serves as a striping table to determine data layout in a capacity leveled manner in accordance with an illustrative embodiment of the present invention. In an illustrative embodiment, the ordered list of volumes comprises a plurality of tuples comprising of a flexible volume ID and the aggregate ID storing the flexible volume. Moreover, the ordered list of volumes may specify the function and implementation of the various volumes and striping rules of the SVS. For example, the first volume in the ordered list may denote the MDV of the SVS, whereas the ordering of volumes in the list may denote the manner of implementing a particular striping algorithm, e.g., round-robin.","In operation, the set of striping rules effectively defines a striping table identifying an ordered set of D-modules to be utilized for storing blocks of a SVS. By apportioning the SVS among these various D-modules, the overall processing consumption of a single module is limited and therefore reduces the chance that a particular module may generate a backlog by, for example, becoming a hot spot.","A Locate( ) function  is provided that enables the VSM  and other modules (such as those of N-module ) to locate a D-module  and its associated volume of a SVS  in order to service an access request to a file. The Locate( ) function takes as arguments, at least (i) a SVS ID , (ii) an offset within the file, (iii) the inode number for the file and (iv) a set of striping rules , and returns the volume  on which that offset begins within the SVS . For example, assume a data access request directed to a file is issued by a client  and received at the N-module  of a node , where it is parsed through the multi-protocol engine  to the appropriate protocol server of N-module .","To determine the location of a D-module  to which to transmit a CF message , the N-module  may first retrieve a SVS entry  to acquire the striping rules  (and list of volumes ) associated with the SVS. The N-module  then executes the Locate( ) function  to identify the appropriate volume to which to direct an operation. Thereafter, the N-Module may retrieve the appropriate VLDB volume entry  to identify the aggregate containing the volume and the appropriate VLDB aggregate entry  to ultimately identify the appropriate D-module . The protocol server of N-module  then transmits the CF message  to the D-module .",{"@attributes":{"id":"p-0095","num":"0095"},"figref":"FIG. 16","b":["1605","1610","1615","1600","1515","1510","806","804"]},"In accordance with an illustrative round robin striping algorithm, volume A  contains a stripe of file content or data (D)  followed, in sequence, by two stripes of sparseness (S) , , another stripe of data (D)  and two stripes of sparseness (S) , . Volume B , on the other hand, contains a stripe of sparseness (S)  followed, in sequence, by a stripe of data (D) , two stripes of sparseness (S) , , another stripe of data (D)  and a stripe of sparseness (S) . Volume C  continues the round robin striping pattern and, to that end, contains two stripes of sparseness (S) ,  followed, in sequence, by a stripe of data (D) , two stripes of sparseness (S) ,  and another stripe of data (D) .","H. Capacity Leveling","The present invention provides a data distribution technique configured to provide capacity leveling in a striped file system. A striped volume set is associated with a set of striping rules including, e.g., a striping table  that identifies an ordered list of volumes and associated nodes to which data is striped. Each node of the cluster includes a disk element adapted to servicing a volume of the SVS and a network element adapted to redirect a data access request to any de-module of the cluster. The content of the data container is apportioned among the volumes of the SVS to thereby improve the efficiency of storage service provided by the cluster. To that end, the striping table specifies the manner in which the data container content is apportioned a stripes across a plurality of volumes. In operation, when a new node is added to a striped volume set, the striping table is evolved, i.e., iteratively updated, to accommodate the newly added node. In one embodiment, each node of a cluster is associated with a capacity value that takes into account, e.g., processor speed, number of processors, hardware configuration and\/or software available for the node. During an evolution process of the striping table, the technique apportions stripes of the SVS among the nodes in a manner so that they are optimally assigned to the nodes in accordance with each node's capacity value. For example, in a two node system, with the first node having a capacity value of 100 and the second node having a capacity value of 200, twice as many stripes should be serviced by the second node as compared to the first node for optimal performance. By utilizing the striping table described herein that incorporates capacity values, heterogeneous nodes, i.e., nodes with differing capacity values, may be better utilized within a striped volume set, thereby reducing underutilized processing resources. That is, nodes may be utilized without requiring higher capacity nodes to throttle their performance to the least powerful node in a cluster.",{"@attributes":{"id":"p-0099","num":"0099"},"figref":["FIG. 17","FIG. 16"],"b":["1700","1700","375","1700"]},{"@attributes":{"id":"p-0100","num":"0100"},"figref":"FIG. 18","b":["1800","1800","1805","1810","150"]},"Additionally, in accordance with one embodiment of the present invention, each of the newly added nodes of the cluster is assigned a capacity value, typically by the vendor (e.g., manufacturer) of the node. However, in alternative embodiments capacity values may be assigned by an administrator and\/or through and automated process. This capacity value may be provided to the volume striping module  of the nodes of the cluster to begin a striping table evolution technique described further below. In response to the addition of a new node, the striping table is evolved to accommodate the new node in step . Generally, the technique described herein evolves the striping table so that each node appears in approximate proportion to that node's capacity value divided by the total of all capacity values of nodes in the cluster (including the new node). That is, the approximate proportion of node X equals the capacity value of node X divided by the sum of all the capacity values of all nodes of the cluster. Evolution of a striping table is described further below in reference to .","Once the new striping table has been evolved, i.e., iteratively updated the new striping table is then associated with the SVS in step . Illustratively, a re-striping operation is then performed in step . A re-striping operation generally causes all data within the SVS to be re-allocated so that the data is striped in accordance with the evolved striping table, i.e., so that the data is distributed in accordance with the capacity leveling obtained from an embodiment of the present invention. It should be noted that performing a restriping operation is optional. In certain alternative embodiments, data may be re-striped as it is written to the striped volume set.","The procedure  completes in step .",{"@attributes":{"id":"p-0104","num":"0104"},"figref":["FIGS. 19A-19D","FIG. 19"]},{"@attributes":{"id":"p-0105","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"char"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"node A","100"]},{"entry":[{},"node B","200"]},{"entry":[{},"node C","50"]},{"entry":[{},"node D","50"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"As will be appreciated by one skilled in the art, the principles described in this illustrative example may be utilized with any number of the nodes having any number of differing and\/or identical capacity values. As such, the description herein of the evolution of striping table  should be taken as an exemplary only. In operation, a striping table is initially generated as a single entry table, such as that shown in . In a single node cluster, each stripe of data is stored on the single node of the cluster, i.e., node A in this example.","Illustratively, the administrator has configured the volume striping module to indicate that three additional nodes will be added, for a total of four nodes in the cluster. The volume striping module may then begin iteratively adding support for each entry. By first adding the entry for a new node, the volume striping module  considers the capacity value not only for the newly added entry but also for other all other entries to be represented within the striping table. By taking this into consideration, the correct number of occurrences of the node A in the striping table will result, which obviates the need to replace instances of node A during further iterations. In one embodiment, each node will appear in the striping table in approximate proportion to its capacity value divided by the sum of all of the capacity values of the nodes in the cluster.","Given the illustrative capacity values described above, the desired representation is equal to the capacity rating of A divided by the total capacity rating, i.e., A divided by A+B+C+D. Illustratively, this equals 100 divided by 400 (100+200+50+50). As such, the volume striping module replaces the number of entries of B+C+D (i.e., the total capacity value of the nodes to be added later) divided by the rating of A+B+C+D (i.e., the total of all of the capacity values), that is 300 out of every 400 entries in the first iteration. By performing mathematical reduction, the volume striping module determines that it is to replace three out of every four entries in the striping table with a B. Replacement within this group should be made by replacing entries of A with the new values of B. Illustratively, the selection of exactly which entries to replace is performed by a semi-static technique, such as that described in U.S. Pat. No. 7,185,144, entitled SEMI-STATIC DISTRIBUTION TECHNIQUE, the contents of which are hereby incorporated by reference.","The VSM  then repeats the iterative process by adding the next entry (i.e., entry C). Continuing this example, the volume striping module determines that it is to replace sufficient number of B's in the striping table while leaving the appropriate total number of B's. Again, this may be determined by dividing the rating of those that are to remain by the total rating. This would equal to the rating of C+D divided by the rating of B+C+D, which equals 100\/300. By reducing this fraction, the volume striping module has identified that one out of every three B's should be replaced with a C. The final iteration then replaces a sufficient number of C's with D. This number may be calculated by dividing the capacity value of D by the rating of C+D, which equates to every other C (i.e., \u00bd). As can be appreciated from , this results in a exemplary striping table that has eight references to node A, 16 references to node B, four references to node C and four references to node D.","As will be appreciated, this results in each node being appropriately apportioned based on their capacity ratings. Using node A as a reference, node D appears twice as frequently due to it having a capacity rating twice as large as node A, etc. By performing the iterative technique described herein, capacity leveling may be achieved to provide for optimal use of heterogeneous computers within a cluster.","The foregoing description has been directed to particular embodiments of this invention. It will be apparent, however, that other variations and modifications may be made to the described embodiments, with the attainment of some or all of their advantages. Specifically, it should be noted that the principles described herein may be implemented in non-distributed file systems. Furthermore, while this description has been written in terms of N and D-modules, the teachings herein are equally suitable to systems where the functionality of the N and D-modules are implemented in a single system. Alternately, the functions of the N and D-modules may be distributed among any number of separate systems, wherein each system performs one or more of the functions. Additionally, the procedures, processes and\/or modules described herein may be implemented in hardware, software, embodied as a computer-readable medium having program instructions, firmware, or a combination thereof. Therefore, it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The above and further advantages of invention may be better understood by referring to the following description in conjunction with the accompanying drawings in which like reference numerals indicate identical or functionally similar elements:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 19A-19D"}]},"DETDESC":[{},{}]}
