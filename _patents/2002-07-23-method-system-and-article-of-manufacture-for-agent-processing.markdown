---
title: Method, system, and article of manufacture for agent processing
abstract: Disclosed is a system, method, and article of manufacture for agent processing. In particular, an agent may be executed within an address space of an invoking process that invoked the agent or may be executed in a separate address space. While the agent is processing, the execution of the agent within the address space of the invoking process may be switched to execution of the agent within the separate address space. Similarly, while the agent is processing, the execution of the agent in the separate address space may be switched to execution of the agent in the address space of the invoking process. Moreover, if the invoking process terminates before completing processing, when the invoking process restarts, the invoking process redetermines which agents should be executed in separate address spaces based on information stored before the invoking process terminated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07103889&OS=07103889&RS=07103889
owner: Sun Microsystems, Inc.
number: 07103889
owner_city: Santa Clara
owner_country: US
publication_date: 20020723
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Additional Implementation Details"],"p":["1. Field of the Invention","The present invention is related to a method, system, and article of manufacture for agent processing.","2. Description of the Related Art","A client computer on which client applications run may be connected by a network, such as the Internet, to a server computer. The Internet is a world-wide collection of connected computer networks (i.e., a network of networks). The server computer may be connected to several low level devices. One type of low level device is a redundant array of independent disks (RAID). A RAID device enables storage of the same data on multiple hard disks, thus allowing simultaneous accesses to the copies of data.","When a client application desires to access a low level device to, for example, retrieve data about the low level device (e.g., whether the low level device is online and available for use or offline and not available for use), the client application submits a request for the data to, for example, the server computer connected to the low level device. The server computer generates a process to handle the client application's request. The process is assigned a portion of memory, which is referred to as the address space of the process.","Moreover, agents implemented in software at the server computer may be used to handle low level device interactions. An agent performs some function, such as retrieving data about a low level device. Thus, the server computer may generate an agent to fulfill the client application's request.","In many cases, the agents may access hardware or third party libraries that have unknown stability levels (e.g., crash often). In some systems, the agents run in the same address space as the process (e.g., a server process) that executed the agents. If agents are permitted to run within the same address space as a process, when one agent fails (e.g., because it is accessing an unstable device), the entire process fails and must be restarted. If the process generates multiple agents, then the failure of one agent causes the termination of all of the agents. This, of course, causes disruptions for a client application.","A Common Gateway Interface (CGI) is a specification for transferring information between a World Wide Web (\u201cWeb\u201d) server and a CGI program. A CGI program may send multiple CGI requests (i.e., requests from a CGI program) to a Web server. Each request is handled by a CGI process, and each CGI process uses a separate address space. For example, if three CGI processes are invoked, each CGI process has a separate address space, resulting in the use of three different address spaces.","FastCGI is a programming interface that can speed up Web applications that use the Common Gateway Interface (CGI). In particular, FastCGI is a plug-in to a Web server computer that processes CGI requests received from a client computer. FastCGI manages multiple CGI requests with a single process that uses a single address space. Thus, if three CGI requests are received a the server computer, one CGI process using one address space handles all three CGI requests.","Thus, there is a need in the art for improved agent execution.","Provided are a method, system, and for processing a request. Initially, an agent that may process the request is identified. Whether the agent should be executed within an address space of an invoking process that would invoke the agent or within a separate address space is determined. If it is determined that the agent should be executed within a separate address space, the agent is executed within a separate address space.","In certain implementations, there are multiple agents and an agent is identified from the group of agents.","In additional implementations, determining whether the agent should be executed within an address space of an invoking process or within a separate address space is based on information in a configuration file. The configuration file includes an indication of whether an agent should be executed in a separate address space, a group identifier, and an indication of when to launch the agent.","In yet other implementations, it is determined when the agent should be launched. In certain implementations, the agent is launched when the invoking process starts. In certain implementations, the agent is launched when the request is received.","In further implementations, an agent has a group identifier and it is determined whether the agent is part of a group of agents sharing the group identifier. In certain implementations, when an agent is part of the group of agents sharing the group identifier and when the agent is executed within the separate address space, each of the agents in the group of agents are executed within that separate address space.","In additional implementations, it is determined that the agent has failed. If the agent was executed within the separate address space, the agent is restarted.","In yet other implementations, an indication to switch the agent that is executing within a separate address space to the agent that is executing within the address space of the invoking process that invoked the agent is received. The agent that is to be switched is terminated and executed within the address space of the invoking process. In certain implementations, the agent is part of a group of agents and each of the agents in the group is terminated and executed within the address space of the invoking process that invoked the agent.","In further implementations, an indication to switch the agent that is executing within an address space of an invoking process that invoked the agent to an agent that is executing in the separate address space is received. The agent that is executing within the address space of a process that invoked the agent is quiesced and executed within the separate address space.","In additional implementations, when the invoking process that has invoked the agent is restarted, a determination is made of which agents are to be executed in one or more separate address spaces based on information stored by the invoking process before it was restarted. Then, those agents are executed in the one or more separate address spaces.","The described implementations of the invention provide a method, system, and for agent processing. In particular, an agent may be forked or threaded. The designation of an agent as forked or threaded may be switched while the agent is processing. Moreover, if a process terminates before completing processing, when the process restarts, the process redetermines which agents should be forked based on information stored before the process terminated.","In the following description, reference is made to the accompanying drawings which form a part hereof and which illustrate several implementations of the present invention. It is understood that other implementations may be utilized and structural and operational changes may be made without departing from the scope of the present invention.","In certain implementations of the invention, an agent may be executed within an address space of a process that is invoking the agent (an \u201cinvoking process\u201d) or may be executed within a secondary address space. When an agent is executed within an address space of a process that is invoking the agent, the agent is said to be a \u201cthreaded agent.\u201d When an agent is executed within a secondary address space, rather than the address space of the process that executed the agent, the agent is said to be a \u201cforked agent.\u201d","The invention provides a common infrastructure to enable agents to be executed either within the same address space of a server computer process that receives a request from a client computer or executed within a separate address space. In certain implementations, the designation of an agent as threaded or forked is based on run time configurable parameters. In certain implementations, the designation of an agent as threaded or forked is dynamically determined based on past execution history of the agent. The designation of an agent as threaded or forked may be changed while the agent is executing.","With implementations of this invention, a system administrator may designate an agent as threaded or forked. For example, if a system administrator knows (e.g., from past testing experience) that a particular agent often fails (i.e., is unstable), then the system administrator may designate this agent as a forked agent that executes within a separate address space, rather than within the address space of a process that invoked the agent. On the other hand, if an agent is known to often complete successfully (i.e., does not terminate often and is stable), then the system administrator may designate the agent as a threaded agent that executes within the address space of the process that invoked the agent. When an agent that is executed within the address space of the process that invoked the agent fails, the process is terminated and restarted. When an agent that is executed in a separate address space fails, the agent (rather than the process) is terminated and restarted. Since an agent that is unstable may be executed within a separate address space, while an agent that is stable may be executed within the address space of the process that invoked the stable agent, the process will be more stable (i.e., it is less likely that the process will be terminated and restarted).","In certain implementations, an agent manages a low level device (e.g., a RAID device). For example, the agent may retrieve data on the state of the low level device. The data may indicate, for example, whether the low level device is online or offline, the status of spindles or temperature sensors at the low level device, or the number of volumes in a RAID device. The agent may also change the low level device (e.g., take a volume of a RAID device offline). In certain implementations, the agent may retrieve data stored on the low level device.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 1A","b":["100","110","100","102","102","110"]},"The HTTP server  is connected to RAID devices , , and . The HTTP server  includes an operating system , such as a UNIX\u00ae operating system. The operating system  generates one or more processes to perform various functions. The client application A  sends requests to the HTTP server  to access RAID devices , , and\/or .",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 1B","FIG. 1C"],"b":["100","102","104","110","112","114","110","112","114","126","128","130","124","110","112","114","110","112","114","150","152","190"]},"In certain implementations, when the operating system  starts up, the operating system  invokes a primary process . The primary process  binds to uniform resource locators (URLS) (i.e., \u201cports\u201d) at the HTTP server . The primary process  may be a daemon. The primary process  may include an agent daemon  for servicing requests for agent services from client applications , , and .","The agent daemon  includes a main component  that starts up the agent daemon . The agent daemon  also includes a mapping to URLs , , and  at HTTP server  (which represents HTTP server  for the primary process). The agent daemon  also includes agent session managers . Agent session managers  includes session managers , , and  for managing agent proxies , , and . The agent proxies  and  are part of agent library , while agent proxy  is part of agent library . Each agent proxy , , and  manages a forked or threaded agent , , or . Threaded agent-N  is the nth agent. In certain implementations, the number of agents is set by a vendor who designed the agents. Each agent , , or  may be connected to a low level device, such as RAID devices , , and . In certain implementations, agents , , and  are written to an agent application programming interface (agent API). The agent API may be written in any programming language (e.g., a C language API or a Java language API). In , an agent proxy , , or  manages the interaction with the agent , , or  through the agent API.","An HTTP server  process communicates with a session manager , , or . The session manager , , or  communicates with an agent ,  or  through an agent proxy , , or . If the agent  is forked, the communication occurs over a form of interprocess communication (IPC). IPC is a set of programming interfaces used to manage processes executed by an operating system. IPC enables two or more processes to communicate with each other. If an agent  or  is threaded, a local procedure may be used to communicate with the agent. Neither the client application , , or  nor the agent , , or  needs to be aware of whether a particular agent , , or  is forked or threaded. In certain implementations, the client application , , or  or the agent , , or  may request information on whether a particular agent , , or  is forked or threaded.","Client application A  may make a request for agent services (e.g., obtaining data describing the state of RAID device  or data stored at RAID device ) through a socket to URL . The request is passed on to a session manager, such as session manager . The session manager  determines which agent should process the request and whether the agent is a forked agent. To process a request, the agent retrieves data requested by the client (e.g., data describing a device or data stored on the device). The determination of which agent should process the request may be based on which agent is connected to a device from which the client application has requested data. For example, if client application A  has requested data about RAID device , then the session manager would assign agent-  to process the request.","The determination of whether the selected agent is forked or threaded may be made, for example, with reference to a configuration file that specifies which agents are to be threaded and which are to be forked. In this example, the session manager  determines that the request should be passed to a forked agent. Additionally, the session manager  determines when to launch an agent. In particular, an agent may be classified as \u201clazy\u201d or \u201cimmediate\u201d in a configuration file. When the primary process  starts, the session managers  review the configuration file and determine whether any of the agents are immediate. Agents classified as immediate are launched when the primary process  starts. Agents classified as lazy are launched when a request from a client application , , or  is received. Table A illustrates a sample configuration file.",{"@attributes":{"id":"p-0049","num":"0048"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE A"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Forked or","Lazy or",{}]},{"entry":[{},"Threaded","Immediate"]},{"entry":[{},"Designation","Designation","Group ID"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Agent-1","Forked","Lazy","1"]},{"entry":[{},"Agent-2","Threaded","Immediate","2"]},{"entry":[{},"Agent-3","Threaded","Lazy","3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"According to the configuration file of Table A, agent-  is forked, is lazy (i.e., launched in response to a first client application request), and has group ID . Agent-  is threaded, immediate (i.e., launched when the primary process  is launched), and has group ID . Agent-  is threaded, lazy, and has group ID .","The group ID values are used when forking multiple agents. In certain implementations, multiple agents may be forked as a group so that they may logically work together and share data. The session manager , , or  determines whether to group two or more agents based on the group ID in the configuration file.","The session manager  invokes a secondary process . For ease of illustration, one secondary process  is shown. However, multiple additional processes may be invoked for additional forked agents. The secondary process  includes many of the components of the primary process, but does not include agent proxies  and  managing threaded agents  and , respectively, and does not include the threaded agents  and , as illustrated in . The session manager  of the primary process  has a link to the agent proxy  in the secondary process . The agent proxy  manages forked agent- , which may access RAID device .","Moreover, client application B  may make a request for agent services to access RAID device  through a socket to URL . The request is passed on to session manager . The session manager  determines which agent should process the request and whether the agent is a forked agent. In this example, the session manager  determines that the request should be passed to a threaded agent- . The session manager  passes the request to agent proxy , which manages threaded agent- . Threaded agent-  processes the request.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 1C","b":["160","160","182","1","190","182","134","118"]},"For ease of illustration, only one forked agent-  has been illustrated in secondary process .  illustrates a group of forked agents in accordance with certain implementations. For example, there could be additional session managers in primary process  (e.g., session manager ), each of which is linked to an agent proxy (e.g., agent proxy ) in the secondary process . Each of the agent proxies in the secondary process  may be linked to a forked agent (e.g., forked agent ) that is lined to a device (e.g., device ). The forked agents ( and ) within the secondary process  are said to form a group of agents. In certain implementations, the group of agents share an address space other than the address space of the primary process. In certain implementations, agents may be forked from the secondary process  to additional processes (e.g., to a third process).",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIGS. 2A and 2B","FIGS. 2A and 2B"],"b":["132","140"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIGS. 3A and 3B","b":["300","110","112","114","124","124","134","136","138","302","134","136","138","150","152","190","150","152","190","304","150","152","190","134","136","138","306","308","310"]},"When an agent is threaded, the session manager  or  within a primary process  passes the request to an agent proxy  or  within the primary process  (block ). The agent proxy  or  within the primary process  passes the request to the threaded agent  or  (block ). The threaded agent  or  performs the request (block ).","When an agent is forked, the session manager  within a primary process  creates a secondary process  that includes the forked agent  (block ). The session manager  within the primary process  determines whether the forked agent  is in a group of agents, by for example, using a configuration file (block ). If so, processing continues to block , otherwise, processing continues to block . In block , the session manager,  invokes other agents in the group in the secondary process . Then, the session manager  within the primary process  passes the request to an agent proxy  within the secondary process  (block ). The agent proxy  within the secondary process  passes the request to the forked agent  (block ). The forked agent  performs the request (block ), by, for example accessing RAID device .",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 4","b":["112","114","150","152","400","150","152","150","152","142","144","118","402","142","144","118","136","138","118","404","136","138","118","128","130","124","118","406","128","130","124","118","112","114","408"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 5","b":["110","190","500","190","190","182","160","502","182","160","134","118","504","134","118","126","124","118","506","126","124","118","110","508"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 6","b":["110","112","114","600","110","112","114","602","190","604","606","604","190","160","190","150","152","118","606","150","152","190","118"]},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 7","b":["110","112","114","118","700","1","18","1","18","118","118","150","152","150","152","190","150","152","190","150","152","190","150","152","190"]},"When the primary process   restarts, the primary process  is able to access the data. In particular, each session manager , , or  uses the data to determine whether an agent ,  or  should be forked (block ). For example, if a threaded agent  or  failed previously, upon restart, whichever session manager  or  that is determining whether that agent  or  should be forked, may designate that agent  or  as a forked agent when the primary process  restarts due to that agent's  or  previously failure. Additionally, if a forked agent  did not fail, the session manager ,  or  may designate that agent as a threaded agent when the primary process  restarts. Then, the agents designated as forked agents are forked (block ). In certain implementations, the determination of which agents should be forked may be made by an agent daemon, a session manager, or an agent library, or by some combination of these components.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 8","b":["150","152","190","800","150","152","190","150","152","190","150","152","190","150","152","190","150","152","190","134","136","138"]},"In block , it is determined whether the agent ,  or  is being switched from a threaded agent  or  to a forked agent. If so, processing continues at block , otherwise, processing continues at block . In block , the threaded agent  or  is quiesced and then restarted as a forked agent. In block , since a forked agent  is being switched to a threaded agent, the forked agent  is terminated and restarted as a threaded agent. In particular, the agent API includes a quiesce method that may be invoked to tell a threaded agent  or  to temporarily stop processing and prepare data for restarting. When the threaded agent  or  is restarted as a forked agent, the forked agent uses the prepared data to restart at a point at which processing had been quiesced.","In certain implementations, when a forked agent  is to be switched to a threaded agent, if the forked agent  is part of a group of agents, only the forked agent  is switched. In certain implementations, when a forked agent  is to be switched to a threaded agent, if the forked agent  is part of a group of agents, all of the forked agents in the group are switched to threaded agents.","In certain implementations, the agents are Common Information Model (CIM) providers in a CIM environment. CIM is a standard for an object-oriented model for managing information. The CIM standard is provided by the Distributed Management Task Force, Inc. (DMTF). For further information on the CIM standard, see \u201cSpecifications for CIM Operations over HTTP,\u201d Version 1.1, May 2, 2002, from the DMTF, which is incorporated by reference herein in its entirety.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 9","b":["900","902","900","920","920","930","930","902","960","940","970","950","930","120","140","150","152","190","940","950"]},"UNIX is a registered trademark of the Open Group.","The above described implementations for creating consistent copies may be implemented using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof. The term \u201carticle of manufacture\u201d as used herein refers to code or logic implemented in hardware logic (e.g., an integrated circuit chip, Programmable Gate Array (PGA), Application Specific Integrated Circuit (ASIC), etc.) or a computer readable medium (e.g., magnetic storage medium (e.g., hard disk drives, floppy disks, tape, etc.), optical storage (CD-ROMs, optical disks, etc.), volatile and non-volatile memory devices (e.g., EEPROMs, ROMs, PROMs, RAMs, DRAMs, SRAMs, firmware, programmable logic, etc.)). Code in the computer readable medium is accessed and executed by a processor. The code may further be accessible through a transmission media or from a file server over a network. In such cases, the article of manufacture in which the code is implemented may comprise a transmission media, such as a network transmission line, wireless transmission media, signals propagating through space, radio waves, infrared signals, etc. Of course, those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the present invention, and that the article of manufacture may comprise any information bearing medium known in the art.","In alternative implementations, the HTTP server  may be replaced with any socket interface.","In certain implementations, rather than the session managers , , and , other components, such as the agent proxies , , and  may determine which agent should process a request and\/or whether the agent should be forked or threaded.","The logic of , B, and \u2013 describe specific operations occurring in a particular order. In alternative implementations, certain of the logic operations may be performed in a different order, modified or removed. Morever, steps may be added to the above described logic and still conform to the described implementations. Further, operations described herein may occur sequentially or certain operations may be processed in parallel, or operations described as performed by a single process may be performed by distributed processes.","The logic of , B, and \u2013 was described as being implemented in software. This logic may be part of the operating system of the host systems or an application program. In yet further implementations, this logic may be maintained in storage areas managed by the control units or in a read only memory or other hardwired type of device. The preferred logic may be implemented in hard disk drives or in programmable and non-programmable gate array logic.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 10","b":["100","102","100","102","1000","1002","1004","1006","1006","1006","1004","1002","1008","1010","1002","1012","1002"]},"The foregoing description of the preferred implementations of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto. The above specification, examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many implementations of the invention can be made without departing from the spirit and scope of the invention, the invention resides in the claims hereinafter appended."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Referring now to the drawings in which like reference numbers represent corresponding parts throughout:",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1D"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
