---
title: Method and data processing system having dynamic profile-directed feedback at runtime
abstract: Software communicates to a processing unit a classification each of at least one schedulable software entity that the processing unit executes. A resource manager within the processing unit dynamically allocates hardware resources within the processing unit to the schedulable software entity during execution in accordance with the classification. The classification may be retrieved by the software from in data storage, and operating system software may schedule the schedulable software entity for execution by reference to the classification. The processing unit may also monitor, in hardware, execution of each of a plurality of schedulable software entities within the processing unit in accordance with a monitoring parameter set. The processing unit may then report to software the utilization of hardware resources by each of the plurality of schedulable software entities so that the software may develop or refine a classification for the schedulable software entity.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07448037&OS=07448037&RS=07448037
owner: International Business Machines Corporation
number: 07448037
owner_city: Armonk
owner_country: US
publication_date: 20040113
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENT"],"p":["The present application is related to U.S. patent application Ser. No. 10\/755,877; which is filed on even date herewith, assigned to the assignee o the present application, and incorporated herein by reference in its entirety.","1. Technical Field","The present invention relates in general to data processing, and in particular, to performance optimization within a data processing system. Still more particularly, the present invention relates to a data processing system and method in which hardware and software coordinate to optimize processing of threads.","2. Description of the Related Art","A number of trends currently influence the development of server-class and mainframe computer systems. In particular, transistor densities within integrated circuits continue to increase according to Moore's Law, which in its current formulation posits that the number of transistors per unit area on integrated circuits will double approximately every 18 months. In addition, processor frequencies continue to double approximately every 2 years. Furthermore, system scale (i.e., the number of central processing units (CPUs) in the system) continues to grow to tens, hundreds, and in some cases, even thousands of processors. The result of these trends is that peak performance of server-class and mainframe computer systems has escalated rapidly, with recently developed large-scale high performance computing (HPC) systems boasting peak performance figures of 100 TFLOPS (100 trillion floating-point operations per second) or more.","Unfortunately, sustained performance in high performance computing systems has not improved at the pace of peak performance, and in fact, the ratio of sustained performance to peak performance while presently low (e.g., 1:10) is declining. With such unutilized computational capacity available, significant attention is now being devoted to achieving greater sustained performance. One object of this focus is the allocation of system resources, such as CPUs, memory, I\/O bandwidth, disk storage, etc., to the various workloads to be accomplished. In conventional multiprocessor data processing systems, the allocation of system resources to workloads is handled by two distinct operating system (OS) components: the scheduler and the workload manager (WLM).","The scheduler is a component of the operating system kernel that is responsible for scheduling execution of schedulable software entities, often referred to as \u201cthreads,\u201d on the various CPUs within the data processing system. To perform the scheduling function, a typical scheduler establishes a global queue from which threads may be scheduled and a number of distributed run queues that are each associated with a respective processing unit. The scheduler assigns threads to run queues based upon a scheduling policy that takes into consideration, for example, thread priorities and the affinity of threads to the system resources (e.g., system memory, data, I\/O resources, caches, execution resources, etc.) required to execute the threads.","The WLM further facilitates the efficient use of system resources by re-allocating the workload among various OS partitions and hardware nodes. For example, the OS\/390 operating system available from International Business Machines (IBM) Corporation of Armonk, N.Y. includes a WLM that balances workloads among various operating system partitions in accordance with user-specified business-oriented goals, such as transaction response times and batch run times for critical batch jobs. Such workload balancing generally entails a great deal of software performance monitoring to gather information regarding resource usage and performance in each OS partition. Utilizing this performance information, the WLM can then manage thread dispatch priorities and the use of memory and other resources to attempt to achieve the user-specified objectives for all of the current workloads.","The present invention recognizes that the performance optimizations achieved through conventional OS schedulers and WLMs, while certainly resulting in performance improvements, optimize only to a certain level of granularity. That is, because schedulers and WLMs are software components, the optimizations achieved by these components tend to address high-level performance issues that can readily be monitored by software. As such, low-level performance issues, such as hardware allocation of shared resources among multiple threads, are not addressed by conventional software-only techniques of performance optimization.","For example, work is frequently presented to a conventional multiprocessor computer system as a sequence of \u201cjobs\u201d that each consist of a number of (possibly) inter-dependent processes. The jobs are generally processed sequentially, meaning that a next process is not initiated until all processes within the previous job have completed execution. Thus, job execution time is determined by the last process to complete. In this type of execution environment, conventional OS schedulers and WLMs can optimize the overall execution of individual processes, for example, by dispatching processes to processors having spatial affinity to data and other required resources. However, conventional OS schedulers and WLMs do not implement fine-grained optimization of the execution of process threads in accordance with the time-varying behavior of the threads. For example, the OS scheduler and WLM typically do not take into consideration the demands for different resources (e.g., I\/O channels, system interconnect, memory controller, and floating point unit) predominating during different phases of thread execution in suspending, interrupting, scheduling, and moving process threads between processors.","In view of the foregoing, the present invention provides an improved method and data processing system for optimizing the performance of a data processing system in which software, such as an operating system, and processing hardware collaborate to optimize performance of threads. According to one embodiment, software communicates to a processing unit a classification each of at least one schedulable software entity that the processing unit executes. A resource manager within the processing unit dynamically allocates hardware resources within the processing unit to the schedulable software entity during execution in accordance with the classification of the at least one schedulable software entity. The classification may be retrieved by the software from in data storage, and operating system software may schedule the schedulable software entity for execution by reference to the classification. The processing unit may also monitor, in hardware, execution of each of a plurality of schedulable software entities within the processing unit in accordance with a monitoring parameter set among one or more monitoring parameter sets. The processing unit may then report to software the utilization of hardware resources by each of the plurality of schedulable software entities so that the software may develop or refine a classification for the schedulable software entity.","All objects, features, and advantages of the present invention will become apparent in the following detailed written description.","With reference now to the figures and in particular with reference to , there is illustrated a high-level block diagram of a multiprocessor (MP) data processing system that provides improved performance optimization in accordance with one embodiment of the present invention. As depicted, data processing system  includes multiple (e.g., 8, 16, 64 or more) processing units  coupled for communication by a system interconnect . Each processing unit  is a single integrated circuit including interface logic  and one or more processor cores .","As further illustrated in , the memory hierarchy of data processing system  includes one or more system memories , which form the lowest level of volatile data storage in the memory hierarchy, and one or more levels of cache memory, such as on-chip level two (L2) caches , which are utilized to stage instructions and operand data from system memory  to processor cores . As understood by those skilled in the art, each succeeding lower level of the memory hierarchy is typically capable of storing a larger amount of data than higher levels, but at higher access latency with respect to processor cores .","As shown, system memory , which is interfaced to interconnect  by memory controller , may store operand data  and portions of one or more operating systems  and one or more application programs . In addition, system memory  may include a classification facility  allocated (e.g., at boot time) by operating system(s) . Although illustrated as a facility within system memory, those skilled in the art will appreciate that classification facility  may alternatively be implemented within another component of data processing system .","Classification facility  includes a number (e.g., 1024) of individual classification fields  that can each be utilized to store classification information pertaining to a respective thread of execution. As described further below, the classification information can be utilized to dynamically optimize execution of data processing system .","System interconnect , which can comprise one or more buses, a switch fabric, or other interconnect architecture, serves as a conduit for communication among the devices (e.g., processing units , memory controller , etc.) coupled to system interconnect . A typical transaction on system interconnect  begins with a request, which may include a transaction field indicating the type of transaction, one or more tags indicating the source and\/or intended recipient(s) of the transaction, and an address and\/or data. Each device connected to system interconnect  preferably snoops all relevant transactions on system interconnect  and, if appropriate, responds to the request with a snoop response. Such snoop responses are received and compiled by response logic , which provides a collective combined response indicating what action, if any, each snooper is to take in response to the request. These actions may include sourcing data on system interconnect , storing data provided by the requesting snooper, invalidating cached data, etc. Although illustrated separately, it should be understood that response logic  may alternatively be incorporated within a particular device (e.g., memory controller ) or may be distributed among various devices (e.g., processing units ) such that different devices (e.g., the masters of each transaction) compile the snoop responses to produce the combined response for different transactions.","Those skilled in the art will appreciate that data processing system  can include many additional unillustrated components, such as I\/O adapters, interconnect bridges, non-volatile storage, ports for connection to networks or attached devices, etc. Because such additional components are not necessary for an understanding of the present invention, they are not illustrated in  or discussed further herein. It should also be understood, however, that the enhancements provided by the present invention are applicable to MP data processing systems of any architecture and are in no way limited to the generalized MP architecture illustrated in .","Referring now to , there is depicted a more detailed block diagram of an exemplary embodiment of a processor core  in accordance with the present invention. As shown, each of processor cores  includes associated level one (L1) instruction and data caches  and , which temporarily buffer instructions and operand data, respectively, that are likely to be accessed by processor core . L2 cache  may be inclusive, non-inclusive, or partially inclusive of the contents of L1 caches  and , as is known in the art.","In addition, processor core  has an instruction sequencing unit (ISU)  that fetches instructions from L1 I-cache  utilizing real addresses obtained by the effective-to-real address translation (ERAT) performed by instruction memory management unit (IMMU) . As will be appreciated by those skilled in the art, ISU  may demand fetch (i.e., non-speculatively fetch) instructions within one or more active threads of execution, or speculatively fetch instructions that may or may not ultimately be executed. In either case, if a requested cache line of instructions does not reside in L1 I-cache , then ISU  requests the relevant cache line of instructions from L2 cache  (and\/or lower level memory) via I-cache reload bus .","Instructions fetched by ISU  are initially buffered within instruction buffer . While buffered within instruction buffer , the instructions may be pre-processed, for example, to perform branch prediction or to translate the instructions utilizing microcode. The instructions within instruction buffer  may optionally be further processed by hardware (HW) monitor , as discussed further below, in order to classify the thread of execution to which the instructions belong.","As illustrated in , in one illustrative embodiment, hardware monitor  contains a number of fields , , and  for storing the monitoring parameters of each thread that may be concurrently executed by process core  by simultaneous multithreading (SMT). Thus, fields , and define monitoring parameters for a first thread, fields , and define monitoring parameters for a second concurrently executed thread within processor core , and so on.","In the illustrative embodiment, instruction type fields , store an indication of a particular opcode or group of opcodes to be detected within a respective associated thread by hardware monitor  of ISU . Depending upon the desired implementation, hardware monitor  can be configured to detect instructions satisfying the criteria within instruction type fields , while the instructions are buffered within instruction buffer  or as the instructions are dispatched for execution by dispatcher . Instruction count fields , further specify a number of instructions satisfying the criterion in the respective instruction type field  to be detected within a window of consecutive instructions in the thread. The size of the window of consecutive instructions is defined by the associated one of window definition fields , . A thread classification obtained through monitoring execution of the thread may be stored within the appropriate one of thread classification fields , ","ISU  of  further includes a resource manager  that tracks and manages the allocation and availability of at least the resources (e.g., execution units, rename and architected registers, cache lines, etc.) within processing core . As illustrated in , resource manager  includes a resource table  that preferably tracks the allocation of resources not only with respect to individual instructions (in order to allocate to instructions the execution unit and registers required for their execution), but also, in embodiments in which SMT is supported, with respect to particular threads. Resource manager  further includes resource allocation policy data structure  that stores rules defining a dynamically alterable policy that governs the allocation of at least the resources within processor core  by resource manager  based upon the classification of threads contained in thread classification fields . Thus, for example, resource allocation policy data structure  may store rules specifying that resource manager  should allocate 30% of execution time in a particular execution unit to a first thread, and allocate 70% of execution time in that execution unit to a second thread based upon the classifications of the threads with respect to the execution unit resource. In one preferred embodiment, a human system administrator can access a software facility of an operating system  or hypervisor  to load a desired rule set into policy data structure  that optimizes execution of a particular type of workload (e.g., scientific or commercial).","As resource manager  allocates resources needed by particular instructions buffered within instruction buffer  by reference to resource table , dispatcher  within ISU  dispatches the instructions from instruction buffer  to execution units -, possibly out-of-program-order, based upon instruction type. Thus, condition-register-modifying instructions and branch instructions are dispatched to condition register unit (CRU)  and branch execution unit (BEU) , respectively, fixed-point and load\/store instructions are dispatched to fixed-point unit(s) (FXUs)  and load-store unit(s) (LSUs) , respectively, and floating-point instructions are dispatched to floating-point unit(s) (FPUs) . After possible queuing and buffering, the dispatched instructions are executed opportunistically by execution units -.","During execution within one of execution units -, an instruction may receive input operands, if any, from one or more architected and\/or rename registers within a register file - coupled to the execution unit. Data results of instruction execution (i.e., destination operands), if any, are similarly written to register files - by execution units -. For example, FXU  receives input operands from and stores destination operands to general-purpose register file (GPRF) , FPU  receives input operands from and stores destination operands to floating-point register file (FPRF) , and LSU  receives input operands from GPRF  and, via DMMU , causes data to be transferred between L1 D-cache  and both GPRF  and FPRF . Similarly, when executing condition-register-modifying or condition-register-dependent instructions, CRU  and BEU  access control register file (CRF) , which in a preferred embodiment contains a condition register, link register, count register and rename registers of each. BEU  accesses the values of the condition, link and count registers to resolve conditional branches to obtain a path address, which BEU  supplies to instruction sequencing unit  to initiate instruction fetching along the indicated path. After an execution unit finishes execution of an instruction, the execution unit notifies ISU , which schedules completion of instructions in program order. Resource manager  also updates resource table  to reflect the release of the resources allocated to the completed instructions.","Referring now to , there is illustrated a software layer diagram of an exemplary software configuration of data processing system  of . As illustrated, the software configuration has at its lowest level an operating system supervisor (or hypervisor)  that allocates system resources among one or more operating systems  concurrently executing within data processing system . The resources allocated to each instance of an operating system  are referred to as a partition. Thus, for example, hypervisor  may allocate two processing units  to the partition of operating system , four processing units  to the partition of operating system , and certain ranges of real and effective address spaces to each partition.","Running above hypervisor  are operating systems , and application programs . As well understood by those skilled in the art, each operating system  allocates resources from the pool of resources allocated to it by hypervisor  to various operating system processes and applications , independently controls the operation of the hardware allocated to its partition, and provides various application programming interfaces (API) through which operating system services can be accessed by its application programs . As described briefly above, operating systems  include a scheduler  that schedules threads to the processor cores  in its partition, and may further include a workload manager (WLM)  to optimize the distribution of work and associated data within the partition.","Application programs , which can be programmed to perform any of a wide variety of computational, control, communication, data management and presentation functions, comprise a number of user-level processes . As with operating system processes, each of these user-level processes  may comprise one or more threads , which as defined herein, are the software entities that are scheduled by the underlying operating system .","In accordance with the present invention, performance optimization within data processing system  is improved by coordinating the optimization efforts of software and hardware. In particular, hardware, for example, hardware monitor  of ISU , monitors instructions belonging to the thread(s) processed within a processor core . The information gathered by the hardware is reported to software, such as an operating system . The software and\/or the hardware then classify the thread(s) of execution and establish a resource allocation policy that optimizes performance based upon the time-varying classification of the thread(s).","With reference now to , there is illustrated a high level logical flowchart of an exemplary process by which data processing system  dynamically optimizes the performance of a thread in accordance with one embodiment of the present invention. The illustrated process is individually performed for each thread concurrently executed by data processing system .","As illustrated, the process begins at block , which represents the scheduler of an operating system  scheduling a thread on a processor core  within its partition. The operating system scheduler may schedule the thread in accordance with conventional scheduling policy based, for example, on a relative priority of the thread with respect to other runnable threads, the affinity of the selected thread, and\/or other factors. Next, as depicted at block , the hardware monitor  within the processor core  establishes monitoring parameters that govern the criterion or criteria by which the thread will be monitored, and begins monitoring execution of the thread by processor core  in accordance with the monitoring parameters. The monitoring parameters for the current thread can be established, for example, by hardware defaults, by the operating system loader when the operating system  on which the thread will execute is loaded, by simply retaining the monitoring parameters of the previously executed thread, or by the operating system  in conjunction with scheduling the thread. In one embodiment, the operating system , the operating system loader, or other software may write the monitoring parameters of the thread into fields ,  and , which may be directly accessed as memory-mapped storage locations.","Returning to , hardware monitor  next determines at block  whether or not the monitoring parameters established at block  have been satisfied by the current thread. For example, hardware monitor  may determine at block  if the number of instructions indicated in the relevant instruction count field  that are of the type specified within the relevant instruction type field  have been detected within an instruction window of the size indicated in window definition field . It should be appreciated that hardware monitor  may additionally determine at block , whether the three criteria contained in fields ,  and  have been jointly satisfied a selected number of times.","As indicated by block , the monitoring process illustrated at block  continues until the thread terminates execution or the monitoring parameters specified within fields - are satisfied. If the thread terminates execution, the process passes from block  to block , which is described below. If, however, hardware monitor  determines at block  that the monitoring parameters specified within fields - have been satisfied, hardware monitor  issues an interrupt to the underlying operating system  at block . The interrupt primarily informs the operating system  that the monitoring parameters have been satisfied by the current thread, but may also provide further state information to the operating system , such as the thread ID, the contents of the fields - assigned to the thread, resource utilization information (e.g., instruction counts by instruction type, cache utilization, and\/or snoop information), etc.","As further illustrated at block , in response to determining at block  that the hardware monitoring parameters are satisfied, hardware, such as hardware monitor , may optionally modify a classification of the thread stored within thread classification field  and\/or the resource allocation policy contained in resource allocation policy field . For example, if fields - define monitoring parameters according to which hardware monitor  counts a certain number of floating-point instructions in a thread within a given instruction window, hardware monitor  may update the relevant thread classification field  to indicate that the thread is a floating-point-dominant thread. By virtue of this classification update, resource manager  will automatically modify the allocation of resources to the thread (and hence update resource table ) by application of the resource allocation policy within resource allocation policy data structure  to the new thread classification. For example, in response to the new thread classification, the resource allocation policy within resource allocation policy data structure  may cause resource manager  to attempt to allocate additional execution slots within FPU(s)  to the current thread.","In response to receipt of the hardware interrupt generated by hardware monitor , the operating system  on which the thread is running determines at block  whether or not the hardware interrupt indicates that a known classification conflict exists between different threads concurrently executing on the processor core . A classification conflict may exist, for example, if a greater number of threads have the same or similar classification than can efficiently be executed concurrently by the processor core , given the finite resource set of the processor core . If operating system  determines at block  that no classification conflict exists for the current thread, the process proceeds from block  to block , which is described below. If, however, operating system  determines at block  that a classification conflict exists for the current thread, the operating system  makes a further determination at block  whether or not to migrate the thread. This determination may take into consideration, for example, whether a processor core is available that would not a have a classification conflict with the current thread, given its current thread set and resource set. The determination shown at block  may further take into consideration the availability of a different runnable thread of sufficient priority and proper classification that may be run in place of the current thread and that will reduce or eliminate the classification conflict. If the operating system  makes a determination at block  that the current thread should not be migrated, the process proceeds to block , which is described below. If, however, operating system  makes a determination that the current thread should be migrated to resolve the classification conflict, the process passes to block .","Block  depicts the operating system  migrating the current thread to a different processor core , possibly after interrupting or suspending the execution of the thread for some period of time before rescheduling the thread for execution. As shown at block , the operating system  may also optionally store the current and\/or historical classification(s) of the thread obtained from the relevant thread classification field  of hardware monitor  within a field  of classification facility  in system memory . In this manner, the operating system  can appropriately initialize the thread classification field  and\/or monitoring parameters for the thread to optimize subsequent execution. If multiple classifications are stored for a particular thread in classification facility , each such thread classification is preferably stored in association with a label, such as an instruction pointer, that facilitates identification of the relevant thread classification for a particular section of the thread. Following block , the process shown in  terminates at block .","Returning to block , in response to a determination by the operating system  that no classification conflict does not exist between the current thread and another thread concurrently executing within the same processor core  or that the current process should not be migrated, the operating system  optionally updates the hardware within processor core  in order to facilitate optimization of the processing of the current thread. For example, the operating system  may update the monitoring parameters contained in the relevant fields - in order to gather additional information needed to further refine the classification within thread classification field . In addition, the operating system  may directly update the classification of the current thread by writing the appropriate thread classification field . The operating system  may alternatively or additionally modify the resource allocation policy within resource allocation policy data structure  in order to better optimize thread processing given the current distribution of thread classifications within the current processor core . Following block , the process illustrated in  returns to block , which has been described.","The exemplary process shown in  provides a number of advantages over conventional optimization techniques. First, because thread monitoring is implemented in hardware, detailed, thread-specific, time-varying classification information is available for use by both the hardware resource manager and the software scheduling and workload management routines, supporting finer-grained optimizations. Second, because the process shown in  iterates during thread processing, a single thread may be classified differently at different points during its execution, depending upon the selected monitoring parameters and the time-varying behavior of the thread. Third, an operating system can more intelligently determine whether or not to migrate the various threads within its partition based upon not only resource affinity, but also hardware-supplied thread classifications.","While the invention has been particularly shown as described with reference to a preferred embodiment, it will be understood by those skilled in the art that various changes in form and detail may be made therein without departing from the spirit and scope of the invention. For example, although aspects of the present invention have been described with respect to a computer system executing software that directs the functions of the present invention, it should be understood that present invention may alternatively or additionally be implemented as a program product for use with a data processing system. Programs defining the functions of the present invention can be delivered to a data processing system via a variety of signal-bearing media, which include, without limitation, non-rewritable storage media (e.g., CD-ROM), rewritable storage media (e.g., a floppy diskette or hard disk drive), and communication media, such as digital and analog networks. It should be understood, therefore, that such signal-bearing media, when carrying or encoding computer readable instructions that direct the functions of the present invention, represent alternative embodiments of the present invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. However, the invention, as well as a preferred mode of use, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 3A","FIG. 2"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 3B","FIG. 2"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
