---
title: Interface definition language compiler
abstract: A distributed computer application can be made to communicate with a plurality of computer architectures. A first compiler compiles and converts input interface source code to produce a high level language including a plurality of computer architecture interfaces. A second compiler integrates application source code with the converted interface source code to produce the distributed computer application with the plurality of computer architecture interfaces that enable the distributed computer application to communicate with the plurality of computer architectures.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07428728&OS=07428728&RS=07428728
owner: Dassault Systemes
number: 07428728
owner_city: Lowell
owner_country: US
publication_date: 20040513
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED CASE","RELATED CASE","TECHNICAL FIELD","BACKGROUND INFORMATION","SUMMARY OF THE INVENTION","DESCRIPTION"],"p":["This claims priority to and the benefit of Provisional U.S. patent application Ser. No. 60\/278,812 filed Mar. 26, 2001, the entirety of which is hereby incorporated by reference.","This is a continuatuon of U.S. patent application Ser. No. 09\/877,416 filed Jun. 8, 2001, the entire disclosure of witch is incoroprated herein by reference.","The invention relates generally to compilers and more particularly to interface definition language compilers that produce multiple interfaces.","Distributed computing is a form of computing in which the processing nodes, or computers, are physically distributed. These computers (clients and servers) are interconnected, and must cooperate in order to maintain some shared state. A distributed computer system can be characterized as a heterogeneous set of hardware, software, and data components; the size and geographical extent of which can vary over a large range. The components are connected by a network and provide a uniform set of services (such as naming, and remote invocation, for example) with certain global properties (such as names, access, and security management, for example).","Distributed objects provide a useful mechanism for client-server communication. The architectures defined for distributed object systems are software frameworks which are required for building and using client\/server applications that use distributed objects. Distributed objects are independent pieces of code that can be accessed by local or remote clients via method invocations. Clients can access distributed objects without knowing where the objects reside or what operating system the objects are executed on. The distributed object framework also provides an infrastructure for supporting a large number of services and applications that can spawn any number of transactions. CORBA and JAVA Components (JAVA RMI and JAVA IDL) are two widely used distributed object architectures.","The invention relates generally to compilers and more particularly to interface definition language compilers that produce multiple interfaces. Distributed applications are currently deployed using a web-enabled configuration such as CORBA, for example. A web-enabled configuration is limited in that services (such as authentication, for example) are duplicated, the network includes only three client\/server tiers, and only clients utilizing the same architecture can communicate with the network. The disclosed compiler enables a distributed application to be deployed in a web-centric configuration. In a web-centric configuration, the services are provided by a web server and shared by the entire network, the network is not limited to three tiers (i.e., the network is n-tier), and a client running on any architecture can communicate with the network.","In one aspect, the invention involves a method of producing a plurality of computer architecture interfaces that enable a distributed computer application to communicate with a plurality of computer architectures. The method includes providing source code written in an interface definition language, providing a compiler capable of compiling the source code and producing the plurality of computer architecture interfaces, and setting at least one compiler flag to determine the plurality of computer architecture interfaces that the compiler will produce. The method further comprises compiling the source code to produce the plurality of computer architecture interfaces that enable the distributed computer application to communicate with the plurality of computer architectures.","In another aspect, the invention involves a method of producing a distributed computer application capable of communicating with a plurality of computer architectures. The method includes providing interface source code written in an interface definition language, providing application source code written in a high level language, and providing a first compiler capable of compiling the interface source code, converting the interface source code to the high level language, and producing a plurality of computer architecture interfaces. The method further comprises setting at least one compiler flag to determine the plurality of computer architecture interfaces that the first compiler will produce and compiling the interface source code to convert the interface source code to the high level language. The converted interface source code includes the plurality of computer architecture interfaces. The method still further comprises compiling the application source code and the converted interface source code with a second compiler to integrate the application source code with the converted interface source code to produce the distributed computer application with the plurality of computer architecture interfaces that enable the distributed computer application to communicate with the plurality of computer architectures.","In one embodiment, compiling the application source code further includes producing the distributed computer application to be executable on a plurality of computer architectures.","In another embodiment, compiling the interface source code further includes producing an XML-RMI interface, an XML-EJB interface, or an XML-JNI interface.","In still another embodiment, compiling the interface source code further includes producing at least one of an RMI-EJB interface, an RMI-JNI interface, or an EJB-JNI interface.","In yet another embodiment, the method further comprises deploying the distributed computer application with the plurality of interfaces on a plurality of clients and a plurality of servers to form a network. The method still further includes sharing a plurality of services provided by one of the plurality of servers with the rest of the plurality of servers and the plurality of clients.","In still another aspect, the invention involves a system for allowing a distributed computer application to communicate with a plurality of computer architectures. The system includes a web server and an application server. The web server includes an XML server and a first client. The first client includes a first architecture in communication with the XML server through a first interface. The application server includes a first server which includes the first architecture in communication with the first client. The application server further includes a second client which includes a second architecture in communication with the first server through a second interface. The application server still further includes a second server which includes the second architecture and a plurality of information services. The second server is in communication with the second client and the plurality of information services is accessible by the distributed computer application executing on another client through one of the XML server, the first server, or the second server.","In one embodiment, the first architecture is one of EJB, JNI, and RMI and the second architecture is one of EJB, JNI, or RMI.","In yet another aspect, the invention involves a method of compiling Interface Definition Language (IDL) source code. The method includes examining each of a plurality of elements in the IDL source code which define a particular interface for each of a plurality of desired interfaces and categorizing each of the plurality of elements which define the particular interface for each of the plurality of desired interfaces as one of a factory class, a stateful class, and a stateless class. The method further includes creating a session class for each of the plurality of desired interfaces. Creating the session class includes forming an abstraction around each of a plurality of services for the particular interface to hide the particularities of each of the plurality of services. The method still further includes modifying an application programming interface for each of the plurality of desired interfaces to include the session class.","The foregoing and other objects, aspects, features, and advantages of the invention will become more apparent from the following description and from the claims.","Referring to , system  is configured as a typical Object Request Broker (ORB) distributed object architecture. The system  includes a browser  (through which an application  implemented as a ORB client  can be executed) in communication (through a firewall ) with an application server  implemented as an ORB server  (on which information services  reside). The application server  is also in communication with an application database . Additionally, browser  is in communication with a web server . Known ORB distributed object architectures include CORBA and JAVA IDL.","In the described typical ORB configuration, administrative services must be duplicated on both the application server  and the web server . For example, both servers  and  must provide authentication services. A separate directory of users and passwords must be kept on the application server  and on the web server , and must be kept synchronized. Additional services that must be duplicated include transaction services, naming services, security services, and database administration services. The configuration described above is commonly referred to as \u201cweb-enabled\u201d because the application , which is deployed over the web, uses different communication channels to communication with server  and the server .","Applications that are developed using the typical ORB distributed object architecture are divided into three tiers. These tiers include a client tier, a service tier, and data store tier. The client tier is a portion of the distributed application that requests services from the service tier. The data store tier is a portion of the distributed application that manages access to persistent data and its storage mechanisms, such as relational databases. The service tier is a portion of the distributed application that contains business logic and performs computations.","Referring to , the present invention involves a compiler  which compiles and converts an interface source code file  (written in an Interface Definition Language or IDL) into another high level language interface source code file , such as JAVA or C++, for example. The converted interface source code file  includes code for implementing a plurality of architectural interfaces. The interface source code file  is integrated with an application source code file  by a compiler  to produce an n-tier application (as opposed to a 3-tier CORBA-based application, for example) that can be implemented on a variety of web server architectures, such as Extensible Markup Language (XML) , Remote Method Invocation (RMI) , Enterprise JavaBean (EJB) , or Java Native Interface (JNI) , for example. Further, the plurality of architectural interfaces produced by this process, allow the application to be accessed from any XML or JAVA-based client.","Referring to , system  is configured as a distributed object architecture. In one embodiment, the system  includes a web browser , a web server , an application server , and an application server database . The web browser  (through which an application  implemented as an XML client  can be executed) is in communication (through a firewall ) with an XML server  that resides on the web server . The web server  also includes an RMI client  and an XML-RMI interface .","The application server  includes an RMI server , an EJB client , information services  (persistence, messaging, life cycle, work flow, policy manager, administration, and structure management) which reside on an EJB server , and an RMI-EJB interface . The web server  communicates with the application server  through the XML-RMI interface  that resides on the web server . The web server  further communicates with the information services  which reside on the EJB server  through the RMI-EJB interface . Thus, using the configuration described above, a user (using the application  can access the information services  on the EJB server  from the XML client  through the web server . The services (authentication, security, transactions, naming, and database administration), which are duplicated in the CORBA-based architecture, are provided by the web server  and shared with application server . This configuration is commonly referred to as \u201cweb-centric\u201d. The application  is deployed on the web and can fully leverage the services and administration capabilities of the web or application server.","Referring to , the information services  can be accessed from any point in the network. For example, a user implementing an application  on an RMI client  from inside the firewall  can access the information services  on the EJB server  from the RMI server  through the RMI-EJB interface . Likewise, a user implementing an application  on an EJB client  from inside the firewall  can access the information services  on the EJB server  directly from the EJB server . The applications , , and  are the same application implemented on different servers.","The system  is not limited to 3-tiers (as with a CORBA-based architecture). Any combination and any number of interfaces (n-tiers) may be stacked on top of one another when building the web server  and the application server .","Referring again to , in one embodiment, the desired interfaces (EJB-RMI, XML-RMI, RMI-JNI, for example) are selected by setting the appropriate flags prior to compilation by the compiler . After the interface file  is created, the interface file  is integrated with the application source code file  and compiled by compiler  to run on a particular architecture (XML, EJB, JNI, RMI, for example). The particular architecture is chosen by setting the appropriate flag prior to compilation. The source code , and  is compiled by compiler  for each desired architecture. Thereafter, the same application can be implemented on a particular architecture by selecting the particular architecture at runtime.","Referring to , in one embodiment, after the flags corresponding to the desired interfaces are set (Step ), the compiler  (when compiling the IDL source file) first engages in a classification process (Step ). Each element in the interface definition (in the IDL source code file) is examined by the compiler  and categorized as a factory class , a stateful class , or a stateless class .","The function of the factory class  is to create new objects. The stateful object  is a server object that has a lifetime that is managed by an application. The stateless object  is a server object that exists only as long as a particular call. The stateless object  is a temporary object used for any kind of information service, such as messaging.","The classification process is required to extract information required by architectures (other than CORBA) that is not explicitly available in the IDL file. For example, XML, RMI, and EJB have unique mechanisms for managing the lifetime of objects. To account for the differences in the mechanisms for managing the lifetime of objects, the first step of the interface classification is to determine which methods in the IDL manage object lifetime (construction\/destruction) and, using those methods, generate an independent factory class . The factory class  is then generated differently for each architecture. For an EJB architecture, the factory class  is used to generate an EJB Home interface which integrates with the EJB JNDI naming services. For an RMI architecture, the factory class  is exposed through the RMI Registry. For an XML architecture, a generated servlet is used to implement the factory class .","The differences in these server side implementations of the factory class  are hidden from the client application by the session class  (discussed below) that is generated for each architecture.","The interface classification process also includes determining whether an object interface is stateful or stateless. Stateful objects  are objects which have internal attributes (or \u201cstate\u201d) which must be maintained on a server for the lifetime of the object. Stateless objects  have no internal attributes. CORBA (and the original IDL) does not distinguish between stateful\/stateless interfaces. Other environments, particularly EJB, manage stateful objects  and stateless objects  entirely differently. In an EJB environment, stateful objects  are private and owned by a single client. Stateless objects  are public and available for use by any client. Stateless objects  are typically managed in an object pool which greatly enhances the performance and scalability of a given application. By classifying interfaces as stateful objects  or stateless objects , the compiler  allows an application to be deployed on an EJB server and take full advantage of the optimizations around stateless objects .","Next, the compiler  performs a transformation process (Step ). During this process a session class  is created. The session class  forms an abstraction around each of the services (naming, authentication, security, and transport, for example) for each of the desired interfaces. The application programming interface (API) for each interface is modified to include the session class . Creating an abstraction around each of the services hides the particularities of the services that are inherent in each of the different architectures and allows the service to be protocol independent. When a particular service is requested by an application, the request passes transparently from tier to tier and can thereby be shared throughout the network (see , B, and C).","The code produced by the transformation process (Step ) conforms to a set of predefined abstractions (defined in the IDL source code) which are wrapped around the services available in each client-server architecture. When a client-server architecture does not provide support for a required abstraction, the compiler inserts a suitable component. For example, the XML interface does not provide a naming service. In order for the XML interface to comply with the calling semantics of the RMI, EJB, etc API's, a de-facto naming service for XML is provided by the compiler. Wherever possible, the compiler uses a transformation which complies with the native services available in each architecture's API. The transformation process (Step ) further modifies the interface defined in the IDL source code to pass session object  information from tier to tier.","Referring to , in one embodiment, after the transformation process (Step ) is complete, the compiler  outputs a converted interface source code file . Next, a particular architecture (on which the application is to be run) is chosen by setting the appropriate flags (Step ). The converted interface source code file  is then integrated with the application source code file  by the compiler  (Step ) to produce an n-tier application that can be implemented on a variety of web server architectures, such as XML , RMI , EJB , or JNI , for example.","After the compilation process is complete, the code produced by the compiler  is deployed on the application server and the web server. The code is deployed to create an n-tier web-centric configuration. Clients, servers, and interfaces can be arranged in any way to suit the needs of the user.","Variations, modifications, and other implementations of what is described herein may occur to those of ordinary skill in the art without departing from the spirit and scope of the invention. Accordingly, the invention is not to be defined only by the preceding illustrative description."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["In the drawings, like reference characters generally refer to the same parts throughout the different views. Also, the drawings are not necessarily to scale, emphasis instead generally being placed upon illustrating the principles of the invention.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
