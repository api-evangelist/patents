---
title: System and method for storage takeover
abstract: A system and method for performing a takeover procedure is disclosed. A plurality of storage system nodes is coupled in a cluster. One or more of the plurality of storage system nodes in the cluster is notified to takeover at least a portion of a writable storage device serviced by another storage system node in the cluster. In response to the notification, the portion of the writable storage device is assimilated into at least one of the notified storage system nodes.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07930587&OS=07930587&RS=07930587
owner: NetApp, Inc.
number: 07930587
owner_city: Sunnyvale
owner_country: US
publication_date: 20090827
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF AN ILLUSTRATIVE EMBODIMENT","A. Cluster Environment","B. Storage System Node","C. Storage Operating System","D. CF Protocol","E. File System Organization","F. VLDB","G. Takeover"],"p":["This application is a continuation of U.S. patent application Ser. No. 11\/606,727 entitled SYSTEM AND METHOD FOR STORAGE TAKEOVER, by Susan M. Coatney et al., filed Nov. 30, 2006, now issued as U.S. Pat. No. 7,613,947 on Nov. 3, 2009.","This application is related to the following United States Patent Applications:","U.S. patent application Ser. No. 11\/606,452 entitled SYSTEM AND METHOD FOR IMPROVED RESOURCE GIVE BACK, by Susan M. Coatney et al., now issued as U.S. Pat. No. 7,546,302 on Jun. 9, 2009, which is presently incorporated by reference in its entirety; and","U.S. patent application Ser. No. 11\/606,538 entitled SYSTEM AND METHOD FOR MAINTAINING DISK LOCATION VIA HOMENESS, by Steven S. Watanabe et al., now issued as U.S. Pat. No. 7,711,683 on May 4, 2010, which is presently incorporated by reference herein in its entirety.","1. Field of the Invention","The present invention relates to networked storage systems and, more particularly, to takeover procedures in clustered storage systems.","2. Background Information","A storage system is a computer that provides storage service relating to the organization of information on writeable persistent storage devices, such as memories, tapes or disks. The storage system is commonly deployed within a storage area network (SAN) or a network attached storage (NAS) environment. When used within a NAS environment, the storage system may be embodied as a file server including an operating system that implements a file system to logically organize the information as a hierarchical structure of directories and files on, e.g. the disks. Each \u201con-disk\u201d file may be implemented as a set of data structures, e.g., disk blocks, configured to store information, such as the actual data for the file. A directory, on the other hand, may be implemented as a specially formatted file in which information about other files and directories are stored.","The file server, or filer, may be further configured to operate according to a client\/server model of information delivery to thereby allow many client systems (clients) to access shared resources, such as files, stored on the filer. Sharing of files is a hallmark of a NAS system, which is enabled because of semantic level of access to files and file systems. Storage of information on a NAS system is typically deployed over a computer network comprising a geographically distributed collection of interconnected communication links, such as Ethernet, that allow clients to remotely access the information (files) is on the file server. The clients typically communicate with the filer by exchanging discrete frames or packets of data according to pre-defined protocols, such as the Transmission Control Protocol\/Internet Protocol (TCP\/IP).","In the client\/server model, the client may comprise an application executing on a computer that \u201cconnects\u201d to the filer over a computer network, such as a point-to-point link, shared local area network, wide area network or virtual private network implemented over a public network, such as the Internet. NAS systems generally utilize file-based access protocols; therefore, each client may request the services of the filer by issuing file system protocol messages (in the form of packets) to the file system over the network. By supporting a plurality of file system protocols, such as the conventional Common Internet File System (CIFS), the Network File System (NFS) and the Direct Access File System (DAFS) protocols, the utility of the filer may be enhanced for networking clients.","A SAN is a high-speed network that enables establishment of direct connections between a storage system and its storage devices. The SAN may thus be viewed as an extension to a storage bus and, as such, an operating system of the storage system enables access to stored information using block-based access protocols over the \u201cextended bus\u201d. In this context, the extended bus is typically embodied as Fibre Channel (FC) or Ethernet media adapted to operate with block access protocols, such as Small Computer Systems Interface (SCSI) protocol encapsulation over FC (FCP) or TCP\/IP\/Ethernet (iSCSI). A SAN arrangement or deployment allows decoupling of storage from the storage system, such as an application server, and some level of storage sharing at the application server level. There are, however, environments wherein a SAN is dedicated to a single server. When used within a SAN environment, the storage system may be embodied as a storage appliance that manages access to information in terms of block addressing on disks using, e.g., a logical unit number (LUN) in accordance with one or more block-based protocols, such as FCP.","One example of a SAN arrangement, including a multi-protocol storage appliance suitable for use in the SAN, is described in United States Patent Application Publication No. US2004\/0030668 A1, filed on Feb. 14, 2004, entitled MULTI-PROTOCOL STORAGE APPLIANCE THAT PROVIDES INTEGRATED SUPPORT FOR FILE AND BLOCK ACCESS PROTOCOLS by Brian Pawlowski et al., which is incorporated herein by reference in its entirety.","It is advantageous for the services and data provided by a storage system, such as a storage node, to be available for access to the greatest degree possible. Accordingly, some storage systems provide a plurality of storage system nodes organized as a cluster, with a first storage system node being clustered with a second storage system node. Each storage system node is configured to take over serving data access requests for the other storage system node if the other storage system node fails. The storage nodes in the cluster notify one another of continued operation using a heartbeat signal which is passed back and forth over a cluster interconnect, and over a cluster switching fabric. If one of the storage system nodes detects the absence of a heartbeat from the other storage node over both the cluster interconnect and the cluster switching fabric, a failure is detected and a takeover procedure is initiated. It is noted that the failure is also usually confirmed by the surviving storage node by checking a master mailbox disk of the other storage node to confirm that it is in fact a failure of the other storage node itself and not simply a failure of the cluster interconnect coupling.","More specifically, a mailbox mechanism includes a set of procedures for determining the most up-to-date coordinating information through the use of one or more mailbox disks. Such disks receive messages from the node with which they are associated in order to confirm that the node continues to be in communication with the mailbox disk, which indicates that the node continues to be capable of writing to the disks assigned to that node. Further details on the configuration and operation of the master mailbox disk are provided in commonly-owned U.S. Pat. No. 7,231,489, of Larson et al., for a SYSTEM AND METHOD FOR COORDINATING CLUSTER STATE INFORMATION, issued on Jun. 12, 2007, which is presently incorporated by reference herein in its entirety.","Many cluster configurations include the concept of partnering. Specifically, each is storage system node in the cluster is partnered with a second storage system node in such a manner that the partner storage system node is available to take over and provide the services and the data otherwise provided by the second storage system node. The partner assumes the tasks of processing and handling any data access requests normally processed by the second storage system node. One such example of a partnered storage system cluster configuration is described in U.S. Pat. No. 7,260,737, entitled SYSTEM AND METHOD FOR TRANSPORT-LEVEL FAILOVER OF FCP DEVICES IN A CLUSTER, by Arthur F. Lent, et al., the contents of which are hereby incorporated by reference. It is further noted that in such storage system node clusters, an administrator may desire to take one of the storage system nodes offline for a variety of reasons including, for example, to upgrade hardware, etc. In such situations, it may be advantageous to perform a \u201cvoluntary\u201d user-initiated takeover operation, as opposed to a failover operation. After the takeover operation is complete, the storage system node's data is serviced by its partner until a giveback operation is performed.","Another example of a storage system node cluster configuration takeover technique is described in U.S. patent application Ser. No. 11\/411,502, entitled SINGLE NODE NAME CLUSTER SYSTEM FOR FIBER CHANNEL, by Britt Bolen et al., the contents of which are hereby incorporated by reference. In this configuration, the cluster has a single world wide node name so that the cluster as a whole appears to the client as a single device. In such clusters, two storage system nodes are partnered such that a first storage system node serves its own \u201clocally owned\u201d data from the disks to which it is directly connected, and proxies requests for its partner disks to a partner storage system node. During takeover operations, the locally owned data of the failed storage system node is serviced by its partner until a give back operation is performed.","In such cases employing a partner mode, additional infrastructure is often required. For example, requests are tracked to determine whether they are partner requests. Data structures are also duplicated. Separate tables describing the data, such as for example, a volume location database (VLDB) must be maintained for the local disks and is for the partner disks. In addition, registry files which store options and configuration parameters are also maintained separately in a local registry file and a partner registry file. As will be apparent to those skilled in the art, this results in additional code complexity in many systems.","It is also noted that, in some storage system architectures, the nodes in each cluster are generally organized as a network element (N-module) and a disk element (D-module). The N-module includes functionality that enables the node to connect to clients over a computer network, while each D-module connects to one or more storage devices such as the disks of a disk array. A file system architecture of the type is generally described in U.S. Pat. No. 6,671,773, issued on Dec. 30, 2003 entitled METHOD AND SYSTEM FOR RESPONDING TO FILE SYSTEM REQUESTS, by M. Kazar et al. (the contents of which are incorporated herein by reference in entirety).","In some recent architectures however, additional functionality has been moved to the N-module which may have previously been performed by the D-module. For example, the N-module handles aspects such as network connectivity. In such configurations, it may be desirable to deliver to upper layers of the N-module a single view of all aggregates that a particular D-module is serving, rather than exposing two sets of aggregates to the N-module (i.e., a local image of the disks being served by the surviving D-module, and a set of partner disks). In previous designs, in a failover, the surviving N-module and D-module took over network addresses and performed other administrative tasks which consumed operational bandwidth in the storage architecture system.","There remains a need, therefore, for a system which eliminates partner mode failover, but allows for a takeover that results in one or more newly assimilated aggregates to be available for access by the N-modules in a multiple node cluster.","The disadvantages of prior techniques are overcome by the present invention which provides a technique for takeover of a failed node's disks and that produces one or more newly assimilated aggregates to be available for access by the N-modules in a multiple node cluster. When a takeover procedure is triggered, either through a lack of heartbeat, or a command for a takeover is received, the system of the present invention is configured such that one or more surviving nodes of the cluster asserts ownership of disks previously served by a failed node, so that all of the disks are locally owned by one of the surviving nodes in the cluster. So, as a result, one or more new aggregates are established that include all of the failed node's disks. According to the invention, one or more newly assimilated aggregates, now served by one or more surviving D-modules, is then exposed to any N-module that interfaces with the surviving nodes. For clarity of illustration, the invention is described with reference to a single newly assimilated aggregate. It should be understood, however, that one or more newly assimilated aggregates can be served by one or more surviving D-modules, while remaining within the scope of the present invention.","In the illustrative embodiment, when the takeover procedure is invoked, a surviving node changes two elements of ownership with respect to each disk or portion thereof. Specifically, the surviving node first changes one or more ownership attributes (such as SCSI-3 reservations or export rules, as described further herein) to reflect its access rights to the failed node's disks, and secondly, it changes a \u201ccurrent owner\u201d status in an ownership location on the disk to reflect itself (the surviving node) as the current owner of the disk assigned to that surviving node. The newly acquired disks are then properly assimilated into one or more aggregates by a suitable process such as a RAID system of the surviving node. A section of the non-volatile memory (NVRAM), which contains the most recent data about the RAID system, referred to herein as the RAID section of the NVRAM is replayed to flush any final parity computations with respect to the disks forming the new aggregate(s).","Duplications in fsid numbers are corrected so that each volume in the newly assimilated aggregate has its own unique fsid identifier. A file system section of the NVRAM of the node is replayed to bring all data up to date, and the volumes are then brought online to thereby enable the surviving node to serve data access requests as if it locally owns all of the volumes that it claimed from the failed node, which volumes are is now contained in the newly assimilated aggregate. Notably, the system and method described herein are performed without requiring a partner mode in the takeover procedure.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1","b":["200","100","200","100","200","310","350","310","200","180","140","350","130","200","150","100","100","200"],"i":["a,b ","a,b ","a,b ","a","a","a,b ","a,b "]},"The nodes  are also coupled across a cluster interconnect  which provides an additional communication path between the nodes. The cluster interconnect  may be Fibre Channel (FC), InfiniBand or another suitable medium. The cluster interconnect  may be used to provide heartbeat signals (\u201cheartbeats\u201d) between the two nodes, which signals are used monitor the active state of each node. The cluster heartbeats are also sent across the cluster switching fabric  over which communications between an N-module and D-module are illustratively effected through remote message passing over the cluster switching fabric , which is sometimes also referred to as the \u201cstorage layer.\u201d The \u201cdeath\u201d of a node is indicated by the loss of heartbeat from both the cluster interconnect and the storage layer. The cluster interconnect is sometimes also referred to as the storage takeover interconnect. That is, as described further hereinafter, if the heartbeat terminates (i.e., \u201ctimes out\u201d), then a takeover procedure is enabled.","The clients  may be general-purpose computers configured to interact with the nodes  in accordance with a client\/server model of information delivery. That is, each client may request the services of the node, and the node may return the results of the services requested by the client, by exchanging packets over the network . The client may issue packets including file-based access protocols, such as the Common Internet File System (CIFS) protocol or Network File System (NFS) protocol, over the Transmission Control Protocol\/Internet Protocol (TCP\/IP) when accessing information in the form of files and directories. Alternatively, the client may issue packets including block-based access protocols, such as the Small Computer Systems Interface (SCSI) protocol encapsulated over TCP (iSCSI) and SCSI encapsulated over Fibre Channel (FCP), when accessing information in the form of blocks.","During normal cluster operation, the storage system node (e.g., node ) that is connected to a set of disks is identified as the \u201chome\u201d of the disks . That storage system node is also identified as the \u201ccurrent owner\u201d at initialization and is primarily responsible for servicing data requests directed to blocks on volumes contained on its set of disks. For example, the storage system node is primarily responsible for the volumes of the disk array which are represented as disk . Similarly, the storage system node is primarily responsible for the disks in the volumes represented as disk in . The clustered storage system  is configured such that either storage system node or can take over data servicing capabilities for the other storage system node in the event of a failure in the manner described further herein. Notably, in a multiple node cluster, a failed node's disks may not all be claimed by a single takeover node. Instead, some of the disks may be claimed by a first takeover node, with the remaining disks being claimed by a second takeover node, for example. This may be used for load balancing of I\/O traffic.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 2","FIG. 9"],"b":["200","222","224","225","226","227","228","230","223","230","235","900","226","200","100","226","100"],"i":"a,b"},"Each node  is illustratively embodied as a dual processor storage system executing a storage operating system  that preferably implements a high-level module, such as a file system, to logically organize the information as a hierarchical structure of named data containers, such as directories, files and special types of files called virtual disks (hereinafter generally \u201cblocks\u201d) on the disks. However, it will be apparent to those of ordinary skill in the art that the node  may alternatively comprise a single or more than two processor system. Illustratively, one processor executes the functions of the N-module  on the node, while the other processor executes the functions of the D-module .","The memory  illustratively comprises storage locations that are addressable by the processors and adapters for storing software program code and data structures associated with the present invention. The processor and adapters may, in turn, comprise processing elements and\/or logic circuitry configured to execute the software code and manipulate the data structures. The storage operating system , portions of which are typically resident in memory and executed by the processing elements, functionally organizes the node  by, inter alia, invoking storage operations in support of the storage service implemented by the node. It will be apparent to those skilled in the art that other processing and memory means, including various computer readable media, may be used for storing and executing program instructions pertaining to the invention described herein.","The network adapter  comprises a plurality of ports adapted to couple the node  to one or more clients  over point-to-point links, wide area networks, virtual private networks implemented over a public network (Internet) or a shared local area network. The network adapter  thus may comprise the mechanical, electrical and signaling circuitry needed to connect the node to the network. Illustratively, the computer network  () may be embodied as an Ethernet network or a FC network. Each client  may communicate with the node over network  by exchanging discrete frames or packets of data according to pre-defined protocols, such as TCP\/IP.","The storage adapter  cooperates with the storage operating system  executing on the node  to access information requested by the clients. The information may be stored on any type of attached array of writable storage device media such as video tape, optical, DVD, magnetic tape, bubble memory, electronic random access memory, micro-electro mechanical and any other similar media adapted to store information, including data and parity information. However, as illustratively described herein, the information is preferably stored on the disks  of the disk array . The storage adapter comprises a plurality of ports having input\/output (I\/O) interface circuitry that couples to the disks over an I\/O interconnect arrangement, such as a conventional high-performance, FC link topology.","Storage of information on each disk array  is preferably implemented as one or more storage \u201cvolumes\u201d that comprise a collection of physical storage disks  cooperating to define an overall logical arrangement of volume block number (vbn) space on the volume(s). Each logical volume is generally, although not necessarily, associated with its own file system. The disks within a logical volume\/file system are typically organized as one or more groups, wherein each group may be operated as a Redundant Array of Independent (or Inexpensive) Disks (RAID). Most RAID implementations, such as a RAID-4 level implementation, enhance the reliability\/integrity of data storage through the redundant writing of data \u201cstripes\u201d across a given number of physical disks in the RAID group, and the appropriate storing of parity information with respect to the striped data, once all of the disks in a given RAID group are assimilated. An illustrative example of a RAID implementation is a RAID-4 level implementation, although it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.","To facilitate access to the disks , the storage operating system  implements a write-anywhere file system that cooperates with one or more virtualization modules to \u201cvirtualize\u201d the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named data containers such as directories and files on the disks. Each \u201con-disk\u201d file may be implemented as set of disk blocks configured to store information, such as data, whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization module(s) allow the file system to further logically organize information as a hierarchical structure of data containers such as blocks on the disks that are exported as named logical unit numbers (LUNs).","In the illustrative embodiment, the storage operating system is preferably the NetApp\u00ae Data ONTAP\u00ae operating system available from Network Appliance, Inc., Sunnyvale, Calif. that implements a Write Anywhere File Layout (WAFL\u00ae) file system. However, it is expressly contemplated that any appropriate storage operating system may be enhanced for use in accordance with the inventive principles described herein. As such, where the term \u201cWAFL\u201d is employed, it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 3","b":["300","325","312","314","316","315","318","320","322","324","326","318","328","330","200"]},"In addition, the storage operating system includes a series of software layers organized to form a storage server  that provides data paths for accessing information stored on the disks  of the node . As described further herein, the software layers of the storage server are illustratively embodied as a D-module . The storage server  illustratively comprises a takeover monitor module  that maintains a data structure such as the takeover monitor resource table . It should be understood that the takeover monitor resource table  is not the only possible embodiment of the data structure, but it is described herein for illustrative purposes. The takeover monitor resource table  is configured to maintain information regarding takeover procedures, as described further herein. The file system module  interacts in cooperating relation with a volume striping module (VSM) , a RAID system module  and a disk driver system module . The RAID system  manages the storage and retrieval of information to and from the volumes\/disks in accordance with I\/O operations, while the disk driver system  implements a disk access protocol such as, e.g., the Small Computer System Interface (SCSI) protocol. However, it should be understood that processes other than the RAID system  may in other embodiments perform such tasks while remaining within the scope of the present invention.","The VSM  illustratively implements a striped volume set (SVS) and, as such cooperates with the file system  to enable storage server  to service a volume of the SVS. In particular, the VSM  implements a Locate( ) function  to compute the location of data container content in the SVS volume to thereby ensure consistency of such content served by the cluster.","A disk ownership module  manages ownership of the disks with respect to their related aggregates and volumes using, for example, one or more data structures such as tables, including, for example, the disk ownership table . In particular, the ownership module  cooperates with the disk driver system  to identify the appropriate D-module for processing data access requests for particular volumes on the disk array . To that end, the ownership module consults disk ownership table , which contains disk ownership information that is illustratively generated at boot-up time, and that is updated by various components of the storage operating system to reflect changes in ownership of disks. Further details regarding the data structure implemented as ownership table  are provided in the above-incorporated U.S. patent application Ser. No. 11\/606,538.","Notably, the disk ownership module  includes program instructions for writing proper ownership information at a proper location on each disk, which is referred to herein as the ownership location. The disk ownership module  also includes program instructions for asserting and eliminating SCSI reservation tags.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 4","b":["400","382","300","410","420","430","440","420","402","404","406","408","350"],"i":["ANSI X",", Fibre Channel Physical and Signaling Interface ","FC","PH","New Identifier Formats Based on IEEE Registration X","T",", revision "]},"Initially, the disk ownership table  is generated upon boot up of the system. More specifically, I\/O services of the disk driver system  query all devices (e.g., disks ) attached to the system. This query requests information as to the nature of the attached disks. Upon completion of the query, the ownership module  instructs the disk driver system  to read the ownership information from each disk. In response, the disk driver system reads the ownership information for each disk from each on-disk ownership location (), and then the ownership module  creates the entries in the disk ownership table  with this information.","Subsequently, the ownership module  accesses the disk ownership table  to extract the identification of all disks that are owned by the appropriate D-module. The ownership module then verifies the SCSI reservations on each disk owned by that D-module by reading the ownership information stored in the ownership location on each disk. If the SCSI reservations and on-disk information do not match, the ownership module changes the SCSI reservation to match the on-disk ownership information. Once the SCSI reservations and on-disk ownership information match for all disks identified as owned by the D-module, the ownership module  then passes the information to the file system and the RAID module, which configure the individual disks into the appropriate RAID groups and volumes for the D-module .","Referring again to , a takeover monitor process  operates in conjunction with a cluster fabric (CF) interface module to monitor the heartbeats between the node and the one or more other nodes in the cluster. If the absence of a heartbeat is detected, the takeover monitor process  initiates the takeover procedure. In addition, the takeover monitor is also responsive to a storage takeover command by e.g., an administrator. In response to lack of heartbeat or issuance of a storage takeover command, a takeover procedure is triggered at the takeover monitor process . When a takeover is initiated by the takeover monitor process , it first consults takeover monitor resource table , which sets forth the routines to be followed in order to effect a takeover. These routines are summarized illustratively in the flowchart of . The takeover monitor process  thereafter notifies other processes, such as the file system , the RAID system , the ownership module  and the disk driver system , instructing each to perform respective routines\/threads that are necessary steps, which steps are illustratively illustrated herein in the flowchart of , to implement the takeover procedures, in the manner described herein.","The file system  implements a virtualization system of the storage operating system  through the interaction with one or more virtualization modules illustratively embodied as, e.g., a virtual disk (vdisk) module (not shown) and a SCSI target module . The vdisk module enables access by administrative interfaces, such as a user interface of a management framework  (see ), in response to a user (system administrator) issuing commands to the node . The SCSI target module  is generally disposed between the FC and iSCSI drivers ,  and the file system  to provide a translation layer of the virtualization system between the block (lun) space and the file system space, where luns are represented as blocks.","The file system  is illustratively a message-based system that provides logical volume management capabilities for use in access to the information stored on the storage devices, such as disks. That is, in addition to providing file system semantics, the file system  provides functions normally associated with a volume manager. These functions include (i) aggregation of the disks, (ii) aggregation of storage bandwidth of the disks, and (iii) reliability guarantees, such as mirroring and\/or parity (RAID). The file system  illustratively implements the WAFL\u00ae file system (hereinafter generally the \u201cwrite-anywhere file system\u201d) having an on-disk format representation that is block-based using, e.g., 4 kilobyte (kB) blocks and using index nodes (\u201cmodes\u201d) to identify files and file attributes (such as creation time, access permissions, size and block location). The file system uses files to store metadata describing the layout of its file system; these metadata files include, among others, an mode file. A file handle, i.e., an identifier that includes an mode number, is used to retrieve an mode from disk.","Broadly stated, all modes of the write-anywhere file system are organized into the mode file. A file system (fs) info block specifies the layout of information in the file system and includes an mode of a file that includes all other modes of the file system. Each logical volume (file system) has an fsinfo block that is preferably stored at a fixed location within, e.g., a RAID group. The mode of the mode file may directly reference (point to) data blocks of the mode file or may reference indirect blocks of the mode file that, in turn, reference data blocks of the mode file. Within each data block of the mode file are embedded modes, each of which may reference indirect blocks that, in turn, reference data blocks of a file.","Operationally, a request from the client  is forwarded as a packet over the computer network  and onto the node  where it is received at the network adapter . A network driver (of layer  or layer ) processes the packet and, if appropriate, passes it on to a network protocol and file access layer for additional processing prior to forwarding to the write-anywhere file system . Here, the file system generates operations to load (retrieve) the requested data from disk  if it is not resident \u201cin core\u201d, i.e., in memory . If the information is not in memory, the file system  indexes into the mode file using the mode number to access an appropriate entry and retrieve a logical vbn. The file system then passes a message structure including the logical vbn to the RAID system ; the logical vbn is mapped to a disk identifier and disk block number (disk,dbn) and sent to an appropriate driver (e.g., SCSI) of the disk driver system . The disk driver accesses the dbn from the specified disk  and loads the requested data block(s) in memory for processing by the node. Upon completion of the request, the node (and operating system) returns a reply to the client  over the network .","It should be noted that the software \u201cpath\u201d through the storage operating system layers described above needed to perform data storage access for the client request received at the node may alternatively be implemented in hardware. That is, in an alternate embodiment of the invention, a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array (FPGA) or an application specific integrated circuit (ASIC). This type of hardware implementation increases the performance of the storage service provided by node  in response to a request issued by client . Moreover, in another alternate embodiment of the invention, the processing elements of adapters ,  may be configured to offload some or all of the packet processing and storage access operations, respectively, from processor , to thereby increase the performance of the storage service provided by the node. It is expressly contemplated that the various processes, architectures and procedures described herein can be implemented in hardware, firmware or software.","As used herein, the term \u201cstorage operating system\u201d generally refers to the computer-executable code operable on a computer to perform a storage function that manages data access and may, in the case of a node , implement data access semantics of a general purpose operating system. The storage operating system can also be implemented as a microkernel, an application program operating over a general-purpose operating system, such as UNIX\u00ae or Windows XP\u00ae, or as a general-purpose operating system with configurable functionality, which is configured for storage applications as described herein.","In addition, it will be understood to those skilled in the art that the invention described herein may apply to any type of special-purpose (e.g., file server, filer or storage serving appliance) or general-purpose computer, including a standalone computer or portion thereof, embodied as or including a storage system. Moreover, the teachings of this invention can be adapted to a variety of storage system architectures including, but not limited to, a network-attached storage environment, and a storage area network and disk assembly directly attached to a client or host computer. The term \u201cstorage system\u201d should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems. It should be noted that while this description is written in terms of a write-anywhere file system, the teachings of the present invention may be utilized with any suitable file system, including a write-in-place file system.","In the illustrative embodiment, the storage server  is embodied as D-module  of the storage operating system  to service one or more volumes of array . In addition, the multi-protocol engine  is embodied as N-module  to (i) perform protocol termination with respect to a client issuing incoming data access request packets over the network , as well as (ii) redirect those data access requests to any storage server  of the cluster . Moreover, the N-module  and D-module  cooperate to provide a highly-scalable, distributed storage system architecture of the cluster . To that end, each blade includes a CF interface module adapted to implement intra-cluster communication among the N- and D-modules, including D-module-to-D-module communication for data container striping operations.","The protocol layers, e.g., the NFS\/CIFS layers and the iSCSI\/FC layers, of the N-module  function as protocol servers that translate file-based and block-based data access requests from clients into CF protocol messages used for communication with the D-module . That is, the N-module servers convert the incoming data access requests into file system primitive operations (commands) that are embedded within CF messages by the CF interface module  for transmission to the D-modules  of the cluster . Notably, the CF interface modules  cooperate to provide a single file system image across all D-modules  in the cluster . Thus, any network port of an N-module that receives a client request can access any data container within the single file system image located on any D-module  of the cluster.","Further to the illustrative embodiment, the N-module  and D-module  are implemented as separately-scheduled processes of storage operating system ; however, in an alternate embodiment, the modules may be implemented as pieces of code within a single operating system process. Communication between an N-module and D-module is thus illustratively effected through the use of message passing between the modules although, in the case of remote communication between an N-module and D-module of different nodes, such message passing occurs over the cluster switching fabric . As noted, the cluster switching fabric  is also used as a second medium over which heartbeats between the nodes are transmitted and received. A known message-passing mechanism provided by the storage operating system to transfer information between modules (processes) is the Inter Process Communication (IPC) mechanism. The protocol used with the IPC mechanism is illustratively a generic file and\/or block-based \u201cagnostic\u201d CF protocol that comprises a collection of methods\/functions constituting a CF application programming interface (API). Examples of such an agnostic protocol are the SpinFS and SpinNP protocols available from Network Appliance, Inc. The SpinFS protocol is described in the above-referenced U.S. Pat. No. 6,671,773.","The CF interface module  implements the CF protocol for communicating file system commands among the modules of cluster . Communication is illustratively effected by the D-module exposing the CF API to which an N-module (or another D-module) issues calls. To that end, the CF interface module  is organized as a CF encoder and CF decoder. The CF encoder of, e.g., CF interface on N-module  encapsulates a CF message as (i) a local procedure call (LPC) when communicating a file system command to a D-module  residing on the same node  or (ii) a remote procedure call (RPC) when communicating the command to a D-module residing on a remote node of the cluster . In either case, the CF decoder of CF interface on D-module  de-encapsulates the CF message and processes the file system command.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 5","b":["500","500","150","100","500","502","504","506","508","510","100","510","500","310","350","508","506"]},"A data container, e.g., a file, is accessed in the file system using a data container handle.  is a schematic block diagram illustrating the format of a data container handle  including a SVS ID field , an mode number field , a unique-ifier field  a striped flag field  and a striping epoch number field . The SVS ID field  contains a global identifier (within the cluster ) of the SVS within which the data container resides. The mode number field  contains an mode number of an mode (within an mode file) pertaining to the data container. The unique-ifier field  contains a monotonically increasing number that uniquely identifies the data container handle . The unique-ifier is particularly useful in the case where an mode number has been deleted, reused and reassigned to a new data container. The unique-ifier distinguishes that reused mode number in a particular data container from a potentially previous use of those fields. The striped flag field  is illustratively a Boolean value that identifies whether the data container is striped or not. The striping epoch number field  indicates the appropriate striping technique for use with this data container for embodiments where the SVS utilizes differing striping techniques for different data containers.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 7","b":["700","702","704","706","708","710","700","700","750","750","760","730"]},"Whereas the aggregate  is analogous to a physical volume of a conventional storage system, a flexible volume is analogous to a file within that physical volume. That is, the aggregate  may include one or more files, wherein each file contains a flexible volume  and wherein the sum of the storage space consumed by the flexible volumes is physically smaller than (or equal to) the size of the overall physical volume. The aggregate utilizes a physical pvbn space that defines a storage space of blocks provided by the disks of the physical volume, while each embedded flexible volume (within a file) utilizes a logical vvbn space to organize those blocks, e.g., as files. Each vvbn space is an independent set of numbers, each of which corresponds to an offset within the file. These offset values are then translated to dbns on disks. Since the flexible volume  is also a logical volume, it has its own block allocation structures (e.g., active, space and summary maps) in its vvbn space.","A container file is a file in the aggregate that contains all blocks used by a flexible volume. The container file is an internal (to the aggregate) feature that supports a flexible volume; illustratively, there is one container file per flexible volume. Similar to a pure logical volume in a file approach, the container file is a hidden file (not accessible to a user) in the aggregate that holds every block in use by the flexible volume. The aggregate includes an illustrative hidden metadata root directory that contains subdirectories of flexible volumes:\n\n","Specifically, a physical file system (WAFL) directory includes a subdirectory for each flexible volume in the aggregate, with the name of the subdirectory being a file system identifier (fsid) of the flexible volume. Each fsid subdirectory (flexible volume) contains at least two files, a file system file and a storage label file. The storage label file is illustratively a 4 kB file that contains metadata similar to that stored in a conventional RAID label. In other words, the storage label file is the analog of a RAID label and, as such, contains information about the state of the flexible volume such as, e.g., the name of the flexible volume, a universal unique identifier (uuid) and fsid of the flexible volume, whether it is online, being created or being destroyed, etc.",{"@attributes":{"id":"p-0076","num":"0076"},"figref":"FIG. 8","b":["800","300","380","800","1","2","802","802","804","804","804","800"]},"Each fsinfo block  includes a block pointer to an mode file  that contains modes of a plurality of files, including an owner map , an active map , a summary map  and a space map , as well as other special meta-data files. The mode file  further includes a root directory  and a \u201chidden\u201d meta-data root directory , the latter of which includes a namespace having files related to a flexible volume in which users cannot \u201csee\u201d the files. The hidden meta-data root directory includes the WAFL\/fsid\/directory structure that contains filesystem file  and storage label file . Note that root directory  in the aggregate is empty; all files related to the aggregate are organized within the hidden meta-data root directory .","In addition to being embodied as a container file having level 1 blocks organized as a container map, the filesystem file  includes block pointers that reference various file systems embodied as flexible volumes . The aggregate  maintains these flexible volumes  at special reserved mode numbers. Each flexible volume  also has special reserved mode numbers within its flexible volume space that are used for, among other things, the block allocation bitmap structures. As noted, the block allocation bitmap structures, e.g., active map , summary map  and space map , are located in each flexible volume.","Specifically, each flexible volume  has the same mode file structure\/content as the aggregate, with the exception that there is no owner map and no WAFL\/fsid\/filesystem file, storage label file directory structure in a hidden meta-data root directory . To that end, each flexible volume  has a volinfo block  that points to one or more fsinfo blocks , each of which may represent a snapshot, along with the active file system of the flexible volume. Each fsinfo block, in turn, points to an mode file  that, as noted, has the same mode structure\/content as the aggregate with the exceptions noted above. Each flexible volume  has its own mode file  and distinct mode space with corresponding mode numbers, as well as its own root (fsid) directory  and subdirectories of files that can be exported separately from other flexible volumes.","The storage label file  contained within the hidden meta-data root directory  of the aggregate is a small file that functions as an analog to a conventional RAID label. A RAID label includes physical information about the storage system, such as the volume name; that information is loaded into the storage label file . Illustratively, the storage label file  includes the name  of the associated flexible volume , the online\/offline status  of the flexible volume, and other identity and state information  of the associated flexible volume (whether it is in the process of being created or destroyed).",{"@attributes":{"id":"p-0081","num":"0081"},"figref":"FIG. 9","b":["900","300","910","930","950","910","970","200","100"]},"The VLDB  is a database process that tracks the locations of various storage components (e.g., SVSs, flexible volumes, aggregates, etc.) within the cluster  to thereby facilitate routing of requests throughout the cluster. In the illustrative embodiment, the N-module  of each node accesses a configuration table  that maps the SVS ID  of a data container handle  to a D-module  that \u201cowns\u201d (services) the data container within the cluster. The VLDB includes a plurality of entries which, in turn, provide the contents of entries in the configuration table ; among other things, these VLDB entries keep track of the locations of the flexible volumes (hereinafter generally \u201cvolumes \u201d) and aggregates  within the cluster. Examples of such VLDB entries include a VLDB volume entry  () and a VLDB aggregate entry  ().",{"@attributes":{"id":"p-0083","num":"0083"},"figref":["FIG. 10","FIG. 11"],"b":["1000","1000","1005","1010","1015","1005","710","1010","700","1005","1100","1100","1105","1110","1115","1105","700","100","1110","1105"]},"The VLDB illustratively implements a RPC interface, e.g., a Sun RPC interface, which allows the N-module  to query the VLDB . When encountering contents of a data container handle  that are not stored in its configuration table, the N-module sends an RPC to the VLDB process. In response, the VLDB  returns to the N-module the appropriate mapping information, including an ID of the D-module that owns the data container. The N-module caches the information in its configuration table  and uses the D-module ID to forward the incoming request to the appropriate data container. All functions and interactions between the N-module  and D-module  are coordinated on a cluster-wide basis through the collection of management processes and RDB library user mode applications.","To that end, the management processes have interfaces to (are closely coupled to) RDB . The RDB comprises a library that provides a persistent object store (storing of objects) for the management data processed by the management processes. Notably, the RDB  replicates and synchronizes the management data object store access across all nodes  of the cluster  to thereby ensure that the RDB database image is identical on all of the nodes . At system startup, each node  records the status\/state of its interfaces and IP addresses (those IP addresses it \u201cowns\u201d) into the RDB database.","As discussed, a takeover process is performed upon absence of a heartbeat, or when the storage takeover command is issued. In either case, the takeover monitor  receives notice of the triggered failover and consults the takeover monitor resource table  to obtain the procedures which are to be followed by one or more processes in the storage server  in order to perform a takeover of the failed node's disks by the surviving storage system node. For example, the takeover monitor process  notifies other processes, such as the file system , the RAID system , the ownership module  and the disk driver system , instructing each to perform respective routines\/threads that are necessary steps to implement the takeover procedures, in the manner described herein.","One of the procedures, illustratively, is to confirm that there is, in fact, a failure of the node (and not simply a failure of the cluster interconnect coupling or the cluster switching fabric). To that end, the surviving node accesses a master mailbox disk of the failed node (i.e., D-module). The mailbox is created upon boot up of the takeover process software. If the failed D-module has not written to the mailbox in a timely fashion, the failure is confirmed and the takeover monitor instructs the surviving node to begin takeover of the disks.","Next, the takeover monitor process  instructs the disk driver system  of the surviving storage system node's D-module to assert new SCSI-3 reservations on each is disk formerly owned by the failed D-module. Notably, the illustrative embodiment is described with reference to a SCSI environment, as will be understood by those skilled in the art, in which SCSI level 3 persistent reservations (as described in SCSI primary commands-3 by Community 10 of the National Committee for Information Technology Standards, which is incorporated fully herein by reference) would have been previously placed on the disks by the now failed D-module. Using SCSI-3 reservations, a D-module can write to a disk if it holds the SCSI-3 reservations for that disk, i.e., non-owning D-modules are prevented from writing to disks because they do not have the SCSI-3 reservation. However, the non-owning file service can read ownership information from a predetermined location on the disk. In accordance with the invention, the disk driver process in the D-module has been programmed with instructions allowing it to pre-empt SCSI reservations on disks in the cluster. Thus, upon a failure, the takeover monitor instructs the surviving D-module to first pre-empt the existing SCSI reservations on the disks previously serviced by the failed node. Once these SCSI reservations have been pre-empted, the surviving node asserts its own SCSI reservations on the disks of the failed node, in the manner defined in the above-cited SCSI-3 ANSI standard specification.","In an alternative aspect of the invention, two or more nodes can simultaneously access and serve data from a common set of disks, but from separate regions (i.e., blocks) on those disks. More specifically, as will be understood by those skilled in the art, individual disks may be logically divided up into regions of contiguous blocks, and ownership information for each region is maintained in a separate ownership location on the disk for each region. This allows two or more nodes to simultaneously access and to serve data access requests from a common set of disks, but from separate regions of those disks. However, in such a configuration, SCSI reservations would not be applicable because such SCSI reservations apply to an entire disk. Consequently, alternative software and\/or hardware mechanisms are applied in accordance with the invention to permit or to restrict access to portions of disks.","For example, access can be controlled by appropriately changing the ownership information for each region of the disk and\/or by using a fencing technique whereby access permission rights are granted or denied for specific regions of the disks. Such fencing techniques may be for example: A) a distributed protocol running across the D-modules that guarantees that only one node has access to a file system region of the disk at any one time (a region being defined as one or more disk blocks, up to the entire disk, not necessarily contiguous) in a system in which each D-module is programmed to honor its access constraints; and B) hardware and\/or firmware logic in the shared storage stack underneath the D-modules, e.g., the disk shelf, provides the fencing. A distributed protocol is typically still required; however, enforcement is stricter in that a D-module in this embodiment cannot write outside its ownership areas. These and other suitable techniques may also be employed when the invention is implemented in a non-SCSI environment for the assertion of ownership on the disks by the takeover node.","As noted herein, in an illustrative embodiment of the invention, ownership information is also stored in a particular location of the disk, which acts as the definitive ownership location on the disk. In an illustrative embodiment of the invention, if the SCSI-3 reservations do not match the on-disk ownership location data, the on-disk ownership information is used. In the case of takeover, the takeover monitor  cooperates with the disk driver system  to assert new SCSI-3 reservations on each disk formerly owned by the failed D-module and which now are under the control of the surviving D-module.","After asserting its SCSI-3 reservations, the surviving node calls the surviving D-module's RAID system  to assimilate all newly owned disks into one or more aggregates . The proper RAID calculations and configurations are then performed. Thereafter, to finalize the RAID assimilation, the RAID system initiates replay of the RAID section of the NVRAM to flush any final parity computations therefrom.","Specifically, the RAID system  adjusts the \u201ccurrent owner\u201d status in the ownership location of each newly assimilated disk to indicate that the surviving node is now the \u201ccurrent owner\u201d of that disk. Thereafter, each newly assimilated aggregate appears to be locally owned by the surviving D-module. On the surviving node, the NVRAM log containing NVRAM entries of the failed node is replayed so that any data in the newly assimilated aggregates are fully up to date.","As will be understood by those skilled in the art, a data write request issued by a client is not acknowledged as having been received successfully until the data has been written and stored in a non-volatile memory. Illustratively, in the present cluster environment, a client-issued data write request is first stored in the NVRAM  of the node  having the D-module that currently owns the relevant disk. The write request data is then written to a backup NVRAM of another (partner) D-module in the cluster prior to the write operation being acknowledged to the client. Later, at a consistency point, the newly obtained data is written from the NVRAM of the current owner D-module to the actual disk. This protects the data in such a cluster environment, so that if a failure occurs prior to the data being written to disk, that data has been stored in the backup NVRAM of the partner D-module in the cluster.","Accordingly, when a takeover occurs, the NVRAM data of the failed node is stored within the NVRAM of the surviving node and can be played back (written to the disks) at the appropriate time to bring the data into the most current state possible. Illustratively, the NVRAM has a RAID section which stores RAID calculation updates, and a file system section which stores file system data. Each section of the NVRAM is replayed at the appropriate time as discussed in further detail with respect to the flow chart of .","In accordance with the present invention, the data of the failed node is to be assimilated into a new aggregate image. However, as noted herein, the data had been originally owned by two different D-modules, and thus some of the file system IDs (\u201cfsids\u201d) may be duplicated. In accordance with the invention, in order to avoid any inconsistencies and errors, these duplicate fsids are corrected so that each fsid for each volume in the newly assimilated aggregate is unique. This, in turn, ensures that the newly assimilated aggregate does not contain any identical (duplicate) fsids.","The volumes of the newly assimilated aggregate are then brought online and the VLDB is updated. As noted, the VLDB keeps track of the location of the volumes  and aggregates  within the cluster as well as their host D-module. Thus, the VLDB  changes the D-module ID  to reflect the new D-module hosting the aggregate. Thereafter, the N-module is allowed to send requests to the updated surviving D-module. The D-module processes data access requests for its locally-owned disks and the newly acquired disks until further notice. The surviving D-module then continues to process data access requests while the failed D-module remains in a \u201cwaiting for send home\u201d state.","The method of takeover in accordance with the present invention is described in further detail in the flowcharts of . As set forth in , the procedure starts at step  and continues to step  where a failure is detected or a storage takeover command is received at the takeover monitor process . At step , the surviving storage system node pre-empts the SCSI reservations, as described herein on the disks previously associated with the failed storage system node. In step , the surviving storage system node asserts its own SCSI reservations on the failed node's disks. As noted herein, another technique, such as a fencing technique, can be employed when only a portion of the disk is involved, or when the implementation is not using the SCSI protocol to access the disks, or in such other circumstances as desired in a particular application of the invention.","In the illustrative implementation of the invention, the surviving storage system node then calls the RAID system of the surviving D-module in step . In step , each disk previously associated with the failed storage system node is assimilated into a new data container. Illustratively, the RAID system  performs block-based assimilation of the newly acquired disks into aggregates, and the proper RAID calculations and configurations are performed. Notably, other embodiments of the invention may not include a RAID system, in which case other suitable processes will assimilate the disks into aggregates. In step , the VLDB is updated. The procedure continues to step  where the RAID system initiates replay of the RAID section of the NVRAM to flush any final parity computations from the RAID section of the NVRAM. It should be appreciated, however, that if the storage network does not use RAID, the blocks of data on the disks can be assimilated by another suitable process while remaining within the scope of the present invention.","Once the RAID assimilation has been performed, then, as illustrated in step , in order to avoid any inconsistencies and errors, any fsid duplications are corrected if the new aggregate refers to an identical fsid as the node's original aggregate. It is noted that aggregate IDs are unique within a cluster, so the aggregate ID numbers will not need to be checked because there should not be such duplications. Then, the procedure continues to step  where the RAID system adjusts the \u201ccurrent owner\u201d status in the ownership location on the disks to indicate that the surviving node is now the current owner of the newly assimilated disks. In step , the newly assimilated aggregates now appear to be locally owned by the surviving D-module. The file system  on the surviving node then receives notice that the aggregates have been successfully assimilated, as illustrated in step . On the surviving node, the file system NVRAM log containing the file system NVRAM entries of the failed node is replayed so that data in the newly assimilated aggregates is brought fully up to date (step ). As noted, for purposes of clarity of illustration, the invention is described with reference to a single newly assimilated aggregate. It should be under stood, however, that one or more newly assimilated aggregates can be served by one or more surviving D-modules, while remaining within the scope of the present invention.","The volumes are brought online as shown in step . The procedure then continues to step , in which the N-module is allowed to send requests to the updated surviving D-module. As shown in step , the D-module processes data access requests for its locally owned disks and for the newly acquired disks until further notice. The surviving D-module then continues to process data access requests while the failed D-module remains in the waiting for send home state. The procedure ends at step .","The procedure of  is illustrative of a configuration in which a single D-module takes over all of the disks of a failed D-module. It should be understood, however, that the invention also encompasses other configurations in which multiple D-modules are connected together in the cluster. For example, a system may be configured in such a manner that D-modules \u201cA\u201d \u201cB\u201d and \u201cC\u201d are interconnected such that write data for half of module A's aggregate are routed to module B and the other half are routed to module C for a takeover. More specifically, upon a failure of module A, the takeover monitor process  running in module B is programmed such that module B performs steps  through  (FIGS. A\/B) on the set of disks that it has been assigned to take over from module A. Similarly, module C follows the procedure for the remaining disks of failed module A. In this case, the newly assimilated aggregate is spread across two D-modules. Alternatively, multiple newly assimilated aggregates can be produced in accordance with the invention. This allows for load balancing of I\/O traffic.","It should be understood that once the takeover is performed, all aggregate\/volumes operate as if they are local to the surviving D-module. From this point onward, there is no partner to local association as in prior systems. In addition, management processes ensure that there is a unique aggregate name throughout the cluster. It should be understood that the present invention provides a simple process for takeover of disks in a storage takeover cluster. The technique has the feature of eliminating partner mode such that it presents a newly assimilated aggregate to its upper software layers and to the N-module. In other words, the images of the disks exposed by the D-module are collapsed into a newly assimilated aggregate during takeover as opposed to requiring a separate partner and local image to be maintained.","Advantageously, the present invention reduces code complexity and operational resources. Thus, the present invention provides a system in which in any set of disks that represents an aggregate can be taken over by any D-module so that the disks are properly recognized as being served by the surviving D-module. It is further noted that the procedure described herein is accomplished without involvement of the processes of the N-module.","The foregoing description has been directed to particular embodiments of the invention. It will be apparent, however, that other variations and modifications may be made to the described embodiments, with the attainment of some or all of their advantages. Specifically, it should be noted that the principles of the invention may be implemented in a non-distributed file system. Furthermore, while this description has been written in terms of D and N-modules, the teachings of the present invention are equally suitable to systems where the functionality of the N- and D-modules is implemented in a single system. Alternatively, the functions of the N- and D-modules may be distributed among a number of separate systems, wherein each system performs one or more functions. Additionally, the features of the present invention have been described with respect to a cluster which contains two nodes, however, it is equally applicable to clusters including a plurality of nodes, which allow for n-way fail over. Additionally, the procedures, processes and\/or modules described herein may be implemented in hardware, software, embodied as a computer readable medium having program instructions, firmware, or a combination thereof. Therefore, it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The above and further advantages of the invention may be better understood by reference to the following description in conjunction with the accompanying drawings in which like reference numerals indicate identical or functionally similar elements:",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIGS. 12A and 12B"}]},"DETDESC":[{},{}]}
