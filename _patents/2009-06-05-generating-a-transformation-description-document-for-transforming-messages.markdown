---
title: Generating a transformation description document for transforming messages
abstract: The present disclosure provides a system and method of generating a transformation specification document describing transformations for transforming a received message conforming to a second interface definition to a message conforming to a first interface definition. The system and method comprise loading the first interface definition into memory; loading the second interface definition into memory; determining all additional elements of the second interface definition loaded into memory not contained in the first interface definition loaded into memory; generating processing logic for removing all of the determined additional elements from the received message; and generating the transformation specification document using the generated processing logic. The present disclosure further relates to a computer program product generating a transformation specification document.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08522135&OS=08522135&RS=08522135
owner: International Business Machines Corporation
number: 08522135
owner_city: Armonk
owner_country: US
publication_date: 20090605
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present application claims priority of U.S. provisional patent application No. 61\/059,504, filed Jun. 6, 2008 and entitled \u201cGenerating a Transformation Description Document for Transforming Messages Between Formats,\u201d the contents of which are incorporated herein by reference in their entirety.","The Service Oriented Architecture (SOA) is a software architecture for implementing web applications. When using the SOA, an application is composed of a set of agents that communicate with each other using a defined set of Application Programming Interfaces (APIs) which may be described using a standard interface definition language (IDL), such as WSDL (Web Service Description Language) or some other language.","An agent that implements an interface is known as a provider or producer agent and an agent that uses an interface is known as a requester or consumer agent. An agent may be both a provider agent and requester agent.","Agents are loosely coupled together. The communication between agents occurs using the defined APIs. Two provider agents may be considered interchangeable if they implement the same set of APIs. Two requester agents may be considered interchangeable if they use the same set of APIs. An agent that is both a provider agent and requester agent may be considered interchangeable if they implement the same set of APIs and use the same set of APIs. An agent may be replaced with an interchangeable agent without requiring changes to other agents in the SOA application.","Developers of an SOA application, that may include both requester and producer agents, may develop the agents separately. The developers may update or modify the producer and requester agents independently, as long as they share a common interface. For example, a developer may update a requester agent by adding a better user interface for displaying information received from the producer agent. This new version of the requester agent can communicate with the producer agent using the same common interface as was used by the old requester agent. Likewise, the developers may update the producer agent, for example to generate information in a more efficient manner. So long as the new version of the producer agent implements the common interface used by the previous version of the producer agent, the requester agents will be able to communicate with the new producer agent.","Although agents are loosely coupled to other agents, they are tightly coupled to the interfaces. Agents are tightly coupled to the interfaces that they use or implement, since changing an interface requires changing both the producer agent and requestor agent that implement or use the interface. The tight coupling of agents to the interfaces causes problems for developing new SOA applications or components that may benefit from a different interface. In order to implement and use a new interface definition, both new requester agents and producer agents are required. It may be difficult to distribute all of the new components to update the old versions at the same time. This can result in an old requester agent trying to communicate with a new producer agent, or new requester agents trying to communicate with old producer agents, which will not work since they do not share a common interface.","Attempts to address this limitation have included isolating the core logic of the producer or requester agent from the interface implementation. This allows for different interfaces to be implemented using specific adaptors that compensate for differences between the interface and the core logic APIs. For example, a producer agent could be created with a new version of the core logic and an adaptor for implementing an older interface. The adaptor would be hard-coded and specific to both the new core version and the interface definition it is implementing. Another producer agent may also be created using the same core version but with a different adaptor that implements a new interface definition, for example, for supporting new features in the core version. An old requester agent can connect to the producer agent that includes the adaptor implementing the older interface. A new requester agent could connect to the producer agent that includes the adaptor implementing the new interface.","The use of adaptors for implementing an interface and adapting it to core logic provides flexibility in defining the interface, as well as the core logic, since both the interface and the core logic may change independently. However, whenever a new interface or new version of core logic is developed, a new adaptor needs to be created. Each adaptor is specific to a particular interface definition, and converts received messages into requests that can be handled by the specific core logic, as well as, converting messages from the core logic into messages that conform to the particular interface definition. As the core logic evolves, this solution requires that new adaptors be created for bridging the new core logic with the different agent interfaces. This can result in having to develop numerous adaptors to support different versions of interfaces, which may be difficult as the adapter requires specific knowledge of the functions of the new core logic. Each adaptor bridges messages from one version of an interface definition to the new core logic.","Another attempt to address this limitation requires maintaining multiple cores in a single component. Each core implements a particular version of the interface. This allows for the interface definition of the agent to change significantly over time since the older interface definition remains implemented by the core. However, this causes the agent to continually increase in size and complexity, making it more difficult to maintain the agent.","A further solution to the limitation is to force the responsibility of compatibility onto system administrators. This requires systems administrators to ensure that all components in the system use the correct version. While this solution simplifies the design and authoring of the agents, it is a difficult solution for system administrators, especially as the size of the system and number of agents increase.","It is desirable to have a mechanism to provide at least some flexibility to modify interfaces or core logic of agents, while remaining simple to maintain compatibility between versions.","In accordance with an embodiment of the present disclosure, there is provided a method of generating a transformation specification document. The transformation specification document describes transformations for transforming a received message conforming to a second interface definition to a message conforming to a first interface definition. The method comprises: loading the first interface definition into memory; loading the second interface definition into memory; determining all additional elements of the second interface definition loaded into memory not contained in the first interface definition loaded into memory; generating processing logic for removing all of the determined additional elements from the received message; and generating the transformation specification document using the generated processing logic.","In accordance with a further embodiment of the present disclosure, there is provided a system generating a transformation specification document. The transformation specification document describes transformations for transforming a received message conforming to a second interface definition to a message conforming to a first interface definition. The system comprising: a processor executing instructions; and a memory, operatively coupled to the processor, storing instructions. The instructions when executed by the processor are operable to: load the first interface definition into memory; load the second interface definition into memory; determine all additional elements of the second interface definition loaded into memory not contained in the first interface definition loaded into memory; generate processing logic for removing all of the determined additional elements from the received message; and generate the transformation specification document using the generated processing logic.","In accordance with still a further embodiment of the present disclosure, there is provided a computer program product generating a transformation specification document. The transformation specification document describes transformations for transforming a received message conforming to a second interface definition to a message conforming to a first interface definition. The computer program product comprising: a computer usable medium having computer usable program code embodied therewith, the computer usable program code comprising: computer usable program code configured to load the first interface definition into memory; computer usable program code configured to load the second interface definition into memory; computer usable program code configured to determine all additional elements of the second interface definition loaded into memory not contained in the first interface definition loaded into memory; computer usable program code configured to generate processing logic for removing all of the determined additional elements from the received message; and computer usable program code configured to generate the transformation specification document using the generated processing logic.","Illustrative embodiments of the present disclosure are described with reference to producer agents and requester agents. Although the description refers to these agents as distinct components, it is understood that an agent can act as both a producer and requester agent at the same time. For example, it is possible for a producer agent to produce information (to be consumed by a requester agent) by consuming information it requested from a different producer agent. In such a situation, the producer agent may implement an interface for sending and receiving information to a requester agent, and use another interface for communicating with the other agent. For the sake of clarity, the requester agent and producer agent are described as separate agents, and implement only a single interface definition.","An interface definition describes a contract between agents. The interface definition describes a format and semantics for the communication between the two agents. If both agents share a common interface definition, the agents can communicate with each other by sending messages that conform to the common interface definition. An interface definition describes an Application Programming Interface (API). An agent can communicate with an agent that implements an API by sending messages formatted according to the API. For example, the following listing describes a simple interface definition for a producer agent that receives an employee number and returns an employee name associated with the employee number.","Example Interface Definition:","Method name: getEmployee","input: employeeNumber: Integer","output: employeeInfo: employeeInformation","Type name: employeeInformation","Name: String","ID: Integer","A producer agent that implements the interface definition will be able to receive a message containing an integer (the employeeNumber) and return a message containing data of the type employeeInformation, which has a string (the employeeInformation.Name) and an associated integer (the employeeInformation.ID). A requester agent that uses the interface definition may send a message containing an integer (the employee number) and receive in response a message containing data of the type employeeInformation (the employee name and employee ID). The interface definition provides a common language that the agents can use to communicate with each other. The interface definition describes the format of messages, and possibly the format of complex types used in the message.","The above listing of the example interface definition is not described in any particular interface definition language (IDL). It is understood that the interface could be described in a more formal IDL, such as a Web Service Description Language (WSDL).","The following listing lists an implementation of the example interface definition in pseudo code for both a provider or producer agent and a requester agent. It is understood that the listing is only for highlighting the implementation of the interface in the producer agent and requester agent.",{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"providerAgent:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"employeeInformation {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Name : String"]},{"entry":[{},"ID : Integer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"employeeInformation getEmployee(employeeNumber : Integer) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"employeeInfo : employeeInformation"]},{"entry":[{},"employeeInfo = infoOfEmployeeNumber(employeeNumber)"]},{"entry":[{},"return employeeInfo"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"requesterAgent:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"employeeInformation {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Name : String"]},{"entry":[{},"ID : Integer"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"displayEmployee(num : Integer){"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"employee : employeeInformation"]},{"entry":[{},"employee = providerAgent.getEmployee(num)"]},{"entry":[{},"display(employee.Name)"]},{"entry":[{},"display(employee.ID)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The implementation of the illustrative requester agent sends a message to the provider agent, using the common interface, requesting the employee information associated with an employee ID number. The provider agent receives the message, retrieves the information, for example, from a database, and sends a response back to the requester agent. The requester agent receives the response and may, for example, display the results.","Referring to , there is shown illustrative components of an SOA application . The SOA application  comprises two co-operating agents , . A requester agent  may send and receive messages  to and from a producer agent . The requester agent  may comprise a requester component . The requester component  may include business logic  and interface logic  for using an interface implemented by another agent. The business logic  and the interface logic  do not need to be separate as depicted in . The business logic  is used by the requester agent  to consume information in a desired way. For example, the business logic  may display received information, it may process the received information and generate new requests to other agents, it may produce a response to a different agent based on the information, etc. The requester agent  may comprise further components in addition to the requester component, such as additional requester components for communicating with different agents. The interface definition  describes a required format of messages for sending and receiving information to and from the producer agent . The interface logic  uses the interface definition  to send and receive information to and from the producer agent  using messages . The format of the messages  conform to the interface definition .","In order for the requester agent  to have information to consume, the producer agent  may send information. The producer agent  is similar to the requester agent ; however, it includes a producer component  instead of a requester component . The producer component  may receive, process, and send information to and from the requester agent  in messages . The producer component  includes business logic  for producing the information. For example, the business logic may generate the information internally, it may request the information from external sources, such as for example databases, it may produce the information based on information it has received from a different producer agent, etc. In addition to the business logic , the producer component  also includes interface logic  for implementing the interface definition, referred to as an interface implementation  that implements the same interface definition  used by the requester agent . Although the requester agent  and the producer agent  both implement the same interface definition, the implementations are different as each implements one side of the communication interface. In addition to the producer component , the producer agent may include further components, such as further producer components for communicating with additional requester agents.","In the above pseudo code listing of the requester component of an agent, the business logic  of the requester component  may be considered the pseudo code for receiving a request to display an employee's name associated with an employee number (i.e., \u201cdisplayEmployee(num: Integer)\u201d) and the pseudo code for displaying the employee name (i.e., \u201cdisplay(employee.Name)\u201d and \u201cdisplay(employee.ID)\u201d). The interface logic  for using the interface definition, may be considered the pseudo code for sending the employee ID number to the producer component of a producer agent  and receiving the employee information in response (i.e., \u201cemployee=providerAgent.getEmployee(num)\u201d). Similarly, the business logic  of the producer component  may be considered the pseudo code for determining the employee name associated with the employee ID number (i.e., \u201cemployeeInfo=infoOfEmployeeNumber(employeeNumber)\u201d). The interface logic for implementing the interface definition, that is the interface implementation , may be considered the pseudo code for receiving the employee number (i.e., \u201cemployeeInformation getEmployee(employee Number: Integer)\u201d) and the pseudo code for returning the employee information in response (i.e., \u201creturn employeeInfo\u201d).","Referring to , there is shown an SOA application . The SOA application  comprises a producer agent  and two requester agents , . The producer agent  and requester agents ,  may be implemented using computer hardware including a processor for executing instructions stored in memory. The components of the SOA application  may be provided by executing instructions stored in the memory. The requester agent  comprises a requester component  that uses an old version of the interface , described by the interface definition . The requester agent  comprises a requester component  that uses a new version of the interface , described by interface definition . The producer agent  is similar to the producer agent , however the producer agent  has two interface implementations ,, from which messages for the producer component  may be received. Each interface implementation , implements the interface described by the separate interface definitions ,. For the purposes of this description, it is assumed that interface definition  is an earlier version (the old version) of interface definition  (the new version). For example, the old version of the interface definition  may be the example interface described above for returning an employee's information associated with an employee ID number. The new version of the interface definition  may include the getEmployee method; however, it may be modified to return, in addition to the employee name and ID number, the department the employee works in. A new version of the example interface definition is shown in the following listing.","Example Interface Definition V2:\n\n","The old requester agent  can send and receive information, using the interface logic  of the requester component , to the producer agent , which implements the interface  used by the requester agent . The producer agent  may pass the received messages to the producer component . The messages sent between the requester agent  and the producer agent  conform to the old interface definition .","The new requester agent  can send and receive information, using the interface logic  of the requester component , to the producer component , of the producer agent , which implements the interface  used by the requester agent . The messages sent between the requester agent  and the producer agent  conform to the new interface definition .","Referring to , there is shown components for supporting multiple versions of an interface in a producer agent. The producer agent  includes a new producer component  that implements  the new version of the interface definition . The new producer component  does not implement the old interface definition . This may help to simplify the creation and maintenance of the new interface definition , and corresponding implementation  by the producer component .","The new requester agent  can communicate directly with the new producer component  of the producer agent  using the interface implementation  of the new interface definition . Messages sent using the interface  conform to the new interface definition . The old requester agent  includes a requester component  that uses the old interface . The old requester agent  does not communicate directly with the new producer component  since they do not implement the same interface. Support for the old requester agent  is achieved without requiring the new producer component  to implement the old interface definition . A version filter  has been added to the producer agent , and can send and receive messages to and from the new producer component . The messages passed between the version filter  and the new producer component  conform to the interface definition . The version filter  implements  the old interface definition , and so can communicate directly with the old requester agent . The version filter  passes messages it receives from the old requester agent  to the new producer component  of the producer agent . The version filter  also passes messages from the new producer component  to the old requester agent ; however, the version filter  first strips any information in the message conforming to the new interface definition  that is not found in the old interface description . By passing messages received from the old requester agent  to the new producer component , and by filtering new information from messages sent from the new producer component  to the old requester agent , the version filter  provides support for multiple versions of requester agents , to communicate with the new version of the producer component . The use of the version filter  provides flexibility in creating new interfaces since a version filter can be used to maintain support for the older requester agents .","In a broad sense, the version filter  acts as a bridge between message formats, receiving messages of one format and transforming them to another format. However, to overcome the difficulty of writing a new filter for transforming messages from each old version to the new version of the interface definition, an evolution constraint  is introduced. The evolution constraint  is a rule or collection of rules that describes how the old version of the interface definition  can be modified to create the new version of the interface definition . Broadly, the evolution constraint  requires that the new interface definition  be a superset of the old interface definition . This allows messages received from the old requester agent  to be passed directly to the new producer component  using the version filter , and messages to be sent from the new producer component  to the old requester agent  to be passed through the version filter  which filters out any information in the response message that is not defined in the old interface definition .","The evolution constraint  may be more specific. It can specify that the definition of messages sent from the old requester agent  to the new producer component  cannot change, and that the definition of messages that are sent from the new producer component  to the old requester agent  can only be added to, that is the messages include all of the information of the old interface description  and may include additional information. The added information in the response message may be removed from response messages sent to the old requester agent  by the version filter  which creates a response message that conforms to the old interface definition . This results in the new producer component  being able to process messages sent from the old requester agent  and provide responses according to the new interface definition , which are stripped of additional information and returned to the old requester agent  in a response message that conforms to the old interface definition. As such, the old requester agent  passes the messages to the version filter , which may pass the message directly to the new producer agent without processing the message. The filter may be designed to add or remove information to the request message; however, the evolution constraint may need to be more complex, for example, defining a default value for new information to be added to the request message, so that the message conforms to the new interface definition implemented by the new producer component . The new producer component  receives the message that conforms to a request message defined by the new interface definition , processes it, and returns a message conforming to the new interface definition to the version filter . The version filter  receives the message and filters out the new information not supported by the old requester agent  and sends the message to the old requester agent . Due to the loose coupling of components in an SOA application, an old producer agent can be replaced with the version filter  without requiring any changes be made to the old requester agent  since both the old producer agent and the version filter  implement the same interface. This can greatly simplify the upgrading, maintenance and support of SOA applications.","The illustrative new interface definition listed above is a properly constrained evolution of the previous illustrative interface definition. The definition of messages received from requesters has not changed, namely getEmployee still sends an Integer. As such the old and new versions can communicate this information. However the response to the message has changed. The employeeInformation type has been augmented to include the additional information for the employee's Department. However, it conforms to the evolution constraint . The version filter  transforms the new version of the message to the old version by stripping the Department information of the employee from the new version of the message.","The version filter  has been described as passing messages received from old requester agent  to the new producer component  without processing them. If, however, the evolution constraint allows the request messages of the new interface definition to have new information, the version filter may process the received messages prior to sending them to the new producer agent. This processing may include, for example, adding default values to the received messages for the new information required by the new interface definition. Similarly, the request message could be processed to strip information from the message not used by the new interface. The evolution constraint may need to specify the default values to be added to request messages if they are allowed to include new information.","Referring to , there is shown the communication between components of the SOA application. The producer agent  comprises a version filter  and a new producer component  as described above with reference to . The SOA application  comprises an old requester agent  and a new requester agent  as described above with reference to  and . For the sake of clarity, the communication between the new producer component  and the old requester agent  and the communication between the new producer component  and the new requester agent  are described as occurring separately. It is understood that the processing of messages may be interleaved, or multiple agents may be supported to process multiple messages concurrently.","The requester component  of the old requester agent  sends a message conforming to the old interface definition (). The old requester agent  sends the message to the location that the old producer component was previously found and which the old requester agent  is configured to use. The old producer component has been replaced at the producer agent  with the version filter , and so the message arrives at the version filter . The version filter  implements the same interface as the old producer component, and as such the old requester agent  does not need to know a change has been made. As a result of the evolution constraint, the new producer component  can process the old request message, and so the version filter  passes the request message on to the new producer component  () without processing it. The new producer component  processes the message to produce a response (). The response message to the request message is sent to the version filter  (). The response message conforms to the new interface definition  and includes additional information not described in the old interface definition . The version filter  processes the received response message (). The processing strips the additional information from the received response message to create a stripped response message conforming to the old interface definition . The version filter  sends the stripped response message conforming to the old interface definition  to the old requester agent  (). The old requester agent  receives the stripped response message and consumes the information (), for example, displaying the information.","The requester component  of the new requester agent  implements the new version of the interface definition , and as such can communicate directly with the new producer component . The new requester agent  sends a request message to the new producer component  (). The request message conforms to the new interface definition . The new producer component  receives the request message and processes it (). The new producer component  sends a response message back to the requester component  of the new requester agent  (). The new requester agent  receives the message conforming to the new interface definition  and processes it (), for example, displaying the information.","The new requester agent  is able to communicate directly with the new producer component , since both share the same common version of the interface description. In order to communicate with the producer component , the new requester agent requires information about where the new producer component  is located. This information can be included in the interface definition. For example, if the interface definition is described using WSDL, the \u201cservices\u201d section of the WSDL can be included, which describes a Universal Resource Identifier (URI) defining the location of the new producer component . Requester agents may be configured to send request messages to the specified URI.","From the above description, it is clear that if the interface definition changes in accordance with an evolution constraint, support for multiple versions of the interface can be provided efficiently through a version filter. Furthermore, by implementing the version filter  external to the new producer component , only communication between the old requester agent  has to pass through the version filter . Any new requester agents can communicate directly with the new producer component . The new producer component  does not differentiate from the messages received and processed from new requester agents and old requester agents through the version filter . It is possible to remove the version filter  at any time, without disturbing the operations of the new requester agents or the new producer components. For example, support for old, previous versions of an interface can be removed after a sufficient amount of time has passed to allow all requester agents to be upgraded to a newer version by simply removing the version filter .","Referring to , there is shown an illustrative embodiment of a producer agent in accordance with the present disclosure. The producer agent  comprises a servlet  and a servlet filter . The servlet  and the servlet filter of the producer agent  integrate with the facilities provided by a servlet container . The servlet container  provides a framework for servlets to operate in. A producer agent, such as producer agent , may be implemented as a servlet and servlet filter configured and operating within a servlet container. A servlet  can be registered to be run by the servlet container . The registration of a servlet  may include specifying an address or URI that messages are sent to for processing by the servlet. Servlet filter , can be registered with the servlet container  in a similar manner. The servlet filter  may be registered to process messages sent to the URI previously registered to the old producer component.","The servlet container may provide functionality to the servlet and servlet filter that, for example, handles the message passing between senders and the servlet and servlet filter. The servlet filters may be chained together, with each servlet filter in the chain processing the message prior to being processed by the servlet. The servlet container maintains these filter chains as well as the passing of messages between servlet filters of the chain, as the servlet filters typically have no knowledge about other servlet filters.","The servlet filter  implements  the old interface definition. The servlet container  receives the messages destined for an address or URI and passes them on to the servlet , or the servlet filter  registered for processing messages sent to that URI. A message from a servlet filter can be passed onto another servlet filter. A message from a servlet filter may also be passed to a servlet. The passing of messages between servlet filters and servlet may be provided by the functionality of the servlet container .","The servlet container  depicted in  may be implemented using various technologies, such as an Apache Tomcat container. The servlet container  provides the framework for the servlet  and servlet filter . The servlet  is registered with the servlet container , and associated with a location or URI  that messages are received at. The servlet  provides the interface implementation  of the new interface definition . The servlet container  also provides the framework for the servlet filter . The servlet filter  is registered with the servlet container , and associated with a location or URI . The location  may be the same location that the old version of the producer component implemented in the servlet  was associated with. This allows old requester agents to communicate with the servlet filter  which processes the message, before being passed to the new servlet , without requiring any changes to the old requester agent. The servlet filter  provides the interface implementation  of the old interface definition  used by the old requester agent.","When a message arrives at the new location  (), the servlet container  passes the message to the servlet  () associated with the address through the servlet registration. The servlet agent  receives the message and processes it () as described above. The response message is returned to the servlet container () and sent to the new requester agent that sent the request message ().","When a message arrives at the old location  (), the servlet container  passes the message to the servlet filter  (). Assuming the evolution constraint of the interface definitions allow the input messages to remain the same, the servlet filter  passes the message to the servlet  () without processing it. The message may be passed from the servlet filter  to the servlet agent  though the servlet container . The servlet agent  processes the message () and prepares a response message. The response message, which conforms to the new version of the interface definition  is sent to the servlet filter  () through the servlet container , which processes the message (). The processing of the message may include stripping additional information not present in the old version of the interface definition . The stripped message is returned to the servlet container () and returned to the old requester agent that sent the request message ().","Referring to , there is shown components of an illustrative version filter  in accordance with an embodiment the present disclosure. The version filter  comprises a message transformer  that sends and receives messages that conform to the old interface definition . The version filter  described is intended to process XML messages, such as those sent in SOAP messages over HTTP. It is understood that the XML messages do not need to be sent in a SOAP message over HTTP. For example, the XML message could be sent as part of a Multipurpose Internet Mail Extension (MIME) message. In such a case, pre-processing of the MIME message may be required to identify the XML message. The XML message component of the MIME message may be extracted and processed by the version filter. The response message may be inserted into the MIME message and returned.","When the messages are expressed in XML, the filter can use an XSL\/T engine  and a generated XSL\/T document to transform the messages from one version to another. The message transformer  may then pass received messages to the XSL\/T engine  which processes them to transform them into a message conforming to the appropriate version of the interface definition. The message transformer  then passes the transformed message to the appropriate location, for example, the old requester agent . As described above, messages received from the old requester can be passed directly to the new producer agent, while messages received from the new producer agent are processed by the XSL\/T engine  to produce the stripped message, which is then sent to the old requester agent . The message transformer  may pass request messages to the XSL\/T engine for processing if needed, for example, to add default values to the message. Although the message transformer  may add a default value to a message, it may be more appropriate or efficient to implement the servlet agent or the producer component  to add the default values to the messages.",{"@attributes":{"id":"p-0067","num":"0073"},"figref":"FIG. 7","i":"a ","b":["702","704","706","708","710"]},{"@attributes":{"id":"p-0068","num":"0074"},"figref":["FIG. 7","FIG. 7","FIG. 7","FIG. 7"],"i":["b ","b ","b ","a","b","b","b","b"],"b":["704","704","702","702","706","706","708","710","710"]},"Although depicts the chaining of multiple version filters together, this approach will add to the processing cost since each filter needs to parse, process and serialize the response. It would be more efficient to have separate version filters to translate messages from the newest interface definition used by the provider agent to some older interface definition used by one or more requester agents.","The processing of the response message by version filters can use the XSL\/T engine to strip any information present in the new interface definition out of the message that is not present in the old interface definition . The processing results in a stripped message as the response which may be returned from the XSL\/T engine to the message transformer , which passes the message onto the requester agent . To produce a different version filter, it is only necessary to provide a different XSL\/T document  that describes how to transform messages from one version to the other version.","If the messages are expressed in XML, the version filter  may transform the message using the message transformer , the XSL\/T engine  and the generated XSL\/T document  as described above. The message transformer  and XSL\/T engine  may be re-used in different version filters , for example, for transforming a second older version of the interface definition to the new version of the interface definition, or alternatively, to an intermediary version of the interface. All that is required is a different XSL\/T document  be generated that describes how to process the messages.","By enforcing the evolution constraint on new versions of interface definitions, it ensures that messages formatted according to the new interface definition can be processed using the XSL\/T engine  and generated XSL\/T document  and transformed into the message formatted according to the old interface definition.","The generated XSL\/T document  is based on the differences between the two versions of the interface definitions , . The generated XSL\/T document  may be generated in different ways. For example, depending on the evolution constraint  the generated XSL\/T document  may be written by hand. Alternatively, knowledge of the evolution constraint  may be used to generate the XSL\/T document  as described further below.","New version filters  can be generated when a new version of the interface definition is created. Different version filters can be created by simply using a different XSL\/T document. Since the XSL\/T document  can be automatically generated, new version filters can be automatically created when a new interface is defined. The message transformer  and XSL\/T engine  of the version filter  can be reused across different version filters.","The generated XSL\/T document  may be automatically generated, using another XSL\/T document, if the interface definitions are expressed in XML and follow the interface evolution constraints described above. An example of a structured language suitable for describing the interface definitions is a Web Service Description Language (WSDL), which is specified in XML.","It will be appreciated that the generated XSL\/T document describes how the XSL\/T engine of the version filter should process messages conforming to a first interface definition to generate messages conforming to a second interface definition. The version filter may process messages in other ways besides using an XSL\/T engine. In such cases, the version filter may use a transformation specification document for describing how the version filter should process the messages. The transformation specification document may include processing logic for processing the messages. For example, processing logic may be added to the transformation specification document for each element in both interface definitions that will cause the version to include the element in the processed message. Alternatively, the processing logic may indicate to the version filter which elements to exclude when processing messages. When the transformation specification document is a generated XSL\/T document, the processing logic of elements may be XSL\/T templates.","Referring to , there is shown an interface definition  expressed in a pseudo WSDL language. Referring to , there is shown an interface definition  expressed in a pseudo WSDL language. The interface definition  may be considered the old version of the interface, and the interface definition  may be considered the new version of the interface. The interface definitions , do not adhere to the formal WSDL requirements, rather they use a pseudo-WSDL type language to express the message and types in a clear manner, in order to highlight the addition of information in the new interface definition . The interface descriptions of and are similar to the illustrative interface descriptions of above; however, generic names have been used. One skilled in the art will appreciate that a complete WSDL interface definition will include additional elements, such as particular bindings for specifying the location of services or agents for sending and receiving messages to and from.","The old interface definition  and the new interface definition  each include three sections of an interface definition expressed using pseudo-WSDL. They are \u201ctypes\u201d , \u201cmessages\u201d  and \u201cporttypes\u201d . Generally, both interface definitions describe data types in the types section . The data types describe the type of information that is exchanged between the requesters and producers (or whatever components implement the interface definition). The types are used in the message section of the interface definition. The message section  describes the structure of messages that can be sent between the agents that implement and use the defined interfaces. The structure of the messages comprise one or more data types, which may be defined in the types section  of the interface definition, or may include predefined types, such as the simple types \u201cinteger\u201d or \u201cstring\u201d. It is understood that the interface definition may refer to other namespaces that include the predefined types. The messages are used in porttypes section . A porttype refers to supported operations. The operations are described by the messages that are sent between the agents. Porttypes in WSDL can contain one or more operations, which may refer to an input message, an output message, and fault messages, in any combination. This can allow requester agents to send information to the producer agents, without requiring the producer agent to respond, or for the producer agent to send information to a requester agent without being requested. The operations of interface definition may also indicate that both input and output messages are part of the porttype. For example, an agent may receive a request for information in an input message, and send the response in an output message. By implementing and using the interface definition, agents can send and receive messages to other agents which will be able to process the message appropriately.","The interface definition  differs from the interface definition  only in the type sections . Although interface definition  differs from the interface definition  only in the type sections , other changes are possible; for example, new port types, operations and messages could be defined in the new interface definition . As with the examples listed above, the old interface definition describes a method that receives an integer and responds with a string and integer. The evolution of the old interface definition to the new interface definition has been constrained, and only adds new information to the response message. That is, the type of the output message now includes, in addition to the string and integer of the old version, a new string, namely \u201cvarC\u201d. In addition to the new information for the response message of an existing method, the new interface definition may describe new methods and new types; however, the version filter does not need to consider these new types and methods since no message sent from an old requester agent will use the new methods or types.","Since the new version of the interface definition  conforms to the evolution constraint, with respect to the old interface definition , an XSL\/T document may be generated automatically to be used by the XSL\/T engine of the version filter. In order to automatically generate the XSL\/T document, knowledge of the evolution constraint is used. Since the new version of the interface definition only adds to the old version of the interface definition, any elements in the new version of the interface definition not found in the old version have been added. The messages according to the new version of the interface definition should be stripped to remove the added elements.","Referring to , there is shown a flow chart of a method for automatically generating a transformation specification document. The method begins by loading the old version of the interface definition  () and the new version of the interface definition  (). The interface definitions may be loaded as a Document Object Model (DOM) tree. The method gets the next element of the new version of the interface definition (). If the method has just started, the next element will be the first element in the interface definition, for example, the root node of the DOM tree if used. It is then determined if the element is found in the old version of the interface definition (). If the element is found in the old version of the interface definition (Yes at ), processing logic is generated () for the element that has been added to the new version of the interface definition. The processing logic specifies which elements to copy from messages conforming to the new version of the interface definition when generating messages to conform to the old version of the interface definition. The processing logic is then added to the transformation specification document () to be used by the version filter when generating messages conforming to the old version of the interface definition from messages conforming to the new version of the interface definition. Next, the new version of the interface definition loaded into memory is checked to determine if there are more elements (). If there are more elements (Yes at ), processing returns to get the next element (). If the element is determined not to be in the old version of the interface definition (No at ), nothing further is required, as this element should not be found in messages conforming to the old version of the interface definition, and processing continues to determine if there is another element in the new version of the interface definition (). If there are no more elements (No at ), the transformation specification document is returned (), which will include processing logic for the elements to be copied from messages conforming to the new version of the interface definition when generating messages conforming to the old version of the interface definition.","The processing logic added to the transformation specification document according to the method described with reference to  indicate explicitly which elements to copy from the new version messages to the old version messages. The default action for elements not explicitly specified in the transformation specification document is to not copy them. Alternatively, the transformation specification document may be created so that the default action is to copy all elements from messages conforming to the old version of the interface definition when generating messages conforming to the new version of the interface definition. In such a case, the processing logic added to the transformation specification document will explicitly indicate the elements that are not to be copied. In such a case, the method described with reference to  would be altered so that the processing logic is generated () and added to the transformation specification document () when the element is not in the old version of the interface definition. Regardless of whether the transformation specification document specifies explicitly which elements to copy, or which elements to delete, it will be appreciated that the transformation specification document has processing logic that cause the added element to be removed from messages conforming to the new version of the interface definition to create messages conforming the old version of the interface definition.","A method for generating a generated XSL\/T document is described below. The method generates the generated XSL\/T document in 2 passes based on the new and old versions of the interface definitions loaded into memory. The first pass processes complex types and simple types and their interface elements and generates a first pass result tree marking the types and their interface elements as requiring processing or deletion. The second pass makes a final determination as to what types need processing based on the first pass result tree. The second pass accounts for base types of complex types that are not accounted for in the first pass.","The first pass goes through the new version of the interface definition and for each complex type in the new interface definition that does not have simple content and is not a restriction of another type in the new interface definition, the method marks the complex type for deletion if it does not exist in the old version of the interface definition. If the complex type does exist in the old version of the interface definition, the method goes through each interface element in the complex type in the old version of the interface definition, and if the interface element does not exist in the new version of the interface definition it is marked to indicate that the old interface element is not in the new version of the interface definition. The method also goes through each interface element of the complex types in the new interface definition and, if the interface element does not exist in the complex type of the old interface definition, marks the interface element as not being in the old interface definition.","Once all of the complex types in the new interface definition that do not have simple content and are not restrictions of other types are processed, the method reports any interface elements marked as being in the old interface definition but not in the new interface definition as a violation of the evolution constraint. The method then builds processing rules for the complex types in the new version of the interface definition. The complex type is marked for deletion if it does not exist in the old interface definition. The complex type is marked as requiring processing if any interface elements in the complex type of the new interface were marked as not being in the complex type of the old interface. For any interface elements in complex types of the new interface definition marked as requiring processing, the method marks the interface element of the complex type as requiring processing if the interface element exists in the old interface definition, and marks the interface element for deletion if it does not exist in the old version of the interface definition.","The first pass of the method also processes each simple type of the new version of the interface definition in a similar manner as complex types. The first pass goes through the new version of the interface definition, and for each simple type in the new interface definition, the method marks the simple type and its enumeration elements for processing or deletion. If the simple type of the new interface definition exists in the old version of the interface definition, the method goes through each enumeration element in the simple type in the old version of the interface definition, and if the enumeration element does not exist in the new version of the interface definition, it is marked to indicate that the old enumeration element is not in the new version of the interface definition. The method also goes through each enumeration element of the simple type in the new interface definition and, if the enumeration element does not exist in the simple type of the old interface definition, marks the enumeration element as not being in the old interface definition.","Once all of the simple types in the new interface definition are processed, the method reports any enumeration elements marked as being in the old interface definition but not in the new interface definition as a violation of the evolution constraint. The method then builds processing rules for the simple types in the new version of the interface definition. The simple type is marked for deletion if it does not exist in the old interface definition. The simple type is marked as requiring processing if any enumeration elements in the simple type of the new interface were marked as not being in the simple type of the old interface definition. For any enumeration elements in simple types of the new interface definition marked as requiring processing, the method marks the enumeration element of the simple type as requiring processing if the enumeration element exists in the old interface definition, and marks the enumeration element for deletion if it does not exist in the old version of the interface definition.","After generating the first pass result tree, the method generates a second pass result tree using the information in the first pass result tree. For each type (both complex types and simple types), the method makes a final determination regarding whether the type requires processing by examining the type and each of its base types.","Types in the second pass result tree will either be marked for deletion, marked for processing, or not marked. Types that are unchanged between the two versions of the interface definition are unmarked and will be processed by a default XSL\/T template in the generated XSL\/T document. The default template copies the element of an unchanged type and then processes all of the contained elements. If an element is marked for deletion, an XSL\/T template is generated for the element in order to avoid the element being processed with the default XSL\/T template; however, the XSL\/T template does not process any of the element, and so the element will not be copied to the generated message. If an element is marked for processing, an XSL\/T template is generated that copies the element and then selectively processes the appropriate set of contained elements.","As described above, the generated XSL\/T document may copy all elements by default and explicitly exclude the types and elements marked for deletion. Alternatively, the default XSL\/T template may not copy any types or elements, and so the elements marked for processing or that are unmarked must be processed by an XSL\/T template while the types and elements marked for deletion may be processed by the default XSL\/T template.","The generated XSL\/T document to process messages is created by analyzing the two interface definition documents as described above and generating XSL\/T templates that will process the content of the messages that is defined in both interfaces. One form of content processing copies the content from the received message to the processed message. For each complex type and simple type in the new interface, if the type does not exist in the old interface, nothing is done, which will mean that the type will not be output, or in other words the information is stripped, by the filter when generating the message conforming to the old interface definition. If the type does exist in the old interface definition, an XSL\/T template is generated and added to the generated XSL\/T document that will pull information from messages conforming to the new interface definition and copy it to messages conforming to the old interface definition. When the XSL\/T templates are being generated for handling the types, the base class elements are handled, and the XSL\/T template is generated to process elements marked for processing in the second pass result tree. Unmarked elements may be processed by the default XSL\/T template which copies the elements. Elements marked for deletion are excluded from being copied with an XSL\/T template that does nothing, in order to avoid the elements being copied and processed by the default XSL\/T template.","In order to be able to exclude information when generating the old version of the response, knowledge of the hierarchy of the interface definition must be known. All elements of a type are at the same level in the interface definition, even if some elements are defined in a base class, when excluding information, the base elements would need to be handled in the XSL\/T template for each derived type.","Referring to , there is shown a component for automatically generating the generated XSL\/T document . The XSL\/T generator  comprises an XSL\/T engine  and a compiler XSL\/T document . The compiler XSL\/T document  is used by the XSL\/T engine  to determine the elements added to the new version of the interface definition, which is shown as the pseudo-WSDL interface definition . The XSL\/T engine compares the new version of the interface definition  to the old version of the interface definition  according to the compiler XSL\/T in order to determine the added elements of the new interface definition. The compiler XSL\/T also describes the template to be added to the generated XSL\/T document  for the added elements of the new interface definition. The added template of the generate XSL\/T document results in the XSL\/T engine not copying the added element from a response message when the message is processed by the XSL\/T engine  of the version filter  using the generated XSL\/T document .","As is understood in the art, an XSL\/T engine matches patterns specified in the XSL\/T document to patterns in the input documents, and applies templates specified in the XSL\/T document and associated with the matched pattern, to generate the output document.","The compiler XSL\/T document  is created to use a pattern based on the evolution constraint that the new version of the interface definition will be a superset of the old version. The pattern indicates that the element (or node if a DOM tree is used by the XSL\/T element) is in the new version of the interface definition and not in the old version of the interface definition. Associated with the pattern is the template that is added to the generated XSL\/T document to strip the matched element from messages.","The use of the XSL\/T generator  and the compiler XSL\/T document as described can help to reduce development and testing costs associated with new versions. The compiler XSL\/T document can be used to automatically generate a generated XSL\/T document to produce a version filter. The version filter with the generated XSL\/T document may process the messages in a consistent manner.","The compiler XSL\/T document can compare any two interface definitions that conform to the interface evolution constraint to produce the generated XSL\/T document used by the version filter to convert messages between the two versions.","The above description has referred to SOA applications as including a requester agent or requester communicating with a producer agent or producer. Although the interaction and cooperation between the components form a useful software application as a whole, the individual components may also be considered separate software applications in so far as they can run independently of each other.",{"@attributes":{"id":"p-0099","num":"0105"},"figref":"FIG. 11","b":["1102","1104","1106","1104","1110","1102","1106","1110"]},"The processor  may be a central processing unit (CPU), a microprocessor, an application specific integrated circuit (ASIC), a field programmable gate array (FPGA) or other type of processor capable of executing instructions. The processor may include the hardware and controlling code such as firmware or basic input\/output system (BIOS) used to configure the processor  and other components of the computer . The processor  may be implemented in one or more physical packages. Each package may include one or more processor cores for executing instructions.","The memory  may include different levels of memory, including both volatile and nonvolatile memory for storage of information. The memory  stores instructions and data for providing the computer  with the functionality of a XSL\/T Generator as described herein, depicted as XSL\/T Generator memory block  in . The memory  may include, for example, registers for storing instructions to be executed by the processor , flash memory, electrically erasable programmable read only memory (EEPROM), random access memory (RAM), hard disk drives (HDD), solid state drives (SSDs), or other types of devices for storing information. The memory  may store the instructions to be executed by the processor to provide the system and method described herein. The instructions may be stored in different levels of the memory at the same time. For example, an instruction may be copied from a HDD to RAM to a register of the processor  prior to being executed by the processor . The results of processing the instruction or instructions may be stored in memory  Storing the instructions of the system and method described herein in the memory  alters one or more characteristics of the memory, such as the electrical characteristics of one or more cells of the memory .","The I\/O devices  may include input and output devices. Input devices may include devices for inputting information to the computer , for example, mice, keyboards, keys, switches, cameras, scanners, microphones, touch panels or screens, or other input devices as known by one of ordinary skill in the art. The output devices may display or convey information and may include, for example, monitors, televisions, Braille devices, lights, printers, speakers, actuators and other output devices as known by one of ordinary skill in the art.","The computer buses may include one or more buses for connecting the memory  and I\/O devices  with the processor , or each other. The buses may be internal or external buses and may include the physical connectors required to connect components to the buses. Different buses are known, and may include for example, peripheral component interconnect (PCI), PCI express (PCIe), industry standard architecture (ISA), advanced technology attachment (ATA), serial ATA (SATA), small computer system interface (SCSI), universal serial bus (USB), IEEE 1394 (FireWire\u2122). The buses may also include buses for controlling the computer such as a front side bus (FSB), address bus, or control bus.","As will be appreciated by one skilled in the art, the present invention may be embodied as a system, method or computer program product. Accordingly, the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, the present invention may take the form of a computer program product embodied in any tangible medium of expression having computer usable program code embodied in the medium.","Any combination of one or more computer usable or computer readable medium(s) may be utilized. The computer-usable or computer-readable medium may be, for example but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, device, or propagation medium. More specific examples (a non-exhaustive list) of the computer-readable medium would include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CDROM), an optical storage device, a transmission media such as those supporting the Internet or an intranet, or a magnetic storage device. Note that the computer-usable or computer-readable medium could even be paper or another suitable medium upon which the program is printed, as the program can be electronically captured, via, for instance, optical scanning of the paper or other medium, then compiled, interpreted, or otherwise processed in a suitable manner, if necessary, and then stored in a computer memory. In the context of this document, a computer-usable or computer-readable medium may be any medium that can contain, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device. The computer-usable medium may include a propagated data signal with the computer-usable program code embodied therewith, either in baseband or as part of a carrier wave. The computer usable program code may be transmitted using any appropriate medium, including but not limited to wireless, wire line, optical fiber cable, RF, etc.","Computer program code for carrying out operations of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","The present invention has been described below with reference to flowchart illustrations and\/or block diagrams of methods, systems and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer-readable medium that can direct a computer or other programmable data processing apparatus to function in a particular manner, such that the instructions stored in the computer-readable medium produce an article of manufacture including instruction means which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer or other programmable data processing apparatus to cause a series of operational steps to be performed on the computer or other programmable apparatus to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","The flowchart and block diagrams in the Figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical functionality. It should also be noted that, in some alternative implementations, the functionality noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functionality or acts, or combinations of special purpose hardware and computer instructions."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["Embodiments of the invention will be described with reference to the drawings in which:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7","i":"a "},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7","i":"b "},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 8","i":["a ","b "],"b":"8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
