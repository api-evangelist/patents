---
title: Responsive user interface with background application logic for working on an object
abstract: A user interface can be maintained in a responsive state on a user interface thread while synchronous application logic is running on a background thread. The application logic can access an object on the background thread, and the user interface can access the same object on the user interface thread. Additionally, a request for work to be done on an object can be received. If the request is to be dispatched to a background thread, then the work can be dispatched to the background thread without blocking the user interface thread. However, if the request is to be dispatched to the user interface thread, then the work can be dispatched to the user interface thread, and the background thread can be blocked.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08418190&OS=08418190&RS=08418190
owner: Microsoft Corporation
number: 08418190
owner_city: Redmond
owner_country: US
publication_date: 20091124
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["End users expect modern connected applications to be responsive even with multiple tasks being active at the same time. To address this expectation, some developers learn and implement asynchronous patterns and architectures, which can allow a user interface to be unblocked while application logic is running. Average developers are used to synchronous patterns and architectures, where all tasks are executed in a serial manner. Asynchronous patterns and architectures can be difficult for such developers to understand and correctly implement.","Whatever the advantages of previous user interface and application logic tools and techniques, they have neither recognized the tools and techniques for a responsive user interface with background application logic described and claimed herein, nor the advantages produced by such tools and techniques.","In one embodiment, the tools and techniques can include maintaining a user interface in a responsive state on a user interface thread while running synchronous application logic on a background thread. The application logic can access an object on the background thread, and the user interface can access the same object on the user interface thread. As used herein, a user interface is considered to be in a responsive state when it is able to respond to user input and updates. Synchronous application logic is logic for an application that can operate correctly if tasks are performed in an order prescribed in the logic. As used herein, an object is an entity, such as a value, variable, function, or data structure, which can be manipulated by one or more threads in a computing environment, such as a thread running a user interface and\/or a thread running application logic.","In another embodiment of the tools and techniques, a request for work to be done on an object can be received. Work is used broadly to refer to any type of manipulation of an object, such as modifying the object, loading information from the object, etc. It can be determined whether the work is to be dispatched to at least one background thread running application logic or to at least one user interface thread running one or more user interface elements. If the request is to be dispatched to the at least one background thread, then the work can be dispatched to the at least one background thread without blocking the at least one user interface thread. However, if the request is to be dispatched to the at least one user interface thread, then the work can be dispatched to the at least one user interface thread, and the at least one background thread can be blocked.","In yet another embodiment of the tools and techniques, one or more user interface elements can be run on a user interface thread. The user interface element(s) can represent at least a portion of a business object. Business logic can be applied to the business object on a background thread, and the business object can be modified on the user interface thread. The background thread can be blocked while the object is modified on the user interface thread. As used herein, a business object is an object that represents one or more business items, such as a person (customer, vendor, employee, etc.), an invoice, a conference room, a building, etc. Business logic is application logic that is applied to one or more business objects, such as logic applied so that an object operates as expected for the type of business item(s) the object represents, or logic applied so that the object configures to rules of a particular business entity (rules for which user objects can access a particular type of invoice, etc.).","This Summary is provided to introduce a selection of concepts in a simplified form. The concepts are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter. Similarly, the invention is not limited to implementations that address the particular techniques, tools, environments, disadvantages, or advantages discussed in the Background, the Detailed Description, or the attached drawings.","Embodiments described herein are directed to improved techniques and tools for allowing a user interface to remain responsive while application logic is running in the background. This may be done without the application logic developer needing to have an understanding of asynchronous development techniques. Such improvements and\/or others may result from the use of various techniques and tools separately or in combination.","Such techniques and tools may include having an object that can be accessed by a user interface thread and a background thread. Synchronous application logic can be run on the background thread. Thus, the developer of that application logic may not implement or even understand asynchronous patterns and coding techniques. While the application logic is running on the background thread, a user interface can be maintained in a responsive state on the user interface thread. The user interface thread can be running even when the background thread is executing application logic related to the object.","When the user interface thread receives user input requesting that the object be manipulated, the user interface thread can fulfill the request asynchronously by forwarding the user input to the background thread and then proceeding without synchronously waiting for the manipulation code to complete. Forwarding and\/or sending communications, such as requests, user input, etc., may include translating the communication into a different form, combining it with other communications, separating it into parts, etc. The background thread can process the user input with the application logic. If the object is to be manipulated, then the background thread may directly access the object and manipulate it. However, in some situations, a user interface element may need to be notified on the user interface thread that the object has been manipulated. If so, a work request can be sent to the user interface thread for the user interface thread to perform the manipulation itself so that change notifications can be raised on the user interface thread, as expected. In this case, the background thread can synchronously wait for the user interface thread to complete the manipulation.","Communications between the user interface and background threads may be conducted through the object. Accordingly, the background and user interface threads can each interact with the object as they would normally interact with application objects. However, the object can include functionality to interact with both threads, and to pass tasks and communications between the two threads.","Accordingly, one or more substantial benefits may be realized from the tools and techniques described herein. For example, developers can develop synchronous application logic to run on the background thread. For example, the functionality of the objects to interact with multiple threads can be built into a software development system, such as Microsoft's Visual Studio\u00ae development system. A developer can use the development system to develop an application with application logic provided by the developer and\/or the development system, such as an application developed in the Visual Studio\u00ae development system to run on Microsoft's Silverlight\u00ae browser plug-in. However, other types of applications and\/or other types of software development systems could be used. Regardless of the specific development system and\/or application type, developers can structure the application logic synchronously. However, as noted above, the tools and techniques described herein can allow the user interface to forward to the background thread user input that requests object manipulation, and to proceed without synchronously waiting for the manipulation code to complete the requested manipulation. Accordingly, the user interface thread and the user interface elements running on the user interface thread can be responsive, even while application logic is running in the background thread.","The subject matter defined in the appended claims is not necessarily limited to the benefits described herein. A particular implementation of the invention may provide all, some, or none of the benefits described herein. Although operations for the various techniques are described herein in a particular, sequential order for the sake of presentation, it should be understood that this manner of description encompasses rearrangements in the order of operations, unless a particular ordering is required. For example, operations described sequentially may in some cases be rearranged or performed concurrently. Techniques described herein with reference to flowcharts may be used with one or more of the systems described herein and\/or with one or more other systems. For example, the various tools and techniques described herein may be implemented with hardware or software, or a combination of both. Moreover, for the sake of simplicity, flowcharts may not show the various ways in which particular techniques can be used in conjunction with other techniques.","I. Exemplary Computing Environment",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":"100"},"The computing environment () is not intended to suggest any limitation as to scope of use or functionality of the invention, as the present invention may be implemented in diverse general-purpose or special-purpose computing environments.","With reference to , the computing environment () includes at least one processing unit () and memory (). In , this most basic configuration () is included within a dashed line. The processing unit () executes computer-executable instructions and may be a real or a virtual processor. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power. The memory () may be volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory), or some combination of the two. The memory () stores software () implementing a responsive user interface with background application logic, such as synchronous background application logic.","Although the various blocks of  are shown with lines for the sake of clarity, in reality, delineating various components is not so clear and, metaphorically, the lines of  and the other figures discussed below would more accurately be grey and fuzzy. For example, one may consider a presentation component such as a display device to be an I\/O component. Also, processors have memory. The inventors hereof recognize that such is the nature of the art and reiterate that the diagram of  is merely illustrative of an exemplary computing device that can be used in connection with one or more embodiments of the present invention. Distinction is not made between such categories as \u201cworkstation,\u201d \u201cserver,\u201d \u201claptop,\u201d \u201chandheld device,\u201d etc., as all are contemplated within the scope of  and reference to \u201ccomputer,\u201d \u201ccomputing environment,\u201d or \u201ccomputing device.\u201d","A computing environment () may have additional features. In , the computing environment () includes storage (), one or more input devices (), one or more output devices (), and one or more communication connections (). An interconnection mechanism (not shown) such as a bus, controller, or network interconnects the components of the computing environment (). Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment (), and coordinates activities of the components of the computing environment ().","The storage () may be removable or non-removable, and may include computer-readable storage media such as magnetic disks, magnetic tapes or cassettes, CD-ROMs, CD-RWs, DVDs, or any other medium which can be used to store information and which can be accessed within the computing environment (). The storage () stores instructions for the software ().","The input device(s) () may be a touch input device such as a keyboard, mouse, pen, or trackball; a voice input device; a scanning device; a network adapter; a CD\/DVD reader; or another device that provides input to the computing environment (). The output device(s) () may be a display, printer, speaker, CD\/DVD-writer, network adapter, or another device that provides output from the computing environment ().","The communication connection(s) () enable communication over a communication medium to another computing entity. Thus, the computing environment () may operate in a networked environment using logical connections to one or more remote computing devices, such as a personal computer, a server, a router, a network PC, a peer device or another common network node. The communication medium conveys information such as data or computer-executable instructions or requests in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired or wireless techniques implemented with an electrical, optical, RF, infrared, acoustic, or other carrier.","The tools and techniques can be described in the general context of computer-readable media. Computer-readable media are any available media that can be accessed within a computing environment. By way of example, and not limitation, with the computing environment (), computer-readable media include memory (), storage (), and combinations of the above.","The tools and techniques can be described in the general context of computer-executable instructions, such as those included in program modules, being executed in a computing environment on a target real or virtual processor. Generally, program modules include routines, programs, libraries, objects, classes, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer-executable instructions for program modules may be executed within a local or distributed computing environment. In a distributed computing environment, program modules may be located in both local and remote computer storage media.","For the sake of presentation, the detailed description uses terms like \u201cdetermine,\u201d \u201cchoose,\u201d \u201cadjust,\u201d \u201csend,\u201d and \u201coperate\u201d to describe computer operations in a computing environment. These and other similar terms are high-level abstractions for operations performed by a computer, and should not be confused with acts performed by a human being, unless performance of an act by a human being (such as a \u201cuser\u201d) is explicitly noted. The actual computer operations corresponding to these terms vary depending on the implementation.","II. System and Environment for Responsive User Interface with Application Logic",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":["200","200","210","210","212","210"]},"A. User Interface Components","A user interface () can include one or more user interface elements, which can represent at least a portion of the object (). For example, the user interface may include one or more standard user interface elements (lists, checkboxes, text boxes, buttons, diagrams, pictures, etc.) representing one or more data fields in the object (). The user interface can run on a user interface thread (), or possibly on multiple user interface threads (not shown), such as in a thread pool. The user interface thread () may be dedicated to the user interface (), or it may be shared, such as with other user interfaces. The user interface thread () can receive tasks from a user interface task queue () according to standard queuing practices (first-in-first-out ordering, etc.). A user interface dispatcher () can receive tasks from the scheduler () in the object (), and can enter them in the user interface task queue () to be executed on the user interface thread (). Also, the user interface thread () can access the object (), such as to pass modification or access requests to the object (). Notifications can also be raised for one or more listeners (such as the user interface ()) on the user interface thread () when the object () is manipulated, such as by having information from the object loaded or by modifying the object ().","B. Logic and Background Components","Application logic (), such as business logic, can run on the background thread () and can be applied to the object (). For example, the application logic () may include standard logic that controls the modification of and access to the object (). The application logic () can run on a background thread (). Indeed, the application logic () can run on multiple background threads (), such as in a thread pool configuration, and the thread(s) may or may not be dedicated to running the application logic (). A background task queue () can provide tasks to the background thread () according to standard queuing practices (first-in-first-out ordering, etc.). A background dispatcher () can receive tasks from the scheduler () in the object (), and can enter them in the background task queue () to be executed on the background thread (). Also, the background thread () can access the object (), such as to pass modification or access requests to the object (). Notifications can also be raised for one or more listeners (such as listeners from the application logic ()) on the background thread () when the object () is manipulated.","C. Object Interaction with the User Interface and Background Threads","The operation of the object () and the interaction of its scheduler () with the user interface dispatcher () and the background dispatcher () can allow the synchronous application logic () to run on the background thread () in an asynchronous manner (i.e., the application logic () can run on the background thread () while the user interface () remains unblocked and responsive on the user interface thread ()). Work can be dispatched to the user interface dispatcher () to run in a synchronous manner when the work is initiated by the background thread () (i.e., the user interface thread () can perform dispatched work from the background thread () while the background thread () is blocked). This can allow conflicts between the threads ( and ) to be avoided because the background thread () can be blocked while the user interface thread () actually manipulates the object (). Moreover, the user interface () can remain responsive while the application logic () is running, even though the application logic () is synchronous.","The scheduler () can have an implicit awareness of both the user interface dispatcher () and the background dispatcher () for the object (). As will be discussed in more detail below, the object () can have defined behavior for being accessed from either the user interface thread () or the background thread (), so that both user interface data binding and background application logic tasks can work concurrently. Thus, the object () can manage common operations from the perspective of either thread ( or ), and can orchestrate work between the user interface dispatcher () and the background dispatcher () so that each thread ( and ) can see a consistent view of the business object () without being aware of the other thread ( or ).","The object () can operate so that the user interface thread is not blocked, even when application logic () is being run on the object (). The application logic () can be executed by the background dispatcher () on a background thread (). This execution of application logic () can include commands, data validation, property calculations, data access, etc. Tasks for the user interface (), such as data binding and the execution of user interface elements, can be executed by the user interface dispatcher () on the user interface thread (). The user interface thread () and the background thread () may initiate property gets and sets, and command invocation on the business object (). Additionally, the user interface thread () and the background thread () can listen on change events for the object (), such as property and list change events. Notifications can be raised on the listener's own thread ( or ).","Additionally, the object () and its scheduler () can move work back and forth between the dispatchers ( and ), and can block the background thread as needed. This configuration can allow both the user interface () and the application logic () to see a consistent view of the object (), and to allow the user interface () to remain responsive even when the application logic () is running on the object ().","With these features of the computing environment (), one or more benefits may be realized. For example, both the user interface thread () and the background thread () can see a consistent state of the business object (), without data races or cache coherency issues between threads. The application logic () can be written as if it was to run in a synchronous environment, even though it can run at the same time the user interface () is responsive.","Thus a developer of the application logic () can write it in a synchronous manner, and can typically interact with just the current background thread () while debugging. Moreover, for an end user, the user interface () can remain responsive and largely consistent with the true state of the object (), as represented by the background thread (). An application running the application logic () and user interface () can run without hanging when the application logic () is running, and the user interface () can refresh immediately to indicate changes to the current state of the business object ().","While the user interface () can remain largely consistent, there may be some time lags in updating information on the user interface () while updates to the information are being processed by the background thread (). If the time lag is too long, the user interface () may inform a user that the background thread is working (such as by updating a value). This could be done by the user interface () asking the background dispatcher () if it is currently processing, and if so, then informing the user that the value may be changed. For example, the user interface could present an intermediate pending state if there is pending work.","An application may interact with multiple objects (). In one configuration, each such object () can have its own dedicated background dispatcher (). Alternatively, a more complex background dispatcher () may be able to interact with multiple objects. This may also involve a more complex object (), such as an object including a more complex scheduler (). An application may also have multiple user interfaces (), such as where an application has multiple screens and each screen is considered a separate user interface (). Each such user interface () may have its own dedicated user interface dispatcher () dispatching tasks to one or more threads. Again, however, a more complex user interface dispatcher () and\/or a more complex object () could allow a user interface dispatcher () to be shared among multiple user interfaces () and\/or multiple user interface threads ().","III. Dual-Threaded Data Reads and Writes","Techniques for dual-threaded data reads and writes of objects will now be discussed with reference to .  are simplified to omit details, such as user interface and background dispatchers, and an object scheduler. However, user interface and background dispatchers can be used to dispatch tasks to the respective threads, and a scheduler in the object can schedule tasks between the different threads\/dispatchers for the techniques of , as discussed above with reference to .","A. Dual-Threaded Data Reads of an Object","Referring now to , an example of a technique () for performing dual-threaded data reads of information from an object will be discussed.  illustrates an object () in the center. A user interface () can represent at least a portion of the object () and can run on a user interface thread (), which is illustrated to the left of the object (). To the right of the object (), application logic () is illustrated running on a background thread (). Actions that are later in time are shown lower in the figure in , as well as in  discussed below, although some reordering of the actions may be done in practice.","The user interface () may initiate a data read. For example, this may be done in response to user input requesting a user interface element to display information from the object (). Accordingly, the user interface () can send a request () to the object () to get the information (such as information about a customer, information about an invoice, etc.). For example, this may include making an application programming interface (API) call to the object (). The object () can recognize that the call came from a user interface thread (), rather than a background thread. Accordingly, the object () can return the current information requested without loading the information. This can result in the object sending a null information return () to the user interface () on the user interface thread ().","The object () can also forward the information request to the application logic () on the background thread () by queuing () the get request () to the background thread (). In response to the get request () being queued () to the background thread (), the application logic () can be applied () to the get request (). For example, the application logic () may be applied () to determine whether a user is authorized to access the requested information under application logic (). If the requested read of information is authorized, the application logic () running on the background thread () can send a get request () (such as by issuing an API call to the object ()), requesting the information from the object ().","The object can recognize that the get request () is from the background thread (), and can block () the background thread (), while loading and setting the object () on the user interface thread (). For example, this may be done by the object () queuing a task on the user interface thread () that will result in the user interface thread () issuing a low level call to load and set the requested information from the object (). The object () can recognize this low level call and, rather than forwarding it to the background thread (), can load and set () the requested information on the user interface thread (). This can result in a notification () of the change (the loading and setting of the requested information) being issued to one or more listeners on the user interface thread. The user interface () can receive the notification (), and can respond by reading the newly-loaded information and updating any corresponding elements in the user interface ().","In addition, the object () can unblock () the background thread and issue change notifications () to one or more listeners on the background thread. In addition, the requested information can be returned () to the application logic () in the background thread () in response to the get request ().","In this technique, the application logic () can be applied synchronously in the background thread () to the request () to get information about the object. While this is being done, the user interface () can keep running on the user interface thread () without being blocked, so that the result is actually parallel operations of the background thread () and the user interface thread (). Accordingly, the user interface () can remain responsive to a user's input, even while the application logic () is being applied to the get request (). However, the background thread can be blocked () while the user interface thread () loads and sets () the requested information, so that conflicts between the two threads ( and ), such as data races, can be avoided. This can be done while allowing the application logic () to be structured in a synchronous manner, relieving the application logic developer from having to apply complex asynchronous coding techniques.","The background thread can also get data directly on the background thread without involving the user interface thread if the get is not expected to be done on the user interface thread. This may be done where a value is not being mutated by caching a value just retrieved or setting a value (such as where the data get request is for a value that has already been loaded). When receiving a request from the background thread to get data, the object can determine whether the get can be done on the background thread, or whether the get is to be done on the user interface thread.","B. Dual-Threaded Data Writes to an Object","Referring now to , an example of a technique () for performing dual-threaded data writes of information to an object will be discussed. Similarly to ,  illustrates an object () in the center. A user interface () represents at least a portion of the object () and runs on a user interface thread (), which is illustrated to the left of the object (). To the right of the object (), application logic () is illustrated running on a background thread ().","The user interface () may initiate a data write, for example, in response to user input making a change to a user interface element corresponding to information in the object (). Accordingly, the user interface () can send a set request () to the object () to modify the information by setting the new information in the object (). For example, this may include making an API call to the object (). The object () can recognize that the call came from a user interface thread (), rather than a background thread. Accordingly, the object () can send a return () to the user interface () without actually setting the information.","The object () can also forward the information request to the application logic () on the background thread () by queuing () the set request () to the background thread (). In response to the set request () being queued to the background thread (), the application logic () can be applied () to the request. For example, the application logic () may be applied () to determine whether a user is authorized to modify the requested information under application logic, or to determine whether to initiate related modifications to the object () or one or more other objects. If the requested write of information is authorized, the application logic () running on the background thread () can send a set request () (such as by issuing an API call to the object ()), requesting that the information be set.","The object () can recognize that the set request () is from the background thread (), and can block () the background thread (), while the object () is modified on the user interface thread (). For example, this may be done by the object () queuing a task on the user interface thread () that will result in the user interface thread () issuing a low level call to modify the object () by setting the new information. The object () can recognize this low level call and, rather than forwarding it to the background thread (), can set () the requested information on the user interface thread (). This can result in a notification () of the change (the setting of the requested information) being issued to one or more listeners on the user interface thread (). The user interface () can receive the notification (), and can respond by reading the newly-set information and updating any corresponding elements in the user interface ().","In addition, the object () can unblock () the background thread () and issue change notifications () to one or more listeners on the background thread (). In addition, a return () can be sent to the application logic () in the background thread in response to the set request (), reporting that the information was successfully set.","Similarly to the data read technique () above, in this data write technique () the application logic () can be applied synchronously in the background thread () to the request () to set information about the object (). While this is being done, the user interface () can keep running on the user interface thread () without being blocked, so that the overall result is an asynchronous operation. Accordingly, the user interface () can remain responsive to a user's input, even while the application logic () is being applied to the set request (). However, the background thread can be blocked () while the user interface thread () sets () the requested information, so that conflicts between the two threads ( and ), such as data races, can be avoided. This can be done while allowing the application logic () to be structured in a synchronous manner, relieving the application logic developer from having to apply complex asynchronous coding techniques.","The background thread can also set data directly on the background thread without involving the user interface if the value being set is independent in meaning to other values and does not create a potential inconsistency during inspection of the object by the user interface. When receiving a request from the background thread to set data, the object can determine whether it can be set on the background thread or whether it is to be set on the user interface thread.","IV. Techniques for Responsive User Interface with Background Application Logic","A technique for a responsive user interface with background application logic will be discussed with reference to . Referring first to , in the technique, synchronous application logic can be run () on at least one background thread, and the application logic can access an object. The object can be a business object, and the application logic can be business logic. While the application logic is running (), a user interface can be maintained () in a responsive state on at least one user interface thread, and the user interface can access the object. Maintaining () the user interface in the responsive state can include not blocking the at least one user interface thread, and maintaining () can also include accessing the object on the at least one user interface thread.","Referring to , the technique can also include sending () a user input request from the at least one user interface thread to the object, and forwarding () the user input request from the object to a dispatcher for the at least one background thread. In addition, the technique can include, in response to receiving the user input request, dispatching () the user input request to a working thread of the at least one background thread, applying () the application logic to the user input request on the working thread, sending () a work request from the working thread to the object; and forwarding () the work request from the object to a dispatcher for the at least one user interface thread. The technique can also include performing () the work on the object (setting information in the object, loading information from the object, etc.) on the least one user interface thread in response to receiving the work request at the dispatcher for the at least one user interface thread. In addition, the at least one background thread can be blocked () while performing () the work on the at least one user interface thread. For example, if the at least one background thread is a thread pool, blocking may include blocking multiple threads or just blocking a thread that is actively processing the work.","Referring now to , another technique for a responsive user interface with background application logic will be discussed. In the technique, a request can be received () to do work on an object, such as a business object. For example, the work can include loading information from the object, setting information in the object, etc. The request can be received () at the object itself. It can be determined () whether the work is to be dispatched to at least one background thread running application logic (such as business logic) or to at least one user interface thread running one or more user interface elements. For example, determining () whether the work is to be dispatched to the at least one background thread or to the at least one user interface thread can include determining whether the request came from the at least one background thread or from the at least one user interface thread. If the request came from the at least one user interface thread without being handled by the at least one background thread, then determining () whether the work is to be dispatched to the at least one background thread or to the at least one user interface thread can include determining that the work is to be done by the at least one background thread.","If the request is to be dispatched to the at least one background thread, then the work can be dispatched () to the at least one background thread without blocking the at least one user interface thread. However, if the request is to be dispatched to the at least one user interface thread, then the work can be dispatched () to the at least one user interface thread, and the at least one background thread can be blocked ().","If the work is dispatched () to the at least one background thread, then the technique can also include applying () the application logic to the request on the at least one background thread.","Referring now to , yet another technique for a responsive user interface with background application logic will be discussed. The technique can include running () one or more user interface elements on at least one user interface thread. The one or more user interface elements can represent at least a portion of a business object. A user input request can be sent () from the at least one user interface thread to the at least one background thread. Business logic can be applied () to the business object on the at least one background thread, and the business object can be accessed () on the at least one background thread without blocking the at least one user interface thread. Also, a modification request can be sent () from the at least one background thread to the at least one user interface thread. For example, the modification request can be sent to the object and forwarded from the object to the at least one user interface thread. The modification request can be sent () in response to a user input request sent from the at least one user interface thread to the at least one background thread. Sending the user input request from the at least one user interface thread to the at least one background thread can include sending the user input request to the object and forwarding the user input request from the object to the at least one background thread.","The business object can be modified () on the at least one user interface thread, and the at least one background thread can be blocked () while the at least one user interface thread modifies the business object. The modification () can be done in response to the request from the at least one background thread. After the business object is modified (), the at least one background thread may be unblocked ().","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
