---
title: Protecting software environment in isolated execution
abstract: The present invention is a method and apparatus to protect a subset of a software environment. A key generator generates an operating system nub key (OSNK). The OSNK is unique to an operating system (OS) nub. The OS nub is part of an operating system in a secure platform. A usage protector uses the OSNK to protect usage of a subset of the software environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07082615&OS=07082615&RS=07082615
owner: Intel Corporation
number: 07082615
owner_city: Santa Clara
owner_country: US
publication_date: 20000922
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCES TO RELATED APPLICATIONS","BACKGROUND","DETAILED DESCRIPTION"],"p":["This is a continuation-in-part of U.S. patent application Ser. No. 09\/540,946 filed Mar. 31, 2000.","1. Field of the Invention","This invention relates to microprocessors. In particular, the invention relates to processor security.","2. Description of Related Art","Advances in microprocessor and communication technologies have opened up many opportunities for applications that go beyond the traditional ways of doing business. Electronic commerce (E-commerce) and business-to-business (B2B) transactions are now becoming popular, reaching the global markets at a fast rate. Unfortunately, while modem microprocessor systems provide users convenient and efficient methods of doing business, communicating and transacting, they are also vulnerable to unscrupulous attacks. Examples of these attacks include virus, intrusion, security breach, and tampering, to name a few. Computer security, therefore, is becoming more and more important to protect the integrity of the computer systems and increase the trust of users.","Threats caused by unscrupulous attacks may be in a number of forms. Attacks may be remote without requiring physical accesses. An invasive remote-launched attack by hackers may disrupt the normal operation of a system connected to thousands or even millions of users. A virus program may corrupt code and\/or data of a single-user platform.","Existing techniques to protect against attacks have a number of drawbacks. Anti-virus programs can only scan and detect known viruses. Most anti-virus programs use a weak policy in which a file or program is assumed good until proved bad. For many security applications, this weak policy may not be appropriate. In addition, most anti-virus programs are used locally where they are resident in the platform. This may not be suitable in a group work environment. Security co-processors or smart cards using cryptographic or other security techniques have limitations in speed performance, memory capacity, and flexibility. Redesigning operating systems creates software compatibility issues and causes tremendous investment in development efforts.","In the following description, for purposes of explanation, numerous details are set forth in order to provide a thorough understanding of the present invention. However, it will be apparent to one skilled in the art that these specific details are not required in order to practice the present invention. In other instances, well-known electrical structures and circuits are shown in block diagram form in order not to obscure the present invention.","Architecture Overview","One principle for providing security in a computer system or platform is the concept of an isolated execution architecture. The isolated execution architecture includes logical and physical definitions of hardware and software components that interact directly or indirectly with an operating system of the computer system or platform. An operating system and the processor may have several levels of hierarchy, referred to as rings, corresponding to various operational modes. A ring is a logical division of hardware and software components that are designed to perform dedicated tasks within the operating system. The division is typically based on the degree or level of privilege, namely, the ability to make changes to the platform. For example, a ring-0 is the innermost ring, being at the highest level of the hierarchy. Ring-0 encompasses the most critical, privileged components. In addition, modules in Ring-0 can also access to lesser privileged data, but not vice versa. Ring-3 is the outermost ring, being at the lowest level of the hierarchy. Ring-3 typically encompasses users or applications level and has the least privilege. Ring-1 and ring-2 represent the intermediate rings with decreasing levels of privilege.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1A","b":["50","50","50","10","20","30","40","52","52","50","50","52"]},"Ring-0  includes two portions: a normal execution Ring-0  and an isolated execution Ring-0 . The normal execution Ring-0  includes software modules that are critical for the operating system, usually referred to as kernel. These software modules include primary operating system (e.g., kernel) , software drivers , and hardware drivers . The isolated execution Ring-0  includes an operating system (OS) nub  and a processor nub . The OS nub  and the processor nub  are instances of an OS executive (OSE) and processor executive (PE), respectively. The OSE and the PE are part of executive entities that operate in a secure environment associated with the isolated area  and the isolated execution mode. The processor nub loader  is a protected bootstrap loader code held within a chipset in the system and is responsible for loading the processor nub  from the processor or chipset into an isolated area as will be explained later.","Similarly, ring-1 , ring-2 , and ring-3  include normal execution ring-1 , ring-2 , ring-3 , and isolated execution ring-1 , ring-2 , and ring-3 , respectively. In particular, normal execution ring- includes N applications to and isolated execution ring-3 includes K applets to .","One concept of the isolated execution architecture is the creation of an isolated region in the system memory, referred to as an isolated area, which is protected by both the processor and chipset in the computer system. The isolated region may also be in cache memory, protected by a translation look aside (TLB) access check. Access to this isolated region is permitted only from a front side bus (FSB) of the processor, using special bus (e.g., memory read and write) cycles, referred to as isolated read and write cycles. The special bus cycles are also used for snooping. The isolated read and write cycles are issued by the processor executing in an isolated execution mode. The isolated execution mode is initialized using a privileged instruction in the processor, combined with the processor nub loader . The processor nub loader  verifies and loads a ring-0 nub software module (e.g., processor nub ) into the isolated area. The processor nub  provides hardware-related services for the isolated execution.","One task of the processor nub  is to verify and load the ring-0 OS nub  into the isolated area, and to generate the root of a key hierarchy unique to a combination of the platform, the processor nub , and the operating system nub . The operating system nub  provides links to services in the primary OS  (e.g., the unprotected segments of the operating system), provides page management within the isolated area, and has the responsibility for loading ring-3 application modules , including applets to , into protected pages allocated in the isolated area. The operating system nub  may also load ring-0 supporting modules.","The operating system nub  may choose to support paging of data between the isolated area and ordinary (e.g., non-isolated) memory. If so, then the operating system nub  is also responsible for encrypting and hashing the isolated area pages before evicting the page to the ordinary memory, and for checking the page contents upon restoration of the page. The isolated mode applets to and their data are tamper-resistant and monitor-resistant from all software attacks from other applets, as well as from non-isolated-space applications (e.g., to ), dynamic link libraries (DLLs), drivers and even the primary operating system . Only the processor nub  or the operating system nub  can interfere with or monitor the applet's execution.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1B","b":["10","10","40","50","60","60","70","80","70","72","74","80","82","84","70","80"]},"The normal execution ring-0  including the primary OS , the software drivers , and the hardware drivers , can access both the OS pages  and the application pages . The normal execution ring-3, including applications to , can access only to the application pages . Both the normal execution ring-0  and ring-3 , however, cannot access the isolated area .","The isolated execution ring-0 , including the OS nub  and the processor nub , can access to both of the isolated area , including the applet pages  and the nub pages , and the non-isolated area , including the application pages  and the OS pages . The isolated execution ring-3 , including applets to , can access only to the application pages  and the applet pages . The applets to reside in the isolated area .",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1C","b":["100","100","110","120","130","140","150","160","170","175","180","182","184","186","130","150","130","100"]},"The processor  represents a central processing unit of any type of architecture, such as complex instruction set computers (CISC), reduced instruction set computers (RISC), very long instruction word (VLIW), or hybrid architecture. In one embodiment, the processor  is compatible with an Intel Architecture (IA) processor, such as the Pentium series, the IA-32\u2122 and the IA-64\u2122. The processor  includes a normal execution mode  and an isolated execution circuit . The normal execution mode  is the mode in which the processor  operates in a non-secure environment, or a normal environment without the security features provided by the isolated execution mode. The isolated execution circuit  provides a mechanism to allow the processor  to operate in an isolated execution mode. The isolated execution circuit  provides hardware and software support for the isolated execution mode. This support includes configuration for isolated execution, definition of an isolated area, definition (e.g., decoding and execution) of isolated instructions, generation of isolated access bus cycles, and generation of isolated mode interrupts.","In one embodiment, the computer system  can be a single processor system, such as a desktop computer, which has only one main central processing unit, e.g. processor . In other embodiments, the computer system  can include multiple processors, e.g. processors , , , etc., as shown in . Thus, the computer system  can be a multi-processor computer system having any number of processors. For example, the multi-processor computer system  can operate as part of a server or workstation environment. The basic description and operation of processor  will be discussed in detail below. It will be appreciated by those skilled in the art that the basic description and operation of processor  applies to the other processors and , shown in , as well as any number of other processors that may be utilized in the multi-processor computer system  according to one embodiment of the present invention.","The processor  may also have multiple logical processors. A logical processor, sometimes referred to as a thread, is a functional unit within a physical processor having an architectural state and physical resources allocated according to some partitioning policy. Within the context of the present invention, the terms \u201cthread\u201d and \u201clogical processor\u201d are used to mean the same thing. A multi-threaded processor is a processor having multiple threads or multiple logical processors. A multi-processor system (e.g., the system comprising the processors , , and ) may have multiple multi-threaded processors.","The host bus  provides interface signals to allow the processor  or processors , , and to communicate with other processors or devices, e.g., the MCH . In addition to normal mode, the host bus  provides an isolated access bus mode with corresponding interface signals for memory read and write cycles when the processor  is configured in the isolated execution mode. The isolated access bus mode is asserted on memory accesses initiated while the processor  is in the isolated execution mode. The isolated access bus mode is also asserted on instruction pre-fetch and cache write-back cycles if the address is within the isolated area address range and the processor  is initialized in the isolated execution mode. The processor  responds to snoop cycles to a cached address within the isolated area address range if the isolated access bus cycle is asserted and the processor  is initialized into the isolated execution mode.","The MCH  provides control and configuration of memory and input\/output devices such as the system memory  and the ICH . The MCH  provides interface circuits to recognize and service isolated access assertions on memory reference bus cycles, including isolated memory read and write cycles. In addition, the MCH  has memory range registers (e.g., base and length registers) to represent the isolated area in the system memory . Once configured, the MCH  aborts any access to the isolated area that does not have the isolated access bus mode asserted.","The system memory  stores system code and data. The system memory  is typically implemented with dynamic random access memory (DRAM) or static random access memory (SRAM). The system memory  includes the accessible physical memory  (shown in ). The accessible physical memory includes a loaded operating system , the isolated area  (shown in ), and an isolated control and status space . The loaded operating system  is the portion of the operating system that is loaded into the system memory . The loaded OS  is typically loaded from a mass storage device via some boot code in a boot storage such as a boot read only memory (ROM). The isolated area , as shown in , is the memory area that is defined by the processor  when operating in the isolated execution mode. Access to the isolated area  is restricted and is enforced by the processor  and\/or the MCH  or other chipset that integrates the isolated area functionalities. The isolated control and status space  is an input\/output (I\/O)-like, independent address space defined by the processor  and\/or the MCH . The isolated control and status space  contains mainly the isolated execution control and status registers. The isolated control and status space  does not overlap any existing address space and is accessed using the isolated bus cycles. The system memory  may also include other programs or data which are not shown.","The ICH  represents a known single point in the system having the isolated execution functionality. For clarity, only one ICH  is shown. The system  may have many ICH's similar to the ICH . When there are multiple ICH's, a designated ICH is selected to control the isolated area configuration and status. In one embodiment, this selection is performed by an external strapping pin. As is known by one skilled in the art, other methods of selecting can be used, including using programmable configuring registers. The ICH  has a number of functionalities that are designed to support the isolated execution mode in addition to the traditional I\/O functions. In particular, the ICH  includes an isolated bus cycle interface , the processor nub loader  (shown in ), a digest memory , a cryptographic key storage , an isolated execution logical processor manager , and a token bus interface .","The isolated bus cycle interface  includes circuitry to interface to the isolated bus cycle signals to recognize and service isolated bus cycles, such as the isolated read and write bus cycles. The processor nub loader , as shown in , includes a processor nub loader code and its digest (e.g., hash) value. The processor nub loader  is invoked by execution of an appropriate isolated instruction (e.g., Iso_Init) and is transferred to the isolated area . From the isolated area , the processor nub loader  copies the processor nub  from the system flash memory (e.g., the processor nub code  in non-volatile memory ) into the isolated area , verifies and logs its integrity, and manages a symmetric key used to protect the processor nub's secrets. In one embodiment, the processor nub loader  is implemented in read only memory (ROM). For security purposes, the processor nub loader  is unchanging, tamper-resistant and non-substitutable. The digest memory , typically implemented in RAM, stores the digest (e.g., hash) values of the loaded processor nub , the operating system nub , and any other critical modules (e.g., ring-0 modules) loaded into the isolated execution space. The cryptographic key storage  holds a symmetric encryption\/decryption key that is unique for the platform of the system . In one embodiment, the cryptographic key storage  includes internal fuses that are programmed at manufacturing. Alternatively, the cryptographic key storage  may also be created with a random number generator and a strap of a pin. The isolated execution logical processor manager  manages the operation of logical processors operating in isolated execution mode. In one embodiment, the isolated execution logical processor manager  includes a logical processor count register that tracks the number of logical processors participating in the isolated execution mode. The token bus interface  interfaces to the token bus . A combination of the processor nub loader digest, the processor nub digest, the operating system nub digest, and optionally additional digests, represents the overall isolated execution digest, referred to as isolated digest. The isolated digest is a fingerprint identifying the ring-0 code controlling the isolated execution configuration and operation. The isolated digest is used to attest or prove the state of the current isolated execution.","The non-volatile memory  stores non-volatile information. Typically, the non-volatile memory  is implemented in flash memory. The non-volatile memory  includes the processor nub . The processor nub  provides the initial set-up and low-level management of the isolated area  (in the system memory ), including verification, loading, and logging of the operating system nub , and the management of the symmetric key used to protect the operating system nub's secrets. The processor nub  may also provide application programming interface (API) abstractions to low-level security services provided by other hardware. The processor nub  may also be distributed by the original equipment manufacturer (OEM) or operating system vendor (OSV) via a boot disk.","The mass storage device  stores archive information such as code (e.g., processor nub ), programs, files, data, applications (e.g., applications to ), applets (e.g., applets to ) and operating systems. The mass storage device  may include compact disk (CD) ROM , floppy diskettes , and hard drive , and any other magnetic or optical storage devices. The mass storage device  provides a mechanism to read machine-readable media. When implemented in software, the elements of the present invention are the code segments to perform the necessary tasks. The program or code segments can be stored in a processor readable medium or transmitted by a computer data signal embodied in a carrier wave, or a signal modulated by a carrier, over a transmission medium. The \u201cprocessor readable medium\u201d may include any medium that can store or transfer information. Examples of the processor readable medium include an electronic circuit, a semiconductor memory device, a ROM, a flash memory, an erasable programmable ROM (EPROM), a floppy diskette, a compact disk CD-ROM, an optical disk, a hard disk, a fiber optical medium, a radio frequency (RF) link, etc. The computer data signal may include any signal that can propagate over a transmission medium such as electronic network channels, optical fibers, air, electromagnetic, RF links, etc. The code segments may be downloaded via computer networks such as the Internet, an Intranet, etc.","I\/O devices  may include any I\/O devices to perform I\/O functions. Examples of I\/O devices  include a controller for input devices (e.g., keyboard, mouse, trackball, pointing device), media card (e.g., audio, video, graphics), a network card, and any other peripheral controllers.","The token bus  provides an interface between the ICH  and various tokens in the system. A token is a device that performs dedicated input\/output functions with security functionalities. A token has characteristics similar to a smart card, including at least one reserved-purpose public\/private key pair and the ability to sign data with the private key. Examples of tokens connected to the token bus  include a motherboard token , a token reader , and other portable tokens  (e.g., smart card). The token bus interface  in the ICH  connects through the token bus  to the ICH  and ensures that when commanded to prove the state of the isolated execution, the corresponding token (e.g., the motherboard token , the token ) signs only valid isolated digest information. For purposes of security, the token should be connected to the digest memory.","Protecting Software Environment in Isolated Execution","The overall architecture discussed above provides a basic insight into a hierarchical executive architecture to manage a secure platform. The elements shown in , B, and C are instances of an abstract model of this hierarchical executive architecture. The implementation of this hierarchical executive architecture is a combination of hardware and software. In what follows, the processor executive, the processor executive handler, and the operating system executive are abstract models of the processor nub , the processor nub loader , and the operating system nub  (, B, and C), respectively.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 2","b":["200","200","16","18","240","220","250","210"]},"The OS nub or OS executive (OSE)  is part of the operating system running on the secure platform . The OS nub  has an associated OS nub identifier (ID) , that may be delivered with the OS nub  or derived from an OS nub code or associated information. The OS nub ID  may be a pre-determined code that identifies the particular version of the OS nub . It may also represent a family of various versions of the OS nub . The OS nub  may optionally have access to a public and private key pair unique for the platform . The key pair may be generated and stored at the time of manufacturing, at first system boot, or later. The protected private key  may be programmed into the fuses of a cryptographic key storage  of the input\/output control hub (ICH)  or elsewhere in persistent storage within the platform . The protected private key  may be based upon a random number generated by an external random number generator. In one embodiment, the protected private key  is generated by the platform  itself the first time the platform  is powered up. The platform  includes a random number generator to create random numbers. When the platform  is first powered up, a random number is generated upon which the protected private key  is based. The protected private key  can then be stored in the multiple key storage  of the non-volatile flash memory . The feature of the protected private key  is that it cannot be calculated from its associated public key . Only the OS nub  can retrieve and decrypt the encrypted private key for subsequent use. In the digital signature generation process, the protected private key  is used as an encryption key to encrypt a digest of a message producing a signature, and the public key  is used as a decryption key to decrypt the signature, revealing the digest value.","The processor nub  includes a master binding key (BK) . The BK  is generated at random when the processor nub  is first invoked, i.e., when it is first executed on the secure platform . The key generator  generates a key operating system nub key (OSNK)  which is provided only to the OS Nub . The OS nub  may supply the OSNK  to trusted agents, such as the usage protector . The key generator  receives the OS Nub identifier  and the BK  to generate the OSNK . There are a number of ways for the key generator  to generate the OSNK . The key generator  generates the OSNK  by combining the BK  and the OS Nub ID  using a cryptographic hash function. In one embodiment, the OS nub ID  identifies the OS nub  being installed into the secure platform . The OS nub ID  can be the hash of the OS nub , or a hash of a certificate that authenticates the OS nub , or an ID value extracted from a certificate that authenticates the OS nub . It is noted that a cryptographic hash function is a one-way function, mathematical or otherwise, which takes a variable-length input string, called a pre-image and converts it to a fixed-length, generally smaller, output string referred to as a hash value. The hash function is one-way in that it is difficult to generate a pre-image that matches the hash value of another pre-image. In one embodiment, the OS nub ID  is a hash value of one of the OS Nub  and a certificate representing the OS nub . Since the security of an algorithm rests in the key, it is important to choose a strong cryptographic process when generating a key. The software environment  may include a plurality of subsets (e.g., subset ). The usage of the software environment  or the usage of the subset  is protected by the usage protector . The usage protector  uses the OSNK  to protect the usage of the subset . The software environment  may include an operating system (e.g., a Windows operating system, a Windows 95 operating system, a Windows 98 operating system, a Windows NT operating system, Windows 2000 operating system) or a data base. The subset  may be a registry in the Windows operating system or a subset of a database. Elements can be implemented in hardware or software.","The subset  is hashed by the hashing function  to produce a first hash value  and a second hash value . One way to detect intrusion or modification of the subset  is to compare the state of the subset before and after a time period. The first and second hash values  and  are typically generated at different times and\/or at different places.","The usage protector  is coupled to the key generator  to protect usage of the software environment  or the subset , using the OSNK . The usage protection includes protection against unauthorized reads, and detection of intrusion, tampering or unauthorized modification. If the two hash values are not the same, then the usage protector  knows that there is a change in the subset . If it is known that this change is authorized and an updated hash value has been provided, the usage protector  would merely report the result. Otherwise, the usage protector  may generate an error or a fault function. When a user is notified of the error, fault condition, he or she would know that the subset  has been tampered, modified. The user may take appropriate action. Therefore, the usage of the subset  is protected.","The are several different embodiments of the usage protector . In one embodiment, the usage protector  decrypts the subset using the OSNK . In two other embodiments, the usage protector  uses not only the OSNK  but also the first hash value  and the second hash value . Yet in two other embodiments, the usage protector uses the OSNK , the protected private key  and the pubic key .",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 3A","FIG. 2"],"b":["250","250","370","375","380","385","390"]},"The compressor  receives the subset  and compresses the subset  to generate a compressed subset . The encryptor  then encrypts the compressed subset  using the OSNK , producing the encrypted compressed subset . The OSNK  is provided to the usage protection  by the key generator  as shown in . At a later time, a request can be made to the OS nub  to access the encrypted compressed subset . If this request is granted, the decryptor  decrypts the retrieved encrypted compressed subset  using the OSNK , producing the retrieved compressed subset . The decompressor  then expands the retrieved compressed subset  to produce the retrieved subset . The compression operation is applied to save time (i.e. speed up) and\/or space for storing the subset  in a memory. In another embodiment, the encryptor  takes the subset  without going through the compressing process and encrypts the subset  to generate an encrypted subset using the OSNK , and the decryptor  decrypts the retrieved encrypted subset directly producing the retrieved subset . The encrypting of the compressed subset  or the subset  prevents unauthorized reads of the subset .",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 3B","FIG. 2"],"b":["250","250","305","365","310","315"]},"The encryptor  encrypts the first hash value  using the OSNK  to generate an encrypted first hash value . The encrypted first hash value  is then stored in the storage . Storage medium  may be any type of medium capable of storing the encrypted hash value . The storage medium  may be, for example, a tape or a disk (e.g., a floppy disk, a hard disk, or an optical disk). At a later time, the subset  is tested for integrity. The decryptor  decrypts the retrieved encrypted first hash value  using the OSNK . This decrypting process generates a decrypted hash value . This decrypted first hash value  is then compared to the second hash value  by the comparator  to detect if changes have been made in the subset . If the two values match, then subset  has not been changed. If the subset  is deliberately updated by an authorized agent, the stored encrypted hash value is also updated, and a subsequent integrity test again results in the two hash values ( and ) matching. If the subset  is modified by an unauthorized agent that does not update the stored encrypted hash value, then the subsequent integrity test results in differing hash values  and , signaling the unauthorized modification. The unauthorized agent cannot avoid this detection by attempting to generate its own version of the stored encrypted hash value, because the unauthorized agent does not have access to the OSNK .",{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 3C","FIG. 2"],"b":["250","250","325","320","322","330"]},"The decryptor  accepts the OS nub's encrypted private key (i.e., protected) , and decrypts it using the OSNK , exposing the private key  for use in the isolated environment. The signature generator  generates a signature  for the subset  using the private key . It is noted that the subset  may be compressed before input it into the signature generator  to generate the signature . The signature algorithm used by the signature generator  may be public-key digital signature algorithm which makes use of a secret private key to generate the signature, and a public key to verify the signature. Example algorithms include ElGama, Schnorr and Digital Signature Algorithms schemes just to name a few. In one embodiment, the generation of the signature  includes hashing the subset  to generate a before hash value, which is then encrypted using the private key  to generate the signature . The signature  is then saved in a storage medium . At a later time, the signature is retrieved from the storage , and the retrieved signature  is used, along with public key , by the signature verifier  to verify the subset . The signature verifier  verifies whether the subset  has been modified, producing a modified\/not-modified indicator . In one embodiment, the verification process includes decrypting the retrieved signature  using the public key  to expose the before hash value. The subset  is hashed to generate an after hash value. The before hash value is compared to the after hash value to detect whether the subset  has been modified. If the two hash values match, the subset  is the same as it was when the signature was generated.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 3D","b":["250","250","345","335","340","349","350","355"]},"The decryptor  accepts the OS nub's encrypted protected private key , and decrypts it using the OSNK , exposing the private key  for use in the isolated environment. The manifest generator  generates a manifest  for the subset . The manifest  represents the subset  in a concise manner. The manifest  may include a number of descriptors or entities, which characterize some relevant aspects of the subset . Typically, these relevant aspects are particular or specific to the subset  so that two different subsets have different manifests. In one embodiment, the manifest  represents a plurality of entities (i.e., a collection of entities) where each entry in the manifest  represents a hash (e.g., unique fingerprint) over one entity in the collection. The subset  is partitioned into one or more group where each group has a pointer and associated hash in the manifest . The manifest  is stored in a storage medium  for later use. The manifest  is also input to the signature generator  to generate a signature  over the manifest  using the private key . The generated signature  is also stored in a storage medium . At a later time, we desire to verify that the portions of the subset  described by the manifest have not changed. This requires verifying that the manifest itself has not been changed, and that each group in subset  described by the manifest has not been changed. The stored signature and manifest are retrieved from the storage medium . The retrieved signature , and the retrieved manifest , along with the public key , are used by the signature verifier  to test that the retrieved manifest  is unchanged from the original manifest . The signature verifier  produces a signature-verified flag , which is asserted only if the signature verifies that the manifest is unchanged. In one embodiment, the verification process includes decrypting the retrieved signature  using the public key  to expose the before hash value. The retrieved manifest  is hashed to generate an after hash value. The before hash value is compared to the after hash value to detect whether the retrieved manifest  has been modified. If the two hash values match, the retrieved manifest  is the same as it was when the signature was generated. The retrieved manifest  is also supplied to the manifest verifier , which uses the descriptive information in the retrieved manifest  to selectively verify portions of subset . In a typical embodiment, this involves hashing each group in subset , where the group is identified by information in the retrieved manifest , and comparing the newly generated hash value against the hash value for the group stored in the retrieved manifest . The manifest verifier  produces a manifest-verified flag , which is asserted if all entries described by the retrieved manifest  are verified as unchanged. If both the manifest-verified flag and the signature-verified flag are asserted, then the overall verification process passes, and the selected portions of subset  are known to be the same as when the signed manifest was originally generated, and a pass\/fail flag  is asserted. Note that the signature verifier  and the manifest verifier  can be invoked in any order.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 3E","FIG. 2"],"b":["250","250","305","311","310","315"]},"The first encryptor  encrypts the first hash value  using the OSNK . The first hash value  is provided by the hashing function  as shown in . The first encryptor  takes the first hash value  and encrypts it to generate an encrypted first hash value  using the OSNK . The encrypted hash value  is then stored in a storage  for later use. The encryption by the OSNK  allows the encrypted first hash value  to be stored in arbitrary (i.e., unprotected) storage media. Storage medium  may be any type of medium capable of storing information (e.g., the encrypted hash value ). The storage medium  may be, for example, a tape or a disk (e.g., a floppy disk, a hard disk, or an optical disk). The second encryptor   encrypts the second hash value  to generate an encrypted second hash value  using the OSNK . The second hash value  is provided by the hash function . The first encryptor  and the second encryptor  use the same encryption algorithm, and this algorithm produces identical repeatable results for a given input. The encrypted first hash value  is now retrieved from the storage  for comparing with the encrypted second hash value . The comparator  compares the encrypted second hash value  with the retrieved encrypted first hash value  to detect if the subset  has been modified or tampered with. In the case where the subset  is deliberately updated by an authorized agent, the stored encrypted hash value is also updated. Since the modification of the subset  is authorized, the second encrypted hash value  is the same as the retrieved first encrypted first hash value . In the case where the subset  has been unauthorized modified or tampered with, the comparator  generates a modified\/not-modified flag indicating the subset  has been modified and therefore, the subset  should not be used. An attacker cannot simply replace the first encrypted hash value  with one corresponding to the unauthorized modified subset , because the attacker does not have access to the OSNK  used to encrypt the hash value.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 4","b":["400","210","230"]},"Upon START, the process  checks to see whether accessing to the subset is authorized (Block ). If accessing to the subset is authorized, the process  is terminated. Otherwise, the process  checks to see if the accessing to the subset is a read or a write (Block ). If it is a write, the process  obtains the OSNK and the subset (Block ). The process  then encrypts the subset using the OSNK (Block ) and stores the encrypted subset in a storage (Block ), the process  is terminated. If accessing to the subset is a read, the process  obtains the OSNK and the encrypted subset (Block ). The process then decrypts the encrypted subset using the OSNK (Block ), the process  is the terminated.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 5","b":"500"},"Upon START, the process  checks to see whether the subset is to be updated or to be tested (Block ). If it is to be updated, the process  checks to see whether accessing the subset is authorized (Block ). If accessing the subset is not authorized, the process  is terminated. If accessing the subset is authorized, the process  obtains the OSNK and the first hash value (Block ) and encrypts the first hash value using the OSNK (Block ). The process  then stores the encrypted first hash value in a storage for later use (Block ). The process is terminated. If the subset is to be tested, the process  then obtains the OSNK and the second hash value (Block ). The process  also retrieves the encrypted first hash value from the storage (Block ) and decrypts it using the OSNK (Block ). The process  then checks to see whether the two hash values are equal (Block ). If the two hash values are equal, the process  clears \u201cmodified\u201d flag (Block ) and is terminated. Otherwise, the process  sets \u201cmodified\u201d flag (Block ) and is terminated.",{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 6"},"Upon START, the process  checks to see whether the subset is to be updated or to be tested (Block ). If it is to be updated, the process  checks to see whether the request to be updated is authorized (Block ). If it is not authorized, the process  is terminated. Otherwise, the process  obtains the OSNK, the protected private key and the subset (Block ). The process  then decrypts the protected private using the OSNK (Block ) and signs the subset using the private key (Block ). The process  stores the signature in a storage (Block ) and is terminated. If the subset is to be tested, the process  obtains the public key, the subset, and the signature (Block ). The process  verifies the subset against the signature using the public key (Block ). The process  then checks whether the subset is verified (Block ). If the subset is verified, the process  clears \u201cmodified\u201d flag (Block ) and is terminated. Otherwise, the process  sets \u201cmodified\u201d flag (Block ) and is terminated.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 7","b":"700"},"Upon START, the process  checks to see whether the subset is to be updated or tested (Block ). If it is to be updated, the process  then checks to see whether the accessing to the subset is authorized (Block ). If it is not authorized, the process  is terminated. Otherwise, the process  obtains the OSNK and the first hash value (Block ) and encrypts the first hash value using the OSNK (Block ). The process then stores the encrypted first hash value in a storage (Block ) and is terminated. If the subset is to be tested, the process  obtains the OSNK and the second hash value (Block ) and encrypts the second hash value using the OSNK (Block ). The process  then retrieves the encrypted first hash value from the storage (Block ) and checks to see whether the encrypted hashes are equal (Block ). If they are equal, the process  clears \u201cmodified\u201d flag and is terminated. Otherwise, the process  sets \u201cmodified\u201d flag (Block ) and is terminated.","While this invention has been described with reference to illustrative embodiments, this description is not intended to be construed in a limiting sense. Various modifications of the illustrative embodiments, as well as other embodiments of the invention, which are apparent to persons skilled in the art to which the invention pertains are deemed to lie within the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The features and advantages of the present invention will become apparent from the following detailed description of the present invention in which:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3D"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3E"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
