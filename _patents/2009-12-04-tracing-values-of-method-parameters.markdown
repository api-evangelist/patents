---
title: Tracing values of method parameters
abstract: Implementations of the present disclosure provide methods including receiving one or more specifications at a virtual machine that is executed using one or more processors, each specification indicating one or more methods and one or more parameters to be traced, the one or more parameters corresponding to the one or more methods, executing an application, the application calling a method of the one or more methods using the virtual machine, determining a subset of the one or more received specifications, the subset corresponding to specifications that are applicable to the method, generating an entry event corresponding to the method based on the subset, the entry event comprising event data including values of the one or more parameters, and reporting the entry event.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09129056&OS=09129056&RS=09129056
owner: SAP SE
number: 09129056
owner_city: Walldorf
owner_country: DE
publication_date: 20091204
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Software applications running in a distributed application server environment may have a plurality of concurrent users accessing the servers and applications. This can result in performance and scalability problems with the servers and applications running on the servers. Performance monitoring, profiling and debugging tools can monitor software applications running on the servers to determine resource consumption information.","Software profiling is a technique for measuring where software application programs consume resources (e.g., central processing unit (CPU) computation times, memory accesses). A profiling tool or profiler can analyze the resource consumption of an application running on a server and provide profiling data based thereon. For example, a Java profiler can support a broad set of Java virtual machines (JVMs). The Java profiler can provide comprehensive profiling of a Java application running on the JVM.","Implementations of the present disclosure provide computer-implemented methods for tracing values of one or more method parameters during execution of an application. In some implementations, a method includes receiving one or more specifications at a virtual machine that is executed using one or more processors, each specification indicating one or more methods and one or more parameters to be traced, the one or more parameters corresponding to the one or more methods, executing an application, the application calling a method of the one or more methods using the virtual machine, determining a subset of the one or more received specifications, the subset corresponding to specifications that are applicable to the method, generating an entry event corresponding to the method based on the subset, the entry event comprising event data including values of the one or more parameters, and reporting the entry event.","In some implementations, receiving one or more specifications occurs while executing the method.","In some implementations, the method further includes grouping the values into a first group and a second group, writing values of the first group directly to the entry event, transforming values of the second group based on one or more modifiers to provide one or more modified values, and writing the one or more modified values to the entry event. The modifiers can be provided in a chain of modifiers, each modifier in the chain of modifiers having an input and an output, an output of one modifier being an input of another modifier in the chain of modifiers, wherein an output of a last modifier in the chain of modifiers comprises a modified value.","In some implementations, each specification comprises a method signature.","In some implementations, the method further includes exiting the method at the virtual machine, generating an exit event, the exit event comprising event data, and determining a duration of a method call with specific parameters based on the event data of the entry event and the event data of the exit event, the event data of the exit event comprising at least one of a timestamp and a processing unit time.","In some implementations, reporting comprises at least one of transmitting the entry event to a user interface and writing the entry event to a file in a storage device.","In some implementations, reporting comprises at least one of transmitting the exit event to a user interface and writing the exit event to a file in a storage device.","In some implementations, the event data of the entry event further comprises at least one of a timestamp and a processing unit time upon corresponding to entering the method.","In some implementations, the method further includes tagging the method based on a version of the method, the version being one of a plurality of versions, and providing an index based on the tagging when reporting the entry event.","The present disclosure also provides a computer-readable storage medium coupled to one or more processors and having instructions stored thereon which, when executed by the one or more processors, cause the one or more processors to perform operations in accordance with implementations of the methods provided herein.","The present disclosure further provides a system for implementing the methods provided herein. The system includes at least a server including one or more processors, and a computer-readable storage medium coupled to the one or more processors having instructions stored thereon which, when executed by the one or more processors, cause the one or more processors to perform operations in accordance with implementations of the methods provided herein.","It is appreciated that methods in accordance with the present disclosure can include any combination of the aspects and features described herein. That is to say that methods in accordance with the present disclosure are not limited to the combinations of aspects and features specifically described herein, but also include any combination of the aspects and features provided.","The details of one or more implementations of the present disclosure are set forth in the accompanying drawings and the description below. Other features and advantages of the present disclosure will be apparent from the description and drawings, and from the claims.","Like reference symbols in the various drawings indicate like elements.","Implementations of the present disclosure are generally directed to tracing the values of method parameters in a profiled software application. More specifically, implementations of the present disclosure relate to a how a software profiling tool collects and stores original profiling data at a back-end, and provides method parameter trace data for display at a front-end. For example, method parameter trace specifications describe which parameters of which methods running in an application on a virtual machine should be traced. Additionally, the method parameter trace specifications can describe how the traced parameters are transformed into one or more parameter values that are reported and displayed to a user.","Referring now to , a schematic illustration of an exemplar system  in accordance with implementations of the present disclosure can include a plurality of clients , , and a computer system . The computer system  can include a server  and a database . In some implementations, the system  may represent a client\/server system supporting multiple computer systems (e.g., computer system ) including one or more clients (e.g., clients , ) and\/or one or more servers (e.g., server ) that are connectively coupled for communication with one another over a network . In some implementations, the clients (e.g., clients , ) may be directly connected to the one or more servers (e.g., server ) (without connecting by way of network ).","The clients ,  can represent various forms of processing devices including, but not limited to, a desktop computer, a laptop computer, a handheld computer, a personal digital assistant (PDA), a cellular telephone, a network appliance, a camera, a smart phone, an enhanced general packet radio service (EGPRS) mobile phone, a media player, a navigation device, an email device, a game console, or a combination of any two or more of these data processing devices or other data processing devices. Each client ,  may access application software on the server .","The server  can represent various forms of servers including, but not limited to a web server, an application server, a proxy server, a network server, or a server farm. For example, the server  can be an application server that executes software accessed by clients , . In operation, multiple clients (e.g., clients , ) can communicate with the server  by way of network . In some implementations, a user can invoke applications available on the server  in a web browser running on a client (e.g., clients , ). Each application can individually access data from one or more repository resources (e.g., database ). For example, the server  can access database .","In some implementations, the client devices ,  may communicate wirelessly through a communication interface (not shown), which may include digital signal processing circuitry where necessary. The communication interface may provide for communications under various modes or protocols, such as GSM voice calls, SMS, EMS, or MMS messaging, CDMA, TDMA, PDC, WCDMA, CDMA2000, or GPRS, among others. For example, the communication may occur through a radio-frequency transceiver (not shown). In addition, short-range communication may occur, such as using a Bluetooth, WiFi, or other such transceiver.","In some implementations, the system  can be a distributed client\/server system that spans one or more networks such as network . The network  can be a large computer network, such as a local area network (LAN), wide area network (WAN), the Internet, a cellular network, or a combination thereof connecting any number of mobile clients, fixed clients, and servers. In some implementations, each client (e.g., clients , ) can communicate with the server  via a virtual private network (VPN), Secure Shell (SSH) tunnel, or other secure network connection. In some implementations, the network  can include the Internet, a wireless service network and may include the Public Switched Telephone Network (PSTN). In other implementations, the network  may include a corporate network (e.g., an intranet) and one or more wireless access points.","Each client (e.g., clients , ) can establish its own session with the server . Each session can be semi-permanent as it can be established at one point in time and torn down at another. Each session can involve two-way information exchange between the computer system  and each individual client , . For example, a Hypertext Transfer Protocol (HTTP) session enables the association of information with individual users. A session can be stateful where at least one of the communicating parts (e.g., the server  or the client (e.g., clients , )) can save information about the session history in order to be able to communicate. Alternatively, stateless communication includes independent requests with associated responses.","Multiple clients (e.g., clients , ) can communicate via network  with the server . In order to run an application each client (e.g., clients , ) can establish a corresponding session with the application server . In some implementations, a user can initiate a profiling session for an application running on the server  using the client . The client  can establish the profiling session with the server . The profiling session can profile an application running on a Java virtual machine (JVM) on the server . For example, a profiler, included on the server , can record and store profiling data for a profiling session in the database  for analysis by the user running the profiling session from the client . In some implementations, the profiling data can be stored in a file system on the server . The profiler can also send the profiling data to the client  for analysis by the user. The client  can display the profiling data recorded for the application running on the JVM in a graphical user interface (GUI) displayed on display device on the client .","As used herein, the term profiling data generally refers to map data and event data. Map data can include a mapping between numeric identifiers and VM structure entities such as stack traces, thread names, classes, methods, and class loaders, for example. Event data directly relates to profiled actions occurring in a VM. Exemplar actions can include the start of threads, object allocations (e.g., for the allocation trace), method enter events, method exit events, and the actual method parameters (e.g., for the method parameter trace), sampled thread stack traces (e.g., for the performance trace), and\/or garbage collection events. The map data can be referenced in the event data. Consequently, instead of writing explicit class specifications, method specifications, and complete stack traces within the event data, only the corresponding numeric identifier need be written. In this manner, the amount of event information (from a memory perspective) can be drastically reduced.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","100","200","108","106","114","102","104"]},"For example, the profiler can analyze the resource consumption of an application running on a JVM. In some implementations, the application can be a standalone Java application. In some implementations, the application can be a complex enterprise application that can utilize a plurality of resources. For example, the profiler can be the JVM Profiler provided by SAP AG.","The profiler can include two components: a profiler front-end component (front-end profiler ) and a profiler back-end component (back-end profiler ). The back-end profiler can be integrated into a back-end virtual machine (VM) . In some implementations, a native application can be provided as a front-end, the native application understanding the profiling protocol of the back-end. In some implementations, the front-end profiler can be integrated into a front-end VM . For example, the back-end VM and the front-end VM can each be a JVM provided by SAP AG. The JVM can run one or more applications integrated with the back-end profiler in the back-end VM  and provides for connection to the front-end profiler . The back-end profiler can provide profiling data for one or more applications running on the back-end VM . The front-end profiler can provide a visual representation of the profiling data provided by the back-end profiler (e.g., client  can include front-end profiler and display device can display the profiling data to a user in a GUI).","For example, a back-end profiler for a JVM can expose profiling data from a Java application executing on a back-end VM. The back-end profiler can use a Java Virtual Machine Tool Interface (JVMTI) to collect profiling data from the JVM. In some implementations, the JVM can provide an interface to load the back-end profiler (e.g., as an agent) into the JVM process. In some scenarios, a proprietary implementation can directly integrate the back-end profiler into the JVM. For example, the SAP\u00ae JVM can include a proprietary back-end profiler directly integrated into the back-end VM.","In some implementations, during a profiling session, a user can directly connect to the VM that includes the profiler (e.g., back-end VM  that includes back-end profiler ). The user can interactively request profiling data be sent from the back-end profiler to the front-end profiler . Profilers , can communicate with each other using client application programming interface (API)  and server API , respectively. For example, computer system  can establish a socket connection between the back-end profiler and front-end profiler . The profilers , can be located on physically different machines (e.g., client  and server , respectively). The profiling data can be transferred from the back-end profiler to the front-end profiler (e.g., by way of a socket connection or the transfer of one or more files). The front-end profiler can receive the profiling data and prepare it for analysis and display to a user. For example, the front-end profiler can display the profiling data in a GUI on display device . In some implementations, the profiling data can be transferred using a file transfer.","In some implementations, the computer system  may directly connect to client  without the use of network . In some implementations, the front-end VM  and back-end VM  including profiler and profiler , respectively, may run on the same machine where client , server  and database  are included on the same physical machine.","The front-end profiler can be a stand alone application that can communicate with the back-end profiler included in the back-end VM  without the need for a front-end VM. More specifically, a front-end profiler may be a stand-alone program or application that is compatible with a back-end profiler. In some implementations, the front-end VM  can run the front-end profiler stand-alone application. The front-end profiler stand-alone application can analyze additional stand-alone applications running on the front-end VM . The front-end profiler stand-alone application can also analyze applications running on the back-end VM .","In some implementations, the profilers , can be integral parts of VMs , , respectively. This can allow for \u201con-demand\u201d examination of applications running on the back-end VM . Because the VMs ,  include profilers , , respectively, profiling can occur during runtime without the need to restart the VMs , . Including a profiler in a VM reduces the memory usage typically required, thereby minimizing the memory overhead of the computer system (e.g., computer system ).","The server API  can start and stop the VM included in the back-end VM  that includes the application for profiling. The back-end profiler can record the profiling data for the application running on the back-end VM . In some implementations, the back-end profiler can store the profiling data as one or more profiling files in the database . In some implementations, the back-end profiler can send the profiling data to the front-end profiler for further processing. For example, an SAP\u00ae JVM's debug connection can connect the client  to the server  to communicate profiling data from the back-end profiler to the front-end profiler using server API  and client API , respectively.","In some implementations, a developer can use a multi-language software development environment to implement, test and debug a software project. The software development environment can be an open architecture software development platform that includes an integrated development environment (IDE) and a plug-in system. The plug-in system can allow extensions to the IDE with the ability to integrate custom tools. The plug-in system can provide a framework for integrating user-made applications and infrastructure components. For example, a front-end profiler that includes a user interface can be provided as a plug-in to the software development platform. For example, the front-end profiler can be an Eclipse plug-in that can be integrated into an Eclipse platform. The Eclipse platform can provide an IDE for implementing, testing and debugging Java based software development projects. An Eclipse platform that includes a front-end profiler plug-in can additionally provide profiling of Java based software development projects. For example, the front-end profiler can be a plug-in to a software development platform running on the front-end VM .","A remote profiling session can occur when a host or server (e.g., server ) that includes the application for profiling is remotely located from the client (e.g., client ) running the application that initiates the profiling session. For example, system  shows an exemplar remote profiling session where the back-end VM  is running an application that includes the back-end profiler and the client  initiates the profiling session from the front-end VM , which includes front-end profiler . In a remote profiling session, opening a debugging port to the back-end VM  can switch the back-end VM  into a profiling mode. Using client , a user can connect to the back-end VM  for profiling by connecting to the debugging port. As shown in , the back-end profiler is an integral part of the back-end VM . As described above, this can allow the back-end VM  to be switched into a profiling mode \u201con demand\u201d during execution of the back-end VM application without the need to restart the back-end VM application.","In some implementations, a local profiling session can occur when the application for profiling and the application that initiates the profiling session are located on the same host or server (e.g., the same physical machine). The local profiling session can perform simultaneous source code implementation, testing, debugging and profiling. The host can include a local display device that displays a GUI to a user. The GUI can allow the user the ability to control and configure the profiling session.","In some implementations, a user can perform a remote or local profiling session in an online or interactive mode. In an online profiling session, a front-end profiler (e.g., front-end profiler ) can initiate a profiling session with a back-end profiler (e.g., back-end profiler ). For example, a user interacting with a GUI displayed on display device can start and stop the profiling session as well as interact with the back-end profiler during the profiling session. The interaction can include configuring and controlling the profiling session as well as receiving profiling data. The user can request the resultant profiling data from the back-end profiler for display on the display device . The back-end profiler can open a debugging port to the back-end VM  when the front-end profiler initiates an online profiling session with the back-end profiler . The back-end VM  can then wait for a connection. The front-end VM  that includes the front-end profiler can connect to the debugging port using client API  and server API  by way of network .","In some implementations, in an online profiling session, a user may optionally store the profiling data received from the back-end VM in a local file (e.g., a file located on the client  as part of a local file system or repository). The user can access the locally stored profiling data file at any time after the completion of the profiling session.","In some implementations, a user can perform a remote or local profiling session in an offline or non-interactive mode. In an offline profiling session, a front-end profiler (e.g., front-end profiler ) can initiate a profiling session with a back-end profiler (e.g., back-end profiler ) but there is no interaction between the front-end profiler (e.g., front-end profiler ) and the back-end profiler (e.g., back-end profiler ) during the profiling session. For example, the system  can provide an interface to couple the front-end VM  to the back-end VM  using the server API  in order to start and stop the profiling session. The back-end VM  that includes the back-end profiler can store the profiling data in the database , and\/or a file. For example, a user interacting with a GUI displayed on the display device can start and stop the profiling session. Once complete, the user can request the profiling data stored in the file in the database  from the computer system  (e.g., the user can interact with a GUI displayed on display device to initiate the request). The client  can receive the profiling data file and display its contents to the user on display device ","In an offline profiling session, storing profiling data for the profiling session in a profiling file on database  can enable a user to retrieve profiling data for a back-end VM (e.g., back-end VM ) at any point after the profiling session is complete. For example, the stored profiling data can be retrieved from the database  whether or not the back-end VM (e.g., back-end VM ) is running.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 3","b":["212","218","212","212","316","324","322"],"i":["b","b ","b "]},"The back-end profiler can include a controller framework . In some implementations, the controller framework  can start and stop profiling sessions as well as traces during a profiling session. The controller framework  can allow a user to select specific back-end profiler options and settings for a profiling session. For example, the front-end profiler can display a GUI to the user on display device that displays the options and settings for the back-end profiler . The user, interacting with the GUI, can select specific back-end profiler options and settings for a profiling session.","The back-end profiler settings can include functional settings and filter settings. Functional profiler settings can determine the functional area of the application code to profile. For example, a functional profiler setting can specify the types of traces to perform for the profiling session (e.g., an allocation trace, a method parameter trace, and\/or a performance trace). Filter profiler settings can define a validity scope (e.g., user, session, thread, VM, etc.) for the functional profiler setting for the profiling session. For example, referring to , a user, operating client , can start an allocation trace in the back-end profiler . The validity scope of the profiling session can be for the user.","The profiler options can include specific monitoring, debugging and analysis functions. For example, profiler options can include memory debugging (e.g., memory leak detection), performance analysis (e.g., hotspot identification), synchronization monitoring, and application debugging (e.g., called method detection). By way of non-limiting example, the profiling functions can include one or more sub-functions (e.g., heap dump, time-based sampling, memory-based sampling, allocation trace, method parameter trace, garbage collection trace, etc.). Allocation analysis can identify and isolate memory related problems in an application. Allocation analysis can be used for memory debugging.","Performance analysis can monitor an application's behavior using information gathered as the application executes. Performance analysis can determine which parts of an application can be optimized for speed. In some implementations, performance analysis can indicate where within the application spent its time during execution thereof. Performance analysis can indicate which methods called other methods while the application executes. The profiling data gathered during a performance analysis can indicate which areas of the application are slower than expected. Performance hotspots (or bottlenecks) can be code segments in the application that can contribute significantly to overall application execution time. In some implementations, a performance hotspot can slow down or halt application execution. Identification of performance hot spots enables improvement of the code segment to improve the overall performance of the code at runtime.","In some implementations, the controller framework  may include a profiler evaluation module for analyzing profiling data. The server API  can obtain the complete profiling data for a profiling session. The profiler evaluation module can analyze the complete profiling data for the profiling session and generate problem oriented, condensed profiling data for the profiling session. The server API  can also obtain the condensed profiling data from the back-end VM . A user may use the condensed profiling data to identify one or more problematic areas in a profiled application. For example, a profiling session can perform a performance analysis on an application using a time-based sampling approach. The time-based sampling approach for performance analysis can be referred to as a statistical analysis. In some implementations, a profiling session can perform a performance analysis on an application using one or more actual events in the application (e.g., a method call) as indicators for tracing the execution path of the application.","In some implementations, the back-end provides low-level profiling data to the front-end for higher-level evaluation of the profiling data at the front-end. For example, the server  can provide the raw profiling data to the client . The client  can process the raw profiling data to provide a high-level evaluation thereof. In other implementations, the profiler evaluation module can analyze the complete profiling data for a profiling session. The profiler evaluation module can generate condensed profiling data directed towards the identified time-consuming methods within the profiled application. The server API  can enable the client  by way of network  and client API  to receive the condensed profiling data from the back-end VM . The client  can display the condensed profiling data to a user in a GUI on the display device ","In some implementations, a user can use the controller framework  to start and stop profiling sessions, and to enable profiler traces for a session. For example, the user can determine one or more profiler traces to enable during a profiling session. In a single profiling session, the user may enable an allocation trace that uses the allocation trace module  and a method parameter trace that uses the method parameter trace module .","In some implementations, the controller framework  can enable the server  to specify a thread filter . The thread filter  can include names and identifiers associated with a profiling session for a particular thread (e.g., a thread executing on the back-end VM ) and can indicate the existence of one or more profiler traces for the profiling session. For example, the names and identifiers can be a client identifier, a user identifier, a profiling session identifier, a request identifier, an application name and a component name. By way of non-limiting example, the thread filter  can filter out specific events in the profiling data (e.g., all allocations from a specified thread). In some implementations, the controller framework  can \u201ctag\u201d the names and identifiers to the thread. The server can set the current thread state using the information in the thread filter .","Class filters  can limit the recording of profiling data for a particular trace to a designated method within a class included in the class filters . For example, when enabling an allocation trace in a profiling session, a user can enable a profiler to record allocation trace data for Java object allocations, which refer to instances of the java.lang.HashMap class. The java.lang.HashMap class can be included in the class filter .","A buffer framework  can compress or decompress profiling data. The compressed or decompressed profiling data can be communicated (e.g., sent to the client ) or stored (e.g., placed in a profiling file and stored in database ). For example, in an offline profiling session, the buffer framework  can compress profiling data for storage as a profiling file in database . When requested by a client (e.g., client ), the buffer framework  can decompress the profiling data in the profiling file for communication back to the client (e.g., client ) and subsequent viewing of the profiling data by a user in a GUI on a display device (e.g., display device ).","Communication framework  can facilitate the communication of profiling data and information between and within various components (e.g., elements, modules, systems, servers, VMs, etc.) included in the computer system . Additionally, the communication framework  can determine and facilitate the storing of profiling data (e.g., profiling data in a profiling file stored in database ).","An identification (ID) service  can assign a numerical identifier to an alphanumeric name. For example, the ID service  can assign a numeric identification value to a class name (e.g., java.lang.HashMap class can be assigned the number \u201c101\u201d) creating a numeric ID tag for the class. A numerical identifier can also be assigned to a method, a class and\/or a class loader. For example, because a class, a method and\/or class loader are not just specified by their name (e.g., there can be more classes of the same name, if they are loaded by different class loaders), using just a name to ID mapping would not allow to differentiate between different class, method or class loader of the same name. In some implementations, a mapping packet can map and group classes, methods and\/or class loaders according to their numerical ID tags (e.g., their assigned numerical values). In some implementations, the ID service  can assign numeric IDs to threads. An object identification (ID) service  can assign numeric IDs to objects. The use of numeric IDs can result in improved efficiency and speed during a profiling session as objects, threads, methods and classes can be sorted, grouped and compared using the numeric IDs instead of an alphanumeric name. The use of numeric IDs can also result in decreased memory consumption during a profiling session.","A method parameter trace module  can trace the values of method parameters. For example, a method parameter trace can check if specific parameter values used in a method lead to excessively long execution times for the method. Additionally, a method parameter trace can provide an overview of the parameter values used by the method during the execution of the application in a profiling session.","In some implementations, and as noted above, the raw profiling data can be provided to the front-end from the back-end for higher-level processing. For example, the front-end can process the profiling data to group one or more consecutive methods in a stack trace into a component, and categorize the trace data at the stack level. For example, when a profiling session includes a time-based sampled allocation trace, the memory allocation quantity can be attributed to a stack trace. In other implementations, the higher-level processing can occur at the back-end. For example, a component statistic module  can group one or more consecutive methods in a stack trace into a component. A component can be a specific application programming interface (API) used by the application. Examples of components can be Java components that can include, but are not limited to, a persistence API, a security API, a portal API and a servlet API. The methods in the stack trace can be grouped into components based on a defined \u201centry method\u201d for the component. The component statistic module  can then categorize the trace data at the stack level. The stack trace including methods can be grouped into components, where one or more consecutive methods can be placed into one component group. Each component group can provide allocation statistics for the API associated with the component.","A garbage collection trace module  can trace garbage collection (GC) events in an application. For example, a Java runtime environment can use a garbage collector to perform garbage collection to reclaim no longer needed memory allocated to an object. Once the garbage collector determines that the object is no longer accessible (e.g., when there is no longer any references to it stored in any variables, the fields of objects, or the elements of any arrays), the garbage collector can reclaim the allocated memory. For example, when a Java application no longer references a particular object, a heap space occupied by the object can be recycled so that the heap space can be made available for subsequently created objects.","As discussed in further detail below, the profiling data into sub-regions or snapshots. A snapshot can be a specific timeframe or interval where profiling data was collected. For example, a user can create a snapshot by selecting a corresponding entry within a context menu of a profiling trace entry in a profile view. As another example, the profiling data can be read at the front-end (e.g., after finishing a dialog step) and the user can input a command to create a snapshot. In response, the front-end can send a command to the back-end to create a snapshot of the profiling data. Consequently, the back-end inserts a snapshot marker into the original profiling data. In the case where the user would like to create a sub-snapshot (e.g., a snapshot within a snapshot), or the user would like to create a snapshot from an arbitrary time period, the front-end can identify the corresponding sections, or sub-regions in the original profiling data, and can read the profiling data for that section.","Analysis of profiling data can identify the impact on system performance of individual software modules in an application. For example, profiling data can indicate the percentage of overall runtime for a software module in an application. Optimization of the software modules that contribute a large percentage of the overall runtime can result in marked system improvements with minimal changes. Profiling data can also indicate where within the software module optimization can be performed to improve the module's overall performance in the system.","For example, time-based sampling can provide an overview of methods in an application that consume the most CPU resources. Time-based sampling can provide a stack trace of the currently active thread at regular intervals. Analysis of time-based sampling can identify a method that consumes a large number of CPU or system resources. For example, the consumption of a large number of system resources by the method can be the result of an expensive method call. For example, the consumption of a large number of system resources by the method can also be the result of calling the method often. A method statistic trace, which can be included in a module with trace modules , for example, can determine the number of times a particular method is called. The method statistic trace together with time-based sampling can provide a time method trace that can calculate the average runtime of a specific method (e.g., the \u201ccumulative time\u201d divided by the method count).","For example, memory-based sampling can provide an overview of methods in an application that consume the most memory resources. Memory-based sampling can provide a stack trace after memory is allocated on a memory heap. Memory-based sampling can identify the methods that allocate the largest number of bytes on the memory heap.","Input\/output (I\/O) based sampling can provide an overview of I\/O operations performed and I\/O resources used by methods in an application. For example, operating a network connection at its maximum bandwidth can consume a large percentage of I\/O resources. An I\/O trace, which can be included in a module with trace modules , for example, can trace the timing of I\/O operations in a method. The I\/O trace can provide data about I\/O operations, as well as data about a file being written and\/or the network address\/port being used. Analysis of the I\/O trace data can provide information about I\/O operations that can include, but is not limited to, the amount of data transmitted by an I\/O operation, the amount of CPU resources used by an I\/O operation, and the number of I\/O operations performed by a method. The analysis of the I\/O trace data can identify I\/O operations that transmit an excessive amount of data. The analysis of the I\/O trace data can identify I\/O operations that consume an excessive number of CPU resources. The analysis of the I\/O trace data can identify if a method performs an excessive number of I\/O operations.","Synchronization monitoring of a software application can provide information related to multithreading and concurrency. For example, problems associated with multithreading and concurrency can include, but are limited to, deadlocks, race conditions, thread starvation and scalability. In some implementations, a monitor trace, which can be included in a module with trace modules , for example, can identify deadlock and scalability issues in an application by acquiring information about the locks used in a VM. Synchronization monitoring can provide an overview of the most contented locks within an application. In this manner, a user can be made aware of which threads are waiting (e.g., threads that explicitly call wait( ) on a Java object\/monitor) and which threads are blocked (e.g., threads that want to enter a monitor section), as well as how long the threads are typically waiting and\/or blocked. Further information can be provided with regard to the waiting and\/or blocked threads. For example, culprit threads can be identified, a culprit thread being a thread that is holding the desired locks.","In some implementations, software profiling can provide additional application debugging functionality. For example, a method count trace, which can be included in a module with trace modules , for example, can provide the number of calls to a particular method. An execution line trace, which can be included in a module with trace modules , for example, can provide information regarding the number of lines of executed and unexecuted application source code. A method call trace, which can be included in a module with trace modules , for example, can provide the methods called by an application.","In some implementations, a method trace can be implemented to trace an application debugging process. The method trace, which can be included in a module with trace modules , for example, can trace the application program flow to a designated point in the source code. The method trace can provide information as to how the application program reached the designated point in the source code.","Referring to , the client  can provide a GUI to a user for display on display device that can allow the user to start, stop and control profiling sessions in the back-end profiler using the client API  in communication with the server API  by way of network . Additionally, the server API  can provide the client API  by way of network  profiling data to display to the user in a GUI on the display device . The user can access and evaluate the displayed profiling data. In some implementations, a guided mode can identify problem areas indicated by the profiling data. In some implementations, the profiling data can be stored as a profiling file in the database  in the computer system . In some implementations, the profiling data can be stored as a file in a file system included on the client . Storing of the profiling data can allow for subsequent retrieval and analysis.","The client  and the client  can connect to the computer system  by way of the network . In some implementations, the back-end profiler can perform in compliance with both the client  and the client , simultaneously, while remaining multiple client compliant. The back-end profiler can restrict profiling sessions to particular clients, while the server  can assign the current client information to its respective thread.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIG. 4","FIG. 2"],"b":["400","212","108","402","404","405","406","404","407"],"i":"a "},"If, in step , if it is determined that the profiling session is not an online profiling session, offline (e.g., non-interactive) profiling is performed in step . The offline profiling session continues until stopped. In step , it is determined whether the offline profiling session is to be stopped. Whether the offline profiling session is to be stopped can be determined based on a user input at the front-end. If the offline profiling session is not to be stopped, the offline profiling session continues in step . If the offline profiling session is to be stopped, the front-end profiler requests the profiling data in step . In step , the profiling data can be analyzed by the front-end profiler. In step , which can be provided as an option, the profiling data can be stored locally in the client for future use by the front-end profiler (e.g., front-end profiler ).","In some implementations, a front-end profiler can provide a user with tools for analyzing profiling data (e.g., resource consumption information) gathered by a back-end profiler. The tools can be included in the front-end profiler. The tools can provide a GUI to the user (e.g., referring to , a GUI can be displayed on display device ). The GUI can allow the user to select criteria for grouping and managing the profiling data in an efficient and meaningful way in order to simplify the analysis of the profiling data.","For example, the IDE of the software development platform (e.g., Eclipse) can be structured into a plurality of perspectives. As used herein, the term perspective refers to a visual container for a set of views and editors for the associated development task that can properly structure and arrange the views, and can be analogous to a page within a book, for example. Examples of perspectives can include, but are not limited to, a perspective for implementing a software application, a debug perspective for debugging functionality, a test perspective for implementing software application testing, and a profiler perspective for profiling functionality. The platform can associate a development task (e.g., source code implementation, debugging, testing, profiling) with a dedicated perspective. The development framework can provide an interface for combining user-made perspectives together with their related content. For example, the development framework can provide a GUI to display to a user on a display device that can combine a profiler perspective with profiling data.","The IDE of the software development platform (e.g., Eclipse) can provide the functionality to execute or debug a software application by providing one configuration framework for executing the application and another configuration framework for debugging the application. Both configuration frameworks can describe the selected application (e.g., a main class to start, start-up parameters, etc.). Another configuration framework can be included to profile an application, and provides a user interface framework that can start a profiling session.","In some implementations, multiple configuration framework types can be provided. Example configuration framework types can include an application configuration framework, a profiling file analysis configuration framework, and a remote profiling configuration framework. The application configuration framework can specify an application (e.g., a Java application) for profiling together with profiling parameters. For example, the application configuration framework can enable a user to execute an application with a profiling session already started. A user can profile the application directly from the start of execution of the application.","Referring now to , a screen-shot  illustrates an exemplar profiler perspective for a VM. As described above, a development framework can provide a GUI to display to a user on a display device, as illustrated by the screen-shot of , for example, that can combine a profiler perspective with profiling data. The screen-shot of  illustrates a portion of an exemplar profiling lifecycle , for which a snapshot is provided between a starting point  (e.g., at 1 minute, 40 seconds) and an ending point  (e.g., at 5 minutes). The snapshot functionality is described in further detail below. The profiler perspective can include a profiler view  for a profiling session (e.g., the Example profiling session).","Referring again to , the profiling file analysis configuration framework can provide a user with a GUI on a display device (e.g., display device ) in order for the user to specify a profiling file for display. As previously described, a profiling file can include collected profiling data. The profiling file can be in a database on a server (e.g., database ) or in a file system on a client (e.g., client ). For example, the IDE can save profiling data from an interactive profiling session in a profiling file on the client that includes the IDE (e.g., client ). For example, profiling data from a non-interactive profiling session can be saved in a profiling file included in a database (e.g., database ) included on a server (e.g., server ). For example, the front-end profiler can provide the back-end profiler specific profiling parameters that enable traces to begin directly on the start-up of the application for profiling in the back-end VM . The profiling data can be stored in a profiling file on database . A user on a client (e.g., client ) can view the profiling file on a display device (e.g., display device ) by generating a profiling file analysis configuration framework.","With further reference to , the remote profiling configuration framework can allow a user to specify a connection (e.g., a host name and port number) to the VM (e.g., back-end VM ) for profiling. For example, as previously described, a back-end profiler (e.g., back-end profiler ) can open a debugging port to a back-end VM (e.g., back-end VM ) when a front-end profiler (e.g., front-end profiler ) initiates an online profiling session with the back-end profiler (e.g., back-end profiler ).","Referring now to , a screen-shot  illustrates an exemplar GUI that can be used to configure a profiler and start a profiling session. For example, and with co-reference to , a user can select to profile an application (e.g., Java application: Example ) running on the back-end VM  using back-end profiler . The user can select to analyze the performance behavior of the application (e.g., the user can select Performance Hotspot Analysis ). The performance behavior of the application can involve method calls and execution paths, which can consume the majority of the CPU resources. The profiling data can include the method calls and execution paths used by the application. In order to profile the application, a user can create an application configuration framework in an IDE running on a client (e.g., client ). As described, the application configuration framework can allow the user to execute the application with a profiling session already started. The user can profile the application directly from the start of execution of the application. Within the application configuration framework, a user can specify a class containing the main method of the application and enable a performance hotspot analysis profiling trace. The performance hotspot analysis profiling trace can provide the user with information that can indicate performance hotspots within the application.","Analysis options  can include information such as a user name or identifier option , a session name or identifier option , a request name or identifier option and an application name or identifier option . For example, the analysis options  can indicate the user, session, requester or application that can start a profiling session. A server (e.g., server ) can tag one or more threads running on a VM (e.g., back-end VM ) with the analysis options . When a profiling session is started (e.g., a user on client  interfaces with a GUI on display device to enable the front-end profiler to initiate a profiling session), a thread filer (e.g., thread filter  in ) included in the a back-end profiler (e.g., back-end profiler ) can process the analysis options . The thread filter (e.g., thread filter ) and the back-end profiler (e.g., back-end profiler ) can determine, for example, if the user name or identifier option matches the user of the client .","In some implementations, the analysis options  can be alphanumeric names associated with each option (e.g., options -). In some implementations, an abbreviated numeric identifier can be used for each option (e.g., options -) where each abbreviated numeric entry corresponds to a longer alphanumeric entry for the options -","Referring again to , once a server (e.g., server ) begins the execution of an application in a VM (e.g., back-end VM ), a back-end profiler (e.g., back-end profiler ) can monitor at regular intervals what the application is executing. For example, back-end profiler can record profiling data that includes a complete stack trace for all threads running in the application on the back-end VM . The server API  by way of network  and client API  can transfer the profiling data to the front-end profiler . For example, in order to obtain an accurate view of the performance behavior of the application, the back-end profiler can perform and record a stack trace computation every ten milliseconds. This can result in the back-end profiler recording and transferring a large amount of profiling data to the front-end profiler especially when the application is large and executes for a prolonged period.","In some implementations, the front-end profiler can maintain profiling data it receives in main memory on the client . In some implementations, if the front-end profiler receives a large amount of profiling data compared to the available amount of main memory on the client , the front-end profiler may store the profiling data in a file on the file system of the client . In this case, some statistical or aggregated profiling data values (e.g., the profiling session duration time) may be presented to the user on a real-time basis in a dedicated profile view (e.g., profile view  in ) included in the IDE of the software development environment on the client . The remaining profiling data can be stored in a file on the file system of the client  for later viewing and analysis by the user in a GUI on display device ","Referring now to , a screen-shot  illustrates an exemplar method statistic view  included in a profiler perspective. The method statistic view  can be used to identify performance hotspots, and provides an overview of the methods that consume the most CPU resources of an application. As described above, a performance hotspot analysis can dump a stack trace of the currently active threads at regular intervals (e.g., every 10 milliseconds). For each method, the front-end profiler (e.g., front-end profiler ) can calculate the percentage of how often a method appears on the top of the stack trace. This percentage can be the self-time for the method. The front-end profiler (e.g., front-end profiler ) can use the method self-time to estimate the amount of time the application spends processing the method. Additionally, for each method, the front-end profiler (e.g., front-end profiler ) can calculate the percentage of how often a method appears at any location in the stack trace. This percentage can be the total time for the method and can denote the amount of time the application spends processing the method, which includes any calls the method made to other methods.","In the example of , a user can select a called methods (hierarchical) entry point. A profiler perspective on a front-end profiler (e.g., front-end profiler ) can open the method statistic view . The method statistic view  can include a hierarchical list of methods called during the snapshot of the performance analysis (e.g., a method statistic of a performance hotspot statistic). The method statistic view  can list the called methods based on the total run time of each of the called methods during the snapshot of the performance analysis.","For example, a profiler can create a statistic view for each entry point. The profiler can determine the statistics for display in the statistic view by parsing original profiling data included in a profiling file. For example, a profiling file can be stored on a file system of a client (e.g., client ) running a front-end profiler (e.g., front-end profiler ). A front-end profiler (e.g., front-end profiler ) can parse original profiling data in the profiling file, determine requested data for display in a statistic view based on the entry point for the snapshot, and provide the requested data for the statistic view. The requested data for the statistic view can be stored in main memory for use by the front-end profiler (e.g., front-end profiler ) and can be stored in a file on the file system. When the front-end profiler (e.g., front-end profiler ) closes the statistic view, the front-end profiler (e.g., front-end profiler ) can delete the profiling data for the statistic view from the main memory of the client, leaving the stored data for the statistic view in a file on the file system. If the front-end profiler (e.g., front-end profiler ) reopens the statistic view, the front-end profiler (e.g., front-end profiler ) can read the data for the statistic view from the stored file without the need to parse the original profiling file.","For example, original profiling data received by a front-end profiler (e.g., front-end profiler ) from a back-end profiler (e.g., back-end profiler ) can include stack trace information for all threads running on a VM (e.g., back-end VM ). The back-end profiler (e.g., back-end profiler ) can sample and record the stack thread information for a stack trace at pre-defined intervals (e.g., every 10 msecs). More specifically, a stack trace includes several stack frames, each stack frame including the individual methods and corresponding line numbers. When the states of the threads are sampled, a complete stack trace is determined for each individual thread. This occurs at the pre-defined interval (e.g., every 10 msecs) depending on the underlying operating system. In order to determine the runtimes of the individual methods, the pre-defined interval is accounted to each stack frame (e.g., the actual method and corresponding line number) of a stack trace. More specifically, the runtime of a method is separated into a self time and a total time. The self time indicates the time spent directly within a specific method, whereas the total time indicates the time spent within a specific method plus the time spent in called methods. Accordingly, if a sampled stack trace is determined, the pre-defined interval (e.g., every 10 msecs) is accounted to the total runtimes of each individual stack frame. The method at the top of the stack trace includes the pre-defined interval added to its self time.","The above-described process can be time consuming dependent on the amount of profiling data. The amount of profiling data can depend on the size of the application running on the VM (e.g., back-end VM ) along with the amount of time the application is running while being profiled. However, the amount of memory required for storing the resultant method statistic can be significantly smaller than the amount of memory required for storing the original profiling data.","The original profiling data provides the complete stack trace for each individual thread. The method statistic can include aggregated data from the original profiling data. The method statistic can provide an overview of the total runtime for each method. Referring again to , an examplar method statistic view  in a profiler perspective is shown. For example, a front-end profiler (e.g., front-end profiler ) can display to a user the method statistic view  on a display device (e.g., display device ) on a client (e.g., client ). The front-end profiler (e.g., front-end profiler ) can store the aggregated data of the method statistic in main memory to a file located on the client (e.g., client ). When the user closes the method statistic view , the aggregated data of the method statistic can be removed from main memory on the client (e.g., client ) but can still remain on the client (e.g., client ) in a file on the file system of the client (e.g., client ). When the user selects the method statistic entry point, the front-end profiler (e.g., front-end profiler ) can display the method statistic view  on the display device (e.g., display device ) to the user. The front-end profiler (e.g., front-end profiler ) can obtain the aggregated data of the method statistic from the stored file on the file system of the client (e.g., client ) without the need to recreate the method statistic from the data included in the original profiling file. This can save the front-end profiler (e.g., front-end profiler ) a significant amount of processing time.","In some implementations, the front-end profiler (e.g., front-end profiler ) can store the aggregated data for the method statistic along with the method statistic view. Storing the method statistic view can include storing the last state of the view prior to the user closing the view (e.g., storing the sort directions, the selection state, the expanded state of trees, etc.). When the user selects the method statistic entry point, the front-end profiler (e.g., front-end profiler ) can display the method statistic view (e.g., method statistic view ) on the display device (e.g., display device ) to the user in the state that the view was in when the user previously closed the view.","In some implementations, a front-end profiler (e.g., front-end profiler ) can store profiling data for a profiling session in a file system on a client (e.g., client ). When a user closes the IDE of the software development platform (e.g., Eclipse), the profiling data can remain in the file on the file system. Additionally, the state of the IDE when closed can also be saved. When the user reopens the IDE, the complete state of the GUI for the IDE can be restored (e.g., profiling sessions, opened views, view states, available statistics, etc.) along with the profiling data for the profiling session.","Referring now to , a screen-shot  illustrates an exemplar graphical user interface (GUI) used to configure a profiler and start an alternative profiling session. For example, and with co-reference to , a user can select to profile an application (e.g., Java application: Example ) running on the back-end VM  using back-end profiler . The user can select to analyze application execution to identify memory related problems (e.g., the user can select Allocation Analysis ). In order to profile the application, the user can create an application configuration framework in an IDE running on a client (e.g. client ). As described, the application configuration framework can allow the user to execute the application with a profiling session already started. The user can profile the application directly from the start of execution of the application. Within the application configuration framework, a user can specify a class containing the main method of the application and enable an allocation analysis profiling trace. The allocation analysis profiling trace can provide the user with information related to the memory consumption by the application.","Referring now to , a screen-shot  illustrates an alternative exemplar method statistic view  included in a profiler perspective is shown. Once the profiling session is complete, a user can select a view for a method statistic. A profiler perspective on a front-end profiler (e.g., front-end profiler ) can open the method statistic view . The method statistic view  can display the methods in an application that performed memory allocations during the profiling session.","In some implementations, a profiler perspective can present a plurality of views to a user. Each view can include specific statistics about a profiling session. A front-end profiler (e.g., front-end profiler ) can uniquely identify and describe the statistics in the view. The unique identification of the statistics can allow a user to navigate from one statistic to other statistics.","For example, using an arbitrary number of navigation steps, a user can start at a first statistic in a first view. The front-end profiler (e.g., front-end profiler ) can generate the first statistic from a first set of first profiling events identified in the profiling data. The user can select an arbitrary number of displayed entries for the first statistic from the first view. The user can navigate to a second statistic in a second view. The front-end profiler (e.g., front-end profiler ) can generate the second statistic for the second view from a second set of second profiling events. The second set of second profiling events can include the first profiling events minus the constraints introduced by the selection of the items from the first statistic in the first view. A user can continue to select an arbitrary number of displayed entries from one view and navigate to a next view. The front-end profiler (e.g., front-end profiler ) can efficiently describe the statistic for each view in an abstract and unique manner to reflect the path to the statistic.","In some implementations, a resource name can uniquely describe a statistic for a profiler in an abstract manner. The resource name can include one or more resource name elements. A resource name element can describe a constraint or filter used to determine the set of profiling events.","For example, a profiling session can produce profiling data that refers to memory allocation events. The front-end profiler (e.g., front-end profiler ) can generate a method statistic from a first set of first profiling events identified in the profiling data. A view for the method statistic can display to a user all methods in which memory allocations occurred.  shows an exemplar method statistic view . The front-end profiler (e.g., front-end profiler ) can apply a type of filter to the profiling data that filters out all methods in which memory allocations occurred. The resource name for the method statistic can include a single resource name element (e.g., \u201cMethod Statistic\u201d). The user can select a method from the method statistic view (e.g., java.util.AbstractList.Iterator( )) and navigate to a view for an allocated object statistic for the selected method. The allocated object statistic view can show the type (e.g., class) of allocated objects created by the selected method as well as allocated objects created by one or more methods called from the selected method. The resource name for the allocated object statistic can include the resource name elements of the parent statistic plus additional resource name elements. For example, the resource name for the allocated object statistic can include the resource name element for the method statistic (e.g., \u201cMethod Statistic\u201d), a filter resource name element for the selected methods (e.g., \u201cjava.util.AbstractList.Iterator( )\u201d), and a resource name element for the allocated object statistic (e.g., \u201cAllocated Object Statistic\u201d).","The user can select one or more allocated object types from the allocated object statistic view (e.g., allocated objects for string functions) and navigate to a view for a thread statistic. The thread statistic view can show the threads where the objects selected from the allocated object statistic are allocated. For example, the resource name for the thread statistic can begin with the resource name elements of the parent statistic (the view that the user selections originated from (e.g., the allocated object statistic)). Additionally, a filter resource name element for the allocated object statistic (e.g., \u201cString Functions\u201d) and a resource name element for the thread statistic (e.g., \u201cThread Statistic\u201d)) can be appended to the resource name elements of the parent statistic.","As shown in the above examples, a naming scheme for a resource name can directly reflect the navigation steps of the user (e.g., resource name: Method Statistic_java.util.AbstractList.Iterator( )_Allocated Object Statistic_String Functions_Thread Statistic). The resource name can uniquely describe a statistic. For example, a user can compare profiling statistics by comparing the resource elements in their resource names. In this manner, a user can identify identical profiling statistics.","For example, a front-end profiler (e.g., front-end profiler ) can create a third profiling statistic from a selection within a second profiling statistic where the second profiling statistic was created by a selection from within a first profiling statistic. In some implementations, the front-end profiler (e.g., front-end profiler ) can create the third profiling statistic by starting with the original profiling data and creating the first profiling statistic by applying a first filter for the first profiling statistic to the original profiling data. Applying the first filter for the first profiling statistic to the original profiling data can filter out profiling events in the original profiling data that do not meet the requirement for selection for the first profiling statistic. This results in a first set of profiling events. The front-end profiler (e.g., front-end profiler ) can create a second profiling statistic from the first profiling statistic by applying a second filter for the second profiling statistic to the first set of profiling events resulting in a second set of profiling events. The front-end profiler (e.g., front-end profiler ) can create the third profiling statistic from the second profiling statistic by applying a third filter for the third profiling statistic to the second set of profiling events resulting in a third set of profiling events. If a user chooses a navigation depth through the profiling data of n times, the profiling data and resultant profiling events are parsed n times. This can consume a large amount of system resources.","In some implementations, a software component for creating profiling statistics can be included in a front-end profiler (e.g., front-end profiler ). The profiling statistic creator software component can parse a resource name to compute the filter constraints used to create a view for a statistic described by the resource name. For example, a resource name can include one or more resource name elements for filtering threads. The profiling statistic creator software component can parse the resource name, extract all filter elements from the resource name and create a single thread filter. Additionally, the profiling statistic creator software component can parse the resource name and group resource name elements of the same type to create a single filter. In this case, if a user has chosen a navigation depth through the profiling data of n times, the profiling statistic creator software component can parse the profiling events once, check each profiling event and determine if all of the filter types apply to the profiling event. Additionally, the profiling statistic creator software component can group resource name elements of the same type to create a single filter for each type in order to create the profiling statistic.","In some implementations, a JVM profiler can profile a Java application running on a local or remote host. Within a remote profiling session, a user can directly connect to the JVM. The user can interactively configure the profiling session and request profiling data. For example, the user can request a class statistic and directly see a view of the class statistic on a display device on the local host that includes a front-end profiler (which can be a plug-in to a software development environment (e.g., Eclipse)). As previously described, the profiling events for a statistic can be used as an input for additional requests for statistics.","Referring again to , and as discussed above, a profiler can be implemented to track the resource consumption and collect corresponding profiling data for an executing application. The profiling data can be collected at the method level (e.g., data regarding memory usage and CPU processing time corresponding to each method called in an executing application can be collected). In some implementations, a profiler can trace the values of method parameters. For example, a method comprises a number of byte code instructions which the application executes. A method can include one or more parameters. An application can call a method to perform a specified task and provides parameter values for the called method. For example, when a Java VM calls a method (e.g., java.util.Arrays.toString(Object[ ] array)), the caller (e.g., a method) provides the values of the method parameters to the called method (e.g., the caller provides the object array as a first parameter for the static method). A method can be called directly or indirectly. More specifically, a directly called method is a method that is called by the application, and an indirectly called method is called within an executing method (i.e., a method that is nested within another method).","Referring to , a user can specify a method and corresponding parameters for tracing by the MPT module  included in the back-end profiler . More specifically, the back-end profiler can trace the values of method parameters used in the identified method. A MPT can provide an overview of the values of method parameters used by a method during execution of an application. By way of one non-limiting example, the user can use the results of a MPT to check if specific values of a method parameter used by the method lead to particularly long application execution times.","As another non-limiting example, a MPT enables a user to specify a particular method (e.g., java.util.Arrays.toString(Object[ ] array)) for tracing along with the specific method parameter for tracing (e.g., the object array: Object[ ] array). The parameter of a method can be determined by its position within a corresponding method signature. More specifically, a method is commonly identified by a unique method signature that includes the method name, and the number, types and order of its parameters. For example, position \u201c1\u201d can be used to indicate the object array parameter (e.g., the object array: Object[ ] array) for the method (e.g., java.util.Arrays.toString(Object[ ] array)). A VM (e.g., a Java VM) can report the value of the indicated trace parameter to the MPT each time the application calls the specific method.","Referring to , the MPT module  can include a set of MPT specifications. The MPT specifications can describe which parameters (the selected parameters) of which methods (the selected methods) are to be traced for a particular profiling session. Additionally, the MPT specifications can describe how to transform the resultant method parameter trace values of the selected parameters for the selected methods in order to obtain one or more values to report to the user. For example, the front-end profiler can display a GUI to the user on display device that enables the user to select one or more methods for tracing and to select one or more parameters used by the selected methods for method parameter tracing. Additionally, the user can specify the transformations, if any, the MPT can apply to the resultant traced method parameter values for reporting back to the user (e.g., in the GUI of the front-end profiler ). The MPT specifications can be generated based on this user input.","The MPT module  can provide the MPT specifications to the back-end VM . Each time the back-end VM  calls a selected method, the back-end VM  can apply the applicable MPT specifications for the selected parameters to the current parameter values of the selected method. The server API  can enable the client  by way of network  and client API  to receive the resultant traced method parameter values from the back-end VM  The front-end profiler can send the user-defined MPT specifications (e.g., a method name, a parameter index, and one or more modifiers) to the back-end profiler . When the back-end VM  executes a method, the back-end VM  can check if the method and its parameters are to be traced. If the back-end VM  determines the method should be traced, the back-end VM  can apply one or more modifiers to the parameter values. The back-end VM  can report the resultant parameter values in a method entry event. For example, the user can create a MPT specification by specifying the method name: \u201cjava.util.HashMap.get(java.lang.Object)java.lang.Object\u201d as the method to trace. The user specifies the first parameter as the parameter to trace. The user specifies the modifier \u201ctoString( )java.lang.String\u201d as the traced parameter value modifier. Each time the back-end VM  executes the \u201cHashMap.get\u201d method, a method entry event is sent to the front-end profiler (e.g., where the data can be written to a file on the file system of the client ). The back-end VM  applies the \u201ctoString( )\u201d method modifier to the traced parameter value (e.g., the Object parameter). The back-end VM  executes the \u201ctoString( )\u201d method on the actual parameter and provides the return value of that method as a parameter value.","In some implementations, when a VM (e.g., back-end VM ) calls a selected method, the VM (e.g., back-end VM ) can record, as an entry event, a timestamp and CPU thread time when entering the method. In some implementations, when the VM (e.g., back-end VM ) calls a selected method, the VM (e.g., back-end VM ) can record, as an entry event, a current stack trace when entering the method. For example, the front-end profiler can display a GUI to the user on display device that enables the user to select one or more entry events for reporting during a profiling session. The selections can be included in the MPT specifications in the MPT module . For example, each time the back-end VM  calls a selected method, the back-end VM  can apply the applicable MPT specifications for entry events for the selected method. The server API  can enable the client  by way of network  and client API  to receive the resultant entry event data as a single entity from the back-end VM .","In some implementations, when a VM (e.g., back-end VM ) exits a selected method, the VM (e.g., back-end VM ) can record, as an exit event, a timestamp and CPU thread time when exiting the method. In some implementations, when the VM (e.g., back-end VM ) calls a selected method, the VM (e.g., back-end VM ) can record, as an exit event, a current stack trace when exiting the method. For example, the front-end profiler can display a GUI to the user on display device that enables the user to select one or more exit events for reporting during a profiling session. The selections can be included in the MPT specifications in the MPT module . For example, each time the back-end VM  exits a selected method, the back-end VM  can apply the applicable MPT specifications for exit events for the selected method. The server API  can enable the client  by way of network  and client API  to receive the resultant exit event data as a single entity from the back-end VM .","In some implementations, when the VM (e.g., back-end VM ) reports both entry events and exit events that include a timestamp, the timestamps can be used to determine the duration of the method call that used specific parameters. In some implementations, when the VM (e.g., back-end VM ) reports both entry events and exit events that include a CPU thread time, the CPU thread times can be used to determine the duration of the method call that used specific parameters.","A user can use a method signature as a method specification for an MPT specification. In some implementations, a user can use a complete method signature to select a method for method parameter tracing. A complete method signature (e.g., example.Arrays.run(example.Value[ ])example.Result) can include a full package name for the input parameter types (e.g., example.Value[ ]) and a full package name for the return parameter types (e.g., example.Result). In some implementations, a method signature may not specify a method completely, as different class loaders may load the method class (e.g., the Arrays class) resulting in different implementations of the same method. A class loader dynamically loads classes into the VM. Additionally, the input parameter type (e.g., Value) and the return parameter type (e.g., Result) in the class (e.g., Arrays) in the differently implemented methods may have only their names in common as they may have different super classes, implement different interfaces, and have different methods and fields.","In some implementations, a user is not able to specify a class loader for a method selected for method parameter tracing. For example, the MPT module  may not differentiate between the differently implemented methods when specifying a method to trace. In some implementations, when the VM (e.g., back-end VM ) reports the value of a selected method parameter, the VM (e.g., back-end VM ) can differentiate between the differently implemented methods. For example, the VM (e.g., back-end VM ) can tag each different class loader object with a different integer value (e.g., a class loader index value). When reporting the value of a selected method parameter, the VM (e.g., back-end VM ) can include the integer value of the class loader (e.g., the class loader index value) to differentiate between the differently implemented methods For each class loader known by the VM (e.g., back-end VM ), a mapping between a numeric value and the class loader definition (e.g., the fully qualified name of the class loader's class) can be reported to the front-end profiler . When the VM (e.g., back-end VM ) reports a method entry event, the called method is reported. A method definition can be associated with mapping information (e.g., a numeric value corresponds to a method definition). The method definition can include the method name and the numeric value of the class loader responsible for loading the method. The VM (e.g., back-end VM ) can report the numeric value of the method definition along with the method entry event.","In some implementations, a user can use the method signature (e.g., example.Arrays.run(Value[ ])Result) that includes a class name for the input parameter types (e.g., Value[ ]) and a class name for the return parameter types (e.g., Result) to select a method for method parameter tracing. By way of non-limiting example, a profiler executing the parameter trace can trace all methods that take an array of objects of a class named \u201cValue\u201d (which may be defined in any package) and return an object of a class named \u201cResult\u201d. Selecting a method with this method signature for method parameter tracing can result in the tracing of a plurality of methods (e.g., example.Arrays.run(Value[ ])Result, example.Arrays.run(example.Value[ ])another .pkg.Result, example.Arrays.run(example.Value[ ])example.Result).","In some implementations, classes that are included in the default package class for the method may not include a package class specifier (e.g., the method signature \u201cexample.Arrays.run(Value[ ])Result\u201d need not include the class specifier \u201cexample\u201d for the array of objects of the \u201cValue\u201d class or the \u201cResult\u201d class). In some implementations, when using covariant return types, a method signature may omit a return class type (e.g., example.Arrays.run(Value[ ])). A user can use the position of the return type in the method signature to specify the parameter to trace (e.g., an index value representing the position of the return type in the method signature). For example, in order to specify the parameter for tracing as the objects of the \u201cValue\u201d class, a user can specify \u201c1\u201d to select the first return parameter.","In some implementations, a user may trace a method that is not a static method (a non-static method). In this case, the non-static method includes an additional, not explicitly defined (implicit) method parameter (e.g., the \u201cthis\u201d parameter). For example, the implicit parameter (e.g., the \u201cthis\u201d parameter) can represent an object on which the method is called (e.g., the receiver). In order to trace the implicit method parameter (e.g., the \u201cthis\u201d parameter) the user can specify a \u201c0\u201d (e.g., an index value for the method signature) to select the implicit the method parameter. In a Java application, for example, a non-static method is called within the context of a Java object (e.g., \u201cthis\u201d denotes the Java object the non-static method is executed on). For example, for a class \u201cjava.util.HashMap\u201d and a method \u201cget(Object)\u201d within the class, \u201cMyObject\u201d is an instance of the \u201cjava.util.HashMap\u201d class. When MyObject.get(Object) is called, \u201cget( )\u201d is called on the \u201cMyObject\u201d instance. In this example, \u201cMyObject\u201d is the \u201cthis\u201d object in the context of the get( ) method execution.","In some implementations, a method of a class can be overwritten in a subclass. In some implementations, a method for a class can be specified in an interface. For example, a user may want to trace a specific method or a specific method called by a specific receiver. For example, in order to perform method parameter tracing where a method of a class can be overwritten in a subclass, the MPT module  can support a plurality of variants. As another example, in order to perform method parameter tracing where a method of a class can be specified in an interface, the MPT module  can support a plurality of variants.","In some implementations, the MPT module  can support one or more variants for a method specification when determining the selection of a method for method parameter tracing. The MPT specification can include the variants. For example, in a first variant, a parameter trace is performed if the selected method matches the method specification included in the MPT specification and the receiver matches the full class name of the class in the method specification. In a second variant, a parameter trace is performed for a method if the criteria for the first variant are met and additionally the same method in all subclasses of the matching class is considered a match as long as the method in the subclass is not overwritten. In a third variant, a parameter trace is performed if the criteria for the first variant are met and additionally the same method in all subclasses of the matching class is matched.","Table 1 provides exemplar class definitions for three arrays.",{"@attributes":{"id":"p-0129","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Definition","Class definition"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","class Arrays {Result run (Value) {return null;}}"]},{"entry":["2","class Arrays2 extends Arrays {\/\/nothing new added}"]},{"entry":["3","class Arrays3 extends Arrays2 {Result run (Value)"]},{"entry":[{},"{return null;}}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Table 2 shows exemplar code segments that can be included in an application running on a VM (e.g., back-end VM ). The code segment can use the class definitions specified in Table 1.",{"@attributes":{"id":"p-0131","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Call","Source code"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","new Arrays( ).run(null);","\/\/ Call 1"]},{"entry":["2","new Arrays2( ).run(null);","\/\/ Call 2"]},{"entry":["3","new Arrays3( ).run(null);","\/\/ Call 3"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"By way of non-limiting example, a user can select the method signature, Arrays.run(Value), as the method specification for the method for parameter tracing to include in the MPT specification. When using the first variant specified in the MPT specification, a VM (e.g., back-end VM ) executing the code segment in Table 2 will perform a parameter trace on Call 1 and not on Call 2 or Call 3, as Call 1 is the case where the receiver is of class \u201cArrays\u201d. When using the second variant specified in the MPT specification, a VM (e.g., back-end VM ) executing the code segment in Table 2 will perform a parameter trace on Call 1 and on Call 2 but not on Call 3, since the \u201cArrays2\u201d method inherits the method implementation of \u201cArrays\u201d. When using the third variant specified in the MPT specification, a VM (e.g., back-end VM ) executing the code segment in Table 2 will perform a parameter trace on Call 1, Call 2 and Call 3, as the \u201cArrays3\u201d method overwrites the \u201cArrays\u201d method.","In another example, a user can select the method signature, Arrays2.run(Value), as the method specification for the method for parameter tracing to include in the MPT specification. When using the first variant specified in the MPT specification, a VM (e.g., back-end VM ) executing the code segment in Table 2 will perform a parameter trace on Call 2 and not on Call 1 or Call 3, as Call 2 is the case where the receiver is of class \u201cArrays2\u201d. When using the second variant specified in the MPT specification, a VM (e.g., back-end VM ) executing the code segment in Table 2 will perform a parameter trace on Call 2 and not on Call 1 and Call 3, as the \u201cArrays2\u201d method is overwritten in the \u201cArrays3\u201d method. When using the third variant specified in the MPT specification, a VM (e.g., back-end VM ) executing the code segment in Table 2 will perform a parameter trace on Call 2 and Call 3 and not on Call 1, as the \u201cArrays2\u201d method is overwritten in the \u201cArrays3\u201d method.","In some implementations, when using covariant return types, a method signature may omit a return class type. For example, the Java programming language allows an overwriting method to change the return type, as long as the new return type is a subtype of the return type of the overwritten method. Table 3 provides exemplar class definitions for two arrays.",{"@attributes":{"id":"p-0135","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Definition","Class definition"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["1","class A {Arrays2 exampleMethod( ) {return null;}}"]},{"entry":["2","class B extends A {Arrays3 exampleMethod( )"]},{"entry":[{},"{return null;}}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"For example, a Java compiler can generate two versions of the exampleMethod method in the B class when compiling the classes in Table 3. A first version of the exampleMethod method in the B class can return the original method type (e.g., \u201cArrays2\u201d). A second version of the exampleMethod method in the B class can return a new method type (e.g., \u201cArrays3\u201d), which is a sub-type of the original type (e.g., \u201cArrays3\u201d method inherits the method implementation of \u201cArrays2\u201d). The method returning the original method type (e.g., the \u201cArrays2\u201d method in class A) can forward the method call to the method returning the sub-type (e.g., the \u201cArrays3\u201d method in class B). For example, a user can select a method signature for the exampleMethod method as the method specification for the method for parameter tracing to include in the MPT specification. When performing a parameter trace, if the return type is omitted in the method specification for the method to trace in the MPT specification both the methods (e.g., method of type \u201cArrays2\u201d and method of type \u201cArrays3\u201d) will be traced. However, the user sees one method in the source code (e.g., class B extends A {Arrays3 exampleMethod( ) {return null;}}). The user can prevent the tracing of both methods by specifying the return type (e.g., either \u201cArrays2\u201d or \u201cArrays3\u201d).","Table 4 provides exemplar code segments that can be included in an application running on a VM (e.g., back-end VM ). The code segments can use the class definitions specified in Table 3.",{"@attributes":{"id":"p-0138","num":"0137"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Call","Source code"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Arrays2 v1 = new Arrays2( );"]},{"entry":[{},"Arrays2 v2 = new Arrays3( );"]},{"entry":[{},"Arrays3 v3 = new Arrays3( );"]},{"entry":["1","v1.mth( ); \/\/ Call 1"]},{"entry":["2","v2.mth( ); \/\/ Call 2"]},{"entry":["3","v3.mth( ); \/\/ Call 3"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"By way of non-limiting example, a user may look to trace all method calls to the exampleMethod method. The profiler executing the parameter trace will not trace Call 1 if the user specifies the return type of the overwritten method (e.g., \u201cArrays3\u201d). The MPT will not trace Call 3 if the user specifies the return type of the original method (e.g., \u201cArrays2\u201d). The MPT will trace Call 1, Call 2 and Call 3 if the user does not specify the return type of the method. However, for Call 2 the profiler executing the parameter trace will trace both the call to the method with the original return type (e.g., \u201cArray 2\u201d) and the forwarded call to the method with the more specific return type (e.g., \u201cArray 3\u201d). In some implementations, if the method specification in the MPT specification does not specify the return type of the method when using covariant return types, the profiler executing the parameter trace can trace only that method (from all the methods which would match in a class), which was added in the class itself or in its most specific super class. For example, the profiler executing the parameter trace can trace every call in the code segment in Table 4 once. The profiler executing the parameter trace can trace the methods, which include the actual implementation of the method and not the forwarded call to the method.","In some implementations, a VM (e.g., back-end VM ) can determine how to specify the representation of a selected method parameter when the VM (e.g., back-end VM ) reports the value of the selected method parameter. For example, the method parameter value types can be primitive value types (e.g., integers (ints) or double precision integers (double)). For example, the method parameter value types can be reference types (e.g., objects (Object) or arrays (Arrays)). When the method parameter is represented as a primitive value type, the VM (e.g., back-end VM ) can report the method parameter value when entering the selected method for tracing and the profiler executing the parameter trace can directly trace the method parameter. When the method parameter is represented as a reference type, there may not be a definitive representation of the parameter and the parameter value may not be directly traced. In some implementations, the profiler executing the parameter trace specification can be supplied with a list of modifiers that operate in a chain-like fashion on the reference type object or array to return a parameter value that can be used as a definitive representation of the parameter.","In some implementations, the profiler executing the parameter trace can directly trace specific reference types. For example, a VM (e.g., back-end VM ) can report the string content of string-like reference types (e.g., java.lang.String, java.lang.StringBuilder and java.lang.StringBuffer). For example, for a reference type of java.lang.Class, the MPT can use the class name or the class name together with information about the corresponding class loader (e.g., the name of the class loader's class).","For example, parameter value types and reference types that can be directly traced can include, but are not limited to: boolean; byte; short; char; int; long; double; float; java.lang.String; java.lang.StringBuilder; java.lang.StringBuffer; and java.lang.Class.","In some implementations, the profiler executing the parameter trace can handle reference types by adding a special case of a class to handle a specific reference type. In some implementations, a modifier can enable the use of user-specified conversions to convert a method parameter value type from one type to a method parameter value type of another type, which can be directly traceable. In some implementations, a VM (e.g., back-end VM ) can use a chain of modifiers to transform a method parameter value from an initial type (the input to the chain of modifiers) that may not be directly traced to a final type (the output of the chain of modifiers) that can be directly traced (e.g., a primitive value type). In some implementations, a VM (e.g., back-end VM ) can use a chain of modifiers to transform a method parameter value from an initial type (the input to the chain of modifiers) that can be the same type as a final type (the output of the chain of modifiers). In the implementation of a chain of modifiers, the output of the first modifier is used as the input to the next modifier. The parameter value at the end of the chain (the output of the chain of modifiers) is a parameter value type or reference type that the profiler can directly trace.","For example, the \u201clength\u201d modifier can modify a method parameter value from an input array type to an output integer (int) type. The precondition for the modifier is that the input type is an array. There is no optional modifier parameter. The modification results in an output parameter reported that is the length of the input array. An error can occur when the array is null. When the error occurs, the output parameter is reported as NULL_INVOCATION.","For example, the \u201carray_element\u201d modifier can modify a method parameter value from an input array type to an output that is an element type of the array. The precondition for the modifier is that the input type is an array. The optional modifier parameter is the index of the array element to extract. For example, if the index is less than zero, the count begins from the end of the array (e.g., \u22121 would indicate the last element, \u22122 the second to last element, etc.). The modification can result in an output parameter that is the element at the given index of the input array. An error can occur when the array is null. When the error occurs, the output parameter is reported as NULL_INVOCATION. An error can occur if the index is out of the range for the input array. When the error occurs, the output parameter is reported as INDEX_OUT_OF_BOUNDS.","For example, the \u201cclass\u201d modifier can modify a method parameter value from an input object type to an output java.lang.Class type. The precondition for the modifier is that the input type is not a primitive value. There is no optional modifier parameter. The modification results in an output parameter reported that is the class of the input object. An error can occur when the object is null. When the error occurs, the output parameter is reported as NULL_INVOCATION.","For example, the \u201cinstance_method\u201d modifier can modify a method parameter value from an input object type to an output that is any type. The precondition for the modifier is that the method given as the parameter is found for the input type. The optional modifier parameter is the name and signature of the method taking no parameters. The modification can result in the method specified as the parameter is executed on the input object. The result of the method call can be used as the output. An error can occur if the object is null. When the error occurs, the output parameter is reported as NULL_INVOCATION. An error can occur if the method throws an exception. When the error occurs, the exception is caught and the output parameter is reported as EXCEPTION_OCCURED.","For example, the \u201cstatic_method\u201d modifier can modify a method parameter value from an input object type to an output that is any type. The precondition for the modifier is that the class loader, which defined the class of the input object, finds the class of the static method given by the parameter. If such a class is found, the class includes a method as specified by the parameter where the method is static. The optional modifier parameter is the class name plus the method name and signature of a static method taking an object of the given input type (or a compatible type). The modification can result in the methods specified as the parameter is executed, with the input object as the first parameter. The result of the method call is used as the output. An error can occur if the method throws an exception. When the error occurs, the exception is caught and the output parameter is reported as EXCEPTION_OCCURED.","For example, the \u201cfield\u201d modifier can modify a method parameter value from an input object type to an output of any type. The precondition for the modifier is that the input type contains a field with the given name and type. The optional modifier parameter is the name and field type. The modification results in the field specified as the parameter read from the input object and the content of the field is used as the output. An error can occur when the object is null. When the error occurs, the output parameter is reported as NULL_INVOCATION.","For example, the \u201ccast\u201d modifier can modify a method parameter value from an input object type to an output object type. The precondition for the modifier is that the input type is not a primitive type. The optional modifier parameter is the name of a class. The modification results in the input type being casted to the class specified as the parameter and used as the output. For example, the assumed type of the object can be changed and not the object itself. An error occurs if the input object cannot be casted to the given type. When the error occurs, the output parameter is reported as CAST_FAILED.","For example, the \u201cid\u201d modifier can modify a method parameter value from an object type to an output long type. The precondition for the modifier is that the input type is not a primitive type. There is no optional modifier parameter. The modification results in a unique id for the input object being returned. Additionally, no two objects have the same id and the same object has the same id. An error can occur when the object is null. When the error occurs, the output parameter is reported as NULL_INVOCATION.","In some implementations, a chain of modifiers can be associated with each method specification included in the MPT specification. In some implementations, an empty chain of modifiers (no modifiers) can be associated with each method specification included in the MPT specification. As described in the above examples, not every modifier can be used on any input type. For example, when a method is initially entered during a method parameter trace, the VM (e.g., back-end VM ) can check each applicable method specification in the MPT specification in order to determine if the VM (e.g., back-end VM ) can use the modifiers for the method to determine the method parameter. If the modifiers cannot be used due to a mismatch between the modifier and the input type, the VM (e.g., back-end VM ) can generate an \u201cMPT Apply Error\u201d, which can include additional information about the error. Modifiers are not applied to primitive value types.","In some implementations, a modifier specification can include the name and signature of a parameter type and method. When the method is initially entered, the name and signature of the parameter type and method can be converted to an actual class and method.","For example, when checking a modifier, the VM (e.g., back-end VM ) can determine the trace parameter type used as an input to the modifier and the trace parameter type used as an output from the modifier. The trace parameter type used as an input to the modifier can be a general class object. Initially, the VM (e.g., back-end VM ) can obtain the class object of the trace parameter. For example, using a type name and calling the loadClass( ) on the class loader that defined the parameter value can obtain the class object of the trace parameter for the reference types. If obtaining the class object of the trace parameter fails, the VM (e.g., back-end VM ) can report an \u201cMPT Apply Error\u201d. The VM (e.g., back-end VM ) will then not trace the method associated with the trace parameter using the MPT specification. If obtaining the class object of the trace parameter is successful, the class object can be the input to the first modifier, for example, in a chain of modifiers. Additionally, each modifier in the chain of modifiers can obtain the output type as a class object if the input type was also a class object.","For example, the previously described \u201carray_element\u201d modifier can output the class object of the element type of the array. In addition, a modifier (e.g., the \u201carray_element\u201d modifier) can check if the input type to the modifier is suitable for the modifier (e.g., the input type is an array). This check can be referred to as the preconditions described for each modifier (e.g., the precondition for the \u201carray_element\u201d modifier is that the input type is an array). If the input type is not suitable (e.g., the preconditions are not met), the VM (e.g., back-end VM ) can report an \u201cMPT Apply Error\u201d.","If the input type is suitable and the preconditions are met, the class of the final output object (the object to be traced) is known. If the class of the final output object is not a traceable type (e.g., the resulting method parameter value type is not a primitive value type) the VM (e.g., back-end VM ) can report an \u201cMPT Apply Error\u201d. If the class of the final output object is a traceable type, the VM (e.g., back-end VM ) can report the method parameter type for the specified method for tracing along with the specific method specification in the MPT specification. For every call to the specified method, the VM (e.g., back-end VM ) can apply the modifiers. For example, a modifier error can occur at each method call. In this case, the VM (e.g., back-end VM ) can report the error specified in the \u201cOn Error\u201d description for each modifier when the error condition described in the \u201cOn Error\u201d description occurs. For example, the VM (e.g., back-end VM ) may report a special tag or error code (e.g., as specified in the \u201cOn Error\u201d description for each modifier) for the first modifier encountering an error.","For example, a VM (e.g., back-end VM ) can report a plurality of types of values for a single MPT specification. For example, a VM can report a \u201cBool\u201d type that represents a Boolean value. For example, a VM can report a \u201cByte\u201d type that can represent a byte value. For example, a VM can report a \u201cShort\u201d value that can represent a short integer (short) value. For example, a VM can report a \u201cChar\u201d value that can represent a character (char) value. For example, a VM can report an \u201cInt\u201d value that can represent an integer (int) value. For example, a VM can report a \u201cLong\u201d value that can represent a long integer (long) value. For example, a VM can report a \u201cFloat\u201d value that can represent a floating decimal integer (float) value. For example, a VM can report a \u201cDouble\u201d value that can represent a double precision integer (double) value. For example, a VM can report a \u201cString\u201d value. The \u201cString\u201d value can represent a string like value. For example, this value type is used for a String, StringBuilder or StringBuffer trace. For example, a VM can report a \u201cCastFailed\u201d value that is the value type traced when a cast of a modifier fails. For example, a VM can report an \u201cEnableFailed\u201d value that is the value type traced when the value could not be traced because the modifiers were incorrect (e.g., a \u201cMPT Apply Error\u201d is reported). The method can still be traced, however, the parameter value will be \u201cEnableFailed\u201d (e.g., timing information or the number of method calls can still be obtained and used). For example, a VM can report an \u201cExceptionInCall\u201d that is the value type traced if a modifier calling a method returns from that method with an exception. For example, a VM can report an \u201cInvalidIndex\u201d that is the value type traced if the VM attempts to access an array with an invalid index. For example, a VM can report a \u201cNullInCall\u201d that is the value type traced if the VM attempts to invoke a method in the \u201cinstance_method\u201d modifier on a null object. For example, a VM can report a \u201cNullValue\u201d that is the value type traced if the value to trace is null. For example, a VM can report an \u201cUnknown\u201d that is the value type traced. When a MPT is enabled, a synthetic entry event can be generated of all methods on the stacks of all current threads.","When the profiling of a specific method specified in the MPT specification begins, the application may already be executing the method. In some implementations of the back-end VM, the back-end VW may not be able to access the parameter values of the method. For example, the application running the method may overwrite or reuse the memory location (i.e. the method stack) where the parameter values are stored, destroying the parameter values.","In some implementations, modifiers can call methods specified in the MPT specification. This can lead to infinite recursion in an application. Therefore, a VM (e.g., back-end VM ) should not trace methods in a thread in which the MPT modifiers are currently executing.","In some implementations, a profiler can trace one or more methods, and can trace one or more parameters for each specific method. In some implementations, a profiler can trace the same method parameter value using different modifiers. For example, a profiler that traces the same method parameter value using different modifiers can result in a set of method parameter values each corresponding to a single MPT specification, on each method call. For example, the back-end VM  executing the profiler can report the set of method parameter values to the front-end VM . The front-end profiler on the front-end VM  can modify or combine the set of method parameter values. For example, the front-end profiler can combine two method parameter values into a single method parameter value. For example, the front-end profiler can extract content from the method parameter values (e.g., when tracing Structured Query Language (SQL) methods the front-end profiler can extract the tables involved in the query and can create a synthetic value containing only the extracted tables).","The front-end profiler can combine the values of the same method parameter using different modifiers. For example, a user selects the HashMap.get(Object) method to trace. The method uses a general object as its input. A VM can call a toString( ) method in the modifier to convert the object to a string and use the result as the parameter value. In another example, a class named Special includes a field that contains more information about the general object, \u201cObject\u201d, than the string returned by the toString( ) method. The user can create MPT specifications, where a first MPT specification uses the \u201cinstance_method\u201d modifier with \u201ctoString( )\u201d as the parameter. A second MPT specification can \u201ccast\u201d a modifier as the first modifier, which tries to cast the object \u201cObject\u201d to a Special class. A field modifier can extract the field (defined in the class named Special) of the object. As a result, two values for the method parameter are generated for an entry event. When the parameter value is of the class Special, an additional parameter value will not be reported as a CastFailed. Therefore, the front-end profiler running on the front-end VM  can display (e.g., on display device ) the second value for the method parameter. Whenever the second value for the method parameter is not an indication of a failed cast (e.g., CastFailed), the front-end VM  can display (e.g., on display device ) the second value for the method parameter as a fallback.","Referring now to , exemplar steps that can be executed in accordance with implementations of the present disclosure will be described. The exemplar steps of  can be executed using one or more processors coupled to a computer-readable storage medium at a computer system (e.g., the computer system  including server ) and\/or a client device (e.g., the client devices , ).","In step , one or more MPT specifications is received. For example, the MPT module  in  can provide one or more MPT specifications to the back-end VM . Each MPT specification indicates one or more methods and one or more parameters to be traced, the one or more parameters corresponding to the one or more methods. In step , an application is executed. The application including calls that call a method of the one or more methods using the virtual machine. For example, the back-end VM  can execute the application, and each time the back-end VM  calls a selected method, the back-end VM  can apply the applicable MPT specifications for the selected parameters to the current parameter values of the selected method. It is appreciated, however, that the MPT specifications can be received while the application is executing. Accordingly, and in some implementations, step  can occur before step . In step , a subset of the MPT specifications is determined. The subset corresponds to MPT specifications that are applicable to a currently called method. For example, the VM (e.g., back-end VM ) can determine the method specification included in the MPT specification for a called method. The VM (e.g., back-end VM ) can call a method specified in the MPT specification during execution of the application.","In step , an entry event for the called method is generated. For example, each time the back-end VM  calls a selected method, the back-end VM  can apply the applicable MPT specifications for entry events for the selected method. In some implementations, the parameter values of the called method can be grouped into a first group and a second group, values of the first group can be directly written to the entry event, values of the second group can be transformed based on one or more modifiers to provide one or more modified values, and the one or more modified values can be written to the entry event. The modifiers can be provided in a chain of modifiers, each modifier in the chain of modifiers having an input and an output, an output of one modifier being an input of another modifier in the chain of modifiers, wherein an output of a last modifier in the chain of modifiers comprises a modified value.","In step , the entry event is reported. For example, the server API  can enable the client  by way of network  and client API  to receive the entry event and, among other data, resultant traced method parameter values from the back-end VM .","In step , an exit event for the called method is generated. For example, each time the back-end VM  exits a selected method, the back-end VM  can apply the applicable MPT specifications for exit events for the selected method. In step , the exit event is reported. For example, the server API  can enable the client  by way of network  and client API  to receive the exit event and, among other data, resultant traced method parameter values from the back-end VM . In step , a duration of the called method can be determined and the steps end. For example, if the entry event and the exit event include respective timestamps, the duration of the called method can be determine by comparing the timestamps. This determination can be performed at the front-end, and\/or the back-end.","Referring now to , a schematic illustration of exemplar hardware components  that can be used to execute implementations of the present disclosure is provided. The system  can be used for the operations described in association with the methods described in accordance with implementations of the present disclosure. For example, the system  may be included in the application server . The system  includes a processor , a memory , a storage device , and an input\/output device . Each of the components , , , and  are interconnected using a system bus . The processor  is capable of processing instructions for execution within the system . In one implementation, the processor  is a single-threaded processor. In another implementation, the processor  is a multi-threaded processor. The processor  is capable of processing instructions stored in the memory  or on the storage device  to display graphical information for a user interface on the input\/output device .","The memory  stores information within the system . In one implementation, the memory  is a computer-readable medium. In one implementation, the memory  is a volatile memory unit. In another implementation, the memory  is a non-volatile memory unit. The storage device  is capable of providing mass storage for the system . In one implementation, the storage device  is a computer-readable medium. In various different implementations, the storage device  may be a floppy disk device, a hard disk device, an optical disk device, or a tape device. The input\/output device  provides input\/output operations for the system . In one implementation, the input\/output device  includes a keyboard and\/or pointing device. In another implementation, the input\/output device  includes a display unit for displaying graphical user interfaces.","The features described can be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. The apparatus can be implemented in a computer program product tangibly embodied in an information carrier, e.g., in a machine-readable storage device, for execution by a programmable processor; and method steps can be performed by a programmable processor executing a program of instructions to perform functions of the described implementations by operating on input data and generating output. The described features can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from, and to transmit data and instructions to, a data storage system, at least one input device, and at least one output device. A computer program is a set of instructions that can be used, directly or indirectly, in a computer to perform a certain activity or bring about a certain result. A computer program can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.","Suitable processors for the execution of a program of instructions include, by way of example, both general and special purpose microprocessors, and the sole processor or one of multiple processors of any kind of computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Generally, a computer will also include, or be operatively coupled to communicate with, one or more mass storage devices for storing data files; such devices include magnetic disks, such as internal hard disks and removable disks; magneto-optical disks; and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, such as EPROM, EEPROM, and flash memory devices; magnetic disks such as internal hard disks and removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, ASICs (application-specific integrated circuits).","To provide for interaction with a user, the features can be implemented on a computer having a display device such as a CRT (cathode ray tube) or LCD (liquid crystal display) monitor for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball by which the user can provide input to the computer.","The features can be implemented in a computer system that includes a back-end component, such as a data server, or that includes a middleware component, such as an application server or an Internet server, or that includes a front-end component, such as a client computer having a graphical user interface or an Internet browser, or any combination of them. The components of the system can be connected by any form or medium of digital data communication such as a communication network. Examples of communication networks include, e.g., a LAN, a WAN, and the computers and networks forming the Internet.","The computer system can include clients and servers. A client and server are generally remote from each other and typically interact through a network, such as the described one. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","In addition, the logic flows depicted in the figures do not require the particular order shown, or sequential order, to achieve desirable results. In addition, other steps may be provided, or steps may be eliminated, from the described flows, and other components may be added to, or removed from, the described systems. Accordingly, other implementations are within the scope of the following claims.","A number of implementations of the present disclosure have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the present disclosure. Accordingly, other implementations are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
