---
title: Method for enabling a compiler or interpreter to use identifiers found at run time in a map container object in a manner similar or identical to identifiers declared at compile time
abstract: A method for enabling a compiler or interpreter to use identifiers found at run time in a map container object in a manner similar or identical to identifiers declared at compile time is presented. More specifically, names defined in a map container object during the execution of a program are treated in a manner similar or identical to names defined in a programming namespace at compilation (or interpretation) time. The map container is applied to encapsulate a non-programming namespace application programming interface (API), so that names defined in a non-programming namespace can be treated in a manner similar or identical to names defined in a programming namespace at compilation (or interpretation) time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06993744&OS=06993744&RS=06993744
owner: Tajen Corporation
number: 06993744
owner_city: Princeton
owner_country: US
publication_date: 20001219
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["This invention relates generally to programming of digital computers, and, more particularly, to a method for enabling compilers or interpreters to use identifiers found at run time in a map container object in a manner similar or identical to identifiers declared at compile time.","In the abstract, a namespace is a space within which names are defined, can be differentiated from each other, and have unique identity. Programming languages always define at least one namespace, allowing names to be defined which are differentiated from each other, and which are used to identify nameable entities in the namespace. Many programming languages, including C++ and Java\u00ae, support multiple namespaces, either explicitly or implicitly, or both. (Java\u00ae is a registered trademark of Sun Microsystems, Inc.) For instance, C++ treats every class as its own namespace, and additionally includes a namespace definition declaration, allowing the definition of previously non-existent namespaces, in which new unique names may be defined.","Various systems and subsystems implemented in computers, other than programming languages, support namespaces, which identify by (typically human-readable) character strings objects of classes supported by those subsystems. For example, a hierarchical filesystem provided by an operating system supplies a namespace where each name identifies either a file (a sequence of bytes on a storage medium) or a directory containing files and other directories. As another example, the IEEE POSIX\u00ae operating system specification, as defined by \u201cIEEE\/ANSI Std 1003.1, 1996 Edition: Information Technology\u2014Portable Operating System Interface (POSIX&)\u2014Part 1: System Application: Program Interface (API) [C Language]\u201d, which is incorporated herein by reference, defines an \u201cenvironment\u201d that supplies a namespace where each name identifies an arbitrary string of characters of any length. (POSIX\u00ae is a registered trademark of The Institute of Electrical and Electronic Engineers, Inc.) As a further example, Uniform Resource Identifiers (URIs) defined by \u201cIEC RFC 2396: Uniform Resource Identifiers (URI): Generic Syntax\u201d, which is incorporated herein by reference, define a namespace encompassing the entire Internet, such that any object reachable via the Internet may be named. As a further example, CORBA\u00ae, as defined by Object Management Group, \u201cThe Common Object Request Broker: Architecture and Specification, Minor revision 2.3.1\u201d, Needham, Mass., Object Management Group, October 1999, which is incorporated herein by reference, defines an Interface Repository, containing named definitions of interfaces and other related objects, which are named by human-readable identifiers. (CORBA\u00ae is a registered trademark of Object Management Group, Inc.) These namespaces hereinafter will be referred to as \u201cnon-programming namespaces\u201d.","It is desirable that computer programs can access objects in these non-programming namespaces, in order to find objects by name, to read and write the objects, to create and delete named objects, and to invoke methods defined on the objects. To this end, it is customary that for a given computer programming language (such as C++ or Pascal), and a given kind of non-programming namespace (such as a filesystem), an application programming interface (API) to that namespace is defined. Such an API typically defines a function for each of the aforementioned operations. The functions that locate named objects in a non-programming namespace often accept as arguments strings of characters which are the names of objects sought. These strings are not considered names in the source programming language used to program the function calls. Therefore, objects defined in non-programming namespaces are named, created, deleted, and manipulated using function calls the meaning of which is defined entirely outside the source programming language. By contrast, objects defined using the source programming language are named, created, deleted, and manipulated using statements defined by the language itself, and those statements are interpreted by a compiler or interpreter of the language. As a result, much of the expressiveness of a programming language cannot be employed by program source code which manipulates objects in a non-programming namespace. Additionally, no uniformity exists in referencing by name objects defined using a programming language versus objects defined outside a programming language.","In practice to date, among APIs to a number of non-programming namespaces defined for a single programming language, there is little or no commonality between the functions of distinct APIs intended to perform similar or identical operations on the objects of their respective non-programming namespaces.","Accordingly, there is a need for a mechanism that provides access to objects and their names defined in non-programming namespaces, which is integrated with access to objects and their names defined in programming namespaces, and which is uniform across disparate kinds of namespaces.","The above-discussed and other drawbacks and deficiencies of the prior art are overcome or alleviated by the method of the present invention for enabling a compiler or interpreter to use identifiers found at run time in a map container object in a manner similar or identical to identifiers declared at compile time. In accordance with the present invention, names defined in a map container object during the execution of a program can be treated in a manner similar or identical to names defined in a programming namespace at compilation (or interpretation) time.","More specifically, when a compiler (or interpreter) incorporating the present invention encounters a locally scoped identifier, it applies static name resolution rules as defined in the programming language definition. If it does not resolve the identifier statically, and one or more map object container objects have been incorporated into the current scope through \u201cnamespace using directives\u201d, the compiler generates code as follows. Firstly, the compiler regards the identifier as a reference to an object which is to be discovered at execution time. When generating object code for source code referencing the identifier, the compiler generates code that accesses the referenced object indirectly, through a reference object associated with the identifier, whose value can be set at run time. Secondly, the compiler generates code to search at run time the map containers incorporated into the current scope through \u201cnamespace using directives\u201d for a key whose value is a string equal to the identifier string. If the generated code finds a matching key in the container, it sets the reference variable associated with the identifier to reference the object corresponding to the key found. If a match is not found, an exception is thrown. After successful assignment to the reference variable, the identifier may be used to reference the object found through its associated reference variable, just as if the identified object had been known at compile time.","Additionally, the compiler may interpret a \u201cnamespace using declaration\u201d that explicitly references a map container object, by generating code as described above, searching only the explicitly referenced map container object for the identifier appearing in the \u201cnamespace using declaration\u201d.","The present invention contemplates immediate useful application to encapsulating access to non-programming namespaces such as filesystems, environment variables, Internet URIs, run-time object name resolution schemes, etc.","The above-discussed and other features and advantages of the present invention will be appreciated and understood by those skilled in the art from the following detailed description and drawings.","An embodiment of the invention may be described with respect to any traditional object-oriented programming language. For the purpose of describing the invention herein, a new programming language, hereinafter called \u201cD\u201d, will be used. The \u201cD\u201d programming, language is the subject of a related application Ser. No. 09\/741,502 entitled \u201cCOMPUTER PROGRAMMING LANGUAGE TO DESCRIBE AND ENCAPSULATE A COMPUTER AS A SET OF CLASSES AND OBJECTS\u201d which is being filed concurrently herein, and which is incorporated herein by reference. This language has syntax similar to that of C++.","Preferably the D language compiler allows reference at run time to objects in a map container, such objects found in the map container with string keys conformant to the compiler's source language lexical requirements for identifiers, such string keys supplied in the source code to the compiler as identifiers.","An embodiment of the invention may be described with respect to any non-programming namespace. For the purpose of describing the invention herein, a POSIX-compliant filesystem is used herein as an exemplary embodiment.","As an aid to understanding the teaching in this document, in the following sections characters enclosed in single quotation marks, as in \u2018this text\u2019, are to be interpreted as characters which could appear in the source code of a D language program exactly as shown in this text, without the enclosing single quotation marks.","Map Container Objects","A container object is an object which can contain other objects. There can be many kinds of container objects, distinguished primarily by how the objects are organized inside the container\u2014whether as a sequential list, a set of unique values, or some other means. The container object of interest here is called a \u201cmap\u201d. This is a container of pairs of objects. The first object of each pair is called the \u201ckey\u201d, and the second object is called the \u201cvalue\u201d. Within a single map container, each key is guaranteed to be unique, so that a key uniquely identifies an object in the map.","In an object-oriented implementation of a map container, all keys are constrained to be of a single class (or its substitutable subclasses), and likewise all values are constrained to be of a single class (or its substitutable subclasses). The key and value classes do not necessarily have any relation to each other: they can be the same class or different classes.","Table 1 below shows source code in the D language for an interface to a class implementing a map container. The interface itself has two parameters: \u2018\u2019 and \u2018\u2019. Both of these are of class \u2018\u2019, the meta-class of classes. \u2018\u2019 and \u2018\u2019 supply the map's key class and value class, respectively.",{"@attributes":{"id":"p-0021","num":"0020"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"new Interfacec<? Classc Keyc, Classc Valuec ?> Mapi"},{"entry":"("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"interface"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"function Subrc<? returns Nat32t nItems ?> size;"]},{"entry":[{},"function Subrc<? Keyc Key, returns ptrTo (Valuec) pValue ?> find;"]},{"entry":[{},"method Subrc<? ?> clear;"]},{"entry":[{},"method Subrc<? Keyc Key, Valuec Value ?> insert;"]},{"entry":[{},"method Subrc<? Keyc Key ?> remove;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":");"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The function \u2018\u2019 returns the number of objects in the container. The function \u2018\u2019 returns a pointer to an object found in the container with key equal to the argument \u2018\u2019. If no object in the container is associated with a key equal to \u2018\u2019, the pointer is set to null. The method \u2018\u2019 removes all objects from the container. The method \u2018\u2019 inserts a new object in the container in association with key value \u2018\u2019. The method \u2018\u2019 removes from the container the object associated with key value \u2018\u2019.","In the present invention, the class of key used is a string of characters, and the class of value is any arbitrary class. Table 2 below shows source code in the D language for a specialized version of interface \u2018\u2019 that specifies the key class as a string. The specialized version is identified as \u2018\u2019.",{"@attributes":{"id":"p-0024","num":"0023"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"new Interfacec<? Classc Valuec ?> SymbolTablei"},{"entry":"("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"interface extends (Mapi (Stringc, Valuec))"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"method Subrc<? Valuec Value, Stringc Key (Value\u2032Name) ?> insert"]},{"entry":[{},"({ insert (Key, Value); });"]},{"entry":[{},"method Subrc<? Valuec Value, Stringc Key (Value\u2032Name) ?> remove"]},{"entry":[{},"({\u2032 remove (Key); });"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"252pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":");"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Class \u2018\u2019 is a predefined class of the D programming language, and is the class of a string of characters. Class \u2018\u2019 is any class. By virtue of the declaration \u2018(, )\u2019, the interface \u2018\u2019 is established as a specialized interface to a general map container, where the key class is always a string class. The interface literal for \u2018\u2019 provides overloaded versions of member methods \u2018\u2019 and \u2018\u2019 that depend on this fact. Both of these methods take two arguments, but the second argument has a default value, which is the name of the first actual argument in string form. This makes possible a shorthand form of invocation, where only a single argument is supplied to \u2018\u2019 or \u2018\u2019, and the identifier of the actual argument is taken to be the key value. Examples of the use of this shorthand form are presented below.","Inserting Objects into a Map Container","It is ordinary for a program to define a map container, whose keys are strings, and to insert named objects into the container. Table 3 below shows source code in the D programming language that defines a map container, whose keys are strings, and inserts named objects into the container.",{"@attributes":{"id":"p-0027","num":"0026"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["new SymbolTablei (Descriptorc) aMap();","## line 1"]},{"entry":"new Descriptorc d1 ();"},{"entry":["aMap.insert (\u201cd1\u201d, d1);","## line 4"]},{"entry":"new Descriptorc d2 ();"},{"entry":["aMap.insert (d2);","## line 7"]},{"entry":["aMap.remove (d1);","## line 9"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Line  in Table 3 defines a symbol table object called \u2018\u2019. As has been seen in Table 2 above, a symbol table object is a map object having <key, value> pairs where the key class is \u2018\u2019. On line  of Table 3, the value class is declared to be \u2018\u2019. The empty parentheses at the end of the line invoke the map object's default constructor, which initializes the map to be an empty container. Likewise, the empty parentheses at the ends of lines  and  in Table 3 invoke the default initializers for those objects. They do not denote that these objects are functions, as similar syntactical usage would do in the C++ programming language.","Note the difference between the call to method \u2018insert\u2019 on line  vs. the call on line  in Table 3. On line  in Table 3, it is clearly seen that a <key, value> pair is being inserted into the map container object identified as \u2018\u2019. The identifier of the value, \u2018\u2019, is redundantly specified in the form of a string literal as the key to be associated with the object itself. This is an invocation of the \u2018\u2019 method defined in the interface literal for \u2018\u2019.","On line  in Table 3, a version of the \u2018\u2019 method is invoked with only one argument, an instance of the map container's value class. This matches the overloaded version of the \u2018\u2019 method defined in the interface literal for \u2018\u2019. This version of the \u2018\u2019 method receives not only the object referenced by the identifier \u2018\u2019, but also the identifier \u2018\u2019 itself as a string object, through the method's second, default argument. Since this overloaded \u2018\u2019 method is implemented in terms of the \u2018\u2019 method in \u2018\u2019, the two methods are known to be semantically equivalent.","The call in line  in Table 3 is not only more convenient for a programmer to write, but it also eliminates the possibility that the programmer will mistakenly use a different string as key than the actual identifier of the object.","Symbol Table as Map","Within every compiler is a symbol table, which is a table of the identifiers declared in the source code being compiled, and the definitions attached to those identifiers. Such a symbol table is a kind of map, where the key is the identifier string itself, and the value is the compiler's internal representation of the definition attached to the identifier.","Referencing Objects in a Map Container","Table 4 below is an example of two different, though equivalent, ways of referring to the named contents of the map object \u2018\u2019.",{"@attributes":{"id":"p-0034","num":"0033"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"new Subrc<? SymbolTablei (Descriptorc) aMap ?> M6"},{"entry":"({"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"new ptrTo (Descriptorc) @ d2 (aMap.find (\u201cd2\u201d));","## line 3"]},{"entry":[{},"using aMap::d1;","## line 5"]},{"entry":[{},"using aNamespace::obj;","## line 7"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"});"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Line  in Table 4 shows the definition of a new subroutine named \u2018\u2019, with a single argument, which is any map container of the same class as that declared in Table 3. For convenience of explanation, the name of the formal argument has been chosen to be the same as the name of the actual map container object in Table 3; that is, \u2018aMap\u2019.","Line  in Table 4 declares a reference object called \u2018\u2019. In the D language, a reference object is a pointer object declared with the suffix \u2018@\u2019 on the expression giving the class of the pointer object. Every reference to an identifier of a pointer object, except an initializing reference, is implicitly a reference to the object which the pointer signifies. The D language definition prohibits initialization of a reference object with a null pointer. The D language compiler always generates code for initializing a reference object which tests if the object is being initialized with a null pointer and, if so, throws an exception.","Line  in Table 4 initializes reference object \u2018\u2019 to refer to the object found by the call to the \u2018\u2019 method of the \u2018\u2019 container. If the \u2018\u2019 method fails to find an object in \u2018\u2019 whose associated key is the character string \u2018\u2019, it returns a null pointer. As explained above, this causes an exception to be thrown. The throwing of an exception terminates the forward execution of statements, so no statements after line  in Table 4 will be executed in this exceptional situation. This is good, since if execution could proceed, \u2018\u2019 would identify a reference object with a null value, which violates the language definition. Throwing an exception safeguards code which assumes that the program adheres to the language definition.","Line  in Table 4 is a \u201cnamespace using declaration\u201d. It declares the identifier \u2018\u2019 as a locally scoped identifier which references an object found in \u2018\u2019 with key value equal to the identifier string. Line  in Table 4 is semantically equivalent to line  in Table 4 (other than the use of \u2018\u2019 instead of \u2018\u2019). The differences are purely syntactic. In fact, in compiling line  in Table 4, the compiler generates the code on line  in Table 4. Line  in Table 4 has the same advantage over line  in Table 4 as does line  in Table 3 over line  in Table 3, because of the avoidance of redundant specification of the object identifier.","Except for the fact that they identify different objects, the identifiers \u2018\u2019 and \u2018\u2019 are semantically and syntactically equivalent. Each references an object found in a map container by its name. Each can be used to manipulate the object it references, in the manner usual in an object-oriented program. Code following each of these lines is protected by the fact that it will not be reached, due to an exception being thrown, if the identifier is not properly initialized to reference an object, as required by the D language definition. This protection is important, since the compiler cannot guarantee at the time it sees the source code whether the map container object will contain the identifiers referenced at run time.","Line  is included in Table 4 to illustrate that the syntax for referencing a name in a program namespace is identical to the syntax used on line  in Table 4 for referencing a name in a map container object. This sameness is an important feature of the present invention. The syntax of line  in Table 4 happens to be identical to the syntax of a \u201cusing declaration\u201d in the C++ programming language. This information is provided not as an essential aspect of the invention, but to include as an illustration the similar use of the syntax of line  in Table 4 in another programming language, to aid in understanding the entire example.","Map as Symbol Table","Table 5 below is an example of another way in which the contents of the exemplary map container can be referenced.",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"new Subrc<? SymbolTablei (Descriptorc) aMap ?> M7"},{"entry":"({"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"using namespace aMap;","## line 3"]},{"entry":[{},"d2:=d1;","## line 5"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"});"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"The statement on line  in Table 5 (called a \u201cusing directive\u201d in the C++ programming language and a UsingStatement in the D programming language) allows the names in \u2018\u2019 to be used without qualification in any statement following line  in Table 5, in the scope of the statement.","When the compiler processes line  in Table 5 to resolve the identity of the identifiers \u2018\u2019 and \u2018\u2019, it searches its symbol table for identifiers available according to the rules of the language. For instance, the compiler will search for any or all of the following: locally-declared identifiers; identifiers which are members of the enclosing class, if there is an enclosing class; identifiers in any namespaces included via using directives; and the global namespace.","The present invention enables a compiler to also search for identifiers in a map container object. When generating code for line  in Table 5, the compiler first determines that the names \u2018\u2019 and \u2018\u2019 are not statically defined in any of the above-mentioned places. It determines this in the traditional way, by searching its symbol table. Assuming that the compiler has not found definitions in any of those places, it generates code which, at execution time, for each of \u2018\u2019 and \u2018\u2019, searches the map container mentioned in the using directive in line  in Table 5 (\u2018\u2019), and initializes a reference object for each found, as described earlier. If one or both are not found, the generated code throws an exception.","Thus, the present invention enables the use of names defined in a map container object at execution time to be treated equivalently to names defined statically at compile time.","Note, in all of the above, that this aspect of the present invention is useful with objects in map containers whose corresponding keys are strings which conform to the lexical requirements of identifiers in the programming language in which the invention is incorporated. If a map container contains keys not conforming to the language's lexical requirements, those keys can be found using string objects or string literals as parameters to map \u2018\u2019 methods, rather than using identifiers, and the rest of the invention remains useful.","Application to Filesystem API","The application of the present invention is open to use in any kind of map, containing any kind of value class. However, the present invention has particular value when applied to certain commonly encountered non-programming namespaces, including filesystems, so-called \u201cenvironments\u201d containing string variables, key registry systems, etc. The useful application of the present invention to any and all such non-programming namespaces is contemplated. For the sake of illustration of such applications, the application of the present invention to a POSIX filesystem is described, however it is not limited to such.","It is possible in an object-oriented programming language to write a class which represents a filesystem, and which encapsulates the filesystem API so that the filesystem appears to be a set of nested map containers. The map's key class is a string whose values are filenames in the filesystem, and the map's value class is a class representing a filesystem file. Significantly, a subclass of the value class is a directory class. This precisely models the POSIX filesystem, where a directory is a special kind of file. The directory class is also a map container class, whose key class is a string whose values are filenames in the filesystem, and whose value class represents a file. These classes and their relationships are expressed as a Unified Modeling Language (UML) static structure chart of the FIGURE. The Unified Modeling Language is defined in Rumbaugh, James, Ivar Jacobson, and Grady Booch, \u201cThe Unified Modeling Language Reference Manual,\u201d Reading, Mass., Addison-Wesley, 1999, which is incorporated herein by reference.","Referring to the FIGURE, box  is the UML symbol for a parameterized class. This box  is labeled Mapi, and represents the interface to the map container class of the example. The dashed box  overlapping box  shows its two parameters, \u201ckey\u201d and \u201cvalue\u201d. The parameter \u201ckey\u201d is bound to the class Stringc , as indicated by the dashed arrow labeled with the UML stereotype <<bind>> from box  to box . The parameter \u201cvalue\u201d is bound to the class Filec , as indicated by the dashed arrow labeled with the UML stereotype <<bind>> from box  to box . Class Filec  is the class of all files in the filesystem, and is the ancestor class of Dirc , the class of directories. Dirc  is derived from Filec  and also implements Mapi . These relationships describe a directory as a subclass of file implementing a map from filenames to files. Dirc  therefore inherits and implements methods and attributes of both map containers and files. For instance, objects in instances of Dirc  can be found using the same operations as used to find objects in instances of classes implementing Mapi . Likewise, instances of Dirc  can be copied using the same methods as used to copy instances of Filec .","The design depicted in the FIGURE is described in the D language in Table 6 below. The names of classes in Table 6 are identical to their corresponding classes in the FIGURE. The source code of Table 6 declares that class Dirc implements the named members inherited from interface \u2018()\u2019.",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"new Classc Dirc"},{"entry":"("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"class extends (SymbolTablei (Filec))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"extends (Filec)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"function Subrc<? Stringc id, returns ptrTo (Filec) pF ?> find;"]},{"entry":[{},"method Subrc<? Stringc id ?> insert;"]},{"entry":[{},"method Subrc<? Filec f, Stringc id (f\u2032Name) ?> insert;"]},{"entry":[{},"method Subrc<? Stringc id ?> remove;"]},{"entry":[{},"method Subrc<? Filec f, Stringc id (f\u2032Name) ?> remove;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":");"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"With this definition of class \u2018\u2019, as both a map container class and a subclass of file found in the filesystem, code such as that shown in Table 7 below is possible.",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"new Subrc<? Dirc Root ?> M1"},{"entry":"({"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"## Copy the file named \u201ca\u201d to the file named \u201cb\u201d, both of which are"]},{"entry":[{},"## in Root."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"using Root::a;","## line 5"]},{"entry":[{},"using Root::b;"]},{"entry":[{},"b:= a;"]},{"entry":[{},"## Concatenate file f to the end of file e."]},{"entry":[{},"using Root::e;"]},{"entry":[{},"using Root::f;"]},{"entry":[{},"f+= e;","## line 12"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"## Copy the file named \u201cd\u201d in the root to the file named \u201ch\u201d in sub-"]},{"entry":[{},"## directory \u201cq\u201d."]},{"entry":[{},"using Root::d;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"using (Root::q as Dirc) ::h;","## line 17"]},{"entry":[{},"h:= d;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"});"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In Table 7, the statement on line  causes the locally scoped identifier \u2018a\u2019 to become a reference to the file named \u201ca\u201d in the directory which is passed into the subroutine as argument \u2018\u2019. Line  in Table 7 defines \u2018\u2019 in a similar fashion, and line  in Table 7 uses object-oriented operator overloading to express a file copy operation as a simple assignment statement.","Line  in Table 7 shows that file operations other than copying, such as concatenation, can also be overloaded onto operators in the language. This is possible because identifiers for file objects are treated identically to identifiers for other objects, even though the namespace for file objects exists outside the programming language.","Line  in Table 7 shows a reference to a file \u201ch\u201d in a subdirectory \u201cq\u201d of directory \u201cRoot\u201d. This is accomplished with a natural recursive extension of the syntax for referencing named objects in a map container. The compiler interprets the statement on line  in Table 7 as follows. For the expression \u2018\u2019, it generates code as described above to find a file object named \u201cq\u201d in the map container identified by \u2018\u2019, and bind a pointer to that file to a reference object also named (in the source code) \u2018\u2019. At this point, identifier \u2018\u2019 identifies an object of class \u2018\u2019. For the expression \u2018\u2019, the compiler generates code to cast the class of identifier \u2018\u2019 down the inheritance hierarchy from class \u2018\u2019, its statically known class, to class \u2018\u2019. More specifically, the compiler generates code to verify that the dynamic class of the object identified by \u2018\u2019 is in fact \u2018\u2019, and to throw an exception if this is not true. The compiler considers the static class of the expression \u2018()\u2019 to be class \u2018\u2019.","Once the reference \u2018\u2019 has been cast to a reference to an object of class \u2018\u2019 as just described, the compiler uses the same method as already described to generate code to find a file object named \u201ch\u201d in the map container identified by \u2018\u2019, and bind a pointer to that file to a reference object also named (in the source code) \u2018\u2019. Line  in Table 7 is then a file copy operation, from a file in the \u2018\u2019 directory, to a file in subdirectory \u201cq\u201d.","The example of Table 7 can be written more simply, as shown in Table 8 below. In Table 8, each directory object is incorporated in its entirety as a namespace, to be searched at execution time.",{"@attributes":{"id":"p-0060","num":"0059"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"new Subrc<? Dirc Root ?> M2"},{"entry":"({"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"## Bring the root directory into the current namespace."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"using namespace Root;","## line 4"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"## Now, names of files and directories in the root directory can be used"]},{"entry":[{},"## without qualification."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"b:= a;","## line 8"]},{"entry":[{},"f+= e;","## line 10"]},{"entry":[{},"using (q as Dirc) ::h;","## line 12"]},{"entry":[{},"h:= d;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"});"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Line  of Table 8 makes the directory object called \u201cRoot\u201d available for searching as a program namespace (at execution time) for any locally scoped identifier not otherwise defined. It can clearly be seen by examining the remaining lines of Table 8 that there is great notational advantage in the directive of line  in Table 8.","The following lines of Table 8 are directly equivalent to lines of Table 7, i.e., Table 8, line ::Table 7, line , Table 8, line ::Table 7, line , Table 8, line ::Table 7, line , and Table 8, line ::Table 7, line .","Thus, the combination of dynamically associating the contents of map objects to source language identifiers, describing non-programming namespaces such as filesystems as map containers, and the ability to overload operations in an object-oriented programming language, leads to an expressive power which allows objects in non-programming namespaces to be treated on a par with objects in programming namespaces.","File Creation and Deletion","The present invention implemented with regard to filesystems allows the same treatment to be accorded the creation and deletion of files as is used with regard to the creation and deletion of objects in a program namespace. Consider the example D language source code of Table 9.",{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"new Subrc<? Dirc Root ?> M3"},{"entry":"({"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"new life (system) Filec f;","## line 3"]},{"entry":[{},"Root.insert (f);"]},{"entry":[{},"using Root::h;","## line 6"]},{"entry":[{},"Root.remove (h);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"});"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Line  of Table 9 shows the definition of a new object named \u2018\u2019, of class \u2018\u2019. This object is defined with a lifetime attribute of \u2018\u2019, meaning that it could exist as long as the system within which it is defined exists. The D language defines the lifetime of a system to be longer than that of a process, thread, or invocation of a subroutine.","Line  of Table 9 invokes the \u2018\u2019 method on \u2018\u2019, passing as an identifier argument both the string form of the identifier \u2018\u2019 and a reference to the object identified by \u2018\u2019. After execution of \u2018\u2019, the \u2018\u2019 object contains a reference to the object identified by \u2018\u2019, uniquely identified within the \u2018\u2019 container by the key equal to the string \u201cf\u201d. Assuming for this example that the lifetime of \u2018\u2019 is also \u2018system\u2019, after the subroutine, thread, and process that created \u2018\u2019 cease to exist, \u2018\u2019 continues to exist by virtue of the reference to it in Root.","In accordance with the foregoing specification, line  of Table 9 defines \u2018\u2019 as the identifier of an object in \u2018\u2019 with key equal to the string \u201ch\u201d. Line  of Table 9 invokes the \u2018\u2019 method on \u2018\u2019, passing a reference to the object identified by \u2018\u2019 in the container \u2018\u2019. By virtue of the second argument of method \u2018\u2019 as shown in Table 6 above, the \u2018\u2019 method also receives a string object equal to \u2018\u2019. After execution of \u2018\u2019, no reference to the object identified by \u2018\u2019 exists in the container \u2018\u2019. However, the reference introduced by the using declaration of line  of Table 9 continues to exist, and therefore so does the object identified by \u2018\u2019. When the scope of identifier \u2018\u2019 is exited, the last reference to the object identified by \u2018\u2019 ceases to exist, and the object has no references to it. The object is deleted immediately or by garbage collection, depending on the memory management scheme. This behavior exactly simulates the treatment by POSIX-compliant filesystems of files whose filesystem links are removed while the files themselves are open in a program. Such files continue to exist until the programs which have them open exit, at which point they are deleted.","Non-Conformant Filename Access","In order to access files whose names do not conform to the lexical requirements of the source language being used, the common method of finding an object in a map container may still be used. Table 10 below shows such access.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"new Subrc<? Dirc Root ?> M10"},{"entry":"({"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"new ptrTo (Filec) @ d2 (Root.find (\u201cd2.txt\u201d));","## line 3"]},{"entry":[{},"using Root::d1;","## line 5"]},{"entry":[{},"d1:= d2;","## line 7"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"});"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Line  associates identifier \u2018\u2019 with an object found in the map container \u2018\u2019 using the key string \u201cd.txt\u201d. Identifiers in this source language may not contain periods, as string \u201cd.txt\u201d does, but this does not prevent source code from being written in the form of line  of Table 10, where an object found is mapped to a lexically acceptable identifier in the source language, using a string not conformant to the lexical requirements of the source language for an identifier. Of course, this form of binding an identifier to a file object can be used even if the filename is conformant to the source language's lexical requirements for an identifier.","Lines  and  of Table 10 are of forms that have already been shown, and illustrate that an identifier bound to an object found in a map container with a key not lexically acceptable as an identifier, may nonetheless be treated in the same manner as any object found or defined with a lexically acceptable identifier.","Traditional File Operations","All of the examples shown above treat file objects as units. Nothing herein prevents file objects from being manipulated in a traditional manner. For example, Table 11 below shows source code to open a file and read it character by character.",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"new Subrc<? Dirc Root ?> M9"},{"entry":"({"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"## \u201cOpen\u201d the file named \u201cc\u201d for reading,"]},{"entry":[{},"\u2003\u2003 and count the number of newline"]},{"entry":[{},"## characters in the file."]},{"entry":[{},"using Root::c;"]},{"entry":[{},"new FilePtrc fpC(c.open(\u201cr\u201d));\u2003\u2003\u2003\u2003## line 6"]},{"entry":[{},"new Nat32t nLinesC(0);"]},{"entry":[{},"while (!fpC.eof ( ))"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"new BLatinc ch(*fpC++);"]},{"entry":[{},"if(ch == \u2018\\n\u2019) { ++nLinesC; }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"});"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Line  of Table 11 shows the definition of new object \u2018\u2019, a file pointer object, initialized with the result of invoking the \u2018\u2019 method on an object named \u2018\u2019. \u2018\u2019 is declared on line  as an object to be found at run time in directory object \u2018\u2019, in accordance with the present invention in the manner described above. The remaining lines of Table 11 define a counter, \u2018\u2019, and execute a loop that reads characters one at a time from the file identified by \u2018\u2019, counting the number of newline characters encountered.","As described above, the present invention can be embodied in the form of computer-implemented processes and apparatuses for practicing those processes. The present invention can also be embodied in the form of computer program code containing instructions embodied in tangible media, such as floppy diskettes, CD-ROM's, hard drives, or any other computer-readable storage medium, wherein, when the computer program code is loaded into and executed by a computer, the computer becomes an apparatus for practicing the invention. The present invention can also be embodied in the form of computer program code, for example, whether stored in a storage medium, loaded into and\/or executed by a computer, or transmitted over some transmission medium (embodied in the form of a propagated signal propagated over a propagation medium), such as over electrical wiring or cabling, through fiber optics, or via electromagnetic radiation, wherein, when the computer program code is loaded into and executed by a computer, the computer becomes an apparatus for practicing the invention. When implemented on a general-purpose microprocessor, the computer program code segments configure the microprocessor to create specific logic circuits.","While preferred embodiments have been shown and described, various modifications and substitutions may be made thereto without departing from the spirit and scope of the invention. Accordingly, it is to be understood that the present invention has been described by way of illustrations and not limitations."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":"The FIGURE is a static structure chart in the Unified Modeling Language (UML) for a filesystem directory defined as a special kind of file which is also a map container object in accordance with the present invention."},"DETDESC":[{},{}]}
