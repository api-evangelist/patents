---
title: Static typing of xquery expressions in lax validation content
abstract: Systems and methods that extend static typing rules/algorithms of the World Wide Web Consortium (W3C) rules, with a more precise static typing algorithm that supplies knowledge for types occurring in the Lax validation section. The Lax validation can be identified, and associated expressions known with particularity, wherein types can be inferred for XQuery expressions that navigate down into the Lax validation section. An annotation component annotates elements (e.g., wild card sections) with additional information about wild card sections, and a mapping component maps Lax wild cards to type systems.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08606806&OS=08606806&RS=08606806
owner: Microsoft Corporation
number: 08606806
owner_city: Redmond
owner_country: US
publication_date: 20080725
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["As programming approaches and foundations have evolved, application programming interfaces (APIs) and programming schemas have been developed to standardize and unify programming methodologies that were previously multi-variant and relatively incompatible. Modern programming therefore often involves employing APIs and schemas in conjunction with reusable libraries. Such Programming languages continue to evolve to facilitate specification by programmers as well as efficient execution. For example, a significant component in functionality of Web Services is programmatic interaction with web data.","In general, there are three major components that make up the world of web data\u2014relational data (e.g., SQL), self-describing data (e.g., XML), and a runtime environment. A popular method of implementing a relational data model is by means of SQL (Structured Query Language). SQL is a language used to communicate with a relational database management system such as SQL Server, Oracle or Access\u2014data in a relational database system is typically stored in tables. An accepted standard for self-describing data is XML (eXtensible Markup Language). XML is a World Wide Web Consortium (W3C) standard language that describes data via a schema or Document Type Definition (DTD). XML data is stored through the use of tags. A runtime environment is a general-purpose multilanguage execution engine (e.g., Common Language Runtime (CLR)) that allows authors to write programs that use both relational data and self-describing data.","XML provides syntax for describing heterogeneous graph(s) of data where typing rules (usually called \u201cschema validation\u201d) are optional and loosely bound to those type instances. Furthermore, the XML schemas associated with those documents can describe more complex structures with sequences, choices, unbounded type collections, and a combination of typed and untyped data. Such constructs are designed to allow a loosely coupled architecture that minimizes hard dependencies between different parties that make up a complex distributed system and have proven to be an effective way to make distributed systems scale up to a level of complexity required for today's interconnected business systems.","Accordingly, wildcard characters can be employed to increase flexibility in what is allowed to appear in a content model. These characters are supported in the XSD language in ways such as: element wildcard characters, represented by the <xsd:any> element; Attribute wildcard characters represented by the <xsd:anyAttribute> element. Moreover, both wildcard character elements, <xsd:any> and <xsd:anyAttribute>, support the use of a processContents attribute. Such enables specifying a value that indicates how XML applications handle the validation of document content associated with these wildcard character elements. For example, the strict value specifies that the contents are fully validated; the skip value specifies that the contents are not validated; the lax value specifies that only elements and attributes for which schema definitions are available are validated.","Furthermore, the XQuery language provides for static type analysis and static type checking. Typically, to perform static type analysis XQuery employs any available XML Schema information tied to the queried data, if available to improve the preciseness of the inferred type. XML Schemas can contain very strict type constraints, for which inferring a type is fairly straight forward, but it also provides so called \u201claxly\u201d validated content models and attributes expressed by the content type xs:anyType, the xs:anyAttribute and xs:any wildcard sections with the processContent property set to Lax. Such process content lax requires content model\/data to be strictly validated\/correct whenever a schema component can be found. Alternatively, if no schema component is found, no requirement of validation exists and such data can be considered very loosely typed.","The following presents a simplified summary in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview. It is not intended to identify key\/critical elements or to delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.","The subject innovation extends static typing rules\/algorithms of the World Wide Web Consortium (W3C) rules, to a more precise static typing algorithm that supplies knowledge for types occurring in the Lax validation section\u2014wherein, such Lax validation can be identified, and the associated expressions known with particularity. Accordingly, types can be inferred for XQuery expressions that navigate down into the Lax validation section, and a more precise type rule is obtained (as compared to current W3C algorithms.) Such facilitates checking compatibility of types at time when operations are to be performed, with expected types (e.g., a check for numeric types\u2014as opposed to any type\u2014for mathematical operation), wherein expressions can be compiled with knowledge for the types involved, and errors mitigated\/optimizations introduced. In a related aspect, an annotation component annotates elements (e.g., wild card sections) with additional information about wild card sections. Such annotation component can further be associated with a mapping component that maps Lax wild cards to type systems. As such, nodes can be annotated for a path expression, when a parser traverses nodes of a tree.","According to a methodology of the subject innovation, initially a Lax wildcard section in a collection of XML schemas is mapped into the XQuery type system. Subsequently, elements and attributes that are Laxly validated can be annotated with additional wild card constraint information. As such, when an XQuery is received that queries using path expressions into a Lax validation section, the subject innovation can supply type information and type inference rules to infer new static type information. This preserves knowledge of what types can be encountered within a Lax validation section, to enable a more precise inference as compared to W3C rules.","To the accomplishment of the foregoing and related ends, certain illustrative aspects of the claimed subject matter are described herein in connection with the following description and the annexed drawings. These aspects are indicative of various ways in which the subject matter may be practiced, all of which are intended to be within the scope of the claimed subject matter. Other advantages and novel features may become apparent from the following detailed description when considered in conjunction with the drawings.","The various aspects of the subject invention are now described with reference to the annexed drawings, wherein like numerals refer to like or corresponding elements throughout. It should be understood, however, that the drawings and detailed description relating thereto are not intended to limit the claimed subject matter to the particular form disclosed. Rather, the intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the claimed subject matter.","In general, conventional and existing XQuery standard provides minimal rules for the type inferencing of queries that delve into lax validation sections. For example, such conventional approaches merely consider all lax elements and attributes to be of the most generic content type (xs:anyType for elements, xs:anySimpleType for attributes); and hence do not provide more exact information. As such, many perfectly legitimate queries typically fail static type checks, because the inferred type is too broad, and hence needs to be rejected. For example, assuming one has the following XML Schema components, where the element E has a lax validation xs:anyType content model and the element integer is of the xs:integer type:",{"@attributes":{"id":"p-0023","num":"0022"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<xs:schema"]},{"entry":[{},"\u2003\u2003xmlns:xs=\u201chttp:\/\/www.w3.org\/2001\/XMLSchema\u201d"]},{"entry":[{},"\u2003\u2003targetNamespace=\u201curn:laxdemo\u201d"]},{"entry":[{},"\u2003\u2003xmlns:x=\u201curn:laxdemo\u201d"]},{"entry":[{},"\u2003\u2003elementFormDefault=\u201cqualified\u201d>"]},{"entry":[{},"\u2002<xs:element name=\u201cE\u201d type=\u201cxs:anyType\u201d\/>"]},{"entry":[{},"\u2002<xs:element name=\u201cinteger\u201d type=\u201cxs:integer\u201d\/>"]},{"entry":[{},"<\/xs:schema>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Then, upon writing the following XQuery,\n\n","The subject innovation provides for an extension to the typing rules algorithms of the World Wide Web Consortium (W3C) rules, to create a more precise static typing algorithm that supplies knowledge for types occurring in the Lax validation section\u2014wherein such Lax validation can be identified, and associated expressions known with particularity. As illustrated in  the types  can be inferred for XQuery expressions based on the XML schemas that are associated with the in-scope schema definitions  (of W3C), to obtain a more precise type rule (as compared to current W3C algorithms.) Such facilitates checking compatibility of types at time when operations are to be performed, with expected types (e.g., a check for numeric types\u2014as opposed to any type\u2014for mathematical operation), wherein expressions can be compiled with knowledge for the types involved, and errors mitigated\/optimizations introduced.","To better appreciate novelties of the subject innovation the following discussion provides for two particular use case examples of what users deem important when employing Lax validation semantics.","I. Use Case 1: Querying XML Data Inside Element of Type xs:anyType","A SQL Server system employs an XML datatype that is constrained by an XML Schema collection (the SQL Server mechanism to define the inscope schema components) that contains a base XML Schema describing the generic properties and uses an element of type xs:anyType to allow users to either use some pre-defined markup in the schema or use its own. An information worker (e.g., \u201cIrene\u201d) authors XML documents that makes use of the lax semantics of the element's xs:anyType. In addition, a database developer, (e.g., \u201cDave\u201d) writes queries against the data in the xs:anyTyped element and desires such queries to exploit the schema type knowledge and obtain the type information of the pre-defined markup elements.","II. Use Case 2: Querying XML Data Inside a lax Validation Section","A SQL Server system employs an XML datatype that is constrained by an XML Schema collection that contains a base XML Schema describing the generic properties and uses a lax wildcard section that allows other XML Schemas in the XML Schema collection to define the types in the section or allows the use of unknown elements.","\u201cDave\u201d, the database developer writes an application that augments the base XML Schema with another schema that describes the application specific extensions in the lax wildcard section. \u201cDave\u201d can write queries against the data in the lax wildcard section and desires the queries to exploit the schema type knowledge and obtain a similar behavior and experience as if the data was typed strict for the data that he knows he has a schema. As described in detail infra, the subject innovation enables static typing rules for querying into laxly validated wildcards and xs:anyType sections that supersedes and augments current W3C algorithms.","In general, XML Schema provides two wildcard sections and the type xs:anyType that implies a laxly validated wildcard content model. The attribute wild card section can be defined as:",{"@attributes":{"id":"p-0031","num":"0032"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<anyAttribute"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"id = ID"]},{"entry":[{},"namespace = ((##any | ##other)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"| List of (anyURI | (##targetNamespace |"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"##local)) ) : ##any"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"processContents = (lax | skip | strict) : strict"]},{"entry":[{},"{any attributes with non-schema namespace ...} >"]},{"entry":[{},"Content: (annotation?)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/anyAttribute>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The element wildcard in the XML Schema Structures recommendation) can be defined as:",{"@attributes":{"id":"p-0033","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<any"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"id = ID"]},{"entry":[{},"maxOccurs = (nonNegativeInteger | unbounded) : 1"]},{"entry":[{},"minOccurs = nonNegativeInteger : 1"]},{"entry":[{},"namespace = ((##any | ##other)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"| List of (anyURI | (##targetNamespace |"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"##local)) ) : ##any"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"processContents = (lax | skip | strict) : strict"]},{"entry":[{},"{any attributes with non-schema namespace ...} >"]},{"entry":[{},"Content: (annotation?)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/any>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"(It is noted that the type xs:anyType corresponds to an <xs:any processContents=\u201clax\u201d\/>)","Typically, Lax validation of an element content wild card represents that given a sequence of elements $se that are inside a lax wildcard or the content of an element typed with xs:anyType, the following rules can be applied:","Assuming that the given XML Schema collection consists of the set of schema components (SC); and that the lax validation section is constrained with the namespace constraints (NS). For every element $e in $se one can check that:\n\n","Lax validation of an attribute content wildcard indicates that given a sequence of attributes $sa that are validated according to the lax wildcard, the following rules will be applied:","Assume that the given XML Schema collection consists of the set of schema components SC.","Assume that the lax validation section is constrained with the namespace constraints NS.","For every attribute $a in $sa check:\n\n","As a consequence of a successful lax validation, every element and global attribute are either guaranteed to be valid according to their global XML Schema constraint with the given name or are considered to be of an unknown, most general type (e.g, xs:anyType for elements and xs:anySimpleType for attributes).","In one aspect, the subject innovation can improve static typing rules that capture the semantics implied by the lax validation rules and the available schema components as constrained by the in-scope schema components and the namespace wildcards. As such, when a path expression with an explicit name test enters into a lax wildcard section, the subject innovation identifies whether the path selects an element or attribute that is known in the static schema context or it selects an element or attribute that is basically considered as any type. Moreover, since a global element or attribute declaration can trigger a validation and thus typing of an element at any level within the lax wildcard section sub tree, the type inference has to carry the information about the accessible global components down the tree. Once a known element or attribute is encountered or hit, that type can be used and the wildcard can be dropped if possible.","In order to resolve a name inside a lax validation section, one particular aspect of the subject innovation can employ namespace wildcard constraints as an additional filter against the statically known XML schema components to ensure absence of names that are disallowed while inferring the static type. According to a further particular aspect, the subject innovation can introduce a name subtraction to the wildcard element. For example:\n\n","It is to be appreciated that such approach can require special rules for the subtractions, and hence logically carry around a large amount of subtractions that are to be propagated since the schema-element can appear within the xs:anyType again.","In a related aspect, the annotation component of the subject innovation can annotate the element and attribute wildcards with an optional namespace constraint. Basically elements and attribute wildcards element(*, xs:anyType) and attribute(*, xs:anySimpleType) obtain an additional constraint that indicates the set of namespaces that are used to constrain the wildcard section. Subsequently, a mapping component can perform the mapping as in the first approach, yet employ the namespace constraint. Thus, the type of the example above can be:\n\n","NS for attributes and elements can be determined when mapping the schema components to the type system, as explained in detail infra. Such can be based upon following rules:","1. If the namespace wildcard constraint is ## any, a special indicator ##any is used to indicate that all the namespaces that belong to the static in-scope schema components may appear as well as any other namespace,","2. If ##other is specified, the set of all namespaces (##any) minus the target namespace that contains the content model,","3. the set of explicitly specified namespaces of the namespace wildcard constraint,","4. if ##targetNamespace is specified, the target namespace that contains the content model.","5. If the target namespace or the XML Schema collection contains the no namespace or ##local is specified, then the no namespace is identified with ##local in the set.","6. Note that 1 and 2 can be considered open-world namespace constraints, meaning that NS does contain an infinite number of namespace uris beyond the ones contained in the XML Schema collection, while c and d are closed-world and NS only contains namespace uris as explicitly given.","7. The intuition of evaluating step expressions now is that whenever the NS is present, it assumes the following:\n\n",{"@attributes":{"id":"p-0054","num":"0076"},"figref":["FIG. 2","FIG. 3"],"b":["210","310","320","210"]},"The following are the formal rules following the syntax used by the XQuery Formal Semantics that show mapping via the mapping  of the XML Schema component to the XQuery type system. It can be assumed that TGNS is the target namespace URI where the any section is being defined in (##local if it is the no namespace target namespace).","Mapping of the xs:any Wildcard","Typically, the xs:any wildcard can be mapped to the union of all top-level elements allowed by the namespace constraint and the catch all of the element wildcard constrained by the namespace constraint. As such:",{"@attributes":{"id":"p-0058","num":"0080"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"[ <any"},{"entry":"\u2003OccursAttributes"},{"entry":"\u2003\u2009namespace = NS"},{"entry":"\u2003\u2009processContents = \u201clax\u201d >"},{"entry":"\u2003annotation?"},{"entry":"\u2009<\/any>"},{"entry":"]"},{"entry":"=="},{"entry":"([NS]| element[for $n in NS return[$n]]"},{"entry":"(*, xs:anyType)"},{"entry":")[OccursAttributes]"},{"entry":"With the following definitions:"},{"entry":"[NS]== Union (for $ns in expand-NS(NS) return"},{"entry":"statEnvs.elemDecl($ns:*))"},{"entry":"statEnvs.elemDecl($ns:*) returns the list of element declarations for the"},{"entry":"given name wildcard from the static in-scope element declaration context."},{"entry":"And expand-NS( ) is defined as:"},{"entry":"expand-NS(NS)"},{"entry":"=="},{"entry":"\u2002for $n in NS"},{"entry":"\u2002return"},{"entry":"\u2003if $n = ##any then XSC"},{"entry":"\u2003else if $n == ##other then XSC\u2212{TGNS}"},{"entry":"\u2003else if $n == ##targetNamespace then TGNS"},{"entry":"\u2003else if $n == ##local then \u2018\u2019"},{"entry":"\u2003else (:if $n == anyURI then:) $n"},{"entry":"And:"},{"entry":"[##any]== ##any"},{"entry":"[##other]== ##any \u2212 TGNS"},{"entry":"[##targetNamespace]== TGNS"},{"entry":"[##local]== ##local"},{"entry":"[anyURI]== anyURI"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Mapping of an Element of Type xs:anyType","Conventional elements of type xs:anyType are typically mapped to normal elements of type xs:anyType. The subject innovation enables implementing standard semantics with lax validation, and the mapping component can map the element of type xs:anyType in the same way as an xs:any wildcard section, wherein the name of such element is known. Accordingly,",{"@attributes":{"id":"p-0061","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"["]},{"entry":[{},"\u2009<element"]},{"entry":[{},"\u2003OccursAttributes"]},{"entry":[{},"\u2003\u2009name = NCName"]},{"entry":[{},"\u2003\u2009NillableAttribute"]},{"entry":[{},"\u2003\u2009type = xs:anyType \/>"]},{"entry":[{},"]"]},{"entry":[{},"=="]},{"entry":[{},"( element [##any] (targetNCName:NCName, xs:anyType"]},{"entry":[{},"[NillableAttribute])"]},{"entry":[{},")[OccursAttributes]"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Mapping of the xs:anyAttributes Wildcard","The following are the formal rules following the syntax employed by the XQuery Formal Semantics that show the mapping of the XML Schema component to the XQuery type system. It can be assumed that TGNS is the target namespace URI where the anyAttribute section can be defined therein. It is to be appreciated that union of all the global attribute declarations allowed by the namespace constraint is added later during the expansion phase of the containing element.",{"@attributes":{"id":"p-0064","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"["},{"entry":"\u2002<anyAttributes"},{"entry":"\u2003namespace = NS"},{"entry":"\u2003processContents = \u201clax\u201d >"},{"entry":"\u2003\u2009annotation?"},{"entry":"\u2009<\/anyAttributes>"},{"entry":"]"},{"entry":"=="},{"entry":"attribute[for $n in NS return[$n]] (*, xs:anySimpleType)*"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0065","num":"0087"},"figref":"FIG. 4","b":["400","410"]},"Subsequently, and at  elements of attributes that are Laxly validated can be annotated with additional wild card constraint information. As such, when an XQuery is received that queries using path expressions into a Lax validation section, the subject innovation can supply type information and type inference rules to infer new static type information at . Such can further preserve knowledge of what types can be encountered within a Lax validation section, to enable a more precise inference as compared to W3C rules a .",{"@attributes":{"id":"p-0067","num":"0089"},"figref":"FIG. 5","b":["500","510","520","530","540"]},{"@attributes":{"id":"p-0068","num":"0090"},"figref":"FIG. 6","b":["600","600","620","630"]},"In one aspect, upon mapping wildcard sections to the type system, and finding an element or attribute marked with a name space wild card constraint, the type inference can be affected as described in detail below. Typically, most rules can propagate the type with the namespace wildcard constraint. Yet, rules for forward step expressions can exploit annotations to infer more precise types. In particular, the axes and filter steps can be adjusted for the cases where they operate on a namespace wildcard constrained element or attribute.","Self Axis","The self axis rule does not change. As such, element and attribute types with namespace wildcard constraints can be passed through unchanged.","Child Axis","In the case of an element type, the static type of the child axis can be obtained by static name or type lookup in the static element declaration context. (statEnvs.elemDecl) and expansion of the type reference to the resulting type (including the necessary adjustment), and the extraction of the types which are not attributes (e.g., the content type). Typically, extraction allows any comments and processing-instructions to be interleaved with the actual schema types. If the element type is marked with a namespace wildcard constraint, then one can assume that a lax validation section has been entered, wherein every step can be applied to every part of the union and that the inference is performed according to the general rules on all of the unmarked elements.","Changes to Static Type Lookup","Initially, one has to extend the static type lookup to ensure that the wildcard constraint is returned on global elements of type xs:anyType. For example, the In-scope schema definitions (ISSD) contains the following declarations (using XQuery SequenceType syntax):",{"@attributes":{"id":"p-0076","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"define element[{##any}]((e4, xs:anyType)"]},{"entry":[{},"define element(e5, eT5)"]},{"entry":[{},"define type eT5 {"]},{"entry":[{},"\u2003element (a, aT),"]},{"entry":[{},"\u2003element[{##local}](*, xs:anyType),"]},{"entry":[{},"\u2003element (b, bT)+,"]},{"entry":[{},"\u2003(element (c, cT) | element (d,dT)?)}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Then the static type lookup of element e4 can supply no Nillable indication and the type reference xs:anyType and the namespace wildcard constraint {##any}. On the other hand, the static type lookup of element e5 can supply no Nillable indication and the type reference eT5 and no namespace wildcard constraint.","Changes to Expansion Phase","Subsequently, it can be required to augment the Expansion phase rules. Basically, one needs to expand the attribute part of an element with an attribute having an attribute wildcard card constraint to include all the optional global attributes of the in-scope schema components of the given XML Schema collection subject to the namespace constraint plus the catch-all. Such can indicate additions to the all group of all specified attributes the all group. [NS] where NS is the namespace wildcard constraint on the anyAttributes section (the catch all is already there). Note that the BuiltInAttributes of the xsi namespace still get type checked according to their types.","Definition:",{"@attributes":{"id":"p-0081","num":"0103"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"[NS]== AllGroup ("]},{"entry":[{},"\u2003for $ns in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003, $t in statEnvs.attrDecl($ns:*)"]},{"entry":[{},"\u2003return $t?"]},{"entry":[{},")"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"And when one extends content part of an element with an element namespace wildcard constraint\u2014then one can include all global elements of the in-scope schema components of the given XML Schema collection subject to the namespace constraint plus the catch-all. The \u201ccatch all\u201d is ##any since the XML Schema validation rule does not typically provide for a restriction of the namespaces at deeper nesting levels. Accordingly, any of the any sections within the element will be mapped to the already familiar",{"@attributes":{"id":"p-0083","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"[ element [NS] (QName, xs:anyType NillableAttribute) )"},{"entry":"OccursAttributes]"},{"entry":"=="},{"entry":"([NS]| element[##any] (*, xs:anyType NillableAttribute)"},{"entry":")OccursAttributes"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"It is to be appreciated that in alternative approach mapping can also be performed from NS to ##any for deeper levels as part of the name filters.","Changes to Child Axis Filter","The rule variable NS denotes the namespace wildcard constraint. The semantics of the rule about \u201cchild axis filter on elements with simple content type\u201d of the XQuery Formal Semantics recommendation remains unaffected by the lookup and extension phase changes.","In case of an element type with complex content type, the static type of child axis is obtained by static type lookup and expansion of the type, then the extraction of the content type. It is assumed that in case of expansion of the complex content type, one obtains all the comments and processing-instructions added to the element and text node content models.","Rule EXP-C1 \u201cchild axis filter on elements with complex and empty content type\u201d:",{"@attributes":{"id":"p-0089","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","static type lookup of ElementType gives optional NS, optional"]},{"entry":[{},"Nillable and TypeReference"]},{"entry":[{},"and optional NS, optional Nillable and TypeReference expands to"]},{"entry":[{},"(AttributeType, ChildType)"]},{"entry":[{},"and ChildType <: node*"]},{"entry":["Then:","\u2003applying the filter child:: on ElementType yields type ChildType"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"If the element's type allows mixed content, a Child Type is obtained that is a union of either xdt:anyAtomicType* and the original type expanded with text nodes and PIs and comments. Thus, neither of previous rules can apply and the following third rule can be introduced:","Rule EXP-C2 \u201cchild axis filter on elements with mixed content type\u201d:",{"@attributes":{"id":"p-0092","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","static type lookup of ElementType gives optional NS, optional"]},{"entry":[{},"Nillable and TypeReference"]},{"entry":[{},"and optional NS, optional Nillable and TypeReference expands to"]},{"entry":[{},"(AttributeType, ChildType)"]},{"entry":[{},"and not(ChildType <: node*) and not(ChildType"]},{"entry":[{},"<: xdt:anyAtomicType*)"]},{"entry":[{},"and ChildType = ComplexType | xdt:anyAtomicType*"]},{"entry":["Then:","\u2002applying the filter child:: on ElementType yields type"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"ComplexType | ((comment? & processing-instruction?)*, text?)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Finally, if the element's type allows either simple or complex content type via xs:anyType, it is required to expand the original type with the namespace wildcard constraints and with text nodes (e.g., the type inferred by the child axis filter can be (pi? & comment? & element of type xs:anyType? & text?)*). Hence typically, the previous rules do not apply and the following rule can be introduced:","Rule EXP-C3 \u201cchild axis filter on elements with any-typed content type\u201d:",{"@attributes":{"id":"p-0095","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","static type lookup of ElementType gives optional NS, optional"]},{"entry":[{},"Nillable and TypeReference"]},{"entry":[{},"and optional NS, optional Nillable and TypeReference expands to"]},{"entry":[{},"(AttributeType, ChildType)"]},{"entry":[{},"and TypeReference = xs:anyType"]},{"entry":["Then:","\u2002applying the filter child:: on ElementType yields type"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(comment? & processing-instruction? & ChildType? & text?)*"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"It is noted that the ChildType already contains expansions with comments and processing-instructions and in all three cases includes the expansions due to the namespace wildcard constraint. All the other child axis filter rules stay the same.","Attribute Axis","In case of an element type, the static type of the attribute axis is obtained by static type lookup and expansion of the resulting type and extractions of the attribute types. Rule EXP-A1 \u201cattribute axis filter on elements\u201d:",{"@attributes":{"id":"p-0099","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","static type lookup of ElementType gives optional NS, optional"]},{"entry":[{},"Nillable and TypeReference"]},{"entry":[{},"and optional NS, optional Nillable and TypeReference expands to"]},{"entry":[{},"(AttributeType, ChildType)"]},{"entry":["Then:","\u2002applying the filter attribute:: on ElementType yields type"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"AttributeType"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Again expansion can expand the AttributeType with the top-level attribute types allowed by the attribute wildcard section if the element type contains an attribute namespace wildcard. All the other attribute axis filter rules can remain the same.","Parent Axis","Since such improvement does not typically improve the static inference for parent axis, the rules do not change in general. Note that the element of type xs:anyType is not typically constrained by a namespace wildcard section. Therefore, all the parent axis inference rules can remain the same.","Descendant Axis","The descendant axis is a depth-first application of the child axis on all the descendant nodes until all leaf nodes have been reached. Inferring a precise static type is complex in the non-recursive case (we would need to make sure that the structure of the inferred type expression is correctly reflecting the structure of the depth-first traversal of the descendants) and impossible in the case of a recursive schema (we would get an endless recursive type). Therefore the type inference infers the prime( )*occ( ) of all the types that we can find going down the child descendants (including text, pi and comments as provided by the child axes). Recursions don't have to be followed, since the prime type factorization already has all the types that we could detect by following the recursion.","Since the descendant axis can not readily indicate whether the final step is selecting a global or local element inside a namespace wildcard section, a union of both can be inferred. Also, a descendant axis can encounter a variety of elements with different namespace wildcard constraints. Nonetheless, since any descendant axes delves into deeper nesting levels of a wildcard section, one can preserve one element wildcard section of the form element[##any] (*, xs:anyType NillableAttribute)) as part of the prime( ) type.","For example:",{"@attributes":{"id":"p-0107","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Type:"},{"entry":"define element(b, bT)"},{"entry":"define type bT {"},{"entry":"\u2002element(e, xs:int)*"},{"entry":"}"},{"entry":"define element(e, eT)"},{"entry":"define type eT {"},{"entry":"\u2002element(a, xs:string),"},{"entry":"\u2002element[{##local}](*, xs:anyType)?"},{"entry":"}\u2003Instance documents ($dx points to document node containing"},{"entry":"XML document):"},{"entry":"$d1:"},{"entry":"<e><a>L1<\/a><e><a>L11<\/a><e><a>L111<\/a><\/e><\/e><\/e>"},{"entry":"$d2:"},{"entry":"<e><a>L1<\/a><e><a>L11<\/a><e><a>L111<\/a><b><e>42<\/e><\/e><\/e>"},{"entry":"<\/e>"},{"entry":"$d1\/descendant::e will infer: (element(e, eT) | element(e, xs:int))*"},{"entry":"Since the element[{##local}](*,xs:anyType) cannot contain another"},{"entry":"element e of the same namespace."},{"entry":"$d1\/descendant::*:e will infer the same."},{"entry":"If the type eT looks like:"},{"entry":"define type eT {"},{"entry":"\u2002element(a, xs:string),"},{"entry":"\u2002element[{##any}](*, xs:anyType)?"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"$d1\/descendant::e will still infer: (element(e, eT)|element(e, xs:int))*Even if one of the other schemas would contain a local unqualified element name, that name would be added to the inference, but the catch all would not be needed. $d1\/descendant::*:e will infer: element(e, eT)|element(e, xs:int)|element[{##any}](*:e, xs:anyType))* since there can be elements from other namespaces with local name e. As explained earlier, the subject innovation enables annotation of the element (*, xs:anyType)? with additional information about the wild card section.","Descendant-or-Self-Axis","Such rule does not change.","Changes to Node Test Filters","Upon extending the wildcard section, all the added element and attribute types can be addressed by the normal filter rules. However, a special filter can be applied when one encounters a namespace wildcard constrained element or attribute type. Typically, the Rules below follow a syntax of the conventional static typing specification. The sequence type notation that is used above of the form:","element[NS](ElementName, TypeReference Nillable? Type reference, where nillable? maps to the form.","element ElementName NS Nillable? TypeReference that is used below.","Principle Node Kind Element","The first rule merely checks if the element type actually has the name of the filter and if so, returns the element. If the name of the element can be matched even if the namespace wildcard constraint is present, the result of the filter can match the element type; e.g., if the element type is element[{##any}](foo, bar) and the filter is (element, foo)\u2014then the element type can be inferred. Note that one can obtain such element type by either an explicit declaration of the element foo to be of type xs:anyType; or by inferring it as part of a query into a laxly validated content model. Thus, in general one needs to expand the rule slightly to match on elements with the namespace wildcard:\n\n",{"@attributes":{"id":"p-0117","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","ElementType is of the form element ElementName NS? Nillable?"]},{"entry":[{},"TypeReference"]},{"entry":[{},"and expand(QName) = expand(ElementName)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (element, QName) on ElementType yields type"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ElementType"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"It is to be appreciated that every time a namespace constraint NS is part of the element type, the type reference can be xs:anyType, and Nillable is true for this and all subsequent rules on name filters on element nodes. The next rule checks if the element type has no name (since the element may have been created with a dynamic name, or there existed an untyped document or a type inference lost the name). If no name existed, then either an element with that name exists with the type of the element, or it does not exist. If a namespace constraint is present, then the constraint is to be checked. In general, if any of the namespaces allowed by the constraint are defined in the in-scope-schema components\u2014as defined by the XML Schema collection associated with the document defining an element of the given name\u2014then, this filter has been satisfied more precisely elsewhere and thus this rule can infer empty. In all other cases, (where the namespace matches but the name does not, or neither is matching but the namespace is allowed), the type gets exposed with the name added and carrying on the namespace constraint.","Rule FIL-E2 \u201c(element, QName) filter on element node without name and namespace constraint\u201d:",{"@attributes":{"id":"p-0120","num":"0143"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","ElementType is of the form element \u2002NS \u2002Nillable? TypeReference"]},{"entry":[{},"and expand(QName) = QName(URI, NCName1)"]},{"entry":[{},"and not(statEnvs.elemDecl(expand(QName)))"]},{"entry":[{},"and ( URI in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003or NS = ##any"]},{"entry":[{},"\u2003\u2003or NS = ##other and URI \u2002!= TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then: applying the filter (element, \u2002QName) on ElementType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type (element \u2002QName \u2002NS Nillable TypeReference)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Several rules below perform the checks above for the case where one does not have a QName as filter but a QName wildcard. Rule FIL-E3 \u201c(element, QName) filter on element node with name *:NCName and namespace constraint\u201d:",{"@attributes":{"id":"p-0122","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","ElementType is of the form element \u2002* : NCName \u2002NS Nillable"]},{"entry":[{},"TypeReference"]},{"entry":[{},"and expand(QName) = QName(URI, NCName1)"]},{"entry":[{},"and NCName = NCName1"]},{"entry":[{},"and not(statEnvs.elemDecl(expand(QName)))"]},{"entry":[{},"and ( URI in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003or NS = ##any"]},{"entry":[{},"\u2003\u2003or NS = ##other and URI \u2002!= TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (element, \u2002QName) on ElementType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type element \u2002QName \u2002NS Nillable TypeReference"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-E4 \u201c(element, QName) filter on element node with name NCName:* and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0124","num":"0147"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","ElementType is of the form element \u2002NCName : * \u2002NS Nillable"]},{"entry":[{},"TypeReference"]},{"entry":[{},"and expand(QName) = QName(URI, NCName1)"]},{"entry":[{},"and statEnv.namespace(NCName) = URI"]},{"entry":[{},"and not(statEnvs.elemDecl(expand(QName)))"]},{"entry":[{},"and ( URI in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003or NS = ##any"]},{"entry":[{},"\u2003\u2003or NS = ##other and URI \u2002!= TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (element, \u2002QName) on ElementType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type element \u2002QName \u2002NS Nillable TypeReference"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The following rules perform the checks above for the case where one does not have a QName as filter but a QName wildcard. Initially, one can check for the *:NCName case. If the element with the wildcard constraint has a given name, then it can be permitted with the given name and propagate the wildcard constraint","Rule FIL-E5 \u201c(element, *:NCName) filter on element node with name and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0127","num":"0150"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"If:","ElementType is of the form element ElementName NS Nillable"]},{"entry":[{},{},"TypeReference"]},{"entry":[{},{},"and expand(ElementName) = QName(URI, NCName1)"]},{"entry":[{},{},"and NCName = NCName1"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Then:applying the filter (element, \u2002*:NCName) on ElementType"]},{"entry":[{},"yields type"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"ElementType"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"If a namespace wildcard constraint is encountered, one can return either *:NCName for the given name if the namespace wildcard is open (##any, ##other), or a wildcard for everyone of the explicitly allowed namespace URIs with the given name assuming that that name has not been found. The union can then collapse it into a single element[{##all}](*:NCName, xsanyType)?. Note that one can infer a more complex union of all names from the namespaces allowed that have not a more precise definition.","Rule FIL-E6 \u201c(element, *:NCName) filter on element node without name and open namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0130","num":"0153"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","ElementType is of the form element NS Nillable TypeReference"]},{"entry":[{},"and (NS = ##any or NS = ##other)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (element, \u2002*:NCName) on ElementType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type (element \u2002*:NCName \u2002NS Nillable TypeReference)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-E7 \u201c(element, *:NCName) filter on element node without name and closed namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0132","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","ElementType is of the form element \u2002NS Nillable TypeReference"]},{"entry":[{},"and not(NS = ##any or NS = ##other)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (element, \u2002*:NCName) on ElementType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type UNION(for each $ns in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2002where not(statEnvs.elemDecl(expand($ns:NCName)))"]},{"entry":[{},"\u2003\u2003\u2003\u2003return element \u2002*:NCName \u2002NS Nillable TypeReference)?)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-E8 \u201c(element, *:NCName) filter on element node with name *:NCName and open namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0134","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","ElementType is of the form element \u2002* : NCName1 NS Nillable"]},{"entry":[{},"TypeReference"]},{"entry":[{},"and NCName = NCName1"]},{"entry":[{},"and (NS = ##any or NS = ##other)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Then:applying the filter (element, \u2002*:NCName) on ElementType yields"},{"entry":"type"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ElementType"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-E9 \u201c(element, *:NCName) filter on element node with name *:NCName and closed namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0136","num":"0159"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","ElementType is of the form element \u2002* : NCName1 NS Nillable"]},{"entry":[{},"TypeReference"]},{"entry":[{},"and NCName = NCName1"]},{"entry":[{},"and not(NS = ##any or NS = ##other)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Then:applying the filter (element, \u2002*:NCName) on ElementType yields"},{"entry":"type"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"UNION(for each $ns in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2002where not(statEnvs.elemDecl(expand($ns:NCName)))"]},{"entry":[{},"\u2003\u2003\u2003\u2003Return element \u2002*:NCName \u2002NS Nillable TypeReference)?)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The following rule manages a name test filter where the name is given and all namespaces can be employed against an element node with a namespace wildcard constraint that has the namespace uri preserved but no name. The namespace uri on that element is in the allowed set of namespaces of the namespace wildcard constraint, since otherwise validation would have rejected the element.","Moreover, to ensure that the local name has not been covered by one of the globally declared elements; the following rule can further be added: Rule FIL-E10 \u201c(element, *:NCName) filter on element node with name NCName:* and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0139","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","ElementType is of the form element NCName1 : * NS Nillable"]},{"entry":[{},"TypeReference"]},{"entry":[{},"and not(statEnvs.elemDecl(expand(NCName1:NCName)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (element, \u2002*:NCName) on ElementType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type (element \u2002NCName1:NCName \u2002NS Nillable TypeReference)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The next additional rules check for the NCName:* case where the element has a namespace wildcard. As explained earlier, if the element node name has already a name space, one can assume that it is part of the allowed namespace constraint due to the validation guarantee that no other namespace is allowed. Likewise, when there is no name, it can be ensured that the namespace is allowed.","Rule FIL-E11 \u201c(element, NCName:*) filter on element node with name and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0142","num":"0165"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","ElementType is of the form element ElementName NS Nillable"]},{"entry":[{},"TypeReference"]},{"entry":[{},"and expand(ElementName) = QName(URI, NCName1)"]},{"entry":[{},"and statEnv.namespace(NCName) = URI"]},{"entry":[{},"and not(statEnvs.elemDecl(expand(ElementName)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Then:applying the filter (element, \u2002NCName:*) on ElementType yields"},{"entry":"type"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ElementType"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-E12 \u201c(element, NCName:*) filter on element node without name and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0144","num":"0167"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","ElementType is of the form element \u2002NS Nillable TypeReference"]},{"entry":[{},"and (statEnv.namespace(NCName) in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003or NS = ##any"]},{"entry":[{},"\u2003\u2003or NS = ##other and statEnv.namespace(NCName) != TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (element, \u2002NCName:*) on ElementType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type (element \u2002NCName:* \u2002NS Nillable TypeReference)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-E13 \u201c(element, NCName:*) filter on element node with name *:NCName and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0146","num":"0169"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","ElementType is of the form element \u2002* : NCName1 NS Nillable"]},{"entry":[{},"TypeReference"]},{"entry":[{},"and not(statEnvs.elemDecl(expand(NCName:NCName1)))"]},{"entry":[{},"and (statEnv.namespace(NCName) in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003or NS = ##any"]},{"entry":[{},"\u2003\u2003or NS = ##other and statEnv.namespace(NCName) != TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (element, \u2002NCName:*) on ElementType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type (element \u2002NCName:NCName1 \u2002NS Nillable TypeReference)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-E14 \u201c(element, NCName:*) filter on element node with name NCName:* and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0148","num":"0171"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","ElementType is of the form element NCName1 : * NS Nillable"]},{"entry":[{},"TypeReference"]},{"entry":[{},"and statEnv.namespace(NCName) = statEnv.namespace(NCName1)"]},{"entry":[{},"and (statEnv.namespace(NCName) in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003or NS = ##any"]},{"entry":[{},"\u2003\u2003or NS = ##other and statEnv.namespace(NCName) != TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Then:applying the filter (element, \u2002NCName:*) on ElementType yields"},{"entry":"type"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ElementType"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In case of the general wildcard, one can preserve the type regardless of whether the element type had a name or not and propagate the namespace wildcard constraint if present. Thus the existing rule can be maintained. Hence, Rule \u201c(element,*) filter on element node\u201d. Similarly, other rules on other node types do not change either.","Principle Node Kind Attribute","Substantially similar rules apply if the principle node kind is \u201cattribute\u201d. However, since the attribute namespace wildcard constraint is not being propagated down, one typically does not require to preserve it in its inference. As explained earlier, again it can be assumed that matching any globally known attribute has been added in the expansion phase and is otherwise checked. Accordingly, they can be excluded as described below. It is to be appreciated that the TypeReference can typically refer to xs:anySimpleType with namespace constraints.","Accordingly, the first rule just can check if the attribute type actually has the name of the filter and if so, returns the attribute type under an assumption that the globally known attributes are checked elsewhere.","Rule FIL-A1 \u201c(attribute, QName) filter on attribute node with name and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0154","num":"0177"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the from attribute AttributeName NS"]},{"entry":[{},"TypeReference "]},{"entry":[{},"and expand(QName) = expand(AttributeName) = QName(URI, Name) "]},{"entry":[{},"and not(statEnvs.attrDecl(expand(QName)))"]},{"entry":[{},"and (URI in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003or NS = ##any"]},{"entry":[{},"\u2003\u2003or NS = ##other and URI != TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, \u2002QName) on AttributeType yields type"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"attribute AttributeName TypeReference"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The next rule can check if the attribute type has no name. If there existed no name, then either an attribute with that name exists with the type of the attribute, or it does not exist. Again one can infer empty if the namespace of the filter is not allowed by the namespace wildcard constraint or already exists globally.","Rule FIL-A2 \u201c(attribute, QName) filter on attribute node without name and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0157","num":"0180"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"If:","AttributeType is of the form attribute NS TypeReference"]},{"entry":[{},{},"and expand(QName) = QName(URI, Name)"]},{"entry":[{},{},"and not(statEnvs.attrDecl(expand(QName)))"]},{"entry":[{},{},"and (URI in expand-NS(NS)"]},{"entry":[{},{},"\u2003\u2003or NS = ##any"]},{"entry":[{},{},"\u2003\u2003or NS = ##other and URI != TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Then:applying the filter (attribute, \u2002QName) on AttributeType yields"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"type (attribute \u2002QName \u2002TypeReference)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Moreover, later rules below perform the checks above for the case where one does not have a QName on the node but a QName wildcard. Since they infer wildcards, one has to add rules for filtering on an attribute type that contains such wildcards and have to take the namespace wildcard constraints into account. As in the element case, if one can infer a complete name, one will have to apply such rules only if the name does not match a globally declared attribute and one does not have to check for the namespace to be allowed by the namespace wildcard constraint.","Rule FIL-A3 \u201c(attribute, QName) filter on attribute node with name *:NCName and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0160","num":"0183"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the form attribute * : NCName NS TypeReference"]},{"entry":[{},"and expand(QName) = QName(URI, NCName1)"]},{"entry":[{},"and NCName = NCName1"]},{"entry":[{},"and not(statEnvs.attrDecl(expand(QName)))"]},{"entry":[{},"and (URI in expand-NS(NS)"]},{"entry":[{},"\u2003or NS = ##any"]},{"entry":[{},"\u2003or NS = ##other and URI != TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, QName) on AttributeType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type attribute QName TypeReference"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-A4 \u201c(attribute, QName) filter on attribute node with name NCName:* and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0162","num":"0185"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the form attribute NCName : * NS TypeReference"]},{"entry":[{},"and expand(QName) = QName(URI, NCName1)"]},{"entry":[{},"and statEnv.namespace(NCName) = URI"]},{"entry":[{},"and not(statEnvs.attrDecl(expand(QName)))"]},{"entry":[{},"and (URI in expand-NS(NS)"]},{"entry":[{},"\u2003or NS = ##any"]},{"entry":[{},"\u2003or NS = ##other and URI != TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, QName) on AttributeType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type attribute QName TypeReference"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In addition, the following rules perform checks above for the case wherein one does not have a QName as filter but a QName wildcard. Since wild cards are inferred wildcards, one can add rules for filtering on an attribute type that contains such wildcard; and has to take the namespace wildcard constraints into account. As in the element case, if one can infer a complete name, one can further apply such rules only if the name does not match a globally declared attribute; and one has to check for the namespace to be allowed by the namespace wildcard constraint. First one can check for the *:NCName case.","Rule FIL-A5 \u201c(attribute, *:NCName) filter on attribute node with name and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0165","num":"0188"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"If:","AttributeType is of the form attribute AttributeName"]},{"entry":[{},{},"NS TypeReference "]},{"entry":[{},{},"and expand(AttributeName) = QName(URI, NCName1)"]},{"entry":[{},{},"and NCName = NCName1"]},{"entry":[{},{},"and not(statEnvs.attrDecl(expand(AttributeName)))"]},{"entry":[{},{},"and (URI in expand-NS(NS)"]},{"entry":[{},{},"\u2003or NS = ##any"]},{"entry":[{},{},"\u2003or NS = ##other and URI != TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Then:applying the filter (attribute, *:NCName) on AttributeType"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"yields type attribute AttributeName TypeReference"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"If the attribute node to be checked has no name given or has a wildcard for its attribute name, one can infer a wildcard of xs:anyType in the case that the namespace wildcard constraint is closed. Otherwise, one can infer the wildcard\u2014wherein one can infer an all group for all the known namespaces in the closed case for the attributes for which no global definition exists.","Rule FIL-A6 \u201c(attribute, *:NCName) filter on attribute node without name and closed namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0168","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the form attribute NS TypeReference"]},{"entry":[{},"and not(NS = ##any or NS = ##other)"]},{"entry":[{},"and some $ns in expand-NS(NS) satisfies"]},{"entry":[{},"not(statEnvs.attrDecl(expand($ns:NCName)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, *:NCName) on AttributeType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type (attribute *:NCName TypeReference)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"It is to be appreciated that such rule can be written as FIL-A6alt if one desires to preserve the all group of all the names.","Rule FIL-A6alt \u201c(attribute, *:NCName) filter on attribute node without name and closed namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0171","num":"0194"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the form attribute NS TypeReference"]},{"entry":[{},"and not(NS = ##any or NS = ##other)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, *:NCName) on AttributeType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type ALLGROUP(for each $ns in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003where not(statEnvs.attrDecl(expand($ns:NCName)))"]},{"entry":[{},"\u2003\u2003return (attribute $ns:NCName TypeReference)?)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-A7 \u201c(attribute, *:NCName) filter on attribute node without name and open namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0173","num":"0196"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the form attribute NS TypeReference"]},{"entry":[{},"and (NS = ##any or NS = ##other)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, *:NCName) on AttributeType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type (attribute *:NCName TypeReference)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-A8 \u201c(attribute, *:NCName) filter on attribute node with name *:NCName and closed namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0175","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the form attribute * : NCName1 NS"]},{"entry":[{},"TypeReference "]},{"entry":[{},"and NCName = NCName1"]},{"entry":[{},"and not(NS = ##any or NS = ##other)"]},{"entry":[{},"and some $ns in expand-NS(NS) satisfies"]},{"entry":[{},"not(statEnvs.attrDecl(expand($ns:NCName)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, *:NCName) on AttributeType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type (attribute *:NCName TypeReference)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"It is to be appreciated that such rule can be written as FIL-A8alt if one desires to preserve the all group of all the names:","Rule FIL-A8alt \u201c(attribute, *:NCName) filter on attribute node with name *:NCName and closed namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0178","num":"0201"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the form attribute * : NCName1 NS"]},{"entry":[{},"TypeReference "]},{"entry":[{},"\u2009and NCName = NCName1"]},{"entry":[{},"and not(NS = ##any or NS = ##other)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, *:NCName) on AttributeType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type ALLGROUP(for each $ns in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003\u2003where not(statEnvs.attrDecl(expand($ns:NCName)))"]},{"entry":[{},"\u2003\u2003\u2002return (attribute $ns:NCName TypeReference)?)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-A9 \u201c(attribute, *:NCName) filter on attribute node with name *:NCName and open namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0180","num":"0203"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the form attribute * : NCName1 NS"]},{"entry":[{},"TypeReference "]},{"entry":[{},"\u2009and NCName = NCName1"]},{"entry":[{},"and (NS = ##any or NS = ##other)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, *:NCName) on AttributeType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type (attribute *:NCName TypeReference)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Likewise, the following rule(s) can preserves prefix from the input and adds the name from the filter. As in the element case, one already has inferred a more precise type if the name exists as a global declaration.","Rule FIL-A10 \u201c(attribute, *:NCName) filter on attribute node with name NCName:* and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0183","num":"0206"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the form attribute NCName1 : * TypeReference"]},{"entry":[{},"and not(statEnvs.attrDecl(expand(NCName:NCName1)))"]},{"entry":[{},"and (statEnv.namespace(NCName) in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003or NS = ##any"]},{"entry":[{},"\u2003\u2003or NS = ##other and statEnv.namespace(NCName) != TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, *:NCName) on AttributeType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type (attribute NCName1:NCName TypeReference)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Subsequently, one can heck for the NCName:* case. Again in this case, if the attribute node name has already a name space, it can be assumed that it is part of the allowed namespace constraint due to the validation guarantee that no other namespace is allowed. Moreover, no name exists, and one has ensure that the namespace is allowed.","Rule FIL-A11 \u201c(attribute, NCName:*) filter on attribute node with name and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0186","num":"0209"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the form attribute AttributeName NS"]},{"entry":[{},"TypeReference "]},{"entry":[{},"and expand(AttributeName) = QName(URI, NCName1)"]},{"entry":[{},"and statEnv.namespace(NCName) = URI"]},{"entry":[{},"and not(statEnvs.attrDecl(expand(AttributeName)))"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, NCName:*) on AttributeType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type attribute AttributeName TypeReference"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-A12 \u201c(attribute, NCName:*) filter on attribute node without name and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0188","num":"0211"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the form attribute NS TypeReference"]},{"entry":[{},"and (statEnv.namespace(NCName) in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003or NS = ##any"]},{"entry":[{},"\u2003\u2003or NS = ##other and statEnv.namespace(NCName) != TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, NCName:*) on AttributeType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type (attribute NCName:* TypeReference)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-A13 \u201c(attribute, NCName:*) filter on attribute node with name *:NCName and namespace wildcard constraint\u201d:",{"@attributes":{"id":"p-0190","num":"0213"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the form attribute * : NCName1 NS"]},{"entry":[{},"TypeReference "]},{"entry":[{},"and not(statEnvs.attrDecl(expand(NCName:NCName1)))"]},{"entry":[{},"and (statEnv.namespace(NCName) in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003or NS = ##any"]},{"entry":[{},"\u2003\u2003or NS = ##other and statEnv.namespace(NCName) != TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, NCName:*) on AttributeType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type (attribute NCName:NCName1 TypeReference)?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Rule FIL-A14 \u201c(attribute, NCName:*) filter on attribute node with name NCName:*\u201d:",{"@attributes":{"id":"p-0192","num":"0215"},"tables":{"@attributes":{"id":"TABLE-US-00044","num":"00044"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If:","AttributeType is of the form attribute NCName1 : * NS"]},{"entry":[{},"TypeReference "]},{"entry":[{},"and statEnv.namespace(NCName) = statEnv.namespace(NCName1)"]},{"entry":[{},"and (statEnv.namespace(NCName) in expand-NS(NS)"]},{"entry":[{},"\u2003\u2003or NS = ##any"]},{"entry":[{},"\u2003\u2003or NS = ##other and statEnv.namespace(NCName) != TGNS)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Then:applying the filter (attribute, NCName:*) on AttributeType yields"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type attribute NCName:* TypeReference"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Moreover, in case of the general wildcard, one preserve the type and do not care about whether the attribute type had a name or not. However, one can still drop the NS constraint and thus change the rule of the original static typing specification as follows:","Rule FIL-A15 \u201c(attribute,*) filter on attribute node\u201d:",{"@attributes":{"id":"p-0195","num":"0218"},"tables":{"@attributes":{"id":"TABLE-US-00045","num":"00045"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"If:","AttributeType is of the form attribute AttributeName? NS?"]},{"entry":[{},{},"TypeReference?"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Then:applying the filter (attribute, *) on AttributeType yields"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type attribute AttributeName? TypeReference?"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0196","num":"0219"},"figref":"FIG. 7","b":"700"},{"@attributes":{"id":"p-0197","num":"0220"},"figref":"FIG. 8","b":["800","800","810","814","820","830","840","850","860","870","880","810"]},"The compiler  can accept as input a file having source code associated with processing of a sequence of elements. The source code may include various expressions and associated functions, methods and\/or other programmatic constructs. The compiler  can process source code in conjunction with one or more components for analyzing constructs and generating or injecting code.","A front-end component  reads and performs lexical analysis upon the source code. In essence, the front-end component  reads and translates a sequence of characters (e.g., alphanumeric) in the source code into syntactic elements or tokens, indicating constants, identifiers, operator symbols, keywords, and punctuation among other things.","The converter component  parses the tokens into an intermediate representation. For instance, the converter component  can check syntax and group tokens into expressions or other syntactic structures, which in turn coalesce into statement trees. Conceptually, these trees form a parse tree . Furthermore and as appropriate, the converter module  can place entries into a symbol table  that lists symbol names and type information used in the source code along with related characteristics.","A state  can be employed to track the progress of the compiler  in processing the received or retrieved source code and forming the parse tree . For example, different state values indicate that the compiler  is at the start of a class definition or functions, has just declared a class member, or has completed an expression. As the compiler progresses, it continually updates the state . The compiler  may partially or fully expose the state  to an outside entity, which can then provide input to the compiler .","Based upon constructs or other signals in the source code (or if the opportunity is otherwise recognized), the converter component  or another component can inject code corresponding to facilitate efficient and proper execution. Rules coded into the converter component  or other component indicates what must be done to implement the desired functionality and identify locations where the code is to be injected or where other operations are to be carried out. Injected code typically includes added statements, metadata, or other elements at one or more locations, but this term can also include changing, deleting, or otherwise modifying existing source code. Injected code can be stored as one or more templates or in some other form. In addition, it should be appreciated that symbol table manipulations and parse tree transformations can take place.","Based on the symbol table  and the parse tree , a back-end component  can translate the intermediate representation into output code. The back-end component  converts the intermediate representation into instructions executable in or by a target processor, into memory allocations for variables, and so forth. The output code can be executable by a real processor, but output code that is executable by a virtual processor can also be provided.","Furthermore, the front-end component  and the back end component  can perform additional functions, such as code optimization, and can perform the described operations as a single phase or in multiple phases. Various other aspects of the components of compiler  are conventional in nature and can be substituted with components performing equivalent functions. Additionally, at various stages during processing of the source code, an error checker component  can check for errors such as errors in lexical structure, syntax errors, and even semantic errors. Upon detection error, checker component  can halt compilation and generate a message indicative of the error.","As used in herein, the terms \u201ccomponent,\u201d \u201csystem\u201d and the like are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software or software in execution. For example, a component can be, but is not limited to being, a process running on a processor, a processor, an object, an instance, an executable, a thread of execution, a program and\/or a computer. By way of illustration, both an application running on a computer and the computer can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers.","The word \u201cexemplary\u201d is used herein to mean serving as an example, instance or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as preferred or advantageous over other aspects or designs. Similarly, examples are provided herein solely for purposes of clarity and understanding and are not meant to limit the subject innovation or portion thereof in any manner. It is to be appreciated that a myriad of additional or alternate examples could have been presented, but have been omitted for purposes of brevity.","Furthermore, all or portions of the subject innovation can be implemented as a system, method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware or any combination thereof to control a computer to implement the disclosed innovation. For example, computer readable media can include but are not limited to magnetic storage devices (e.g., hard disk, floppy disk, magnetic strips . . . ), optical disks (e.g., compact disk (CD), digital versatile disk (DVD) . . . ), smart cards, and flash memory devices (e.g., card, stick, key drive . . . ). Additionally it should be appreciated that a carrier wave can be employed to carry computer-readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network (LAN). Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.","In order to provide a context for the various aspects of the disclosed subject matter,  as well as the following discussion are intended to provide a brief, general description of a suitable environment in which the various aspects of the disclosed subject matter may be implemented. While the subject matter has been described above in the general context of computer-executable instructions of a computer program that runs on a computer and\/or computers, those skilled in the art will recognize that the innovation also may be implemented in combination with other program modules. Generally, program modules include routines, programs, components, data structures, and the like, which perform particular tasks and\/or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the innovative methods can be practiced with other computer system configurations, including single-processor or multiprocessor computer systems, mini-computing devices, mainframe computers, as well as personal computers, hand-held computing devices (e.g., personal digital assistant (PDA), phone, watch . . . ), microprocessor-based or programmable consumer or industrial electronics, and the like. The illustrated aspects may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. However, some, if not all aspects of the innovation can be practiced on stand-alone computers. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","With reference to , an exemplary environment  for implementing various aspects of the subject innovation is described that includes a computer . The computer  includes a processing unit , a system memory , and a system bus . The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .","The system bus  can be any of several types of bus structure(s) including the memory bus or memory controller, a peripheral bus or external bus, and\/or a local bus using any variety of available bus architectures including, but not limited to, 11-bit bus, Industrial Standard Architecture (ISA), Micro-Channel Architecture (MSA), Extended ISA (EISA), Intelligent Drive Electronics (IDE), VESA Local Bus (VLB), Peripheral Component Interconnect (PCI), Universal Serial Bus (USB), Advanced Graphics Port (AGP), Personal Computer Memory Card International Association bus (PCMCIA), and Small Computer Systems Interface (SCSI).","The system memory  includes volatile memory  and nonvolatile memory . The basic input\/output system (BIOS), containing the basic routines to transfer information between elements within the computer , such as during start-up, is stored in nonvolatile memory . By way of illustration, and not limitation, nonvolatile memory  can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM), electrically erasable ROM (EEPROM), or flash memory. Volatile memory  includes random access memory (RAM), which acts as external cache memory. By way of illustration and not limitation, RAM is available in many forms such as synchronous RAM (SRAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), double data rate SDRAM (DDR SDRAM), enhanced SDRAM (ESDRAM), Synchlink DRAM (SLDRAM), and direct Rambus RAM (DRRAM).","Computer  also includes removable\/non-removable, volatile\/nonvolatile computer storage media.  illustrates a disk storage , wherein such disk storage  includes, but is not limited to, devices like a magnetic disk drive, floppy disk drive, tape drive, Jaz drive, Zip drive, LS-60 drive, flash memory card, or memory stick. In addition, disk storage  can include storage media separately or in combination with other storage media including, but not limited to, an optical disk drive such as a compact disk ROM device (CD-ROM), CD recordable drive (CD-R Drive), CD rewritable drive (CD-RW Drive) or a digital versatile disk ROM drive (DVD-ROM). To facilitate connection of the disk storage devices  to the system bus , a removable or non-removable interface is typically used such as interface .","It is to be appreciated that  describes software that acts as an intermediary between users and the basic computer resources described in suitable operating environment . Such software includes an operating system . Operating system , which can be stored on disk storage , acts to control and allocate resources of the computer system . System applications  take advantage of the management of resources by operating system  through program modules  and program data  stored either in system memory  or on disk storage . It is to be appreciated that various components described herein can be implemented with various operating systems or combinations of operating systems.","A user enters commands or information into the computer  through input device(s) . Input devices  include, but are not limited to, a pointing device such as a mouse, trackball, stylus, touch pad, keyboard, microphone, joystick, game pad, satellite dish, scanner, TV tuner card, digital camera, digital video camera, web camera, and the like. These and other input devices connect to the processing unit  through the system bus  via interface port(s) . Interface port(s)  include, for example, a serial port, a parallel port, a game port, and a universal serial bus (USB). Output device(s)  use some of the same type of ports as input device(s) . Thus, for example, a USB port may be used to provide input to computer , and to output information from computer  to an output device . Output adapter  is provided to illustrate that there are some output devices  like monitors, speakers, and printers, among other output devices  that require special adapters. The output adapters  include, by way of illustration and not limitation, video and sound cards that provide a means of connection between the output device  and the system bus . It should be noted that other devices and\/or systems of devices provide both input and output capabilities such as remote computer(s) .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as remote computer(s) . The remote computer(s)  can be a personal computer, a server, a router, a network PC, a workstation, a microprocessor based appliance, a peer device or other common network node and the like, and typically includes many or all of the elements described relative to computer . For purposes of brevity, only a memory storage device  is illustrated with remote computer(s) . Remote computer(s)  is logically connected to computer  through a network interface  and then physically connected via communication connection . Network interface  encompasses communication networks such as local-area networks (LAN) and wide-area networks (WAN). LAN technologies include Fiber Distributed Data Interface (FDDI), Copper Distributed Data Interface (CDDI), Ethernet\/IEEE 802.3, Token Ring\/IEEE 802.5 and the like. WAN technologies include, but are not limited to, point-to-point links, circuit switching networks like Integrated Services Digital Networks (ISDN) and variations thereon, packet switching networks, and Digital Subscriber Lines (DSL).","Communication connection(s)  refers to the hardware\/software employed to connect the network interface  to the bus . While communication connection  is shown for illustrative clarity inside computer , it can also be external to computer . The hardware\/software necessary for connection to the network interface  includes, for exemplary purposes only, internal and external technologies such as, modems including regular telephone grade modems, cable modems and DSL modems, ISDN adapters, and Ethernet cards.",{"@attributes":{"id":"p-0217","num":"0240"},"figref":"FIG. 10","b":["1000","1000","1010","1010","1000","1030","1030","1030","1010","1030","1000","1050","1010","1030","1010","1060","1010","1030","1040","1030"]},"What has been described above includes various exemplary aspects. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing these aspects, but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly, the aspects described herein are intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims.","Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as \u201ccomprising\u201d is interpreted when employed as a transitional word in a claim."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
