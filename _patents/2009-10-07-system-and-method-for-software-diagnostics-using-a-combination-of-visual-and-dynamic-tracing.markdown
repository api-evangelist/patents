---
title: System and method for software diagnostics using a combination of visual and dynamic tracing
abstract: A software system is disclosed that provides remote troubleshooting and tracing of the execution of computer programs. The software system includes an information-gathering module that gathers run-time information about program execution, program interaction with the operating system and the system resources, monitors user actions and captures screen output, and passes the gathered information to an information-display module, the gathered information allowing a support technician (e.g., a software developer, a help desk person, etc.) to see the user interactions with the program and corresponding reactions of the system, and/or to remotely view environment variables, file access operations, system interactions, and user interactions that occur on the user's computer and locate failed operations that cause execution problems.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08504994&OS=08504994&RS=08504994
owner: Identify Software, Ltd.
number: 08504994
owner_city: Petach-Tikva
owner_country: IL
publication_date: 20091007
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT","Other Embodiments"],"p":["This application is a continuation of U.S. patent application Ser. No. 09\/799,338, filed Mar. 5, 2001, which claims the benefit of priority of U.S. provisional patent application No. 60\/186,636, filed Mar. 3, 2000; all of which are hereby expressly incorporated by reference in their entireties.","1. Field of the Invention","The present invention relates to software tools for assisting software developers and help desk personnel in the task of monitoring and analyzing the execution of computer programs running on remote computers and detection and troubleshooting of execution problems.","2. Description of the Related Art","The problem of ascertaining why a particular piece of software is malfunctioning is currently solved by a number of techniques including static analysis of configuration problems and conventional debugging techniques such as run-time debugging and tracing. Despite the significant diversity in software tracing and debugging programs (\u201cdebuggers\u201d), virtually all debuggers share a common operational model: the developer notices the presence of a bug during normal execution, and then uses the debugger to examine the program's behavior. The second part of this process is usually accomplished by setting a breakpoint near a possibly flawed section of code, and upon reaching the breakpoint, single-stepping forward through the section of code to evaluate the cause of the problem.","Two significant problems arise in using this model. First, the developer needs to know in advance where the problem resides in order to set an appropriate breakpoint location. Setting such a breakpoint can be difficult when working with an event-driven system (such as the Microsoft Windows\u00ae operating system), because the developer does not always know which of the event handlers (callbacks) will be called.","The second problem is that some bugs give rise to actual errors only during specific execution conditions, and these conditions cannot always be reproduced during the debugging process. For example, a program error that occurs during normal execution may not occur during execution under the debugger, since the debugger affects the execution of the program. This situation is analogous to the famous \u201cHeizenberg effect\u201d in physics: the tool that is used to analyze the phenomena actually changes its characteristics. The Heizenberg effect is especially apparent during the debugging of time-dependent applications, since these applications rely on specific timing and synchronization conditions that are significantly altered when the program is executed step-by-step with the debugger.","An example of this second type of problem is commonly encountered when software developers attempt to diagnose problems that have been identified by customers and other end users. Quite often, software problems appear for the first time at a customer's site. When trying to debug these problems at the development site (typically in response to a bug report), the developer often discovers that the problem cannot be reproduced. The reasons for this inability to reproduce the bug may range from an inaccurate description given by the customer, to a difference in environments such as files, memory size, system library versions, and configuration information. Distributed, client\/server, and parallel systems, especially multi-threaded and multi-process systems, are notorious for having non-reproducible problems because these systems depend heavily on timing and synchronization sequences that cannot easily be duplicated.","When a bug cannot be reproduced at the development site, the developer normally cannot use a debugger, and generally must resort to the tedious, and often unsuccessful, task of manually analyzing the source code. Alternatively, a member of the software development group can be sent to the customer site to debug the program on the computer system on which the bug was detected. Unfortunately, sending a developer to a customer's site is often prohibitively time consuming and expensive, and the process of setting up a debugging environment (source code files, compiler, debugger, etc.) at the customer site can be burdensome to the customer. Some software developers attempt to resolve the problem of monitoring the execution of an application by imbedding tracing code in the source code of the application. The imbedded tracing code is designed to provide information regarding the execution of the application. Often, this imbedded code is no more than code to print messages which are conditioned by some flag that can be enabled in response to a user request. Unfortunately, the imbedded code solution depends on inserting the tracing code into the source prior to compiling and linking the shipped version of the application. To be effective, the imbedded code must be placed logically near a bug in the source code so that the trace data will provide the necessary information. Trying to anticipate where a bug will occur is, in general, a futile task. Often there is no imbedded code where it is needed, and once the application has been shipped it is too late to add the desired code.","Another drawback of current monitoring systems is the inability to correctly handle parallel execution, such as in a multiprocessor system. The monitoring systems mentioned above are designed for serial execution (single processor) architectures. Using serial techniques for parallel systems may cause several problems. First, the sampling activity done in the various parallel entities (threads or processes) may interfere with each other (e.g., the trace data produced by one entity may be over written by another entity). Second, the systems used to analyze the trace data cannot assume that the trace is sequential. For example, the function call graph in a serial environment is a simple tree. In a parallel processing environment, the function call graph is no longer a simple tree, but a collection of trees. There is a time-based relationship between each tree in the collection. Displaying the trace data as a separate calling tree for each entity is not appropriate, as this does not reveal when, during the execution, contexts switches were done between the various parallel entities. The location of the context switches in the execution sequence can be very important for debugging problems related to parallel processing.","Moreover, the computing model used in the Microsoft Windows environment, which is based on the use of numerous sophisticated and error-prone applications with many components interacting in a complex way, requires a significant effort for system servicing and support. Many Windows problems experienced by users are software configuration errors that commonly occur when the users add new programs and devices to their computers. Problems also occur due to the corruption of important system files, resources, or setups. Another important source of software malfunctioning is \u201cunexpected\u201d user behavior that was not envisioned by the software developers (as occurs when, for example, the user inadvertently deletes a file needed by the application).","The present invention overcomes these and other problems associated with debugging and tracing the execution of computer programs. The present invention provides features that allow a remote software developer or help desk person to debug configuration problems such as missing or corrupted environment variables, files, DLLs, registry entries, and the like. In one embodiment, a \u201cvisual problem monitor\u201d system includes an information-gathering module that gathers run-time information about program execution, program interaction with the operating system and the system resources. The information-gathering module also monitors user actions and captures screen output. In one embodiment, file interactions, DLL loading and\/or registry accesses are monitored non-intrusively. In one embodiment, the relevant support information captured by the information-gathering module is saved in a log file. The information-gathering module passes the gathered information to an information-display module. In one embodiment, the information-gathering module attaches to the running program using a hooking process. The program being monitored need not be specially modified or adapted to allow the information-gathering module to attach.","The information-display module allows a support technician (e.g., a software developer, a help desk person, etc.) to see the user interactions with the program and corresponding reactions of the system. This eliminates the \u201cquestions and answers\u201d game that support personnel often play with users in order to understand what the user did and what happened on the user's PC. In one embodiment, the information-display module allows the support technician to remotely view environment variables, file access operations, system interactions, and user interactions that occur on the user's computer. In one embodiment, the information-display module allows the support technician to remotely view crash information (in the event of a crash on the user's computer), system information from the user's computer, and screen captures from the user's computer.","One aspect of the present invention is a software system that facilitates the process of identifying and isolating bugs within a client program by allowing a developer to trace the execution paths of the client. The tracing can be performed without requiring modifications to the executable or source code files of the client program. In one embodiment, the system interaction tracing can be performed even without any knowledge of the source code or debug information of the client. Preferably, the trace data collected during the tracing operation is collected according to instructions in a trace control dataset, which is preferably stored in a Trace Control Information (TCI) file. Typically, the developer generates the TCI file by using a trace options editor program having a graphical user interface. The options editor displays the client's source code representation on a display screen together with controls that allow the software developer to interactively specify the source code and data elements to be traced. The options editor may use information created by a compiler or linker, such as debug information, in order to provide more information about the client and thereby make the process of selecting trace options easier. Once the trace options are selected, the client is run on a computer, and a tracing library is used to attach to the memory image of the client (the client process). The tracing library is configured to monitor execution of the client, and to collect trace data, based on selections in the trace options. The trace data collected by the tracing library is written to an encoded buffer in memory. The data in the buffer may optionally be saved to a trace log file for later use.","The developer then uses a trace analyzer program, also having a graphical user interface, to decode the trace information into a human-readable form, again using the debug information, and displays translated trace information on the display screen to allow the developer to analyze the execution of the client program. In a preferred embodiment, the trace options editor and the trace analyzer are combined into a single program called the analyzer. The analyzer is preferably configured to run under the control of a multi-process operating system and to allow the developer to trace multiple threads and multiple processes. The tracing library is preferably configured to run in the same process memory space as the client thereby tracing the execution of the client program without the need for context switches.","In one embodiment, the software system provides a remote mode that enables the client program to be traced at a remote site, such as by the customer at a remote customer site, and then analyzed at the developer site. When the remote mode is used, the developer sends the TCI file for the particular client to a remote user site together with a small executable file called the tracing \u201cagent.\u201d The agent is adapted to be used at the remote user site as a stand-alone tracing component that enables a remote customer, who does not have access to the source code of the client, to generate a trace file that represents execution of the client application at the remote site. The trace file is then sent to the developer site (such as by email), and is analyzed by the software developer using the analyzer. The remote mode thus enables the software developer to analyze how the client program is operating at the remote site, without the need to visit the remote site, and without exposing to the customer the source code or other confidential details of the client program.","The software system also preferably implements an online mode that enables the software developer to interactively trace and analyze the execution of the client. When the software system is used in the online mode, the analyzer and agent are effectively combined into one program that a developer can use to generate trace options, run and trace the client, and display the trace results in near real-time on the display screen during execution of the client program.","In one embodiment, the support technician typically uses a default TCI file that allows the trace system to trace interactions and other important API functions without access to source code and\/or debug information. This is useful for troubleshooting commercial applications such Microsoft Office, Internet Information Server, CRM and ERP systems, and other legacy products and the like.","In the drawings, like reference numbers are used to indicate like or functionally similar elements. In addition, the first digit or digits of each reference number generally indicate the figure number in which the referenced item first appears.","The present invention provides a new model for software diagnostics by tracing the execution path of a computer program and user interaction with the computer program. In the preferred embodiment of the invention, this tracing model is implemented within a set of tracing and debugging tools that are collectively referred to as the BugTrapper system (\u201cBugTrapper\u201d). The BugTrapper tools are used to monitor and analyze the execution of a computer program, referred to as a client. One feature of the BugTrapper is that it does not require special instructions or commands to be imbedded within the source code of the client, and it does not require any modifications to be made to the source or executable files of the client. \u201cTracing,\u201d or \u201cto trace,\u201d refers generally to the process of using a monitoring program to monitor and record information about the execution of the client while the client is running. A \u201ctrace\u201d generally refers to the information recorded during tracing. Unlike conventional debuggers that use breakpoints to stop the execution of a client, the BugTrapper tools collect data while the client is running. Using a process called \u201cattaching\u201d, the BugTrapper tools instrument the client by inserting interrupt instructions at strategic points defined by the developer (such as function entry points) in the memory image of the client. This instrumentation process is analogous to the process of connecting a logic analyzer to a circuit board by connecting probes to test points on the circuit board. When these interrupts are triggered, the BugTrapper collects trace information about the client without the need for a context switch, and then allows the client to continue running.","The BugTrapper implementations described herein operate under, and are therefore disclosed in terms of, the Windows-NT\/2000 and Windows-95\/98 operating systems and the like. It will be apparent, however, that the underlying techniques can be implemented using other operating systems that provide similar services. Other embodiments of the invention will be apparent from the following detailed description of the BugTrapper.","Overview of BugTrapper System and User Model","The BugTrapper provides two modes of use, remote mode, and online mode. As discussed in more detail in the following text accompanying , using remote mode a developer can trace the remote execution of a program that has been shipped to an end user (e.g. a customer or beta user) without providing a special version of the code to the user, and without visiting the user's site or exposing the source code level details of the program to the user. The system can also be used in an online mode wherein the developer can interactively trace a program and view the trace results in real time.","Remote Mode","Remote mode involves three basic steps shown in . In step 1, shown in , a developer  uses a program called the BugTrapper analyzer  to create a file called a trace control information (TCI) file . The TCI file  contains instructions that specify what information is to be collected from a program to be traced (the client). The analyzer  obtains information about the client from a build (e.g., compile and link) by-product, such as a link map file, or, as in the preferred embodiment, a debug information file . Typically, the debug information file  will be created by a compiler and will contain information such as the names and addresses of software modules, call windows, etc. for the specific client. The developer  then sends the TCI file  and a small tracing application called the agent  to a user  as shown in . The user  runs the agent  and the client  and instructs the agent  to attach to the client . The agent attaches to the client  by loading a client-side trace library  into the address space of the client . An agent-side trace library  is provided in the agent . The client-side trace library  and the agent-side trace library  are referred to collectively as the \u201ctrace library.\u201d The agent-side trace library  and the client-side trace library  exchange messages through normal interprocess communication mechanisms, and through a shared memory trace buffer . The agent-side trace library  uses information from the TCI file  to attach the client-side trace library  into the client , and thereby obtain the trace information requested by the developer .","The agent  and the client-side trace library  run in the same context so that the client  can signal the client-side trace library  without performing a context switch and thus without incurring the overhead of a context switch. For the purposes herein, a context can be a process, a thread, or any other unit of dispatch in a computer operating system. The client  can be any type of software module, including but not limited to, an application program, a device driver, or a dynamic link library (DLL), or a combination thereof. The client  can run in a single thread, or in multiple processes and\/or multiple threads.","In operation, the agent  attaches to the client  using a process known as \u201cattaching.\u201d The agent  attaches to the client , either when the client  is being loaded or once the client  is running. Once attached, the agent  extracts trace information, such as execution paths, subroutine calls, and variable usage, from the client . Again, the TCI file  contains instructions to the client-side trace library  regarding the trace data to collect. The trace data collected by the client-side trace library  is written to the trace buffer . On command from the user  (such as when a bug manifests itself), the agent  copies the contents of the trace buffer  to a trace log file . In some cases, the log data is written to a file automatically, such as when the client terminates. The user  sends the trace log file  back to the developer . As shown in , the developer  then uses the analyzer  to view the information contained in the trace log file . When generating screen displays for the developer , the analyzer  obtains information from the debug information file . Since the analyzer  is used to create the TCI file  and to view the results in the trace log file , the developer can edit the TCI file  or create a new TCI file  while viewing results from a trace log file .","Remote mode is used primarily to provide support to users  that are located remotely relative to the developer . In remote mode, the agent  is provided to the user  as a stand-alone component that enables the user to generate a trace log file that represents the execution of the client. The TCI file  and the trace log file  both may contain data that discloses secrets about the internal operation of the client  and thus both files are written using an encoded format that is not readily decipherable by the user . Thus, in providing the TCI file  and the agent  to the user, the developer  is not divulging information to the user that would readily divulge secrets about the client  or help the user  in an attempt to reverse engineer the client . The Agent traces the client without any need for modification of the client. The developer  does not need to build a special version of the client  executable file and send it to the customer, neither does the customer need to pre-process the client executable file before tracing.","From the perspective of the remote user, the agent  acts essentially as a black box that records the execution path of the client . As explained above, the trace itself is not displayed on the screen, but immediately after the bug reoccurs in the application, the user  can dump the trace data to the trace log file  and send this file to the developer  (such as by email) for analysis. The developer  then uses the analyzer  to view the trace log file created by the user  and identify the problematic execution sequence. In remote mode, the user  does not need access to the source code or the debug information. The agent , the TCI file , and the trace log file  are preferably small enough to be sent via email between the developer  and the user . Further details regarding the remote mode of operation are provided in the sections below.","Online Mode","As shown in , the BugTrapper may also be used in an online mode rather than remote mode as shown in the previous figures. In this mode, the BugTrapper is used by the developer  to locally analyze a client , which will typically be a program that is still being developed. For example, the online mode can be used as an aid during the development as a preliminary or complementary step to using a conventional debugger. In many cases it is hard to tell exactly where a bug resides and, therefore, where breakpoints should be inserted. Online mode provides the proper basis for setting these breakpoints. Later, if further analysis is required, a more conventional debugger can be used. In online mode, the analyzer  is used to perform all of its normal operations (e.g. creating the TCI file  and viewing the trace results) as well as the operations performed by the agent  in remote mode. Thus, in online mode, the agent  is not used because it is not needed. The developer  uses the analyzer  to run the client  and attach the client-side trace library  to the client . In online mode, the analyzer  reads the trace buffer  in near real-time to provide near real-time analysis functionality. In the online mode, the analyzer  immediately displays the trace information to the developer .","The developer  uses the analyzer  to interactively create trace control information (TCI). The TCI may be sent to the client-side trace library  via file input\/output operations or through conventional inter-process communication mechanisms such as shared memory, message passing or remote procedure calls. The TCI indicates to the client-side trace library  what portions of the client  to trace, and when the tracing is to be performed. As the client program  runs, the client-side trace library  collects the trace information and relays the information back to the analyzer , which displays the information in near real-time within one or more windows of the BugTrapper.","Operational Overview of the Tracing Function","Regardless of which operational mode is used (online or remote), the client  is run in conjunction with the client-side trace library . As described in detail below, the client-side trace library  is attached to the in-memory image of the client  and generates trace information that describes the execution of the client . The TCI file , provided by the developer , specifies where tracing is to take place and what information will be stored. Because the client is traced without the need for context switches, the effect of this tracing operation on the performance of the client  is minimal, so that even time-dependent bugs can be reliably diagnosed. As described below, this process does not require any modification to the source or object code files of the client , and can therefore be used with a client  that was not designed to be traced or debugged.","The analyzer  is used to analyze the trace data and isolate the bug. The developer  may either analyze the trace data as it is generated (online mode), or the developer  may analyze trace data stored in the trace log file  (mainly remote mode). As described below, the assembly level information in the trace log file is converted back to a source level format using the same debug information used to create the TCI file . During the trace analysis process, the analyzer  provides the developer  with execution analysis options that are similar to those of conventional debuggers, including options for single stepping and running forward through the traced execution of the client  while monitoring program variables. In addition, the analyzer  allows the developer  to step backward in the trace, and to search for breakpoints both in the future and in the past.","The attaching mechanism used to attach the client-side trace library  to the client  involves replacing selected object code instructions (or fields of such instructions) of the memory image of the client  with interrupt (INT) instructions to create trace points. The locations of the interrupts are specified by the TCI file  that is created for the specific client . When such an interrupt instruction is executed, a branch occurs to the tracing library . The client-side trace library  logs the event of passing the trace point location and captures pre-specified state information, such as values of specific program variables and microprocessor registers. The instructions that are replaced by the interrupt instructions are maintained within a separate data structure to preserve the functionality of the application.","Overview of the Analyzer User Interface","The analyzer  comprises a User Interface module that reads trace data, either from the trace buffer  (during on-line mode tracing) or from the trace log file  (e.g. after remote tracing) and displays the data in a format, such as a trace tree, that shows the sequence of traced events that have occurred during execution of the client . Much of the trace data comprises assembly addresses. With reference to , the analyzer  uses the debug information  to translate the traced assembly addresses to comprehensive strings that are meaningful to the developer. In order to save memory and gain performance, this translation to strings is preferably done only for the portion of the trace data which is displayed at any given time, not the whole database of trace data. Thus, for example, in formatting a screen display in the user interface, only the trace data needed for the display in the user interface at any given time is read from the log file . This allows the analyzer  to display data from a trace log file  with more than a million trace records.","The debug information  is preferably created by a compiler when the client is compiled. Using the debug information  the analyzer translates function names and source lines to addresses when creating the TCI file . Conversely, the analyzer  uses the debug information  to translate addresses in the trace data back into function names and source lines when formatting a display for the user interface. One skilled in the art will recognize that other build information may be used as well, including, for example, information in a linker map file and the Type Library information available in a Microsoft OLE-compliant executable.","Preferably, the debug information is never used by the trace libraries ,  or the agent , but only by the analyzer . This is desirable for speed because debug information access is typically relatively slow. This is also desirable for security since there is no need to send to the user  any symbolic information that might disclose confidential information about the client .","The analyzer  allows the developer  to open multiple trace tree windows and define a different filter (trace control instructions) for each of window. When reading a trace record, each window filter is preferably examined separately to see if the record should be displayed. The filters from the various windows are combined in order to create the TCI file , which is read by the client-side trace library . In other words, the multiple windows with different filters are handled by the User Interface, and the client-side trace library  reads from a single TCI file .",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 3A","FIG. 3"],"b":["300","106","300","300","310","314","316","318","300","304","306","312","304","310","320","320","330","330","320","330","102","314","320","330"]},"The executable pane  displays an \u201cexecutable\u201d listbox . Each line in the executable listbox  displays information about an executable image that is currently being traced. Each line in the list box  displays a filename field , a process id (PID) field , and a status field . Typical values for the status field  include \u201crunning,\u201d \u201cinactive,\u201d and \u201cexited.\u201d The trace detail pane  contains a trace detail tree , which that is preferably implemented as a conventional hierarchical tree control. The trace detail tree  displays attributes, variables such as arguments in a function call window, and function return values of a function selected in the trace tree . The source pane  displays a source listing of one of the files listed in the source listbox . The source listing displayed in the source pane  corresponds to the source code of the function selected in the trace tree  of to the selected source line. The source code is automatically scrolled to the location of the selected function.","The frame window  also contains a title bar which displays the name of the analyzer  and a file name of a log or Trace Control Information (TCI) file that is currently open. If the current file has not yet been saved, the string \u201c-New\u201d is concatenated to the file name display.","The status bar  displays the status of the analyzer  (e.g. Ready), the source code file containing the source code listed in the source code pane , and the line and column number of a current line in the source pane .","The toolbar  provides windows tooltips and the buttons listed in Table 1.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 3B","FIG. 3B","FIG. 3A"],"b":["300","310","320"]},{"@attributes":{"id":"p-0065","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Buttons on the toolbar"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Button","Menu Equivalent","Key","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["\u201cOpen\u201d","File | Open","Ctrl + O","Opens an existing Trace Control"]},{"entry":[{},{},{},"Information file."]},{"entry":["\u201cSave\u201d","File | Save","Ctrl + S","Saves the current Trace Control"]},{"entry":[{},{},{},"Information to a file."]},{"entry":["\u201cClear\u201d","Edit | Clear All",{},"Clears the Trace Tree pane, the All Trace"]},{"entry":[{},{},{},"Detail pane, and the Source pane"]},{"entry":["\u201cFind\u201d","Edit | Find","Ctrl + F","Finds a specific string in the executable"]},{"entry":[{},{},{},"source code or trace tree."]},{"entry":["\u201cBookmark\u201d","Edit | Bookmark",{},"Adds or deletes a bookmark for Bookmark"]},{"entry":[{},{},{},"the currently selected function, or edits the"]},{"entry":[{},{},{},"name of an existing bookmark."]},{"entry":["\u201cWindow\u201d","View | New",{},"Opens a new instance of the Window"]},{"entry":[{},"Window",{},"analyzer."]},{"entry":["\u201cStart\/Stop\u201d","Executable |",{},"Starts or stops tracing the Start\/Stop"]},{"entry":[{},"Start\/Stop Trace",{},"executables listed in the Trace Executable"]},{"entry":[{},{},{},"pane."]},{"entry":["\u201cAdd\u201d","Executable | Add","Ins","Adds an executable to the Add Executable"]},{"entry":[{},{},{},"pane, without running it, so that it can be"]},{"entry":[{},{},{},"run and traced at a later date."]},{"entry":["\u201cRun\u201d","Executable | Run","F5","When the <New Executable> Run string is"]},{"entry":[{},{},{},"selected, adds an executable to the"]},{"entry":[{},{},{},"Executable pane, starts this executable and"]},{"entry":[{},{},{},"begins tracing. When an executable which"]},{"entry":[{},{},{},"is not running is selected in the Executable"]},{"entry":[{},{},{},"pane, starts this executable and begins"]},{"entry":[{},{},{},"tracing."]},{"entry":["\u201cAttach\u201d","Executable | Attach",{},"When the <New Executable> Attach string"]},{"entry":[{},{},{},"is selected, attaches a running executable to"]},{"entry":[{},{},{},"the Executable pane and begins tracing."]},{"entry":[{},{},{},"When an executable that is not traced is"]},{"entry":[{},{},{},"selected, attaches the running process of"]},{"entry":[{},{},{},"this executable, if it exists."]},{"entry":["\u201cTerminate\u201d","Executable |",{},"Terminates the executable Terminate"]},{"entry":[{},"Terminate",{},"currently selected in the Executable pane."]},{"entry":["\u201cOptions\u201d","Executable | Trace",{},"Opens the Trace Options Trace Options"]},{"entry":[{},"Options",{},"window in which you can specify the"]},{"entry":[{},{},{},"elements that you want to trace for the"]},{"entry":[{},{},{},"selected executable."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The TCI file  specifies one or more clients  and the specific elements (functions, processes and so on) to be traced either in online or remote mode. The TCI information is specified in a trace options window (described in the text associated with ). The TCI file  is used to save trace control information so that the same trace options can be used at a later time and to send trace control information to a user  to trace the client . The subsections that follow provide a general overview of selecting trace information for a TCI file  and descriptions of various trace options, different ways to access the trace options, and how to use the trace options to specify elements to be traced.","The TCI file  for a client  is interactively generated by the software developer  using the analyzer . During this process, the analyzer  displays the source structure (modules, directories, source files, C++ classes, functions, etc.) of the client  using the source code debug information  generated by the compiler during compilation of the client . As is well known in the art, such debug information  may be in an open format (as with a COFF structure), or proprietary format (such as the Microsoft PDB format), and can be accessed using an appropriate application program interface (API). Using the analyzer , the developer  selects the functions and source code lines to be traced. This information is then translated into addresses and instructions that are recorded within the TCI file. In other embodiments of the invention, trace points may be added to the memory image of the client  by scanning the image's object code \u201con the fly\u201d for specific types of object code instructions to be replaced.","Trace control information is defined for a specific client . In order to access the trace tool, the developer  first adds the desired programs  to the list of executables shown in the executable pane  shown in . The executable is preferably compiled in a manner such that debug information is available. In many development environments, debug information may be included in an optimized \u201crelease\u201d build such that creation of the debug information does not affect the optimization. In a preferred embodiment, the debug information is stored in a PDB file. If during an attempt to add the executable to the Executable pane  a PDB file is not found by the analyzer , the developer  is prompted to specify the location of the PDB file. Once an executable has been added to the Executable pane , the developer  can set the trace control information using the available trace options described below.","To use the online mode to trace an executable  that is not currently running, the developer selects an executable file to run as the client . To run an executable file, the developer  double-clicks the <New Executable> text  in the executable pane  to open a file selection window thus allowing the developer  to select the required executable. Alternatively, the developer  can click the Run button on the toolbar , or select the Run option from the \u201cExecutable\u201d menu after selecting the <New Executable> text. The file selection window provides a command line arguments text box to allow the developer  to specify command line arguments for the selected executable file.","After selecting an executable to be a client  a trace options window (as described below in connection with ) is displayed which allows the developer  to specify which functions to trace. After selecting the desired trace options and closing the trace options window, the executable starts running and BugTrapper starts tracing. As the client  runs, trace data is collected and the trace data are immediately displayed in the analyzer frame window  as shown in .","To cause the analyzer  to trace an executable that is currently running, the developer  may click the \u201cAttach\u201d button on the toolbar  after selecting the <New Executable> text. Upon clicking the \u201cAttach\u201d button on the toolbar , a process list window  is displayed, as shown in . The process list window  displays either an applications list  or a process list (not shown). One skilled in the art will understand that, according to the Windows operating system, an application is a process that is attached to a top level window. The applications list  displays a list of all of the applications that are currently running. The process list window  also provides a process list, which is a list of the processes that are currently running. The applications list  is selected for display by an applications list tab and the process list is selected for display by pressing the applications list tab. To select a process from the process list window, the developer  clicks the Applications tab or the Processes tab as required, and then selects the application or process to be traced. The process list window  also provides a refresh button to refresh the application list and the process list, and an OK button to close the process list window .","After the developer  selects an application or process using the process list window , and closes the process list window , the analyzer  displays a trace options window , as shown in  below. The application or process selected in the process list window  becomes the client . The analyzer  can display trace data for multiple processes and applications (multiple clients); however, for the sake of simplicity, the operation of the analyzer  is described below primarily in terms of a single client . The trace options window  allows the developer  to select the functions to be traced. Selecting trace options is described below in the text in connection with . After selecting trace options and closing the trace options window , the client-side trace library  is attached to the client , and the client  continues to run. The client-side trace library  thereafter collects trace information that reflects the execution of the client  and sends the trace information to the analyzer  for display.","The developer can also add an executable file (e.g. a windows .exe file) to the executable pane  without actually running the executable file. To add an executable that is not currently running (and which is not to be run yet) to the executable pane , the developer  selects the <New Executable> text  and then clicks the Add button on the toolbar , whereupon a file selection window is displayed. The developer  uses the file selection window to select the desired executable and closes the file selection window. The file selection window provides a text field to allow the developer to enter command line arguments for the executable. Upon closing the file selection window, the trace options window  is displayed which enables the developer  to select the functions to trace. After selecting trace options and closing the trace options window, the selected executable is inserted into the Executable pane  with the status \u201cInactive.\u201d The developer can then begin a trace on the inactive executable by selecting the executable in the executable pane  and clicking the \u201cRun\u201d or \u201cAttach\u201d buttons on the toolbar .","In a preferred embodiment, the developer  can only create a new TCI file  when the executable list  contains the names of one or more executable files. To create a TCI file , the developer  selects \u201cSave\u201d from the \u201cFile\u201d menu. The developer can also open a previously saved TCI file  and then modify the TCI file  using the trace options window . Once a TCI file  has been created (or opened) the developer  can select an executable from the executable pane and click the \u201cRun\u201d or \u201cAttach\u201d button from the toolbar to start tracing.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 5","FIG. 5","FIG. 6","FIG. 7","FIG. 8"],"b":["500","500","501","504","501","602","510","702","512","502","514","802","516","502","602","702","802","520","522"]},"The trace options window  allows the developer  to specify which functions to trace and what to display in the trace tree . The trace options window  allows the developer  to filter out functions which have already been traced. These functions will be redisplayed where they were traced if they are later re-select for tracing. If a function is not selected for tracing in the trace options window , it will not be displayed in the trace tree . If a function that was not traced is filtered in again, it will not appear in that portion of the information that has already been displayed.","For example, consider the following C++ program:",{"@attributes":{"id":"p-0078","num":"0077"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"f1 ( ) { }"]},{"entry":[{},"f2 ( ) { }"]},{"entry":[{},"main ( ) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"while (1) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"getchar (c);"]},{"entry":[{},"f1( );"]},{"entry":[{},"f2( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Using the above program as an example of a client , and assuming that the user forms the following steps:\n\n","Then, after Step 4 the following depicts the elements that are displayed in the trace window, with the symbol  representing a tear in the trace as described below in connection with .","main","f1","\u02dc\u02dc\u02dc\u02dc (Step 3)","f1","After Step 6 the trace appears as follows:","main","f1","f2","\u02dc\u02dc\u02dc\u02dc (Step 4)","f1","\u02dc\u02dc\u02dc\u02dc (Step 5)","f1","f2","In the above example, after f2 was filtered in again in step 5, it was restored in the first portion of the trace because filtering out occurred after this portion had already been executed. However, f2 never returned to the second portion, which was executed after f2 had been filtered out. Therefore, changing the trace options also determines which of the functions that have already been traced will be displayed. If a traced function is then filtered out from the trace, it can later be filtered in again.","In the filter tree pane , the process tab , corresponding to the process page , is not displayed prior to activating a process. Each of the four pages in the filter tree pane  displays a tree that the developer  can use to select the functions to be traced and analyzed. The source code pane  displays a source code fragment that contains the source code for the selected function and enables the developer  to select the specific source lines to be traced. Each line of executable source in the source code pane  is provided with a check box displayed along the left edge of the pane . The developer  checks the box to select the corresponding source line for tracing.","The \u201cadvanced\u201d button  opens a window which allows the developer  to specify which elements to display during the trace (e.g. arguments, pointers, \u201cthis\u201d class members and return values) and the maximum string length to be traced. The add DLL button  opens a window which allows the developer  to specify DLL files to be traced. This is useful when a DLL is loaded dynamically, as described below.","The developer  uses the filter tree pane  to select functions to be traced. Four page selection tabs at the top of the filter tree pane  enable the developer  to view the functions classified (sorted) according to file (on the file page ), class (on the class page ), name (on the name page ) or process (on the process page ). The way the functions are organized is different for each classification tab. However, the tree structure that is displayed in each of the four pages operates in the same way, even though the data elements in the tree are different for each page. Thus, the following discussion relating to the filter tree applies to any of the four pages of the filter tree pane .","The filter tree is a tree of function names with check boxes to the left of each name. Function check boxes appear blank, checked or dimmed as follows:\n\n","The file page , shown in , provides a hierarchical tree that lists the objects according to their hierarchical level in the following order:\n\n","The source file structure is taken from the debug information (e.g., .PDB) files  for the client . If the full path name of the source file is not contained in the .PDB file, then the functions contained in that source file are located in a separate branch of the trace tree  under the title <Unknown Directory>. Functions that are included in the .PDB file, but whose source file is unknown, are located in a separate branch of the trace tree  under the title <Unknown Source File>.","The class page , shown in , provides a hierarchical tree that lists the trace objects sorted by class, ignoring their distribution amongst source files. Functions, which do not belong to a specific class are located in a separate branch of the trace tree  under the title <Functions>. The name page , shown in , provides a hierarchical tree that lists functions sorted alphabetically by name. Leading underscores and class names for methods are ignored. The process page , shown in , provides a hierarchical tree that displays each process that has been selected for tracing. Under each process is a list of the threads for that process.","DLL files that are not linked with the executable but rather are loaded dynamically (e.g. libraries loaded using the LoadLibrary system call), are not shown by default in the trace options window . In order to trace a dynamically loaded DLL file, the dynamically loaded DLL file should be added to the list of DLL files using the Add DLL button  in the Trace Options window . Clicking the add DLL button  displays a file selection window. Using the file selection window, the developer  then selects the required DLL file. The selected DLL file is added to the filter tree in the filter tree pane  of the trace options window .","The BugTrapper can also trace DLL files loaded by an executable, even when the executable does not contain debug information. For example, if the developer  writes a DLL file as an add-on (e.g., an ActiveX control) to a commercial program (e.g. Microsoft Internet Explorer), the developer  can activate BugTrapper on the commercial program and perform a trace on the add-on.","The BugTrapper also allows the developer  to specify various function attributes to be displayed in the trace detail pane  of the analyzer frame window , (shown in ) while performing a trace. The developer  can choose to display arguments, pointers, \u201cthis\u201d class members and return values. One skilled in the art will recognize that under the terminology of C++, a \u201cthis\u201d class member is a class member that is referenced by the C++ \u201cthis\u201d pointer. The developer  can also specify the maximum string length to be displayed. Selecting more options generally reduces the number of records in the trace log file and thus reduces the amount of execution time that is logged. The discussion below regarding the cyclic trace buffer provides further details of how much execution time is actually logged. The advanced button provides access to an advanced options window (not shown).","Selecting the arguments checkbox causes function arguments to be displayed in the trace detail pane . Selecting the \u201cpointers\u201d checkbox causes data to which a first level function argument of the pointer type points to be displayed. In other words, selecting the pointers checkbox causes function arguments that are pointers to be de-referenced for the display. The developer  may select the \u201cthis\u201d checkbox to have \u201cthis\u201d to have all members in a class displayed in the trace detail pane  when there is a call to a method which has a this pointer. The developer  may select the return checkbox to have function return values displayed in the trace detail pane .","The BugTrapper also allows the developer  to control tracing of specific source lines. In the source code pane , a checkbox is located to the left of each executable source line, which can be traced. To view the source code fragment containing a specific function, the developer  selects the required function in the filter tree pane  and the analyzer  displays the appropriate source code fragment in the source code pane . If analyzer cannot locate the source code, then the source code is not displayed and the developer  may press the spacebar or right-click in the source code pane  and select a \u201cSource Location\u201d command from a pop-up menu. The \u201cSource Location\u201d command opens a dialog box which allows the developer  to specify a source code file to be displayed in the source code pane . The appropriate source code is then displayed in the source code pane , as shown in .","To select the source code lines to trace, the developer clicks the check boxes corresponding to the desired lines. To select multiple lines, the developer  can either press CTRL+A to select the whole source code file, or drag the mouse along several lines and thereby select a group of lines. The developer  can then click on any checkbox in the selected area to check all the selected lines or click on a checkbox that is already checked to deselect all selected the lines. If lines of code in a file are selected for tracing, then the filename is displayed in blue. The developer  may also select which variables (e.g., local variables, global variables, static variables, etc.) should be traced for each traced line.","If a client  is modified and recompiled, it may not be desirable to use an existing TCI file for that client  (for example, a function that was selected for tracing may have been from the modified and recompiled version). Whenever the BugTrapper encounters an outdated TCI file , it issues a warning and then continues to trace based on a heuristic algorithm, which attempts to match the trace instructions to the modified client executable. Trace information for an application that may be recompiled at some future date can be supplemented by saving the trace information to an Extended Trace Control Information (TCE) file rather than a regular TCI file . The TCE file contains extra symbolic information (such as function names) that is not part of a regular TCI file . Using the extra symbolic information greatly increases the chances that the heuristic trace algorithm will produce the desired results. It is especially desirable to use a TCE file at the user  site when the client  is frequently modified, and the developer  does not want to redefine the trace options after each compilation. The TCE file is identified by a .TCE extension.","The developer may save a TCI file  by clicking the save button on the toolbar , whereupon the trace control information is saved. The first time that information is saved to a new TCI file , a file selection window appears. In the file selection window, the developer  may select the type of file (TCI or TCE) in a \u201cSave as\u201d type box.","The TCI file  can be used to trace a local client  at a later time, or it can be sent to a user  for use with the agent  to trace a client  at a remote site. In a preferred embodiment, for remote tracing, the developer  sends the user  a self-extracting zip file that contains the agent  and the TCI file .","Using the Agent","As described above, the agent  is an executable module which the developer  can provide to a user  along with a Trace Control Information (TCI) file in order to trace a client . The trace data collected by the agent  are written to the trace log file  which the user sends to the developer . The developer  uses the analyzer  to view the contents of the trace log file and analyze the trace information in the log file . Trace analysis using the analyzer  is discussed in subsequent sections of this disclosure. The present section discusses the procedures for starting the agent , including the first step performed by the user  to run the agent . The present section also discloses techniques for selecting the TCI file , specifying a directory for the trace log file , specifying the client , and, finally, using the agent  to control the logging of trace data. The agent  is an easy-to-run standalone application, with step-by-step instructions provided on the screen. To trace an application, the user  needs both the agent  and the TCI file . The TCI file  is prepared, as described above, by the developer  and contains information about the client  and the specific functions to be traced.","In a preferred embodiment, the developer supplies the agent  as a self extracting zip file that can be installed by simply double clicking on the zip file name. At the end of the installation, the user  can launch the agent . When the agent  is launched, it displays a TCI select window (not shown) which is a conventional file select dialog that allows the user to select the TCI file . Likewise, the agent  provides a log file window, which allows the user  to select a directory for the log file . The default log file is the last log file that was opened by the agent . The next step in using the agent  is to specify the client  executable(s) to trace.","If an executable specified in the TCI file  is already running, an attach to running processes window (running window)  is displayed, as shown in . The running window  provides a finish button , a cancel button , a back button , and a list of processes . The list of processes  shows any currently running processes that are specified in the TCI file . The list of processes  shows all processes that are specified in the TCI file  that are not currently running as disabled (grayed). The running window  allows the user  to select a currently running process to trace by selecting items in the list . Preferably, the user  will deselect any executables that are to be re-run from the start (that is, when the user does not want to attach to an executable that is already running). To select a running process, the user  selects a process from the list , and then presses the finish button  to cause the BugTrapper to attach to the client processes and starts to collect trace data.","If an executable specified in the TCI file is not currently running, then a start processes window (start window)  is displayed, as shown in . The start window  provides a finish button , a cancel button , a back button , and a list of executable files . The start window  also provides a path field , a parameters field , and a directory field . The list of files  shows any currently running processes that are specified in the TCI file. The start window  allows the user to specify executables that are not currently running to be traced. The agent  will run the selected client(s)  and trace them according to the information in the TCI file .","The file list  displays the executables, which are listed in the TCI file. Each item in the file list  is provided with a check box. To specify the executables to run, the user  checks the boxes for the desired executables in the file list . If the file path in the file list  is not correct, then the user may enter the correct file path in the path field . The user  may also add command line arguments in the parameters field . The file path and command line steps may be repeated as needed to specify the file path and commands for additional executables. When the finish button  is clicked, an agent window (described below) is displayed and the agent  runs the specified executables, attaches to the executable processes, and starts tracing.","The agent window (not shown) is displayed by the agent . The agent window displays the names of the TCI file and the log file. The agent window also contains an animated icon whose movement indicates whether trace data is currently being collected while the client  is running. The agent window also contains: a \u201cStart\/Stop\u201d button to start or stop the trace; a \u201cClear\u201d button to clear the trace buffer , a \u201cDump\u201d button to save the contents of trace buffer  to the log file; and an \u201cExit\u201d button to exit the agent .","The \u201cStop\/Start\u201d button allows the user  to stop and restart tracing when desired. Stopping the trace may improve system performance. The \u201cStart\/Stop\u201d button toggles between Stop and Start according to the tracing status. The animated icon moves when tracing is in progress. The \u201cClear\u201d button allows the user  to clear the trace buffer . The cleared information is not stored in the log file  unless the user first uses the dump button. The dump button allows the user  to save the contents of the trace buffer  to the log file . On the first save after a new process had been started, the agent  overwrites the old log file  (if one exists). On subsequent saves, new information will be appended to the existing log file . Clicking the exit button causes the agent  to exit. Upon exiting, the trace buffer is written to the log file. Note that the trace information is written to the log file when either dump or exit is clicked and also when the traced application crashes or terminates. The user  will preferably use the dump button frequently if it appears likely that the entire operating system may crash.","In one embodiment, the user may select to write every trace line to the disk as it is traced, or, the user may select to write trace lines periodically every N seconds. Such writing is useful, for example, when it appears likely that the entire operating system may crash.","Analysis of the Trace Information","The analyzer  is used to analyze a trace, either online as an application runs or off-line using a remote trace log. The general topics that fall under the rubric of trace analysis include, starting an online trace, opening a previously saved trace log file, viewing trace information, interpreting the trace information, working with trace information, and additional trace functions that are available when performing an online trace.","The BugTrapper allows the developer  to trace a client  executable in order to pinpoint an element in the client  code that causes a bug. The primary device for displaying trace information in the analyzer  is the trace tree  in the trace tree pane  shown in . The trace control information (TCI) filters can be modified during trace analysis to filter out some of the available trace data according to the needs of the developer .","Analysis of a remote trace (or a previously saved online trace) is started by opening a previously saved trace log file and displaying the trace information that it contains in the trace tree pane . The log file  may either have been created by saving trace information using the analyzer , or the log file  may have been created at a remote location using the agent . A trace log file  is opened by using an \u201cOpen Log\u201d command from the \u201cFile\u201d pull down menu found on the menu bar . Once a trace log file  is open, the title bar  displays the name and path of the opened log file . Once a trace log file  is open, the developer can view the trace information using various panes in the analyzer frame window . Trace information is displayed in the trace tree pane , the trace detail pane , and the source pane .","The trace tree , in the trace tree pane , is a hierarchical tree showing trace data collected from the client . Trace data includes information about events that took place during execution of the client , including function calls, function returns, selected source lines, etc. The developer  can use the mouse to choose any function from the trace tree, whereupon the arguments and return values for the chosen function are shown in the trace detail pane , and the source for the chosen function is displayed in the source pane . The types of trace information displayed for both online traces and a trace from log files is almost identical, however the log file trace provides a static display, while the online trace is dynamic and can be viewed as the trace information is being collected.","The trace tree  displays a hierarchical tree of the sequence of function calls and returns in the client . The number of lines in the trace tree is shown in the trace tree pane title bar . The trace tree  is organized in a standard tree structure and the developer  can click on the tree control buttons to collapse or expand the view of functions belonging to lower hierarchical levels. Clicking on a function or a source line in the trace tree pane  causes the trace detail pane  and the source pane  to change to display information relevant to the function. Selecting a function in the trace tree  and pressing the delete button on the keyboard removes the selected function from the trace. This is equivalent to filtering the function out of the trace.","The trace data is written to a buffer in memory called the trace buffer , and from there either displayed in the trace tree pane  (when performing an online trace) or written to a log file (when performing a remote trace). The trace buffer  is organized as a circular buffer of fixed size. The size of the trace buffer  can be set by the developer . When the trace buffer  is full, new trace records overwrite the oldest records contained in the buffer . One skilled in the art will recognize that other buffering methods can be used without changing the scope of the present invention. For example, the trace information could be stored in a buffer, which simply added trace records without overwriting old records. In a preferred embodiment, loss of old data is acceptable because, when the client  malfunctions, the developer  is usually interested in the most recent records prior to the malfunction. Thus, there is usually little need to keep all of the records, especially the oldest ones. The size of the trace buffer  is set so that it will be big enough to hold a large number of records without consuming too many system resources. Typically, 20,000 to 40,000 records are kept.","When the trace buffer  is written to a log file , the trace records are preferably appended to the end of the log file . In a log file, old records are not deleted, and the trace size is limited only by the available disk space.","Alternatively, when tracing online, the trace tree is actually an image of the trace buffer . Because of this, the trace tree will not display more records than the trace buffer  contains, so old records are deleted (\u201cscrolled out\u201d of the display). The rows counter at the top of the trace tree pane  indicates the number of records in the trace buffer  and the number of rows in the trace tree. Because the buffer  is circular, the number of rows in the trace tree  continuously grows during the beginning of the tracing process until the buffer wraps (typically 20,000 to 40,000 records). Thereafter, the number remains approximately at the same level as old records are overwritten with new records. The exact number of records that are kept in the trace buffer  depends on the size of the trace records. The size of each trace record is determined by the TCI options specified by the developer . For example, if the developer  requires tracing of \u201cthis\u201d class members, the size of the records will increase and the number of records in the buffer will decrease.","The analyzer  and the agent  can trace a multi-threaded and multi-processed client . When tracing a multi-threaded process, different threads are separated from each other in the trace tree pane  by a thread caption bar . For multi-process applications, similar horizontal bars, called process caption bars (not shown), separate trace lines belonging to different processes. The thread caption bar  and the process caption bar separate the trace tree  into sections. These caption bars represent a context switch in the application, between threads and between processes. Process caption bars are similar to the thread caption bar , therefore any future mention of threads also applies to processes in multi-process applications.","The thread caption bar  contains a name field, a process ID number field, and a thread ID number field . Within the trace tree  itself, there is an up arrow at the top of each section, and a down arrow at the bottom of each section. Clicking the up arrow causes the displayed trace tree  to jump to the previous point in the trace tree  where the thread gained control. Clicking the down arrow causes the displayed trace tree  to jump to the next point in the trace tree  where the thread gains control. The trace tree  also provides an expand\/collapse control button  to allow the developer  to expand and collapse the current thread view. The trace tree pane  also provides a vertical scroll bar for scrolling up and down through the trace tree . When the trace tree pane  is scrolled up or down to a section containing functions of lower hierarchical levels, the portion of the trace tree  displayed in the window is shifted leftwards. The depth of this shift, with respect to the first function called in the process, is indicated by a stack level indicator  appearing in a rectangle in the upper left corner under the thread caption bar  (as shown in ).","The trace detail pane  shows available details describing the function selected in the trace tree view.  shows a trace detail pane  that displays a C++ class having several members and methods, a class derived from another classes, and classes as members of a class. The trace details are displayed in a trace detail tree  which is a hierarchical tree structure. A right arrow  in the trace detail pane  marks where the function is called. A left arrow at the bottom of the detail tree  marks where the function returned to its caller. Some of the data that can be displayed (such as the arguments) are only displayed if an option is selected in the advanced trace options. If an argument in the call window of a function is of the aggregate type, the argument's components will be displayed beneath the right arrow  in the form of a hierarchy tree. If an argument is of the pointer type, and pointers were selected in the advanced trace options, then the value displayed in the trace detail tree  will be that of the data to which the pointer points. However, for pointer fields that reside within arguments, only the address contained in the pointer will be displayed. In other words, in the preferred embodiment, the pointer is de-referenced only for the first level arguments. One skilled in the art will understand that other pointers could be de-referenced as well, and that the trace detail tree  could display the value pointed to by arguments deeper than the first level.","In one embodiment, the trace detail pane  also shows time stamps. The time stamps display the time that a function is called and the time that the function returns to its caller.","If the argument is an array of known size, then the elements of the array will be displayed. If the array size is unknown, then the value displayed is the value of the first array element. If the argument is of character pointer type, then the string value is displayed. If the argument is numeric, then the decimal, hex, or decimal and hex values are displayed, depending on the selection made in the advanced trace options. Right-clicking the mouse when it points in the trace detail pane  displays a popup menu which allows the developer  to select how numeric arguments are displayed (as decimal, hex, or decimal and hex values).","The source pane  shows the source code for the selected function or source line selected in the trace tree . The source code listed in the source pane  is automatically scrolled to the location of the selected object, if possible. The line in the source code is displayed in bold and is pointed to by an arrow. The analyzer  looks for the source file in the current directory and in the directory indicated in the .PDB file. If the source file is not found, the source pane remains blank. In this case, the developer  can change the source file search path in order to display the source code. To change the source file path the developer should select a function in the trace tree , then right-click in the source pane to open a pop-up menu, and then select the \u201cSource Location\u201d from the pop-up menu. Alternatively, the developer  can add additional source directories and remove source directories by selecting the \u201cOptions\u201d command from the \u201cView\u201d menu on the menu bar . Source file paths can also be removed.","The analyzer  provides several features which make it easier to analyze trace information and pinpoint a bug in the client . These features can be used both while performing an online trace and while viewing trace information from a remote log file . Analysis features include: saving trace information to a log file ; printing the trace tree ; searching for trace elements; locating a function in the trace options window ; filtering the trace information; adding, editing, deleting and locating bookmarks; clearing the trace tree pane; and displaying multiple windows. Additional features available for online tracing include saving trace information to the log file .","The \u201cFind\u201d button on the toolbar  is used to initiate a search for an element in the trace tree . Clicking the Find button opens a \u201cFind what\u201d dialog box in which the developer  can enter a search text string. The find what dialog provides a \u201cFind Next\u201d button to start a search for the occurrence of the specified search text. The first occurrence of the specified text is highlighted in the relevant pane. Functions in the source code displayed in source pane  can be located in the trace options dialog  by right-clicking inside the source code in the source pane . The right-click opens a pop-up menu. The developer then selects a \u201cLocate in Trace Options\u201d command from the pop-up menu to open the trace options window . The trace options window  will open with the desired function displayed and highlighted.","The trace filter previously described in the text relating to  is a tool that enables the developer  to select the functions to trace. When using the trace filter to change the display while performing an online trace, the trace continues in the background, and when the developer  closes the trace options window  the new filter is applied to the display in the trace window . The developer  can also use the trace options window  to change the display while performing an off-line trace. This enables the developer  to filter out traced elements and display a subset of the traced information. The information contained in the log file is not modified, only the display changes.","A bookmark allows the developer  to mark trace lines (functions or source lines) in the trace tree . The developer  can also edit the name of a bookmark or delete the bookmark it as required. Bookmarks are inserted in the trace tree  by using the bookmark button on the toolbar . Bookmarks allow easy jumps to the bookmarked element. To insert a bookmark in the trace tree , the developer will: select the trace line (a function or source line in the trace tree ) to mark; press the bookmark button to open the bookmark window; type the bookmark name in the bookmark widow; and click the OK button. A waiving flag icon  appears on the left of the bookmarked trace line in the trace tree . The bookmark name is displayed whenever the cursor is placed over the bookmarked line. To change a bookmark name, the developer  repeats the steps to create a bookmark. To delete a bookmark from the trace tree , the developer  can press a delete button on the bookmark window. The \u201cGoto Bookmark\u201d command from the \u201cEdit\u201d menu is used to go to a bookmark in the trace tree .","Multiple instances of the analyzer  can be open simultaneously. Each instance can define different filter options for each window. This feature is especially useful for multi-threaded applications, where it is convenient to observe each thread in a separate window.","The analyzer  provides for starting and stopping of an online trace. All trace points are disabled when tracing is stopped. Stop is helpful if the trace adversely influences the application performance and it appears that the subsequent operations in the client  are not relevant to the problem being analyzed. The Start\/Stop Tracing button on the toolbar  is used to toggle tracing on and off. Tracing is stopped or restarted as specified. When tracing is stopped, the boundaries of the lost tree portion appear in the trace tree pane  as a tear , as shown in . When tracing is resumed, the trace tree  continues under the tear .","Internal Implementation Details of the BugTrapper System","The sections that follow discuss various internal operational and implementation details of the agent , the analyzer , the trace libraries , , and how these elements interact with the client  and the operating system.","The Attaching Mechanism","One aspect of the present invention is the attaching mechanism used by the BugTrapper to collect trace information. With traditional tools, it was necessary to manually enter trace points in the application's source code, or at a minimum, even if trace points were automatically added to the source, to re-compile the source code. With BugTrapper, tracing is accomplished by attaching to the memory image of the application (i.e., the copy of the executable code that is loaded into RAM or other memory for execution). There is no need to enter trace points into, or to otherwise modify, the source, object, or executable files of the client  application. No special tracing version of the client  is needed, and the client  need not be written in any special manner. Attaching to the client  in memory allows function calls, returns, and other source lines to be traced. The attaching mechanism also allows for the tracing of any executable, including optimized (release) builds, multi-threading and multi-processes, longjumps, signals, exceptions, and recursions.","The BugTrapper client-side trace library  is attached to the client , in part, by modifying certain executable instructions of the memory image of the client . This process is generally called \u201cexecutable code instrumentation,\u201d or simply \u201cinstrumentation.\u201d The instrumentation process is performed such that the functionality of the client  is preserved. Because the instrumentation is made only on the memory image, there is no need to pre-process or modify the source code or executable files of the client . Use of the client-side trace library  provides significant advantages over the prior art by eliminating the need for context switches when debugging a program. Context switching has the effect of significantly slowing down the rate of execution. The tracing implementation provided by BugTrapper can therefore be used to study the real time behavior of a program and detect bugs resulting from such behavior. Although one skilled in the art will recognize that the present invention can advantageously be used with any operating system, a preferred embodiment runs under the Windows-NT\/2000, Windows-95\/98 and similar operating systems supplied by Microsoft Inc. The following description of the internal details of the BugTrapper will thus be described in terms of the Windows-NT\/2000\/95\/98 operating systems with the understanding that the invention is not limited to said systems.","The trace libraries ,  include a number of callable functions (discussed below). By using the callable functions, and system functions provided by the Win32 API (application program interface), the trace libraries performs two major tasks: (1) attaching specialty functions to application, and (2) tracing the execution of the application's executable code. Both of these tasks are described separately below. The agent-side trace library  is primarily responsible for attaching the client-side trace library  to the client . The agent-side trace library  also provides communication with the client-side library . The client-side trace library  is primarily responsible for placing data in the trace buffer . In the following description, the term \u201cclient process\u201d is used to refer to the executable code of the client  that has been loaded into a memory space for execution. BugTrapper refers both to BugTrapper Agent or BugTrapper Analyzer, depending whether it is operating in the Online mode or the Remote mode.","The act of attaching to a currently running process is known as a Process Attach. The act of attaching to a new process, during the creation of the new process, in order to trace the new process from its start is known as a Creation Attach. In a Creation Attach it is desirable to pause the client  process as close as possible to its entry point so that virtually all of the functions executed by the client  will be traced.","In the Windows-NT\/2000 compatible and Windows-95\/98 compatible operating systems, each process resides at a distinct location or \u201caddress space\u201d in memory. A DLL, such as the client-side trace library , which resides in another address space, cannot simply be loaded into the same address space as the client process. To overcome this limitation, BugTrapper forces the client process to load the client-side trace library  DLL (using a process called injection) into the process space of the client process.","Attaching to a Client Running Under Windows-NT\/2000","In a preferred embodiment, the injection process for Process Attach in Windows-NT is accomplished by using the CreateRemoteThread( ) function of the Win32 API, to create a remote thread in the client process and to force the newly created thread to run code in the client process. The code that is run by the remote thread is a copy of an injection function copied to the remote thread using the Win32 API WriteProcessMemory( ) function. The Process Attach involves the following sequence of events shown in  beginning with a procedure block  where the function inst_attach( ) of the tracing library is called in BugTrapper, using the process ID (\u201cPID\u201d) of the client (client) process as an argument. The function inst_attach( ) performs the following operations:","1) It obtains a handle to the client process using OpenProcess( )","2) It allocates memory in the client process's address space using the Win32 API function VirtualAllocEx( );","3) It copies the code for the injection function and other various data (including the full path of the Trace Library) onto the allocated memory space using the WriteProcessMemory( ) function; and","4) It creates a new thread in the client process with CreateRemoteThread( ).","The new thread created in step 4 starts executing at the address to which the injection function was previously copied in step 3. The procedure then advances from the procedure block  to a procedure block  where the injection function starts running in the new thread of the client process. Using data passed to it via other parts of the memory space, the injection function loads the client-side trace library .","The procedure advances from the procedure block  to a procedure block  where the client-side trace library  runs in the context of the new thread while the instrumentation is taking place. The client-side trace library  communicates with BugTrapper (i.e., the agent-side trace library ), handling commands, and actually performing the instrumentation.","The procedure advances from the procedure block  to a procedure block  where the client-side trace library  exits, and the injection function destroys its own thread and stops executing by calling the ExitThread( ) function. Unlike other debuggers that terminate the debugged process on exit, here the client  continues to run, without any substantial alteration to the functionality of the client .","Creation Attach is accomplished under Windows-NT by creating the client process in a suspended state, by using the CREATE_SUSPENDED flag in the CreateProcess( ) function. In this case, the previously described procedure cannot be used, since none of the system DLLs in the client process have been initialized. In particular, since KERNEL32.DLL is not loaded, the client-side trace library  cannot be loaded. The present attaching procedure overcomes this difficulty by performing the following attaching procedure, which begins at a procedure block  shown in .","To attach to a new client , the attaching procedure begins in block , in which the client process is created in a CREATE_SUSPENDED state. The attaching procedure then advances to a procedure block . In the procedure block , BugTrapper makes a call to the inst_prepare( ) of the agent-side trace library . The inst_prepare function, using WriteProcessMemory( ) and VirtualAllocEx( ) allocates memory in the client process and copies a small assembly language code segment into the allocated space. The procedure then proceeds to a procedure block  where the inst_prepare function overwrites the entry point of the client executable in the client process with a jump instruction to the new assembly code. The attaching procedure then advances to a procedure block  wherein the inst_prepare function allows the client process to resume, and thereby start the initialization process for the client process. After all DLLs are initialized, including the client-side trace library , execution continues to the entry point of the client executable, which now contains a jump to the new assembly code. When the jump occurs, the attaching procedure advances from the procedure block  to a procedure block . In the procedure block , the assembly code restores the original client entry point, and suspends the client process. At this point, the client process is suspended without running any executable code, but is past the initialization stage. The attaching procedure then advances to a procedure block .","In the procedure block , BugTrapper can now call inst_attach( ) to attach to the client process and start instrumenting it. When the attaching procedure is complete, it can allow the client process to resume. The assembly code simply jumps directly is back to the original entry point of the client , and execution of the client  starts with the proper instrumentation.","Attaching to a Client Running Under Windows-95\/98","In Windows-95\/98, Process Attach and Creation Attach are implemented in a manner different from the Windows-NT\/2000 manner discussed above because the CreateRemoteThread API call is not supported in this operating system.","Creation Attach under Windows-95\/98 exploits the fact that process initialization starts from a known entry point of kernel32.dll. BugTrapper creates the client process in the suspended mode and then calls to the inst95_attach function. This function performs the following sequence of operations:","1) It initializes the communication channel for IPC with the client process.","2) It copies various data (such as the Injection Function code and the path for the client-side trace library ) into the client's address space, using WriteProcessMemory function.","3) It initializes a shared heap memory.","4) It copies onto the heap a small piece of assembler code (a patch) that executes the jump to the function that creates thread in the client process.","5) It copies the injection function itself.","6) It patches the entry point of kernel32.dll so that the entry point points to the shared heap address where the assembler code is located. Because of the lack of \u201cCopy on Write\u201d mechanism in Windows-95, this patching applies also to the client process.","7) It resumes the main thread of the client process.","8) In the client process, the entry point of kernel32.dll is called and, thus, the applied patch starts execution. The patch performs the following operations:\n\n","9) If inst95_attach returns successfully, then the initial instrumentation of the client process is done and the tracing begins.","During a Process Attach, BugTrapper calls the inst95_attach_to_running_process function in the agent-side trace library . The inst95_attach_to_running_process function executes the following sequence of operations:","1) It initializes the communication channel for IPC with a client process.","2) It calls a function create remote thread (not to be confused with the CreateRemoteThread API call in Windows-NT), that performs the following operations:\n\n","A device driver, which will be further described below, intercepts the INT  interrupt that is caused by the first executed instruction of the above-mentioned valid thread. Upon receiving the interrupt, the device driver sets the instruction pointer to the start address of the injection function that was copied onto the shared heap, and clears the single step flag in the valid thread context. After clearing the single step flag, the driver proceeds as if the interrupt was successfully handled, and returns the control to Windows-95.","Since the instruction pointer now points to the injection function, the injection function starts to execute in the context of the client process. The injection function continues as in the case of Creation Attach described above and creates a new thread that subsequently performs the loading of the client-side trace library  into the address space of the client .","In order to leave the interrupted valid thread intact, the injection function executes the breakpoint instruction, which immediately causes an INT  interrupt that is intercepted by the device driver. The device driver restores the thread context that was stored immediately after the thread was suspended and then the device driver returns the control to Windows-95.","Tracing Execution","The trace function involves tracing the execution of the instrumented client process and reporting certain events to BugTrapper. The client-side trace library  accomplishes the tracing function by using breakpoints, and by reporting information concerning the status of the client process upon reaching the breakpoints.","During the execution of the client process, the execution trace is stored within a fixed size circular trace buffer  in memory. In the remote mode of operation the contents of the trace buffer  are copied to a trace log file . The trace log file  thus contains trace information that reflects a time window ending with the writing of the log file . The length of this time window is generally dependent upon the size of the trace buffer . In a preferred embodiment, the trace buffer  is small enough to allow the trace log file  to be sent to the developer's site using standard email programs. In the online mode of operation, the display is constantly being updated mirroring the trace buffer . The displayed information can also be saved to a log file  and later re-displayed.","After the client process has been attached, the process of tracing the execution of the client  involves the steps of installing breakpoints, triggering breakpoints, and catching breakpoints. Breakpoints are installed by overwriting the target address of the assembly instruction to be traced with an INT  instruction, occupying a single byte of space. The original byte at that address, along with other information, is stored in a data structure created by the agent-side trace library . The data structure, which describes all trace points, is preferably a hash table comprising a corresponding array of records for each hash value. The hashing is implemented with the target address as a parameter, allowing for a very fast searching for information concerning a trace point by using its address.","Breakpoints are triggered whenever the target address gets executed. When the target address is executed, the breakpoint instruction generates an INT  interrupt. On Windows NT\/2000 this interrupt is handled by the Windows-NT\/2000 kernel-mode handler. The kernel-mode handler transfers the execution to the user-mode routine KiUserExceptionDispatcher inside NTDLL.DLL (the system DLL). The KiUserExceptionDispatcher routine handles the task of locating a corresponding exception filter for the particular kind of exception.","Catching of breakpoints occurs within the context of the client . With standard debuggers, control would pass to the debugger process at this point. BugTrapper, takes a new approach, eliminating the need for context switching to properly trace the execution (for better performance). Since no context switching takes place, control remains with the client .","When the client-side trace library  is initially loaded, a patch is applied to the KiUserExceptionDispatcher function, having the effect of forcing a call to a function in the client-side trace library  before processing the exception. This function (the BugTrapper exception handler), determines whether the breakpoint occurred as a result of the tracing or for another reason. An exception that is not the result of tracing (i.e., no trace point has been installed at this target address) will result in a return of execution to KiUserExceptionDispatcher. When an exception is the result of the tracing, the handler notifies the appropriate routines in the tracing library  and defers the breakpoint, thereby allowing the original instruction at the target address to execute.","To defer a breakpoint, the original byte at the target address is restored, returning execution while setting a trap flag in the FLAGS register of an x86 processor. The trap flag causes an INT  interrupt to occur as a result of the execution of the original instruction. This interrupt is also treated as an exception, eventually reflecting into the BugTrapper exception handler. The handler restores the breakpoint instruction at the target address and returns for second time, allowing the client process code to continue running as if nothing happened.","In Windows 95\/98, interception of the INT and INT interrupts is done by a device driver. The driver registers its interrupt handler for INT and INT interrupts. When the interrupt handler is called, it checks to see if the interrupt occurred in the context of the client process. If the interrupt occurred in the client process, then the interrupt handler changes the instruction pointer of the thread to the address of a routine in the client-side trace library , and passes back on its stack any data needed by the function (such as thread context). After this function handles the trace point, it triggers an additional INT  interrupt that is recognized by the device driver. The device driver acts as if the interrupt has been successfully handled, causing the traced thread to continue execution. When the device driver recognizes that an interrupt has occurred not in the context of the client process, then the device driver passes the interrupt to the operating system interrupt handler (thus not affecting the normal behavior of other programs in the system or the operating system itself).","When tracing a plain source line (e.g., not a function entry or exit point), the client-side trace library  inserts data in the trace buffer to indicate that a trace point has been reached. When reaching a function entry trace point (apart from writing data to the trace buffer) a special mechanism is used because tracing of information regarding both the entry to and exit from the function is desired. This is preferably accomplished by modifying the return address of the function. The return address is located on the stack. The original return address is saved and a new return address point is inserted. The new return address points to a special assembly stub inside the client-side trace library . Therefore, when the function returns the assembly stub is called. The stub reports to the client-side trace library  function that the function has exited, and the client-side trace library  writes this trace point to the trace buffer. The stub then jumps to the real return address of the function.","In certain environments it is possible for a function to be entered but not properly exited. The function ceases running (with its stack erased and execution continuing elsewhere), but never returns to its caller. Therefore, for tracing purposes, it never returned to the BugTrapper assembly stub. For example, this would happen when a C++ exception occurs inside the a function and the exception handler at an outer function instructs the function generating the exception to exit, or when the setjmp( )\/longjmp( ) functions are used in C\/C++ programs. To detect and trace such events, the microprocessor's stack pointer register (ESP) is checked whenever a trace point triggers to determine whether any functions have exited. The stack pointer normally grows down. Its position is registered at the entry of each function together with the above-mentioned return address. If the stack pointer has moved to a higher point than that at entry, the function is deemed to have exited, and the client-side trace library  reports that the function has exited. Several different redundant checks are also performed to ensure the reliability of this mechanism.","Additional Tracing and Attaching Features","The BugTrapper attaching technology can be used with multi-process and multi-threaded applications. Every trace record is associated with a process and a thread. Stack information is separately kept for each context. Therefore, the BugTrapper can trace two or more client executables at the same time. This allows BugTrapper to display any context switches between the processes and threads of the client(s) .","The BugTrapper supports the tracing of Dynamically Linked Libraries (DLLs), including all sub-formats such as OCX, Active-X, drivers (DRV), etc. The tracing of DLLs is accomplished by analyzing the client  process to find the DLLs it uses, and by displaying the source structures of the DLLs to the user. The user can then specify trace points within the DLLs as is done for any other executable. When applying trace points to a DLL, BugTrapper finds the base address into which the DLL was loaded, and uses the address to translate the addresses in the debug information to actual addresses in the running image.","The BugTrapper also supports the tracing of DLLs for which no debug information is available, such as system DLL's. The tracing of such DLLs is accomplished by tracking the exported functions used by the DLLs. This is done by analyzing the DLL exported function table in the client  to retrieve information concerning the exported function names and addresses.","The BugTrapper also supports tracing of sub-processes. For example, when a first process P and a second process P are listed in the executable pane , and P spawns P as a sub-process, then BugTrapper will start tracing P. This is done by tracing the CreateProcess function in all of the traced processes, even if the developer  did not specify tracing the CreateProcess function. By tracing CreateProcess, BugTrapper will know that P spawned a sub-process, and BugTrapper can identify that the sub-process name (P in the present example) is listed in the executable pane . When the sub-process is created, BugTrapper will attach to the sub-process using the \u201cCreation Attach\u201d mechanism discussed above.","Variables and memory values can also be traced by BugTrapper. The user can view variable values as in an ordinary debugger. The variables may include function arguments, the C++\u201cthis\u201d pointer, function return values, local variables, global variables, static variables, etc. The data to which a pointer is pointing can also be traced. This information can be viewed for optimized builds, which cannot always be done by current debuggers. Tracking of variables in memory is accomplished by first analyzing the debug information to find the address (global, static, stack, or dynamic address) of the variable and the data it holds. BugTrapper then uses these addresses to dump to the trace log file  the memory content according to variable size.","When the traced application crashes, BugTrapper records the point where the failure occurred, even if the line was not specified in the TCI file . All stack variables are saved by using the Win32 debug API and the system library IMAGEHLP.DLL.","Interprocess Communication","Communication between the client-side trace library  and the agent-side trace library  (in the agent  or the analyzer ) can be divided into two categories. Category one comprises normal messages. Category two comprises trace data.","Category one communication is accomplished using standard Windows InterProcess Communication (IPC) primitives, such as shared memory to pass data, and semaphores to signal and synchronize. Normal messages include commands sent to the client-side trace library  such as, start trace function at a given address, or suspend tracing. Normal messages also include notifications sent by the client-side trace library , such as creation of a sub-process or run-time loading of a DLL.","The trace data itself is sent using a different mechanism, because of the quantity of data. Trace data comprises: function calls (including the assembly address of the called function); values of parameters for each call; function return values (including function address); tracing of other source lines specified in the TCI file  (including their address); variables value at these addresses; etc. The trace records are written to a shared memory area called the trace buffer , and from there either displayed in the BugTrapper user interface by the analyzer  (when performing an online trace) or written to a log file by the agent  (when performing a remote trace).","The client-side trace library  and the agent-side trace library  prevent simultaneous access to the trace buffer using standard locking mechanism such as Mutex (in Windows-95) or Interlocked Functions (in Windows-NT). For performance reasons, when collecting trace data, the client-side trace library  preferably only writes trace data to the trace buffer  in shared memory. The client-side trace library  preferably performs no I\/O to the disk or to the display. Disk I\/O and display updates are done later by the agent  or the analyzer . This reduces the performance penalty imposed on the client .","Indexing of the Trace Data","In order to process scrolling of the trace tree efficiently, there should desirably be direct access to records in the trace buffer  or trace log file . Serial access would be inefficient because it would require a search for the needed data in the trace buffer  upon every tree scroll operation. To facilitate direct access, an index is maintained with every trace tree window. The index contains the locations of all of the \u201cfunction call\u201d records in the trace buffer, which are included in the filter of the corresponding window in which the trace tree is displayed. In addition to the location information, some user-interface related information such as whether the record is invisible (\u201ccollapsed\u201d) is kept. The developer  can \u201ccollapse\u201d (remove from display) part of a tree which is located under a specific call in the tree hierarchy. Collapsing part of a tree influences the current displayed portion of the tree.","For example, assuming that only one record is displayed on a tree having a scroll bar, if the tree includes records (1 2 3 4 5) and the scroll bar is located at the middle, record 3 should be displayed. However, if records 2 and 3 are collapsed (leaving 1 4 5), then record 4 should be displayed. For a tree including more than a million lines, including thousands of collapsed records, the calculation of the location of the displayed portion of the trace data might be a time-consuming task. In order to do this efficiently, the analyzer  holds, together with the above-mentioned calls index, a special array SA, where SA[i] contains the number of visible records from record number 1000*i to 1000*(i+1). Use of the SA array greatly speeds up the task of locating desired trace information. For example, assume that records - are invisible (collapsed by the developer ) and that the vertical scroll bar position is 1500. In this case SA[0]=950 and the appropriate record is 1550. The analyzer  calculates this number directly, without the need to scan the whole calls index: 1000\u2212SA[0]+1500 (scroll bar position)=1550. The SA array provides for very fast vertical scrolling. The SA array is updated each time a new record is read from the trace buffer  or the log file , or when the developer  collapses or expands some of the trace tree. In general, when the analyzer  draws a trace tree, it performs the following steps: (1) lock the trace buffer ; (2) scan new records and update the calls index and the SA array; (3) read and analyze the records that must be shown; (4) merge the records with the debug information  and create strings for each record; (5) draw the page; and (6) unlock the shared memory trace buffer . Note that when reading data from a trace log file  only steps 3-5 are performed, since steps 1, 2, and 6 are unnecessary.","Visual Problem Monitor","In one embodiment, a visual problem monitor assists a support technician (e.g., a help desk person, a system administrator, etc.) in remotely analyzing problems by gathering run-time information about: program execution; interaction between the executing program and the operating system; system resources; user actions; file operations; failed operations and screen output. For example, file interactions, DLL loading and\/or registry accesses can be monitored non-intrusively. The support technician can remotely view user interactions with the program and corresponding reactions by the system. This mitigates (or in some cases eliminates) the \u201cquestions and answers\u201d game that support technicians usually play with users in order to understand what the user did and what happened on the customer's PC.","By using the dynamic analysis capabilities of the visual problem monitor, the support technician can check the parameters that influenced the program more effectively than by scanning static data gathered from the user's computer. For example, there is no need to check the versions of all the DLL's in the user's computer or to dump the entire registry from the user's computer. Rather, by using the visual problem monitor, the support technician can choose to view only the DLL's used by the traced program, or the registry entries or files accessed by the traced program. The visual problem monitor helps the support technician understand the details of problems in cases where programs produce cryptic messages and in cases where the programs simply crash without any specific error message.","In one embodiment, the visual problem monitor uses the executable hooking technology described above. The hooking technology allows trace points to be added to a running program while preserving the program's original operation. Support and help desk technicians can use this technology for tracing software interaction with the system and other API functions, without access to the source code, and therefore it does not require extra work to be done by the software vendors. In one embodiment, tracing of API functions using BugTrapper hooking technology requires one standard TCI file for all Windows applications.",{"@attributes":{"id":"p-0198","num":"0224"},"figref":"FIG. 15","b":["1500","1500","1501","1509","1502","1501","1506","1507","1508","1506","1507","1508","1503","1503","1509","1505","1504"]},"System interaction tracing allows support personnel to gather information about behavior of the program , and to diagnose sources of errors. The dynamic tracing mechanism provided by the visual problem monitor system  provides logging the following Windows API functions and GUI events:","Calls of Windows API functions related to:\n\n","The events are synchronized by time and logged into the log file . Several mechanisms can be used for gathering information for event logging. Monitoring of Win32 API calls can be done using any of the following tools and techniques:\n\n","One embodiment of the visual problem monitor system  uses the following logging mechanisms: (1) the hooking mechanism described above is used to gather event data for logging of Windows API functions; and (2) hooking to Windows messages related to keyboard and mouse events and screen updates is used to gather event data for logging of GUI interactions and screen capture. In one embodiment, standard data compression techniques are used for compression of the visual information and other records in the log file .","More specifically, the following system interaction functions are traced by the visual problem monitor system :\n\n","In one embodiment, the information collected by the information-gathering module  and stored in the log file  is passed to a remote support technician in order to allow the support technician to resolve software support issues related to the program . The log file  created by the information-gathering module  is transferred to the information-display module  running on the support technician's computer. The log file  can be transferred using email, WEB access, network file transfer protocols and the like.","The support technician can select between two modes of operation. In a first mode, the information-gathering module  is continuously active. When a problem occurs, the log file  is created. If the user chooses to call the help desk, the support technician can obtain the log file  and use it for analysis. In a second mode, the information-gathering module  is active on demand. In the second mode, when the user calls the help desk, the support technician activates the information-gathering module  on the user's computer and receives the log file  using network communication protocols. In one embodiment, the support technician receives the log file  by using a TCP\/IP-based communication protocol.","The information-display module  is used by the support technician to view the data from the log file  (as shown in  below). The information-display module  allows the support technician to filter the display to show only specific types of events or the whole scenario. In one embodiment, suspicious events (e.g. loading a non-existing DLL) are highlighted.",{"@attributes":{"id":"p-0207","num":"0277"},"figref":"FIG. 16","b":["1600","1502","1600","1609","1509","1608","1605","1509","1607","1509","1607","1509","1603","1606","1603","1603","1602","1601"]},"The GUI  provides verbalization of data from the log file . Events logged in the log file  are displayed as textual strings in plain English, or another natural language in the window . Thus the support technician and PC users need relatively less programming experience to use the system . In one embodiment, the screen captures shown in the window  are replayed synchronously with the even displays provided by the GUI . This allows the support technician to see what was happening on the user's screen when various events occurred in the user's system. Thus, for example, screen captures in the window  are replayed synchronously with the replay of events in the window , , etc. The support technician can use the controls  to control (e.g., pause, rewind, etc) the animated screen-capture display (in the window ) and the animated event displays provided by the GUI .","In one embodiment, the log file  is an extension of the trace log file  shown in . The log file  includes records related to logging of screen updates and user interaction with the application as follows:\n\n","In one embodiment, the recording of GUI-related objects is based on intercepting Windows messages by the message event hooking module . The message event hooking module  is supplied with an Attach(ThreadIdent) method that sets a hooking function with help of the Windows SetWindowsHookEx( ) function and creates an additional thread. The Hook( ) function in the current thread analyzes intercepted messages and window regions that are re-drawn. As a result, special messages are generated and directed to the additional thread for transforming into records and writing into DirectAccessStream objects.","The vlFramebufferUpdate records are generated to save bitmaps of invalidated regions of windows. In one embodiment, bitmaps are created by reading video memory using Microsoft DirectX methods. In one embodiment, each created bitmap stores only a minimal rectangle corresponding to the window update region.","A significant number of software problems arise from the deletion or corruption of critical files. In many cases the diagnostic messages issued by programs do not provide enough information for troubleshooting. The visual problem monitor system  provides more information about the missing file problem. Consider, for example, a simple example with Acrobat Reader. If font file Zd.pfb is missing, then the Acrobat Reader is not started and the user gets the cryptic message \u201cNo ZapfDingbats or Multiple Master fonts found.\u201d After getting this cryptic message, the user has to guess what happened with the application or the system and where it is possible to find the suddenly lacking fonts and how to restore the system to working order. A typical solution in such a case is to reinstall the whole application. Since the visual problem monitor system  tracks file access operations, the visual problem monitor system  can easily detect that the program lacks the file Zd.pfb in the directory C:\\Acrobat3\\Reader\\Fonts, thus providing a better way for the problem resolution.","DLL management represents a significant challenge for Windows users. The following scenario illustrates the problem. Assume that installation of a vendor's program overrides the system DLL mapi32.dll with an older version without any warning message. As a result, after installing the vendor's program the Microsoft Notepad+ program fails to send any mail and gives the user a nonspecific message \u201cSendMail failed to send message.\u201d Since the visual problem monitor system  tracks the use of DLLs, visual problem monitor system  can show a support technician that a function from mapi32.dll made a call to a nonexistent executable mapisrv.exe (the problem lies in MAPI version mismatch). In one implementation, visual problem monitor system  includes a DLL management module that monitors DLL-related operations and detects typical DLL problems.","In one embodiment, the visual problem monitor and the BugTrapper can be used in concert to locate problems in software. Support technicians typically analyze visual problem monitor trace information without access to the source code. When the problem is caused by a bug in the source code of the client program, the trace log is transferred to a software developer. Software developers can open visual problem monitor trace logs using the BugTrapper analyzer and by accessing source code can view the calls of traced API functions in the source code. The escalation workflow is illustrated in the flowchart  shown in . The flowchart  begins at a process block  where a visual problem monitor agent (comprising the event processing engine  and one or more of the hooking modules -) and the event knowledge database  (an API-level TCI file) is sent to a user (e.g., a customer) site. The process block  typically happens in response to a user complaint (regarding a software problem) to a support site. In a subsequent block , the user generates a trace log file  by running (or attempting to run) the malfunctioning program client in connection with the visual problem monitor agent. In a subsequent block , the trace log file  is transferred to the support site (e.g. by using the Internet, computer network, etc.). In a subsequent process block , the trace log file  is analyzed by using the visual problem monitor. If the reason for the software malfunction is found by using the visual problem monitor, then the process advances to a process block  where the user is informed of the nature of the problem and, typically, how to correct the problem; otherwise, the process advances to a process block . In the process block , the trace log file  is transferred to a developer (e.g., at a developer site). In a subsequent process block , the developer uses the BugTrapper source code analyzer (with application source code inputs from a process block ) to search for program bugs in the malfunctioning application.","Although the present invention has been described with reference to a specific embodiment, other embodiments will occur to those skilled in the art. It is to be understood that the embodiment described above has been presented by way of example, and not limitation, and that the invention is defined by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A software system which embodies the various features of the invention will now be described with reference to the following drawings.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 17"}]},"DETDESC":[{},{}]}
