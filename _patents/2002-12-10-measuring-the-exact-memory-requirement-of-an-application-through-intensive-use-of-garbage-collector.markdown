---
title: Measuring the exact memory requirement of an application through intensive use of garbage collector
abstract: Method and apparatus are disclosed for the intensive use of garbage collection in order to determine the exact amount of memory that is consumed by a running application at any point of its execution. A garbage collector executes immediately prior to allocations of memory during execution of a program. The amount of memory used by the application is known after each such allocation of memory, and is very close to or equal to its theoretical requirement. A developer is also enabled to determine whether a specified memory allotment for an application is ever exceeded.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06898602&OS=06898602&RS=06898602
owner: Sun Microsystems Inc.
number: 06898602
owner_city: Palo Alto
owner_country: US
publication_date: 20021210
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","COMPUTER PROGRAM LISTINGS"],"p":["This Application claims the benefit of Provisional Application No. 60\/375,147 filed Apr. 22, 2002. This Application is related to another U.S. patent application, entitled \u201cMeasuring Maximum Memory Requirement of an Application at any Point through Continuous Use of Garbage Collector\u201d, filed on even date herewith.","1. Field of the Invention","This invention relates to improvements in computer memory management. More particularly, this invention relates to the determination of the amount of available memory in a running computer application.","2. Description of the Related Art","The terms Sun, Sun Microsystems, Java, J2ME, and the Sun logo are trademarks or registered trademarks of Sun Microsystems, Inc., in the United States of America, and other countries. All other company and product names may be trademarks of their respective companies.","The Mobile Information Device Profile (MIDP) defines a set of Java application programming interfaces (APIs) that provide an application runtime environment for mobile information devices, such as cellular telephones. MIDP is defined in the document (JSR-37), JCP Specification, Java 2 Platform, Micro Edition, 1.0a (Sun Microsystems Inc., Palo Alto, Calif., December 2000), which is incorporated herein by reference. MIDP builds on the Connected Limited Device Configuration (CLDC) of the Java 2 Platform, Micro Edition (J2ME). MIDP applications that use the MIDP and CLDC APIs are known as MIDlets.","Mobile information devices typically have a very small memory, low-speed graphics, and slow communications performance, when compared with personal computers (PCs). While programmers commonly develop applications using personal computers as development platforms, the memory and speed limitations of the target mobile information devices must be taken into account in order for the applications to run satisfactorily on the target devices. In particular, the memory capacity in mobile information devices is often a limiting factor in program development.","In early programming languages, memory allocation and deallocation was a burden imposed directly on the programmer, who was responsible to allocate and deallocate memory blocks. This burden was essentially eliminated over 40 years ago by the invention of garbage collectors, which are programs that deallocate memory that is assigned to dead or unreachable objects. Garbage collectors have greatly improved programmer productivity, and have enhanced software reliability. They are supported by modern programming languages, such as Java. A variety of different garbage collection techniques is now known in the art.","In general it is not possible for a garbage collector to determine exactly which objects are still live. It is commonly assumed by implementers of garbage collection routines that a live object is reachable or can be proven to be referenced. Nevertheless, the inability to guarantee that an object is live inconveniences a program developer who is working in an environment in which memory is a limiting resource. As supported in most languages, garbage collection is an asynchronous process. It is typically invoked automatically by the computer system at runtime when the amount of memory allocated by the running program reaches some limit, which depends on the amount of memory actually available in the system. Therefore, the developer is generally unable to determine at any particular point in the execution of the application how much of the memory allocated to the application is actually required, and how much is merely preempted by objects that are no longer reachable. Furthermore, it is often desirable to reduce the memory requirement of an application at critical points in its execution. At present, this cannot be done deterministically in the context of small wireless devices, such as cellular telephones, using current garbage collection techniques.","In accordance with a disclosed embodiment of the invention, a developer is enabled to determine the amount of memory that is consumed by a running application at any point of its execution.","According to one disclosed embodiment of the invention, a garbage collector executes immediately prior to at least some allocations of memory that take place during execution of a program. Consequently at these steps, no memory allocation ever occurs until all unreachable memory has been reclaimed. The amount of memory used by the application is known after each such allocation of memory, and is very close to or equal to its theoretical requirement.","In another embodiment the garbage collector is invoked at each instruction at which an allocation of memory occurs.","A developer of an application for a device with a small memory, such as a MIDP device, can use this feature of the present invention to tailor the memory requirements of the application to comply with the memory limitations of the device, even when the developer is writing the application on a workstation with a much larger memory.","The invention provides a method for evaluating memory storage requirements of a computer application, including executing code of the application on a development platform, designating program instructions in the code at which garbage collection is to be performed on a heap memory, running a garbage collector to free a portion of the memory from the heap that is no longer in use at each of the designated program instructions. After running the garbage collector, the amount of the memory that is still in use in the heap is determined, and an indication of the amount of the memory that is still in use at each of the designated program instructions is returned.","In an additional aspect of the method, particular ones of the program instructions are designated, wherein an allocation of the memory for an object occurs on the heap.","According to one aspect of the method, the code is software code.","According to a further aspect of the method, the code is embedded in hardware.","In another aspect of the method, the amount of the memory that is still in use is shown on a screen display.","According to a further aspect of the method, the application is a MIDlet adapted to execute on a mobile information device.","According to yet another aspect of the method, the mobile information device is MIDP compliant.","Still another aspect of the method includes determining whether the amount of the memory that is still in use exceeds a predetermined value at each of the designated program instructions.","The invention provides a computer software product, including a computer-readable medium in which computer program instructions are stored, which instructions, when read by a computer, cause the computer to perform a method for evaluating memory requirements of a computer application, including executing code of the application, identifying locations in the code at which garbage collection is to be performed for a memory that is allocated in a heap, running a garbage collector to free at least a portion of the memory from the heap that is no longer in use prior to each of the identified locations, and after running the garbage collector, determining an amount of the memory that is still in use in the heap, and thereafter returning an indication of the amount of the memory.","In one aspect of the computer software product, the step of identifying locations is performed by designating each of the locations in the code that correspond to completion of consecutive statements of the computer program as requiring garbage collection.","In another aspect of the computer software product, the step of identifying locations is performed by designating particular ones of the locations that correspond to statements of the computer program that are associated with an allocation of the memory for an object as requiring garbage collection.","In yet another aspect of the computer software product, the step of returning an indication is performed by plotting the amount of the memory that is still in use on a screen display.","According to still another aspect of the computer software product, the application is a MIDlet adapted to execute on a mobile information device.","According to an additional aspect of the computer software product, the mobile information device is MIDP compliant.","One aspect of the computer software product includes the step of determining whether the amount of the memory that is still in use exceeds a predetermined value at each of the identified locations.","The invention provides a development system for evaluating memory requirements of a computer application, including a user interface adapted for executing code of the application. The user interface is further adapted for identification of locations in the code at which garbage collection is to be performed. The system includes a memory, containing a data structure therein that has stored computer instructions that are invokable via the user interface for allocation of a heap. The instructions include a first instruction to invoke a garbage collector for the heap, a second instruction to reserve a portion of the heap for an object has a specified size, and a third instruction to return an indication of an amount of the heap that is still is used by the application.","According to another aspect of the development system, the user interface has a facility to designate the locations in the code that occur between pairs of program statements of the application as requiring garbage collection.","According to a further aspect of the development system, user interface has a facility to designate particular ones of the locations, which have instructions that result in an allocation of the heap for the object as requiring garbage collection.","According to yet another aspect of the development system, the code is software code.","According to still another aspect of the development system, the code is stored in hardware.","According to still another aspect of the development system, the user interface responds to the indication by plotting the indication on a screen display.","According to an additional aspect of the development system, the application is a MIDlet adapted to execute on a mobile information device.","According to one aspect of the development system, the mobile information device is MIDP compliant.","According to another aspect of the development system, the user interface reports a determination whether the amount of the heap that is still is used by the application exceeds a predetermined value.","In the following description, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent to one skilled in the art, however, that the present invention may be practiced without these specific details. In other instances well-known circuits, control logic, and the details of computer program instructions for conventional algorithms and processes have not been shown in detail in order not to unnecessarily obscure the present invention.","Software programming code, which embodies aspects of the present invention, is typically maintained in permanent storage, such as a computer readable medium. In a client\/server environment, such software programming code may be stored on a client or a server. The software programming code may be embodied on any of a variety of known media for use with a data processing system, such as a diskette, or hard drive, or CD-ROM. The code may be distributed on such media, or may be distributed to users from the memory or storage of one computer system over a network of some type to other computer systems for use by users of such other systems. The techniques and methods for embodying software program code on physical media and distributing software code via networks are well known and will not be further discussed herein.","Although the embodiments described in this provisional patent application make use of particular features and vocabulary of the Java language and operating environments, and refer specifically to mobile device applications, the present invention is not limited to this context or to the particular implementation tools described here. Rather, the principles of the present invention may be applied using other programming languages, and may be used to solve problems of resource mismatches that may arise in development of applications for different sorts of target platforms.","A modification of a standard memory allocation function mallocHeapObject( ) is shown in Listing . Conventionally a call to the function mallocHeapObject( ) simply allocates a contiguous block of heap memory according to a parameter \u201csize\u201d. According to a disclosed embodiment of the invention, the function mallocHeapObject( ) is modified by provision of a global Boolean variable \u201cexcessive_gc\u201d. A test of the variable excessive_gc is made in the function mallocHeapObject( ) prior to any attempt to allocate memory. If the variable excessive_gc is set, then the system garbage collector is immediately invoked, and there is a delay until garbage collection is complete. A parameter having a value 0 in the parameter list of the garbage collector indicates that all heap memory is to be swept. Heap memory is allocated upon completion of garbage collection. Following a successful memory allocation, the amount of memory actually used by the calling application is available in a global variable \u201cmemory_used\u201d. Prior to exiting the function mallocHeapObject( ) a test of another global Boolean variable \u201ctrace_usage\u201d is made. If the variable trace_usage is set, then a display of memory usage is activated. This is explained in further detail hereinbelow.","First Embodiment.","Reference is now made to , which is a high level block diagram of a system  adapted to determine the amount of memory that is in use during development of an application for a target device in accordance with a disclosed embodiment of the invention. Typically, a developer  is attempting to create an application for a mobile information device , which can be MIDP compliant. The application may be ultimately embedded in hardware or installed in a memory as software. Typically, development is done using a conventional workstation , such as a personal computer, and then the application is transferred to the mobile information device  as a computer software product stored on a memory device  that is adapted to the mobile information device . Alternatively, the application can be downloaded to the mobile information device  via a link . The application can then be tested in the operating environment of the mobile information device . As memory on the mobile information device  is generally a critical resource, the developer  needs to determine the amount of memory that is in use in a heap at specific points in the application. Additionally or alternatively, it may be desired to assure that no more memory than necessary is allocated to the application under development at specific points during its execution. For example, it may be required that the application under development never causes other concurrently executing applications to be starved for memory.","Reference is now made to , which is a flow chart illustrating the application of the function mallocHeapObject( ) according to a disclosed embodiment of the invention suitable for use with the system  (FIG. ). The process begins at initial step  at which program development is commenced. Next, at step  a program statement is read from working memory and evaluated.","Control now passes to decision step , where a determination is made whether the program statement developed in step  requires memory to be allocated for an object. If the determination at decision step  is negative, then control proceeds to step , which is disclosed below.","If the determination at decision step  is affirmative, then control proceeds to step . Garbage collection is begun. Control then proceeds to delay step , where the completion of garbage collection is awaited.","Upon completion of the delay step , memory is allocated at step  for the object as determined in decision step .","Next control proceeds to step . Step  is also performed in the event that the determination at decision step  was negative. Here memory usage by the application is reported. This can be done on a console display, or via a graphical user interface. Alternatively, the memory usage can be written to a log file. It will be noted that step  is performed regardless of whether step  needed to be performed. This is useful for plotting memory use against the number of program statements, and for verifying that no adverse events have occurred, for example unintended memory deallocations.","Next, at decision step  a determination is made whether more program statements remain to be written. If the determination at decision step  is affirmative, then control returns to step .","If the determination at decision step  is negative, then control proceeds to final step , and the process ends.","Reference is now made to , which is a flow chart illustrating a practical use of the method disclosed with reference to , in which the developer can determine if a predetermined memory size specification of a program is exceeded. It is to be emphasized that the process disclosed with reference to  is exemplary. Many other valuable uses for the inventive method may occur to those engaged in the art of software development. The process begins at initial step . A program written using the method of  is prepared for execution. The developer may execute the program step-wise, or alternatively, he may elect to perform a continuous execution, and perform the steps disclosed below as a retrospective analysis with reference to appropriate log files.","At step  a program statement is executed. Control then passes to decision step , where it is determined whether garbage collection occurred during step . If the determination at decision step  is negative, then control proceeds to decision step , which is disclosed below.","If the determination at decision step  is affirmative, then at step  the amount of memory used by the program is noted.","Control now passes to decision step , where it is determined whether the quantity of memory used that was noted in step  exceeds a specified threshold. If the determination at decision step  is negative, then control proceeds to decision step , which is disclosed below.","If the determination at decision step  is affirmative, then at step  it is recorded that a design flaw was revealed at the program statement that was executed in step . Control proceeds to decision step .","At decision step  a determination is made whether more program statements remain to be executed, or retrospectively analyzed. If the determination at decision step  is affirmative, then control returns to step .","If the determination at decision step  is negative, then the process ends at final step .","Second Embodiment.","While a near optimum use of memory is achieved using the first embodiment, there are circumstances in which it is necessary to guarantee that the use of memory by an executing application does not exceed its theoretical minimum. The second embodiment is similar to the first embodiment, except now garbage collection is invoked between each pair of program instructions. In one variation, garbage collection can be forced by simply calling the garbage collector. This may be done directly, provided the garbage collector is exposed to the programmer. Otherwise, the function mallocHeapObject( ) (Listing ) may be called, setting the parameter size to a value of zero. In such a case, the garbage collector is invoked as a side effect of the function, but the amount of memory allocated to the program does not change. The technique is illustrated by the pseudocode fragment of Listing . It should be noted that allocations of memory by program instructions are irrelevant, in that they do not instigate garbage collection.","Some programming environments support memory monitors, which can be activated during step-wise program execution. If a memory monitor is available, explicit calls to the function mallocHeapObject( ) need not be written as shown in Listing . Instead, calls to the garbage collector and the display of current memory use by the application are automatically accomplished by the system kernel at or following execution of each program instruction.","Reference is now made to , which is a flow chart illustrating a method of determining the maximum memory requirement of an application at any point through continuous use of garbage collection according to the second embodiment of the invention. The process begins at initial step  where an application to be tested is installed in a development platform. The development platform can be a target device, such as a mobile information device, or a general purpose computer, operating in an emulation mode if necessary, in order to execute the instructions of the target device.","Next, at step  a range of program instructions in the code is established for testing. The maximum heap memory requirements of the application will be determined by testing successive instructions within the range. The range may encompass all pairs of instructions between the first and the last instruction of the application, or can be a smaller range. A memory location is designated to hold a high-water mark of the heap size for the application as execution proceeds and is initialized to zero.","Next, at decision step  a determination is made whether instructions are executing within the range selected in step . This is typically done by examining the state of the program counter. If the determination at decision step  is negative, then control proceeds to final step , and the procedure terminates. The value of the high-water mark stored in the memory location that was reserved for the high-water mark in step  is reported to the operator.","If the determination at decision step  is affirmative, then control proceeds to step . A program instruction is executed. Typically, a program counter is advanced following completion of the instruction.","Next, at step , garbage collection is performed. Intensive invocation of the garbage collection routine following each instruction may delay completion of the application, but provides valuable information to the developer.","Next, at step , the current heap size is determined.","Next, at decision step  a determination is made whether the heap size that was determined in step  exceeds the contents of the memory location that was reserved for the high-water mark in step .","If the determination at decision step  is negative, then control returns to decision step .","If the determination at decision step  is affirmative, then control proceeds to step . A new high-water mark or maximum heap size for the application is established control. The heap size that was determined in step  is stored in the memory location that was reserved for the high-water mark in step . Control then returns to decision step .","Reference is now made to , which is a plot of memory use of a test application for a mobile information device, which was taken from a screen display of a memory monitor in accordance with a disclosed embodiment of the invention. The function mallocHeapObject( ) (Listing ) was called during execution in the manner disclosed for the second embodiment. The variable trace_usage was set, thereby enabling operation of the memory monitor. However, the variable excessive_gc was not set. Thus, the function mallocHeapObject( ) behaved as a conventional memory allocation function, without intensive garbage collection. The maximum memory usage, 94,280 bytes, is found at a statement , as measured by the memory monitor. A current statement  is associated with a memory usage of 52,892 bytes.","Reference is now made to , which is a plot of memory use of the test application shown in  in accordance with a disclosed embodiment of the invention. The plot was taken under the same conditions as that of , except that the variable excessive_gc was set. A statement  and a statement  correspond respectively to the statement  and the statement . The memory usage associated with the statement  was measured maximally at 11,980 bytes. At the statement , the memory usage was measured at 9,304 bytes. The difference between the plot of FIG.  and  may be attributed to intensive collection of inaccessible objects during the execution illustrated in FIG. .","It will be appreciated by persons skilled in the art that the present invention is not limited to what has been particularly shown and described hereinabove. Rather, the scope of the present invention includes both combinations and sub-combinations of the various features described hereinabove, as well as variations and modifications thereof that are not in the prior art, which would occur to persons skilled in the art upon reading the foregoing description.",{"@attributes":{"id":"p-0079","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"* = = = = = = = = = = ====== = = = = = = = = = = = = = *\/"},{"entry":"* FUNCTION: mallocHeapObject( )"},{"entry":"* TYPE: public memory allocation operation"},{"entry":"* OVERVEIW: Allocate a contiguous area of n cells in the"},{"entry":"* dynamic heap."},{"entry":"* INTERFACE:"},{"entry":"* parameters: size: the requested object size in cells,"},{"entry":"* returns: pointer to newly allocated area, or"},{"entry":"* NULL if allocation fails."},{"entry":"* = = = = = = = = = = ====== = = = = = = = = = = = = = *\/"},{"entry":"cell* mallocHeapObject (long size)"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"cell* thisChunk;"]},{"entry":[{},"if (excessive_gc) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"garbageCollect (0);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"thisChunk = allocateFreeChunk(size);"]},{"entry":[{},"\/* allocation failed, run garbageCollect( ) *\/"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"garbageCollect(size); \/* So it knows what we need *\/"]},{"entry":[{},"thisChunk = allocateFreeChunk(size);"]},{"entry":[{},"if (thisChunk == NULL) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* allocation failed, not enough memory *\/"]},{"entry":[{},"return NULL;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"if (max_memory < memory_used) max_memory = memory_used;"]},{"entry":[{},"if (trace_memory) show_memory_usage( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0080","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Listing 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003Statement 1;"]},{"entry":[{},"#if DEBUG"]},{"entry":[{},"\u2003mallocHeapObject(0);"]},{"entry":[{},"#endif"]},{"entry":[{},"\u2003Statement 2;"]},{"entry":[{},"#if DEBUG"]},{"entry":[{},"\u2003mallocHeapObject(0);"]},{"entry":[{},"#endif"]},{"entry":[{},"\u2003Statement 3;"]},{"entry":[{},"."]},{"entry":[{},"."]},{"entry":[{},"."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a better understanding of these and other objects of the present invention, reference is made to the detailed description of the invention, by way of example, which is to be read in conjunction with the following drawings, wherein:",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 6","FIG. 5"]}]},"DETDESC":[{},{}]}
