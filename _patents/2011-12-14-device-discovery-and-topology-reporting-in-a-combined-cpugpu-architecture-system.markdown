---
title: Device discovery and topology reporting in a combined CPU/GPU architecture system
abstract: Methods and apparatus are provided, as an aspect of a combined CPU/APD architecture system, for discovering and reporting properties of devices and system topology that are relevant to efficiently scheduling and distributing computational tasks to the various computational resources of a combined CPU/APD architecture system. The combined CPU/APD architecture unifies CPUs and APDs in a flexible computing environment. In some embodiments, the combined CPU/APD architecture capabilities are implemented in a single integrated circuit, elements of which can include one or more CPU cores and one or more APD cores. The combined CPU/APD architecture creates a foundation upon which existing and new programming frameworks, languages, and tools can be constructed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08797332&OS=08797332&RS=08797332
owner: Advanced Micro Devices, Inc.
number: 08797332
owner_city: Sunnyvale
owner_country: US
publication_date: 20111214
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY OF EMBODIMENTS","DETAILED DESCRIPTION","Conclusion"],"p":["This application claims the benefit of U.S. Provisional Application No. 61\/423,565, filed on Dec. 15, 2010 and is incorporated by reference in its entirety.","1. Field of the Invention","The present invention is generally directed to computer systems. More particularly, the present invention is directed to computer system topology.","2. Background Art","The desire to use a graphics processing unit (GPU) for general computation has become much more pronounced recently due to the GPU's exemplary performance per unit power and\/or cost. The computational capabilities for GPUs, generally, have grown at a rate exceeding that of the corresponding central processing unit (CPU) platforms. This growth, coupled with the explosion of the mobile computing market (e.g., notebooks, mobile smart phones, tablets, etc.) and its necessary supporting server\/enterprise systems, has been used to provide a specified quality of desired user experience. Consequently, the combined use of CPUs and GPUs for executing workloads with data parallel content is becoming a volume technology.","However, GPUs have traditionally operated in a constrained programming environment, available primarily for the acceleration of graphics. These constraints arose from the fact that GPUs did not have as rich a programming ecosystem as CPUs. Their use, therefore, has been mostly limited to two dimensional (2D) and three dimensional (3D) graphics and a few leading edge multimedia applications, which are already accustomed to dealing with graphics and video application programming interfaces (APIs).","With the advent of multi-vendor supported OpenCL\u00ae and DirectCompute\u00ae, standard APIs and supporting tools, the limitations of the GPUs in traditional applications has been extended beyond traditional graphics. Although OpenCL and DirectCompute are a promising start, there are many hurdles remaining to creating an environment and ecosystem that allows the combination of a CPU and a GPU to be used as fluidly as the CPU for most programming tasks.","Existing computing systems often include multiple processing devices. For example, some computing systems include both a CPU and a GPU on separate chips (e.g., the CPU might be located on a motherboard and the GPU might be located on a graphics card) or in a single chip package. Both of these arrangements, however, still include significant challenges associated with (i) separate memory systems, (ii) efficient scheduling, (iii) providing quality of service (QoS) guarantees between processes, (iv) programming model, and (v) compiling to multiple target instruction set architectures (ISAs)\u2014all while minimizing power consumption.","For example, the discrete chip arrangement forces system and software architects to utilize chip to chip interfaces for each processor to access memory. While these external interfaces (e.g., chip to chip) negatively affect memory latency and power consumption for cooperating heterogeneous processors, the separate memory systems (i.e., separate address spaces) and driver managed shared memory create overhead that becomes unacceptable for fine grain offload.","Both the discrete and single chip arrangements can limit the types of commands that can be sent to the GPU for execution. By way of example, computational commands (e.g., physics or artificial intelligence commands) often should not be sent to the GPU for execution. This performance-based limitation exists because the CPU may relatively quickly require the results of the operations performed by these computational commands. However, because of the high overhead of dispatching work to the GPU in current systems and the fact that these commands may have to wait in line for other previously-issued commands to be executed first, the latency incurred by sending computational commands to the GPU is often unacceptable.","Given that a traditional GPU may not efficiently execute some computational commands, the commands must then be executed within the CPU. Having to execute the commands on the CPU increases the processing burden on the CPU and can hamper overall system performance.","Although GPUs provide excellent opportunities for computational offloading, traditional GPUs may not be suitable for system-software-driven process management that is desired for efficient operation in a multi-processor environment. These limitations can create several problems.","For example, since processes cannot be efficiently identified and\/or preempted, a rogue process can occupy the GPU hardware for arbitrary amounts of time. In other cases, the ability to context switch off the hardware is severely constrained\u2014occurring at very coarse granularity and only at a very limited set of points in a program's execution. This constraint exists because saving the necessary architectural and microarchitectural states for restoring and resuming a process is not supported. Lack of support for precise exceptions prevents a faulted job from being context switched out and restored at a later point, resulting in lower hardware usage as the faulted threads occupy hardware resources and sit idle during fault handling.","Combining CPU, GPU, an I\/O memory management into a unified architecture such that computational tasks can be efficiently scheduled and distributed requires system and application software to have some knowledge of the features, properties, interconnections, and attributes of the unified CPU\/GPU system architecture.","What is needed are improved methods and apparatus for discovering and reporting properties of devices and system topology that are relevant to efficiently scheduling and distributing computational tasks to the various computational resources of a system implementing a combined CPU\/GPU architecture.","Although GPUs, accelerated processing units (APUs), and general purpose use of the graphics processing unit (GPGPU) are commonly used terms in this field, the expression \u201caccelerated processing device (APD)\u201d is considered to be a broader expression. For example, APD refers to any cooperating collection of hardware and\/or software that performs those functions and computations associated with accelerating graphics processing tasks, data parallel tasks, or nested data parallel tasks in an accelerated manner compared to conventional CPUs, conventional GPUs, software and\/or combinations thereof.","Methods and apparatus are provided, as an aspect of a combined CPU\/APD architecture system, for discovering and reporting properties of devices and system topology that are relevant to efficiently scheduling and distributing computational tasks to the various computational resources of a combined CPU\/APD architecture system. The combined CPU\/APD architecture unifies CPUs and APDs in a flexible computing environment. In some embodiments, the combined CPU\/APD architecture capabilities are implemented in a single integrated circuit, elements of which can include one or more CPU cores and one or more APD cores. The combined CPU\/APD architecture creates a foundation upon which existing and new programming frameworks, languages, and tools can be constructed.","Generally, software should be aware of the properties of the underlying hardware to be better able to leverage the performance capabilities of the platform for feature utilization and task scheduling. In order to efficiently utilize the computational resources of a combined CPU\/APD architecture system, the features, properties, interconnections, attributes and\/or characteristics of the platform must be discovered and reported to the software.","Methods and apparatus are provided, as an aspect of a combined CPU\/APD architecture system, for discovering and reporting properties of devices and system topology that are relevant to efficiently scheduling and distributing computational tasks to the various computational resources of a combined CPU\/APD architecture system. The combined CPU\/APD architecture in accordance with the invention unifies CPUs and APDs in a flexible computing environment.","In some embodiments, the combined CPU\/APD architecture capabilities are implemented in a single integrated circuit, elements of which can include one or more CPU cores and one or more unified APD cores, as explained in greater detail below. In contrast to the traditional computing environment where the CPU and APD are typically separate (e.g., residing on separate cards or boards or in separate packages), the combined CPU\/APD architecture creates a foundation upon which existing and new programming frameworks, languages, and tools can be constructed.","The unified environment of the combined CPU\/APD system architecture enables programmers to write applications that seamlessly transition processing of data between CPUs and APDs, benefiting from the best attributes each has to offer. A unified single programming platform can provide a strong foundation for development in languages, frameworks, and applications that exploit parallelism.","In the detailed description that follows, references to \u201cone embodiment,\u201d \u201can embodiment,\u201d \u201can example embodiment,\u201d etc., indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same embodiment. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to affect such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described.","The term \u201cembodiments of the invention\u201d does not require that all embodiments of the invention include the discussed feature, advantage or mode of operation. Alternate embodiments may be devised without departing from the scope of the invention, and well-known elements of the invention may not be described in detail or may be omitted so as not to obscure the relevant details of the invention. In addition, the terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. For example, as used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the terms \u201ccomprises,\u201d \u201ccomprising,\u201d \u201cincludes\u201d and\/or \u201cincluding,\u201d when used herein, specify the presence of stated features, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, steps, operations, elements, components, and\/or groups thereof.","Conventional mechanisms for CPU-based feature detection and scheduling, such as CPU identification (CPUID), run into severe limitations even for the homogeneous and comparatively simple CPU topologies that are commonly used in today's operating systems and platforms.","In order to properly configure the input\/output memory management unit (IOMMU), it is necessary to discover the topology of the CPU\/memory\/APD\/network (e.g., add-in boards, memory controller, north\/south bridge, etc.). Similarly, in order to make scheduling and workload decisions appropriately, application software needs information such as how many different APDs and compute units are available and what properties the APDs and compute units possess. Therefore one or more processes, one or more hardware mechanisms, or a combination of both are needed for device discovery and topology reporting in accordance with the present invention. More generally, at least one mechanism, at least one process, or at least one mechanism and at least one process are needed for device discovery and topology reporting.","In one embodiment of the present invention, information regarding devices and topology is encoded prior to being reported to the application software. One way is to provide a table according to the advanced configuration and power interface (ACPI) specifications to the operating system level and then on to the user mode level. Information relevant to discovery of devices and topology and having utility for scheduling and workload decision making may be communicated by way of such a table. The table may include, but is not limited to, locality information (e.g., which memory is closest to the APD). By \u201cclosest\u201d, it is typically meant that that memory is physically closest since shorter signal paths usually mean lighter loading and shorter signal transit times. However \u201cclosest\u201d as used herein more broadly includes the memory that is operable to transfer data most quickly.","With respect to CPU\/scalar compute cores, the discoverable properties include, but are not limited to, number of cores, number of caches, and cache topology (e.g., cache affinity, hierarchy, latency), translation lookaside buffer (TLB), floating point unit (FPU), performance states, power states, and so on. Some properties, such as, for example, number of cores per socket and cache sizes, are currently exposed through the CPUID instruction. Additional properties, such as, for example, number of sockets, socket topology, performance\/power states, etc., are or will be exposed through ACPI tables as defined through ACPI definitions which apply to conventional systems. The CPU cores may be distributed across different \u201clocality domains\u201d non-uniformity memory architecture (NUMA); however, to a first order, the cores are uniformly managed by the OS and virtual memory manager (VMM) schedulers.","With respect to APD compute cores, discoverable properties include, but are not limited to, single instruction multiple data (SIMD) size, SIMD arrangement, local data store affinity, work queue properties, CPU core, and IOMMU affinity, hardware context memory size and so on. Some discrete APD cores may be attachable or detachable from a live platform, while integrated APD cores may be hardwired or part of an accelerated processing unit in accordance with embodiments of the present invention.","With respect to support components, discoverable components include extended peripheral component interconnect (PCIe) switches, memory controller channels and banks on either the APU or discrete APD, and non-compute I\/O devices (AHCI, USB, display controller, etc.). System and APD local memory may expose various coherent and non-coherent access ranges that the operating system manages differently, and which may have specific affinity to CPU or APD. Other data path properties, including but not limited to, type, width, speed, coherence property, and latency, may be discoverable. Some properties are exposed through PCI-E capability structures or ACPI tables; however, not all properties relevant to device discovery and topology reporting can currently be expressed with conventional mechanisms.","CPUID refers to an instruction which, when executed by a computational resource such as a CPU, provides information about its particular features and characteristics. For example, an x86 architecture CPU may provide information such as vendor ID, processor information and feature bits, cache and TLB descriptor information, processor serial number, highest extended function supported, extended processor information and feature bits, processor brand string, L1 cache and TLB identifiers, extended L2 cache features, advanced power management information, and virtual and physical address sizes.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 1A","b":["100","102","104","102","100","102","104","104","102","102","104"]},"In one example, system  also includes a memory , an operating system , and a communication infrastructure . The operating system  and the communication infrastructure  are discussed in greater detail below.","The system  also includes a kernel mode driver (KMD) , a software scheduler (SWS) , and a memory management unit , such as an IOMMU. Components of system  can be implemented as hardware, firmware, software, or any combination thereof. A person of ordinary skill in the art will appreciate that system  may include one or more software, hardware, and firmware components in addition to, or different from, that shown in the embodiment shown in .","In one example, a driver, such as KMD , typically communicates with a device through a computer bus or communications subsystem to which the hardware connects. When a calling program invokes a routine in the driver, the driver issues commands to the device. Once the device sends data back to the driver, the driver may invoke routines in the original calling program. In one example, drivers are hardware-dependent and operating-system-specific. They usually provide the interrupt handling required for any necessary asynchronous time-dependent hardware interface.","Device drivers, particularly on modern Microsoft Windows\u00ae platforms, can run in kernel-mode (Ring 0) or in user-mode (Ring 3). The primary benefit of running a driver in user mode is improved stability, since a poorly written user mode device driver cannot crash the system by overwriting kernel memory. On the other hand, user\/kernel-mode transitions usually impose a considerable performance overhead, thereby prohibiting user mode-drivers for low latency and high throughput requirements. Kernel space can be accessed by user module only through the use of system calls. End user programs like the UNIX shell or other GUI based applications are part of the user space. These applications interact with hardware through kernel supported functions.","CPU  can include (not shown) one or more of a control processor, field programmable gate array (FPGA), application specific integrated circuit (ASIC), or digital signal processor (DSP). CPU , for example, executes the control logic, including the operating system , KMD , SWS , and applications , that control the operation of computing system . In this illustrative embodiment, CPU , according to one embodiment, initiates and controls the execution of applications  by, for example, distributing the processing associated with that application across the CPU  and other processing resources, such as the APD .","APD , among other things, executes commands and programs for selected functions, such as graphics operations and other operations that may be, for example, particularly suited for parallel processing. In general, APD  can be frequently used for executing graphics pipeline operations, such as pixel operations, geometric computations, and rendering an image to a display. In various embodiments of the present invention, APD  can also execute compute processing operations (e.g., those operations unrelated to graphics such as, for example, video operations, physics simulations, computational fluid dynamics, etc.), based on commands or instructions received from CPU .","For example, commands can be considered as special instructions that are not typically defined in the instruction set architecture (ISA). A command may be executed by a special processor such a dispatch processor, command processor, or network controller. On the other hand, instructions can be considered, for example, a single operation of a processor within a computer architecture. In one example, when using two sets of ISAs, some instructions are used to execute x86 programs and some instructions are used to execute kernels on an APD compute unit.","In an illustrative embodiment, CPU  transmits selected commands to APD . These selected commands can include graphics commands and other commands amenable to parallel execution. These selected commands, that can also include compute processing commands, can be executed substantially independently from CPU .","APD  can include its own compute units (not shown), such as, but not limited to, one or more SIMD processing cores. As referred to herein, a SIMD is a pipeline, or programming model, where a kernel is executed concurrently on multiple processing elements each with its own data and a shared program counter. All processing elements execute an identical set of instructions. The use of predication enables work-items to participate or not for each issued command.","In one example, each APD  compute unit can include one or more scalar and\/or vector floating-point units and\/or arithmetic and logic units (ALUs). The APD compute unit can also include special purpose processing units (not shown), such as inverse-square root units and sine\/cosine units. In one example, the APD compute units are referred to herein collectively as shader core .","Having one or more SIMDs, in general, makes APD  ideally suited for execution of data-parallel tasks such as those that are common in graphics processing.","Some graphics pipeline operations, such as pixel processing, and other parallel computation operations, can require that the same command stream or compute kernel be performed on streams or collections of input data elements. Respective instantiations of the same compute kernel can be executed concurrently on multiple compute units in shader core  in order to process such data elements in parallel. As referred to herein, for example, a compute kernel is a function containing instructions declared in a program and executed on an APD compute unit. This function is also referred to as a kernel, a shader, a shader program, or a program.","In one illustrative embodiment, each compute unit (e.g., SIMD processing core) can execute a respective instantiation of a particular work-item to process incoming data. A work-item is one of a collection of parallel executions of a kernel invoked on a device by a command. A work-item can be executed by one or more processing elements as part of a work-group executing on a compute unit.","A work-item is distinguished from other executions within the collection by its global ID and local ID. In one example, a subset of work-items in a workgroup that execute simultaneously together on a SIMD can be referred to as a wavefront . The width of a wavefront is a characteristic of the hardware of the compute unit (e.g., SIMD processing core). As referred to herein, a workgroup is a collection of related work-items that execute on a single compute unit. The work-items in the group execute the same kernel and share local memory and work-group barriers.","In the exemplary embodiment, all wavefronts from a workgroup are processed on the same SIMD processing core. Instructions across a wavefront are issued one at a time, and when all work-items follow the same control flow, each work-item executes the same program. Wavefronts can also be referred to as warps, vectors, or threads.","An execution mask and work-item predication are used to enable divergent control flow within a wavefront, where each individual work-item can actually take a unique code path through the kernel. Partially populated wavefronts can be processed when a full set of work-items is not available at wavefront start time. For example, shader core  can simultaneously execute a predetermined number of wavefronts , each wavefront  comprising a multiple work-items.","Within the system , APD  includes its own memory, such as graphics memory  (although memory  is not limited to graphics only use). Graphics memory  provides a local memory for use during computations in APD . Individual compute units (not shown) within shader core  can have their own local data store (not shown). In one embodiment, APD  includes access to local graphics memory , as well as access to the memory . In another embodiment, APD  can include access to dynamic random access memory (DRAM) or other such memories (not shown) attached directly to the APD  and separately from memory .","In the example shown, APD  also includes one or \u201cn\u201d number of command processors (CPs) . CP  controls the processing within APD . CP  also retrieves commands to be executed from command buffers  in memory  and coordinates the execution of those commands on APD .","In one example, CPU  inputs commands based on applications  into appropriate command buffers . As referred to herein, an application is the combination of the program parts that will execute on the compute units within the CPU and APD.","A plurality of command buffers  can be maintained with each process scheduled for execution on the APD .","CP  can be implemented in hardware, firmware, or software, or a combination thereof. In one embodiment, CP  is implemented as a reduced instruction set computer (RISC) engine with microcode for implementing logic including scheduling logic.","APD  also includes one or \u201cn\u201d number of dispatch controllers (DCs) . In the present application, the term dispatch refers to a command executed by a dispatch controller that uses the context state to initiate the start of the execution of a kernel for a set of work groups on a set of compute units. DC  includes logic to initiate workgroups in the shader core . In some embodiments, DC  can be implemented as part of CP .","System  also includes a hardware scheduler (HWS)  for selecting a process from a run list  for execution on APD . HWS  can select processes from run list  using round robin methodology, priority level, or based on other scheduling policies. The priority level, for example, can be dynamically determined. HWS  can also include functionality to manage the run list , for example, by adding new processes and by deleting existing processes from run-list . The run list management logic of HWS  is sometimes referred to as a run list controller (RLC).","In various embodiments of the present invention, when HWS  initiates the execution of a process from RLC , CP  begins retrieving and executing commands from the corresponding command buffer . In some instances, CP  can generate one or more commands to be executed within APD , which correspond with commands received from CPU . In one embodiment, CP , together with other components, implements a prioritizing and scheduling of commands on APD  in a manner that improves or maximizes the utilization of the resources of APD  and\/or system .","APD  can have access to, or may include, an interrupt generator . Interrupt generator  can be configured by APD  to interrupt the operating system  when interrupt events, such as page faults, are encountered by APD . For example, APD  can rely on interrupt generation logic within IOMMU  to create the page fault interrupts noted above.","APD  can also include preemption and context switch logic  for preempting a process currently running within shader core . Context switch logic , for example, includes functionality to stop the process and save its current state (e.g., shader core  state, and CP  state).","As referred to herein, the term state can include an initial state, an intermediate state, and\/or a final state. An initial state is a starting point for a machine to process an input data set according to a programming order to create an output set of data. There is an intermediate state, for example, that needs to be stored at several points to enable the processing to make forward progress. This intermediate state is sometimes stored to allow a continuation of execution at a later time when interrupted by some other process. There is also final state that can be recorded as part of the output data set.","Preemption and context switch logic  can also include logic to context switch another process into the APD . The functionality to context switch another process into running on the APD  may include instantiating the process, for example, through the CP  and DC  to run on APD , restoring any previously saved state for that process, and starting its execution.","Memory  can include non-persistent memory such as DRAM (not shown). Memory  can store, e.g., processing logic instructions, constant values, and variable values during execution of portions of applications or other processing logic. For example, in one embodiment, parts of control logic to perform one or more operations on CPU  can reside within memory  during execution of the respective portions of the operation by CPU .","During execution, respective applications, operating system functions, processing logic commands, and system software can reside in memory . Control logic commands fundamental to operating system  will generally reside in memory  during execution. Other software commands, including, for example, kernel mode driver  and software scheduler  can also reside in memory  during execution of system .","In this example, memory  includes command buffers  that are used by CPU  to send commands to APD . Memory  also contains process lists and process information (e.g., active list  and process control blocks ). These lists, as well as the information, are used by scheduling software executing on CPU  to communicate scheduling information to APD  and\/or related scheduling hardware. Access to memory  can be managed by a memory controller , which is coupled to memory . For example, requests from CPU , or from other devices, for reading from or for writing to memory  are managed by the memory controller .","Referring back to other aspects of system , IOMMU  is a multi-context memory management unit.","As used herein, context can be considered the environment within which the kernels execute and the domain in which synchronization and memory management is defined. The context includes a set of devices, the memory accessible to those devices, the corresponding memory properties and one or more command-queues used to schedule execution of a kernel(s) or operations on memory objects.","Referring back to the example shown in , IOMMU  includes logic to perform virtual to physical address translation for memory page access for devices including APD . IOMMU  may also include logic to generate interrupts, for example, when a page access by a device such as APD  results in a page fault. IOMMU  may also include, or have access to, a TLB . TLB , as an example, can be implemented in a content addressable memory (CAM) to accelerate translation of logical (i.e., virtual) memory addresses to physical memory addresses for requests made by APD  for data in memory .","In the example shown, communication infrastructure  interconnects the components of system  as needed. Communication infrastructure  can include (not shown) one or more of a peripheral component interconnect (PCI) bus, extended PCI (PCI-E) bus, advanced microcontroller bus architecture (AMBA) bus, advanced graphics port (AGP), or other such communication infrastructure. Communications infrastructure  can also include an Ethernet, or similar network, or any suitable physical communications infrastructure that satisfies an application's data transfer rate requirements. Communication infrastructure  includes the functionality to interconnect components including components of computing system .","In this example, operating system  includes functionality to manage the hardware components of system  and to provide common services. In various embodiments, operating system  can execute on CPU  and provide common services. These common services can include, for example, scheduling applications for execution within CPU , fault management, interrupt service, as well as processing the input and output of other applications.","In some embodiments, based on interrupts generated by an interrupt controller, such as interrupt controller , operating system  invokes an appropriate interrupt handling routine. For example, upon detecting a page fault interrupt, operating system  may invoke an interrupt handler to initiate loading of the relevant page into memory  and to update corresponding page tables.","Operating system  may also include functionality to protect system  by ensuring that access to hardware components is mediated through operating system managed kernel functionality. In effect, operating system  ensures that applications, such as applications , run on CPU  in user space. Operating system  also ensures that applications  invoke kernel functionality provided by the operating system to access hardware and\/or input\/output functionality.","By way of example, applications  include various programs or commands to perform user computations that are also executed on CPU . CPU  can seamlessly send selected commands for processing on the APD .","In one example, KMD  implements an application program interface (API) through which CPU , or applications executing on CPU  or other logic, can invoke APD  functionality. For example, KMD  can enqueue commands from CPU  to command buffers  from which APD  will subsequently retrieve the commands. Additionally, KMD  can, together with SWS , perform scheduling of processes to be executed on APD . SWS , for example, can include logic to maintain a prioritized list of processes to be executed on the APD.","In other embodiments of the present invention, applications executing on CPU  can entirely bypass KMD  when enqueuing commands.","In some embodiments, SWS  maintains an active list  in memory  of processes to be executed on APD . SWS  also selects a subset of the processes in active list  to be managed by HWS  in the hardware. Information relevant for running each process on APD  is communicated from CPU  to APD  through process control blocks (PCB) .","Processing logic for applications, operating system, and system software can include commands specified in a programming language such as C and\/or in a hardware description language such as Verilog, RTL, or netlists, to enable ultimately configuring a manufacturing process through the generation of maskworks\/photomasks to generate a hardware device embodying aspects of the invention described herein.","A person of skill in the art will understand, upon reading this description, that computing system  can include more or fewer components than shown in . For example, computing system  can include one or more input interfaces, non-volatile storage, one or more output interfaces, network interfaces, and one or more displays or display interfaces.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 1B","FIG. 1A","FIG. 1B","FIG. 1A","FIG. 1B"],"b":["104","124","124","124","124","124","125","0","124","162","1","2","124","124","160","166","128"],"i":["a","b","c","a","b ","c"]},"In , graphics pipeline  can include a set of blocks, referred to herein as ordered pipeline . As an example, ordered pipeline  includes a vertex group translator (VGT) , a primitive assembler (PA) , a scan converter (SC) , and a shader-export, render-back unit (SX\/RB) . Each block within ordered pipeline  may represent a different stage of graphics processing within graphics pipeline . Ordered pipeline  can be a fixed function hardware pipeline. Other implementations can be used that would also be within the spirit and scope of the present invention.","Although only a small amount of data may be provided as an input to graphics pipeline , this data will be amplified by the time it is provided as an output from graphics pipeline . Graphics pipeline  also includes DC  for counting through ranges within work-item groups received from CP pipeline . Compute work submitted through DC  is semi-synchronous with graphics pipeline .","Compute pipeline  includes shader DCs  and . Each of the DCs  and  is configured to count through compute ranges within work groups received from CP pipelines and ","The DCs , , and , illustrated in , receive the input ranges, break the ranges down into workgroups, and then forward the workgroups to shader core .","Since graphics pipeline  is generally a fixed function pipeline, it is difficult to save and restore its state, and as a result, the graphics pipeline  is difficult to context switch. Therefore, in most cases context switching, as discussed herein, does not pertain to context switching among graphics processes. An exception is for graphics work in shader core , which can be context switched. After the processing of work within graphics pipeline  has been completed, the completed work is processed through a render back unit , which does depth and color calculations, and then writes its final results to memory .","Shader core  can be shared by graphics pipeline  and compute pipeline . Shader core  can be a general processor configured to run wavefronts. In one example, all work within compute pipeline  is processed within shader core . Shader core  runs programmable software code and includes various forms of data, such as state data.","A disruption in the QoS occurs when all work-items are unable to access APD resources. Embodiments of the present invention facilitate efficiently and simultaneously launching two or more tasks to resources within APD , enabling all work-items to access various APD resources. In one embodiment, an APD input scheme enables all work-items to have access to the APD's resources in parallel by managing the APD's workload. When the APD's workload approaches maximum levels, (e.g., during attainment of maximum I\/O rates), this APD input scheme assists in that otherwise unused processing resources can be simultaneously utilized in many scenarios. A serial input stream, for example, can be abstracted to appear as parallel simultaneous inputs to the APD.","By way of example, each of the CPs  can have one or more tasks to submit as inputs to other resources within APD , where each task can represent multiple wavefronts. After a first task is submitted as an input, this task may be allowed to ramp up, over a period of time, to utilize all the APD resources necessary for completion of the task. By itself, this first task may or may not reach a maximum APD utilization threshold. However, as other tasks are enqueued and are waiting to be processed within the APD , allocation of the APD resources can be managed to ensure that all of the tasks can simultaneously use the APD , each achieving a percentage of the APD's maximum utilization. This simultaneous use of the APD  by multiple tasks, and their combined utilization percentages, ensures that a predetermined maximum APD utilization threshold is achieved.","The discovery of the properties of a combined CPU\/APD architecture system is described below in connection with a representative system which is shown in . As will be described in greater detail below, the representative system includes two APUs coupled to each other with an interprocessor communication link, a first add-in board coupled to a first of the two APUs, the first add-in board having a dedicated APD and local memory; and a second add-in board coupled to a second of the two APUs, the second add-in board having two dedicated APDs with each of those APDs coupled to its own local memory; and both of the APDs coupled to the second APU through a shared PCIe bridge. This exemplary system is used to illustrate various features, properties, and capabilities that, when their presence, properties, interconnections and\/or attributes are made known to software, such as but not limited to application software, can be used by that software to more efficiently utilize the computational resources of the platform. As will be appreciated by those of ordinary skill, alternative embodiments having differing configurations and arrangements are contemplated.","In accordance with the present invention, several extensions to the established platform infrastructure discovery mechanisms (such as, for example, extensions to ACPI) are provided that allow incorporating properties of a combined CPU\/APD architecture system architecture into the discoverable platform properties in a flexible, extensible and consistent manner. Other communications protocols in addition to, or in replacement of, ACPI could also be employed by other embodiments. Various embodiments of the present invention introduce features and improvements to incorporate CPU, APU and APD properties into a consistent infrastructure, to support software. This software may also be referred to as operating system platform\/power management software (OSPM).",{"@attributes":{"id":"p-0095","num":"0094"},"figref":["FIG. 2","FIG. 2"]},"The present invention is not limited to the illustrative embodiment of , and it is noted that embodiments of the present invention include both larger and smaller platform designs with more than two or with one APU socket in a similar fashion. The embodiments described herein are for illustrative purposes, and it is to be understood that other embodiments in accordance with the present invention are possible. The detailed implementation properties of a specific platform design in accordance with the present invention may be different.","Referring to , the platform components break down into a number of blocks, each of which may contain different features, properties, interconnections, and\/or attributes. Software, including but to a lesser degree application software enumerate these features, properties, interconnections, and\/or attributes, and incorporate these into the code operation.","A system platform  in accordance with the present invention. System platform  includes a first APU  and a second APU . APU  and APU  are communicatively coupled by a first interprocessor communication link . In one embodiment, first interprocessor communication link  is a HyperTransport link. APUs ,  each include a CPU with a plurality of cores, an APD with a plurality of SIMD cores, and an input\/output memory manager unit.","Illustrative system platform  further includes a first system memory  coupled to first APU  by a first memory bus . First system memory  includes coherent cacheable portion and a non-coherent non-cacheable portion . System platform  further includes a first add-in board  and a second add-in board . First add-in board  is coupled to first APU  by a first PCIe bus . Second add-in board  is coupled to second APU by a second PCIe bus . In various alternative embodiments, some or all of the physical components and\/or software, firmware, or microcode, of one or both of first add-in board  and second add-in board  are disposed on a common substrate (e.g., a printed circuit board) with one or more APUs.","First add-in board  includes a first dedicated APD , a first local memory  coupled to first dedicated APD  by a memory bus , and a first firmware memory  having stored therein firmware such as VBIOS UEFI GOP (video basic input output system, unified extensible firmware interface, graphics output protocol). First firmware memory  is typically physically implemented as a non-volatile memory, but such an implementation is not a requirement of the present invention. First dedicated APD  includes one or more SIMD units. First local memory  includes a first portion that is coherent, and a second portion that is non-coherent. First local memory  is typically physically embodied as a volatile memory, but such an implementation is not a requirement of the present invention.","Second add-in board  includes a second dedicated APD , a second local memory coupled to second APD  by a memory bus , a third dedicated APD , a third local memory  coupled to third dedicated APD  by a memory bus , a PCIe bridge  coupled to second dedicated APD  by a PCIe bus , PCIe bridge  further coupled to third dedicated APD  by a PCIe bus . Second local memory  includes a first portion that is coherent, and a second portion that is non-coherent. Third local memory  includes a first portion that is coherent, and a second portion that is non-coherent. Second and third local memories ,  are typically physically implemented as a volatile memory, but such an implementation is not a requirement of the present invention. Second add-in board  further includes a second firmware memory  having stored therein firmware such as VBIOS UEFI GOP.","Traditionally, CPU functionality and resources are exposed through the CPUID instruction and ACPI tables and methods (e.g., for capabilities and features, power and performance states, etc.), whereas for other devices in the system, for example, peripheral devices, PCIe capability structures are utilized.","Basic characteristics described through these mechanisms include resource functionality and resource affinity; the former is usually described as \u201cpools\u201d of uniform components with identical features and characteristics (e.g., CPU cores), the latter in general requiring hierarchical expressions describing the topology and relationship between those resources. Each of these representations has benefits for certain tasks, and therefore may be retained in the enumeration process in embodiments of the present invention.","Presented below, in connection with a combined CPU\/APD computational system architecture, are various design principles and detailed component properties exposed for enumeration, along with methods and mechanisms for exposing those properties. Some properties may be exposed via either one or more executed instructions (e.g., CPUID), and some properties may be exposed via information structures such as tables. In various alternative embodiments, a particular property may be exposed by CPUID, information structure, or both.","Basic detection of a combined CPU\/APD computational system architecture platform, may be accomplished by executing a CPUID instruction. It is noted however, that executing a CPUID instruction does not generally provide for detail capabilities discovery of the combined CPU\/APD computational system components. Rather this mechanism typically provides only a yes\/no answer regarding whether the system itself is a combined CPU\/APD computational system. Therefore, in accordance with aspects of the present invention, combined CPU\/APD computational system architecture detail features are generally provided via information structures, such as improved ACPI tables, that specify the relevant features in detail of the combined CPU\/APD computational system architecture platform.","In one embodiment, the CPU is embodied so that it may execute an improved CPUID instruction, and which when executed exposes basic information regarding the combined CPU\/APD architecture system. In this illustrative embodiment, CPUID Fn8000001E EDX is used for basic information exposure of the combined CPU\/APD architecture system (see Table 1 below). Application and other software can use Bit  to identify if it is running on a combined CPU\/APD architecture capable platform. Running on a combined CPU\/APD architecture capable platform means that the platform has at least one APU containing both combined CPU\/APD architecture compliant CPU and APD functionality, i.e., compute units and SIMDs. Software may then use discovery and evaluation of the content of an improved ACPI table to retrieve the detailed information of the available functionality and topology. It is noted that the present invention is not limited to this particular op code for the CPUID instruction, or to the particular arrangement of bits or fields as shown in Table 1.",{"@attributes":{"id":"p-0107","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["CPUID",{}]},{"entry":["Fn8000_001E_EDX Bits","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["31:9","Reserved"]},{"entry":["8","Reserved (may be used for combined"]},{"entry":[{},"architecture IOMMU present)"]},{"entry":["\u20027:1","Reserved (may be used for combined"]},{"entry":[{},"architecture version ID)"]},{"entry":["0","Combined architecture major version\/"]},{"entry":[{},"Family (0: Not present, 1: combined"]},{"entry":[{},"architecture capable APU present"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In accordance with embodiments of the present invention, the discovery process on a platform such as shown in  exposes information regarding the available components based on locality, loosely in hierarchical order. The discovery process is conceptually similar to the ACPI NUMA node definition (ACPI 4.0 Specification) but is improved to include the specific APD\/SIMD properties and IOMMU functionality into the node properties.","A combined CPU\/APD architecture system platform is characterized as containing one or more processing units compliant with the CPU\/APD architecture (see ), wherein at least one is an APU (i.e., containing both CPU Compute and APD-SIMD execution units). Each of the processing units is roughly defined through its physical representation (e,g., \u201cAPU Socket\u201d, APD \u201cadapter\u201d\/device) and has discoverable internal sub-components and properties, such as but not limited to, CPU compute units and caches (optionally, none may be expressed in a combined architecture compliant discrete APD device); APD SIMD and caches (optional, if traditional CPU properties are expressed); memory controller(s) and connections; IOMMU (optionally, none may be expressed for a combined architecture compliant discrete APD); and IO connection interfaces (e.g., PCIe, HyperTransport,DMI, internal, or other).","Since not all memory resources (e.g., APD local memory) are necessarily part of the coherent global memory, precautions are taken, to express these properties accordingly. Therefore rather than using a system resource affinity table (SRAT), improved information structures are provided to accommodate the information associated with the combined CPU\/APD system architecture. More particularly, a new base structure in accordance with the present invention, herein referred to as the component resource affinity table (CRAT), and a number of related sub-structures are introduced. It is noted that this is an illustrative embodiment and that other information structure arrangements are within the scope of the present invention.","CRAT is the head structure of the discoverable combined CPU\/APD architecture platform properties in the exemplary embodiment. Software parses the table to find the discoverable processing units, properties and their affinity, allowing software to identify component locality. CRAT content may change during runtime as some physical components arrive or depart from the system (e.g., hot plug of CPU\/APU and\/or discrete APD). Table 2 identifies and describes the fields of the CRAT.",{"@attributes":{"id":"p-0112","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CRAT Header Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Byte","Byte",{}]},{"entry":["Header","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Signature","4","0","\u2018CRAT\u2019. Signature for the Component Resource"]},{"entry":[{},{},{},"Affinity Table."]},{"entry":["Length","4","4","Length, in bytes, of the entire CRAT. The length implies"]},{"entry":[{},{},{},"the number of Entry fields at the end of the table"]},{"entry":["Revision","1","8","0"]},{"entry":["Checksum","1","9","Entire table must sum to zero"]},{"entry":["OEMID","6","10","OEM ID"]},{"entry":["OEM Table","8","16","For the Component Resource Affinity Table, the table"]},{"entry":["ID",{},{},"ID is the manufacturer model ID"]},{"entry":["OEM","4","24","OEM revision of Component Resource Affinity Table"]},{"entry":["Revision",{},{},"for supplied OEM Table ID"]},{"entry":["Creator ID","4","28","Vendor ID of utility that created the table."]},{"entry":["Creator","4","32","Revision of utility that created the table"]},{"entry":["Revision",{},{},{}]},{"entry":["TotalEntries","4","36","Total number [n] of entries in the Component Resource"]},{"entry":[{},{},{},"Allocation Structure"]},{"entry":["NumDomains","2","40","Number of combined architecture proximity domains."]},{"entry":[{},{},{},"This includes possible discrete APD \u201cdomains\u201d that are"]},{"entry":[{},{},{},"represented for possible Add-In-Boards attached, e.g.,"]},{"entry":[{},{},{},"via PCI Express. Not all of them may be populated"]},{"entry":[{},{},{},"initially at platform definition. This number may be"]},{"entry":[{},{},{},"higher than the CPU proximity domains expressed in"]},{"entry":[{},{},{},"SRAT due to additional entries for other (PCIe"]},{"entry":[{},{},{},"connected) combined architecture components."]},{"entry":["Reserved","6","42","Reserved"]},{"entry":["Component","\u2014","48","A list of component resource allocation structures for"]},{"entry":["Resource",{},{},"the platform. See definitions below for the various sub-"]},{"entry":["Allocation",{},{},"components."]},{"entry":"Structure[n]"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The CRAT header includes and precedes the sub-component structures containing the actual component information. The sub-components are described by the sub-component tables as follows.","Various embodiments of the present invention provide an APU affinity information structure. This sub-component describes the APU node components, available I\/O interfaces and their bandwidth and provides this information to software. Multiple such structures may be expressed for the same node in order to adequately describe more complex APU platform properties. Table 3 identifies and describes the fields of the CRAT APU Affinity Information Structure. It is noted that this is an illustrative embodiment and that other information structure arrangements are within the scope of the present invention.",{"@attributes":{"id":"p-0115","num":"0114"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CRAT APU Affinity Information Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Byte","Byte",{}]},{"entry":["Field","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Type","1","0","0 APU Structure"]},{"entry":["Length","1","1","40 (Length, in bytes, of the APU Structure)"]},{"entry":["Reserved","2","2","Reserved"]},{"entry":["Flags","4","4","Flags\u2014APU Affinity Structure. Indicates whether the node"]},{"entry":[{},{},{},"is active and can be hot plugged and what functionality is"]},{"entry":[{},{},{},"present. For details see Table 4"]},{"entry":["Proximity","4","8","Integer that represents the proximity domain to which the"]},{"entry":["Domain",{},{},"node belongs"]},{"entry":["ProcessorIdLow","4","12","Low value of the logical processor included in this"]},{"entry":[{},{},{},"combined architecture proximity domain. For CPUs this"]},{"entry":[{},{},{},"value is the low value of APIC Id of that APU. Logical"]},{"entry":[{},{},{},"SIMD Id are expressed with bit 31 set to 1 (0x80000000)."]},{"entry":["CPUCoreCount","2","16","Indicates overall count of x86(\u221264) -compatible execution"]},{"entry":[{},{},{},"units (CPU cores) present in this (APU-) node (identifiable"]},{"entry":[{},{},{},"by SW). This value is 0 for a node with a discrete APD."]},{"entry":["SIMDCount","2","18","Indicates overall count of APD SIMDs present in this node"]},{"entry":[{},{},{},"(identifiable by SW). This value is 0 if no SIMDs are"]},{"entry":[{},{},{},"present in this node (=\u201ctraditional\u201d CPU)."]},{"entry":["SIMDWidth","2","20","\u201cWidth\u201d of a single SIMD unit. SIMDCount*SIMDWidth"]},{"entry":[{},{},{},"determines the total number of non-x86 execution units. If"]},{"entry":[{},{},{},"SIMDCount is 0, this value is ignored."]},{"entry":["IOCount","2","22","Number of discoverable IO Interfaces connecting this node"]},{"entry":[{},{},{},"to other components. These can be e.g., HyperTransport,"]},{"entry":[{},{},{},"PCIe or component-internal Interfaces. The value is 0 if"]},{"entry":[{},{},{},"platform does not characterize IO properties. If value is"]},{"entry":[{},{},{},"non-0, IO Interface parameters (e.g., maximum bandwidth,"]},{"entry":[{},{},{},"latency) can be characterized by CRAT component sub-"]},{"entry":[{},{},{},"structures."]},{"entry":["Reserved","16","24","Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Table 4 describes the Flags field of the APU affinity information structure and provides further information about the parameters. It is noted that this is an illustrative embodiment and that other information structure arrangements are within the scope of the present invention.",{"@attributes":{"id":"p-0117","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Flags field of the CRAT APU Affinity Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Bit","Bit",{}]},{"entry":["Field","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Enabled","1","0","If clear, OSPM ignores the contents of the APU Affinity"]},{"entry":[{},{},{},"Structure. This allows system firmware to populate the"]},{"entry":[{},{},{},"CRAT with a static number of structures but only enable"]},{"entry":[{},{},{},"them as necessary."]},{"entry":["Hot Pluggable","1","1","The information conveyed by this bit depends on the value of"]},{"entry":[{},{},{},"the Enabled bit."]},{"entry":[{},{},{},"If the Enabled bit is set and the Hot Pluggable bit is also set,"]},{"entry":[{},{},{},"the system hardware supports hot-add and hot-remove on the"]},{"entry":[{},{},{},"I\/O interfaces"]},{"entry":[{},{},{},"If the Enabled bit is set and the Hot Pluggable bit is clear,"]},{"entry":[{},{},{},"the system hardware does not support hot-add or hot-remove"]},{"entry":[{},{},{},"on their\/O interfaces"]},{"entry":["CPU present","1","2","1 if the APU processing unit node has x86 compatible"]},{"entry":[{},{},{},"execution units (=CPU)"]},{"entry":["APD present","1","3","1 if the APU processing unit node has non-x86 SIMD"]},{"entry":[{},{},{},"execution units (=APD)"]},{"entry":["IOMMU present","1","4","1 if the APU processing unit node has associated"]},{"entry":[{},{},{},"IOMMUvX(X >= 2) functionality present"]},{"entry":["Reserved","27","5","Must be zero"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Table 5 shows the memory component affinity structure which indicates presence of memory nodes in the structures' topology. The same structure is used to both describe system memory and visible device local memory resources. It is noted that this is an illustrative embodiment and that other information structure arrangements are within the scope of the present invention.",{"@attributes":{"id":"p-0119","num":"0118"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CRAT Memory Component Affinity Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Byte","Byte",{}]},{"entry":["Field","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Type","1","0","1 CRAT Memory Affinity Structure"]},{"entry":["Length","1","1","40 (Length, in bytes, of the Memory Affinity Structure)"]},{"entry":["Reserved","2","2","Reserved"]},{"entry":["Flags","4","4","Flags\u2014Memory Affinity Structure. Indicates whether the"]},{"entry":[{},{},{},"region of memory is enabled and can be hot plugged. For"]},{"entry":[{},{},{},"details see Table 6"]},{"entry":["Proximity Domain","4","8","Integer that represents the proximity domain to which the"]},{"entry":[{},{},{},"memory belongs"]},{"entry":["Base Address Low","4","12","Low 32 Bits of the Base Address of the memory range"]},{"entry":["Base Address","4","16","High 32 Bits of the Base Address of the memory range"]},{"entry":["High",{},{},{}]},{"entry":["Length Low","4","20","Low 32 Bits of the length of the memory range"]},{"entry":["Length High","4","24","High 32 Bits of the length of the memory range"]},{"entry":["Width","4","28","Memory width\u2014Specifies the number of parallel bits of"]},{"entry":[{},{},{},"the memory interface (Alternative use: bandwidth of the"]},{"entry":[{},{},{},"memory)"]},{"entry":["Reserved","8","32","Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Table 6 shows the flags field of the memory affinity structure which provides further information about this node's parameters. It is noted that this is an illustrative embodiment and that other information structure arrangements are within the scope of the present invention.",{"@attributes":{"id":"p-0121","num":"0120"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Flags field of the CRAT Memory Affinity component structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Bit","Bit",{}]},{"entry":["Field","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Enabled","1","0","If clear, OSPM ignores the contents of the Memory Affinity"]},{"entry":[{},{},{},"Structure. This allows system firmware to populate the"]},{"entry":[{},{},{},"CRAT with a static number of structures but only enable"]},{"entry":[{},{},{},"them as necessary."]},{"entry":["Hot Pluggable","1","1","The information conveyed by this bit depends on the value of"]},{"entry":[{},{},{},"the Enabled bit."]},{"entry":[{},{},{},"If the Enabled bit is set and the Hot Pluggable bit is also set,"]},{"entry":[{},{},{},"the system hardware supports hot-add and hot-remove of this"]},{"entry":[{},{},{},"memory region (Alternative: also used for discrete APD"]},{"entry":[{},{},{},"memory)"]},{"entry":[{},{},{},"If the Enabled bit is set and the Hot Pluggable bit is clear,"]},{"entry":[{},{},{},"the system hardware does not support hot-add or hot-remove"]},{"entry":[{},{},{},"of this memory region."]},{"entry":["Nonvolatile","1","2","If set, the memory region represents Non-Volatile memory"]},{"entry":["Reserved","29","3","Must be zero"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Table 7 shows the cache affinity information structure which provides the following topology information to the operating system: the association between a cache, its relative level (i.e., L1, L2 or L3) and the combined architecture proximity domain to which it belongs; and information about whether the cache is enabled, size, and lines. The cache affinity structure is used to express both \u201ctraditional\u201d CPU cache topology and APD cache properties to software in a systematic way. It is noted that this is an illustrative embodiment and that other information structure arrangements are within the scope of the present invention.",{"@attributes":{"id":"p-0123","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"287pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CRAT Cache Affinity information Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Byte","Byte",{}]},{"entry":["Field","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Type","1","0","2 CRAT Cache Affinity Structure"]},{"entry":["Length","1","1","64 (Length, in bytes, of the CRAT Cache Affinity"]},{"entry":[{},{},{},"Structure)"]},{"entry":["Reserved","2","2","Reserved"]},{"entry":["Flags","4","4","Flags\u2014Cache Affinity Structure. Indicates whether the"]},{"entry":[{},{},{},"region of cache is enabled. For details see Table 8."]},{"entry":["ProcessorIdLow","4","8","Low value of a logical processor which includes this"]},{"entry":[{},{},{},"component. This value is the base of the sibling mask"]},{"entry":[{},{},{},"window representing logical processors which share this"]},{"entry":[{},{},{},"component."]},{"entry":[{},{},{},"For CPUs this value is the low value of APIC Id. Logical"]},{"entry":[{},{},{},"SIMD Id are expressed with bit 31 set to 1 (0x80000000)."]},{"entry":["SiblingMap","32","12","Bitmask of Processor Id sharing this component. 1 bit per"]},{"entry":[{},{},{},"logical processor. 32 bytes = 256 bits to describe256"]},{"entry":[{},{},{},"logical processors\/SIMD per cache."]},{"entry":["CacheSize","4","44","Cache size in KB"]},{"entry":["CacheLevel","1","48","Integer representing level: 1, 2, 3, 4, etc."]},{"entry":["LinesPerTag","1","49","Cache Lines per tag"]},{"entry":["CacheLineSize","2","50","Cache line size in bytes"]},{"entry":["Associativity","1","52","Cache associativity"]},{"entry":[{},{},{},"The associativity fields are encoded as follows:"]},{"entry":[{},{},{},"00h: Reserved"]},{"entry":[{},{},{},"01h: Direct mapped"]},{"entry":[{},{},{},"02h-FEh: Associativity, (e.g., 04h = 4-way"]},{"entry":[{},{},{},"associative.)"]},{"entry":[{},{},{},"FFh: Fully associative"]},{"entry":["CacheProperties","1","53","Cache Properties bits [2:0] represent Inclusive\/Exclusive"]},{"entry":[{},{},{},"property encoded."]},{"entry":[{},{},{},"0: Cache is strictly exclusive to lower level caches"]},{"entry":[{},{},{},"1: Cache is mostly exclusive to lower level caches"]},{"entry":[{},{},{},"2: Cache is strictly inclusive to lower level caches"]},{"entry":[{},{},{},"3: Cache is mostly inclusive to lower level caches"]},{"entry":[{},{},{},"4: Cache is a \u201cconstant cache\u201d (=explicit update)"]},{"entry":[{},{},{},"5: Cache is a \u201cspecialty cache\u201d (e.g., Texture cache)"]},{"entry":[{},{},{},"6-7: Reserved"]},{"entry":[{},{},{},"CacheProperties bits [7:3] are reserved"]},{"entry":["CacheLatency","2","54","Cost of time to access cache described in nanoseconds."]},{"entry":[{},{},{},"Sub 1 ns time to be rounded to 1 ns."]},{"entry":["Reserved","8","56","Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"With respect to the \u2018CacheLatency\u2019 field of Table 7, it is noted various alternative embodiments may use more or less temporal granularity, and\/or different rounding policies. It is further noted that alternative embodiments may include information regarding cache replacement policy, even in view of current microarchitectural differences that exist across vendor products.","Table 8 identifies and describes the information stored in the flags field of the CRAT cache affinity information structure. It is noted that this is an illustrative embodiment and that other information structure arrangements are within the scope of the present invention.",{"@attributes":{"id":"p-0126","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Flags field of the CRAT Cache Affinity Information Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Bit","Bit",{}]},{"entry":["Field","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Enabled","1","0","If clear, the OSPM ignores the contents"]},{"entry":[{},{},{},"of the Cache Affinity Structure. This"]},{"entry":[{},{},{},"allows system firmware to populate the"]},{"entry":[{},{},{},"CRAT with a static number of"]},{"entry":[{},{},{},"structures but only enable then as"]},{"entry":[{},{},{},"necessary. This bit required to be"]},{"entry":[{},{},{},"enabled for the rest of the flags to be"]},{"entry":[{},{},{},"valid."]},{"entry":["Data Cache","1","1","1 if cache includes data"]},{"entry":["Instruction","1","2","1 if cache includes instructions"]},{"entry":["cache",{},{},{}]},{"entry":["CPU Cache","1","3","1 if cache is part of CPU functionality"]},{"entry":["SIMD Cache","1","4","1 if cache is part of SIMD functionality"]},{"entry":["Reserved","27","5","Must be zero"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Modern processors may include a TLB. A TLB is a cache of page translations for the physical processor. The TLB affinity structure, shown in Table 9, provides the following topology information statically to the operating system for a processor: the association between a TLB component, its relative level (i.e., L1, L2 or L3) and the sibling processors which share the component; information about whether the TLB affinity structure is enabled and if it contains translation for data or instructions. The TLB affinity structure is an extension to the list of static resource allocation structures for the platform. Changes to page level support in future architectures will require extensions to this table. It is noted that this structure may be an array of substructures, each describing a different page size. It is noted that this is an illustrative embodiment and that other information structure arrangements are within the scope of the present invention.",{"@attributes":{"id":"p-0128","num":"0127"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"322pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CRAT Translation Look-aside Buffer Affinity Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Byte","Byte",{}]},{"entry":["Field","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Type","1","0","3 CRAT TLB Affinity Structure"]},{"entry":["Length","1","1","64 (Length, in bytes, of the CRAT TLB Affinity Structure)"]},{"entry":["Reserved","2","2","Reserved"]},{"entry":["Flags","4","4","Flags\u2014TLB Affinity Structure. Indicates whether the TLB is"]},{"entry":[{},{},{},"enabled and defined. Details in See Table 10."]},{"entry":["ProcessorIdLow","4","8","Low value of a logical processor which includes this"]},{"entry":[{},{},{},"component. This value is the base of the sibling mask window"]},{"entry":[{},{},{},"representing logical processors which share this component."]},{"entry":[{},{},{},"For CPUs this value is the low value of APIC Id. Logical"]},{"entry":[{},{},{},"SIMD Id are expressed with bit 31 set to 1 (0x80000000)."]},{"entry":["SiblingMap","32","12","Bitmask of Processor Id sharing this component. 1 bit per"]},{"entry":[{},{},{},"logical processor. 32 bytes = 256 bits to describe256 logical"]},{"entry":[{},{},{},"processors\/SIMD per TLB."]},{"entry":["TLBLevel","4","44","Integer representing level: 1, 2, 3, 4, etc."]},{"entry":["DataTLBAssociativity2MB","1","48","Data TLB associativity for 2 MB pages"]},{"entry":[{},{},{},"The associativity fields are encoded as follows:"]},{"entry":[{},{},{},"00h: Reserved."]},{"entry":[{},{},{},"01h: Direct mapped."]},{"entry":[{},{},{},"02h-FEh: Associativity, (e.g., 04h = 4-way"]},{"entry":[{},{},{},"associative.)"]},{"entry":[{},{},{},"FFh: Fully associative"]},{"entry":["DataTLBSize2MB","1","49","Data TLB number of entries for 2 MB"]},{"entry":["InstructionTLB","1","50","Instruction TLB associativity for 2 MB pages"]},{"entry":["Assoc2MB",{},{},"The associativity fields are encoded as follows:"]},{"entry":[{},{},{},"00h: Reserved."]},{"entry":[{},{},{},"01h: Direct mapped."]},{"entry":[{},{},{},"02h-FEh: Associativity, (e.g., 04h = 4-way"]},{"entry":[{},{},{},"associative.)"]},{"entry":[{},{},{},"FFh: Fully associative"]},{"entry":["InstructionTLBSize2MB","1","51","Instruction TLB number of entries for 2 MB pages"]},{"entry":["DTLB4KAssoc","1","52","Data TLB Associativity for 4 KB pages"]},{"entry":["DTLB4KSize","1","53","Data TLB number of entries for 4 KB pages"]},{"entry":["ITLB4KAssoc","1","54","Instruction TLB Associativity for 4 KB pages"]},{"entry":["ITLB4KSize","1","55","Instruction TLB number of entries for 4 KB pages"]},{"entry":["DTLB1GAssoc","1","56","Data TLB Associativity for 1 GB pages"]},{"entry":["DTLB1GSize","1","57","Data TLB number of entries for 1 GB pages"]},{"entry":["ITLB1GAssoc","1","58","Instruction TLB Associativity for 1 GB pages"]},{"entry":["ITLB1GSize","1","59","Instruction TLB number of entries for 1 GB pages"]},{"entry":["Reserved","4","60","Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0129","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 10"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Flags field of the CRAT TLB Affinity Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Bit","Bit",{}]},{"entry":["Field","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Enabled","1","0","If clear, the OSPM ignores the"]},{"entry":[{},{},{},"contents of the TLB Affinity"]},{"entry":[{},{},{},"Structure. This allows system"]},{"entry":[{},{},{},"firmware to populate the CRAT"]},{"entry":[{},{},{},"with a static number of structures"]},{"entry":[{},{},{},"but only enable then as necessary."]},{"entry":["Data TLB","1","1","1 if TLB includes translation"]},{"entry":[{},{},{},"information for data"]},{"entry":["Instruction","1","2","1 if TLB includes translation"]},{"entry":["TLB",{},{},"information for instructions"]},{"entry":["CPU TLB","1","3","1 if TLB is part of CPU functionality"]},{"entry":["SIMD TLB","1","4","1 if TLB is part of SIMD functionality"]},{"entry":["Reserved","27","5","Must be zero"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Various embodiments of the present invention include an FPU Affinity Information Structure which provides the following topology information to the operating system: the association between an FPU and logical processors (CPU's) which share it; and Size. The FPU affinity structure is an extension to the list of static resource allocation structures for the platform. This information may be useful to applications which use AVX instructions to correlate which processors are siblings. Details of the CRAT FPU affinity information structure are shown in Table 11. It is noted that this is an illustrative embodiment and that other information structure arrangements are within the scope of the present invention.",{"@attributes":{"id":"p-0131","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"thead":{"row":{"entry":"TABLE 11"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CRAT FPU Affinity information Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Byte","Byte",{}]},{"entry":["Field","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Type","1","0","4 CRAT FPU Affinity Structure"]},{"entry":["Length","1","1","64 (Length, in bytes, of the CRAT FPU Affinity"]},{"entry":[{},{},{},"Structure)"]},{"entry":["Reserved","2","2","Reserved"]},{"entry":["Flags","4","4","Flags\u2014FPU Affinity Structure. Indicates whether the region"]},{"entry":[{},{},{},"of FPU affinity structure is enabled and defined. For details"]},{"entry":[{},{},{},"see Table 12."]},{"entry":["ProcessorIdLow","4","8","Low value of a logical processor which includes this"]},{"entry":[{},{},{},"component. This value is the base of the sibling mask window"]},{"entry":[{},{},{},"representing logical processors which share this component."]},{"entry":[{},{},{},"For CPUs this value is the low value of APIC Id. Logical"]},{"entry":[{},{},{},"SIMD Id are expressed with bit 31 set to 1 (0x80000000)."]},{"entry":["SiblingMap","32","12","Bitmask of Processor Id sharing this component. 1 bit per"]},{"entry":[{},{},{},"logical processor. 32 bytes = 256 bits to describe256 logical"]},{"entry":[{},{},{},"processors\/SIMD per TLB."]},{"entry":["FPUSize","4","44","Product specific"]},{"entry":["Reserved","16","48","Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0132","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 12"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Flags field of the CRAT FPU Affinity Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Bit","Bit",{}]},{"entry":["Field","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Enabled","1","0","If clear, the OSPM ignores the contents"]},{"entry":[{},{},{},"of the FPU Affinity Structure. This"]},{"entry":[{},{},{},"allows system firmware to populate the"]},{"entry":[{},{},{},"CRAT with a static number of structures"]},{"entry":[{},{},{},"but only enable then as necessary."]},{"entry":["Reserved","31","1","Must be zero"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Various embodiments of the present invention include an IO affinity information structure (see Tables 13 and 14). The CRAT IO Affinity Information Structure provides the following topology information to the operating system: the association between a discoverable IO interface and combined CPU\/APD architecture nodes which share it; maximum, minimum bandwidth and latency characterizations; and Size. The IO affinity structure is an extension to the list resource allocation structures for the platform. This information may be useful to applications which use AVX instructions to correlate which processors are siblings. It is noted that this is an illustrative embodiment and that other information structure arrangements are within the scope of the present invention.",{"@attributes":{"id":"p-0134","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"center"}},"thead":{"row":{"entry":"TABLE 13"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CRAT IO Affinity Information Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Byte","Byte",{}]},{"entry":["Field","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Type","1","0","5 CRAT IO Affinity Structure"]},{"entry":["Length","1","1","64 (Length, in bytes, of the CRAT IO Affinity Structure)"]},{"entry":["Reserved","2","2","Reserved"]},{"entry":["Flags","4","4","Flags\u2014IO Affinity Structure. Indicates whether the region of"]},{"entry":[{},{},{},"IO affinity structure is enabled and defined. For details see"]},{"entry":[{},{},{},"Table 14."]},{"entry":["Proximity Domain","4","8","Integer that represents the proximity domain to which the IO"]},{"entry":["From",{},{},"Interface belongs"]},{"entry":["Proximity Domain","4","12","Integer that represents the other proximity domain to which"]},{"entry":["To",{},{},"the IO Interface belongs"]},{"entry":["Type","1","16","IO Interface type. Values defined are"]},{"entry":[{},{},{},"0: Undefined"]},{"entry":[{},{},{},"1: Hypertransport"]},{"entry":[{},{},{},"2: PCI Express"]},{"entry":[{},{},{},"3: Other (e.g. internal)"]},{"entry":[{},{},{},"4-255: Reserved"]},{"entry":["VersionMajor","1","17","Major version of the Bus interface (optional)"]},{"entry":["VersionMinor","2","18","Minor version of the Bus interface ((optional)"]},{"entry":["MinimumLatency","4","20","Cost of time to transfer, described in nanoseconds. Sub 1 ns"]},{"entry":[{},{},{},"time to be rounded to 1 ns."]},{"entry":["MaximumLatency","4","24","Cost of time to transfer, described in nanoseconds. Sub 1 ns"]},{"entry":[{},{},{},"time to be rounded to 1 ns."]},{"entry":["Minimum","4","28","Minimum interface Bandwidth in MB\/s"]},{"entry":["Bandwidth",{},{},{}]},{"entry":["Maximum","4","32","Maximum interface Bandwidth in MB\/s"]},{"entry":["Bandwidth",{},{},{}]},{"entry":["Recommended","4","36","Recommended transfer size to reach maximum interface"]},{"entry":["TransferSize",{},{},"bandwidth in Bytes"]},{"entry":["Reserved","24","40","Reserved"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0135","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 14"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Flags field of the CRAT IO Affinity Structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Bit","Bit",{}]},{"entry":["Field","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Enabled","1","0","If clear, the OSPM ignores the contents"]},{"entry":[{},{},{},"of the FPU Affinity Structure. This"]},{"entry":[{},{},{},"allows system firmware to populate the"]},{"entry":[{},{},{},"CRAT with a static number of structures"]},{"entry":[{},{},{},"but only enable then as necessary."]},{"entry":["Coherency","1","1","If set, IO interface supports coherent"]},{"entry":[{},{},{},"transactions (natively or through"]},{"entry":[{},{},{},"protocol extensions)"]},{"entry":["Reserved","31","2","Must be zero"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Various embodiments of the present invention include a component locality distance information table (\u2018CDIT\u2019). This table provides a mechanism for the combined CPU\/APD architecture platform to indicate the relative distance (in terms of transaction latency) between all the combined CPU\/APD architecture system localities, which are also referred to herein as combined CPU\/APD architecture proximity domains. These embodiments represent improvements to the system locality distance information table (SLIT) as defined in the ACPI 4.0 Specification. The value of each entry[i, j] in the CDIT, where i represents a row of a matrix and j represents a column of a matrix, indicates the relative distances from component locality\/proximity domain i to every other component locality j in the system (including itself).","The i,j row and column values correlate to the fusion proximity domains defined in the CRAT table. In this illustrative embodiment, the entry values are one-byte unsigned integers. The relative distance from component locality i to component locality j is the (i*N+J)th entry in the matrix (index value is 2-byte unsigned integer), where N is the number of combined CPU\/APD architecture proximity domains. Except for the relative distance from a component locality to itself, each relative distance is stored twice in the matrix. This provides the capability to describe the scenario where the relative distances for the two directions between component localities is different. If one component locality is unreachable from another, a value of 255 (0xFF) is stored in that table entry. The relative distances from a component locality to itself are normalized to a value of 10, and distance values of 0-9 are reserved and have no meaning.",{"@attributes":{"id":"p-0138","num":"0137"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"294pt","align":"center"}},"thead":{"row":{"entry":"TABLE 15"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CDIT header structure"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Field","Byte","Byte",{}]},{"entry":["Header","Length","Offset","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Signature","4","0","\u2018CDIT\u2019. Signature for the Component Locality Distance"]},{"entry":[{},{},{},"Information Table."]},{"entry":["Length","4","4","Length, in bytes, of the entire CDIT. The length implies the"]},{"entry":[{},{},{},"number of Entry fields at the end of the table"]},{"entry":["Revision","1","8","0"]},{"entry":["Checksum","1","9","Entire table must sum to zero"]},{"entry":["OEMID","6","10","OEMID"]},{"entry":["OEM Table ID","8","16","For the Component Resource Affinity Table, the table ID is"]},{"entry":[{},{},{},"the manufacturer model ID"]},{"entry":["OEM Revision","4","24","OEM revision of Component Resource Affinity Table for"]},{"entry":[{},{},{},"supplied OEM Table ID"]},{"entry":["Creator ID","4","28","Vendor ID of utility that created the table"]},{"entry":["Creator Revision","4","32","Revision of utility that created the table"]},{"entry":["NumDomains","4","36","Number of combined CPU\/APD architecture proximity"]},{"entry":[{},{},{},"domains. This includes possible discrete APD \u201cdomains\u201d"]},{"entry":[{},{},{},"that are represented for possible Add-In-Boards attached e.g.."]},{"entry":[{},{},{},"via PCI Express. Not all of them may be populated initially"]},{"entry":[{},{},{},"at platform definition. This number may be higher than the"]},{"entry":[{},{},{},"CPU proximity domains expressed in SRAT due to additional"]},{"entry":[{},{},{},"entries for other (PCIe connected) combined CPU\/APD"]},{"entry":[{},{},{},"architecture components."]},{"entry":["Entry[0][0]","1","40","Matrix entry (0, 0), contains a value of 10"]},{"entry":[". . .",{},{},{}]},{"entry":["Entry[0][Number","1",{},{}]},{"entry":["of Domains-1]",{},{},{}]},{"entry":["Entry[1][0]","1",{},{}]},{"entry":[". . .",{},{},{}]},{"entry":["Entry[Number","1",{},"Contains a value of 10."]},{"entry":["of Domains-1]",{},{},{}]},{"entry":["[Number of",{},{},{}]},{"entry":"Domains-1]"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Various embodiments of the present invention include a combined CPU\/APD architecture table discovery device. The CRAT is returned when the \u2018CRAT\u2019 method located at the combined CPU\/APD architecture device ACPI node is evaluated. The component locality distance information table (CDIT) is returned when the CDIT method located at the combined CPU\/APD architecture device ACPI node is evaluated. The presence of the combined CPU\/APD architecture discovery device allows for a consistent notification mechanism for hot plug and hot-unplug notifications of combined CPU\/APD Architecture components, which in turn requires the reevaluation of the tables and methods. This logical ACPI device is required for a combined CPU\/APD architecture system compatible platform.",{"@attributes":{"id":"p-0140","num":"0139"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Plug and",{}]},{"entry":["Play ID","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ACPI000F","Combined CPU\/APD architecture Topology Reporting"]},{"entry":[{},"Device. This ID is used for combined CPU\/APD"]},{"entry":[{},"Architecture capable components. This device provides"]},{"entry":[{},"a control and notification point for all combined"]},{"entry":[{},"CPU\/APD Architecture components."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0141","num":"0140"},"figref":"FIG. 5","b":"502"},"The illustrative process of  further includes discovering  properties of APD compute cores including one or more of SIMD size, SIMD arrangement, local data store affinity, work queue properties, IOMMU affinity, and hardware context memory size; discovering  properties of support components including one or more of bus switches, and memory controller channels and banks; discovering  properties of system memory and APD local memory including but not limited to coherent and non-coherent access ranges; discovering  properties of one or more data paths including one or more of type, width, speed, coherence and latency; encoding  at least a portion of the discovered properties; and providing  one or more information structures and storing information in at least one of the one or more information structures, the stored information representative of at least a portion of the discovered properties.","It is noted that the present invention is not limited to any particular order in which the various properties are discovered. It is further noted that the present invention is not limited to any particular order in which the discovered properties are stored, encoded, reported, or otherwise communicated, transmitted, or made available for use, processing or inspection by any hardware, firmware, operating system or application software. It is still further noted that the present invention is not limited to any particular memory address range or physical type of memory in which the one or more information structures in accordance with the present invention are stored.","The present invention is not limited to any particular means or methods of property discovery. By way of example and not limitation, some properties may be exposed or discovered by executing one or more instructions by at least one of a plurality of computational resources, such instruction execution providing information in one or more registers, or in one or more memory locations. It is still further noted that the present invention is not limited by which particular properties are used by operating system or application software to schedule or distribute computational tasks amongst the computational resources of a combined CPU\/APD architecture system.",{"@attributes":{"id":"p-0145","num":"0144"},"figref":"FIG. 6","b":["602","604","606","608"]},"A property is relevant to scheduling and distribution of computational tasks if that property information is used by one or more computational resources of the combined CPU\/APD architecture system in the scheduling and\/or distribution of computational tasks. In connection with this description of the illustrative embodiment of , a hardware resource is one which provides (i) at least one computational resource that may be assigned to perform one or more computational tasks by the scheduling and distribution logic of operating system software, application software, or both; or (ii) a memory that can be assigned to one or more computational tasks by the scheduling and distribution logic of operating system software, application software, or both.","It is noted that addition of a hardware resource may occur as a result of \u201chot-plugging\u201d a board or a card into the system. Alternatively, a hardware resource may be physically present in the system but unavailable to be assigned computational tasks until it is \u201cadded\u201d through the action of firmware or software making the hardware resource available or visible to the scheduling and distribution logic of operating system software, application software, or both. In this case, \u201cadding\u201d may be referred to as enabling. Similarly, a hardware resource may be removed from the system either by being physically removed therefrom, or by being disabled, or made not visible to the scheduling and distribution logic of operating system software, application software, or both. In this case, \u201cremoving\u201d may be referred to as disabling. It is noted that the present invention is not limited to any particular means or method of enabling and disabling a hardware resource. Such hardware resources may be enabled to achieve particular performance levels and disabled to reduce power consumption. Alternatively, a hardware resource may disabled, i.e., made unavailable to receive a task from the scheduling and distribution logic, because that hardware resource has been reserved for another purpose.","In one illustrative embodiment of the present invention, a system includes, but is not limited to, a first computer memory having a predetermined physical storage size and logical arrangement; a first CPU coupled to the first computer memory; the first CPU having a predetermined number of discoverable properties; a first APD coupled to the first computer memory, the first APD having a predetermined number of discoverable properties; and a means for determining at least a portion of the discoverable properties of the first CPU and at least a portion of the discoverable properties of the first APD, encoding the discovered properties and storing the encoded properties in a memory table. It is noted that such a means for determining includes, but is not limited to, software executed by the first CPU, software executed by the first APD, or software executed by both the first CPU and the first APD.","One illustrative method of operating a combined CPU\/APD architecture system, in accordance with the present invention includes discovering properties of one or more CPU compute cores; discovering properties of one or more APD compute cores; discovering properties of one or more support components; discovering properties of a system memory; if an APD local memory is present, discovering properties of the APD local memory; discovering properties of data paths including one or more of type, width, speed, coherence and latency; encoding at least a portion of the discovered properties; and providing one or more information structures and storing information in at least one of the one or more information structures, the stored information representative of at least a portion of the discovered properties. Typically the discovered properties are relevant to scheduling computational tasks to one or more of a plurality of computational resources in the combined CPU\/APD architecture system. In some embodiments, at least a portion of the discovered properties are discovered by executing one or more instructions on at least one of a plurality of computational resources, such instruction execution providing information in one or more registers of the computational resource executing the one or more instructions, or in one or more memory locations of a memory coupled to the computational resource.","In various alternative embodiments, the method of operating a combined CPU\/APD architecture system includes repeating one or more of the discovering operations subsequent to the detection of the addition or removal of at least one hardware resource. In this way, the information relevant to scheduling and distribution of computational tasks may be dynamically updated to reflect the hardware resources that are available at a particular point in time.","Another illustrative method of operating a combined CPU\/APD architecture system in accordance with the present invention includes discovering, by operation of the combined CPU\/APD architecture system, properties relevant to scheduling and distribution of computational tasks in a combined CPU\/APD architecture system; providing, by operation of the combined CPU\/APD architecture system, one or more information structures and storing information in at least one of the one or more information structures, the stored information representative of at least a portion of the discovered properties; determining, by operation of the combined CPU\/APD architecture system, whether one or more hardware resources have been added to, or removed from, the combined CPU\/APD architecture system; and subsequent to determining that one or more hardware resources have been added to, or removed from, the combined CPU\/APD architecture system, discovering, by operation of the combined CPU\/APD architecture system, at least one property relevant to scheduling and distribution of computational tasks in the combined CPU\/APD system.","It is noted that the present invention is not limited to the combination of x86 CPU cores with APDs, but is applicable to various CPU or instruction set architectures combined with APDs.","The exemplary methods and apparatus illustrated and described herein find application in at least the fields of computing devices (including, but not limited to, notebook, desktop, server, handheld, mobile and tablet computers, set top boxes, media servers, televisions and the like), graphics processing, and unified programming environments for heterogeneous computational resources.","It is to be understood that the present invention is not limited to the illustrative embodiments described above, but encompasses any and all embodiments within the scope of the subjoined claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS\/FIGURES","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
