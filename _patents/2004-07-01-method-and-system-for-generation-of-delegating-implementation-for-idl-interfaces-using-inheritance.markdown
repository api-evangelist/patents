---
title: Method and system for generation of delegating implementation for IDL interfaces using inheritance
abstract: A method of generating an interface definition language (IDL) interface involves identifying parents for the IDL interface, identifying parent interfaces associated with the parents, wherein the parent interfaces include concrete parent interfaces, computing a set of directly implemented methods for the parent interfaces, generating an implementation of the IDL interface with the concrete parent interfaces to generate a plurality of delegation fields, generating an initialization method and a setting method for each of the plurality of delegation fields, and generating indirectly implemented methods with a body that delegates functionality to one of the plurality of delegate fields.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07735015&OS=07735015&RS=07735015
owner: Oracle America, Inc.
number: 07735015
owner_city: Redwood Shores
owner_country: US
publication_date: 20040701
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application is a continuation of U.S. patent application Ser. No. 09\/860,654, filed on May 18, 2001 now U.S. Pat. No. 6,788,317, and claims the benefit, pursuant to 35 U.S.C. \u00a7120, of that application.","Applications developed using distributed objects such as Common Object Request Broker Architecture (CORBA) naturally lend themselves to multi-tiered architecture, fostering a neat separation of functionality. A three-tiered application has a user interface code tier, a computation code (or business logic) tier, and a database access tier. All interactions between the tiers occur via the interfaces that all CORBA objects publish.  illustrates the transition from monolithic applications to multi-tiered, modular applications. A first generation system () has a graphical user interface (GUI) (), a business logic (), and a data store () all combined into one monolithic application. A next generation system () has the GUI () and the business logic () as one application with an interface to the data store (). A latest generation system () has three distinct tiers. A first tier or user interface (UI) tier () includes one or more GUI (), which interface with one or more service logic () in a second tier or service tier (). The service logic () in the service tier () interfaces with other service logic (), one or more GUI (), and one or more data sources (). A third tier or data store tier () includes one or more data sources (), which interface with one or more service logic ().","The UI tier is the layer of user interaction. The focus is on efficient user interface design and accessibility. The UI tier can reside on a user desktop, on an Intranet, or on the Internet. Multiple implementations of the UI tier may be deployed accessing the same server. The UI tier usually invokes methods on the service tier and, therefore, acts as a client. The service tier is server-based code with which client code interacts. The service tier is made up of business objects (CORBA objects that perform logical business functions, such as inventory control, budget, sales order, and billing). These objects usually invoke methods on the data store tier objects. The data store tier is made up of objects that encapsulate database routines and interact directly with the database management system product or products.","CORBA is the standard distributed object architecture developed by an Object Management Group (OMG) consortium. The mission of the OMG is to create a specification of architecture for an open software bus, or Object Request Broker (ORB), on which object components written by different vendors can interoperate across networks and operation systems.","The ORB is middleware that establishes the client-server relationships between objects by interacting and making requests to differing objects. The ORB sits between distributed (CORBA) objects in the second tier of the three tier architecture and operates as a class library enabling low-level communication between parts (objects) of CORBA applications. Programmers usually write applications logic in CORBA and the application logic is then connected to the data store by using some other application, e.g., ODBC, JDBC, proprietary, etc. Usually only objects in the application logic communicate using the ORB. Using the ORB, a client transparently invokes a method on a server object, which can be on the same machine or across a network. The ORB intercepts a call and is responsible for finding an object that can implement a request, pass the object a plurality of parameters, invoke the method, and return the results. The client does not have to be aware where the object is located, the programming language of the object, the operating system of the object, or any other system aspects that are not part of the interface of the object. In other words, the application logic can be run on many hosts in many operating systems and parts of the application logic can be written in different computer languages.","The diagram, shown in , shows a method request () sent from a client () to an instance of a CORBA object implementation, e.g., servant () (the actual code and data that implements the CORBA object) in a server (). The client () is any code that invokes a method on the CORBA object. The client () of the CORBA object has an object reference () for the object and the client () uses this object reference () to issue method request (). If the server object () is remote, the object reference () points to a stub function (), which uses the ORB machinery () to forward invocations to the server object (). The stub function () encapsulates the actual object reference (), providing what seems like a direct interface to the remote object in the local environment. The stub function () uses the ORB () to identify the machine that runs the server object and, in turn, asks for that machine's ORB () for a connection to the object's server (). When the stub function () has the connection, the stub function () sends the object reference () and parameters to the skeleton code () linked to an implementation of a destination object. The skeleton code () transforms the object reference () and parameters into the required implementation-specific format and calls the object. Any results or exceptions are returned along the same path.","The client () has no knowledge of the location of the CORBA object, implementation details of the CORBA object, or which ORB () is used to access the CORBA object. A client ORB () and a server ORB () communicate via the OMG-specified Internet InterORB Protocol (IIOP) (). The client () may only invoke methods that are specified in the interface of the CORBA object. The interface of the CORBA object is defined using the OMG Interface Definition Language (IDL). CORBA objects can be written in any programming language for which there is mapping from IDL to that language (e.g., Java\u2122, C++, C, Smalltalk, COBOL, and ADA). The IDL defines an object type and specifies a set of named methods and parameters, as well as the exception types that these methods may return. An IDL compiler translates the CORBA object's interface into a specific programming language according to an appropriate OMG language mapping.","Referring to , the stub files () and skeleton files () are generated by an IDL compiler for each object type. Stub files () present the client () with access to IDL-defined methods in the client programming language. The server skeleton files () figuratively glue the object implementation to the ORB () runtime. The ORB () uses the skeletons () to dispatch methods to the servants ().","All CORBA objects support an IDL interface. The IDL interface defines an object type and can inherit from one or more other interfaces. The IDL syntax is very similar to that of Java\u2122 or C++. The IDL is mapped into each programming language to provide access to object interfaces from that particular language. Using an IDL compiler of a CORBA implementation for Java\u2122, the IDL interfaces are translated to Java\u2122 constructs according to IDL to Java\u2122 language mapping. For each IDL interface, IDL compiler generates a Java\u2122 interface, classes, and other \u201c.java\u201d files needed, including the stub files and the skeleton files.","As a general guide, creating a CORBA-based distributed application has five steps as shown in . The first step is to define a remote interface (Step ). The interface is defined using the IDL. Also, by using the IDL, the possibility exists to implement clients and servers in any other CORBA-compliant language. If the client is being implemented for an existing CORBA service, or the server for an existing client, the IDL interfaces come from the implementer, e.g., a service provider or vendor. The IDL compiler is then run over those interfaces.","Referring to , the second step is to compile the remote interface (Step ). When the IDL compiler is run over the interface definition file, the Java\u2122 version of the interface is generated along with class code files for the stubs and skeletons that enable applications to hook into the ORB.","The third step is to implement the server (Step ). Once the IDL compiler is run, the skeletons generated by the compiler are used to put together the server application. In addition to implementing the methods of the remote interface, the server code includes a mechanism to start the ORB and wait for invocation from a remote client.","The fourth step is to implement the client (Step ) as shown in . Similarly to the implementation of the server, the stubs generated by the IDL compiler are used as the basis of the client application. The client code builds on the stubs to start the ORB, obtain a reference for the remote object, and call the method.","The fifth step is to start the application (Step ). Once the server and client have been implemented and the server is started, the client is run.","In certain circumstances, a form of inheritance or delegation is involved in the CORBA-based distributed application development process. Inheritance can take several forms, including single inheritance and multiple inheritance. Single inheritance is explained by the following example. An Object A implements a Method A. If Object B is formed by inheriting from Object A, then Object B inherits all of the functionality of Object A such that Object B now implements Method A. Furthermore, the declaration of Object B need not contain any source code related to Method A.","Referring to , in this example of normal single inheritance, interfaces are defined in the IDL (Interface Definition Language) as interface A () and interface B (). The IDL compiler generates skeleton classes APOA () and BPOA (). The Implementation Generator generates implementation classes AImpl () and BIpml (). In this example, operations operation_A( ) () in AImpl () and operation_A( ) () and operation_B( ) () in BImpl () are empty and the developer adds functionality into these methods.","An object has multiple inheritance if the object inherits from more than one other object. For example, Object A implements Method A and Object B implements Method B. Object C can be formed from Object A and Object B such that Object C implements Method A and Method B. Further, the declaration of Object C need not contain any code that relates to Method A or Method B.","Delegation can take several forms, including static delegation and virtual delegation. With static delegation, methods call a method directly on the object that implements the delegated method directly. For example, an Object C is said to delegate to Objects A and B if instead of inheriting from the objects the object uses a actual separate instances of Objects A and B to perform a method implementation. With, virtual delegation, a method calls a method implemented on the most derived parent object that implements the delegated method.","As illustrated in , Forte\u2122 for Java\u2122 products (), formerly called NetBeans, are visual programming environments written entirely in Java\u2122. These products are commonly regarded as the leading Integrated Development Environment (IDE). IDEs are easily customizable and extensible, as well as platform independent. Forte\u2122 for Java\u2122 () includes a Form Editor (), an integrated full-featured text editor (), a debugger (), and a compiler (). Forte\u2122 for Java\u2122 () is also completely modular. Forte\u2122 for Java\u2122 () is built around a set of Open Application Programming Interface (API's), which allow it to be easily extensible. This means that the IDE functionality for editing, debugging, GUI generation, etc. is represented in modules that can be downloaded and updated dynamically as is illustrated in . Instead of waiting for a completely new release, as soon as new versions () or new modules () are available, users can update that individual version or module via the Update Center ().","In general, in one aspect, the present invention involves a method of generating an interface definition language (IDL) interface. The method involves identifying parents for the IDL interface, identifying parent interfaces associated with the parents, wherein the parent interfaces include concrete parent interfaces, computing a set of directly implemented methods for the parent interfaces, generating an implementation of the IDL interface with the concrete parent interfaces to generate a plurality of delegation fields, generating an initialization method and a setting method for each of the plurality of delegation fields, and generating indirectly implemented methods with a body that delegates functionality to one of the plurality of delegate fields.","In general, in one aspect, the present invention involves a method of generating an interface definition language (IDL) interface. The method involves identifying parents for the IDL interface, identifying parent interfaces associated with the parents, wherein the parent interfaces includes concrete parent interfaces, computing a set of directly implemented methods for the parent interfaces, generating an implementation of the IDL interface with the concrete parent interfaces to generate a plurality of delegation fields, generating an initialization method and a setting method for each of the plurality of delegation fields, and generating indirectly implemented methods with a body that delegates functionality to one of the plurality of delegate fields. The indirectly implemented methods are generated to guarded blocks. Generating the body includes generating a full body implementation for each of the indirectly implemented methods, wherein the full body implementation includes delegation source code, a delegation object attribute, and an initialize inheritance tree method. The type of delegation is one selected from the group including none, static delegation, and virtual delegation.","In general, in one aspect, the present invention involves a computer system adapted to generate an interface definition language (IDL) interface. The computer system includes a processor, a memory element, and software instructions. The software instructions enable the computer under control of the processor, to perform identifying parents for the IDL interface, identifying parent interfaces associated with the parents, wherein the parent interfaces include concrete parent interfaces, computing a set of directly implemented methods for the parent interfaces, generating an implementation of the IDL interface with the concrete parent interfaces to generate a plurality of delegation fields, generating an initialization method and a setting method for each of the plurality of delegation fields, and generating indirectly implemented methods with a body that delegates functionality to one of the delegate fields.","In general, in one aspect, the present invention involves a system for generating an implementation for an interface definition language (IDL) interface, The system includes means for identifying parents for the IDL interface, means for identifying parent interfaces associated with the parents, wherein the parent interfaces include concrete parent interfaces, means for computing a set of directly implemented methods for the parent interfaces, means for generating an implementation of the IDL interface with the concrete parent interfaces to generate a plurality of delegation fields, means for generating an initialization method and a setting method for each of the plurality of delegation fields, and means for generating indirectly implemented methods with a body that delegates functionality to one of the plurality of delegate fields.","In general, in one aspect, the present invention involves a method for generating an interface definition language interface (IDL). The method involves generating at least one directly implemented method for each of a plurality of parent interfaces, determining at least one inheritance relationship among the plurality of parent interfaces; generating at least one delegation field using the at least one inheritance relationship, determining a type of delegation to apply to the at least one delegation field, generating at least one delegation method configured to delegate control to the at least one delegation field in manner defined by the type of delegation. The at least one delegation field to which control is delegated is determined using the at least one inheritance relationship.","Other aspects and advantages of the invention will be apparent from the following description and the appended claims.","Specific embodiments of the invention will now be described in detail with reference to the accompanying figures. Like elements in the various figures are denoted by like reference numerals for consistency.","The invention described here may be implemented on virtually any type computer regardless of the platform being used. For example, as shown in , a typical computer () includes a processor (), an associated memory element (), a storage device (), and numerous other elements and functionalities typical to today's computers (not shown). The computer () may also include input means, such as a keyboard () and a mouse (), and an output device, such as a monitor (). Those skilled in the art will appreciate that these input and output means may take other forms. Computer () is connected via a network connection () to the Internet ().","As discussed above and shown in , development of CORBA object applications starts with a developer defining remote interface(s) (Step ) of CORBA server objects using the IDL which is part of the CORBA specification. Next, the description of interface(s) is compiled using the IDL compiler (Step ) into constructs in a target computer language. Mapping of the IDL constructs into constructs in the target language is specified by the CORBA specification. In the case of the CORBA implementation written in Java\u2122, these constructs are classes in Java\u2122 and provide all necessary functionality for communicating over the ORB. The third and fourth steps in writing the CORBA application is writing implementation of defined interface(s) for the server (Step ) and the client (Step ). Writing the implementation is done in the target language and usually extends constructs produced by the IDL compiler. CORBA implementation written in Java\u2122 requires the implementation be written with a new class for every interface that extends or implements some generated class.","Returning to the Forte\u2122 for Java\u2122 IDE, a CORBA support module () as shown in  has been-created to be used within Forte\u2122 for Java\u2122 or any other IDE to develop, test, and debug any kind of CORBA application. The CORBA support module () provides support for writing the IDL file in an editor () or generating the IDL file from various templates (). The IDL file is then compiled using an IDL Compiler () into constructs in a target computer language, such as classes in Java\u2122. The support module () also provides support for editing or generating client and server main and implementation classes. Further, the CORBA support module () includes browsers for interface repository and name service (), a POA support component (), and a CORBA wizard component ().","An important part of the CORBA support module () of the Forte\u2122 for Java\u2122 IDE is an Implementation Generator (). After writing the IDL file, the developer implements all interfaces that are written to the IDL file. The support module () assists the developer with this task through the medium of the Implementation Generator (). Using the Implementation Generator (), the developer can generate a basic implementation (i.e., an implementation with empty method body) for all interfaces from the IDL file. During the generation of the implementation, customizable options are available of certain setup properties (e.g., generation of method bodies, etc.).","The Implementation Generator is activated either by selecting the \u201cGenerate Implementation\u201d menu item () in a standard pop-up menu from within the IDL Node () in the Explorer () as shown in , or by selecting the Generate Implementation menu item in a standard pop-up menu in the a source editor () as shown in . The result is source code in the source editor within the IDE in Java\u2122 language.","In certain circumstances, the Implementation Generator is required to resolve inheritance issues. The present invention involves a method of supporting multiple object inheritance in a language that does not natively support multiple inheritance, such as Java\u2122. One skilled in the art will appreciate that many object oriented languages do not support multiple inheritance. The method implemented in place of inheritance (multiple or single) is delegation of an inherited method into a method of the parent implementation. In accordance with one or more embodiments of the present invention, Forte\u2122 for Java\u2122 IDE supports generation of full delegation code for implementation of IDL interface that extends parent(s).","Single inheritance through delegation in accordance with one or more embodiments of the present invention is shown in . The interfaces are defined in the IDL as interface A () and interface B (). The Forte\u2122 for Java\u2122 IDE implementation generator generates implementation classes AImpl and BImpl. The implementation code is generated in the form of classes AImpl () and BImpl (). BImpl () contains a reference to an object of type AImpl () and indirectly implements operation_A( ) () by calling the implementation of operation_A( ) () in object AImpl (). Thus, the implementation of operation_A( ) () is delegated to the object AImpl () referenced by object BImpl (). Operations operation_A () in AImpl () and operation_B () in BImpl () are with empty bodies so the developer adds functionality to these operations. However, operation_A () in BImpl () has body, which uses delegation to operation_A in instance of AImpl () to provide its functionality.","A more complex case of inheritance through delegation in accordance with one or more embodiments of the present invention is shown in . The interfaces are defined in the IDL as interface A (), interface B (), and interface C (). The Forte\u2122 for Java\u2122 IDE implementation generator generates the implementation code in the form of classes AImpl (), BImpl (), and CImpl (). BImpl () contains a reference to an object of type AImpl () and indirectly implements operation_A( ) () by calling the implementation of operation_A( ) () in object AImpl (). Thus, the implementation of operation_A( ) () is delegated to the object AImpl () referenced by object BImpl (). Object CImpl () contains a reference to objects of type AImpl () and a reference to objects of type BImpl (). Object CImpl indirectly implements operation_B( ) () by calling the implementation of operation_B( ) in object BImpl (). Object CImpl () indirectly implements operation_A( ) (). If static delegation is used, then operation_A( ) () is implemented by calling the implementation of operation_A( ) () in object AImpl (). If virtual delegation is used, then operation_A( ) () is implemented by calling the implementation of operation_A( ) () in object BImpl ().","The implementation generator generates implementation for IDL interface with parent(s) and inheritance using the following method as shown in . First, all parents are identified for an interface (Step ). Once all parents are identified (Step ), a set of directly implemented methods is computed for all parent interfaces, including the interface above (Step ). The delegation fields of types of concrete interfaces' implementations are then generated into an implementation of the interface (Step ). Next, initialization and settings method are generated for the delegation fields (Step ). Lastly, non-directly implemented methods with a body that delegates functionality to one of the delegate fields (an instance) are generated (Step ). The specifics of the generation of non-directly implemented methods depends heavily on the type of delegation chosen.","In accordance with one or more embodiments of the present invention, implementation of inheritance support for the implementation generator component within the CORBA Support Module has three delegation settings, including a none setting, a Static Delegation setting, and a Virtual Delegation setting. The none setting uses a default Forte\u2122 for Java\u2122 IDE implementation generator. The Static Delegation setting enables methods to call methods directly on the object that directly implements the delegated methods. The Virtual Delegation setting enables methods to call methods on the most derived object that implements the delegated method.","A typical IDL file defining interface A and interface B, which inherits from interface A is shown below.",{"@attributes":{"id":"p-0055","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"interface A {"]},{"entry":[{},"\u2003void op ( );"]},{"entry":[{},"\u2003};"]},{"entry":[{},"\u2003interface B : A {"]},{"entry":[{},"\u2003void op2 ( );"]},{"entry":[{},"\u2003};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"A typical implementation generated by a developer using Forte\u2122 for Java\u2122 IDE implementation generator creates two files (Almpl.java and BImpl.java) is shown below.",{"@attributes":{"id":"p-0057","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/*"]},{"entry":[{},"\u2009* This file was generated from inher1.idl"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"package idls_local.newFeatures;"]},{"entry":[{},"class AImpl extends idls_local.newFeatures._AImplBase {"]},{"entry":[{},"\u2003\u2003public void op( ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003throw new UnsupportedOperationException ( );"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},"\/*"]},{"entry":[{},"\u2009* This file was generated from inher1.idl"]},{"entry":[{},"\u2009*\/"]},{"entry":[{},"package idls_local.newFeatures;"]},{"entry":[{},"class BImpl extends idls_local.newFeatures._BImplBase {"]},{"entry":[{},"\u2003\u2003public void op( ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003throw new UnsupportedOperationException ( );"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003\u2003public void op2( ) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003throw new UnsupportedOperationException ( );"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In accordance with one or more embodiments of the present invention, full bodies are generated for inherited methods where the methods are delegated to embedded implementation of a parent interface. When the typical IDL file defining interface A and interface B above is generated with the implementation generator using delegation, a class AImpl is generated as source code () in a source editor as shown in  and a class BImpl is generated as source code () in a source editor as shown in .","To help preserve integrity, inherited (delegated) methods and required fields may be generated to the guarded blocks so the developer is not able to change the method or required fields. Once the guarded blocks are implemented, the only way to change the source code is to make changes to the IDL file.","A \u201cfull body implementation\u201d requires generation of delegation source code, creation of a delegated object attribute, and creating of an _initialize_inheritance_tree method. For delegation of certain classes, an initialized instance field(s) of the type of a parent(s) implementation(s) is needed. The instance fields are generated in a certain implementation for all parents even for parents of parent, e.g., three interfaces A, B, and C where B inherits from A and C inherits from B. In the implementation of C (in class CImpl) a field of type BImpl (implementation for interface B) and a field of type AImpl (implementation for interface A) are generated.","To properly initialize these delegation fields a particular method is generated. This method is usually named \u201c_initialize_inheritance_tree\u201d and is responsible for proper initialization of delegation fields. The method uses a setter method for setting the parent's instances for the certain implementation.","Next, the initialization method is called from a constructor and a default constructor is generated with a full method body resulting in the implementation of the IDL file shown in .","After generating all the helper methods and fields, delegation methods with full body can be generated where these methods call methods of the same name on the certain parent instance.","IDL Abstract Interfaces are intended for situations where, at compile time, it is unknown whether an object will be passed by reference or by value.","Interfaces that inherit from an abstract parent are unable to embed implementation of the abstract interface. Therefore, the implementation is unable to have full method bodies (i.e., only empty bodies are possible) making generation of delegation for abstract interfaces more complex.","The following IDL file example will assist explaining the method of generating delegation for abstract interfaces:",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ abstract_interface.idl"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Created on November 20, 2000, 10:49 AM"]},{"entry":[{},"\/\/ by kgardas"]},{"entry":[{},"\/\/"]},{"entry":[{},"abstract interface Printable {"]},{"entry":[{},"\u2003\u2003void print ( );"]},{"entry":[{},"};"]},{"entry":[{},"interface HelloWorld : Printable {"]},{"entry":[{},"\u2003\u2003attribute string msg;"]},{"entry":[{},"\u2003\u2003\/\/string msg ( );"]},{"entry":[{},"};"]},{"entry":[{},"interface Demo : HelloWorld {"]},{"entry":[{},"\u2003\u2003void run ( );"]},{"entry":[{},"};"]},{"entry":[{},"interface XX : Demo {"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The implementation generator delegates a method print to the concrete (non-abstract) interfaces. The possible delegations are none, static and virtual. None delegation causes nothing dramatic to happen. The generator generates empty methods print for all implementations for all concrete interfaces. In case of other delegation types the implementation of interface HelloWorld directly implements operation print from its parent Printable, so the developer has to write implementation for this operation. The implementation of interface Demo delegates operation print into implementation of its parent HelloWorld. Only generation of implementation of interface XX differs for static and virtual delegation. In case of static delegation, implementation of interface XX delegates its operation print into the implementation which directly implements this operation. This is the implementation of interface HelloWorld. In case of virtual delegation, implementation of interface XX delegates its operation print into the implementation of the most derivated parent. This is the implementation of interface Demo.","In case that an interface directly inherits from an abstract interface, the implementation class of this interface generated by the Implementation Generator has methods defined by the abstract interface generated with empty bodies. For instance, as the interface Demo inherits from Printable twice (directly and indirectly via HelloWorld interface), the method \u201cprint\u201d generated to the implementation of interface Demo has an empty body.",{"@attributes":{"id":"p-0070","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ abstract_interface.idl"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Created on November 20, 2000, 10:49 AM"]},{"entry":[{},"\/\/ by kgardas"]},{"entry":[{},"\/\/"]},{"entry":[{},"abstract interface Printable {"]},{"entry":[{},"\u2003\u2003void print ( );"]},{"entry":[{},"};"]},{"entry":[{},"interface HelloWorld : Printable {"]},{"entry":[{},"\u2003\u2003attribute string msg;"]},{"entry":[{},"\u2003\u2003\/\/string msg ( );"]},{"entry":[{},"};"]},{"entry":[{},"interface Demo : HelloWorld, Printable {"]},{"entry":[{},"\u2003\u2003void run ( );"]},{"entry":[{},"};"]},{"entry":[{},"interface XX : Demo {"]},{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Properties of the CORBA Support Settings and some additional properties of the expert properties of these settings have been added. The two main added properties are for defining delegation type and defining guarded blocks usage.  shows a dialog box containing various project settings with the properties tab () showing interface generation options. Specifically, the Delegation Type option () may be selected by using a standard drop down box () that lists the available options of None (), Static (), and Virtual (). The currently selected option is highlighted () and displayed in the drop down box ().  shows a dialog box containing various project settings with the expert tab () showing expert interface generation options. The Use Guarded Blocks option () may be selected by using a drop down box (), which lists the available options of True () and False (). The currently selected option is highlighted () and displayed in the drop down box ().","Advantages of the present invention may include one or more of the following. The delegation of inherited methods into the method of a parent implementation is supported. Full delegation code for implementation of IDL interface can be generated. Those skilled in the art will appreciate that the present invention may include other advantages and features.","While the invention has been described with respect to a limited number of embodiments, those skilled in the art, having benefit of this disclosure, will appreciate that other embodiments can be devised which do not depart from the scope of the invention as disclosed herein. Accordingly, the scope of the invention should be limited only by the attached claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
