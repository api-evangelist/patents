---
title: Compositional lifting of operations over structural types
abstract: A set of syntactic extensions that are compiled with a type-directed translation method to facilitate lifting member access on base types to a newly constructed type. The extensions are processed with a type system that facilitates seamless data access to relational and semi-structured data in an object oriented host language.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07912863&OS=07912863&RS=07912863
owner: Microsoft Corporation
number: 07912863
owner_city: Redmond
owner_country: US
publication_date: 20040730
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","SUMMARY"],"p":["This application is related to co-pending U.S. patent application Ser. No. 10\/909,060 entitled \u201cTYPE-SYSTEM EXTENSIONS FOR OBJECT-ORIENTED LANGUAGE BASED ON COERCIVE SUBTYPING WITH RESTRICTIONS\u201d filed on Jul. 30, 2004.","This invention is related to object-oriented (OO) languages, and more specifically, to data access using an OO language.","Programming languages need to continuously evolve to help programmers cope with complicated applications. These evolutionary steps are typically quite modest; most commonly, the provisioning of better or reorganized APIs (Application Program Interfaces). Occasionally, a more radical evolutionary step is taken. One such example is the addition of generic classes to languages such as both Java and C.","The time has come, however, for another large evolutionary step to be taken. Much software is now intended for distributed, web-based scenarios. It is typically structured using a three-tier model consisting of a middle tier containing the business logic that extracts relational data from a data services tier (a database) and processes it to produce semi-structured data (typically XML\u2014eXtensible Markup Language) to be displayed in the user interface tier. These middle tier applications are most commonly written in an object-oriented language such as Java or C and have to deal with relational data (essentially SQL (Structured Query Language) tables), object graphs, and semi-structured data (e.g., XML, HTML).","Unfortunately support for such data access has barely evolved at all. All that exists is naive access via simple APIs. Consider the following fragment of Java that uses JDBC (Java DataBase Connectivity\u2014which is an API that lets a Java application access a database via SQL) to query a SQL database (the user-supplied country is stored in variable input).\n\n","Using strings to represent SQL queries is not only clumsy but also removes any possibility for static checking. The impedance mismatch between the language and the relational data is quite striking; e.g., a value is projected out of a row by passing a string denoting the column name and using the appropriate conversion function. Perhaps most seriously, the passing of queries as strings is often a security risk (the \u201cscript code injection\u201d problem\u2014e.g., consider the case when the variable input is the string \u201c'OR 1=1\u2212\u201d.","The future of e-commerce is largely dependant on development of what are referred to as Web Services, which are Internet-based APIs that provide valuable functions or services for users. For example, Microsoft Passport\u00ae is a Web Service that facilitates user interaction by transferring user profile information to designated websites. The broad idea behind Web Services is to loosely couple heterogeneous computer infrastructures together to facilitate data transmission and computation to provide the user with a simple yet powerful experience.","A significant component in functionality of Web Services is programmatic interaction with web data. However, the world of web data is presently quite disjunctive. In general, there are three major components that make up the world of web data\u2014relational data (e.g., SQL), semi-structured data (e.g., XML), and a runtime environment.  illustrates a Venn diagram  that depicts a conventional web data world. A popular method of implementing a relational data model is by means of SQL that facilitates accessing data of a relational database system which is typically stored in tables. An accepted standard for semi-structured data is XML. XML is a World Wide Web Consortium (W3C) standard language that describes data via a schema or Document Type Definition (DTD). XML data is stored through the use of tags. A runtime environment is a general-purpose multilanguage execution engine (e.g., Common Language Runtime (CLR)) that allows authors to write programs that use both relational data and self-describing data.","However, in common with the situation with relational data access, there is also an impedance mismatch between looseness of the \u201cdocument world\u201d from which XML evolved, and a more structured world of object-oriented (OO) programming languages, which dominate the applications world. Bridging these two worlds today is conventionally accomplished by employing specialized objects that model the XML world called \u201cXML Document Object Model,\u201d or by \u201cXML Serialization\u201d technologies, which intelligently map one world into the other at runtime. However, these bridging mechanisms are often cumbersome and\/or limited in functionality.","Object-oriented languages like C++, Java, and C# provide a way of defining classes and\/or structs, and then constructing instances of those types via \u201cconstructors\u201d using the \u201cnew\u201d operator. The objects being constructed and the arguments being passed to the constructors are all strongly typed. These languages usually also provide convenience mechanisms for initializing simply homogeneous arrays of objects. These constructs are designed to make programs written in these languages run fast.","XML, on the other hand, provides syntax for describing heterogeneous graph(s) of data where typing rules (usually called \u201cschema validation\u201d) are entirely optional and loosely bound to those type instances. Furthermore, the XML schemas associated with those documents can describe more complex structures with sequences, choices, unbounded type collections, and a combination of typed and untyped data using constructs like <xsd:any\/> and <xsd:anyAtrribute\/>. These constructs are designed to allow a loosely coupled architecture that minimizes hard dependencies between different parties that make up a complex distributed system and have proven to be the only way to make distributed systems scale up to a level of complexity required for today's interconnected business systems.","Seamless integration of data-access in an OO host language is an extremely tricky problem and many people have attempted to solve this problem in the past with varying degrees of success. At the heart of the problem are three different and distinct type systems: the semi-structured XML that is used to describe data elements on web page and business-to-business documents; the SQL language, that is used to interrogate and process data in a relational database; and, the CLR, which are OO services and security services that applications can use.","Dealing with the complexity of these disparate models is a major pain for programmers today, since mainstream programming languages like C, C++, VB, C#, or Java simply do not know anything about relational or semi-structured data, yet programmers need to deal with all three data models at once.","Most programming languages do not provide an integrated view of these three worlds, but typically provide a \u201chands off\u201d API to access one domain from the other. However, data integration via APIs has reached its limits. Alternatively, various methods of so-called data-binding have been explored where concepts from an XML or relation world are mapped onto the OO world. However, without type-system and language extensions these attempts will only be of limited value because of the size of the impedance mismatch they are attempting to bridge.","Unfortunately API support in both Java and C# for XML and XPath\/XQuery is depressingly similar. XPath has been widely used in the XML community as a query language to navigate and retrieve from an XML data source. Furthermore, XQuery uses XPath as its query language to retrieve data from an XML data source.","Due to the increasingly complex nature of software systems, programmers have been riddled by undetectable programmatic errors that oftentimes do not manifest until too late. Developers continue to try to expand power of programming languages by incorporating complex mathematical and philosophical concepts. Additionally, the software market is becoming increasingly platform independent and service oriented. Combining powerful object-oriented programmatic concepts into the new data centric and service based world causes programmers problems as they try and piece together best parts of a multitude of different technologies in an ad hoc fashion.","Type systems are a formal mechanism for ensuring that typed programs perform correctly and in a well-behaved manner. Typed programs or typed systems are generally programs or systems that assign types to variables (e.g., Boolean, integer, real, etc.) or objects. Types are classifications of data that describe how a programmer wants to use the data and how a compiler should interpret such data. However, many functions are only defined to work on particular types (e.g. integer addition or floating point addition). If a given function is defined to work with a certain data type and it receives a different type of data, a type error will be produced. A type system can prevent certain execution errors by utilizing a type-checking algorithm to determine whether a program is well behaved or ill behaved. This process is referred to as type checking. Type checking allows for early detection and therefore correction of errors that may often go undetected by programmers. If such errors are left uncorrected they may lurk in the code, only to become manifestly obvious at a most inopportune time.","In general there are two varieties of type systems\u2014nominal and structural. A nominal type system is a system in which type names are used to determine whether types are equivalent. In a structural type system, names are not essential, because types are said to be equivalent if they have the same structure, as the name suggests. For example assume Type A=string of integers (1 . . . 10) and Type B=string of integers (1 . . . 10). Further assume that a is of Type A, b is of Type B, and the expression a=b is written into the same program. Under a nominal type system this expression would produce an error because a and b are of different types. Under a structural type system such an assignment would be legal because the types are equivalent.","There is an unmet need for common OO languages to evolve to support data access associated the rich structure of both relational and semi-structured data.","The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key\/critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.","The present invention disclosed and claimed herein, in one aspect thereof, comprises a type-directed translation method that facilitates the lifting of member access of base types to newly constructed types. A data access component includes a type system that works with the syntactic extensions to extend an objected oriented language to access semi-structured data and relational data.","In another aspect of the present invention, the type-directed translation method compiles the syntactic extensions to lift member access over a receiver.","In yet another aspect thereof, the type-directed translation method compiles the syntactic extensions to lift member access over one or more arguments.","In still another aspect of the present invention, the type-directed translation method compiles the syntactic extensions to lift member access over the receiver and one or more arguments.","In another aspect thereof, the type-directed translation method compiles the syntactic extensions to lift member access over an operator.","In still another aspect thereof, the type-directed translation method compiles the syntactic extensions to lift member access over arbitrary structure types to support updates.","To the accomplishment of the foregoing and related ends, certain illustrative aspects of the invention are described herein in connection with the following description and the annexed drawings. These aspects are indicative, however, of but a few of the various ways in which the principles of the invention can be employed and the present invention is intended to include all such aspects and their equivalents. Other advantages and novel features of the invention will become apparent from the following detailed description of the invention when considered in conjunction with the drawings.","The present invention is now described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It may be evident, however, that the present invention can be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to facilitate describing the present invention.","As used in this application, the terms \u201ccomponent\u201d and \u201csystem\u201d are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component can be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components can reside within a process and\/or thread of execution, and a component can be localized on one computer and\/or distributed between two or more computers.","As used herein, the term to \u201cinfer\u201d or \u201cinference\u201d refer generally to the process of reasoning about or inferring states of the system, environment, and\/or user from a set of observations as captured via events and\/or data. Inference can be employed to identify a specific context or action, or can generate a probability distribution over states, for example. The inference can be probabilistic\u2014that is, the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher-level events from a set of events and\/or data. Such inference results in the construction of new events or actions from a set of observed events and\/or stored event data, whether or not the events are correlated in close temporal proximity, and whether the events and data come from one or several event and data sources.","Referring now to , there is illustrated a block diagram of a system  that employs a data access component  that facilitates seamless data access of both semi-structured and relational data in a runtime environment  (e.g., object-oriented (OO)), in accordance with the present invention. The runtime environment , inter alia, compiles high level programming languages into machine instructions that can subsequently be executed by a processor. As illustrated, the present invention describes a language solution to bridge technological gaps rather than utilizing APIs (Application Programming Interfaces), like conventional technologies. The language solution integrates the worlds of relational data (e.g., SQL-Structured Query Language), semi-structured data (e.g., XML-eXtensible Markup Language), and the runtime environment  (e.g., CLR (Common Language Runtime) or JVM (Java Virtual Machine)) to present a coherent and unified interface to all three worlds. The amalgamation of worlds is accomplished by delving deeper than APIs and building a unified extended type system. Thus, the present invention facilitates incorporating some of the best features of many present day languages into a single cohesive language.","There exists semi-structured data  and relational data  for accessing by the runtime environment . Such interaction is desired in the conventional web data world. A popular method of implementing a relational data model  is by means of SQL that facilitates accessing data of a relational database system which is typically stored in tables, and an accepted standard for the semi-structured data  is XML. The OO runtime environment  allows an author to write programs that use both relational data and self-describing data.","Bridging the conventional impedance mismatch between the runtime environment  and both the semi-structured data  and the relational data  is the novel data access component , which includes a type system  and associated syntactic constructions  to facilitate seamless interaction therebetween in accordance with the present invention.","It is to be appreciated that the disclosed type system  and associated constructions  support independent interaction of the data sources ( and ) with the runtime environment , such that it is not required that both the data sources ( and ) be accessible to facilitate all interactions.","Referring now to , there is illustrated a type system  that provides relational and semi-structured data access in accordance with the present invention. While, for purposes of simplicity of explanation, the one or more methodologies shown herein, e.g., in the form of a flow chart, are shown and described as a series of acts, it is to be understood and appreciated that the present invention is not limited by the order of acts, as some acts may, in accordance with the present invention, occur in a different order and\/or concurrently with other acts from that shown and described herein. For example, those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events, such as in a state diagram. Moreover, not all illustrated acts may be required to implement a methodology in accordance with the present invention.","At , the system  restricts covariance to identity conversions on the underlying element type. At , the system  defines a number of type congruencies between types that induce an equivalence, instead of using mutual convertibility. This allows the same underlying type to be denoted by a different type-expression. At , the system  provides type-directed lifting of member access and\/or operators. At , the system  provides type-directed lifting of a receiver and\/or some or all of the arguments. At , the system,  provides updates. At , the system  provides a \u201ckind\u201d system that facilitates stratification of types into different kinds.","Referring now to , there is illustrated core structural types  of the type system of the present invention. The core types  include nominal types , discriminated unions , tuple types , intersection types , anonymous delegate types , streams , and array types .","Referring now to , there is illustrated a table of types  that facilitate data access in accordance with the present invention. The types are defined by the following abstract syntax:",{"@attributes":{"id":"p-0054","num":"0061"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"T ::= N","-- nominal type"]},{"entry":[{},"\u2003| T [ ]","-- array with elements of type T"]},{"entry":[{},"\u2003| either {...; L;...}","-- disjoint union"]},{"entry":[{},"\u2003| struct {...;L;...}","-- labeled tuple"]},{"entry":[{},"\u2003| all {... ;L;...}","-- intersection"]},{"entry":[{},"\u2003| definitely<T>","-- non-null"]},{"entry":[{},"\u2003| maybe<T>","-- possibly null"]},{"entry":[{},"\u2003| sequence<T>","-- stream"]},{"entry":[{},"\u2003| delegate T(...,T,...)","-- anonymous delegate"]},{"entry":[{},"L ::=T | T m","-- optionally labeled member"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Referring now to , there is illustrated a table of operations  that can be applied to the types  of  to facilitate data access in accordance with the present invention. The operations on these types are defined by the following abstract syntax:",{"@attributes":{"id":"p-0056","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"E ::= e . f ","-- normal field access"]},{"entry":[{},"\u2003| e...f","-- transitive field access"]},{"entry":[{},"\u2003| e.m (...,e,...)","-- method call"]},{"entry":[{},"\u2003| e.f (... . ,e,... .)","-- delegate invocation"]},{"entry":[{},"\u2003| e.{s}","-- apply-to-all"]},{"entry":[{},"\u2003| e[e]","-- filter"]},{"entry":[{},"\u2003| new (N) (..., (m:=)e,...)","-- construction"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Note that the concrete syntax for these types and the set of operations can be different in any actual programming language that embodies the described invention.","Nominal types N are existing types such as value types, reference types, interfaces or (nominal) delegates that are either built-in or defined using some mechanism for introducing nominal types, e.g., class, value type, interface or delegate declarations:\n\n","Nominal types are called nominal because the equivalence and subtype relationship between these types is determined by their (fully qualified) name. For instance, while the types Point and Punt above both contain exactly the same members and hence, are structurally the same, they are considered as different types by the type system because they have a different declared name. The subtype relationship between nominal types is also determined from their declaration\/name. For example, given a derived type ColorPoint defined as,\n\n","An implicit reference conversion is automatically obtained between ColorPoint and Point, which is written as ColorPoint <: Pointid. In general, the subtype relation is written S<: Tf, meaning that S is a subtype of T and f is a witness that coerces a value of type S to a value of type T.","Array types are also standard, but in contrast to nominal type, the equivalence of arrays is determined by their structure, a new array type is not declared each time one is used. For example, using the type Point[ ] in one program is the same as another use of the type Point[ ] as long as the two types Point are the same. Subtyping on arrays is covariant, which means that if the element types of two arrays are in a subtype relation, the two arrays created from these types are also in a subtype relation. A property of the covariance of arrays is that it is restricted to identity conversions on the underlying element type. This is written using the following rule:",{"@attributes":{"id":"p-0062","num":"0074"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":[{"mi":"S","mo":"<"},{"mi":["T","id"],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}],"mo":":"},{"mrow":[{"mrow":{"mi":"S","mo":["[","]"]},"mo":"<"},{"mrow":{"mi":"T","mo":["[","]"]},"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mi":"id"}],"mo":":"}]}}}},"The new types described herein are structural types such as discriminated unions, tuple types, intersection types, streams, and anonymous delegate types. The associated structural properties are defined next. In addition to subtype relationships between types, a number of type congruencies (\u2261) are introduced between types that induce an equivalence relation on types. This allows the same underlying type to be denoted by a different type-expression.","The value type tuple type struct { . . . ; T m; . . . } is a heterogeneous ordered finite collection of optionally labeled members. For example, values of type struct {bool; int x; char c;} are triples containing an unlabeled Boolean, an integer labeled x, and a character labeled c.","Tuple types are covariant, provided the corresponding conversion on the members is an identity conversion",{"@attributes":{"id":"p-0066","num":"0078"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":[{"mi":"\u2026S","mo":"<"},{"mi":["T","id\u2026"],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}],"mo":":"},{"mrow":[{"mrow":{"mi":"struct","mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mi":["\u2026","Sm","\u2026"],"mo":["\u2062",";",";"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}},"mo":"<"},{"mi":"struct","mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mi":["\u2026","Tm","\u2026"],"mo":["\u2062",";",";"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}}],"mo":":"}]}}}},"The members of a tuple type can be accessed by position, or when they are labeled by their label. For example, given a value s of the example tuple type, its members can be accessed using the following expressions:\n\n","All label-based access on tuple types can be translated into positional access via a type-directed translation. This is especially relevant when member access is lifted over tuple types. For example, given a nested tuple type, the members of the nested inner struct can still be transparently accessed from the outer one\n\n","Note that while the tuple type has no direct member labeled c, the member c of the nested struct can be transparently accessed. The compiler uses the static type of the receiver ns in the expression ns.c to determine how to access the member c.","The types definitely<T>, maybe<T>, and sequence<T> denote streams of values, and are flattened. That is, the following types are considered equivalent:\n\n","Note that this kind of equivalence of types is usually implicit in other languages such as Java or C#. For example, in C#, the following two type declarations class C: IA, IB { } and class C: IB, IA { } are considered equivalent, i.e., class C: IA, IB { }\u2261class C: IB, IA { }.","Flattening of streams also works when there is an intervening either type.\n\n","The stream types form the following hierarchy, where the conversions definitively<T><: T and T<: maybe<T> are not identity conversions.\n\n","Stream types are covariant, provided again that the conversion on the underlying type is the identity for sequence and definitely. It is possible to allow a non-identity conversion for maybe.",{"@attributes":{"id":"p-0075","num":"0117"},"maths":[{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":[{"mi":"S","mo":"<"},{"mi":["T","id"],"mo":["\u2062","\u2062"]}],"mo":":"},{"mrow":[{"mi":["definitely","S"],"mo":["\u2062","<",">","<"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":["definitely","T"],"mo":["<",">"],"mrow":{"mo":"\u2062","mi":"id"}}],"mo":":"}]}}},{"@attributes":{"id":"MATH-US-00003-2","num":"00003.2"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":[{"mi":"S","mo":"<"},{"mi":"T","mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mi":"id","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["or","a","nonidentity","conversion","f"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}}}],"mo":":"},{"mrow":[{"mi":["maybe","S"],"mo":["\u2062","<",">","<"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mi":["maybe","T"],"mo":["<",">"],"mrow":{"mo":"\u2062","mrow":{"mi":"id","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"e","mo":"->","mrow":{"mi":"e","mo":".","mrow":{"mo":["{","}"],"mrow":{"mrow":{"mi":"return","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"it"}}},"mo":";"}}}}}}}}],"mo":":"}]}}},{"@attributes":{"id":"MATH-US-00003-3","num":"00003.3"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":[{"mi":"S","mo":"<"},{"mi":["T","id"],"mo":["\u2062","\u2062"]}],"mo":":"},{"mrow":[{"mi":["sequence","S"],"mo":["<",">","<"]},{"mi":["sequence","T"],"mo":["<",">"],"mrow":{"mo":"\u2062","mi":"id"}}],"mo":":"}]}}}]},"Member access is lifted over stream types. For example, given a stream of type sequence<Button> bs, the BackColor of each button can be selected in the stream using bs.BackColor. The compiler translates this into an explicit apply-to-all operation bs.{return it. BackColor;}. For definitely<T>, it is a little different. If definitely<Button> bs, then bs.BackColor has type Color, and translated into ((Button)bs).BackColor.","Binary (and unary) operators are also lifted over maybe and sequence.",{"@attributes":{"id":"p-0078","num":"0120"},"maths":[{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mi":"T","mo":["\u2062","\u2062"],"mrow":{"mo":["(",")"],"mrow":{"mi":["T","T"],"mo":","}}},{"mi":["sequence","T"],"mo":["<",">"],"mrow":{"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":["sequence","T"],"mo":["<",">"]},{"mi":["sequence","T"],"mo":["<",">"]}],"mo":","}}}}]}}},{"@attributes":{"id":"MATH-US-00004-2","num":"00004.2"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mi":"T","mo":["\u2062","\u2062"],"mrow":{"mo":["(",")"],"mrow":{"mi":["T","T"],"mo":","}}},{"mi":["maybe","T"],"mo":["<",">"],"mrow":{"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":["maybe","T"],"mo":["<",">"]},{"mi":["maybe","T"],"mo":["<",">"]}],"mo":","}}}}]}}}]},"The lifted operation applies the operation () pairwise to each element in the argument streams.","The typing rules and syntax directed translation of all types except all { } and delegate are described in detail herein.","An extension of this system is by the notion of 1-values and updates. Updates are an aspect of imperative programming. Current XML-based languages (e.g., XQuery, XDuce, and Xtatic) lack support for updates. Moreover, conventional languages (e.g., XJ) restrict 1-values to be singletons.","The disclosed invention allows updates where 1-values are arbitrary structured types. Updating is achieved by introducing a new type-constructor of 1-values of type T, written , and defining a similar notion of lifting on 1-values. An assignment expression e1=e2 then applies the 1-value translation to e1, which results in a translated expression e1\u2032 of type T, and the r-value translation to e2, which results in a translated expression e2 of some type S, where S<: Tf and then the r-value f(e2\u2032) is assigned to the 1-value e1'.","The extension of this type-system uses generics. The type system described thus far does not support the construction of user-defined generic classes such as,\n\n","More details on generics in general, is available in the C# language specification.","Consider an interaction between generics and the disclosed type systems. Define the following class Foo<A> as,\n\n","A problem is that when the type of the type-parameter A is unknown, no determination can be made of the type of the result of accessing the a member of an instance fa of the generic type Foo. Depending on what A is, the result type of fa.a can be sequence<B>, for example, when a is bound to sequence<B>, or maybe<C> when A is bound to either definitely<C> or maybe<C>.","This problem is solved by stratifying the type-system into several layers to prevent problematical instantiations like the above. One way to achieve such a stratification is by introducing a \u201ckind\u201d system for types, i.e., by partitioning types into different buckets. This partitioning can be at different granularities. For example, all types could be divided into two buckets; types that are not subject to congruencies; and, types that are subject to congruencies. Type variables are restricted in types that are subject to congruencies to only types that are not subject to congruencies. Given the above example, it then follows that,\n\n","In this way it can always be determined by looking at the structural types in isolation what congruencies apply.","In one sample implementation of stratification, a first level includes base types, int, float, class types, and a button string. A second level can include either or struct, that have component types of base types or the same level. A third level can include maybe, sequence, and definitely. A fourth level can include constraints for generic classes.","Referring now to , there is illustrated a block diagram of a system  that includes a runtime environment  that facilitates multi-data access in accordance with the present invention. The runtime environment  is operable to run one or more programs, here, a first program  (denoted PROGRAM) and a second program  (denoted PROGRAM). Each of the first and second programs ( and ) can be written by a different programming language. That is, the first program  can be written according to a first programming language  (also denoted PROGRAMMING LANGUAGE) and the second program  can be written according to a second programming language  (also denoted PROGRAMMING LANGUAGE). Given that the programming languages ( and ) are different, each employs a different type system where necessary to access the data sources. Thus, the first programming language  employs a first type system  (also denoted TYPE SYSTEM) and the second programming language  employs a second type system  (also denoted TYPE SYSTEM).","The first program  can be written using the first type system  to process either relational query expressions  or semi-structured expressions . In contrast, the second program  can be written using the second type system  to process both relational query expressions  and semi-structured expressions . Both the first and second programs ( and ) can be executed in the same runtime environment  according to conventional program execution architectures.","It is to be appreciated that where the same programming language is used for both the first and second programs ( and ) a common type system can be used to facilitate data access of both the data sources. It is further to be appreciated that the disclosed type system is not restricted to only two data sources, but can be implemented with suitable types and constructions to interface with a third data source (not shown) or even a fourth data source (not shown) that is different from the first three.","The programming languages ( and ) are run on top of the runtime environment . The runtime environment , inter alia, provides services to the programming languages ( and ) such as automatic memory management, code security, and debugging facilities, which allows authors to focus on an underling logic of their applications rather than details of implementation. The first programming language  provides a vocabulary and set grammatical rules that authors can use to implement desired functionality of their applications. In one implementation, the first programming language  can be a strongly typed object-oriented language that is tightly integrated with a compiler and the first type system . This allows programs to be thoroughly error checked prior to execution.","The first program  employs the vocabulary and grammatical rules of the first programming language  to develop an application. Once the first program  is written, it is compiled. The first program  can be compiled into an intermediate language (IL) or directly to machine code. A processor  can then execute the first program  via the runtime environment . The processor  can also interact with a storage  to facilitate execution of the first program .","The semi-structured expression(s)  can be a part of the first program . When employed in the first program , the semi-structured expressions  are utilized to retrieve semi-structured data  (e.g., XML literals or object instances from XML documents). The semi-structured expressions  allow navigation to and retrieval of data in an XML document, for example, similar to the approach taken by the W3C recommended XML Path Language (XPath).","Alternatively, the relational query expressions  can be a part of the first program , and are comprised of query terms, logical operators, and special characters that allow authors to specify how and which data is to be retrieved from a relational database . The relational database  can store massive amounts of data in the form of tables that can be accessed, retrieved, or otherwise manipulated programmatically. The processor  is operably connected to database management system (DBMS) , and retrieves data from relational database  by requesting information from the DBMS  via the relational query expressions .","In an alternative implementation to the first program , the second program  utilizes both the relational query expressions  and the semi-structured expressions , which facilitates accessing both the relational database  and the semi-structured documents  as provided by the second type system .",{"@attributes":{"id":"p-0098","num":"0145"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0099","num":"0146"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0100","num":"0147"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0101","num":"0148"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0102","num":"0149"},"figref":["FIG. 12","FIG. 12"],"ul":{"@attributes":{"id":"ul0025","list-style":"none"},"li":{"@attributes":{"id":"ul0025-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0026","list-style":"none"},"li":["public Control GetNextControl (\n        \n        ",");"]}}}},"Coercive subtyping implies that there is a subtype relationship between types. If it is desired to transfer a value from a first type to a second type, nothing additional needs to be done if the first type is a subset of the second type. However, it is to be appreciated that sometimes the values are different. Thus, some work or conversion must be performed. For example, integers are a subtype real numbers. By representation, however, integers are 32-bit and floating point numbers are 64-bit. Thus, when converting from integer to floating point, a change in representation of the value occurs (i.e., coercive subtyping). Coercive subtyping is costly because of the change in representation involved. All of the subtyping should be inexpensive because all of the subtyping is implicitly convertible. Thus, there is point at which a decision is made as to whether to convert the values based on cost. There is a way to restrict subtyping of a complicated type based on some criteria on the subtyping of the component types.","In one implementation, a heuristic is employed to determine when to make the conversion based on the costs associated therewith.","In another implementation, artificial intelligence (AI) can be employed to analyze the cost and make the decision to convert. The subject invention can employ various AI-based schemes for carrying out various aspects thereof. For example, a process for determining the cost associated with a conversion can be facilitated via an automatic classifier system and process.","A classifier is a function that maps an input attribute vector, x=(x1, x2, x3, x4, xn), to a confidence that the input belongs to a class, that is, f(x)=confidence(class). Such classification can employ a probabilistic and\/or statistical-based analysis (e.g., factoring into the analysis utilities and costs) to prognose or infer an action that a user desires to be automatically performed.","A support vector machine (SVM) is an example of a classifier that can be employed. The SVM operates by finding a hypersurface in the space of possible inputs, which hypersurface attempts to split the triggering criteria from the non-triggering events. Intuitively, this makes the classification correct for testing data that is near, but not identical to training data. Other directed and undirected model classification approaches include, e.g., na\u00efve Bayes, Bayesian networks, decision trees, neural networks, fuzzy logic models, and probabilistic classification models providing different patterns of independence can be employed. Classification as used herein also is inclusive of statistical regression that is utilized to develop models of priority.","As will be readily appreciated from the subject specification, the subject invention can employ classifiers that are explicitly trained (e.g., via a generic training data) as well as implicitly trained (e.g., via observing user behavior, receiving extrinsic information). For example, SVM's are configured via a learning or training phase within a classifier constructor and feature selection module. Thus, the classifier(s) can be used to automatically perform a number of functions, including but not limited to determining according to a predetermined criteria when to make the conversion based on the cost of conversion, when to convert based on the type of values, and when to make the conversion based on the kind of data being processed.","Application to C# Programming Language","Following is a description of a lightweight extension of the popular object-oriented language C# in accordance with the present invention. Notable features include type-theoretic integration of the three prevalent data models in web-based applications, namely the object-oriented, relational, and semi-structured models of data. This is achieved by extending the class-based type system of C# with streams, particular forms of tuple and discriminated union types, and content types. The type system and the operational semantics are described. Although C# is the basis for this example application, the disclosed extensions apply equally well to other OO languages, including Java.","The disclosed extension to C#, hereinafter referred to as \u201cXen\u201d, is a coherent extension of C#. This means that there is no redesign of C#, but rather the language is worked as it currently exists. Moreover, the extensions do not conflict in any way with the underlying language; C# programs should be valid Xen programs with the same behavior.","The type system of Xen is intended to be as simple as possible (in contrast with, for example, regular expression types), and to line up closely with the underlying execution environment, in our case the CLR.","From a programming perspective, the real power of Xen comes from its elegant and coherent query-like capabilities. These have been carefully designed to mimic existing query languages, in particular XQuery and SQL, as closely as possible. This principal has had the most profound effect upon the overall design of Xen.","Extensions to the type system-streams, tuple types, discriminated unions, and content classes-and for each are considered the new query capabilities.","The first structural type added is a stream type. For example, sequence<int> is the type for homogeneous sequences of integers. Streams in Xen are aligned with iterators. Thus, streams are generated lazily using iterator blocks and consumed using the foreach statement. For example, given a stream zones of type sequence<int>, the following statement prints each element in that stream:\n\n","C# member access is generalized to map over streams, e.g., zones.ToString( ) implicitly maps the call over the elements of the stream and returns a value of type sequence<string>. Another difference between iterators in C# is that streams in Xen are automatically flattened. Consider a type CD that contains a member zones of type sequence<int>. Then, given a stream cds of type sequence<CD>, all zones are converted to strings by writing cds.zones.ToString( ). In other words, member access has been generalized so that it behaves like a path expression. Thus, a design goal of Xen was to add XPath-like query expressions to C# in a lightweight and coherent way.","The second structural types added are tuple types. A tuple type is like a tuple, and is written as struct{int i; Button;}, for example. A value of this type contains a member i of type int and an unlabeled member of type Button. A value of this type can be constructed with the following expression: new (i=42, new Button ( )). To access components of tuple types, the notion of member access is generalized. Thus, assuming a value x of the previous type, x.i is written to access the integer value. Unlabeled members are accessed by their position; for example, x [1] returns the Button member. As for streams, member access is lifted over unlabelled members of tuple types. To access the Backcolor property of the Button component in variable x it can be written x. Backcolor, which is equivalent to x[1].Backcolor.","Xen also allows repeated occurrences of the same member name within a tuple type, even at different types. For example, assume the following declaration: struct {int i; Button; float i;} z; Then z.i projects the two i members of z into a new tuple type that is equivalent to new (z [0], z [2]) and the type struct{int;float;}.","The third structural type added is a particular form of discriminated union type, called an either type. This is written, for example, either{int; bool;}. As the name suggests, a value of this type is either an integer or a Boolean. Like unions, discriminated unions in Xen inherently know their type. Again, member access has been generalized over discriminated unions. As either types have a disjunctive flavor, stream types are used to handle the possibility that the element is not of the required type. Consider a discriminated union value w of type either{int;Button;}. An attempt can be made to access the color of w using the lifted member access expression w.Backcolor. This will return a value of type sequence<Color>, which is either a singleton stream containing the Color value when w contains a Button, or the null pointer (the empty stream) when w happens to be an integer. Again, the path expression behavior is representative of XPath.","Content classes are the fourth type-system extension added to C#. A content class is a normal class that has a single unlabelled type that describes the content of that class. From an XSD (XML Schema Definition) perspective, classes correspond to global element declarations, while the content type of classes correspond to complex types.","These type extensions form the essence of Xen. While being quite simple they are in fact sufficiently powerful to represent both relational and semi-structured data. Relational tables are merely streams of tuple types. For example, the relational table created with the SQL declaration:\n\n","can be represented as the Xen declaration:\n\n","Similarly, the following XSD schema,\n\n","can be represented as the Xen content class declaration:\n\n","Core Language of Xen\u2014InnerXen","An InnerXen program consists of one or more class declarations. Each class declaration defines zero or more methods and contains exactly one unlabeled type that is called the content type (collections of field declarations can be encoded). A class declaration with a content type is called a content class. InnerXen follows C# and requires methods to be explicitly marked as virtual or override. Given a program, it is assumed that there is a unique designated method within the class declarations that serves as the entry point.",{"@attributes":{"id":"p-0127","num":"0190"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Program","p ::= "]},{"entry":[{},"Class Definition","cd ::= class c : c{\u03c4;  }"]},{"entry":[{},"Method Definition","md ::= virtual \u03c4m( ){ }"]},{"entry":[{},{},"\u2003| override \u03c4m( ){ }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"InnerXen supports two main kinds of types: value types and reference types. As usual, the distinguished type void is used for methods that do not return anything. Value types include the base types bool and int and the structural types: tuple types and discriminated unions. Reference types are either class types or streams. As usual, only reference types have object identity and are represented at runtime by references into the heap. A designated special class object is assumed.",{"@attributes":{"id":"p-0129","num":"0192"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Types","\u03c4::=\u03b3","Value types"]},{"entry":[{},"\u2003| \u03c1","Reference types"]},{"entry":[{},"\u2003| void | null","Void and null types"]},{"entry":["Value Types","\u03b3::=b","Base types"]},{"entry":[{},"\u2003| struct{  }","Tuple types"]},{"entry":[{},"\u2003| either{  }","Disjoint union types"]},{"entry":["Base Types","b::=bool | int",{}]},{"entry":["Reference Types","\u03c1::=c","Classes"]},{"entry":[{},"\u2003| sequence<\u03c4>","Stream types"]},{"entry":["Field Definition","fd::=\u03c4f,","Named member"]},{"entry":[{},"\u2003| \u03c4,","Unnamed member"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"InnerXen expressions, as for C#, are split into ordinary expressions and promotable expressions. Promotable expressions are expressions that can be used as statements. A number of built-in primitive operators are assumed, such as ==, \u2225 and &&. In the grammar, it is written e\u2295e, where \u2295 denotes an instance of one of these operators.","Explanation of these expressions that are new for InnerXen is deferred hereinbelow to where the InnerXen type system is considered.",{"@attributes":{"id":"p-0132","num":"0195"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Expression","e ::=b | i","Literals"]},{"entry":[{},"\u2003| e \u2295 e","Built-in operation"]},{"entry":[{},"\u2003| x","Variable"]},{"entry":[{},"\u2003| null","Null"]},{"entry":[{},"\u2003| (\u03c4) e","Cast"]},{"entry":[{},"\u2003| e is \u03c4","Dynamic typecheck"]},{"entry":[{},"\u2003| e was \u03c4","Static typecheck"]},{"entry":[{},"\u2003| new \u03c4(e)","Object creation"]},{"entry":[{},"\u2003| new \u03c4( )","Closure creation"]},{"entry":[{},"\u2003| new ( )","Tuple type creation"]},{"entry":[{},"\u2003| new \u03c4(\u03c4\u2032, e)","Discriminated union"]},{"entry":[{},{},"and internal stream element "]},{"entry":[{},{},"creation"]},{"entry":[{},"\u2003| e.f","Field access by name"]},{"entry":[{},"\u2003| e[i]","Field access by position"]},{"entry":[{},"\u2003| pe","Promotable expression"]},{"entry":["Promotable expression","pe ::= x = e","Variable assignment"]},{"entry":[{},"\u2003| e.m(\u0113)","Method invocation"]},{"entry":[{},"\u2003| e. { }","Apply-to-all"]},{"entry":[{},"\u2003| ({ })","Block expression"]},{"entry":["Binding expression","be ::= f = e","Named binding"]},{"entry":[{},"\u2003| e","Unnamed binding"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Statements in InnerXen are standard. The yield statement is an updated version used to generate streams.",{"@attributes":{"id":"p-0134","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Statement","s ::=;","Skip"]},{"entry":[{},{},"\u2003| pe;","Promoted expression"]},{"entry":[{},{},"\u2003| if (e) s else s","Conditional"]},{"entry":[{},{},"\u2003| \u03c4x = e;","Variable declaration"]},{"entry":[{},{},"\u2003| return e;","Return statement"]},{"entry":[{},{},"\u2003| return ;",{}]},{"entry":[{},{},"\u2003| yield return e;","Yield statement"]},{"entry":[{},{},"\u2003| yield break ;","End of stream statement"]},{"entry":[{},{},"\u2003| foreach (\u03c4 x in e) s","Foreach loop"]},{"entry":[{},{},"\u2003| while (e) s","While loop"]},{"entry":[{},{},"\u2003| { }","Block"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"In what follows, it is assumed that InnerXen programs are well-formed, e.g., no cyclic class hierarchies, correct method body construction, etc.","Static Semantics","In this section, the InnerXen type system is formalized and some of the new language features are described. The type system and language extensions are designed to be unobtrusive to the programmer, and things (i.e., member access over structural types) should work as expected. Additionally, the extension to subtyping is as close as possible to the spirit of host language. A goal of Xen is to keep the type system extensions few and as simple as possible.","Subtyping","Normally, subtyping is formalized by defining a relation between a subtype and a supertype. However, for the formalization of InnerXen, subtyping is treated as a coercion. Hence, the subtype relation is written \u03c4<: \u03c4\u2032f meaning that \u03c4 is a subtype of \u03c4 and f is a witness that coerces a value of type \u03c4 to a value of type \u03c4\u2032. To be more precise, f is a context, i.e., code with a designated \u2018hole\u2019, usually written C[ ] such that when a code fragment v of type \u03c4 is placed in the hole, the resulting code, written C[v], is of type \u03c4\u2032. For succinctness, rather than writing contexts, a functional notation is used, e.g., xe. When no coercion is necessary (e.g., when converting from a subclass to a superclass), the identity function id, is written.","In fact, the typing judgments translate InnerXen constructs to a strictly smaller subset of the language, which is then evaluated by the operational semantics. However, to increase readability and avoid clutter, the syntactic sugar of (promotable) block expressions and apply-to-all expressions are sometimes used in the target of the translations. The rules that use such sugar are marked with an asterisk (*).","Subtyping in InnerXen is reflexive and transitive, so the following rules are immediate.",{"@attributes":{"id":"p-0142","num":"0205"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":[{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":[{"mi":"\u03c4","mo":"<"},{"msup":{"mi":["\u03c4","\u2032"]},"mo":["\u2062","\u2062"],"mi":"id"}],"mo":":"}},{"mrow":[{"mrow":[{"mi":"\u03c4","mo":"<"},{"mrow":[{"mrow":{"msup":[{"mi":["\u03c4","\u2032"]},{"mi":["\u03c4","\u2032"]}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mi":"f","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"<"},{"msup":{"mi":["\u03c4","\u2033"]},"mo":["\u2062","\u2062"],"mi":"g"}],"mo":":"}],"mo":":"},{"mrow":[{"mi":"\u03c4","mo":"<"},{"mrow":[{"msup":{"mi":["\u03c4","\u2033"]},"mo":["\u2062","\u2062"],"mi":"e"},{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"e"}}}}],"mo":"\u21a6"}],"mo":":"}]}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}}},"Much of the previous work on using coercions to represent subtyping focuses on the problem of coherence, i.e., if there is more than one coercion between two types then they are observationally equivalent. Building upon C# and Java-coherence is too strong a condition. First, because some coercions are side-effecting, e.g., boxing, and so coherence can never hold. The second concerns how overloading is resolved (and interestingly is independent of the first). Consider the following overloaded method f.\n\n","In both C# and Java, the call f (new Button ( )) prints Ha, Ha, even though both Button <: Control id and Button <: Control <: object id. This is because C# and Java determine that the first conversion is better. Since a design goal was to build directly upon C#, it is also assumed that given any two conversions \u03c3<: \u03c4f and \u03c3<: \u03c4\u2032\u2192g (where \u03c4 may be equal to \u03c4\u2032) the better conversion of the two can be determined. Whenever subsumption is used (for assignments and method calls) the best conversion is chosen. For example, the assignment x=new Button ( ) injects into control when x has type either{Control; object;}.","Value Types. Following C# a value of any value type can be coerced to the supertype object. Doing so will box the value, place it on the heap, and return the heap reference. Thus, the coercion witness is not a pure function (boxing the same value twice will not return the same reference). The following rule covers the base types and tuple types. The case for discriminated unions is described later.\n\n","Reference types. Two rules are provided. Firstly, a nominal class type c is a subtype of another class type c\u2032 if c extends c\u2032. Secondly, null is a subtype of any reference type.",{"@attributes":{"id":"p-0147","num":"0213"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":[{"mrow":[{"mi":"class","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"c","mo":":","msup":{"mi":["c","\u2032"]}}},{"mrow":[{"mi":"c","mo":"<"},{"msup":{"mi":["c","\u2032"]},"mo":["\u2062","\u2062"],"mi":"id"}],"mo":":"}]},{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":[{"mi":"null","mo":"<"},{"mi":["\u03c1","id"],"mo":["\u2062","\u2062"]}],"mo":":"}}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}}},"Streams. Streams represent ordered homogeneous collections of zero or more values. In Xen, streams are most commonly generated by yield blocks. The following method From generates the infinite stream of integers n, n+1, . . . :\n\n","Given a stream, iteration over its elements can be performed using a foreach statement. However, Xen offers a convenient shorthand called an apply-to-all expression written as e.{ } which applies the method-body { } to each element it in the stream e. The variable it plays a similar role as the implicit receiver argument this in methods and is bound to each successive element of the iterated stream. For instance, the apply-to-all expression below will convert the stream of natural numbers from 0 into the stream of even numbers, converts each of these into a string, and then prints them all:\n\n","Block expressions are a lightweight way to define finite streams without the need to define a generator method. For instance, the following block expression generates a stream of two strings:\n\n","Generator block expressions are translated into closures. Streams are covariant provided that the conversion on the element type is the identity. The rationale for this is that implicit conversions should limited to constant-time operations. Coercing a stream of type sequence<int> to a stream of type sequence<object>, for example, would be linear in the length of the stream, as the boxing conversion from int to object is not the identity. Coercing a stream to the object type simply requires the identity witness.",{"@attributes":{"id":"p-0152","num":"0223"},"maths":[{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mrow":[{"mi":"\u03c4","mo":"<"},{"msup":{"mi":["\u03c4","\u2032"]},"mo":["\u2062","\u2062"],"mi":"id"}],"mo":":"},{"mrow":[{"mi":["sequence","\u03c4"],"mo":["<",">","<"]},{"mi":"sequence","mo":["<",">"],"msup":{"mi":["\u03c4","\u2032"]},"mrow":{"mo":"\u2062","mi":"id"}}],"mo":":"}]},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}},{"@attributes":{"id":"MATH-US-00007-2","num":"00007.2"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":[{"mi":["sequence","\u03c4"],"mo":["<",">","<"]},{"mi":["object","id"],"mo":["\u2062","\u2062"]}],"mo":":"}}}}]},"A feature of Xen is that streams are always flattened. Thus, Xen types are subject to the following equivalence.\n\n","Consequently, there are no streams of streams, and embedded empty streams disappear. Since null is equated to the empty stream, it follows also that element of streams are never null.","Flattening of stream types is essential to efficiently deal with recursively defined streams. Consider the following recursive variation of the function From that was defined previously:\n\n","The recursive call yield return From (n); yields a stream forcing the type of From to be a nested stream. The non-recursive call yield return n++; yields a single integer thus forcing the return type of From to be a normal stream. As the type system treats the types sequence<int> and sequence<sequence<int>> as equivalent, this is type-correct.","Without flattening, it would be required to copy the stream produced by the recursive invocation, leading to a quadratic instead of a linear number of yields:\n\n","Note that flattening of stream types does not imply that the underlying stream is flattened via some coercion; every element in a stream is yield-ed at most once. Iterating over a stream will effectively perform a depth-first traversal over the n-ary tree produced by the stream generators.","Tuple types. Tuple types encapsulate heterogeneous ordered collections of values. Members of tuple types can be labeled or unlabeled, and labels can be duplicated, even at different types. Members of tuple types can be accessed by label or by position.","Tuple types, as for streams, are covariant provided that the upcast-conversion that would be applied is the identity:",{"@attributes":{"id":"p-0161","num":"0239"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":[{"mover":{"mi":["fd","_"]},"mo":"<"},{"mover":{"msup":{"mi":["fd","\u2032"]},"mi":"_"},"mo":["\u2062","\u2062"],"mi":"id"}],"mo":":"},{"mrow":[{"mrow":{"mi":"struct","mo":"\u2062","mrow":{"mo":["{","}"],"mover":{"mi":["fd","_"]}}},"mo":"<"},{"mi":["struct","id"],"mo":["\u2062","\u2062","\u2062"],"mrow":{"mo":["{","}"],"mover":{"msup":{"mi":["fd","\u2032"]},"mi":"_"}}}],"mo":":"}]}}}},"Subtyping respects field names: let fd, fd\u2032 be \u03c4f, and \u03c4\u2032 f\u2032; then",{"@attributes":{"id":"p-0163","num":"0241"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":"fd","mo":"<","mrow":{"mstyle":{"mtext":":"},"mo":"\u2062","msup":{"mi":["fd","\u2032"]}}}},{"mrow":{"mo":["(",")"],"mrow":{"mi":"f","mo":"=","mrow":{"mrow":{"msup":{"mi":["f","\u2032"]},"mo":"\u2a53","mrow":{"mi":"\u03c4","mo":"<"}},"mo":":","msup":{"mi":["\u03c4","\u2032"]}}}},"mo":"."}],"mo":["\u2062","\u2062"],"mover":{"mo":"=","mi":"def"}}}},"br":{}},"Either types. A value of an either type is a discriminated union that may hold (at different times) any of the values of its members. Unlike unions in C\/C++ and variant records in Pascal where users have to keep track of which type is present, values of discriminated unions in Xen are implicitly tagged with the static type of the chosen alternative. In other words, discriminated union values are essentially a pair of a value and its static type. The special member e.value retrieves the value component of a discriminated union value e. The type component can be tested with the conformity test e was \u03c4. The expression e was \u03c4 is true for exactly one \u03c4 in . This invariant is maintained by the type system.","Like tuple types, the members of discriminated unions can be labeled or unlabeled. The following absorption rule states that a labeled member in a discriminated union is just a nested singleton tuple type:\n\n","Discriminated unions are idempotent, commutative, and associative; duplicated members are ignored, the order of the members is arbitrary, and nesting is irrelevant:\n\n","Associativity also works across streams.","sequence<either{sequence<either{ }>; }>\u2245sequence<either{  }>","Values of non-discriminated union types can be injected into a discriminated union:",{"@attributes":{"id":"p-0169","num":"0251"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mi":"\u03c4","mo":"\u2260","mrow":{"mi":"either","mo":"\u2062","mrow":{"mo":["{","}"],"mover":{"msup":{"mi":["\u03c4","\u2033"]},"mi":"_"}}}},{"mrow":[{"mi":"\u03c4","mo":"<"},{"mrow":[{"mi":["either","e"],"mo":["\u2062","\u2062","\u2062"],"mrow":{"mo":["{","}"],"mrow":{"mi":"\u03c4","mo":";","mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}}},{"mi":["new","either"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":[{"mo":["{","}"],"mrow":{"mi":"\u03c4","mo":";","mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}},{"mo":["{",")"],"mrow":{"mi":["\u03c4","e"],"mo":","}}]}],"mo":"\u21a6"}],"mo":":"}]}}}},"InnerXen allows width subtyping for discriminated unions. In this case the coercion is slightly more involved as it extracts the value from the source discriminated union before creating the target discriminated union.",{"@attributes":{"id":"p-0171","num":"0253"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mo":"\u2062","mi":"e"},"mo":"\u21a6","mfrac":{"msup":{"mover":{"mrow":{"mrow":[{"mrow":{"mi":"either","mo":"\u2062","mrow":{"mo":["{","}"],"mover":{"msub":{"mi":["\u03c4","i"]},"mi":"_"}}},"mo":"<"},{"mi":"either","mo":"\u2062","mrow":{"mo":"{","mrow":{"mi":"either","mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mover":[{"msub":{"mi":["\u03c4","i"]},"mi":"_"},{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}],"mo":";"}}}}}],"mo":":"},"mi":"_"},"mrow":{"mi":"(*","mo":")"}},"mrow":{"mo":["(",")"],"mrow":{"mo":["{","}"],"mrow":{"mrow":{"mrow":[{"mi":"if","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["e","was"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msub":{"mi":["\u03c4","i"]}}}},{"mo":["{","}"],"mrow":{"mover":[{"msub":{"mi":["\u03c4","i"]},"mi":"_"},{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}],"mo":"\u2062"}},{"mo":["(",")"],"mrow":{"msub":{"mi":["\u03c4","i"]},"mo":",","mrow":{"mi":["e","value"],"mo":"."}}}],"mo":["\u2062","\u2062","\u2062"],"mi":"returnneweither"},"mo":";"}}}}}}}},"Here, and in the following, the convention of indexing sequences is used, i.e.,  represents a sequence of types, where each type is indexed with its position. An element of this sequence at position i is referred to as \u03c4.","The rules above are carefully crafted to allow alternative implementations that do not use types as tags for discriminated unions. They allow any implementation that maintains the stated invariant for the conformity test, e.g., integers tags used in the actual Xen implementation.","InnerXen follows the design of C# in allowing all values to be boxed, and hence, all value types are a subtype of the supertype object. For values of discriminated unions, boxing is a little more subtle as it should first strip off the type tag and then upcast to object.",{"@attributes":{"id":"p-0175","num":"0257"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mover":{"mrow":{"mrow":[{"msub":{"mi":["\u03c4","i"]},"mo":"<"},{"mi":"object","mo":["\u2062","\u2062"],"msub":{"mi":["g","i"]}}],"mo":":"},"mi":"_"},"mrow":{"mrow":[{"mrow":{"mi":"either","mo":"\u2062","mrow":{"mo":["{","}"],"mover":{"msub":{"mi":["\u03c4","i"]},"mi":"_"}}},"mo":"<"},{"mrow":[{"mi":["object","e"],"mo":["\u2062","\u2062"]},{"mo":"(","mrow":{"mo":"{","mrow":{"mo":["(",")"],"mover":{"mrow":{"mrow":{"mrow":{"mrow":{"mrow":[{"mi":"if","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["e","was"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}}],"msub":{"mi":["\u03c4","i"]}}}},{"msub":{"mi":["g","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["e","value"],"mo":"."}}}],"mo":["\u2062","\u2062","\u2062"],"mi":"return","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":";"},"mo":"}"},"mo":")"},"mi":"_"}}}}],"mo":"\u21a6"}],"mo":":"}},"mo":"\u2062","mrow":{"mi":"(*","mo":")"}}}}},"Generalized Member Access","The essence of Xen is that member access is uniformly lifted over all structural types. This gives the language much of the expressive power of query languages such as XPath. This generalized member access is treated in a similar way as subtyping in that it is replaced with explicit coercions.","Each type constructor is now considered in turn and for each, two new judgment forms are formalized:","The field access judgment \u03c4.f<: \u03c4\u2032g returns a witness g: \u03c4\u2192\u03c4\u2032 that performs the lookup of field f on an instance of \u03c4. Positional field access is analogous and omitted.","The method call judgment \u03c4.m( )<: \u03c4\u2033g returns a witness g: (\u03c4, )\u2192\u03c4\u2033 that calls the method with signature \u03c4\u2033 m( ) on a receiver of type \u03c4.","Member access over streams. Lifting member access on streams is really just syntactic sugar for a simple apply-to-all expression of member access on the elements of the stream.",{"@attributes":{"id":"p-0182","num":"0264"},"maths":{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mrow":[{"mrow":{"mi":["\u03c4","f"],"mo":"."},"mo":"<"},{"msup":{"mi":["\u03c4","\u2032"]},"mo":["\u2062","\u2062"],"mi":"g"}],"mo":":"},{"mrow":[{"mi":["sequence","\u03c4"],"mo":["<",">","<"],"mrow":{"mo":".","mi":"f"}},{"mrow":[{"mi":"sequence","mo":["<",">"],"msup":{"mi":["\u03c4","\u2032"]},"mrow":{"mo":"\u2062","mi":"e"}},{"mi":"e","mo":".","mrow":{"mo":["{","}"],"mrow":{"mrow":{"mi":"return","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"it"}}},"mo":";"}}}],"mo":"\u21a6"}],"mo":":"}]},"mo":"\u2062","mrow":{"mi":"(*","mo":")"}}}}},"Methods that return non-void results are lifted similarly to field-access. For example, each string can be converted to uppercase in the stream ss from earlier by simply writing ss.ToUpper( ). This expression is translated into the apply-to-all block ss.{return it.ToUpper( );}. Again, the witness for lifting general method invocation over streams introduces an apply-to-all block:",{"@attributes":{"id":"p-0184","num":"0266"},"maths":{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mrow":[{"mrow":{"mi":"\u03c4","mo":".","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}}},"mo":"<"},{"msup":{"mi":["\u03c4","\u2033"]},"mo":["\u2062","\u2062"],"mi":"g"}],"mo":":"},{"mrow":[{"mi":["sequence","\u03c4"],"mo":["<",">","<"],"mrow":{"mo":".","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}}}},{"mrow":[{"mi":"sequence","mo":["<",">"],"msup":{"mi":["\u03c4","\u2033"]},"mrow":{"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"mi":"e","mo":",","mover":{"mi":["a","_"]}}}}},{"mi":"e","mo":".","mrow":{"mo":["{","}"],"mrow":{"mrow":{"mi":"return","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"it","mo":",","mover":{"mi":["a","_"]}}}}},"mo":";"}}}],"mo":"\u21a6"}],"mo":":"}]},"mo":"\u2062","mrow":{"mi":"(*","mo":")"}}}}},"Methods that return void are applied to each element of the stream. There is no stream of void.",{"@attributes":{"id":"p-0186","num":"0268"},"maths":{"@attributes":{"id":"MATH-US-00015","num":"00015"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":{"mrow":[{"mrow":{"mi":"\u03c4","mo":".","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}}},"mo":"<"},{"mi":["void","g"],"mo":["\u2062","\u2062"]}],"mo":":"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mrow":{"mrow":{"mi":"sequence","mo":"\u2062","mrow":{"mrow":[{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2032"]}},{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}}],"mo":"."}},"mo":"<"},"mo":":"},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}},{"mtd":{"mrow":{"mrow":[{"mi":"void","mo":["\u2062","\u2062"],"mrow":{"mo":["(",")"],"mrow":{"mi":"e","mo":",","mover":{"mi":["a","_"]}}}},{"mi":"foreach","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":"(","mrow":{"mrow":{"mi":["\u03c4","it","in"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mrow":{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"it","mo":",","mover":{"mi":["a","_"]}}}}},"mo":";"}}}],"mo":"\u21a6"}}}]}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msup":{"mo":["(","*"]},"mo":")"}}}}},"Note that even members of object are lifted. Thus, for instance, the result of calling ss.GetType( ) on a stream ss has type sequence<Type>. In order to perform method invocation on the actual stream, it casts to object first, e.g., ((object)ss).GetType( ).","Member access over tuple types. Accessing tuple type members returns a new tuple type that contains as tuple members only those that were selected from the original tuple type. For example the selection s.x on a variable s of type struct {int x; string; bool x;} returns a new tuple type of type struct (int; bool;} that is created by the expression new (s [0], s [2]). This idea of projection is given by the following rule, where the premise uses a list comprehension to generate a list of triples (\u03c4, g, i) for each member fdthat has a member f. In the conclusion, one writes  to select only those elements from the given tuple type and apply the respective conversion on that member.",{"@attributes":{"id":"p-0189","num":"0271"},"maths":{"@attributes":{"id":"MATH-US-00016","num":"00016"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mo":["[","]"],"mrow":{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"mi":["\u03c4","i"],"mo":[",",","],"msub":{"mi":["g","i"]}}},{"mrow":{"msub":{"mi":["fd","i"]},"mo":".","mi":"f"},"mo":"<"}],"mo":"|"},{"mi":"\u03c4","mo":["\u2062","\u2062"],"msub":{"mi":["g","i"]}}],"mo":":"}},{"mrow":[{"mrow":{"mi":"struct","mo":"\u2062","mrow":{"mrow":{"mo":["{","}"],"mover":{"msub":{"mi":["fd","i"]},"mi":"_"}},"mo":".","mi":"f"}},"mo":"<"},{"mrow":[{"mi":["struct","e"],"mo":["\u2062","\u2062","\u2062"],"mrow":{"mo":["{","}"],"mover":{"mi":["\u03c4","_"]}}},{"mi":"new","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mrow":{"msub":{"mi":["g","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"e","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"i"}}}},"mi":"_"}}}],"mo":"\u21a6"}],"mo":":"}]}}}},"The base case of member access is when the label of a field matches the label that is accessed.\n\n","Method calls are lifted over tuple types in a similar way as member selection.",{"@attributes":{"id":"p-0192","num":"0275"},"maths":{"@attributes":{"id":"MATH-US-00017","num":"00017"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mo":["[","]"],"mrow":{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":[",",","],"msub":{"mi":["g","i"]},"mi":"i"}},{"mrow":{"msub":{"mi":["fd","i"]},"mo":".","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["\u03c4","_"]}}}},"mo":"<"}],"mo":"|"},{"msup":{"mi":["\u03c4","\u2032"]},"mo":["\u2062","\u2062"],"msub":{"mi":["g","i"]}}],"mo":":"}},{"mrow":[{"mrow":{"mi":"struct","mo":"\u2062","mrow":{"mrow":[{"mo":["{","}"],"mover":{"msub":{"mi":["fd","i"]},"mi":"_"}},{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["\u03c4","_"]}}}],"mo":"."}},"mo":"<"},{"mrow":[{"mi":["struct","e"],"mo":["\u2062","\u2062","\u2062"],"mrow":{"mo":["{","}"],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}},{"mi":"new","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mrow":{"msub":{"mi":["g","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"e","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"i"}}}},"mi":"_"}}}],"mo":"\u21a6"}],"mo":":"}]}}}},"When member selection, or method calls succeeds for just one member, the struct is not created, but just the value of that member is returned. For example, given value p of type struct{int x; int y;}, selecting p.x returns a single value x [0] of type int. This refinement should be obvious and is omitted.","Member access over discriminated unions. It is known that a given value matches exactly one of the alternatives of a discriminated union. To lift member access over discriminated unions, a conformity test of the current value is performed, and the corresponding member selected. For example, given a value x of type either (string; Person; int) where both string and Person have a member Length of type int and Inch, respectively, lifting x.Length returns a value of type Sequence<either{int; Inch;}> via the translation:\n\n","The general rule for lifting field selection and method invocation over discriminated unions collects the alternatives for which the member lookup succeeds, and creates the conformity test to determine the member\/method to actually select\/invoke.",{"@attributes":{"id":"p-0196","num":"0281"},"maths":[{"@attributes":{"id":"MATH-US-00018","num":"00018"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":{"mo":["[","]"],"mrow":{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":[",",","],"msub":{"mi":["g","i"]},"mi":"i"}},{"mrow":{"msub":{"mi":["\u03c4","i"]},"mo":".","mi":"f"},"mo":"<"}],"mo":"|"},{"msup":{"mi":["\u03c4","\u2032"]},"mo":["\u2062","\u2062"],"msub":{"mi":["g","i"]}}],"mo":":"}},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":"either","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":{"mo":["{","}"],"mover":{"msub":{"mi":["\u03c4","i"]},"mi":"_"}},"mo":".","mi":"f"}},"mo":"<"},{"mi":"sequence","mo":["<",">"],"mrow":{"mi":"either","mo":"\u2062","mrow":{"mo":["{","}"],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}}}],"mo":":"}}},{"mtd":{"mrow":{"mi":"\u2147","mo":"\u21a6","mrow":{"mo":["(",")"],"mrow":{"mo":["{","}"],"mover":{"mrow":{"mrow":{"mrow":[{"mi":"if","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["e","was"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"msub":{"mi":["\u03c4","i"]}}}},{"msub":{"mi":["g","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["e","value"],"mo":"."}}}],"mo":["\u2062","\u2062","\u2062"],"mi":"yieldreturn","mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}},"mo":";"},"mi":"_"}}}}}}]}},"mo":"\u2062","mrow":{"msup":{"mo":["(","*"]},"mo":")"}}}},{"@attributes":{"id":"MATH-US-00018-2","num":"00018.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":{"mo":["[","]"],"mrow":{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2033"]},"mo":[",",","],"msub":{"mi":["g","i"]},"mi":"i"}},{"mrow":{"msub":{"mi":["\u03c4","i"]},"mo":".","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}}},"mo":"<"}],"mo":"|"},{"msup":{"mi":["\u03c4","\u2033"]},"mo":["\u2062","\u2062"],"msub":{"mi":["g","i"]}}],"mo":":"}},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mrow":{"mi":"either","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":[{"mo":["{","}"],"mover":{"msub":{"mi":["\u03c4","i"]},"mi":"_"}},{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}}],"mo":"."}},"mo":"<"},{"mi":"sequence","mo":["<",">"],"mrow":{"mi":"either","mo":"\u2062","mrow":{"mo":["{","}"],"mover":{"msup":{"mi":["\u03c4","\u2033"]},"mi":"_"}}}}],"mo":":"}}},{"mtd":{"mrow":{"mi":"e","mo":"\u21a6","mrow":{"mo":["(",")"],"mrow":{"mo":["{","}"],"mover":{"mrow":{"mrow":{"mrow":[{"mi":"if","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["e","was"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"msub":{"mi":["\u03c4","i"]}}}},{"msub":{"mi":["g","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["e","value"],"mo":"."}}}],"mo":["\u2062","\u2062","\u2062"],"mi":"yieldreturn","mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}},"mo":";"},"mi":"_"}}}}}}]}},"mo":"\u2062","mrow":{"msup":{"mo":["(","*"]},"mo":")"}}}}]},"When member access succeeds for every alternative in the discriminated union, the return type can sometimes be improved. For example x.GetType( ) would return a value of type object instead of sequence<object>.","Member access over classes. Method invocation on classes, i.e., nominal types, searches the class hierarchy until a matching method is found. If a matching method \u03c4\u2032 m( ) in class c is found, the actual types of the arguments are adjusted to the types expected by m:",{"@attributes":{"id":"p-0199","num":"0284"},"maths":{"@attributes":{"id":"MATH-US-00019","num":"00019"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"class","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mi":"c","mo":":","mrow":{"msup":{"mi":["c","\u2032"]},"mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mi":"\u03c4","mo":",","mover":{"mi":["md","_"]}}}}}}},{"mrow":{"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":"\u2062","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"msup":{"mi":["\u03c4","\u2033"]},"mi":"_"}}}},"mo":"\u2208","mover":{"mrow":{"mi":["m","d"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mi":"_"}}},{"mrow":{"mrow":[{"mover":{"mi":["\u03c4","_"]},"mo":"<"},{"mover":{"msup":{"mi":["\u03c4","\u2033"]},"mi":"_"},"mo":["\u2062","\u2062"],"mi":"f"}],"mo":":"}}]}},"mrow":{"mrow":[{"mrow":{"mi":"c","mo":".","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["\u03c4","_"]}}}},"mo":"<"},{"mrow":[{"msup":{"mi":["\u03c4","\u2032"]},"mo":["\u2062","\u2062"],"mrow":{"mo":["(",")"],"mrow":{"mi":"e","mo":".","mover":{"mi":["a","_"]}}}},{"mi":"e","mo":".","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"a"}},"mi":"_"}}}}],"mo":"\u21a6"}],"mo":":"}}}}},"When the method is not found in the current class, its superclass is searched. In this case, before performing the call, the receiver is upcasted. When calling a method defined on object on a base type, such as 5.GetType( ), this method invocation is translated into",{"@attributes":{"id":"p-0201","num":"0286"},"maths":{"@attributes":{"id":"MATH-US-00020","num":"00020"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"class","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mi":"c","mo":":","mrow":{"msup":{"mi":["c","\u2032"]},"mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mi":"\u03c4","mo":",","mover":{"mi":["md","_"]}}}}}}},{"mrow":{"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":"\u2062","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"msup":{"mi":["\u03c4","\u2033"]},"mi":"_"}}}},"mo":"\u2209","mover":{"mrow":{"mi":["m","d"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mi":"_"}}},{"mrow":{"mrow":[{"mrow":{"msup":{"mi":["c","\u2032"]},"mo":".","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["\u03c4","_"]}}}},"mo":"<"},{"msup":{"mi":["\u03c4","\u2032"]},"mo":["\u2062","\u2062"],"mi":"g"}],"mo":":"}},{"mrow":{"mrow":[{"mi":"c","mo":"<"},{"msup":{"mi":["c","\u2032"]},"mo":["\u2062","\u2062"],"mi":"f"}],"mo":":"}}]}},"mrow":{"mrow":[{"mrow":{"mi":"c","mo":".","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["\u03c4","_"]}}}},"mo":"<"},{"mrow":[{"msup":{"mi":["\u03c4","\u2032"]},"mo":["\u2062","\u2062"],"mrow":{"mo":["(",")"],"mrow":{"mi":"e","mo":".","mover":{"mi":["a","_"]}}}},{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"e"}},"mo":",","mover":{"mi":["a","_"]}}}}],"mo":"\u21a6"}],"mo":":"}}}}},"Recall that InnerXen class declarations contain, in addition to the methods, just a single content type. Thus, one might expect that the rules for generalized member access can be blindly applied to access elements of classes. Recursion requires a different approach. Consider the following recursive class List of lists of integers:\n\n","Given an instance xs of type List, it is not desired that xs.head recursively select all head fields in xs. However, simply unfolding the content type and using the rules given above for generalized access over tuple types that is precisely what would happen. There are a number of solutions, but in order to keep the Xen type system as simple as possible, the recursive cycles are broken at nominal types. This means that member lookup is not performed on nominal members of the content of nominal types. Using these refined rules, the result type of xs.head is int.","Formalizing this is trivial, but time-consuming. Another family of generalized member access judgments are defined, written \u03c4\u2022f\u2192g, which is identical to the previous rules except they are not defined for nominal types.","To define field access on nominal types, the content type of a class is first defined as follows.",{"@attributes":{"id":"p-0206","num":"0292"},"maths":{"@attributes":{"id":"MATH-US-00021","num":"00021"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mfrac":{"mrow":[{"mi":"class","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"c","mo":["(","}"],"mrow":{"mi":"\u03c4","mo":";","mover":{"mi":["md","_"]}}}},{"mrow":{"mi":"content","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mo":["(",")"],"mi":"c"}},"mo":"=","mi":"\u03c4"}]}},{"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"class","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"c","mo":":","mrow":{"msup":{"mi":["c","\u2032"]},"mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"mi":"\u03c4","mo":[";",";"],"mover":{"mi":["md","_"]}}}}}}},{"mrow":{"mrow":{"mi":"content","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["c","\u2032"]}}},"mo":"=","msup":{"mi":["\u03c4","\u2032"]}}}]}},"mrow":{"mrow":[{"mi":"content","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mrow":{"mo":["(",")"],"mi":"c"}},{"mi":"struct","mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":";","mi":"\u03c4"}}}],"mo":"="}}}]}}}}},"InnerXen provides a special member on class values, e.content that returns the content type value. The rule for generalized field selection on classes searches for the member f on the content type of class c and then applies the witness to the content value of the instance.",{"@attributes":{"id":"p-0208","num":"0294"},"maths":{"@attributes":{"id":"MATH-US-00022","num":"00022"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mi":"content","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}},"mo":"=","mi":"\u03c4"}},{"mrow":{"mrow":{"mi":["\u03c4","f"],"mo":"\u00b7"},"mo":["\u2062","\u2062"],"mi":"g"}}]}},"mrow":{"mrow":[{"mrow":{"mi":["c","f"],"mo":"."},"mo":"<"},{"mrow":[{"mi":["\u03c4","e"],"mo":["\u2062","\u2062"]},{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["e","content"],"mo":"."}}}],"mo":"\u21a6"}],"mo":":"}}}}},"Typing InnerXen Programs","Building on the previous description subsections, the rules for forming typing judgments over InnerXen expressions, statements, method declarations and programs are now provided.","Typing expressions. For the most part, the typing judgments for InnerXen are straightforward. As subtyping is treated using coercions, a typing judgment for expressions is of the form E\u251ce<: \u03c4e\u2032, which means that in a typing context E (which is a map from variable names to types) expression e has type \u03c4 and is expanded to the expression e\u2032.","The rules for expressions all follow the same pattern where the judgment on the level of expressions is defined in terms of a similar judgment on types. In addition to the member access and method call judgments described hereinabove, judgments for dynamic casting will be defined and used.","The typing judgments for literals, variables and null are standard and as follows.\n\n","The judgments for casting involve the application of the upcasting judgment \u03c4<: \u03c4\u2032f that was defined earlier and two new downcasting judgments (\u03c4) \u03c4\u2032f and \u03c4 is \u03c4\u2032f.","The downcasting rule (\u03c4)\u03c4\u2032 recursively deconstructs the downcast from a value of static type \u03c4\u2032 to a value of dynamic type \u03c4 up to the point where \u03c4\u2032 is a reference type. In that case, a true dynamic downcast can be performed based on the fact that reference types carry their dynamic type. Downcasting from a reference type to a value type also unboxes the value at runtime.\n\n","Downcasting from one struct to another attempts the downcast on all the components of the struct. Here, downcasting is lifted over field declarations in the obvious way.",{"@attributes":{"id":"p-0217","num":"0306"},"maths":{"@attributes":{"id":"MATH-US-00023","num":"00023"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mover":[{"mrow":{"mrow":{"mo":["(",")"],"msub":{"mi":["fd","i"]}},"mo":"\u2062","msubsup":{"mrow":{"mo":["(",")"],"mrow":{"mi":["f","d"],"mo":"\u2062"}},"mi":["i","\u2032"]}},"mi":"_"},{"msub":{"mi":["g","i"]},"mi":"_"}],"mo":["\u2062","\u2062"]},{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"mi":"struct","mo":"\u2062","mrow":{"mo":["{","}"],"mover":{"msub":{"mi":["fd","i"]},"mi":"_"}}}},{"mo":["{","}"],"mover":{"msubsup":{"mi":["fd","i","\u2032"]},"mi":"_"}}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mi":["struct","e"]},{"mi":"new","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mrow":{"msub":{"mi":["g","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"e","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"i"}}}},"mi":"_"}}}],"mo":"\u21a6"}]}}}},"Downcasting from a discriminated union first removes the type tag and then attempts to downcast the resulting value. It is not permitted to downcast to an either type.",{"@attributes":{"id":"p-0219","num":"0308"},"maths":{"@attributes":{"id":"MATH-US-00024","num":"00024"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mover":[{"mrow":{"mrow":{"mo":["(",")"],"mi":"\u03c4"},"mo":"\u2062","msubsup":{"mi":["\u03c4","i","\u2032"]}},"mi":"_"},{"msub":{"mi":["g","i"]},"mi":"_"}],"mo":["\u2062","\u2062"]},{"mrow":[{"mrow":[{"mo":["(",")"],"mi":"\u03c4"},{"mo":["{","}"],"mover":{"msubsup":{"mi":["\u03c4","i","\u2032"]},"mi":"_"}}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mi":["either","e"]},{"mo":"(","mover":{"mrow":{"mrow":{"mo":["{","}"],"mrow":{"mrow":{"mi":["if","return"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mrow":[{"mo":["(",")"],"mrow":{"mi":["e","was"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mo":"\u2062"},"msubsup":{"mi":["\u03c4","i","\u2032"]}}},{"msub":{"mi":["g","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["e","value"],"mo":"."}}}],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}},"mo":";"}},"mo":")"},"mi":"_"}}],"mo":"\u21a6"}]},"mo":"\u2062","mrow":{"msup":{"mo":["(","*"]},"mo":")"}}}}},"The typing judgments are now defined for both directions of casting of expressions in terms of these judgments on types:",{"@attributes":{"id":"p-0221","num":"0310"},"maths":[{"@attributes":{"id":"MATH-US-00025","num":"00025"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"E","mo":"\u22a2","mrow":{"mi":"e","mo":"<"}},{"msup":[{"mi":["\u03c4","\u2032"]},{"mi":["e","\u2032"]}],"mo":["\u2062","\u2062"]}],"mo":":"}},{"mrow":{"mrow":[{"msup":{"mi":["\u03c4","\u2032"]},"mo":"<"},{"mi":["\u03c4","f"],"mo":["\u2062","\u2062"]}],"mo":":"}}]}},"mrow":{"mrow":[{"mi":"E","mo":"\u22a2","mrow":{"mrow":{"mrow":{"mo":["(",")"],"mi":"\u03c4"},"mo":"\u2062","mi":"e"},"mo":"<"}},{"mi":"\u03c4","mo":["\u2062","\u2062"],"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["e","\u2032"]}}}}],"mo":":"}},"mo":"\u2062","mrow":{"mo":["(",")"],"mi":"upcast"}}}},{"@attributes":{"id":"MATH-US-00025-2","num":"00025.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"E","mo":"\u22a2","mrow":{"mi":"e","mo":"<"}},{"msup":[{"mi":["\u03c4","\u2032"]},{"mi":["e","\u2032"]}],"mo":["\u2062","\u2062"]}],"mo":":"}},{"mrow":{"mrow":{"mi":"\u03c4","mo":"<"},"mo":":","msup":{"mi":["\u03c4","\u2032"]}}},{"mrow":{"mrow":{"mo":["(",")"],"mi":"\u03c4"},"mo":"\u2062","msup":{"mi":["\u03c4","\u2032"]}}}]}},"mo":["\u2062","\u2062"],"mi":"f"},{"mrow":[{"mi":"E","mo":"\u22a2","mrow":{"mrow":{"mrow":{"mo":["(",")"],"mi":"\u03c4"},"mo":"\u2062","mi":"e"},"mo":"<"}},{"mi":"\u03c4","mo":["\u2062","\u2062"],"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["e","\u2032"]}}}}],"mo":":"}]},"mo":"\u2062","mrow":{"mo":["(",")"],"mi":"downcast"}}}}]},"Note that in order to satisfy a type soundness property, a \u201cstupid\u201d cast rule is defined in the now familiar fashion, but avoided here for brevity.","InnerXen has the is operator from C# that performs a dynamic check if the runtime type of an object is compatible with a given type. For this, an auxiliary judgment form \u03c4 is \u03c4\u2032g is introduced that returns the witness g for testing whether a value of type \u03c4 is at runtime a value of type \u03c4\u2032. The first three judgments are standard.",{"@attributes":{"id":"p-0224","num":"0313"},"maths":[{"@attributes":{"id":"MATH-US-00026","num":"00026"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":{"mi":"\u03b3","mo":"<"},"mo":":","mi":"\u03c4"},{"mrow":{"mi":["\u03b3","is","\u03c4","e"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":"\u21a6","mi":"true"}]}}},{"@attributes":{"id":"MATH-US-00026-2","num":"00026.2"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":{"mi":"\u03c1","mo":"<"},"mo":":","mi":"\u03c4"},{"mrow":[{"mi":["\u03c1","is","\u03c4","e"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mi":["e","null"],"mo":"!="}],"mo":"\u21a6"}]}}},{"@attributes":{"id":"MATH-US-00026-3","num":"00026.3"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":{"mi":"\u03c4","mo":"<"},"mo":":","mi":"\u03c1"},{"mrow":[{"mrow":[{"mi":["\u03c1","is","\u03c4","e"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mo":["(",")"],"mrow":{"mi":["e","null"],"mo":"!="}}],"mo":"\u21a6"},{"mo":["(",")"],"mrow":{"mi":["e","is","\u03c4"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}],"mo":["\u2062","&&"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}]}}}]},"The judgments for tuple types and discriminated unions show a duality. For tuple types it is recursively checked whether the is relation holds for all the components of the struct, while for discriminated unions, it is checked if any of the components was of the required type. Here, the is relation is lifted over field declarations in the obvious way.",{"@attributes":{"id":"p-0226","num":"0315"},"maths":{"@attributes":{"id":"MATH-US-00027","num":"00027"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mfrac":{"mrow":{"mover":[{"msub":{"mi":["fd","i"]},"mi":"_"},{"msubsup":{"mi":["fd","i","\u2032"]},"mi":"_"},{"msub":{"mi":["g","i"]},"mi":"_"}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mrow":{"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mo":"\u2062"},"mi":"is","mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mi":["struct","is","struct","e"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":[{"mo":["{","}"],"msub":{"mover":{"mi":["fd","_"]},"mi":"i"}},{"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mo":"\u2062"},{"mo":["{","}"],"mover":{"msubsup":{"mi":["fd","i","\u2032"]},"mi":"_"}}]},"mo":"\u21a6"}},{"mover":{"mrow":{"mo":"&&","mrow":{"msub":{"mi":["g","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"e","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"i"}}}}},"mi":"_"}}]}}},"mrow":{"mrow":{"mi":["either","is","either","e"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":[{"mo":["{","}"],"mover":{"mi":["\u03c4","_"]}},{"mo":["{","}"],"mrow":{"mover":[{"mi":["\u03c4","_"]},{"msubsup":{"mi":["\u03c4","\u03b9","\u2032"]},"mi":"_"}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}}]},"mo":"\u21a6","mover":{"mrow":{"mo":"||","mrow":{"mi":["e","was"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msubsup":{"mi":["\u03c4","i","\u2032"]}}},"mi":"_"}}}}}},"The typing judgment for an is expression can now be defined in terms of the judgment on types:",{"@attributes":{"id":"p-0228","num":"0317"},"maths":{"@attributes":{"id":"MATH-US-00028","num":"00028"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"E","mo":"\u22a2","mrow":{"mi":"e","mo":"<"}},{"msup":[{"mi":["\u03c4","\u2032"]},{"mi":["e","\u2032"]}],"mo":["\u2062","\u2062"]}],"mo":":"}},{"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["is","\u03c4","g"]}}]}},"mrow":{"mrow":[{"mi":"E","mo":"\u22a2","mrow":{"mrow":{"mi":["e","is","\u03c4"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}]},"mo":"<"}},{"mi":"bool","mo":["\u2062","\u2062"],"mrow":{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["e","\u2032"]}}}}],"mo":":"}}}}},"The typing judgment for the expression e was \u03c4 ensures that static type of e is a discriminated union that includes \u03c4, and generates the actual runtime conformity test to check if the dynamic value of e has type tag \u03c4.",{"@attributes":{"id":"p-0230","num":"0319"},"maths":{"@attributes":{"id":"MATH-US-00029","num":"00029"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":[{"mi":"E","mo":"\u22a2","mrow":{"mi":"e","mo":"<"}},{"mi":"either","mo":["\u2062","\u2062","\u2062"],"mrow":{"mo":["{","}"],"mrow":{"mi":"\u03c4","mo":";","mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}},"msup":{"mi":["e","\u2032"]}}],"mo":[":","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mrow":[{"mi":"E","mo":"\u22a2","mrow":{"mrow":{"mi":["e","was","\u03c4"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":"<"}},{"mi":["bool","was","\u03c4"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mrow":{"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mo":"\u2062"},"msup":{"mi":["e","\u2032"]},"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":[":","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}]}}}},"The type of an instance of a tuple type is derived from the type of the actual arguments of its constructor. The type of a binding expression f=e is derived from the binding expression e.",{"@attributes":{"id":"p-0232","num":"0321"},"maths":{"@attributes":{"id":"MATH-US-00030","num":"00030"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mi":"E","mo":"\u22a2","mrow":{"mover":[{"mi":["be","_"]},{"mi":["fd","_"]}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mover":{"mi":["be","_"]},"mi":"\u2032"}}},{"mi":"E","mo":"\u22a2","mrow":{"mrow":[{"mi":"new","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["be","_"]}}},{"mo":["{","}"],"mover":{"mi":["fd","_"]}},{"mi":"new","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mover":{"mi":["be","_"]},"mi":"\u2032"}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":"struct"}}]}}}},"The core subset of Xen supports one-argument constructors for classes that take an instance of the content type of that class:",{"@attributes":{"id":"p-0234","num":"0323"},"maths":{"@attributes":{"id":"MATH-US-00031","num":"00031"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":["e","\u03c4"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["e","\u2032"]}}}},{"mi":"\u03c4"}]}},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mi":"content","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"c"}},"mi":"f"},{"mi":"E","mo":"\u22a2","mrow":{"mi":["new","c","new"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":[{"mi":"c","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"e"}},{"mi":"c","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["e","\u2032"]}}}}}]}}]}}}},"Users never need to use the constructor for discriminated unions themselves, instead they can use subtyping to implicitly coerce a value into a discriminated union. Similarly, users never need to create closures explicitly, instead they use generating block expressions or methods. However, for completeness the type rules for these two constructors are provided:",{"@attributes":{"id":"p-0236","num":"0325"},"maths":[{"@attributes":{"id":"MATH-US-00032","num":"00032"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":["e","\u03c4"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["e","\u2032"]}}},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mi":"E","mo":["\u22a2","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}},"mrow":{"mi":["new","either"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mtext":"<:"}],"mrow":[{"mo":["{","}"],"mrow":{"mi":"\u03c4","mo":";","msup":{"mover":{"mi":["\u03c4","_"]},"mi":"\u2032"}}},{"mo":["(",")"],"mrow":{"mi":["\u03c4","e"],"mo":","}}]}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}},{"mtd":{"mrow":{"mrow":{"mi":["either","new","either"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mrow":[{"mo":["{","}"],"mrow":{"mi":"\u03c4","mo":";","mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}},{"mo":["{","}"],"mrow":{"mi":"\u03c4","mo":":","mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}},{"mo":["(",")"],"mrow":{"mi":"\u03c4","mo":",","msup":{"mi":["e","\u2032"]}}}],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"\u2003"}}}]}}}},{"@attributes":{"id":"MATH-US-00032-2","num":"00032.2"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mi":"E","mo":",","mrow":{"mi":"\u03c4","mo":"\u22a2","mrow":{"mover":[{"mi":["s","_"]},{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["s","\u2032"]}}}},{"mi":"E","mo":"\u22a2","mrow":{"mi":["new","\u03c4","new"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":[{"mi":"\u03c4","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["s","_"]}}},{"mi":"\u03c4","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mover":{"mi":["s","_"]},"mi":"\u2032"}}}]}}]}}}]},"The following example uses coercion, tuple type, and class construction to build an instance of the Address type:\n\n","It is illustrated hereinbelow how XML literals in the full Xen language make constructing such values easy.","The typing judgment for member access e.f on expressions simply uses the judgment for generalized member lookup defined earlier:",{"@attributes":{"id":"p-0240","num":"0330"},"maths":{"@attributes":{"id":"MATH-US-00033","num":"00033"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":["e","\u03c4"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["e","\u2032"]}}}},{"mrow":{"mi":["\u03c4","f"],"mo":"."}}]}},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["\u03c4","\u2032"]},"mi":"g"},{"mi":"E","mo":"\u22a2","mrow":{"mrow":[{"mi":["e","f"],"mo":"."},{"mi":"g","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["e","\u2032"]}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["\u03c4","\u2032"]}}}]}}}},"Positional access is not lifted; the receiver must be a tuple type:",{"@attributes":{"id":"p-0242","num":"0332"},"maths":{"@attributes":{"id":"MATH-US-00034","num":"00034"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":["e","struct","\u03c4"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mo":["{","}"],"mover":{"msub":{"mi":["fd","i"]},"mi":"_"}},"msup":{"mi":["e","\u2032"]}}}},{"mrow":{"mrow":{"mi":"type","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"msub":{"mi":["fd","i"]},"mi":"_"}}},"mo":"=","mi":"\u03c4"}}]}},"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mrow":[{"mi":"e","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"i"}},{"msup":{"mi":["e","\u2032"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"i"}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"\u03c4"}}}}}},"Typing promotable expressions. Promotable block expressions are the sinkholes of all new syntactic forms. Promotable block expressions are translated into closures when their bodies are generators; otherwise, they are translated into elementary block expressions. Typing of block expressions uses a conventional \u201crepmin\u201d-trick to feed the derived type of a statement list back as the required type. The function sort( ) is used to infer the required type of block expressions and apply-to-all expressions from the derived types. It constructs a discriminated union of all the maximal types (or just the maximal type, if there is just one).","The maximal type of a set of types is their least upper bound, provided it can be reached with identity conversions only. When the block expression is a generator block, i.e., contains a yield statement (which is checked by the yields predicate), the inferred type is a stream of the inferred type. For the expression {yield return 47; yield return \u201cHello\u201d;} the derived types for the block statements will be int, string and hence, the required type of the block will be sequence<either{int; string;)>. Note that Xen's syntactic context condition requires that any expression block must either have yield or return statements.",{"@attributes":{"id":"p-0245","num":"0335"},"maths":[{"@attributes":{"id":"MATH-US-00035","num":"00035"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":{"mrow":{"mi":"E","mo":",","mrow":{"mi":"sequence","mo":"\u2062","mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"mi":"sort","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["\u03c4","_"]}}}},{"mover":[{"mi":["s","_"]},{"mi":["\u03c4","_"]},{"msup":{"mi":["s","\u2032"]},"mi":"_"}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":"\u22a2"}},{"mrow":{"mi":"yields","mo":"(","mover":{"mi":["s","_"]}}}]}}}},"mo":")"},"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mo":["{","}"],"mover":{"mi":["s","_"]}}},{"mo":["\u2329","\u232a"],"mrow":{"mi":"sort","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["\u03c4","_"]}}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"sequence"}}}},{"mtd":{"mrow":{"mi":["new","sequence"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":[{"mo":["\u2329","\u232a"],"mrow":{"mi":"sort","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["\u03c4","_"]}}}},{"mo":["(",")"],"mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"}}]}}}]}}}},{"@attributes":{"id":"MATH-US-00035-2","num":"00035.2"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mi":"E","mo":",","mrow":{"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"sort","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["\u03c4","_"]}}},{"mover":[{"mi":["s","_"]},{"mi":["\u03c4","_"]},{"msup":{"mi":["s","\u2032"]},"mi":"_"}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":"\u22a2"}},{"mrow":{"mo":["-","|"]}}]}},"mo":"\u2062","mrow":{"mi":"yields","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["s","_"]}}}}},{"mi":"E","mo":"\u22a2","mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mo":["{","}"],"mover":{"mi":["s","_"]}}},{"mi":"sort","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["\u03c4","_"]}}},{"mo":["(",")"],"mrow":{"mo":["{","}"],"mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}]}}}]},"The typing of assignment is straightforward:",{"@attributes":{"id":"p-0247","num":"0337"},"maths":{"@attributes":{"id":"MATH-US-00036","num":"00036"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":["x","\u03c4"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}},{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":"e","mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":[{"mi":["\u03c4","\u2032"]},{"mi":["e","\u2032"]}]}}},{"mrow":{"mi":["\u03c4","f"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["\u03c4","\u2032"]}}}]}},"mrow":{"mrow":[{"mi":["E","x"],"mo":"\u22a2"},{"mrow":[{"mi":["e","\u03c4","x"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"e"}}],"mo":"="}],"mo":"="}}}}},"As for C# and Java, method resolution is based on the static types of the actual arguments and the receiver object. The generalized method invocation judgment defined earlier is used:",{"@attributes":{"id":"p-0249","num":"0339"},"maths":{"@attributes":{"id":"MATH-US-00037","num":"00037"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":["e","\u03c4"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["e","\u2032"]}}}},{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mover":[{"mi":["a","_"]},{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"},{"msup":{"mi":["a","\u2032"]},"mi":"_"}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}},{"mrow":{"mrow":{"mi":"\u03c4","mo":".","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}}},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["\u03c4","\u2033"]},"mi":"f"}}]}},"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mrow":[{"mi":"e","mo":".","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["a","_"]}}}},{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msup":[{"mi":["e","\u2032"]},{"mi":["a","\u2032"]}],"mo":","}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["\u03c4","\u2033"]}}}}}}},"Apply-to-all blocks on streams are syntactic sugar for a promotable block expression that applies the block to each element of its receiver stream. Note, again, the derived type is passed back as the required type.",{"@attributes":{"id":"p-0251","num":"0341"},"maths":{"@attributes":{"id":"MATH-US-00038","num":"00038"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":[{"mtr":{"mtd":[{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":["e","sequence"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mo":["\u2329","\u232a"],"mi":"\u03c4"},"msup":{"mi":["e","\u2032"]}}}},{"mrow":{"mrow":[{"mi":"E","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":["it","\u03c4"],"mo":"\u22a2"}}},{"mrow":[{"mi":"sequence","mo":"\u2062","mrow":{"mo":["\u2329","\u232a"],"mrow":{"mi":"sort","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["\u03c4","_"]}}}}},{"mover":[{"msup":{"mi":["s","\u2032"]},"mi":"_"},{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":"\u22a2"}],"mo":","}}]}},{"mtr":[{"mtd":{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mrow":[{"mi":"e","mo":".","mrow":{"mo":["{","}"],"mover":{"mi":["s","_"]}}},{"mo":["\u2329","\u232a"],"mrow":{"mi":"sort","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":"sequence"}}}},{"mtd":{"mrow":{"mo":["(",")"],"mrow":{"mo":["{","}"],"mrow":{"mrow":{"mrow":[{"mi":"foreach","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["\u03c4","it","in"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["e","\u2032"]}}}},{"mi":"return","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mo":["{","}"],"msup":{"mi":["s","\u2032"]}}}}],"mo":["\u2062","\u2062","\u2062"],"mi":"yield","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":";"}}}}}]}]}}}},"Typing statements. The empty statement does not contribute anything to the result of a statement block; neither does a nested block:\n\n",{"@attributes":{"id":"p-0253","num":"0344"},"maths":{"@attributes":{"id":"MATH-US-00039","num":"00039"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mi":"E","mo":",","mrow":{"mi":"\u03c4","mo":"\u22a2","mrow":{"mover":[{"mi":["s","_"]},{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"msup":{"mi":["s","\u2032"]}}}},{"mi":"E","mo":",","mrow":{"mi":"\u03c4","mo":"\u22a2","mrow":{"mrow":[{"mo":["{","}"],"mover":{"mi":["s","_"]}},{"mo":["{","}"],"msup":{"mi":["s","\u2032"]}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}}}]}}}},"Promotable expressions are executed for their side-effects, and their type is ignored:",{"@attributes":{"id":"p-0255","num":"0346"},"maths":{"@attributes":{"id":"MATH-US-00040","num":"00040"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mi":"E","mo":"\u22a2","mrow":{"mi":"pe","mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"msup":[{"mi":["\u03c4","\u2032"]},{"mi":["pe","\u2032"]}]}},{"mi":"E","mo":",","mrow":{"mi":"\u03c4","mo":"\u22a2","mrow":{"mi":["pe","void"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"msup":{"mi":["pe","\u2032"]}}}}]}}}},"The derived types of the two branches of conditional statements are combined, and the condition must have type bool. The while statement is completely analogous:",{"@attributes":{"id":"p-0257","num":"0348"},"maths":[{"@attributes":{"id":"MATH-US-00041","num":"00041"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":["e","bool"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"msup":{"mi":["e","\u2032"]}}}},{"mrow":{"mi":"E","mo":",","mrow":{"mi":"\u03c4","mo":"\u22a2","mrow":{"msub":{"mi":["s","l"]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"},"mi":"void","msubsup":{"mi":["s","\u2032"],"mn":"1"}}}}},{"mrow":{"mi":"E","mo":",","mrow":{"mi":"\u03c4","mo":"\u22a2","mrow":{"msub":{"mi":"s","mn":"2"},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mover":{"msup":{"mi":["\u03c4","\u2033"]},"mi":"_"},"mi":"void","msubsup":{"mi":["s","\u2032"],"mn":"2"}}}}}]}},"mrow":{"mi":"E","mo":[",",","],"mrow":[{"mi":"\u03c4","mo":"\u22a2","mrow":{"mrow":{"mi":"if","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"e"}},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"msub":[{"mi":"s","mn":"1"},{"mi":"s","mn":"2"}],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":"else","mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}},{"mover":{"msup":{"mi":["\u03c4","\u2033"]},"mi":"_"},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mrow":{"mi":"if","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["e","\u2032"]}}},"msubsup":[{"mi":["s","\u2032"],"mn":"1"},{"mi":["s","\u2032"],"mn":"2"}],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"else"}]}}}},{"@attributes":{"id":"MATH-US-00041-2","num":"00041.2"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":["e","bool"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"msup":{"mi":["e","\u2032"]}}}},{"mrow":{"mi":"E","mo":",","mrow":{"mi":"\u03c4","mo":"\u22a2","mrow":{"mi":"s","mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"},"msup":{"mi":["s","\u2032"]}}}}}]}},"mrow":{"mi":"E","mo":",","mrow":{"mi":"\u03c4","mo":"\u22a2","mrow":{"mi":["while","s","while"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":[{"mo":["(",")"],"mi":"e"},{"mo":["(",")"],"msup":{"mi":["e","\u2032"]}}],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"},"msubsup":{"mi":["s","\u2032"],"mn":"1"}}}}}}}]},"The required result type of statements is used in the return and yield statements. The empty return statement can only occur in a void returning context.\n\n","If necessary, the derived return type \u03c4\u2032 of a normal return statement is coerced to the required return type \u03c4.",{"@attributes":{"id":"p-0260","num":"0352"},"maths":{"@attributes":{"id":"MATH-US-00042","num":"00042"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":"e","mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"msup":[{"mi":["\u03c4","\u2032"]},{"mi":["e","\u2032"]}]}}},{"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u03c4","f"]}}]}},"mrow":{"mi":"E","mo":",","mrow":{"mrow":[{"mi":"\u03c4","mo":"\u22a2","mrow":{"mi":["return","e"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mstyle":[{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"msup":{"mi":["\u03c4","\u2032"]},"mi":"return","mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["e","\u2032"]}}}}],"mo":[";","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}}}}}}},"The return-type of a yield break statement is the null type.\n\n","The required type of a yield return statement is a stream type, and if necessary, the derived return type is upcasted to the required return type. A way of inspecting a stream element is by consuming it in a foreach loop. Otherwise stream elements can never be inspected. The implementation has to distinguish only between stream elements that produce streams and ones that are simple values. Formalization herein uses the type tagging scheme that has been introduced for either values.",{"@attributes":{"id":"p-0263","num":"0356"},"maths":[{"@attributes":{"id":"MATH-US-00043","num":"00043"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":[{"mtr":{"mtd":[{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":"e","mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"msup":[{"mi":["\u03c4","\u2032"]},{"mi":["e","\u2032"]}]}}},{"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":"\u2260","mrow":{"mi":"sequence","mo":"\u2062","mrow":{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2033"]}}}}},{"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mi":["\u03c4","f"]}}]}},{"mtr":[{"mtd":{"mrow":{"mi":"E","mo":",","mrow":{"mrow":{"mrow":[{"mi":"sequence","mo":"\u2062","mrow":{"mo":["\u2329","\u232a"],"mi":"\u03c4"}},{"mi":["yield","return","e"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":"\u22a2"},"mo":[";","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"}]}}}},{"mtd":{"mrow":{"mrow":{"mi":["sequence","yield","return","new","sequence"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mrow":[{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2032"]}},{"mo":["\u2329","\u232a"],"mi":"\u03c4"},{"mo":["(",")"],"mrow":{"mi":"\u03c4","mo":",","mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["e","\u2032"]}}}}}],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":";"}}}]}]}}},{"@attributes":{"id":"MATH-US-00043-2","num":"00043.2"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":["e","sequence"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mrow":{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2032"]}},"msup":{"mi":["e","\u2032"]}}}},{"mrow":{"mi":["sequence","sequence","f"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mrow":[{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2032"]}},{"mo":["\u2329","\u232a"],"mi":"\u03c4"}],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}]}}]}},"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mo":"\u2062","mtable":{"mtr":[{"mtd":{"mrow":{"mi":"E","mo":",","mrow":{"mrow":{"mrow":[{"mi":"sequence","mo":"\u2062","mrow":{"mo":["\u2329","\u232a"],"mi":"\u03c4"}},{"mi":["yield","return","e"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}],"mo":"\u22a2"},"mo":";","mstyle":{"mtext":"<:"}}}}},{"mtd":{"mrow":{"mrow":{"mi":["sequence","yield","return","new","sequence"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mrow":[{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2032"]}},{"mo":["\u2329","\u232a"],"mi":"\u03c4"},{"mo":["(",")"],"mrow":{"mrow":[{"mi":"sequence","mo":"\u2062","mrow":{"mo":["\u2329","\u232a"],"mi":"\u03c4"}},{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["e","\u2032"]}}}],"mo":","}}],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":";"}}}]}}}}}]},"The last rule uses the equivalence sequence<\u03c4\u2032>\u2245sequence<sequence<\u03c4\u2032>> for simplification of the inferred return type. This rule also shows that covariance on streams is only applicable when the coercion on the element type is the identity. Thus, sometimes, a nested stream is explicitly copied to \u201copen it for conversion\u201d. For example, the following method fails to type-check because the type of the type of ns is not convertible to the required type of the method f:","sequence<int> ns= . . . ;","sequence<object> f( ){yield return ns;}","The type correct way is to copy the stream ns, such that each element can be implicitly boxed from int to object.","sequence<object> f( ) {yield return ns.{return it;};}","Note the conciseness of the apply-to-all expression to achieve this. Depending on whether the element type of the collection in a foreach statement is a supertype or a subtype of the declared type of the iteration variable, coercion is first applied to a fresh iteration variable y (i.e., y\u2209dom (E)):",{"@attributes":{"id":"p-0267","num":"0360"},"maths":[{"@attributes":{"id":"MATH-US-00044","num":"00044"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":[{"mtr":{"mtd":[{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":["e","sequence","f"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mrow":{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2032"]}},"msup":[{"mi":["e","\u2032"]},{"mi":["\u03c4","\u2032"]},{"mi":["\u03c4","\u2033"]}]}}},{"mrow":{"mrow":[{"mi":"E","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":"x","mo":"\u21a6","msup":{"mi":["\u03c4","\u2033"]}}}},{"mi":"\u03c4","mo":"\u22a2","mrow":{"mi":"s","mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mover":{"msup":{"mi":["\u03c4","\u2032\u2032\u2032"]},"mi":"_"},"msup":{"mi":["s","\u2032"]}}}],"mo":","}}]}},{"mtr":[{"mtd":{"mrow":{"mi":"E","mo":",","mrow":{"mi":"\u03c4","mo":"\u22a2","mrow":{"mi":["foreach","s"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2033"]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["x","in","e"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}},"mover":{"msup":{"mi":["\u03c4","\u2032\u2032\u2032"]},"mi":"_"}}}}}},{"mtd":{"mrow":{"mi":"foreach","mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":[{"mo":["(",")"],"mrow":{"msup":[{"mi":["\u03c4","\u2032"]},{"mi":["e","\u2032"]}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["y","in"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}},{"mo":["{","}"],"mrow":{"mrow":{"mrow":[{"msup":{"mi":["\u03c4","\u2033"]},"mo":"\u2062","mi":"c"},{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"y"}}],"mo":"="},"mo":";","msup":{"mi":["s","\u2032"]}}}]}}}]}]}}},{"@attributes":{"id":"MATH-US-00044-2","num":"00044.2"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":[{"mtr":{"mtd":[{"mrow":{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":["e","sequence"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mrow":{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2032"]}},"msup":{"mi":["e","\u2032"]}}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},{"mrow":{"mrow":{"mo":["(",")"],"msup":{"mi":["\u03c4","\u2033"]}},"mo":["\u2062","\u2062","\u2062"],"msup":{"mi":["\u03c4","\u2032"]},"mi":"f"}},{"mrow":{"mrow":[{"mi":"E","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":"x","mo":"\u21a6","msup":{"mi":["\u03c4","\u2033"]}}}},{"mi":"\u03c4","mo":"\u22a2","mrow":{"mi":"s","mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mover":{"msup":{"mi":["\u03c4","\u2032\u2032\u2032"]},"mi":"_"},"msup":{"mi":["s","\u2032"]}}}],"mo":","}}]}},{"mtr":[{"mtd":{"mrow":{"mi":"E","mo":",","mrow":{"mi":"\u03c4","mo":"\u22a2","mrow":{"mi":["foreach","s"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<:"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}}],"mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2033"]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["x","in","e"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}},"mover":{"msup":{"mi":["\u03c4","\u2032\u2032\u2032"]},"mi":"_"}}}}}},{"mtd":{"mrow":{"mi":"foreach","mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":[{"mo":["(",")"],"mrow":{"msup":[{"mi":["\u03c4","\u2032"]},{"mi":["e","\u2032"]}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mi":["y","in"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}},{"mo":["{","}"],"mrow":{"mrow":{"mrow":[{"msup":{"mi":["\u03c4","\u2033"]},"mo":"\u2062","mi":"x"},{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"y"}}],"mo":"="},"mo":";","msup":{"mi":["s","\u2032"]}}}]}}}]}]}}}]},"Typing statement lists. Local variable declarations in statement lists are similar to a local variable assignment, but they also extend the environment:",{"@attributes":{"id":"p-0269","num":"0362"},"maths":{"@attributes":{"id":"MATH-US-00045","num":"00045"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"E","mo":"\u22a2","mrow":{"mi":"e","mo":"<","mrow":{"mstyle":{"mtext":":"},"mo":["\u2062","\u2062","\u2062"],"msup":[{"mi":["\u03c4","\u2032"]},{"mi":["e","\u2032"]}]}}}},{"mrow":{"msup":[{"mi":["\u03c4","\u2032"]},{"mi":["\u03c4","\u2033"]}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<"},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"f"}},{"mrow":{"mrow":[{"mi":"E","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":"x","mo":"\u21a6","msup":{"mi":["\u03c4","\u2033"]}}}},{"mi":"\u03c4","mo":"\u22a2","mrow":{"mi":"s","mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<"},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mover":[{"msup":{"mi":["\u03c4","\u2032\u2032\u2032"]},"mi":"_"},{"msup":{"mi":["s","\u2032"]},"mi":"_"}]}}],"mo":","}}]}},"mrow":{"mi":"E","mo":",","mrow":{"mrow":[{"mrow":{"mi":"\u03c4","mo":"\u22a2","mrow":{"msup":{"mi":["\u03c4","\u2033"]},"mo":"\u2062","mi":"x"}},"mo":"=","mi":"e"},{"mrow":[{"mover":[{"mi":["s","_"]},{"msup":{"mi":["\u03c4","\u2032\u2032\u2032"]},"mi":"_"}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<"},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["\u03c4","\u2033"]},"mi":"x"},{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"msup":{"mi":["e","\u2032"]}}}],"mo":"="}],"mo":[";",";"],"mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"}}}}}}},"In all other cases, the derived types of the statement lists are combined",{"@attributes":{"id":"p-0271","num":"0364"},"maths":{"@attributes":{"id":"MATH-US-00046","num":"00046"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mi":"E","mo":",","mtable":{"mtr":{"mtd":[{"mrow":{"mi":"\u03c4","mo":"\u22a2","mrow":{"mi":"s","mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<"},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"},"msup":{"mi":["s","\u2032"]}}}},{"mrow":{"mi":"E","mo":",","mrow":{"mi":"\u03c4","mo":"\u22a2","mrow":{"mi":"ss","mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<"},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mover":{"msup":{"mi":["\u03c4","\u2033"]},"mi":"_"},"msup":{"mi":["ss","\u2032"]}}}}}]}}},{"mi":"E","mo":[",",","],"mrow":[{"mi":"\u03c4","mo":"\u22a2","mrow":{"mi":["s","ss"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<"},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mover":{"msup":{"mi":["\u03c4","\u2032"]},"mi":"_"}}},{"mover":{"msup":{"mi":["\u03c4","\u2033"]},"mi":"_"},"mo":["\u2062","\u2062","\u2062","\u2062"],"msup":[{"mi":["s","\u2032"]},{"mi":["ss","\u2032"]}],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}]}]}}}},"Typing programs. The rules for typing programs and class declarations are straightforward, and just recursively check\/translate all class declarations in a program:",{"@attributes":{"id":"p-0273","num":"0366"},"maths":[{"@attributes":{"id":"MATH-US-00047","num":"00047"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"c","mo":["\u2062","\u2062"],"msup":{"mi":["c","\u2032"]}}},{"mover":{"mrow":{"mi":["c","d"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mi":"_"}}]}},"mo":["\u2062","\u2062"],"mover":{"mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msup":{"mi":["d","\u2032"]}},"mi":"_"}},{"mover":[{"mrow":{"mi":["c","c","d"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},"mi":"_"},{"mrow":{"msup":[{"mi":["c","\u2032"]},{"mi":["d","\u2032"]}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mi":"c"},"mi":"_"}],"mo":["\u2062","\u2062"]}]}}},{"@attributes":{"id":"MATH-US-00047-2","num":"00047.2"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mi":"c","mo":"\u22a2","mrow":{"mover":[{"mi":["md","_"]},{"msup":{"mi":["md","\u2032"]},"mi":"_"}],"mo":["\u2062","\u2062"]}},{"mi":["class","c","class","c"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":[{"mi":["c","\u2032"]},{"mi":["c","\u2032"]}],"mrow":[{"mo":["{","}"],"mrow":{"mi":"\u03c4","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mover":{"mi":["md","_"]}}},{"mo":["{","}"],"mrow":{"mi":"\u03c4","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mover":{"mi":["md","_"]}}}]}]}}}]},"Consider typing method declarations. Normal methods are checked by extending the environment with the types of the formal parameters and the this pointer.",{"@attributes":{"id":"p-0275","num":"0368"},"maths":{"@attributes":{"id":"MATH-US-00048","num":"00048"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":[{"mo":["[","]"],"mrow":{"mrow":[{"mi":["this","c"],"mo":["\u2062","\u21a6","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},{"mover":[{"mi":["x","_"]},{"mi":["\u03c4","_"]}],"mo":"\u21a6"}],"mo":","}},{"mrow":[{"msup":{"mi":["\u03c4","\u2032"]},"mo":"\u22a2","mrow":{"mrow":{"mover":[{"mi":["s","_"]},{"msup":{"mi":["\u03c4","\u2033"]},"mi":"_"},{"msup":{"mi":["s","\u2032"]},"mi":"_"}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<"},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":["\u2062","-"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}},{"mi":"yields","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["s","_"]}}}],"mo":"\u2758"}],"mo":","},{"mi":"c","mo":"\u22a2","mrow":{"msup":[{"mi":["\u03c4","\u2032"]},{"mi":["\u03c4","\u2032"]}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<"},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":[{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mrow":{"mi":["\u03c4","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mi":"_"}}},{"mo":["{","}"],"mover":{"mi":["s","_"]}},{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mrow":{"mi":["\u03c4","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mi":"_"}}},{"mo":["{","}"],"mrow":{"mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"},"mo":";"}}]}}]}}}},"Generator methods, i.e., methods that yield, are translated into ordinary methods that immediately return a promotable block expression that constructs a closure to lazily generate the stream defined by this method.",{"@attributes":{"id":"p-0277","num":"0370"},"maths":{"@attributes":{"id":"MATH-US-00049","num":"00049"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":{"mrow":[{"mo":["[","]"],"mrow":{"mrow":[{"mi":["this","c"],"mo":["\u2062","\u21a6","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}]},{"mover":[{"mi":["x","_"]},{"mi":["\u03c4","_"]}],"mo":"\u21a6"}],"mo":","}},{"mrow":[{"mi":"sequence","mo":"\u2062","mrow":{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2032"]}}},{"mover":[{"mi":["s","_"]},{"msup":{"mi":["\u03c4","\u2033"]},"mi":"_"},{"msup":{"mi":["s","\u2032"]},"mi":"_"}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<"},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mi":"yields","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["s","_"]}}}}],"mo":["\u22a2","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}],"mo":","},"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"c","mo":["\u2062","\u22a2","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":[{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mrow":{"mi":["\u03c4","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mi":"_"}}},{"mo":["{","}"],"mover":{"mi":["s","_"]}}]}}}},{"mtd":{"mrow":{"mi":"sequence","mo":["\u2062","\u2062","\u2062","\u2062"],"mrow":[{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2032"]}},{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mrow":{"mi":["\u03c4","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mi":"_"}}},{"mo":["{","}"],"mrow":{"mrow":{"mi":["return","new","sequence"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":[{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2032"]}},{"mo":["(",")"],"mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"}}]},"mo":";"}}],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}}]}}}}},"Dynamic Semantics","In this section, the dynamics of InnerXen are formalized by defining an operational semantics. This is in the form of a reduction relation, although a \u2018big-step\u2019 evaluation relation can easily be defined. First, the value forms of InnerXen expressions are defined (where bv is the value form of a binding expression):",{"@attributes":{"id":"p-0280","num":"0373"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Expression values","v ::= b | i | null","Basic values"]},{"entry":[{},"\u2003| r","Reference"]},{"entry":[{},"\u2003| new ( )","Struct value"]},{"entry":[{},"\u2003| new \u03c4(\u03c4\u2032, v)","Either value or stream element"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Evaluation of InnerXen expressions and statements takes place in the context of a state, which is a pair (H, R), where H is a heap and R is a stack frame. A heap is represented as a finite partial map from references r to runtime objects, and a stack frame is a finite partial map from variable identifiers to values. A runtime object, as for C#, is a pair (\u03c4, cn) where \u03c4 is a type and cn is a canonical, which is either a value or a closure. A closure is the runtime representation of a stream and is written as a pair (R, ) where R is a stack frame and  is a statement sequence.","In what follows, it is assumed that expressions and statements are well-typed. As has been mentioned before, the extensive use of coercions means that a number of expression and statement forms do not appear in their full generality at runtime.","For purposes of brevity, only the key reduction steps are described. Evaluation contexts, written E[ ], are used to encode the evaluation strategy in the now familiar way. The definition is omitted. The key feature is that an InnerXen expression (and also for statements) is either a value or can be uniquely decomposed to the form E[e].","Reduction of expressions. The reduction relation for InnerXen expressions is written S, e\u2192S\u2032, e\u2032 which means that given a state S, expression e reduces by one or possibly more steps to e\u2032 and a (possibly updated) state S\u2032. (An auxiliary function value is used, and defined as follows:",{"@attributes":{"id":"p-0285","num":"0378"},"maths":{"@attributes":{"id":"MATH-US-00050","num":"00050"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mrow":{"mi":"value","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["f","v"],"mo":"-"}}},"mo":["\u2062","\u2062"],"mover":{"mo":"=","mi":"def"},"mi":"v"},{"mrow":[{"mi":"value","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"v"}},{"mi":"v","mo":"."}],"mo":["\u2062","\u2062"],"mover":{"mo":"=","mi":"def"}}],"mo":","},"mo":")"}}},"ul":{"@attributes":{"id":"ul0083","list-style":"none"},"li":{"@attributes":{"id":"ul0083-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0084","list-style":"none"},"li":{"@attributes":{"id":"ul0084-0001","num":"0379"},"o":["(H, R), x\u2192(H, R), R(x)","(H, R), x\u2192(H, R), R(x)","(H, R), x\u2192(H, R), R(x)"]}}}}},{"@attributes":{"id":"p-0286","num":"0380"},"maths":[{"@attributes":{"id":"MATH-US-00051","num":"00051"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"r"}},{"mo":["(",")"],"mrow":{"mi":["c","cn"],"mo":","}}],"mo":"="},{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mi":["r","content"],"mo":"."},{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}}],"mo":"->"}],"mo":[",",","],"mi":"cn"}]}}},{"@attributes":{"id":"MATH-US-00051-2","num":"00051.2"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mn":"0","mo":["\u2264","\u2264"],"mi":["i","n"]},{"mi":"S","mo":[",",","],"mrow":[{"mrow":{"mrow":[{"mi":"new","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"bv","mn":"0"},{"mi":["bv","n"]}],"mo":[",","\u2062",","],"mi":"\u2026","mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}}},{"mo":["[","]"],"mi":"i"}],"mo":"\u2061"},"mo":"->","mi":"S"},{"mi":"value","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["bv","i"]}}}]}]}}},{"@attributes":{"id":"MATH-US-00051-3","num":"00051.3"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"r"}},{"mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":",","mi":"cn"}},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"msup":{"mi":["\u03c4","\u2032"]},"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mtext":"<"},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"\u03c4"}],"mo":"="},{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mi":["r","is","\u03c4"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}}],"mo":"->"}],"mo":[",",","],"mi":"true"}]}}},{"@attributes":{"id":"MATH-US-00051-4","num":"00051.4"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"r"}},{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":",","mi":"cn"}}],"mo":"="}},{"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"\u226e:"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"\u03c4"}}]}},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mi":["r","is","\u03c4"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}}],"mo":"->"}],"mo":[",",","],"mi":"false"}}}}],"ul":{"@attributes":{"id":"ul0085","list-style":"none"},"li":{"@attributes":{"id":"ul0085-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0086","list-style":"none"},"li":{"@attributes":{"id":"ul0086-0001","num":"0381"},"o":"S, new \u03c4\u2032(\u03c4, v) was \u03c4\u2192S, true"}}}}},{"@attributes":{"id":"p-0287","num":"0382"},"maths":{"@attributes":{"id":"MATH-US-00052","num":"00052"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mi":"\u03c4","mo":"\u2260","msup":{"mi":["\u03c4","\u2033"]}},{"mi":["S","false"],"mo":[",",","],"mrow":{"mrow":{"mi":["new","was"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["\u03c4","v"],"mo":","}}},"msup":{"mi":["\u03c4","\u2033"]}},"mo":"->","mi":"S"}}]}}},"ul":{"@attributes":{"id":"ul0087","list-style":"none"},"li":{"@attributes":{"id":"ul0087-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0088","list-style":"none"},"li":{"@attributes":{"id":"ul0088-0001","num":"0383"},"o":"S, new \u03c4\u2032(\u03c4, v).value\u2192S, v"}}}}},{"@attributes":{"id":"p-0288","num":"0384"},"maths":{"@attributes":{"id":"MATH-US-00053","num":"00053"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"r"}},{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":",","mi":"cn"}}],"mo":"="}},{"mrow":{"mi":"\u03c4","mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":"<"},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"msup":{"mi":["\u03c4","\u2032"]}}}]}},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mrow":{"mo":["(",")"],"mi":"\u03c4"},"mo":"\u2062","mi":"r"},{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}}],"mo":"->"}],"mo":[",",","],"mi":"r"}}}}},"Two rules for creating runtime objects are given below. The first creates a simple boxed object, places it on the heap (at a fresh location) and returns the heap reference. The second is similar but creates a closure to be placed on the heap.",{"@attributes":{"id":"p-0290","num":"0386"},"maths":[{"@attributes":{"id":"MATH-US-00054","num":"00054"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mi":"r","mo":"\u2209","mrow":{"mi":"dom","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"H"}}},{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mi":"new","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"\u03c4","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"v"}}},{"mo":["(",")"],"mrow":{"mrow":{"mi":"H","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":"r","mo":"\u21a6","mrow":{"mo":["(",")"],"mrow":{"mi":["\u03c4","v"],"mo":","}}}}},"mo":",","mi":"R"}}],"mo":"->"}],"mo":[",",","],"mi":"r"}]}}},{"@attributes":{"id":"MATH-US-00054-2","num":"00054.2"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mi":"r","mo":"\u2209","mrow":{"mi":"dom","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"H"}}},{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mi":"new","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"\u03c4","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["s","_"]}}}},{"mo":["(",")"],"mrow":{"mrow":{"mi":"H","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":"r","mo":"\u21a6","mrow":{"mo":["(",")"],"mrow":{"mi":"\u03c4","mo":",","mrow":{"mo":["(",")"],"mrow":{"mi":"R","mo":",","mover":{"mi":["s","_"]}}}}}}}},"mo":",","mi":"R"}}],"mo":"->"}],"mo":[",",","],"mi":"r"}]}}}]},"Reduction of promotable expressions. Evaluating an assignment simply updates the stack frame:\n\n","Evaluating a method call first extracts the appropriate method body, then creates a new stack frame consisting of the local bindings of the parameters to the corresponding arguments, and finally, evaluates the body. Symbolically, \u2192* means the reflexive, transitive closure of \u2192.",{"@attributes":{"id":"p-0293","num":"0390"},"maths":{"@attributes":{"id":"MATH-US-00055","num":"00055"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":[{"mtd":{"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"r"}},{"mo":["(",")"],"mrow":{"mi":["c","_"],"mo":","}}],"mo":"="}},{"mrow":{"mrow":[{"mi":"method","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["m","c"],"mo":","}}},{"mrow":[{"msup":{"mi":["\u03c4","\u2032"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mrow":{"mi":["\u03c4","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mi":"_"}}},{"mo":["{","}"],"mover":{"mi":["s","_"]}}],"mo":"\u2062"}],"mo":"="}}]}}}},{"mtd":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":"H","mo":",","mrow":{"mo":["[","]"]}}},{"mrow":[{"mo":["{","}"],"mrow":{"mrow":{"mrow":{"mi":["c","this"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"=","mi":"r"},"mo":[";",";"],"mover":[{"mrow":{"mrow":{"mi":["\u03c4","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":"=","mi":"v"},"mi":"_"},{"mi":["s","_"]}]}},{"mo":"*","mrow":{"mo":["(",")"],"mrow":{"msup":[{"mi":["H","\u2032"]},{"mi":["R","\u2032"]}],"mo":","}}}],"mo":"->"},{"mi":"return","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msup":{"mi":["v","\u2032"]}}],"mo":[",",",",","],"mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"}}}}]},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mi":"r","mo":".","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["v","_"]}}}},{"mo":["(",")"],"mrow":{"msup":[{"mi":["H","\u2032"]},{"mi":["R","\u2032"]}],"mo":","}}],"mo":"->"}],"mo":[",",","],"msup":{"mi":["v","\u2032"]}}}}}},"Stream generating block expressions are translated to closures; non-generating block expressions evaluate the statement sequence in the current frame.",{"@attributes":{"id":"p-0295","num":"0392"},"maths":{"@attributes":{"id":"MATH-US-00056","num":"00056"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mover":{"mi":["s","_"]},"mo":"->","mrow":{"mo":"*","mrow":{"mo":["(",")"],"mrow":{"msup":[{"mi":["H","\u2032"]},{"mi":["R","\u2032"]}],"mo":","}}}},{"mi":["return","v"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}}],"mo":[",",",",","],"mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"}},{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mo":["(",")"],"mrow":{"mo":["{","}"],"mover":{"mi":["s","_"]}}},{"mo":["(",")"],"mrow":{"msup":[{"mi":["H","\u2032"]},{"mi":["R","\u2032"]}],"mo":","}}],"mo":"->"}],"mo":[",",","],"mi":"v"}]}}}},"For void methods and block expressions that return void, two further rules are provided. The statement sequence  has been exhausted or statement execution of  is interrupted by a return; statement. In both cases, the pseudo-value void is returned as the result. The type system guarantees that this result is never inspected and the operational semantics guarantees that it is immediately discarded. For purposes of brevity these rules are not provided. However, the rules for foreach are similar in spirit.","As for Java, there are a number of known error configurations. ERR denotes the set of predictable errors. One member of this set is NullX, which is generated by the following rules. Other error states can be created.",{"@attributes":{"id":"p-0298","num":"0395"},"maths":[{"@attributes":{"id":"MATH-US-00057","num":"00057"},"math":{"@attributes":{"overflow":"scroll"},"mover":{"mrow":{"mi":["S","NullX"],"mo":[",",","],"mrow":{"mrow":{"mi":"null","mo":".","mrow":{"mi":"m","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":["v","_"]}}}},"mo":"\u2192","mi":"S"}},"mi":"_"}}},{"@attributes":{"id":"MATH-US-00057-2","num":"00057.2"},"math":{"@attributes":{"overflow":"scroll"},"mover":{"mrow":{"mi":["S","NullX"],"mo":[",",","],"mrow":{"mrow":{"mi":["null","content"],"mo":"."},"mo":"\u2192","mi":"S"}},"mi":"_"}}}]},"Reduction of statements. A statement value is of the form \u2018;\u2019, return;, return v;, yield break; or yield return v. The reduction relation for statements (resp. statement lists) is written S, s\u2192S\u2032, s\u2032 (resp. S, \u2192S\u2032, ). The rules for if, while, promotable expressions, updates of local variables and blocks are standard:",{"@attributes":{"id":"p-0300","num":"0397"},"maths":[{"@attributes":{"id":"MATH-US-00058","num":"00058"},"math":{"@attributes":{"overflow":"scroll"},"mover":{"mrow":{"mi":"S","mo":[",",","],"mrow":{"mrow":{"mi":["if","else"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mo":["(",")"],"mi":"true"},"msub":[{"mi":"s","mn":"1"},{"mi":"s","mn":"2"}]},"mo":"\u2192","mi":"S"},"msub":{"mi":"s","mn":"1"}},"mi":"_"}}},{"@attributes":{"id":"MATH-US-00058-2","num":"00058.2"},"math":{"@attributes":{"overflow":"scroll"},"mover":{"mrow":{"mi":"S","mo":[",",","],"mrow":{"mrow":{"mi":["if","else"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mo":["(",")"],"mi":"false"},"msub":[{"mi":"s","mn":"1"},{"mi":"s","mn":"2"}]},"mo":"\u2192","mi":"S"},"msub":{"mi":"s","mn":"2"}},"mi":"_"}}},{"@attributes":{"id":"MATH-US-00058-3","num":"00058.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mrow":{"mi":"S","mo":[",",","],"mrow":[{"mrow":{"mrow":[{"mi":["wh","ile"],"mo":"\u2062"},{"mo":["(",")"],"mi":"e"},{"mo":["{","}"],"mover":{"mi":["s","_"]}}],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":["\u2062","\u2192"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"S"},{"mi":["if","else"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":[{"mo":["(",")"],"mi":"e"},{"mo":["{","}"],"mrow":{"mover":{"mi":["s","_"]},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"while","mrow":[{"mo":["(",")"],"mi":"e"},{"mo":["{","}"],"mover":{"mi":["s","_"]}}]}},{"mo":["{",";","}"]}]}]},"mi":"_"},"mo":"\u2062"}}},{"@attributes":{"id":"MATH-US-00058-4","num":"00058.4"},"math":{"@attributes":{"overflow":"scroll"},"mover":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mi":["\u03c4","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"v","mo":"\u2192","mrow":{"mo":["(",")"],"mrow":{"mi":"H","mo":",","mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":["x","v"],"mo":"\u21a6"}}}}}}],"mo":"="}],"mo":[",",",",";"]},"mi":"_"}}},{"@attributes":{"id":"MATH-US-00058-5","num":"00058.5"},"math":{"@attributes":{"overflow":"scroll"},"mover":{"mrow":{"mrow":{"mi":"S","mo":[",",","],"mrow":{"mrow":{"mo":["{","}"],"mover":{"mi":["s","_"]}},"mo":"\u2192","mi":"S"},"mover":{"mi":["s","_"]}},"mo":"\u2062","mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mi":"_"}}},{"@attributes":{"id":"MATH-US-00058-6","num":"00058.6"},"math":{"@attributes":{"overflow":"scroll"},"mover":{"mrow":{"mi":"S","mo":[",",",",";"],"mrow":{"mi":["v","S"],"mo":"\u2192"}},"mi":"_"}}}]},"The rules for foreach effectively perform a lazy depth-first traversal over the n-ary tree produced by the stream generators. If the stream is null the iteration stops.",{"@attributes":{"id":"p-0302","num":"0399"},"maths":{"@attributes":{"id":"MATH-US-00059","num":"00059"},"math":{"@attributes":{"overflow":"scroll"},"mover":{"mrow":{"mi":"S","mo":[",",",",";"],"mrow":{"mrow":{"mi":["foreach","s"],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mi":["\u03c4","x","in","null"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}},"mo":"\u2192","mi":"S"}},"mi":"_"}}}},"When the stream is not null, every iteration forces the evaluation of part of the stream as follows. First, a new evaluation context is created with the closure's frame as the current frame and the closure statements as its body. Next, the body is evaluated until it cannot be reduced any further. Then a case distinction is made. If the computation producing the stream is empty, or if the computation producing the stream breaks the foreach loop is equivalent to skip.",{"@attributes":{"id":"p-0304","num":"0401"},"maths":[{"@attributes":{"id":"MATH-US-00060","num":"00060"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"r"}},{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":",","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["R","\u2032"]},"mo":",","mover":{"mi":["s","_"]}}}}}],"mo":"="}},{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":"H","mo":",","msup":{"mi":["R","\u2032"]}}},{"mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"},"mo":"->","mrow":{"mo":"*","mrow":{"mo":["(",")"],"mrow":{"msup":[{"mi":["H","\u2032"]},{"mi":["R","\u2033"]}],"mo":","}}}}],"mo":[",",",",";"]}}]}},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mi":["foreach","s"],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mi":["\u03c4","x","in","r"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}},{"mo":["(",")"],"mrow":{"mrow":{"msup":{"mi":["H","\u2032"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":"r","mo":"\u21a6","mrow":{"mo":["(",")"],"mrow":{"mi":"\u03c4","mo":",","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["R","\u2033"]},"mo":[",",";"]}}}}}}},"mo":",","mi":"R"}}],"mo":"->"}],"mo":[",",",",";"]}}}},{"@attributes":{"id":"MATH-US-00060-2","num":"00060.2"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"r"}},{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":",","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["R","\u2032"]},"mo":",","mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"}}}}}],"mo":"="}},{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":"H","mo":",","msup":{"mi":["R","\u2032"]}}},{"mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"},"mo":"->","mrow":{"mo":"*","mrow":{"mo":["(",")"],"mrow":{"msup":[{"mi":["H","\u2032"]},{"mi":["R","\u2033"]}],"mo":","}}}},{"mrow":{"mi":["yield","break"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},"mo":";","mover":{"msup":{"mi":["s","\u2033"]},"mi":"_"}}],"mo":[",",","]}}]}},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mi":["foreach","s"],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mi":["\u03c4","x","in","r"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}},{"mo":["(",")"],"mrow":{"mrow":{"msup":{"mi":["H","\u2032"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":"r","mo":"->","mrow":{"mo":["(",")"],"mrow":{"mi":"\u03c4","mo":",","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["R","\u2033"]},"mo":[",",";"]}}}}}}},"mo":",","mi":"R"}}],"mo":"->"}],"mo":[",",",",";"]}}}}]},"In any case, the side-effect of the evaluation are recorded in the closure, otherwise other references could not observe that the stream has been partially evaluated. If the computation evaluates to a yield return statement the following case distinction is made. If the element type is a reference type, and the value v is null, the computation continues and the null reference (e.g., the empty stream) is dropped.",{"@attributes":{"id":"p-0306","num":"0403"},"maths":{"@attributes":{"id":"MATH-US-00061","num":"00061"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":[{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"r"}},{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":",","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["R","\u2032"]},"mo":",","mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"}}}}}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":"H","mo":",","msup":{"mi":["R","\u2032"]}}},{"mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"},"mo":"->","mrow":{"mo":"*","mrow":{"mo":["(",")"],"mrow":{"msup":[{"mi":["H","\u2032"]},{"mi":["R","\u2033"]}],"mo":","}}}},{"mrow":{"mi":["yield","return","new","sequence"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":[{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c1","\u2032"]}},{"mo":["(",")"],"mrow":{"mi":["\u03c1","null"],"mo":","}}]},"mo":";","mover":{"msup":{"mi":["s","\u2033"]},"mi":"_"}}],"mo":[",",","]}}}]},{"mtr":[{"mtd":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mi":["foreach","s"],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mi":["\u03c4","x","in","r"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}},{"mo":["(",")"],"mrow":{"mrow":{"msup":{"mi":["H","\u2032"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":"r","mo":"\u21a6","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":",","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["R","\u2033"]},"mo":",","mover":{"msup":{"mi":["s","\u2033"]},"mi":"_"}}}}}}}},"mo":",","mi":"R"}}],"mo":"->"}],"mo":[",",","]}}},{"mtd":{"mrow":{"mi":["foreach","s"],"mo":["\u2062","\u2062"],"mrow":{"mo":["(",")"],"mrow":{"mi":["\u03c4","x","in","r"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}}}}]}]}}}},"If the element type is not a stream and the value v is not null, the value v is the next stream element to be returned; as a consequence, v is bound to the iteration variable and the foreach loop is unrolled once.",{"@attributes":{"id":"p-0308","num":"0405"},"maths":{"@attributes":{"id":"MATH-US-00062","num":"00062"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":[{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"r"}},{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":",","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["R","\u2032"]},"mo":",","mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"}}}}}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":"H","mo":",","msup":{"mi":["R","\u2032"]}}},{"mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"},"mo":"->","mrow":{"mo":"*","mrow":{"mo":["(",")"],"mrow":{"msup":[{"mi":["H","\u2032"]},{"mi":["R","\u2033"]}],"mo":","}}}}],"mo":[",",","]}}},{"mtd":{"mrow":{"mrow":[{"mi":["yield","return","new","sequence"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":[{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2033"]}},{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2033"]},"mo":",","mi":"v"}}]},{"mrow":{"mover":{"msup":{"mi":["s","\u2033"]},"mi":"_"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"v"},"mo":"\u2260","mi":"null"}],"mo":";"}}}]},{"mtr":[{"mtd":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mi":["foreach","s"],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mi":["\u03c4","x","in","r"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}},{"mo":["(",")"],"mrow":{"mrow":{"msup":{"mi":["H","\u2032"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":"r","mo":"\u21a6","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":",","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["R","\u2033"]},"mo":",","mover":{"msup":{"mi":["s","\u2033"]},"mi":"_"}}}}}}}},"mo":",","mi":"R"}}],"mo":"->"},{"mrow":{"mo":["{","}"],"mrow":{"mrow":{"mi":["\u03c4","x","in","v"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":";","mi":"s"}},"mo":";"}],"mo":[",",","]}}},{"mtd":{"mrow":{"mi":["foreach","s"],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mi":["\u03c4","x","in","r"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}}}}]}]}}}},"If the element type is a nested stream, the value is evaluated first (first foreach loop) and only then evaluation continues (second foreach loop). This unfolding of the nested stream is the essence of lazy flattening.",{"@attributes":{"id":"p-0310","num":"0407"},"maths":{"@attributes":{"id":"MATH-US-00063","num":"00063"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mtable":[{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"H","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"r"}},{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":",","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["R","\u2032"]},"mo":",","mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"}}}}}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":"H","mo":",","msup":{"mi":["R","\u2032"]}}},{"mover":{"msup":{"mi":["s","\u2032"]},"mi":"_"},"mo":"->","mrow":{"mo":"*","mrow":{"mo":["(",")"],"mrow":{"msup":[{"mi":["H","\u2032"]},{"mi":["R","\u2033"]}],"mo":","}}}}],"mo":[",",","]}}},{"mtd":{"mrow":{"mrow":{"mi":["yield","return","new","sequence"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":[{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2033"]}},{"mo":["(",")"],"mrow":{"mrow":{"mi":"sequence","mo":"\u2062","mrow":{"mo":["\u2329","\u232a"],"msup":{"mi":["\u03c4","\u2033"]}}},"mo":",","mi":"v"}}]},"mo":";","mover":{"msup":{"mi":["s","\u2033"]},"mi":"_"}}}}]},{"mtr":[{"mtd":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"mi":["H","R"],"mo":","}},{"mrow":[{"mi":["foreach","s"],"mo":["\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mi":["\u03c4","x","in","r"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}},{"mo":["(",")"],"mrow":{"mrow":{"msup":{"mi":["H","\u2032"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":"r","mo":"\u21a6","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["\u03c4","\u2032"]},"mo":",","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":["R","\u2033"]},"mo":",","mover":{"msup":{"mi":["s","\u2033"]},"mi":"_"}}}}}}}},"mo":",","mi":"R"}}],"mo":"->"}],"mo":[",",","]}}},{"mtd":{"mrow":{"mrow":{"mo":["{","}"],"mrow":{"mrow":{"mi":"foreach","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["\u03c4","x","in","v"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}},"mo":"\u2062","mi":"s"}},"mo":";"}}},{"mtd":{"mrow":{"mrow":{"mi":"foreach","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["\u03c4","x","in","r"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}}},"mo":"\u2062","mi":"s"}}}]}]}}}},"Executing a program simply executes the designated entry-point method body.","Extensions to InnerXen","In this section, further details of features of the full Xen language are described. One feature is updating, which could be considered part of the core of Xen.","XML literals. The full Xen language supports XML literals as syntactic sugar for serialized object graphs. For example, an instance can be created of the Address type from the introduction using the following literal:\n\n","The Xen compiler contains a validating XML parser that deserializes the above literal into normal constructor calls.","XML literals can also contain typed holes, much as in XQuery, that allows embedding of expressions to compute part of the literal. This is especially convenient for generating streams. This requires a more complicated form of subtyping for the validator.","Path expressions and comprehensions. The full Xen language adds several more powerful query expressions to those already described. For instance, filter expressions e[e\u2032] are syntactic sugar for the following apply-to-all expression: e. {if (e\u2032) yield return it;}. Wildcard selection e.* enumerates all top-level members of a struct and is syntactic sugar for the expression ({ }).","Since labels can be duplicated in tuple types and discriminated unions, the full language also allows type-based selection. For example, given the earlier example tuple type struct {int a; struct {string a;};} x the string member a can be selected by writing x.string::m.","Transitive queries are also supported in the full Xen language: the expression e . . . \u03c4::m selects all members m of type \u03c4 that are transitively reachable from e. Transitive queries are inspired by the XPath descendant axis.","In addition to path-like queries, the full Xen language also supports comprehensions using SQL select expressions. Comprehensions are convenient when joining data from different sources. For example, one of the XQuery use-cases asks to list the title prices for each book that is sold by both booksellers A and BN. Using a select statement and XML-literals, this query can be written in full Xen as follows:","A-BN=","select\n\n","from book a in A.book, book bn in BN.book","where a.title==bn.title;","Note the use of XML placeholders {a.title} and {bn.price}: when this code is evaluated new titles and new prices are computed from the bindings of the select-from-where clause.","Updates. So far it has been shown how to query values using generalized member access, but as Xen is an imperative language, one would expect to be able to perform updates on values as well. Properly formalizing the notion of updates on semi-structured data using path-expressions however, is not completely trivial.","Updates on tuple types are relatively straight forward, but care needs to be taken of the fact that labels can be duplicated. For example, the assignment x.a=y below","struct{int a; struct{string a;};} x;","struct{int; string a;} y=new(47, \u201c11\u201d);","x.a=y;","needs to be broken into several smaller assignments to each individual occurrence of member a as in the block expression below:","({x[0]=y[0]; x[1] [0]=y[1]; return y;})","It is less clear how and if updates have to be lifted over streams. For example, given a stream bs of type sequence<Button>, should the rhs of the lifted update bs.Text=ts be a stream of which each element is then assigned to the corresponding element of the stream or a single value that is assigned to each of the elements in the stream. Since no choice is obviously better, it is left to the programmer and not lift updates over streams.","Updates can be defined on discriminated unions. For example, given the variable x of type either{string; Person; int;} where type Person has a field Age, the expression x.Age=40 can be used to update the Age field of x. If x contains a string or an int, then the update has no effect.","To formalize properly updates, one needs to distinguish between 1-values and r-values.","All groups. Consider an ordinary class such as Point that has normal fields instead of a single content type.\n\n","Fields of ordinary classes are modeled using intersection types or XSD all groups. That is, the class Point below is shorthand for the following content class\n\n","Whereas discriminated unions either{ } could be considered as type-indexed sums with the guarantee that e was \u03c4 is true for exactly one of the types \u03c4 in , all groups all { } can be considered as type-indexed records where the invariant is that e was \u03c4 is true for all types \u03c4 in . For values e of type all { }, the special member e.\u03c4 retrieves the member of type  from the all group.","Besides for modeling normal classes, all groups can also be used to formalize the notion of method groups that are informally used in the C# and Java language specifications. All groups are interesting by themselves as a program structuring principle.","The problem of manipulating relational and semi-structured data within common object-oriented languages have been described. A series of elegant extensions to C# are described that provide type-safe, first-class access to these forms of data. A core language, called InnerXen, has been described and have formalized both its type system and operational semantics.","In another implementation of the disclosed Xen\/InnerXen language, it is within contemplation of the present invention that a Xen compiler can be been built that implements a superset of the InnerXen fragment described herein. For example, a richer set of implicit conversions (e.g., unrestricted covariance for streams and tuple types) and a richer set of type including first class functions and intersection types can be considered. Moreover, Xen can be combined with the polyphonic extensions to C#.","Referring now to , there is illustrated a block diagram of a computer operable to execute the disclosed architecture. In order to provide additional context for various aspects of the present invention,  and the following discussion are intended to provide a brief, general description of a suitable computing environment  in which the various aspects of the present invention can be implemented. While the invention has been described above in the general context of computer-executable instructions that may run on one or more computers, those skilled in the art will recognize that the invention also can be implemented in combination with other program modules and\/or as a combination of hardware and software.","Generally, program modules include routines, programs, components, data structures, etc., that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the inventive methods can be practiced with other computer system configurations, including single-processor or multiprocessor computer systems, minicomputers, mainframe computers, as well as personal computers, hand-held computing devices, microprocessor-based or programmable consumer electronics, and the like, each of which can be operatively coupled to one or more associated devices.","The illustrated aspects of the invention may also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules can be located in both local and remote memory storage devices.","A computer typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media can comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital video disk (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by the computer.","Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media.","With reference again to , there is illustrated an exemplary environment  for implementing various aspects of the invention that includes a computer , the computer  including a processing unit , a system memory  and a system bus . The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  can be any of various commercially available processors. Dual microprocessors and other multi-processor architectures may also be employed as the processing unit .","The system bus  can be any of several types of bus structure that may further interconnect to a memory bus (with or without a memory controller), a peripheral bus, and a local bus using any of a variety of commercially available bus architectures. The system memory  includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS) is stored in a non-volatile memory  such as ROM, EPROM, EEPROM, which BIOS contains the basic routines that help to transfer information between elements within the computer , such as during start-up. The RAM  can also include a high-speed RAM such as static RAM for caching data.","The computer  further includes an internal hard disk drive (HDD)  (e.g., EIDE, SATA), which internal hard disk drive  may also be configured for external use in a suitable chassis (not shown), a magnetic floppy disk drive (FDD) , (e.g., to read from or write to a removable diskette ) and an optical disk drive , (e.g., reading a CD-ROM disk  or, to read from or write to other high capacity optical media such as the DVD). The hard disk drive , magnetic disk drive  and optical disk drive  can be connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface  and an optical drive interface , respectively. The interface  for external drive implementations includes at least one or both of Universal Serial Bus (USB) and IEEE 1394 interface technologies.","The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, and so forth. For the computer , the drives and media accommodate the storage of any data in a suitable digital format. Although the description of computer-readable media above refers to a HDD, a removable magnetic diskette, and a removable optical media such as a CD or DVD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as zip drives, magnetic cassettes, flash memory cards, cartridges, and the like, may also be used in the exemplary operating environment, and further, that any such media may contain computer-executable instructions for performing the methods of the present invention.","A number of program modules can be stored in the drives and RAM , including an operating system , one or more application programs , other program modules  and program data . All or portions of the operating system, applications, modules, and\/or data can also be cached in the RAM .","It is appreciated that the present invention can be implemented with various commercially available operating systems or combinations of operating systems.","A user can enter commands and information into the computer  through one or more wired\/wireless input devices, e.g., a keyboard  and a pointing device, such as a mouse . Other input devices (not shown) may include a microphone, an IR remote control, a joystick, a game pad, a stylus pen, touch screen, or the like. These and other input devices are often connected to the processing unit  through an input device interface  that is coupled to the system bus , but can be connected by other interfaces, such as a parallel port, an IEEE 1394 serial port, a game port, a USB port, an IR interface, etc.","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , a computer typically includes other peripheral output devices (not shown), such as speakers, printers etc.","The computer  may operate in a networked environment using logical connections via wired and\/or wireless communications to one or more remote computers, such as a remote computer(s) . The remote computer(s)  can be a workstation, a server computer, a router, a personal computer, portable computer, microprocessor-based entertainment appliance, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although, for purposes of brevity, only a memory storage device  is illustrated. The logical connections depicted include wired\/wireless connectivity to a local area network (LAN)  and\/or larger networks, e.g., a wide area network (WAN) . Such LAN and WAN networking environments are commonplace in offices, and companies, and facilitate enterprise-wide computer networks, such as intranets, all of which may connect to a global communication network, e.g., the Internet.","When used in a LAN networking environment, the computer  is connected to the local network  through a wired and\/or wireless communication network interface or adapter . The adaptor  may facilitate wired or wireless communication to the LAN , which may also include a wireless access point disposed thereon for communicating with the wireless adaptor . When used in a WAN networking environment, the computer  can include a modem , or is connected to a communications server on the LAN, or has other means for establishing communications over the WAN , such as by way of the Internet. The modem , which can be internal or external and a wired or wireless device, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, can be stored in the remote memory\/storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.","The computer  is operable to communicate with any wireless devices or entities operatively disposed in wireless communication, e.g., a printer, scanner, desktop and\/or portable computer, portable data assistant, communications satellite, any piece of equipment or location associated with a wirelessly detectable tag (e.g., a kiosk, news stand, restroom), and telephone. This includes at least Wi-Fi and Bluetooth\u2122 wireless technologies. Thus, the communication can be a predefined structure as with conventional network or simply an ad hoc communication between at least two devices.","Wi-Fi, or Wireless Fidelity, allows connection to the Internet from a couch at home, a bed in a hotel room or a conference room at work, without wires. Wi-Fi is a wireless technology like a cell phone that enables such devices, e.g., computers, to send and receive data indoors and out; anywhere within the range of a base station. Wi-Fi networks use radio technologies called IEEE 802.11 (a, b, g, etc.) to provide secure, reliable, fast wireless connectivity. A Wi-Fi network can be used to connect computers to each other, to the Internet, and to wired networks (which use IEEE 802.3 or Ethernet). Wi-Fi networks operate in the unlicensed 2.4 and 5 GHz radio bands, with an 11 Mbps (802.11a) or 54 Mbps (802.11b) data rate or with products that contain both bands (dual band), so the networks can provide real-world performance similar to the basic 10BaseT wired Ethernet networks used in many offices.","Referring now to , there is illustrated a schematic block diagram of an exemplary computing environment  in accordance with the present invention. The system  includes one or more client(s) . The client(s)  can be hardware and\/or software (e.g., threads, processes, computing devices). The client(s)  can house cookie(s) and\/or associated contextual information by employing the present invention, for example. The system  also includes one or more server(s) . The server(s)  can also be hardware and\/or software (e.g., threads, processes, computing devices). The servers  can house threads to perform transformations by employing the present invention, for example. One possible communication between a client  and a server  can be in the form of a data packet adapted to be transmitted between two or more computer processes. The data packet may include a cookie and\/or associated contextual information, for example. The system  includes a communication framework  (e.g., a global communication network such as the Internet) that can be employed to facilitate communications between the client(s)  and the server(s) .","Communications can be facilitated via a wired (including optical fiber) and\/or wireless technology. The client(s)  are operatively connected to one or more client data store(s)  that can be employed to store information local to the client(s)  (e.g., cookie(s) and\/or associated contextual information). Similarly, the server(s)  are operatively connected to one or more server data store(s)  that can be employed to store information local to the servers .","What has been described above includes examples of the present invention. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the present invention, but one of ordinary skill in the art may recognize that many further combinations and permutations of the present invention are possible. Accordingly, the present invention is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as \u201ccomprising\u201d is interpreted when employed as a transitional word in a claim."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0029","num":"0036"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0030","num":"0037"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0031","num":"0038"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0032","num":"0039"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0033","num":"0040"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0034","num":"0041"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0035","num":"0042"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0036","num":"0043"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0037","num":"0044"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0038","num":"0045"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0039","num":"0046"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0040","num":"0047"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0041","num":"0048"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0042","num":"0049"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
