---
title: Visually indicating problems found during programmatic analysis of a graphical program
abstract: A system and method for visually indicating one or more problems in a graphical program. The graphical program may be programmatically analyzed to discover a problem (or potential problem) in the graphical program. The problem found during the programmatic analysis of the graphical program may then be visually indicated on a display device. Visually indicating the problem may comprise visually indicating one or more objects in the graphical program to which the problem corresponds. Visually indicating the graphical program object(s) may comprise displaying information or altering the appearance of the object(s) in order to call the user's attention to the object(s).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07650574&OS=07650574&RS=07650574
owner: National Instruments Corporation
number: 07650574
owner_city: Austin
owner_country: US
publication_date: 20040511
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","DESCRIPTION OF THE RELATED ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention relates to the field of graphical programming, and more particularly to a system and method for visually indicating problems found during programmatic analysis of a graphical program.","Traditionally, high level text-based programming languages have been used by programmers in writing application programs. Many different high level text-based programming languages exist, including BASIC, C, Java, FORTRAN, Pascal, COBOL, ADA, APL, etc. Programs written in these high level text-based languages are translated to the machine language level by translators known as compilers or interpreters. The high level text-based programming languages in this level, as well as the assembly language level, are referred to herein as text-based programming environments.","Increasingly, computers are required to be used and programmed by those who are not highly trained in computer programming techniques. When traditional text-based programming environments are used, the user's programming skills and ability to interact with the computer system often become a limiting factor in the achievement of optimal utilization of the computer system.","There are numerous subtle complexities which a user must master before he can efficiently program a computer system in a text-based environment. The task of programming a computer system to model or implement a process often is further complicated by the fact that a sequence of mathematical formulas, steps or other procedures customarily used to conceptually model a process often does not closely correspond to the traditional text-based programming techniques used to program a computer system to model such a process. In other words, the requirement that a user program in a text-based programming environment places a level of abstraction between the user's conceptualization of the solution and the implementation of a method that accomplishes this solution in a computer program. Thus, a user often must substantially master different skills in order to both conceptualize a problem or process and then to program a computer to implement a solution to the problem or process. Since a user often is not fully proficient in techniques for programming a computer system in a text-based environment to implement his solution, the efficiency with which the computer system can be utilized often is reduced.","To overcome the above shortcomings, various graphical programming environments now exist which allow a user to construct a graphical program or graphical diagram, also referred to as a block diagram. U.S. Pat. Nos. 4,901,221; 4,914,568; 5,291,587; 5,301,301; and 5,301,336; among others, to Kodosky et al disclose a graphical programming environment which enables a user to easily and intuitively create a graphical program. Graphical programming environments such as that disclosed in Kodosky et al can be considered a higher and more intuitive way in which to interact with a computer. A graphically based programming environment can be represented at a level above text-based high level programming languages such as C, Basic, Java, etc.","A user may assemble a graphical program by selecting various icons or nodes which represent desired functionality, and then connecting the nodes together to create the program. The nodes or icons may be connected by lines representing data flow between the nodes, control flow, or execution flow. Thus the block diagram may include a plurality of interconnected icons such that the diagram created graphically displays a procedure or method for accomplishing a certain result, such as manipulating one or more input variables and\/or producing one or more output variables. In response to the user constructing a diagram or graphical program using the block diagram editor, data structures and\/or program instructions may be automatically constructed which characterize an execution procedure that corresponds to the displayed procedure. The graphical program may be compiled or interpreted by a computer.","A graphical program may have a graphical user interface. For example, in creating a graphical program, a user may create a front panel or user interface panel. The front panel may include various graphical user interface elements or front panel objects, such as user interface controls and\/or indicators, that represent or display the respective input and output that will be used by the graphical program, and may include other icons which represent devices being controlled.","Thus, graphical programming has become a powerful tool available to programmers. Graphical programming development environments such as the National Instruments LabVIEW product have become very popular. Tools such as LabVIEW have greatly increased the productivity of programmers, and increasing numbers of programmers are using graphical programming environments to develop their software applications. In particular, graphical programming tools are being used for test and measurement, data acquisition, process control, man machine interface (MMI), supervisory control and data acquisition (SCADA) applications, modeling, simulation, image processing\/machine vision applications, and motion control, among others.","Modem graphical programming development environments allow users to create large and complex graphical programs. It can sometimes be difficult for users to evaluate a graphical program simply by looking at its block diagram. Thus, it may be desirable to enable graphical programs to be programmatically analyzed in various ways, e.g., to provide the user with information about the graphical program or inform the user of potential problems in the graphical program.","One embodiment of the present invention comprises a system and method for visually indicating one or more problems in a graphical program. The graphical program may be stored in a memory, and the graphical program may be programmatically analyzed to discover one or more problems (or potential problems) in the graphical program. Programmatically analyzing the graphical program may comprise programmatically examining or analyzing properties of one or more of objects in the graphical program, where the one or more problems are discovered based on the properties of the one or more objects. In various embodiments, the graphical program may be programmatically analyzed based on any of various kinds of properties of objects in the graphical program.","In various embodiments, the method may be operable to discover any of various kinds of problems or potential problems in the graphical program. For example, in one embodiment the one or more problems may include problems (or potential problems) or factors that affect performance of the graphical program. As another example, the one or more problems may include errors or potential errors in the graphical program. As another example, the one or more problems may include problems found in adherence to style or design standards for the graphical program, e.g., programming style standards or user interface design standards. As another example, the one or more problems may be related to documentation for the graphical program. Additional exemplary types of problems that may be found during programmatic analysis of a graphical program are described below.","Information listing the one or more problems (or potential problems) discovered during the programmatic analysis of the graphical program may be displayed on a display device. Displaying the information listing the one or more problems may include displaying text information listing the one or more problems, e.g., text information specifying names or descriptions of the one or more problems.","User input selecting a first problem (or potential problem) from the one or more listed problems (or potential problems) may be received. In various embodiments, user input of any kind may be received to select the first problem, e.g., depending on the manner in which the one or more problems are listed. In response, the first problem in the graphical program may be visually indicated on a display device. Visually indicating the first problem may comprise displaying graphical information to visually indicate the problem. In one embodiment text information regarding the first problem may also be displayed. In one embodiment the first problem may comprise a problem in the block diagram of the graphical program. In this embodiment, visually indicating the first problem may comprise displaying the block diagram of the graphical program and displaying information to visually indicate the problem in the block diagram. In another embodiment the first problem may comprise a problem in the graphical user interface of the graphical program. In this embodiment, visually indicating the first problem may comprise displaying the graphical user interface of the graphical program and displaying information to visually indicate the problem in the graphical user interface of the graphical program.","The graphical program may include a plurality of objects, such as block diagram objects and\/or graphical user interface objects. In one embodiment the first problem (or potential problem) found during the programmatic analysis of the graphical program may correspond to an object in the graphical program. Thus, visually indicating the first problem may comprise visually indicating the object to which the first problem corresponds. For example, in one embodiment the first problem may correspond to an object in the block diagram of the graphical program, such as a node or wire. Thus, the first problem may be visually indicated by displaying the block diagram and visually indicating the node or wire (or other block diagram object) in the block diagram. In another embodiment the first problem may correspond to an object in the graphical user interface of the graphical program, such as a control or indicator. Thus, the first problem may be visually indicated by displaying the graphical user interface and visually indicating the control or indicator (or other graphical user interface object) in the graphical user interface of the graphical program.","In another embodiment the first problem found during the programmatic analysis of the graphical program may correspond to multiple objects in the graphical program or may correspond to a portion of the graphical program but not to a particular object. In this embodiment, visually indicating the first problem may comprise visually indicating the portion of the graphical program or visually indicating multiple objects in the graphical program.","Visually indicating a graphical program object or graphical program portion that corresponds to the first problem found during analysis of the graphical program may comprise displaying information or altering the appearance of the graphical program object or portion in any of various ways in order to call the user's attention to that object or portion of the graphical program. For example, one or more nodes, wires, or other objects in a block diagram of the graphical program may be visually indicated by changing their usual color, changing the color of the background behind them, drawing a border around them, causing them to blink, or providing any of various other kinds of visual cues to draw the user's attention to these objects or cause the objects to stand out from other objects in the block diagram. Graphical user interface objects in a graphical user interface of the graphical program may be highlighted in a similar manner.","Where the programmatic analysis performed on the graphical program discovers a plurality of problems (or potential problems) in the graphical program, the method may further comprise receiving user input selecting a second problem from the one or more listed problems. In response, the second problem in the graphical program may be visually indicated on the display device, similarly as described above. Other problems found during the programmatic analysis of the graphical program may be selected and visually indicated in a similar manner. For example, as the user selects each problem, the appropriate portion of the graphical program may be scrolled into view, and the object(s) or graphical program portion that corresponds to the problem may be visually indicated as described above. In another embodiment, the one or more problems discovered during the programmatic analysis of the graphical program may be listed one at a time so that the user can simply advance from one problem to the next but may not be able to see all the problems listed at once or select a problem randomly.","While the invention is susceptible to various modifications and alternative forms, specific embodiments thereof are shown by way of example in the drawings and are herein described in detail. It should be understood, however, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims.","Incorporation by Reference","The following references are hereby incorporated by reference in their entirety as though fully and completely set forth herein:","U.S. Pat. No. 4,914,568 titled \u201cGraphical System for Modeling a Process and Associated Method,\u201d issued on Apr. 3, 1990.","U.S. Pat. No. 5,481,741 titled \u201cMethod and Apparatus for Providing Attribute Nodes in a Graphical Data Flow Environment\u201d.","U.S. Pat. No. 6,173,438 titled \u201cEmbedded Graphical Programming System\u201d filed Aug. 18, 1997.","U.S. Pat. No. 6,219,628 titled \u201cSystem and Method for Configuring an Instrument to Perform Measurement Functions Utilizing Conversion of Graphical Programs into Hardware Implementations,\u201d filed Aug. 18, 1997.","U.S. Patent Application Publication No. 20010020291 (Ser. No. 09\/745,023) titled \u201cSystem and Method for Programmatically Generating a Graphical Program in Response to Program Information,\u201d filed Dec. 20, 2000.","Terms","The following is a glossary of terms used in the present application:","Memory Medium\u2014Any of various types of memory devices or storage devices. The term \u201cmemory medium\u201d is intended to include an installation medium, e.g., a CD-ROM, floppy disks 104, or tape device; a computer system memory or random access memory such as DRAM, DDR RAM, SRAM, EDO RAM, Rambus RAM, etc.; or a non-volatilem memory such as a magnetic media, e.g., a hard drive, or optical storage. The memory medium may comprise other types of memory as well, or combinations thereof. In addition, the memory medium may be located in a first computer in which the programs are executed, or may be located in a second different computer which connects to the first computer over a network, such as the Internet. In the latter instance, the second computer may provide program instructions to the first computer for execution. The term \u201cmemory medium\u201d may include two or more memory mediums which may reside in different locations, e.g., in different computers that are connected over a network.","Carrier Medium\u2014a memory medium as described above, as well as signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as a bus, network and\/or a wireless link.","Programmable Hardware Element\u2014includes various types of programmable hardware, reconfigurable hardware, programmable logic, or field-programmable devices (FPDs), such as one or more FPGAs (Field Programmable Gate Arrays), or one or more PLDs (Programmable Logic Devices), such as one or more Simple PLDs (SPLDs) or one or more Complex PLDs (CPLDs), or other types of programmable hardware. A programmable hardware element may also be referred to as \u201creconfigurable logic\u201d.","Medium\u2014includes one or more of a memory medium, carrier medium, and\/or programmable hardware element; encompasses various types of mediums that can either store program instructions\/data structures or can be configured with a hardware configuration program.","Program\u2014the term \u201cprogram\u201d is intended to have the full breadth of its ordinary meaning. The term \u201cprogram\u201d includes 1) a software program which may be stored in a memory and is executable by a processor or 2) a hardware configuration program useable for configuring a programmable hardware element.","Software Program\u2014the term \u201csoftware program\u201d is intended to have the full breadth of its ordinary meaning, and includes any type of program instructions, code, script and\/or data, or combinations thereof, that may be stored in a memory medium and executed by a processor. Exemplary software programs include programs written in text-based programming languages, such as C, C++, Pascal, Fortran, Cobol, Java, assembly language, etc.; graphical programs (programs written in graphical programming languages); assembly language programs; programs that have been compiled to machine language; scripts; and other types of executable software. A software program may comprise two or more software programs that interoperate in some manner.","Hardware Configuration Program\u2014a program, e.g., a netlist or bit file, that can be used to program or configure a programmable hardware element.","Graphical Program\u2014A program comprising a plurality of interconnected nodes or icons, wherein the plurality of interconnected nodes or icons visually indicate functionality of the program.","The following provides examples of various aspects of graphical programs. The following examples and discussion are not intended to limit the above definition of graphical program, but rather provide examples of what the term \u201cgraphical program\u201d encompasses:","The nodes in a graphical program may be connected in one or more of a data flow, control flow, and\/or execution flow format. The nodes may also be connected in a \u201csignal flow\u201d format, which is a subset of data flow.","Exemplary graphical programming development environments that may be used to create graphical programs include LabVIEW, DasyLab, DiaDem and Matrixx\/SystemBuild from National Instruments, Simulink from the MathWorks, VEE from Agilent, WiT from Coreco, Vision Program Manager from PPT Vision, SoftWIRE from Measurement Computing, Sanscript from Northwoods Software, Khoros from Khoral Research, SnapMaster from HEM Data, VisSim from Visual Solutions, ObjectBench by SES (Scientific and Engineering Software), and VisiDAQ from Advantech, among others.","The term \u201cgraphical program\u201d includes models or block diagrams created in graphical modeling environments, wherein the model or block diagram comprises interconnected nodes or icons that visually indicate operation of the model or block diagram; exemplary graphical modeling environments include Simulink, SystemBuild, VisSim, Hypersignal Block Diagram, etc.","A graphical program may be represented in the memory of the computer system as data structures and\/or program instructions. The graphical program, e.g., these data structures and\/or program instructions, may be compiled or interpreted to produce machine language that accomplishes the desired method or process as shown in the graphical program.","Input data to a graphical program may be received from any of various sources, such as from a device, unit under test, a process being measured or controlled, another computer program, a database, or from a file. Also, a user may input data to a graphical program or virtual instrument using a graphical user interface, e.g., a front panel.","A graphical program may optionally have a GUI associated with the graphical program. In this case, the plurality of interconnected nodes are often referred to as the block diagram portion of the graphical program.","Node\u2014In the context of a graphical program, an element that may be included in a graphical program. A node may have an associated icon that represents the node in the graphical program, as well as underlying code or data that implements functionality of the node. Exemplary nodes include function nodes, terminal nodes, structure nodes, etc.","Data Flow Graphical Program (or Data Flow Diagram)\u2014A graphical program or diagram comprising a plurality of interconnected nodes, wherein the connections between the nodes indicate that data produced by one node is used by another node.","Graphical User Interface\u2014this term is intended to have the full breadth of its ordinary meaning. The term \u201cGraphical User Interface\u201d is often abbreviated to \u201cGUI\u201d. A GUI may comprise only one or more input GUI elements, only one or more output GUI elements, or both input and output GUI elements.","The following provides examples of various aspects of GUIs. The following examples and discussion are not intended to limit the ordinary meaning of GUI, but rather provide examples of what the term \u201cgraphical user interface\u201d encompasses:","A GUI may comprise a single window having one or more GUI Elements, or may comprise a plurality of individual GUI Elements (or individual windows each having one or more GUI Elements), wherein the individual GUI Elements or windows may optionally be tiled together.","A GUI may be associated with a graphical program. In this instance, various mechanisms may be used to connect GUI Elements in the GUI with nodes in the graphical program. For example, when Input Controls and Output Indicators are created in the GUI, corresponding nodes (e.g., terminals) may be automatically created in the graphical program or block diagram. Alternatively, the user can place terminal nodes in the block diagram which may cause the display of corresponding GUI Elements front panel objects in the GUI, either at edit time or later at run time. As another example, the GUI may comprise GUI Elements embedded in the block diagram portion of the graphical program.","Front Panel\u2014A Graphical User Interface that includes input controls and output indicators, and which enables a user to interactively control or manipulate the input being provided to a program, and view output of the program, while the program is executing.","A front panel is a type of GUI. A front panel may be associated with a graphical program as described above.","In an instrumentation application, the front panel can be analogized to the front panel of an instrument. In an industrial automation application the front panel can be analogized to the MMI (Man Machine Interface) of a device. The user may adjust the controls on the front panel to affect the input and view the output on the respective indicators.","Graphical User Interface Element\u2014an element of a graphical user interface, such as for providing input or displaying output. Exemplary graphical user interface elements comprise input controls and output indicators","Input Control\u2014a graphical user interface element for providing user input to a program. Exemplary input controls comprise dials, knobs, sliders, input text boxes, etc.","Output Indicator\u2014a graphical user interface element for displaying output from a program. Exemplary output indicators include charts, graphs, gauges, output text boxes, numeric displays, etc. An output indicator is sometimes referred to as an \u201coutput control\u201d.","Computer System\u2014any of various types of computing or processing systems, including a personal computer system (PC), mainframe computer system, workstation, network appliance, Internet appliance, personal digital assistant (PDA), television system, grid computing system, or other device or combinations of devices. In general, the term \u201ccomputer system\u201d can be broadly defined to encompass any device (or combination of devices) having at least one processor that executes instructions from a memory medium.","Measurement Device\u2014includes instruments, data acquisition devices, smart sensors, and any of various types of devices that are operable to acquire and\/or store data. A measurement device may also optionally be further operable to analyze or process the acquired or stored data. Examples of a measurement device include an instrument, such as a traditional stand-alone \u201cbox\u201d instrument, a computer-based instrument (instrument on a card) or external instrument, a data acquisition card, a device external to a computer that operates similarly to a data acquisition card, a smart sensor, one or more DAQ or measurement cards or modules in a chassis, an image acquisition device, such as an image acquisition (or machine vision) card (also called a video capture board) or smart camera, a motion control device, a robot having machine vision, and other similar types of devices. Exemplary \u201cstand-alone\u201d instruments include oscilloscopes, multimeters, signal analyzers, arbitrary waveform generators, spectroscopes, and similar measurement, test, or automation instruments.","A measurement device may be further operable to perform control functions, e.g., in response to analysis of the acquired or stored data. For example, the measurement device may send a control signal to an external system, such as a motion control system or to a sensor, in response to particular data. A measurement device may also be operable to perform automation functions, i.e., may receive and analyze data, and issue automation control signals in response.","FIG. \u2014Computer System",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 1","b":"82"},"In various embodiments, the graphical program that is programmatically analyzed may comprise any type of graphical program, e.g., may be created using any graphical programming development environment or graphical programming language, and may perform any function. The computer system  may programmatically analyze the graphical program for any of various reasons. For example, it may be desirable to programmatically analyze a graphical program to determine factors that limit or affect the graphical program's performance, to discover errors or potential errors in the graphical program, to determine information regarding the user interface design of the graphical program, etc. In one embodiment, results of the programmatic analysis may be displayed to the user or stored, e.g., in a report file or database.","In one embodiment, a graphical program may be programmatically analyzed to determine whether the graphical program adheres to certain design or style standards. For example, certain programming conventions may be recommended for graphical programs written using a particular graphical programming development environment, to promote maximum performance and reliability. As another example, an organization may set various programming standards to which graphical program developers are expected to adhere. Thus, in one embodiment the computer system  may be operable to programmatically analyze the graphical program and inform the user of any portions of the graphical program that do not adhere to the design or style standards. As described below, in one embodiment the user may be able to customize analysis criteria used by the computer system  to meet the user's particular analysis needs or reflect the user's particular design or style standards.","As described above, various elements may be associated with a graphical program, such as a block diagram, a graphical user interface, documentation or help, etc. The computer system  may be operable to programmatically analyze any of these elements for various purposes. For example, the block diagram may be programmatically analyzed for performance and style issues. For example, the block diagram may be analyzed for wiring style, loop and structure usage, unnecessary elements on the block diagram, etc.","As another example, the graphical user interface may be programmatically analyzed for user interface issues, e.g., design or style issues, as well as functional issues. For example, the graphical user interface may be analyzed for user interface control or indicator usage, font selection, the presence of labels, etc.","As another example, the graphical program may be analyzed for documentation issues. The graphical program may be analyzed for user documentation and\/or developer documentation. For example, the computer system  may be operable to check for comments on the graphical program's block diagram, analyze help text or descriptions for controls or graphical sub-programs, etc.","In one embodiment the computer system  may execute a program referred to herein as a graphical program analyzer. The graphical program analyzer may provide a user interface with which the user can interact to specify an analysis configuration. After programmatically analyzing one or more graphical programs according to the analysis configuration, the graphical program analyzer may be operable to display results of the analysis and\/or store the results, e.g., in a file or database. In one embodiment the graphical program analyzer may identify one or more problems or other issues in the graphical program and may be operable to display the graphical program portions associated with the problems or other issues. For example, in one embodiment, in response to a user request to display the graphical program portion associated with a particular block diagram problem or issue found during the analysis, the graphical program analyzer may open the block diagram of the graphical program and highlight or call the user's attention to one or more block diagram objects relevant to the problem or issue. One embodiment of a graphical program analyzer is described in detail below.","In another embodiment the computer system  may execute a user-created program operable to programmatically analyze a target graphical program. For example, instead of interacting with a graphical program analyzer tool as described above, the user may create a program operable to programmatically analyze one or more graphical programs. In one embodiment an application programming interface (API) for programmatically analyzing a graphical program may be provided. For example, the API may be associated with or provided by an application development environment (ADE) used to create the program that analyzes the target graphical program(s).","In various embodiments the user may be able to create any kind of program to analyze the target graphical program. In one embodiment the program that performs the analysis of the graphical program may comprise a text-based program, i.e., a program written in a text-based programming language such as C, C++, Visual C++, Java, Visual Basic, etc. For example, an API that includes various functions or methods related to performing programmatic analysis of a graphical program may be provided, and the user may include various function and method calls in the text-based program.","In another embodiment the program that performs the analysis of the graphical program may itself comprise a graphical program. For example, a graphical programming API that includes various function nodes or other graphical program objects related to performing programmatic analysis of a graphical program may be provided. The user may include various function nodes or objects from the API in a graphical program and may interconnect the function nodes with other nodes in the graphical program to visually indicate the desired analysis functionality. The user may also provide the graphical program with references to one or more target graphical programs so that the graphical program executes to programmatically analyze the target graphical program(s). The user may also include function nodes operable to perform functions such as displaying results from the programmatic analysis or generating a report based on the results. An exemplary graphical programming API for programmatically analyzing graphical programs is described in detail below.","Referring again to , the computer system  may include a display device. The computer system  may also include a memory medium(s) on which one or more computer programs or software components may be stored. In an embodiment in which a graphical program analyzer is used to analyze a graphical program, the memory medium may store the graphical program analyzer program and\/or the graphical programs to be analyzed. The user may interact with one or more GUI panels of the graphical program analyzer displayed on the display device. The graphical program analyzer may also display results of the programmatic analysis on the display device.","In an embodiment in which the user creates a program to programmatically analyze a graphical program, the memory medium may store an application development environment used to create or develop the user's program. In one embodiment the memory medium may store a graphical programming development environment used to create a graphical program operable to programmatically analyze a target graphical program. A user interface of the development environment may be displayed on the display device as the user's program is created.","In one embodiment the computer system  may execute the program created by the user. Thus, in one embodiment the user's program may be stored in the memory medium. The memory medium may also store the target graphical program(s) programmatically analyzed by the user's program. In one embodiment a GUI of the program created by the user may be displayed on the display device as it is executed. In another embodiment, the user may create the program on another computer system, and the program may then be transferred to the computer system  for execution, or the user may create the program on the computer system  and then transfer the program to another computer system for execution.","FIG. A\u2014Computer Network",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 1A","b":["82","90","82","84","90","82","90","84"]},"In one embodiment the computer system  may communicate with the computer system  to programmatically analyze one or more target graphical programs. For example, a graphical program analyzer or a program created by a user as described above may execute on the computer system  to programmatically analyze a target graphical program stored on the computer system  (or stored on a memory medium associated with the computer system ).","In another embodiment, the target graphical program(s) may be stored on a device  coupled to the computer system . For example, the device  may include a programmable hardware element and\/or may include a processor and memory medium which may execute a real time operating system. The graphical program analyzer or user-created program may execute on the computer system  to programmatically analyze the target graphical program(s) stored on the device .","Exemplary Systems","In one embodiment, graphical programs that are programmatically analyzed may be involved with performing test and\/or measurement functions; controlling and\/or modeling instrumentation or industrial automation hardware; modeling and simulation functions, e.g., modeling or simulating a device or product being developed or tested, etc. Exemplary test applications where the graphical program may be used include hardware-in-the-loop testing and rapid control prototyping, among others.","However, it is noted that graphical programs may be used for a plethora of applications and are not limited to the above applications. In other words, applications discussed herein are exemplary only. Thus, the system and method described herein may be utilized to programmatically analyze graphical programs used in any of various types of applications, including the control of other types of devices such as multimedia devices, video devices, audio devices, telephony devices, Internet devices, etc., as well as general purpose software applications such as word processing, spreadsheets, network control, network monitoring, financial applications, games, etc.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 2A","b":["100","100","82","82","82","150"]},"The one or more instruments may include a GPIB instrument  and associated GPIB interface card , a data acquisition board  and associated signal conditioning circuitry , a VXI instrument , a PXI instrument , a video device or camera  and associated image acquisition (or machine vision) card , a motion control device  and associated motion control interface card , and\/or one or more computer based instrument cards , among other types of devices. The computer system may couple to and operate with one or more of these instruments. The instruments may be coupled to a unit under test (UUT) or process , or may be coupled to receive field signals, typically generated by transducers. The system  may be used in a data acquisition and control application, in a test and measurement application, an image processing or machine vision application, a process control application, a man-machine interface application, a simulation application, or a hardware-in-the-loop validation application.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 2B","FIG. 2A","FIG. 2A"],"b":["160","160","100","160","82","82"]},"The computer  may execute a graphical program to communicate with the one or more devices to a process or device  to perform an automation function, such as MMI (Man Machine Interface), SCADA (Supervisory Control and Data Acquisition), portable or distributed data acquisition, process control, advanced analysis, or other control. In one embodiment, this graphical program may be programmatically analyzed as described above. For example, the graphical program may be programmatically analyzed to inform the user of efficiency or design problems or potential problems.","The one or more devices may include a data acquisition board  and associated signal conditioning circuitry , a PXI instrument , a video device  and associated image acquisition card , a motion control device  and associated motion control interface card , a fieldbus device  and associated fieldbus interface card , a PLC (Programmable Logic Controller) , a serial instrument  and associated serial interface card , or a distributed data acquisition system, such as the Fieldpoint system available from National Instruments, among other types of devices.","In the systems of  above, one or more of the various devices may couple to each other over a network, such as the Internet.","FIG. \u2014Computer System Block Diagram",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 3","FIGS. 1 and 1A","FIGS. 2A","FIG. 3"],"b":["82","90","82","2"]},"The computer may include at least one central processing unit or CPU (processor)  which is coupled to a processor or host bus . The CPU  may be any of various types, including an x86 processor, e.g., a Pentium class, a PowerPC processor, a CPU from the SPARC family of RISC processors, as well as others. A memory medium, typically comprising RAM and referred to as main memory,  is coupled to the host bus  by means of memory controller . The main memory  may store programs such as described above with reference to . The main memory may also store operating system software, as well as other software for operation of the computer system.","The host bus  may be coupled to an expansion or input\/output bus  by means of a bus controller  or bus bridge logic. The expansion bus  may be the PCI (Peripheral Component Interconnect) expansion bus, although other bus types can be used. The expansion bus  includes slots for various devices such as described above. The computer  further comprises a video display subsystem  and hard drive  coupled to the expansion bus .","In one embodiment a device  may also be connected to the computer. The device  may include a processor and memory which may execute a real time operating system. The device  may also or may instead comprise a programmable hardware element. In one embodiment a target graphical program to be programmatically analyzed may be deployed on the device . The deployed graphical program may take the form of graphical program instructions or data structures that directly represents the graphical program. Alternatively, the deployed graphical program may take the form of text code (e.g., C code) generated from the graphical program. As another example, the deployed graphical program may take the form of compiled code that has generated from either the graphical program or from text code that in turn was generated from the graphical program.","FIG. \u2014Visually Indicating Problems in a Graphical Program",{"@attributes":{"id":"p-0095","num":"0094"},"figref":["FIG. 4","FIG. 4"]},"In , a graphical program may be stored in a memory. The graphical program may include a plurality of objects. For example, the graphical program may include a block diagram that has a plurality of block diagram objects that visually represent functionality of the block diagram. For example, in one embodiment the block diagram may include a plurality of nodes that are interconnected by wires to indicate data flow among the nodes. In one embodiment the graphical program may also include a graphical user interface that has a plurality of graphical user interface objects. For example the graphical user interface may include one or more controls with which a user may interact to provide input to the graphical program and\/or may include one or more indicators operable to display output from the graphical program.","Storing the graphical program in the memory may comprise storing one or more data structures in the memory, where the one or more data structures represent the graphical program. The one or more data structures may comprise information specifying the plurality of objects in the graphical program. In various embodiments, the data structure(s) may be organized in any way.","In , the graphical program may be programmatically analyzed to discover one or more problems (or potential problems) in the graphical program. Programmatically analyzing the graphical program may comprise programmatically examining or analyzing properties of one or more of the objects in the graphical program, where the problem is discovered based on the properties of the one or more objects. In various embodiments, the graphical program may be programmatically analyzed based on any of various kinds of properties of objects in the graphical program. As one example, connections among nodes in the block diagram of the graphical program may be analyzed. For example, the block diagram of the graphical program may be traversed to determine whether it includes a node of type A that is connected to a node of type B. Such a connection may indicate a problem or a potential problem in the graphical program, and it may be desirable to inform the user of this problem.","In various embodiments, the method may be operable to discover any of various kinds of problems or potential problems in the graphical program. For example, in one embodiment the problem may comprise a problem (or potential problem) or factor that affects performance of the graphical program. As another example, the problem may comprise an error or potential error in the graphical program. As another example, the problem may comprise a problem found in adherence to style or design standards for the graphical program, e.g., programming style standards or user interface design standards. As another example, the problem may be related to documentation for the graphical program. Additional exemplary types of problems that may be found during programmatic analysis of a graphical program are described below.","In , information listing the one or more problems discovered during the programmatic analysis of the graphical program may be displayed on a display device. Displaying the information listing the one or more problems may include displaying text information listing the one or more problems, e.g., text information specifying names or descriptions of the one or more problems. In various embodiments, the one or more problems may be listed in any of various ways and may be listed together or separately. In one embodiment the one or more problems may be shown in a list, where the list may be displayed or organized in any of various ways. For example, problems in the list may be categorized in various ways or may be displayed in a hierarchical manner. As one example, programmatically analyzing the graphical program in  may comprise performing a plurality of tests on the graphical program, and the one or more problems may be displayed in a manner that associates each problem with the test in which the problem was discovered. In other embodiments, the one or more problems may be listed in other ways. For example, in one embodiment each problem may be displayed as an icon.","In , user input selecting a first problem (or potential problem) from the one or more listed problems (or potential problems) may be received. In various embodiments, user input of any kind may be received to select the first problem, e.g., depending on the manner in which the one or more problems are listed. As one example, the one or more problems may be displayed in a selectable list, and the user may select the first problem by interacting with the displayed list, e.g., by clicking or double-clicking on the first problem with a pointing device, checking a box next to the first problem, pressing a button to select the first problem, etc.","In , the first problem (or potential problem) in the graphical program may be visually indicated on the display device in response to the user selecting the first problem. Visually indicating the first problem may comprise displaying graphical information to visually indicate the first problem. In one embodiment text information regarding the first problem may also be displayed. In one embodiment the first problem may comprise a problem in the block diagram of the graphical program. In this embodiment, visually indicating the first problem may comprise displaying the block diagram of the graphical program and displaying information to visually indicate the first problem in the block diagram. In another embodiment the first problem may comprise a problem in the graphical user interface of the graphical program. In this embodiment, visually indicating the first problem may comprise displaying the graphical user interface of the graphical program and displaying information to visually indicate the first problem in the graphical user interface of the graphical program.","As described above, the graphical program may include a plurality of objects, such as block diagram objects and\/or graphical user interface objects. In one embodiment the first problem (or potential problem) found during the programmatic analysis of the graphical program may correspond to an object in the graphical program. Thus, visually indicating the first problem may comprise visually indicating the object to which the first problem corresponds. For example, in one embodiment the first problem may correspond to an object in the block diagram of the graphical program, such as a node or wire. Thus, the first problem may be visually indicated by displaying the block diagram and visually indicating the node or wire (or other block diagram object) in the block diagram. In another embodiment the first problem may correspond to an object in the graphical user interface of the graphical program, such as a control or indicator. Thus, the first problem may be visually indicated by displaying the graphical user interface and visually indicating the control or indicator (or other graphical user interface object) in the graphical user interface of the graphical program.","In another embodiment the first problem found during the programmatic analysis of the graphical program may correspond to multiple objects in the graphical program or may correspond to a portion of the graphical program but not to a particular object. In this embodiment, visually indicating the first problem may comprise visually indicating the portion of the graphical program or visually indicating multiple objects in the graphical program.","Visually indicating a graphical program object or graphical program portion that corresponds to the first problem found during analysis of the graphical program may comprise displaying information or altering the appearance of the graphical program object or portion in any of various ways in order to call the user's attention to that object or portion of the graphical program. For example, one or more nodes, wires, or other objects in a block diagram of the graphical program may be visually indicated by changing their usual color, changing the color of the background behind them, drawing a border around them, causing them to blink, or providing any of various other kinds of visual cues to draw the user's attention to these objects or cause the objects to stand out from other objects in the block diagram. Graphical user interface objects in a graphical user interface of the graphical program may be highlighted in a similar manner.","Where the programmatic analysis performed in  discovers a plurality of problems (or potential problems) in the graphical program, the method may further comprise receiving user input selecting a second problem from the one or more listed problems. In response, the second problem in the graphical program may be visually indicated on the display device, similarly as described above. Other problems found during the programmatic analysis of the graphical program may be selected and visually indicated in a similar manner. For example, as the user selects each problem, the appropriate portion of the graphical program may be scrolled into view, and the object(s) or graphical program portion that corresponds to the problem may be visually indicated as described above. In another embodiment, the one or more problems discovered during the programmatic analysis of the graphical program may be listed one at a time so that the user can simply advance from one problem to the next but may not be able to see all the problems listed at once or select a problem randomly.","In various embodiments, the method may be operable to perform programmatic analysis of any kind on the graphical program, in order to discover problems of any kind. In one embodiment, user input specifying one or more options for programmatically analyzing the graphical program may be received, and the graphical program may be programmatically analyzed in accordance with the one or more options. For example, one or more GUI panels for configuring the programmatic analysis of the graphical program may be displayed, and the user input may be received to the one or more GUI panels. An exemplary graphical program analyzer is described below, which allows the user to specify one or more tests to perform on the graphical program. Each failure occurrence of the specified tests may be visually indicated as described above.","Graphical Program Analyzer","In one embodiment a graphical program analyzer tool or utility that allows a user to interactively specify analysis options for analyzing a graphical program may be provided. The graphical program analyzer may be operable to programmatically analyze one or more graphical programs according to the analysis options specified by the user and may then display results of the analysis. In one embodiment the graphical program analyzer may provide a wizard-like interface to guide the user through the analysis process. For example, the graphical program analyzer may display a plurality of graphical user interface (GUI) panels with which the user may interact.","In various embodiments the graphical program analyzer may be operable to programmatically analyze any kind of graphical program, e.g., may analyze graphical programs developed using any graphical programming development environment or graphical programming language. Screen shots from a software utility operable to programmatically analyze LabVIEW graphical programs are described below to illustrate one particular embodiment of a graphical program analyzer.","In one embodiment the graphical program analyzer may be integrated into a graphical programming development environment. For example,  illustrates an editor window for editing the block diagram of a LabVIEW graphical program that performs a measurement function. As shown, the user has activated a \u201cTools\u201d menu in the editor window to display a \u201cAnalyze VIs . . . \u201d menu option. (LabVIEW graphical programs may also be referred to as VIs.) The user may select this menu option to launch a wizard-like interface that allows the user to specify an analysis configuration for analyzing one or more graphical programs. Thus, in this example the graphical program analyzer is tightly integrated with the graphical program editor in a common user interface.","In another embodiment the graphical program analyzer may not be integrated with a graphical programming development environment. For example, the user may launch the graphical program analyzer as a separate software application from an operating system shell or GUI.",{"@attributes":{"id":"p-0112","num":"0111"},"figref":["FIG. 6","FIG. 6","FIG. 6"]},"In one embodiment, if the user does not choose to analyze the currently open graphical program (or if the graphical program analyzer does not give the user this option) then the graphical program analyzer may display a GUI panel for selecting one or more graphical programs to be analyzed.  illustrates an exemplary GUI panel for selecting graphical program(s) to be analyzed. The user can click the \u201cAdd Top-Level Item . . . \u201d button to display a dialog allowing the user to select a graphical program or a library of graphical programs to be analyzed. In this example, the user has selected a library of graphical programs named \u201cllbtoanalyze.llb\u201d that includes several LabVIEW VIs.","Some kinds of graphical programs may use graphical sub-programs. As described above, a graphical program may have a block diagram that includes a plurality of interconnected nodes or icons. A graphical sub-program may be included as a node in the block diagram of a graphical program. The graphical sub-program may have its own block diagram which the user may view by expanding this node.","In one embodiment, the graphical program analyzer may be operable to analyze not only the top-level graphical programs selected by the user but also any graphical sub-programs in the top-level graphical programs. Graphical sub-programs may also use their own graphical sub-programs, i.e., graphical sub-programs may be nested to any desired degree. In one embodiment the graphical program analyzer may be operable to programmatically analyze an entire nested chain of graphical sub-programs. The user interface of the graphical program analyzer may provide the user with options for specifying whether and which graphical sub-programs should be analyzed. For example, the GUI panel of  includes a \u201cInclude\/Exclude SubVIs\u201d button that the user may click to include or exclude in the analysis the subVIs in the selected LabVIEW VI in the \u201cItems to Analyze\u201d list on the left.","As described above, in various embodiments the graphical program analyzer may be operable to perform analysis of any kind on the selected graphical program(s). In one embodiment the graphical program analyzer may allow the user to select from a plurality of tests to perform on the selected graphical program(s). For example, the graphical program(s) may be analyzed to determine whether they pass or fail the selected tests. In various embodiments the graphical program analyzer may be operable to perform any desired test.","In one embodiment the tests may be organized into different categories. Tests may be categorized in any way. In one embodiment, test categories include block diagram tests, documentation tests, user interface tests, and general tests.","Block diagram tests may include tests that programmatically analyze the graphical program's block diagram for performance and style issues. For example, the block diagram may be analyzed for wiring style, loop and structure usage, unnecessary elements on the block diagram, etc. Exemplary block diagram tests for LabVIEW graphical programs are described below.","Documentation tests may include tests that programmatically analyze the graphical program for documentation issues. The graphical program may be analyzed for user documentation and\/or developer documentation. For example, the graphical program analyzer may check for comments on the graphical program's block diagram, help text or descriptions for controls or graphical sub-programs, etc. Exemplary documentation tests for LabVIEW graphical programs are described below.","User interface tests (also referred to herein as front panel tests) may include tests that programmatically analyze the graphical program for user interface issues. For example, the graphical program's graphical user interface may be analyzed for design or style issues as well as functional issues. For example, the user interface may be analyzed or control usage, font selection, the presence of labels, etc. Exemplary front panel tests for LabVIEW graphical programs are described below.","General tests may include tests that programmatically analyze the graphical program for performance and style issues that do not fit into the other three categories. For example, the programmatic interface (e.g., input and output connectors or parameters) of the graphical program may be analyzed. Exemplary general tests for LabVIEW graphical programs are described below.","In one embodiment the graphical program analyzer may allow the user to customize or modify the analysis criteria used in programmatically analyzing the graphical program(s). For example, in an embodiment in which the graphical program analyzer performs different kinds of tests on the graphical program(s) such as described above, the graphical program analyzer may allow the user to select which tests to perform on the graphical program(s). This may enable the analysis to be customized according to the user's specific needs or according to the type of graphical program. As one example, if the graphical program does not have a visible graphical user interface displayed at runtime or if the user is not concerned with design issues for the graphical user interface then user interface tests may be excluded from the analysis.",{"@attributes":{"id":"p-0123","num":"0122"},"figref":["FIG. 8","FIG. 8","FIG. 8"]},"In one embodiment the graphical program analyzer may be operable to display a description or help text for each test to inform the user of how the test analyzes the graphical program. In the example of , the text box in the bottom left of the GUI panel is updated with test descriptions as the user selects various tests from the \u201cTest\u201d list box at the top left. In this example, the user has selected the \u201cBackwards Wires\u201d test item. The illustrated test description informs the user that this test checks for wires that do not flow from left to right. (In LabVIEW, the convention is for data flow to be indicated in the block diagram in a left to right manner.)","In one embodiment, one or more of the available tests may have configurable options or parameters, and the graphical program analyzer may allow the user to adjust the options or parameters. For example, the GUI panel of  includes an area on the right side labeled \u201cSelected Test's Configuration\u201d. When the user selects a test in the \u201cTest\u201d list box on the left, this area may be updated to display GUI controls that allow the user to specify options or set parameters relevant to the test. For example, in  the user may select an option to specify that wire segments within terminals should be ignored for the \u201cBackwards Wires\u201d test. The options or parameters set by the user for each test may affect whether the graphical program passes or fails the test.",{"@attributes":{"id":"p-0126","num":"0125"},"figref":"FIG. 9"},"As described below, in one embodiment the graphical program analyzer may be operable to generate a report or display results after the graphical program(s) have been analyzed. In one embodiment the user may also be able to specify options for each test that relate to the reporting. For example, as shown in , the user may set a \u201cMaximum Reported Failures\u201d parameter to specify a maximum number of times that failure occurrences of the selected test should be included in the report or the displayed results. The user may also set a \u201cTest Ranking\u201d parameter (e.g., low or high) that controls the ordering for the report. For example, failures for high-ranked tests may be shown in the report before failures for low-ranked tests.","As described above, in one embodiment the user may select multiple graphical programs to be analyzed. In one embodiment, by default each of the graphical programs may be analyzed with the tests selected by the user. In another embodiment the user may be able to select different tests to perform for different graphical programs. For example, the GUI panel of  allows the user to customize the set of tests that are performed for each of the listed VIs. The tests previously selected by the user appear in the list box on the right. The user may select one or more of the VIs in the list box on the left and uncheck any tests that he does not want to be performed for those VIs.","In one embodiment the graphical program analyzer may allow the user to save an analysis configuration representing the input that the user has provided to the GUI of the graphical program analyzer. For example, the analysis configuration may specify information such as the graphical program(s) that were selected, whether graphical sub-programs should be analyzed, which tests to perform for which graphical programs, options or parameters for each test, etc. Saving the analysis configuration may enable the user to later re-use the same configuration to analyze other graphical programs or to re-analyze the same graphical programs without having to re-enter all the configuration input to the graphical program analyzer GUI. The graphical program analyzer may allow the user to save the analysis configuration at various points in the configuration input process. For example, the GUI panels of  each have a \u201cSave . . . \u201d button that the user can click to save the analysis configuration. In various embodiments the analysis configuration may be stored in various ways. In one embodiment the analysis configuration may be stored in a configuration file.","After the user has provided input to the GUI of the graphical program analyzer to create an analysis configuration such as described above (or after a previously saved analysis configuration has been re-loaded and possibly modified), the user may request the graphical program analyzer to programmatically analyze the graphical program(s). For example, the GUI panel of  has an \u201cAnalyze\u201d button that the user can click to start the analysis.","The graphical program analyzer may then programmatically analyze the graphical program(s) according to the criteria or tests specified by the user. Programmatically analyzing a graphical program may include any technique or method implemented by a program that inspects or examines the graphical program. For example, programmatically analyzing the graphical program may include analyzing one or more data structures that represent the graphical program. For example, the data structure(s) may be analyzed to determine graphical program elements (e.g., nodes, programmatic structures such as loops or case structures, user interface elements, etc.) present in the graphical program and\/or to determine a relationship among these graphical program elements.","The graphical program analyzer may check for the presence of different kinds of graphical program elements or relationships among the elements, depending on which tests were selected by the user. As one example, where the user selected the \u201cArrays and Strings in Loops\u201d test described above, the graphical program analyzer may analyze data structures representing the graphical program to determine whether the graphical program includes any loops. If so, each loop (or a data structure representing the loop) may be analyzed to determine whether array or string function nodes are included within the loop.","In one embodiment the graphical program analyzer may be operable to display information indicating results of the analysis after it has been completed. For example, the graphical program analyzer may display information indicating problems found (if any) in the graphical program(s). In an embodiment in which the graphical program analyzer performs selected tests on the graphical program(s) as described above, pass\/fail results of the individual tests may be shown. The graphical program analyzer may also display other information such as statistics regarding the number of tests that were performed, the number or percentage that passed\/failed, etc.",{"@attributes":{"id":"p-0134","num":"0133"},"figref":["FIG. 11","FIG. 11"]},"In one embodiment, tests may be displayed according to a ranking. For example, each test may be ranked as a high, medium, or low ranking test. The GUI panel of  may display the high-ranking tests first, followed by the medium and then the low-ranking tests. Tests that involve issues that have a significant impact on the graphical program's performance or correctness may be ranked as high. Tests that involve minor style, cosmetic, or other issues that do not significantly affect the graphical program's performance may be ranked as low. Other tests may fall into the middle ranking area. In one embodiment each test may have a default ranking. As described above with reference to , the user may also change the rankings for the tests if desired. In one embodiment, high-ranking tests may be marked in the GUI with an exclamation point, and low-ranking tests may be marked with an \u201ci\u201d symbol, allowing the user to easily distinguish the test rankings.","It is possible that each test may be performed and may fail multiple times during the analysis of a graphical program. In one embodiment, the user may be able to view each failure occurrence. (As described above, in another embodiment the user may specify a \u201cMaximum Reported Failures\u201d parameter to specify a maximum number of failure occurrences to report.) For example, in the GUI panel of , the user may click the \u201c+\u201d and \u201c\u2212\u201d signs beside each test in the results list to expand or collapse the failure occurrences for that test.","Clicking on a particular failure occurrence shown under a test may cause the GUI panel to display text at the bottom of the panel to explain why the test failed for that occurrence. For example, the analysis results displayed in  indicate that three failure occurrences of the \u201cWire Bends\u201d test were found. The user has selected the \u201cOccurrence \u201d item, and the text at the bottom informs the user that this occurrence corresponds to a wire that has a segment with a length less than a specified minimum pixel length. As described below, in one embodiment the graphical program analyzer may also be operable to automatically display the portion of the graphical program that failed the test.",{"@attributes":{"id":"p-0138","num":"0137"},"figref":["FIG. 12","FIG. 11"]},{"@attributes":{"id":"p-0139","num":"0138"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0140","num":"0139"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0141","num":"0140"},"figref":"FIG. 15"},"In one embodiment the graphical program analyzer may also be operable to display portions of the graphical program that correspond to the displayed results of the analysis. For example, in one embodiment the graphical program analyzer may be operable to display the graphical program portion that corresponds to each failure occurrence of the tests that were performed. This may allow the user to easily correlate the analysis results with the graphical program itself.","In one embodiment the graphical program analyzer may display the portion of a graphical program that corresponds to a failure occurrence of a test by launching an editor window and bringing the relevant portion of the graphical program into view, e.g., by scrolling the editor window so that the relevant portion is visible. For example, if the failure occurrence represents a problem in the block diagram of the graphical program then the graphical program analyzer may open the block diagram in an editor window and automatically scroll the problem area into view. In one embodiment the graphical program analyzer may also highlight or call the user's attention to the relevant portion of the block diagram, e.g., may highlight one or more nodes, wires, or other objects in the block diagram that caused the test to fail. This may enable the user to easily identify and modify the problem area of the block diagram if desired.","Similarly, if a failure occurrence for a test represents a problem in the user interface of the graphical program then the graphical program analyzer may open the user interface in an editor window and automatically scroll the problem area into view. In one embodiment the graphical program analyzer may also highlight or call the user's attention to the relevant portion of the user interface, e.g., may highlight one or more user interface controls, indicators, or other objects in the user interface that caused the test to fail. This may enable the user to easily identify and modify the problem area of the user interface if desired.","Highlighting a graphical program portion that corresponds to a test failure occurrence may comprise displaying information or altering the appearance of the graphical program portion in any of various ways in order to call the user's attention to that portion of the graphical program. For example, the graphical program analyzer may alter the appearance of one or more nodes, wires, or other objects in a block diagram of the graphical program by changing their usual color, changing the color of the background behind them, drawing a border around them, causing them to blink, or providing any of various other kinds of visual cues to draw the user's attention to these objects or cause the objects to stand out from other objects in the block diagram. User interface objects in a user interface of the graphical program may be highlighted in a similar manner. In one embodiment the graphical program analyzer may also or may alternatively provide speech or audio cues to draw the user's attention to the relevant portion of the graphical program.",{"@attributes":{"id":"p-0146","num":"0145"},"figref":["FIGS. 16-20","FIGS. 11-15","FIG. 11","FIG. 11"],"b":"2"},"In response to the user requesting to view the portion of the graphical program that corresponds to the failure occurrence shown in , the graphical program analyzer may open the block diagram of the graphical program in an editor window and highlight the wire that has the segment that is less than the specified minimum pixel length, as shown in . As shown, the highlighted wire  is visually indicated with a thick dashed border. (On a computer display, the border may also circulate or march around the wire to help draw the user's attention.)","The highlighted user interface control  labeled \u201cStop\u201d in  corresponds to the failure occurrence selected in . As discussed above, this failure occurrence represents a warning regarding the \u201cStop\u201d control in the graphical program's user interface. In response to the user requesting to view the portion of the graphical program that corresponds to this failure occurrence (e.g., by double-clicking on the selected \u201cOccurrence \u201d item in  with a mouse device), the graphical program analyzer may open the user interface of the graphical program in an editor window and highlight the user interface control  labeled \u201cStop\u201d, as shown in . As shown the user interface control  is highlighted with a thick dashed border.","As discussed above, the failure occurrence selected in  represents a warning regarding the graphical program as a whole and not any specific object in the graphical program. In , the graphical program analyzer has highlighted the entire block diagram of the graphical program by inverting colors in the block diagram.","The highlighted graphical sub-program node  in  corresponds to the failure occurrence selected in . As discussed above, this failure occurrence represents a warning that the error output terminal of the node is not connected to anything. In , the graphical program analyzer has highlighted the graphical sub-program node  by drawing a thick dashed border around the node.","The highlighted graphical sub-program node  in  corresponds to the failure occurrence selected in . As discussed above, this failure occurrence represents a warning that the graphical sub-program represented by the node  is not platform independent. In , the graphical program analyzer has highlighted the graphical sub-program node  by drawing a thick dashed border around the node.","In another embodiment, in addition to highlighting the graphical program portion that corresponds to a test failure occurrence, the graphical program analyzer may also be operable to display one or more suggestions for how to modify the graphical program to correct the problem. In one embodiment, the graphical program analyzer may also be operable to automatically modify the graphical program to correct the problem if desired by the user. For example, the user may click a button or provide other input requesting the graphical program to be modified. The graphical program analyzer may then programmatically modify the graphical program to eliminate the problem. In various embodiments, the graphical program may be programmatically modified in any way, depending on the nature of the test that failed. As one example, if the graphical program analyzer found a wire that does not adhere to a left-to-right dataflow convention, the graphical program analyzer may programmatically re-position one or more nodes or other objects in the graphical program so that the wire is re-drawn to indicate dataflow in a left-to-right manner.","The analysis results shown above in  represent an example where the graphical program analyzer programmatically analyzed a single graphical program. As described above, in one embodiment the user may select multiple graphical programs to be analyzed. For example, the user may select multiple top-level graphical programs to be analyzed or may select one or more top-level graphical programs and specify that graphical sub-programs in the top-level graphical program(s) should also be analyzed.",{"@attributes":{"id":"p-0154","num":"0153"},"figref":["FIG. 21","FIG. 21"]},{"@attributes":{"id":"p-0155","num":"0154"},"figref":"FIG. 22"},"In , the user has selected a failure occurrence of an \u201cUnused Code\u201d test in the top-level \u201cSemaphore with SubVIs.vi\u201d graphical program. As shown in the description at the bottom of the GUI panel, the test failed in this case because a wire in the block diagram of the top-level graphical program that is sourced by a tunnel is not used by its owning While loop. In this example, the description of the failure occurrence also includes suggestions for how the block diagram may be modified. The user may double-click the selected \u201cOccurrence \u201d item in the \u201cResults list\u201d box to request the graphical program analyzer to display the problem area of the block diagram, as described above.  illustrates the top-level graphical program's block diagram with the While loop's tunnel  highlighted.","In , the user has selected a failure occurrence of a \u201cBackwards Wires\u201d test in the \u201cCreate Semaphore.vi\u201d graphical sub-program. As noted above, \u201cCreate Semaphores.vi\u201d is a graphical sub-program of the top-level \u201cSemaphore with SubVIs.vi\u201d graphical program. As shown in the description at the bottom of the GUI panel, the test failed in this case because a wire in the block diagram of the graphical sub-program does not follow LabVIEW's left-to-right dataflow style. The user may double-click the selected \u201cOccurrence \u201d item in the \u201cResults list\u201d box to request the graphical program analyzer to display the problem area of the block diagram, as described above.  illustrates the graphical sub-program's block diagram with the backwards wire  highlighted. Thus, in one embodiment the graphical program analyzer may be operable to not only automatically display problematic portions in a top-level graphical program but may also open graphical sub-programs in which problems were found during the analysis and display\/highlight the problematic portions in the graphical sub-programs.","The examples discussed above illustrated exemplary problems found in the block diagram and user interface of various graphical programs. As described above, in one embodiment the graphical program analyzer may also be operable to analyze a graphical program to determine whether the graphical program includes various kinds of documentation.  illustrates an exemplary GUI panel in which a failure occurrence for a \u201cVI Documentation\u201d test is selected. As shown in the description at the bottom of the GUI panel, the test failed in this case because the VI has no VI description.","In one embodiment, the graphical program analyzer may be operable to generate a report or file based on the results of programmatically analyzing one or more graphical programs. In various embodiments the report or file may include any kind of information regarding an analysis that was performed on the graphical program(s). For example, the report or file may include information such as the names of the graphical programs that were analyzed, the tests that were performed, failure occurrences for the tests, etc. The report or file may also include summary information such as the number of times each test was performed, the number or percentage of failure occurrences, the time it took to programmatically analyze the graphical program(s), etc.","The report or file may also be organized or stored in any desired way or according to any desired file or report standard. For example, the graphical program analyzer may be operable to store a report as an ASCII file, an HTML file, or in a proprietary file format that can be imported into another software application. In one embodiment the graphical program analyzer may also be operable to save a report file that can later be re-loaded into the graphical program analyzer so that the analysis results can be re-displayed and the user can interactively see the correlation between failure occurrences and the respective graphical program portions, as described above.","The exemplary GUI panel described above for showing analysis results includes an \u201cExport . . . \u201d button (e.g., as shown in ) that the user can click to invoke a dialog for specifying a report file to save. The user may specify a path for the report file, as well as options specifying a desired format (e.g., HTML or ASCII), a desired sorting order for the results (e.g., by graphical program or by test), etc. The user may also be able to specify what information to include in the report file, e.g., by checking or unchecking boxes such as \u201cSummary Data\u201d, \u201cFailed Tests\u201d, \u201cErrors\u201d, etc.","API for Analyzing a Graphical Program","In another embodiment, instead of interacting with a graphical program analyzer tool as described above, the user may create a program operable to programmatically analyze one or more graphical programs. For example, in one embodiment an application programming interface (API) for programmatically analyzing a graphical program may be provided. For example, the API may be associated with or provided by an application development environment (ADE) or may be available as an add-on to the ADE.","In various embodiments the user may be able to create any kind of program to analyze the graphical program. In one embodiment the program that performs the analysis of the graphical program may comprise a text-based program, i.e., a program written in a text-based programming language such as C, C++, Visual C++, Java, Visual Basic, etc. For example, an API that includes various functions or methods related to performing programmatic analysis of a graphical program may be provided, and the user may include various function and method calls in the text-based program.","In another embodiment the program that performs the analysis of the graphical program may itself comprise a graphical program. For example, a graphical programming API that includes various function nodes or other graphical program objects related to performing programmatic analysis of a graphical program may be provided. The user may include various function nodes or objects from the API in a graphical program and may interconnect the function nodes with other nodes in the graphical program to visually indicate the desired analysis functionality. The user may also provide the graphical program with references to one or more target graphical programs so that the graphical program executes to programmatically analyze the target graphical program(s). The user may also include function nodes operable to perform functions such as displaying results from the programmatic analysis or generating a report based on the results.","In one embodiment the graphical programming API may be tightly integrated with a graphical programming development environment. For example, the user interface of the graphical programming development environment may provide the user with access to various function nodes related to programmatically analyzing a graphical program and may allow the user to include the nodes in graphical programs created using the graphical programming development environment.  illustrates one embodiment of a palette for the LabVIEW graphical programming development environment that includes a plurality of function nodes related to programmatically analyzing a graphical program. The user may drag and drop nodes from the palette into a graphical program. A description of the nodes in the palette follows.","It is noted that the particular set of nodes described below represents an exemplary embodiment of a LabVIEW graphical programming API for programmatically analyzing LabVIEW graphical programs or VIs. However, in various embodiments a graphical programming API for programmatically analyzing a graphical program may take on any of various other forms and may be used in any graphical programming development environment.",{"@attributes":{"id":"p-0167","num":"0166"},"figref":"FIG. 29"},"The \u201cPath to Configuration File\u201d input specifies the path to the configuration file containing the desired VI Analyzer task settings. If the user does not specify a path, the node may create a new VI Analyzer task. The user can use a configuration file previously saved by other VI Analyzer nodes or by a graphical program analyzer interactive tool such as described above.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cConfiguration File Password\u201d input specifies the password for the configuration file specified in the \u201cPath to Configuration File\u201d input. If the configuration file is not password protected, the node ignores this input. If the password is incorrect, the node returns an error.","The \u201cVI Analyzer Task\u201d output returns a reference to the new VI Analyzer task. The user may wire this output to the VI Analyzer Task input of other VI Analyzer nodes.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0173","num":"0172"},"figref":"FIG. 30"},"The \u201cVI Analyzer Task\u201d input specifies a reference to the task to be destroyed. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0177","num":"0176"},"figref":"FIG. 31"},"The \u201cOverwrite?\u201d input specifies whether to overwrite the configuration file if the file specified in the \u201cPath to Configuration File\u201d input already exists. The default is TRUE, which overwrites the existing file. If \u201cOverwrite?\u201d is FALSE and the file exists, the node returns an error.","The \u201cVI Analyzer Task\u201d input specifies a reference to the current task. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cPath to Configuration File\u201d input specifies the path to the configuration file to save. If an invalid path is specified, the node returns an error. If no path is specified, the node saves the configuration file using the path specified in the \u201cVIAn New Task\u201d node. If no paths are specified for either node, the node returns an error.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cConfiguration File Password\u201d input specifies the password to assign to the configuration file. If this input is not used, the configuration file is not password protected.","The \u201cVI Analyzer Task\u201d output returns a reference to the VI Analyzer task specified in the \u201cVI Analyzer Task\u201d input.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0185","num":"0184"},"figref":"FIG. 32"},"The \u201cVI Analyzer Task\u201d input specifies a reference to the current task. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cVIs Tested\u201d output returns an array of paths to every graphical program analyzed.","The \u201cTests Run\u201d output returns an array of strings specifying the names of all the tests run in the analysis.","The \u201cVI Analyzer Task\u201d output returns a reference to the VI Analyzer task specified in the \u201cVI Analyzer Task\u201d input.","The \u201cAnalysis Results\u201d output returns the results of programmatically analyzing the graphical programs. This output may comprise a cluster including the following elements:\n\n","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0193","num":"0222"},"figref":"FIG. 33"},"The \u201cPath to Configuration File\u201d input specifies the path to the configuration file with the VI Analyzer task settings to use. The user can specify a configuration file previously saved by other VI Analyzer nodes or by a graphical program analyzer interactive tool such as described above.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cConfiguration File Password\u201d input specifies the password for the configuration file specified by \u201cPath to Configuration File\u201d. If the configuration file is not password protected, the node ignores this input. If the password is incorrect, the node returns an error.","The \u201cAnalysis Results\u201d output returns the results of programmatically analyzing the graphical programs. This output may comprise a cluster including several elements, similarly as described above with respect to the \u201cAnalysis Results\u201d output of the \u201cVIAn Run\u201d node.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0199","num":"0228"},"figref":"FIG. 34"},"The \u201cOverwrite Report?\u201d input specifies whether to overwrite a report file if the file specified in the \u201cReport Save Path\u201d input already exists. The default is TRUE, which overwrites the file. If \u201cOverwrite Report?\u201d is FALSE and the file exists, the node returns an error.","The \u201cReport Save Path\u201d input specifies the path to the report or results file. If the path specified is invalid, the node returns an error.","The \u201cAnalysis Results\u201d input specifies the analysis results from a VI Analyzer task that was run using either the \u201cVIAn Easy Analyze\u201d node or the \u201cVIAn Run\u201d node. The \u201cAnalysis Results\u201d output of either of those nodes may be wired to the \u201cAnalysis Results\u201d input of this node.","The \u201cReport Save Type\u201d input determines whether the node saves the results to a tab-delimited ASCII file, an HTML file, or a VI Analyzer results file. The default is an ASCII file. If a VI Analyzer results file is selected, the node saves the report data to a VI Analyzer results file that can be loaded into a results window of a graphical program analyzer interactive tool such as described above.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cExport Options\u201d input specifies the sections of the analysis results to include in the report. This input may comprise a cluster of the Boolean options shown below. The default selects the Summary Data, Failed Tests, and Errors options. If \u201cReport Save Type\u201d is set to a VI Analyzer results file, the node ignores this input.\n\n","The \u201cSort Type\u201d input specifies whether to sort the report results by graphical program or by test. The default sorts the results by graphical program. If the \u201cReport Save Type\u201d input is set to VI Analyzer results file, the node ignores this input.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.","As described above, the user may create a graphical program that includes the above-described nodes and may execute the graphical program to programmatically analyze one or more target graphical programs.  illustrate an exemplary user interface and block diagram for a graphical program that uses the \u201cVIAn Easy Analyze\u201d and \u201cVIAn Easy Report\u201d nodes described above.","As shown in the block diagram of , a path to a configuration file \u201csample.cfg\u201d has been wired to the \u201cPath to Configuration File\u201d input of the \u201cVIAn Easy Analyze\u201d node. When the block diagram is executed, the \u201cVIAn Easy Analyze\u201d node may execute to programmatically analyze the graphical program(s) specified in the \u201csample.cfg\u201d configuration file, using the settings specified in the configuration file (e.g., the tests to be performed and the settings for each individual test, etc.).","The user may interact with the graphical program's user interface shown in  to specify a path to an HTML report file in which to save results of the analysis in HTML format. A user interface terminal in the block diagram provides the path specified by the user to the \u201cReport Save Path\u201d input of the \u201cVIAn Easy Report\u201d node. Summary data produced by the \u201cVIAn Easy Analyze\u201d node is also displayed on the user interface of  after the analysis has been performed.","The nodes described above control programmatic analysis of a graphical program at a relatively high level. Other nodes that allow control to be performed at a lower level may also be provided. For example, the icon at the bottom right of the palette shown in  represents a sub-palette. The user may click this icon to display the sub-palette of , which provides additional utility nodes for configuring the programmatic analysis of a graphical program. The nodes in  are described below.",{"@attributes":{"id":"p-0212","num":"0246"},"figref":"FIG. 38"},"The \u201cVI Analyzer Task\u201d input specifies a reference to the current task. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cItem to Add\u201d input specifies the path to the VI, LLB, or folder to add to the VI Analyzer task. If an LLB or folder is specified, the node adds all the VIs included in the LLB or folder to the VI Analyzer task. If an invalid path or a path to an invalid item is specified, the node returns an error. By default, the node does not include item subVIs unless the \u201cInclude SubVIs setting?\u201d is changed.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cVI Analyzer Task\u201d output returns a reference to the VI Analyzer task wired to the \u201cVI Analyzer Task\u201d input.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0218","num":"0252"},"figref":"FIG. 39"},"The \u201cVI Analyzer Task\u201d input specifies a reference to the current task. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cItem to Remove\u201d input specifies the VI, folder, or LLB to remove from the VI Analyzer task. If a top-level item is specified, the node removes the item and all its sub-items. If a sub-item is specified, the node excludes the sub-item but includes other sub-items within the top-level item.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cVI Analyzer Task\u201d output returns a reference to the VI Analyzer task wired to the \u201cVI Analyzer Task\u201d input.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0224","num":"0258"},"figref":"FIG. 40"},"The \u201cVI Analyzer Task\u201d input specifies a reference to the current task. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cVI Analyzer Task\u201d output returns a reference to the VI Analyzer task wired to the \u201cVI Analyzer Task\u201d input.","The \u201cItems\u201d output returns the paths of all top-level VIs, folder, or LLBs that the VI Analyzer task includes.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0230","num":"0264"},"figref":"FIG. 41"},"The \u201cVI Analyzer Task\u201d input specifies a reference to the current task. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cVI Analyzer Task\u201d output returns a reference to the VI Analyzer task wired to the \u201cVI Analyzer Task\u201d input.","The \u201cTest Names\u201d output specifies the names of the tests that the VI Analyzer task includes.","The \u201cTest Configurations\u201d output specifies an array of clusters in which each cluster represents the configuration options for a specific test as follows:\n\n","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0237","num":"0277"},"figref":"FIG. 42"},"The \u201cVI Analyzer Task\u201d input specifies a reference to the current task. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cVI\u201d input specifies the path to the VI to exclude from the tests specified by the \u201cTests to Exclude\u201d input. If the VI is not included in the VI Analyzer task, or if the path specified is empty or invalid, the node produces an error.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cTests to Exclude\u201d input specifies the names of the tests to exclude from the VI specified by the \u201cVI\u201d input. The \u201cTest Names\u201d output of the \u201cVIAn Get Tests\u201d node may be wired to this input. If an invalid test name is specified, the node produces an error.","The \u201cVI Analyzer Task\u201d output returns a reference to the VI Analyzer task wired to the \u201cVI Analyzer Task\u201d input.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0244","num":"0284"},"figref":"FIG. 43"},"The \u201cVI Analyzer Task\u201d input specifies a reference to the current task. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cVI Analyzer Task\u201d output returns a reference to the VI Analyzer task wired to the \u201cVI Analyzer Task\u201d input.","The \u201cSubVI Exclusion Paths\u201d output returns the paths to all folders of subVIs to be excluded subVIs are included in a VI Analyzer task. The VI Analyzer task excludes all subVIs in the specified folders.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0250","num":"0290"},"figref":"FIG. 44"},"The \u201cVI Analyzer Task\u201d input specifies a reference to the current task. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cSubVI Exclusion Paths\u201d input specifies the paths to the folders to be excluded when subVIs are included in a VI Analyzer task. The VI Analyzer task excludes all subVIs in the folders.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cVI Analyzer Task\u201d output returns a reference to the VI Analyzer task wired to the \u201cVI Analyzer Task\u201d input.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0256","num":"0296"},"figref":"FIG. 45"},"The \u201cVI Analyzer Task\u201d input specifies a reference to the current task. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cTest Name\u201d input specifies the name of the test to modify. If an invalid test name is specified, the node returns an error.","The \u201cNew Test Info\u201d input specifies the configuration settings to modify. This input may comprise a cluster of the following elements:\n\n","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cVI Analyzer Task\u201d output returns a reference to the VI Analyzer task wired to the \u201cVI Analyzer Task\u201d input.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0263","num":"0309"},"figref":"FIG. 46"},"The \u201cVI Analyzer Task\u201d input specifies a reference to the current task. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cTest Name\u201d input specifies the name of the test to modify. If an invalid test name is specified, the node returns an error.","The \u201cControl Name\u201d input specifies the name of the control in which to change the value. If an invalid control name is specified, the node returns an error.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cControl Value\u201d input specifies the new value for the control specified by the \u201cControl Name\u201d input.","The \u201cVI Analyzer Task\u201d output returns a reference to the VI Analyzer task wired to the \u201cVI Analyzer Task\u201d input.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0271","num":"0317"},"figref":"FIG. 47"},"The \u201cVI Analyzer Task\u201d input specifies a reference to the current task. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cItem\u201d input specifies the VI, folder, or LLB for which to change the \u201cInclude SubVIs?\u201d setting.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cInclude SubVIs?\u201d input determines whether to analyze the subVIs of the item specified by the \u201cItem\u201d input. The default is FALSE, which does not analyze the subVIs.","The \u201cVI Analyzer Task\u201d output returns a reference to the VI Analyzer task wired to the \u201cVI Analyzer Task\u201d input.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0278","num":"0324"},"figref":"FIG. 48"},"The \u201cVI Analyzer Task\u201d input specifies a reference to the current task. The VI Analyzer task must be a valid task created using the \u201cVIAn New Task\u201d node.","The \u201cPassword to Add\u201d input specifies the password or passwords needed to open password-protected VIs included in the VI Analyzer task.","The \u201cerror in\u201d input describes error conditions that occur before this node executes.","The \u201cVI Analyzer Task\u201d output returns a reference to the VI Analyzer task wired to the \u201cVI Analyzer Task\u201d input.","The \u201cerror out\u201d output specifies error information. If the \u201cerror in\u201d input indicated that an error occurred before this node ran, the \u201cerror out\u201d output specifies the same error information. Otherwise, the \u201cerror out\u201d output describes the error status that this node produces.",{"@attributes":{"id":"p-0284","num":"0330"},"figref":["FIGS. 49-51","FIG. 50","FIG. 51"]},"In this example, a plurality of VIs in a library (LLB) are programmatically analyzed. The \u201cVIAn New Task\u201d node uses preset analysis settings loaded from a configuration file. Nodes described above are used to perform tasks such as adding an LLB to the analysis task, removing a single VI from the analysis task, removing certain tests from the analysis task, and modifying a configuration value on a test. Once the programmatic analysis performed by the \u201cVIAn Run\u201d node is complete, the \u201cVIAn Easy Report\u201d node saves the analysis results to an HTML report.","Exemplary Tests","As discussed above, in one embodiment programmatically analyzing a graphical program may comprise performing various kinds of tests on the graphical program, e.g., tests that have a pass\/fail result. For example, in one embodiment the tests may include block diagram tests, documentation tests, user interface tests, or general tests. The following sections describe exemplary tests that may be performed when programmatically analyzing LabVIEW graphical programs. For example, these tests may be used by an interactive graphical program analyzer tool such as described above and\/or may be performed by a user-created program that utilizes functions or nodes from an API for programmatically analyzing graphical programs. It is noted that the following tests are exemplary, and in other embodiments any of various other kinds of tests may be performed for graphical programs created using any desired graphical programming development environment.","Block Diagram Tests","This section describes exemplary block diagram tests.","The following tests may analyze performance of the block diagram, e.g., may analyze graphical program code that affects performance of the block diagram:","Arrays and Strings in Loops\u2014Checks loops to see if loops contain Build Array or Concatenate Strings functions. These functions should generally be avoided in loops because each call to them requires a dynamic resizing of the array or string, which can affect memory and processor time.","Coercion Dots\u2014Checks the total number of coercion dots on the block diagram and the number of coercion dots on individual wires and compares them to user-specified limits.","Enabled Debugging\u2014Checks whether debugging is enabled or disabled. Disabling debugging improves VI performance.","Wait in While Loop\u2014Checks While Loops with front panel control terminals for structures or functions other than I\/O functions that regulate the speed of the While Loop.","The following tests may analyze the block diagram for issues related to programming style:","Backwards Wires\u2014Checks whether wires flow from left to right.","Control Terminal Wiring\u2014Checks whether wires exit control terminals from the right side and enter indicator terminals on the left side.","Sequence Structure Usage\u2014Checks whether the block diagram includes Stacked Sequence structures that contain more than the user-specified maximum number of frames. The test does not check Flat Sequence structures.","String Constant Style\u2014Checks the style of string constants on the block diagram. String constants containing no characters fail the test. The user may replace these with an empty string constant. String constants set to Normal Display that contain only white space such as spaces, tabs, or line feed fail the test. The user may set the constants to \u2018\\\u2019 Codes Display to improve block diagram readability.","Unused Code\u2014Checks for unnecessary code on the block diagram.","Wire Bends\u2014Compares the total number of bends on a wire and wire segments and compares them to user-specified limits.","Wires Under Objects\u2014Checks for wires that run under objects or other wires.","The following tests may analyze the block diagram for potential design problems to warn the user about:","Adding Array Size Elements\u2014Checks whether the Add Array Elements function connects to the output of the Array Size function to determine the size of a multidimensional array. The user can wire the Multiply Array Elements function to the size(s) output of the Array Size function to determine whether a multidimensional array is empty.","Breakpoint Detection\u2014Checks for breakpoints on the block diagram, including breakpoints on wires, nodes, and subdiagrams.","Bundling Duplicate Names\u2014Checks element names in the Bundle By Name and Unbundle By Name functions for duplicates. Duplicate elements can cause confusing and sometimes incorrect block diagram behavior.","Error Cluster Wired\u2014Checks that the error output on a block diagram node is wired. The user can set the test to ignore VIs with automatic error handling disabled. Nodes that usually have unwired error outputs can also be ignored.","For Loop Iteration Count\u2014Checks For Loops to ensure that the VI does not use both auto-indexing arrays and the N terminal to govern the number of iterations the For Loop runs. The test can also check for multiple auto-indexing arrays governing the iteration count.","Globals and Locals\u2014Checks whether a block diagram contains global and local variables.","Hidden Objects in Structures\u2014Checks whether any objects in structures are hidden outside the visible bounds of the structure.","Hidden Tunnels\u2014Checks tunnels, shift registers, and other structure border elements to see if they overlap. Overlapping tunnels can make a block diagram difficult to read. The test does not check dynamic event tunnels or tunnels on the inner borders of Flat Sequence structures.","Indexer Datatype\u2014Checks functions that index array elements and string characters to ensure that a signed or unsigned 32-bit integer data type indexes the elements. The test fails if a signed or unsigned 8-bit or 16-bit integer data type indexes string or array elements. The test ignores functions that use constants for indexing.","Pattern Label\u2014Checks whether a file dialog box that uses file patterns specifies a pattern label. Items that can be checked include the File Dialog function and the browse options on a path control.","Reentrant VI Issues\u2014Checks for control references, implicit Property Nodes, or implicit Invoke Nodes in a reentrant VI. Because reentrant VIs maintain multiple data spaces but share a single front panel, unexpected results can occur when attempting to read or manipulate properties of controls on the shared front panel.","Typedef Cluster Constants\u2014Checks cluster constants on the block diagram that are linked to typedef controls to determine whether their values match the default value of the typedef control. If a constant has a non-default value and the structure of the typedef changes, the value of the constant might reset. The user can use the Bundle By Name function to change the value of any elements inside a cluster constant linked to a typedef control.","User Interface Tests","This section describes exemplary user interface tests. A user interface panel for a LabVIEW VI is referred to as a front panel.","The following tests may analyze user interface design or style:","Clipped Text\u2014Checks that any visible text on the front panel is not cut off. This includes text in control labels, control captions, free labels, and text controls such as strings and paths. The test does not check the text inside list boxes, tables, tree controls, and tab controls.","Dialog Controls\u2014Checks that the front panel controls are on the Dialog Controls palette. The test ignores controls that do not have a dialog counterpart. The test also ignores multicolumn list boxes and tables.","Duplicate Control Labels\u2014Checks that controls on the front panel do not share the same label.","Empty List Items\u2014Checks list box, multicolumn list box, table, and tree controls to ensure that they are empty. The contents of these controls populate when a VI runs, so saving a VI with contents in these controls uses memory unnecessarily.","Font Usage\u2014Checks that front panel controls, indicators, and free labels use user-specified symbolic fonts, such as application, system, or dialog fonts. The test does not check fonts for text within list boxes, tables, tree controls, and tab controls.","Overlapping Controls\u2014Checks that front panel controls do not overlap. The test does not analyze front panel decorations.","Panel Size and Position\u2014Checks that a front panel completely resides within the bounds of the screen. The test also checks whether the front panel is larger than the maximum specified width and height. If a multi-monitor system is being utilized, the test fails if the panel does not reside entirely within the bounds of the primary monitor. This test works only on standard, control, and global VIs.","Transparent Labels\u2014Checks that free labels, control labels, and control captions all have transparent backgrounds.","The following tests may analyze the appearance and arrangement of front panel controls on VIs used as subVIs:","Array Default Values\u2014Checks charts, graphs, and arrays on a front panel for empty default values. Saving non-empty default values inside charts, graphs, or arrays uses memory unnecessarily. When the VI runs, it overwrites values wired to indicators on the block diagram. If the VI is used as a subVI, the VI overwrites values wired to controls connected to the connector pane.","Cluster Sized to Fit\u2014Checks that front panel clusters are set to Size to Fit, Arrange Horizontally, or Arrange Vertically. If one of these autosizing options is not selected, cluster objects might not be visible.","Control Alignment\u2014Checks that the alignment of controls on the front panel roughly matches the alignment of controls on the connector pane.","Documentation Tests","This section describes exemplary documentation tests.","The following tests may analyze VIs to ensure that they have documentation that benefits other developers:","Comment Usage\u2014Checks whether the block diagram has a minimum user-specified number of comments. The test also can check whether all sub-diagrams of multiframe structures, such as Case, Event, and sequence structures, have at least one comment.","Label Call Library Nodes\u2014Checks Call Library Function Nodes on the block diagram for labels. The user can improve the readability of a VI by using the label of a Call Library Function Node to describe the function being calling in a shared library. The test fails if a Call Library Function Node has no label or the default label.","Revision History\u2014Checks for revision history comments. The user can clear the revision history when a VI has been completed so that end-users cannot see developer comments.","The following tests may analyze VIs to ensure that they have documentation that benefits end users:","VI Documentation\u2014Checks for text in the VI description, control description, and\/or tip strip fields on all controls.","General Tests","This section describes exemplary general tests that do not fall into the above categories.","The following tests may analyze properties of the VI as a file, such as filename and size:","SubVI and TypeDef Locations\u2014Checks that subVIs and TypeDefs reside in one of an arbitrary number of user-specified locations (paths and LLBs). If no location is specified, the test passes. The test does not check Express VIs on a block diagram.","VI Extension\u2014Checks the filename extension. The test fails for any VI that does not have a .vi or .vit extension, or for any custom control that does not have a .ctl or .ctt extension. The test is case insensitive.","VI Name\u2014Checks the name of a VI for potentially invalid characters.","VI Saved Version\u2014Checks that the VI is saved in the most current version of LabVIEW.","VI Size\u2014Compares the file size of a VI to the maximum allowable size the user specifies.","The following tests may analyze VI icon and connector pane style issues:","Connected Pane Terminals\u2014Checks that control and indicator terminals on the connector pane are wired on the block diagram.","Connector Pane Alignment\u2014Checks that inputs wire to connector pane terminals on the left side and that outputs wire to connector pane terminals on the right side.","Connector Pane Pattern\u2014Checks that the connector pane pattern, regardless of rotation, matches one of the user-specified connector pane patterns.","Default Icon\u2014Checks that VI icons are neither default nor empty.","Error Style\u2014Checks that error connections appear in the lower-left and lower-right comers of the connector pane. This part of the test runs only if the connector pane wires a single error in and a single error out terminal. The test also checks whether an error case appears around the contents of the block diagram.","Icon Size and Border\u2014Checks that the icon image is 32\u00d732 pixels in size and has a solid border. The test does not check the icons of control or global VIs.","Polymorphic Terminals\u2014Checks that terminals on all instances of a polymorphic VI appear in the same position on the connector pane of the instance VI. The test does not analyze broken polymorphic VIs.","Terminal Connection Type\u2014Checks that controls and indicators on the connector pane that match user-specified names or patterns include the user-specified terminal connection type, such as required, recommended, or optional.","Terminal Positions\u2014Checks that controls and indicators connected to a connector pane that match user-specified names or patterns are located in certain positions.","The following tests may analyze the overall setup of a VI:","Broken VI\u2014Checks for broken VIs.","Driver Usage\u2014Checks for subVIs, functions, or Property Nodes that are part of National Instruments driver software packages.","Platform Portability\u2014Checks for potential problems that might occur when porting a VI from one operating system to another.","Removed Diagram\u2014Checks whether the block diagram is present. The user can password protect a VI if he does not want end-users to view the block diagram.","Toolkit Usage\u2014Checks whether subVIs are National Instrument toolkit VIs. When a VI that includes toolkit VIs as subVIs is distributed, each computer that runs the VI must have the toolkit VIs installed or the VI does not run correctly.","VI Lock State\u2014Checks the lock state of a VI. The test fails if the lock state matches the user-specified lock state(s).","It is noted that various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a carrier medium.","Although the embodiments above have been described in considerable detail, numerous variations and modifications will become apparent to those skilled in the art once the above disclosure is fully appreciated. It is intended that the following claims be interpreted to embrace all such variations and modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A better understanding of the present invention can be obtained when the following detailed description of the preferred embodiment is considered in conjunction with the following drawings, in which:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":"82"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 3","FIGS. 1"],"b":["1","2","2"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 5-27"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 28-51"}]},"DETDESC":[{},{}]}
