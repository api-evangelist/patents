---
title: Tester of cryptographic service providers
abstract: An implementation of a technology, described herein, for ensuring reliability, stability, and adherence to a given set of security conformance standards for cryptographic program modules. An implementation of the present claimed invention is a debugging and testing tool for customized cryptographic service providers (“CSPs”). A CSP has a cryptographic type and functionality level within that type. The CSPs are tested based various test classifications. The crypto sub-system of the OS has a set of application program interface (“API”) that manage cryptographic procedures called “CryptoAPI.” For a CSP to be considered reliable, stable, and in compliance with a given set of security conformance standards, it must successfully operate with the CryptoAPI in a reliable and stable manner and it must react appropriately for the given security conformance standards. The CSPs are tested in order of increasing complexity/sophistication in functionality from simplest to most complex. This abstract itself is not intended to limit the scope of this patent. The scope of the present invention is pointed out in the appending claims.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07079648&OS=07079648&RS=07079648
owner: Microsoft Corporation
number: 07079648
owner_city: Redmond
owner_country: US
publication_date: 20010607
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["This invention generally relates to a technology for ensuring reliability, stability, and adherence to a given set of security conformance standards for cryptographic program modules.","For the modern operating system (OS), security is not just a desirable feature, but it is a vital and important component. Security sub-systems of an OS manage user authentication, which includes identification, validation, and authorization. More typically, the OS's security sub-system handles the front-end of such authorization for a network system.","Once the security sub-system has identified the user, the network validates the user and manages her access to available resources. In this typical scenario, the identified\/validated users are given access only to a limited set of available resources for which the user is authorized.","Part of the core problem of most security scenarios (including the one described here) is the reliability of the OS's identification of the user. The solution to that problem varies with the needs of those employing the security systems. For example, the reliability of the user's identification is of little importance within the context of a home network. Conversely, the reliability of the user's identification is vital and extraordinarily important in a diplomatic embassy, in the Pentagon, within the R&D department of an international corporation, and the like.","Consequently, a one-size-fits-all approach to a security sub-system is undesirable. Rather, a customized approach is better.","Customizable Security Architecture",{"@attributes":{"id":"p-0007","num":"0006"},"figref":["FIG. 1","FIG. 1"],"b":["110","162","160","110","120","130"]},"A customizable security sub-system, such sub-system , typically includes a crypto sub-system . The crypto sub-system typically includes a set of program module front-ends that allow for the management of cryptographic information. These front-ends are typically implemented as an application program interface (API). Management includes accessing, reading, writing, creating, etc. of cryptographic information (such as the user's public-private key pairs). This cryptographic information is the basis for reliably identifying the user.","The crypto sub-system allows one or more customizable plug-ins. These plug-ins may also be called \u201ccryptographic service providers\u201d (CSPs), \u201ccryptographic solutions,\u201d or \u201ccryptographic program modules.\u201d The CSPs perform the actual cryptographic functionality, such as encryption, decryption, and key management. This cryptographic functionality is a major element in the user-identification process.","As shown in , the crypto sub-system includes CSPs \u2013 which are not part of the original OS. These CSPs may be customized. These custom CSPs allow for the customization of cryptographic identification of users. For custom CSP, the user may be identified by a bio-metric device (such as a retinal scanner); by a smart card reader (such as reader ); or other the like. Other software (such as ) or hardware (such as crypto accelerator ) may be used.","Typically, an OS provides one or more default CSPs, such as default CSP  of . The default CSPs are provided with the original OS and they are used unless a customized CSP takes over its functionality. Also, these default CSPs may be useful as a template for the customized CSPs. The default CSP  gets the username and password from the user via traditional input mechanisms, such as a keyboard .","By allowing the introduction of customized security packages, an OS can better address the needs of a broad set of customers. This is especially desirable for cryptographic modules, since many security-oriented entities, such as governments, require the ability to provide their own, non-public, cryptographic implementations. An OS that is able to meet these needs will provide a customizable security architecture. An example of such an OS is Microsoft\u00ae Windows\u00ae 2000.","This type of architecture is also valuable where an entity (be it a person or a business, for example) needs a customized security implementation in terms of alternate user-authentication methods or alternate methods of private data storage. For example, smart cards may be used to authenticate access to systems and\/or data. Another example includes using bio-metrics to authenticate a user. Examples of bio-metrics include fingerprint-recognition, retinal-recognition, iris-recognition, voice-recognition, and facial recognition. This architecture allows for the security features of an OS to be flexible as authentication technology advances.","Limitations of a Customizable Security Architecture","However, a significant drawback to such an architecture is ensuring the integrity of a customized security plug-in. If the plug-in is unreliable, unstable, and\/or does not adhere to a given set of security conformance standards, then the security features of the OS may be easily compromised; thus, casting doubt on the integrity and security of the data and resources protected by the OS.","Furthermore, reports of such security compromises will harm the public perception of the overall security provided the OS despite that fact that the security breaches were caused by a customization rather than the OS itself.","Therefore, there needs to be a mechanism available so that these customized cryptographic solutions may be tested to ensure reliability, stability, and adherence to a given set of security conformance standards.","Described herein is a technology for ensuring reliability, stability, and adherence to a given set of security conformance standards for cryptographic program modules.","An implementation of the present claimed invention is a debugging and testing tool for customized cryptographic service providers (\u201cCSPs\u201d). It tests customized cryptographic solutions to ensure reliability, stability, and adherence to a given set of security conformance standards. A CSP has a cryptographic type and functionality level within that type. The CSPs are tested based various test classifications.","The crypto sub-system of the OS has a set of application programming interfaces (\u201cAPIs\u201d) that provide access to cryptographic procedures. This may be called a \u201cCryptoAPI.\u201d CryptoAPI typically consists of multiple functions or objects that implement cryptographic operations, for example, encryption. Applications must be able to rely on CryptoAPI to behave in a pre-defined way. For a CSP to be considered reliable, stable, and in compliance with a given set of security standards, it must successfully implement the CryptoAPI in a reliable and stable manner and it must react appropriately for the given security conformance standards.","The CSPs are tested in order of increasing complexity\/sophistication in functionality from most basic\/simple to most complex\/sophisticated. As a result, CSPs are tested from the most basic set of APIs to a more complex set of APIs; from the most basic functionality level to the most complex functionality level made available by the CSP.","This summary itself is not intended to limit the scope of this patent. Moreover, the title of this patent is not intended to limit the scope of this patent. For a better understanding of the present invention, please see the following detailed description and appending claims, taken in conjunction with the accompanying drawings. The scope of the present invention is pointed out in the appending claims.","The following description sets forth one or more specific embodiments of a tester of cryptographic service providers that incorporate elements recited in the appended claims. These embodiments are described with specificity in order to meet statutory written description, enablement, and best-mode requirements. However, the description itself is not intended to limit the scope of this patent.","The one or more specific embodiments, described herein, are exemplary implementations of the tester of cryptographic service providers. The inventors intend these exemplary implementations to be examples. The inventors do not intend these exemplary implementations to limit the scope of the claimed present invention. Rather, the inventors have contemplated that the claimed present invention might also be embodied and implemented in other ways, in conjunction with other present or future technologies.","An example of an embodiment of a tester of cryptographic service providers (\u201cCSPs\u201d) may be referred to as an \u201cexemplary CSP tester.\u201d","Overview","The one or more exemplary implementations, described herein, of the present claimed invention may be implemented (whole or in part) by a CSP testing system  and\/or by a computing environment like that shown in , , and .","In general, the exemplary CSP tester is a debugging and testing tool for customized cryptographic service providers (\u201cCSPs\u201d), which may also be called cryptographic solutions, cryptographic plug-ins, or cryptographic program modules. The exemplary CSP tester tests customized cryptographic solutions to ensure reliability, stability, and adherence to a given set of security conformance standards.","When the operating system (\u201cOS\u201d) registers a CSP, it identifies its cryptographic type and functionality level within that type. A cryptographic type identifies which of the standard cryptographic algorithms are being used by the CSP. Examples include RSA, DSS, and ECC. A functionality level identifies how much functionality is implemented. Examples of functionality levels include signature level only and full level, although the latter may imply the presence of optional features. For more details on this, see the section below titled \u201cCSP Classification.\u201d","The CSPs are tested based upon four classes of situations: positive, negative, scenario, and interoperability. For more details on this, see the section below titled \u201cTesting Classifications.\u201d","The crypto sub-system of the OS has a set of application programming interfaces (\u201cAPIs\u201d) that manage cryptographic procedures. This may be called \u201cCryptoAPI.\u201d In particular, the crypto sub-system provides a standard interface between the CSPs and client applications. For listing of an example of CryptoAPI that may be used by a crypto sub-system, see the section below titled \u201cOther Implementation Details.\u201d","For a CSP to be considered reliable, stable, and in compliance with a given set of security conformance standards, it must successfully operate with the set of APIs in a reliable and stable manner and it must react appropriately for the given security conformance standards. The CSPs are tested in order of increasing complexity\/sophistication in functionality from most basic\/simple to most complex\/sophisticated. As a result, CSPs are tested from the most basic APIs to the more complex APIs; from the most basic functionality level to the most complex functionality level (or at least the most complex level registered by the CSP). For more details on this, see the section below titled \u201cTesting from Less to More Complexity.\u201d","In addition, a report is generated that indicates the performance of a CSP for each combination of the test cases performed. However, rather than directly reporting the raw results, the reporting component examines and annotates the results before reporting them. If the reporting component determines that the CSP operated consistently with the underlying OS, but that in doing so the CSP implements non-optimal behavior, than the scenario in question will be further analyzed by the reporting component to accurately determine its severity. When this occurs, the reporting component displays an informative message indicating that the CSP operated correctly but still generated incorrect results. For more details on this, see the section below titled \u201cFiltered Reporting.\u201d","Exemplary CSP Testing System",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 2","FIG. 1"],"b":["140","144","148","144"]},"The CSP testing system  includes an input simulator , an output analyzer ; and a report generator .","As the name implies, the input simulator  simulates input for the subject CSP to simulate actual input from a user. Input data and requests are submitted to the CSP via the CryptoAPI, that is, the input simulator calls a given function of the CryptoAPI with a certain set of data. The CryptoAPI then does limited processing on this input data and submits the request to the CSP. The CSP performs the requested operation on the input and reports the result back to the CryptoAPI. Finally, the CryptoAPI returns the result to the input simulator. Various forms of input are simulated including valid and invalid input.","The output analyzer  examines the output from the subject CSP to determine whether the CSP behaved properly. Generally, incorrect or non-existent results indicate a problem with the subject CSP. This problem can be a bug, poor programming, improper implementation of the cryptographic algorithm, etc.","The report generator  generates a detailed report of the test results of the subject CSP. This report details the given situation, the expected results, and the actual results. This report may be displayed on a monitor, printed on paper, saved to disk (or some other storage medium), or any combination of the above. A short exemplary report is recreated below in the section titled \u201cOther Implementation Details.\u201d","In at least one implementation of exemplary CSP tester, the report generator  does more than simply report the results. It preprocess the raw results and if necessary modifies or amends them. For more details on this, see the section below titled \u201cFiltered Reporting.\u201d","CSP Classification","All CSPs are classified based upon their cryptographic type and functionality level within that type. When a customized CSP identifies itself to the crypto sub-system (for example, via a registration process), it indicates its type and functionality level.","A cryptographic type identifies which of the standard cryptographic algorithms are being used by the CSP. These are fully defined cryptography algorithm standards.","An example of such a cryptography algorithm standard is RSA (Rivest-Shamir-Adleman), a public-key encryption technology developed by RSA Data Security, Inc. The RSA algorithm has become the de facto standard for industrial-strength encryption, especially for data sent over the Internet. The RSA algorithm is also widely used for digital signatures, the purpose of which is to authenticate both a message and its signer. It is built into many software products.","Another example of such a cryptography algorithm standard is the Digital Signature Standard (DSS) as specified by the National Institute of Standards and Technology (NIST). The DSS is a standard for digital signatures.","Other examples of cryptographic types include ECC, FORTEZZA, EXCHANGE, and SSL. Within each type, there are standard levels of functionalities. A functionality level identifies how much functionality of the given type is implemented by the custom CSP. Examples of functionality levels include base; signature level only; signature and key exchange level; full level; and Schannel. Of course, depending upon the needs of each implementation, there may be many other defined levels.","Below is a table illustrating two example types (RSA and DSS) and their associated functionality levels. In addition, illustrated in Table 1 is a breakdown of the cryptographic functions that correspond to given levels of functionality.",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"182pt","align":"center"}}],"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Cryptographic","Functionality","Crypto Capabilities"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Type","Level","Key Exchange","Signature","Encryption","Hashing"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["RSA","Signature",{},"X",{},"MD5; & SHA"]},{"entry":[{},"Sign. & key","X","X",{},"MD5; & SHA"]},{"entry":[{},"Full","X","X","RC2; & RC4","MD5; & SHA"]},{"entry":[{},"Schannel","X","X","RC4; DES; or","MD5; & SHA"]},{"entry":[{},{},{},{},"3DES"]},{"entry":["DSS","Signature",{},"X",{},"MD5; & SHA"]},{"entry":[{},"DH","X","X","RC2; & RC4","MD5; & SHA"]},{"entry":[{},"Schannel","X","X","RC4; DES; or","MD5; & SHA"]},{"entry":[{},{},{},{},"3DES"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"These cryptographic capabilities (e.g., key-exchange, data signing, encryption, hashing, etc.) are known and understood by those of ordinary skill in the art.","For the purposes of brevity and clarity, a nomenclature is adopted herein to describe both the type and functionality level together of a CSP. In the nomenclature, the type and functionality level are separated by and an underscore (\u201c_\u201d) and ordered. For example, RSA_SIG is a CSP that is of type \u201cRSA\u201d and has a minimal functionality level of \u201cSIGnature.\u201d","Functionality Level Hierarchy","The functionality levels allow CSP's to be classified as functional aggregates. These levels define CSP requirements on a cryptographic capability basis. Generally, the functional divisions are based first on specific public-key algorithm support (signature versus key exchange) and then on specific symmetric algorithm support.","Functionality Levels:\n\n","These are internal classes for the exemplary CSP tester. External CSP types are mapped to one or more of these internal classes to facilitate the reuse of test cases. For example, a RSA_SCHANNEL CSP will be mapped to Levels I, II, and IV and it will be required to pass the test cases for those groups.","The hierarchy is intended to facilitate the association of testable behavior with specific CSP classes. For example, tests for Level I CSP's will be expected to work on all CSP's. This hierarchy allows test cases to be aggregated as building blocks for describing the functional expectations for each CSP class. For example, implementers of RSA_SCHANNEL CSP's will be expected to pass all tests in Levels I, II, and IV.","Testing Classifications","With the exemplary CSP tester, there are four test classifications: positive, negative, scenario, and interoperability. Generally, the subject CSP is tested for each test classification in that order. Of course, other implementations may have more, less, and\/or different classifications.","For all of these test classifications below, the subject CSP is tested to see how well it implements the CryptoAPI, which is provided by the OS to be the interface between the subject CSP and the calling application. However, only the portion of the CryptoAPI supported by the subject CSP is tested. For more details on this, see the section below titled \u201cTesting from Less to More Complexity.\u201d","Positive. The exemplary CSP tester tests the custom CSP for positive test cases. For this type of test case, the CyptoAPI should return a result indicating success (for example, a return value of TRUE). This is also the default test case set. The subject CSP is tested against all of the CryptoAPI, within the CSP's level of functionality, to determine whether the given API generates a success result when it is expected to do so.","Negative. The exemplary CSP tester tests the custom CSP for negative test cases. For this type of test case, the CyptoAPI should return a result indicating failure (for example, a return value of FALSE). The subject CSP is tested against all of the CryptoAPI within its level of functionality to determine whether the given API generate a failure result when it is expected to do so.","Specific Scenario. The exemplary CSP tester tests the custom CSP for specific scenario test cases. This type of test case uses multiple features of the CyptoAPI in tandem. The subject CSP is tested with API combinations of within its level of functionality to determine whether the CSP generates the correct results in response to the given API combinations.","Interoperability. The exemplary CSP tester tests the custom CSP for interoperability test cases. This type of test case uses multiple CryptoAPI features in tandem and at least two CSPs. The subject CSP is tested with combinations of APIs within its level of functionality and its results are compared with those generated by a pre-tested CSP (such as the default one). These results are used to determine whether the subject CSP is correctly interoperating with a pre-tested CSP.","Testing from Less to More Complexity","For the subject CSP to be considered reliable, stable, and in compliance with a given set of security conformance standards, it must successfully operate with the CyptoAPI in a reliable and stable manner and it must react appropriately for the given security conformance standards.","The subject CSP is tested in order of increasing complexity\/sophistication in functionality from most basic\/simple to most complex\/sophisticated. The subject CSP is tested from the most basic features of the CryptoAPI to the most complex features (within the level of functionality of the subject CSP). The subject CSP is tested from the most basic functionality level to the most complex functionality level (within the level of functionality of the subject CSP).","Logical Hierarchical Tiers","For illustration purposes, the following are five logical hierarchical tiers for testing the subject CSP with the CryptoAPI. From one to five, the tiers increase in level of cryptographic functionality. These tiers may be mapped to the CSP levels of functionality described above in the section titled \u201cCSP Classification.\u201d","The logical hierarchical tiers are listed on a per-API basis and represent five \u201caccess-level\u201d categories. Access to the user's public-key pairs is considered the highest level of access, followed by the ability to create session keys. The classification levels are listed in order of increasing access level.","The five logical hierarchical tiers representing five \u201caccess-level\u201d categories:\n\n","This includes all API's in the \u201cKey level\u201d which can also be used with UI-protected keys.","The following outline illustrates the above tiers in terms of example CyptoAPI groups by which they are associated:\n\n","As mentioned above, these tiers may be mapped to the CSP levels of functionality described above in the section titled \u201cCSP Classification.\u201d The following is an example of mapping between the functionality levels and the tiers:","Signature Only. This CryptoAPI subset comprises the least level of functionality for a subject CSP that provides only signing capabilities. The purpose of this level is to provide a minimum compatibility standard for all types of CSPs.\n\n","Signature and Key Exchange. (Level I (base level)+key-exchange keys) Support for key-exchange public-key pairs is required.\n\n","Full Provider. (Level II+encryption (RC2 and RC4 for PROV_RSA_FULL)) This CyptoAPI subset augments the base-level requirements with commonly used hashing and encryption algorithms.\n\n","Schannel Provider. (Level II+encryption (at least RC4, DES, or 3DES for PROV_RSA_SCHANNEL)) The functionality in CryptoAPI subsets I and II, with the addition of the following subset, is the minimum required for an Schannel CSP.\n\n","Optional CyptoAPI:\n\n","The report generator  of  produces a formatted report of the test results. For example, the output may include:\n\n","For example, each test case may have the following information associated with it.\n\n","In addition, the report generator  may filter the raw data before generating the output. This functionality can be performed by other components of the exemplary CSP tester.","This filtering provides a mechanism to handle known software inconsistencies and backward compatibility issues. Known inconsistencies should not be considered fatal test failures. This filtering process flags specific test case failures to be either more or less severe, depending on the version of the underlying OS.","Methodological Implementations of the Exemplary CSP Tester",{"@attributes":{"id":"p-0080","num":"0180"},"figref":"FIGS. 3 and 4","b":"200"},"At  of , the exemplary CSP tester establishes communication with the crypto sub-system and the subject CSP. At , it identifies the cryptographic type and functionality level of the subject CSP. This information will be used to direct the testing to the cryptographic type of the subject CSP and limit the testing to the functionality supported by the CSP.","Blocks \u2013, inclusive, form a loop. The loop is repeated for each test classification (e.g., positive, negative, scenario, and interop). One loop is performed for each test classification. For example, the first time through the loop the present test classification is \u201cpositive\u201d; the next time it is \u201cnegative\u201d; next is \u201cscenarios\u201d; and last is \u201cinterop.\u201d","Within the loop, at , the exemplary CSP tester tests the subject CSP based upon the present test classification and its identified level of functionality. The subject CSP is tested with some or all of the CryptoAPI of the crypto sub-system. More details of this block are shown in  and discussed below.","After testing, at , the test results are sent to the report generator. At , the report generator examines this raw data to flag apparent incorrect results that are actually correct. Thus, the report generator filters the raw data and produces a warning, or reduces the severity of the reported error, where appropriate.","At , the report is generated. It may be printed, displayed, stored, etc. The functions of blocks \u2013 may be performed outside of this loop, if so desired.","At , the loop returns back to block  and the next test classification is employed. If all of the test classifications have been processed, then this methodological implementation ends at .","In , blocks \u2013, inclusive, form a first loop. These blocks also represent block  of , but in more detail. This first loop is repeated for each hierarchical tier from least to most complicated (e.g., Signature Only, Signature and Key Exchange, and Full).","For example, the first time through the loop the present hierarchical tier is \u201cSignature Only\u201d; the next time it is \u201cSignature and Key Exchange\u201d; and last is \u201cFull.\u201d This example assumes that the subject CSP has the top level of functionality. If the subject CSP is identified as having Level I (signature only), then first time through the loop the present hierarchical tier is \u201cSignature Only\u201d and that is the last time through.","Blocks \u2013, inclusive, form a second loop. The second loop is nested inside of the first loop. This second loop is repeated for each feature of the CryptoAPI (or given combination of features) within the present hierarchical tier. The first time through the loop the CSP may be tested with one feature of the CryptoAPI; the next time it will be tested with another feature; and so forth until all features of the CryptoAPI within a given hierarchical tier are tested. If the present test classification is \u201cscenario\u201d or \u201cinterop\u201d, then specific combinations of features of the CryptoAPI are tested together during each loop. If the present test classification is \u201cinterop\u201d, then specific combinations of features CryptoAPI are tested together during each loop with at least one other CSP.","At , the exemplary CSP tester tests the subject CSP using the present feature of the CryptoAPI (or given combinations of features) and the present testing classification (see  regarding loop of blocks \u2013). This may be considered a \u201cdiscrete sub-testing\u201d since one or more specific features of the CryptoAPI (which have a given level of functionality) is discretely tested with the subject CSP.","Exemplary Computing System and Environment",{"@attributes":{"id":"p-0091","num":"0191"},"figref":"FIG. 5","b":["900","900"]},"The exemplary computing environment  is only one example of a computing environment and is not intended to suggest any limitation as to the scope of use or functionality of the computer and network architectures. Neither should the computing environment  be interpreted as having any dependency or requirement relating to any one or combination of components illustrated in the exemplary computing environment .","The exemplary CSP tester may be implemented with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use include, but are not limited to, personal computers, server computers, thin clients, thick clients, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The exemplary CSP tester may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The exemplary CSP tester may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","The computing environment  includes a general-purpose computing device in the form of a computer . The components of computer  can include, by are not limited to, one or more processors or processing units , a system memory , and a system bus  that couples various system components including the processor  to the system memory .","The system bus  represents one or more of any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, an accelerated graphics port, and a processor or local bus using any of a variety of bus architectures. By way of example, such architectures can include an Industry Standard Architecture (ISA) bus, a Micro Channel Architecture (MCA) bus, an Enhanced ISA (EISA) bus, a Video Electronics Standards Association (VESA) local bus, and a Peripheral Component Interconnects (PCI) bus also known as a Mezzanine bus.","Computer  typically includes a variety of computer readable media. Such media can be any available media that is accessible by computer  and includes both volatile and non-volatile media, removable and non-removable media.","The system memory  includes computer readable media in the form of volatile memory, such as random access memory (RAM) , and\/or non-volatile memory, such as read only memory (ROM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within computer , such as during start-up, is stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently operated on by the processing unit .","Computer  may also include other removable\/non-removable, volatile\/non-volatile computer storage media. By way of example,  illustrates a hard disk drive  for reading from and writing to a non-removable, non-volatile magnetic media (not shown), a magnetic disk drive  for reading from and writing to a removable, non-volatile magnetic disk  (e.g., a \u201cfloppy disk\u201d), and an optical disk drive  for reading from and\/or writing to a removable, non-volatile optical disk  such as a CD-ROM, DVD-ROM, or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are each connected to the system bus  by one or more data media interface . Alternatively, the hard disk drive , magnetic disk drive , and optical disk drive  can be connected to the system bus  by one or more interface (not shown).","The disk drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules, and other data for computer . Although the example illustrates a hard disk , a removable magnetic disk , and a removable optical disk , it is to be appreciated that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes or other magnetic storage devices, flash memory cards, CD-ROM, digital versatile disks (DVD) or other optical storage, random access memories (RAM), read only memories (ROM), electrically erasable programmable read-only memory (EEPROM), and the like, can also be utilized to implement the exemplary computing system and environment.","Any number of program modules can be stored on the hard disk , magnetic disk , optical disk , ROM , and\/or RAM , including by way of example, an operating system , one or more application programs , other program modules , and program data .","A user can enter commands and information into computer  via input devices such as a keyboard  and a pointing device  (e.g., a \u201cmouse\u201d). Other input devices  (not shown specifically) may include a microphone, joystick, game pad, satellite dish, serial port, scanner, and\/or the like. These and other input devices are connected to the processing unit  via input\/output interfaces  that are coupled to the system bus , but may be connected by other interface and bus structures, such as a parallel port, game port, or a universal serial bus (USB).","A monitor  or other type of display device can also be connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , other output peripheral devices can include components such as speakers (not shown) and a printer  which can be connected to computer  via the input\/output interfaces .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as a remote computing device . By way of example, the remote computing device  can be a personal computer, portable computer, a server, a router, a network computer, a peer device or other common network node, and the like. The remote computing device  is illustrated as a portable computer that can include many or all of the elements and features described herein relative to computer .","Logical connections between computer  and the remote computer  are depicted as a local area network (LAN)  and a general wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When implemented in a LAN networking environment, the computer  is connected to a local network  via a network interface or adapter . When implemented in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the wide network . The modem , which can be internal or external to computer , can be connected to the system bus  via the input\/output interfaces  or other appropriate mechanisms. It is to be appreciated that the illustrated network connections are exemplary and that other means of establishing communication link(s) between the computers  and  can be employed.","In a networked environment, such as that illustrated with computing environment , program modules depicted relative to the computer , or portions thereof, may be stored in a remote memory storage device. By way of example, remote application programs  reside on a memory device of remote computer . For purposes of illustration, application programs and other executable program components such as the operating system are illustrated herein as discrete blocks, although it is recognized that such programs and components reside at various times in different storage components of the computing device , and are executed by the data processor(s) of the computer.","Computer-Executable Instructions","An implementation of an exemplary CSP tester may be described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.","Exemplary Operating Environment",{"@attributes":{"id":"p-0109","num":"0209"},"figref":["FIG. 5","FIG. 5"],"b":["900","928","930","926"]},"The operating environment is only an example of a suitable operating environment and is not intended to suggest any limitation as to the scope or use of functionality of the exemplary CSP tester(s) described herein. Other well known computing systems, environments, and\/or configurations that are suitable for use include, but are not limited to, personal computers (PCs), server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, programmable consumer electronics, wireless phones and equipments, general- and special-purpose appliances, application-specific integrated circuits (ASICs), network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","Computer Readable Media","An implementation of an exemplary CSP tester may be stored on or transmitted across some form of computer readable media. Computer readable media can be any available media that can be accessed by a computer. By way of example, and not limitation, computer readable media may comprise \u201ccomputer storage media\u201d and \u201ccommunications media.\u201d","\u201cComputer storage media\u201d include volatile and non-volatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by a computer.","\u201cCommunication media\u201d typically embodies computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as carrier wave or other transport mechanism. Communication media also includes any information delivery media.","The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared, and other wireless media. Combinations of any of the above are also included within the scope of computer readable media.","Other Implementation Details","In this section are other implementation details.","Examples of CyptoAPI","The following are examples of CryptoAPI that may be used with implementations of the present claimed invention. These particular CryptoAPI are part of the Microsoft\u00ae Windows\u00ae 2000 operating system and more information about them may be found in the operating system's platform SDK (software developer's kit).","Example CryptoAPI:\n\n","The following is a short example report of the exemplary CSP tester:",{"@attributes":{"id":"p-0119","num":"0244"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"[ OPT]CSP under test: Company Strong Cryptographic Provider"},{"entry":"[ OPT]CSP type: PROV_RSA_FULL"},{"entry":"[ OPT]Test case set: Positive test cases. API's should return TRUE"},{"entry":"[ ----]----------------------------------------"},{"entry":"[ ERR1]Test case 2.32: ERROR_CONTINUE"},{"entry":"[ API]CryptGetProvParam"},{"entry":"[ INFO]Returned: False"},{"entry":"[ INFO]Error type: The API returned bad data"},{"entry":"[ INFO]Known error: Yes"},{"entry":"[ INFO]Actual error code: 0x0 ( )"},{"entry":"[ INFO]Test case description: CryptGetProvParam PP_NAME is"},{"entry":"not Unicode"},{"entry":"[ ----]----------------------------------------"},{"entry":"[ ERR1]Test case 12.7: ERROR_CONTINUE"},{"entry":"[ API]CryptSetKeyParam"},{"entry":"[ INFO]Returned: False"},{"entry":"[ INFO]Error type: API failed unexpectedly"},{"entry":"[ INFO]Known error: Yes"},{"entry":"[ INFO]Actual error code: 0x80090005 (Bad Data. )"},{"entry":"[ INFO]Test case description: Attempt to change key to exportable"},{"entry":"[ ----]----------------------------------------"},{"entry":"[ ERR1]Test case 12.9: ERROR_CONTINUE"},{"entry":"[ API]CryptSetKeyParam"},{"entry":"[ INFO]Returned: False"},{"entry":"[ INFO]Error type: The API returned bad data"},{"entry":"[ INFO]Known error: Yes"},{"entry":"[ INFO]Actual error code: 0x0 ( )"},{"entry":"[ INFO]Test case description: CryptGetKeyParam KP_PERMISSIONS"},{"entry":"should now include CRYPT_EXP"},{"entry":"ORT"},{"entry":"[ ----]----------------------------------------"},{"entry":"[ KEY]Creating user protected key. You should see UI."},{"entry":"[ ----]----------------------------------------"},{"entry":"[ KEY]Creating user protected key. You should see UI."},{"entry":"[ ----]----------------------------------------"},{"entry":"[ ERR1]Test case 28.20: ERROR_CONTINUE"},{"entry":"[ API]CryptGenKey"},{"entry":"[ INFO]Returned: False"},{"entry":"[ INFO]Error type: API failed unexpectedly"},{"entry":"[ INFO]Known error: Yes"},{"entry":"[ INFO]Actual error code: 0x80090009 (Invalid flags specified. )"},{"entry":"[ ----]----------------------------------------"},{"entry":"[ ERR1]Test case 28.21: ERROR_CONTINUE"},{"entry":"[ API]CryptDestroyKey"},{"entry":"[ INFO]Returned: False"},{"entry":"[ INFO]Error type: API failed unexpectedly"},{"entry":"[ INFO]Known error: Yes"},{"entry":"[ INFO]Actual error code: 0x57 (The parameter is incorrect. )"},{"entry":"[ ----]----------------------------------------"},{"entry":"[ ERR1]Test case 28.28: ERROR_CONTINUE"},{"entry":"[ API]CryptGenKey"},{"entry":"[ INFO]Returned: False"},{"entry":"[ INFO]Error type: API failed unexpectedly"},{"entry":"[ INFO]Known error: Yes"},{"entry":"[ INFO]Actual error code: 0x80090009 (Invalid flags specified. )"},{"entry":"[ ----]----------------------------------------"},{"entry":"[ ERR1]Test case 28.29: ERROR_CONTINUE"},{"entry":"[ API]CryptDestroyKey"},{"entry":"[ INFO]Returned: False"},{"entry":"[ INFO]Error type: API failed unexpectedly"},{"entry":"[ INFO]Known error: Yes"},{"entry":"[ INFO]Actual error code: 0x57 (The parameter is incorrect. )"},{"entry":"[ ----]----------------------------------------"},{"entry":"[ ERR1]Test case 28.36: ERROR_CONTINUE"},{"entry":"[ API]CryptGenKey"},{"entry":"[ INFO]Returned: False"},{"entry":"[ INFO]Error type: API failed unexpectedly"},{"entry":"[ INFO]Known error: Yes"},{"entry":"[ INFO]Actual error code: 0x80090009 (Invalid flags specified. )"},{"entry":"[ ----]----------------------------------------"},{"entry":"[ ERR1]Test case 28.37: ERROR_CONTINUE"},{"entry":"[ API]CryptDestroyKey"},{"entry":"[ INFO]Returned: False"},{"entry":"[ INFO]Error type: API failed unexpectedly"},{"entry":"[ INFO]Known error: Yes"},{"entry":"[ INFO]Actual error code: 0x57 (The parameter is incorrect. )"},{"entry":"----------------"},{"entry":"There were 46 test blocks."},{"entry":"46 (100%) blocks attempted, 43 (93%) successful."},{"entry":"PASS\u200391% (42\/46) [Attempted] [Successful]"},{"entry":"WARN\u2003\u20022% ( 1\/46) [Attempted] [Successful]"},{"entry":"ERR1\u2003\u20026% ( 3\/46) [Attempted]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Although the invention has been described in language specific to structural features and\/or methodological steps, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or steps described. Rather, the specific features and steps are disclosed as preferred forms of implementing the claimed invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The same numbers are used throughout the drawings to reference like elements and features.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
