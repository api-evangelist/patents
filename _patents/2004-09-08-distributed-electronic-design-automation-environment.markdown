---
title: Distributed electronic design automation environment
abstract: PCB Logical design data is stored in a database according to a connectivity-based data model. Circuit functional blocks, inputs and outputs of functional blocks, and signals are stored as separate data structures. Those structures may be edited by users at separate clients during concurrent editing sessions. Profile data for each of multiple users specifies logical design data elements accessible by, and PCB design software to be provided to, that user. The PCB design software may be plug-ins executable within a web browser at a client, and the client computers may communicate with the database via the Internet. Layout data may also be stored in the database, with elements of the layout data mapped to elements of the logical design data. Constraint data may also be stored in the database, with elements of the constraint data being mapped to elements of the layout data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07546571&OS=07546571&RS=07546571
owner: Mentor Graphics Corporation
number: 07546571
owner_city: Wilsonville
owner_country: US
publication_date: 20040908
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["COPYRIGHT NOTICE","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS","CONCLUSION"],"p":["A portion of the disclosure of this patent document may contain material which is subject to copyright protection. To the extent that it does, the copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever. The following notice applies to the software and data as described below and in the drawings hereto: Copyright \u00a9 2004, Mentor Graphics Corp., All Rights Reserved.","This invention relates to the field of electronic design automation tools, and more specifically, to concurrent design activities distributed among multiple users.","As used throughout this specification and claims, a \u201cdesign\u201d for an electronic device generally refers to information needed to construct that device. As can be appreciated from this broad definition, an electronic design has numerous aspects. Logical aspects of a design (sometimes known as a logical design or the \u201cfront end\u201d design) include the identification of various functional elements. These functional elements may be specific electronic components (e.g., particular microprocessors, memory chips, and other components). These functional elements may also be more generic (e.g., an AND gate, an OR gate, a multiplexer, a resistor or capacitor having a certain resistance or capacitance value, etc.). The logical aspects of a design also include interconnections between inputs and outputs of these functional elements. Physical aspects of a design (also known as the \u201clayout\u201d or the \u201cback end\u201d design) include the actual size and location of various physical components associated with logical design elements. Notably, there is not necessarily a one-to-one correspondence between logical and physical elements. For example, a logical design element such as a gate must be implemented as an actual physical component. However, available chips and other physical components may have multiple \u201cslots,\u201d each of which contains a separate gate or other element having its own input and output pins. A single physical component may thus correspond to multiple logical elements. There are numerous other logical and physical design elements. In many cases, a particular element in the logical domain will have no directly corresponding element in the physical domain, and vice versa.","Traditionally, the schematic diagram has been the basis for electronic design. More specifically, front end designers often record the various functional elements of the logical design and the necessary interconnections on one or more graphical schematic diagrams. After completing the logical design, the front end designers then provide one or more sheets of schematic diagrams to the back end designers. The front end designers might also include a netlist (i.e., a list of all signals in the logical design and the logical elements connected to each signal) and information regarding constraints (e.g., restrictions on the manner in which components and nets can be placed and\/or connected). The netlist is typically a separate document (or computer file), and the constraint information might be annotated onto the schematic or provided as a separate document. Using this front end information, the back end designers determine the actual placement of physical components on one or more circuit boards and route the physical connections (e.g., conductive circuit board traces) between the pins of those components. Frequently, the back end designers must also assign elements from the schematic to a particular physical component (e.g., assigning a gate to a slot of a chip). In some cases, the back end designer may add a physical component (e.g., a filter capacitor) to the layout design that is not represented on the schematics, or may make other types of changes that may implicitly affect the logical design.","This traditional approach to electronic design presents numerous problems. In the past, typical designs included numerous Small Scale Integration (SSI) and\/or Medium Scale Integration (MSI) parts, and perhaps a few Large Scale Integration (LSI) parts. The SSI and MSI parts would typically have a limited number of pins, and the LSI parts might have on the order of 100 pins. With such designs, a schematic can be a useful representation. As designs have evolved, however, the schematic diagram has become less valuable. For example, current designs may include LSI or Very Large Scale Integration (VLSI) parts having up to thousands of pins. Such parts can be difficult or impossible represent on a single sheet of a schematic diagram. Drawing pieces of the same part on multiple drawing sheets can be tedious, and the resulting diagram is often confusing. Similarly, modern designs often have complex patterns of interconnections which run throughout the entire design, and must thus span numerous sheets of schematic diagrams. Following such interconnection patterns across multiple sheets is also tedious and confusing.","A schematic-driven design approach has numerous other shortcomings. Using traditional schematic-driven methods, front end and back end design are generally performed as serial processes with limited communication between the two. However, the complexity of electronic designs and market pressures to rapidly complete designs are continuing to increase. In such an environment, it is beneficial (and often necessary) for front and back end design tasks to be performed concurrently. In turn, this requires rapid (and sometimes frequent) exchange of design information between front and back ends. Existing methods inhibit such a rapid exchange, as entire design files (e.g., schematics, constraint data, net lists, etc.) must be transferred and then converted to an appropriate form. For example, a back end designer receiving an updated schematic must identify what symbols and\/or interconnections have changed and then determine whether a part must be added, a trace added or re-routed, etc.","Traditional methods can also inhibit collaboration among multiple front-end designers. Separating a design project into manageably-sized portions and assigning those portions to different designers can be difficult. Moreover, managing design data as a collection of design data computer files limits the granularity with which design data can be \u201clocked\u201d to prevent conflicting edits by multiple users. File-based systems pose additional challenges for designers wishing to collaborate on a project. For example, a designer may often be unsure whether he or she has all of the files needed for a particular project. This also makes transfer of a design between designers a time-consuming process.","Traditional electronic design methods are increasingly less valuable in other ways. In addition to often having more LSI and VLSI parts, modern designs are becoming increasingly dense. In other words, designs must fit into increasingly smaller spaces. In turn, this requires printed circuit boards (PCBs) to have more and more layers. Modern designs also have increasing numbers of high speed signals. These factors make constraints upon the physical design more and more critical. Both front and back end designers must be able to track, access and\/or modify these constraints. However, existing methods for constraint management become less useful as designs become more complex. Constraint data must often be synchronized among multiple users in real time, and waiting for an updated schematic (with revised constraint annotations) or a separate constraint document can require too much time. More important, lack of an automated system for synchronizing constraint data may result in a failure to effectively communicate constraint data between front and back ends.","Traditional design methods present other challenges for numerous persons working in parallel, particularly when those persons are in widely dispersed locations. For example, logical and\/or layout design may be performed by teams of engineers working in different cities (or even in different countries). Various design tasks may be outsourced to other companies. Still other groups (e.g., manufacturing, purchasing) located in other locations may have need for the information contained in the layout and\/or logical design data. Ensuring that all of these groups have the appropriate software needed to edit or view design data can impose significant administrative burdens. Yet a further complication arises when trying to limit the type of information accessible by certain groups. For example, purchasing department personnel may need access to design data when determining which parts to order, but do not need the ability to edit that design. As another example, it would be highly advantageous if a company could more easily assign a design task to an outside designer working for another company, provide that designer with the necessary software tools for the assigned task, and limit the designer's access to design data relevant to that task.","For these and numerous other reasons, there remains a need for improved systems and methods for electronic design automation.","In at least some embodiments of the invention, logical design data for a PCB is stored in a database. The design data is organized according to a connectivity-based data model. Also stored are profiles for multiple users. The profile data for each user specifies logical design data elements accessible by that user and PCB design software to be provided to that user for accessing or editing logical design data. In accordance with the stored profiles, elements of the logical design data and one or more PCB design software programs are transmitted to client computers. The PCB design software may include plug-ins executable within a web browser at a client. Logical design data edits are received from the clients and applied to the logical design data stored in the database.","Additional embodiments of the invention include storing PCB logical design data which is organized according to a connectivity-based data model. In some embodiments, circuit functional blocks, inputs and outputs of functional blocks, and signals are stored as separate data structures. Those separate data structures may be edited by users at separate clients during concurrent editing sessions conducted at said separate clients. Still further embodiments include scripted design data objects, each of the scripted design data objects including at least one data object and at least one associated script. An associated script is executable to automatically modify a data object.","In at least some embodiments, logical design data and layout data are stored in a database. Elements of the layout data are mapped to elements of the logical design data. Edits to logical design data are automatically mapped to layout design data. Constraint data may also be stored in the database, with elements of the constraint data being mapped to elements of the layout data.","Yet other embodiments of the invention include automated change requests. A request to edit one or more logical design data elements is received from a first of plural users. A change request message is then sent to others of the plural users. That message identifies the requested edit and offers the other users the ability to approve the requested edit. Upon receiving approvals from at least a portion of the users receiving the change request message, a database is automatically updated to include the requested edit. Still further embodiments include filtering notifications, received by a user, of logical design data edits by other users.","These and other features and advantages of the present invention will be readily apparent and fully understood from the following detailed description of preferred embodiments, taken in connection with the appended drawings.","Connectivity-Centric Data Model","In many parts of the design process (in both the front and back ends), connectivity between circuit elements is more critical than a particular graphical representation of the circuit. , a schematic diagram for a portion of a hypothetical circuit , illustrates this point. Included in  are two flip-flops  and , an AND gate  and a four-way AND gate . Also shown in  are interconnections between inputs and outputs of these circuit elements, as well as connections to various signal lines (e.g., \u201cClock,\u201d \u201cData,\u201d etc.) connected to other circuit elements not shown in . Although a schematic such as  may assist in visualizing signal flows and in understanding other aspects of a circuit design, the specific graphical form and arrangement of circuit element symbols is generally not critical to a front end designer. For example, the logical functionality of the circuit in  is unaffected if AND gate  is reoriented and moved to a different location (shown in dashed lines). A schematic diagram is similarly not critical to a back end designer laying out a circuit represented by the schematic. The arrangement of symbols on a schematic is generally not used when determining the placement of actual physical components on a printed circuit board (PCB), and the precise arrangement of signal lines on a schematic diagram is generally unhelpful when routing PCB traces between component pins.","Accordingly, at least some embodiments of the invention implement a connectivity-based data model for electronic design. Such a data model can be stored and manipulated non-graphically, and offers numerous advantages (as described herein). In at least some of these embodiments, a connectivity-based data model describes a circuit design using the concepts of cells, ports and nets. A cell is a functional block of a circuit. A cell may be an individual circuit element (e.g., a single microprocessor, memory chip, capacitor, AND gate, etc.), or may be a collection of individual elements. A port is an input and\/or output of a cell. A net is a signal communicated to or from one or more ports.",{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 2","FIG. 1","FIG. 2","FIG. 2"],"b":["2","4","6","8","1","2","3","4","2","1","4","4","6","1","2","3","8","1","4","5"],"o":["Q ","Q"]},"Cell E is shown in  with a broken line surrounding cells A and B. The ports of cell E are labeled in  as E_ through E_ and represent inputs provided to, or outputs from, the functional block defined by cell E. Cell E also includes multiple nets E_a through E_f connecting ports of cells A and B and of cell E. Net E_a connects ports E_, A_ and B_. Net E_b connects ports E_ and A_, and net E_c connects ports A_ and E_. Net E_d connects ports A_ and B_, net E_e and connects ports B_ and E_, and net E_f connects ports B_ and E_. Cell F is shown with a broken line surrounding cells C and D, and has ports F_ through F_ and internal nets F_a through F_g. Additional nets connecting cells E and F to each other or to additional signals include \u201cClock,\u201d \u201cData\u201d through \u201cData,\u201d and \u201cNet\u201d through \u201cNet.\u201d Some of these nets may be \u201cglobal,\u201d i.e., they may run throughout the entire design (or throughout much of the design) and connect to numerous other cells (either single- or multi-element cells). Other nets may be \u201clocal,\u201d i.e., only connecting a few cells.","Cells E and F are arbitrarily defined for purposes of example. However, a designer might choose to define a cell to include other cells for various reasons. For example, a particular collection of logical elements may represent a functional block that the designer will use in several parts of a circuit design, or perhaps in several different circuit designs. Instead of recreating individual component cells for those logical elements (and their interconnections) in each of multiple locations, the designer simply reproduces the multi-component cell in another part of the design.","By representing a circuit design as a collection of cells, ports and nets, the design can readily be described non-graphically. For example, a circuit design can be stored as a collection of tables in a relational database.  show a simplified example of such storage as applied to the design of .  is a table titled \u201cProjects.\u201d Each row in the \u201cProjects\u201d table corresponds to a particular design project, identified by the value in the first column. In the present example, a row corresponds to the design of  (renamed \u201cBoard \u201d for convenience). Additional columns hold values identifying cells of the project.  is a table labeled \u201cCells,\u201d and contains a separate row for each cell. Fields of  hold values identifying cells within (\u201ccontained cell\u201d), and ports of, a cell to which a row corresponds.  is a \u201cPorts\u201d table, each row of which corresponds to a port. The fields of the \u201cports\u201d table rows hold values identifying the cell for which a particular port is an input and\/or output, as well as nets connected to that port.  is a \u201cNets\u201d table. Each row of  corresponds to a net, and has fields identifying ports to which that net connects.","Although storing data for the design of  in the tables of  may initially appear more complicated than a graphic representation, such storage offers numerous advantages. Data can be accessed more quickly and to a finer degree of granularity than is possible with a graphical representation. Moreover, adding additional design information is a relatively simple matter of adding new fields and\/or tables. Use of tables also facilitates rapid identification of circuit elements of interest. For example, a user can determine all components receiving a particular signal by using the Nets table. This would generally be much faster than attempting to find the same information from a complex schematic.","Still further advantages can be obtained through use of an object-oriented design data model. An object-oriented approach offers many of the advantages of tables such as in  (e.g., accessing design data rapidly and to a fine degree of granularity), but simplifies development and distribution of application programs for editing and managing design data. In at least some embodiments, cells, ports and nets are stored as objects. As will be understood by persons skilled in the art, an \u201cobject\u201d is a data structure that may contain both data values and programming routines (also known as methods). The methods within an object can be configured to access data within the object, to replicate the object, to create other objects, to modify data within other objects, and for numerous other purposes. In at least some embodiments of the invention, an object-oriented design data model is implemented using the JAVA programming language available from Sun Microsytems, Inc. of Santa Clara, Calif. Details of the JAVA programming language are well known, and available from, e.g., Sun Microsystems at <http:\/\/www.sun.com>.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 4","b":["22","26","26","38"]},"The DDOM includes a main object . The main object can be analogized to a container for other objects of the DDOM. Main object  is often the starting point from which other objects are accessed. For example, when initially loading logical data for one or more designs, main object  is first accessed so as to determine what other DDOM objects may be available. In some cases, main object  also detects various events that occur in a program for editing logical design data. By way of example, a user may select a graphically-displayed icon corresponding to a logical design element. Main object  would detect that selection event and pass the necessary data to one or more other DDOM objects. As another example, and as discussed more fully below, objects within various other data models could be accessed and\/or modified. Main object  detects such events for other object model objects and then invokes one appropriate methods within one or more DDOM objects.","Associated with main object  are one or more Project objects (block ). Each project object corresponds to a particular design project (e.g., an effort to develop a specific electronic device or a portion thereof). So as not to confuse the general concept of a \u201cproject\u201d with a Project data object, a Project data object will hereinafter be called a \u201cProject object.\u201d Each Project object has name, version and unique identification (unique id) fields. As used herein in connection with describing an object type, \u201cfield\u201d refers generically to a type of information contained or referenced by an object. When used in this context, \u201cfield\u201d does not require that an object contain a table or other specific type of data structure. A field within an object may be a name\/value pair (e.g., name=Cell ), a pointer or other reference to a value stored elsewhere, or may be any of various other types of data structures. The name field may hold a name that a designer has assigned to a particular project, and which will be used by (or displayed to) the designer when accessing project design data in a computerized electronic design automation (EDA) system. For example, a design for an input\/output interface board for a new computer might be named \u201cIO Interface.\u201d Each Project object also has a version. For example, one or more designers may create multiple versions of design data for a particular project in order to maintain information about alternative designs. As one illustration, a first designer may disagree with design changes made by a second designer. The first designer may therefore save a separate copy of the design data that does not include the second designer's changes. The version field for a Project object may hold a number or other alphanumeric value. The unique id for a Project object is an identifier used to reference the Project object by other DDOM objects and elsewhere in an EDA. In some embodiments, the unique id is an alphanumeric string (e.g., \u201cABCDEFG123456789\u201d) that is assigned automatically when the object is created.","Associated with a Project object may be one or more Attribute objects (block ). An Attribute object represents a name=value pair used to link some type of additional information to the object associated with the Attribute object. For example, an Attribute object associated with a Project object may be used to link a lifecycle state to the object (e.g., \u201cLifecycle State=Under Construction\u201d; lifecycle states are described below), to identify permission levels or roles of users authorized to access the object, etc. In addition to name, value, version and unique id fields, an Attribute object may also have context value fields, which are described below.","Each Project object may have one or more associated Cell objects (block ). As discussed in connection with , a cell conceptually refers to a functional block of a circuit. That block may be a single logical element (e.g., one resistor) or may be a collection of logical elements and their interconnections. A Cell Object generally corresponds to a description of a functional block. So as not to confuse the general concept of a \u201ccell\u201d with a Cell data object, a Cell data object will hereinafter be called a \u201cCell object.\u201d As with a Project object, a Cell object also has name, version and unique id fields. Associated with a Cell object may be one or more Attribute objects (a double-headed arrow between blocks  and  is omitted for clarity).","As described in more detail below, an upper level of a design hierarchy can be represented as a single Cell Object. For example, the entire design of  could correspond to a single Cell Object named \u201cTop.\u201d A CellInstance Object (block ) corresponds to an instantiation of a Cell Object. By way of illustration, the functional block corresponding to a \u201cTop\u201d Cell Object of the  design could be replicated in other designs. Those replicated blocks (which need not be identical to each other) would correspond to separate CellInstance objects. Each of those CellInstance objects would be a separate instantiation of the \u201cTop\u201d Cell object. Each CellInstance object has name, version and unique id fields, and may have one or more associated Attribute objects (a double-headed arrow between blocks  and  is omitted for clarity). Additional aspects of Cell and CellInstance objects are discussed below.","Associated with a Cell object may be one or more Representation objects (block ). As indicated above, a Cell object corresponds to a functional block of a design. That functional block can often be described using various combinations of logical sub-elements and interconnections between those sub-elements. Although alternative representations of the same cell may often correspond to blocks of sub-elements that perform identical functions, this need not be the case. Each Representation object also has name, version and unique id fields. Each Representation object may also have one or more associated Attribute objects. So as not to confuse the diagram of , a double-headed arrow connecting blocks  and  is omitted from .","As seen in , blocks  (Cell) and  (CellInstance) are linked directly by a single arrow line, as well as indirectly through block  (Representation). It should be remembered, however, that the blocks in  (with the exception of block ) represent object types, not individual objects per se. Thus,  does not require that a CellInstance object be an instantiation of the Cell object with which it is indirectly linked via a Representation object. This is shown diagrammatically in , in which the blocks do represent individual objects. For simplicity, objects of certain types described in  are not included in . Cell object \u2032 has an associated Representation object \u2032, which has associated CellInstance Objects \u2032 and \u2032. CellInstance object \u2032 is an instantiation of Cell object \u2033 and CellInstance object \u2032 is an instantiation of Cell object \u2032\u2033.","Returning to , each Cell object is also associated with one or more Port objects (block ). Each Port object corresponds to an input to and\/or output of a functional block corresponding to a Cell object with which the Port object is associated. So as not to confuse the general concept of a \u201cport\u201d with a Port data object, a Port data object will hereinafter be called a \u201cPort object.\u201d As with other object types, each Port object has name, version and unique id fields, and may have one or more associated Attribute objects (a double-headed arrow between blocks  and  is omitted for clarity). Each Port object further has scalar, bus and bundle fields to indicate whether the corresponding port is of a scalar, bus or bundle type. A scalar port connects to a scalar net, and receives (or outputs) a single bit signal. Examples of scalar ports include ports which receive or output a clock or reset signal, a prescribed voltage level (e.g., \u201cVDD\u201d), etc. A bus port connects to a bus net, and receives a multibit signal. An example includes an N-bit wide memory addressing line. A bundle port connects to a bundle net, and receives (or outputs) a combination of bus and scalar signals.","Similarly, a CellInstance object (block ) may have one or more associated PortInstance objects (block ). Each PortInstance object corresponds to an input to (our output from) the functional block corresponding to an associated CellInstance object. A PortInstance object has name, version and unique id fields, and may have one or more associated Attribute objects (a double-headed arrow between blocks  and  is omitted for clarity). Like Port objects, PortInstance objects also have fields to indicate whether the corresponding port is of a scalar, bus or bundle type. A PortInstance object is an instantiation of a Port object. In particular, a PortInstance object is an instantiation of a Port object associated with the Cell object from which the CellInstance object is instantiated.","Both Port and PortInstance objects are associated with Connection objects (block ). A Connection object (which has name, version and unique id fields) links a Port or PortInstance object to a Net object (block ). Each Net object corresponds to a net providing a signal to (or receiving a signal from) the linked Port or PortInstance object. Accordingly, each Net object also has fields indicating whether the corresponding net is of a scalar, bus or bundle type. A Net object also has name, version and unique id fields, and may have one or more associated Attribute objects (a double-headed arrow between blocks  and  is omitted for clarity). Because a single Net may be connected to many ports, the asterisk is on the block  side of the line connecting blocks  and .","Returning to block , a Cell object is associated with one or more Configuration objects. A Configuration object contains data indicating which Representation object is to be used when instantiating a cell at a particular hierarchical design level. The concept of design hierarchy can be illustrated with . If the entire design of  is treated as a single cell, that entire-design cell would be at the highest (or \u201ctop\u201d) level of the design hierarchy. Cells E and F are at intermediate levels of the hierarchy, while cells A, B, C and D are at lower levels of the hierarchy.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIGS. 5B-5E","FIG. 5B","FIG. 5B","FIG. 5B","FIG. 5B"],"b":["1","1","1","1","1","1","1","1","1","1","1","1","1","1","1","2","2","2","1","2"],"i":["d ","s ","d ","s","d ","d","s ","s","d ","d ","d ","s "]},"The Cell  object has a single associated Configuration object (Cfg) and a single, default Representation object (R). Associated with the Robject are CellInstance objects CI and CIX. Object CIX is an instantiation of a Cell object not shown in , while object CI is an instantiation of Cell object Cell .","Cell object Cell  has two associated Configuration objects Cfgand Cfgand two associated Representation objects Rand R. Configuration object Cfgspecifies that a default representation (i.e., the representation corresponding to object R) should be used for the Cell  functional block. Configuration object Cfgspecifies that a specified representation (i.e., the representation corresponding to object R) should be used for the Cell  functional block. The Robject is associated with CellInstance objects CI and CIW. Object CIW is an instantiation of a Cell object not shown in , while object CI is an instantiation of Cell object Cell . The Cell  object corresponds to the lowest level of the design hierarchy (e.g., a single component such as a capacitor or resistor), and there is only one representation of the corresponding functional block. The Robject is associated with CellInstance objects CIZ and CIT; CIZ and CIT are instances of other Cell objects not included in .",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 5C","FIG. 5B"],"b":["1","2","2","2","1","2","3","3","3","2","3","4","4","3"],"i":["d","d"]},{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIGS. 5D and 5E","FIG. 5D","FIG. 5D","FIG. 5E","FIGS. 5D and 5E"],"b":["1","1","1","1","1","2","2","2","2","3","3","3","3","4","1","3","3","3","3","3","3","1","1","3","3"],"i":["s ","s ","s","d ","s ","s ","s ","d","s ","s ","s "]},"Two additional blocks of the DDOM are blocks  (Library object type) and  (Variant object type). The DDOM may have one or more Library objects, each of which is associated with one or more Cell objects. In this manner, each Library object corresponds to a collection (or a library) of various Cell objects. In some cases, a library may be a database identifying actual physical components that can be used on a PCB (e.g., resistors, capacitors, memory chips, etc.); associated with those components may be Cell objects which can be added to a design (i.e., associated with a Project object). A library may also include other types of Cell objects which can be accessed by users and added to a project (i.e., associated with a Project object). For example, a Cell object may previously have been developed for a functional block used in numerous types of projects. Instead of recreating that functional block each time it is needed in a new project, the pre-existing Cell object can be associated with new Project objects. A Library object has name, version and unique id fields. Each Projects object is also associated with one or more Library objects.","A Variant object (block ) corresponds to a particular Cell object that has been modified in some way so as to provide an alternate design. Unlike separate versions of a Cell object, which are typically used to store interim design variations before a design is complete, a Variant object often corresponds to a design that is intended for a slightly different end use. For example, a particular electronic device may require some modifications in order to be used in another country having different standards (e.g., NTIS vs. PAL video standards), but a large portion of the underlying design may be the same. A Variant object also has name, version and unique id fields, and may have one or more associated Attribute objects (a double-headed arrow between blocks  and  is omitted for clarity). A Variant object may also have a script. As discussed below, scripts can be used to specially modify an object in some way.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIGS. 6A-6T","FIGS. 6A-6T"]},"In , the project tree is partially collapsed. At the first level of the tree is a node for \u201cProjects\u201d This node is expanded in  to show numerous projects (titled \u201cDesign ,\u201d \u201cDesign \u201d and \u201cDesign \u201d); each node corresponds to a separate Project object. Although only three projects are shown, more or less could be present. The node for the project \u201cDesign \u201d is also partially expanded. The first node (\u201cLibraries\u201d) can be expanded to show various Library objects that are associated with, and may be used in connection with, the \u201cDesign \u201d Project Object. Following the Libraries node are nodes for all of the Cell objects associated with the \u201cDesign \u201d Project object. For purposes of example, the \u201cDesign \u201d Project object corresponds to the designs shown in .  is substantially the same as , except that a resistor (\u201cR\u201d) and an additional net (\u201cE_g\u201d) have been added. The \u201cBlock E\u201d Cell object corresponds to the functional blocks represented as cell E in . The \u201cBlock F\u201d Cell object corresponds to the functional block represented as cell F in . The \u201cFF,\u201d \u201cTwo_AND,\u201d \u201cFour_AND\u201d and \u201cRes\u201d Cell objects respectively correspond to a D-type flip-flop, a two-input AND gate, a four-input AND gate and a resistor. The \u201cTop\u201d Cell object corresponds to the function block for the entire circuit of  or . For convenience,  also contains a key listing the various icons used in  and K. The icons shown are only examples, and other icons could be used.","In , respectively, the nodes for Cell objects \u201cFF\u201d, \u201cRes,\u201d \u201cFour_AND\u201d and \u201cTwo_AND\u201d have been partially expanded. The \u201cPorts\u201d node for each of these Cell objects lists the Port objects associated with each of these Cell objects. Cell object FF is associated with Port objects \u201cClo,\u201d \u201cDat,\u201d \u201cQ\u201d and \u201cQbar\u201d (); Cell object Res is associated with Port objects \u201cp\u201d and \u201cp\u201d (); Cell object Four_AND is associated with Port objects \u201cIn_\u201d through \u201cIn_\u201d and \u201cOut\u201d (); and Cell object Two_AND is associated with Port objects \u201cIn_,\u201d \u201cIn_\u201d and \u201cOut\u201d (). Although some nodes in  have the same names (\u201cIn_,\u201d \u201cIn_\u201d and \u201cOut\u201d), they correspond to different Port objects. For example, the In_ Port object corresponding to  and the In_ Port object corresponding to  would have different unique id values, even if their name values are the same. Included in the tree under nodes for Cell objects FF, Res, Four_AND and Two_AND are nodes labeled \u201cRepresentations\u201d and \u201cConfigurations.\u201d These nodes, once expanded, identify Representation objects and Configuration objects associated with the Cell Objects.","In , the tree node for the Block E Cell object is expanded. On-page connectors aa, bb, cc and dd link the tree portion of  with the tree portion of . The first node under the Block E Cell Object (\u201cPorts\u201d) is expanded to identify Port Objects (E_ through E_) associated with the Block E Cell object. The Representation node is also expanded. In this example, there are two Representation objects associated with the Block E object. The first, \u201cDefault,\u201d is shown in . This Representation object, which corresponds to the design illustrated in , includes CellInstance objects A, B and R. CellInstance objects A and B are separate instances of Cell Object FF. The \u201c[FF]\u201d after each CellInstance name indicates that each of the A and B CellInstance objects is an instance of the FF Cell object. CellInstance object R is an instance of Cell object Res. Identified under each of the tree nodes for CellInstance objects A, B and R are PortInstance objects associated with each of the CellInstance objects. For example, associated with CellInstance object A are PortInstance Objects A_ through A_. A_ through A_ are, respectively, instances of Port Objects \u201cClo,\u201d \u201cDat,\u201d \u201cQbar\u201d and \u201cQ\u201d (). PortInstance objects R_ and R_ are instances of Port objects p and p (). Following the R node is a node labeled \u201cNets,\u201d under which are listed the Net objects associated with the \u201cDefault\u201d Representation object for the Block E Cell object.","The second Representation object for the Block E cell is named \u201cAlt \u201d and is shown in . This representation, which corresponds to the design illustrated in , is different than that corresponding to the Default Representation object. Associated with the Alt  Representation object are CellInstance objects A (having PortInstance objects A_ through A_) and B (having PortInstance objects B_ through B_), as well as Net objects E_a through E_f. The \u201cConfigurations\u201d node is not expanded, in . If that node were expanded, however, it would include a default configuration that, if active, specifies the Default representation of Block E. There would similarly be a configuration that, when active, specifies the Alt_ representation.","The Block F Cell Object is partially expanded in . On-page connectors ab and ac link the tree portion of  with the tree portion of . In the present example, there is only one Representation object (\u201cDefault\u201d) associated with the \u201cBlock F\u201d Cell object. Although the Representation object has the same name as other Representation objects (e.g., \u201cDefault\u201d in ), it has a different unique id value.","The \u201cTop\u201d Cell object is partially expanded in . Off-page connectors ee, ff, and gg link the tree portion of  with the tree portion of . Off-page connectors hh, ii, jj and ll link the tree portion of  with the tree portion of . Cell object \u201cTop\u201d has a single Representation object (\u201cTop Board\u201d). Associated with the \u201cTop Board\u201d Representation object are CellInstance objects \u201cE\u201d (an instance of Cell object \u201cBlock E\u201d) and \u201cF\u201d (an instance of Cell Object \u201cBlock F\u201d). Net objects associated with the \u201cTop Board\u201d Representation object are listed under the Nets node, which is not expanded in .","The Configurations node and the node for Configuration object \u201cTop Config\u201d are expanded in . The \u201cTop Config\u201d object specifies the \u201cTop Board\u201d Representation object for the \u201cTop\u201d Cell object. As seen in , the \u201cTop Board\u201d Representation object is associated with CellInstance objects \u201cE\u201d (and instance of the \u201cBlock E\u201d Cell object) and \u201cF\u201d (an instance of the \u201cBlock F\u201d Cell object). \u201cTop Config\u201d further specifies which representations of \u201cBlock E\u201d and \u201cBlock F\u201d to use when instantiating \u201cE\u201d and \u201cF.\u201d In particular, and as seen in , \u201cTop Config\u201d specifies that the \u201cDefault\u201d representation of \u201cBlock E\u201d should be instantiated. Similarly, and as seen in , \u201cTop Config\u201d specifies that the \u201cDefault\u201d representation for \u201cBlock F\u201d should be instantiated.","A Cell object can have multiple configurations. In the present example, the \u201cTop\u201d object has another configuration known as \u201cTop Config\u201d (shown unexpanded in ). In , the tree node for the \u201cTop Config\u201d object is made active and expanded. In at least some embodiments, only a tree node for an active configuration can be expanded. \u201cTop Config\u201d specifies the \u201cAlt_\u201d representation of \u201cBlock E\u201d should be instantiated instead of the \u201cDefault\u201d representation of \u201cBlock E.\u201d Off-page connectors ad, ae and af link the tree portion of  with the tree portion of . Off-page connectors ag, ah and ai link the tree portion of  with the tree portion of .","Only three hierarchical levels are included in the example of . However, additional levels of design hierarchy are possible. For example, \u201cDesign \u201d could be modified to include multiple representations of Cell object \u201cFF.\u201d  shows the \u201cFF\u201d node further expanded (after such modification) to reveal two representations of Cell object \u201cFF.\u201d The first Representation object (\u201cDefault\u201d) corresponds to a representation in which an instance of FF would be a leaf node (i.e., the lowest level of a branch in the projects tree). For example, the \u201cDefault\u201d representation of Cell object \u201cFF\u201d could correspond to a discrete component bought from a vendor. The second Representation object (\u201cAlt_a\u201d) corresponds to an implementation of a flip flop using 4 NAND gates and an inverter (such an implementation is shown in  P for convenience).  show the tree node for \u201cBlock E\u201d expanded to show (via a different type of icon) that CellInstance object A is no longer the lowest level of design hierarchy in that branch of the projects tree. On-page connectors aj, ak, al and am link the tree portion of  with the tree portion of .  shows the \u201cTop Config\u201d node expanded to now reveal four levels of design hierarchy: \u201cTop,\u201d \u201cE,\u201d \u201cA\u201d and \u201cN\u201d through \u201cInv\u201d. On-page connectors an and ao link the separated tree portions of . In the example of , \u201cTop Config\u201d specifies that that the \u201cDefault\u201d representation for \u201cBlock E\u201d should be instantiated, that the \u201cAlt_a\u201d representation of Cell object FF should be instantiated for CellInstance A, and that the \u201cDefault\u201d representation of FF should be instantiated for CellInstance B.","In  the Block E Cell object has been instantiated twice (CellInstance objects E and E) under the \u201cTop Board\u201d representation for the Top Cell object. In other words, there are now three CellInstance objects associated with the \u201cTop Board\u201d Representation object for the Top Cell object (E, E and F). Although there are now two CellInstance objects which are instantiations of the Block E Cell object, there are still only 2 instantiations of the FF Cell object (\u201cA\u201d and \u201cB\u201d) and only one instantiation of the Res Cell object (\u201cR\u201d). Stated differently, the \u201cA\u201d node under the \u201cE\u201d node and the \u201cA\u201d node under the \u201cE\u201d node refer to the same CellInstance object; the same applies to the two \u201cB\u201d nodes and to the two \u201cR\u201d nodes. Although the two \u201cA\u201d nodes refer to the same object, the object has a different context in each tree location. This context can be used to vary the behavior of the object based on its location in the design hierarchy. For example, CellInstance object \u201cR\u201d could have associated attributes that depend upon context. One attribute may specify a first resistance value in one position of the design hierarchy (e.g., under \u201cE\u201d), and another attribute may specify an different resistance value in a second position within the design hierarchy (e.g., under \u201cE\u201d). As shown in , an Attribute object (block ) may have multiple values (\u201ccontext values\u201d) that depend upon context. A context string of a Configuration object (block ) defines the context values to be used at various locations within the hierarchy (i.e., when the CellInstance object is in different contexts).","Although CellInstance objects have been discussed in connection with , PortInstance, Connection and Net objects can also have context. For example, if the A nodes under E and E were expanded to identify ports of A, A_ under A on the E branch and A_ under A on the E branch would refer to the same PortInstance object, but with different contexts. If the Nets node under E and the Nets node under E were expanded, E_a under E and E_a under E would refer to the same Net object, but have different contexts values. The Connection object linking A_ and E_a in the E context is the same Connection object linking A_ and E_a in the E context, but likewise has a separate context value in each case.","Example System Architecture","In at least some embodiments, and using objects according to the DDOM of , design data is stored in an object-oriented database. Client computers (operated by front end designers) download a set of DDOM objects, via a Design Objects Server (DOS), from the object-oriented database. The downloaded DDOM objects include methods that act as application programming interfaces (APIs) for application programs executing on a client computer. Those client APIs are used by one or more application programs to edit and\/or create design objects.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIG. 7","FIG. 7","FIG. 7"],"b":["50","50","50","50","56","50","56","50","58","58","60","62","60","60","62"]},"Executing on client  are various design applications -. In at least some embodiments, these applications are implemented as plug-ins running within a container application . In at least some embodiments, the container application is written in the aforementioned JAVA programming language and can be run in three different modes: as an applet within a browser (such as the INTERNET EXPLORER browser program available from Microsoft Corporation of Redmond, Wash.); by invocation using JAVA WEB START (described at <http:\/\/java.sun.com\/products\/javawebstart\/architecture.html>); or as a standalone application. These plug-ins, also written using the JAVA language, are designed to address different design and data management tasks. The creation of JAVA-based applications and plug-ins and execution of such applications and plug-ins in one of the above-described modes are well known in the art, and therefore not further described herein.","In the present example, plug-in  is a Design Data Manager (DDM). DDM  allows a designer to display a logical design element listing (such as the projects tree described above) and to edit those design elements. Plug-in  is a viewer application, and allows the designer to view the contents of (or other information about) one or more design elements (or other objects) selected in another application. Plug-in  is a schematic editor. Schematic editor  allows a designer to generate a schematic diagram from design data contained in DDOM objects, as well as to modify DDOM objects by manipulating graphical images on a displayed schematic. Plug-in  is a transaction manager, which is discussed in more detail below. Other plug-ins  could include an attribute editor (which allows a designer to edit one or more attributes of a design object), a constraint editor (which allows a front end designer to specify constraints for physical components that a back end designer may use to implement the logical design elements), a parts selector (which allows a designer to access one or more libraries), an output window (which displays status information from other plug-ins or scripts), and a scripting plug-in (which allows a user to write, paste and edit scripts; scripts are discussed below). Plug-ins - are only a few examples of the types of plug-ins executable by client  in connection with embodiments of the invention. Also stored in memory of client  are local copies of DDOM objects for one or more design projects.","Client Editing of Design Data",{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIGS. 8A-8J","FIGS. 8A-8J"]},"Shown in  is a user interface for DDM . A first pane  of DDM  contains selectable folder tabs labeled \u201cprojects\u201d and \u201clibraries.\u201d By selecting the projects tab, and as shown in , the user is able to see a projects tree  displayed in pane . In at least some embodiments, DDM  includes a second pane . Pane  also includes various selectable tabs, such as \u201cConnectivity,\u201d \u201cAttributes\u201d and \u201cPackaged Data.\u201d As discussed in more detail below, selection of various tabs in pane  allows a user to obtain additional details about an object selected in pane . All of the tabs shown for pane  may not be present in a particular case. The available tabs in panes  and  can vary based on program configurations and\/or the currently loaded project data. In at least some embodiments, selecting the \u201cChange Split\u201d command causes panes  and  to re-orient relative to one another (e.g., from pane  over pane  to panes  and  being side by side, or vice versa).","Also shown in  is a viewer plug-in . In at least some embodiments, viewer plug-in  performs various functions. When the front end design environment is initially loaded onto a client computer, viewer  provides a \u201cwelcome\u201d screen as shown in . The welcome screen can provide a portal by which a user may access administrative and other screens. The welcome screen can also be used to provide system messages (e.g., \u201cdatabase will be down for maintenance from 12:00 to 4:00 a.m.\u201d), to summarize design projects for the user, to summarize pending change requests for the user (change requests are discussed below), and to provide numerous other types of information. Viewer  also allows a user to view information about objects that may be selected in DDM plug-in . In some cases, that information may be in the form of a textual description of the selected object. In other cases, that information may be a schematic diagram or HDL code associated with the object.","The projects tree in pane  can be expanded in a manner similar to that described in connection with . When expanded, different parts of projects tree  may be seen by manipulating and on-screen scroll bar or other user interface. In , HDL code for a selected Representation object is shown in viewer . In , a schematic diagram for a selected Representation object is shown.",{"@attributes":{"id":"p-0104","num":"0103"},"figref":["FIGS. 8D-8J","FIG. 8D","FIG. 8D","FIG. 8E"],"b":["80","68","92","66","92","68","66","68","68","92"]},{"@attributes":{"id":"p-0105","num":"0104"},"figref":["FIGS. 8D and 8E","FIGS. 8D and 8E"],"b":["68","92","66","68","68","92"]},"Using DDM  and\/or other plug-ins executing on a client, a designer can make changes to a design in various manners.  illustrate ways in which a designer can make design modifications using DDM . In at least some embodiments, a designer may select a design element in the projects tree using a computer mouse. When the designer selects a node on the tree (using, e.g., a \u201cright click\u201d), the designer is provided a context menu presenting various options. For example, as shown in , the designer has right-clicked upon a projects tree node for a Cell object, bringing up a context menu . The first selection in context menu  (\u201cMake Reusable\u201d) makes the selected cell accessible by other users and\/or projects, and may cause the selected cell to be added to one or more libraries (i.e., associated with one or more Library objects). The \u201cChange Description\u201d menu option allows a designer to add, delete or modify textual information used to describe the Cell object. The \u201cDelete Cell\u201d option permits a designer to delete the object. The \u201cChange Lifecycle State\u201d option allows a designer to change the lifecycle state for the object. The \u201cScript\u201d option allows a designer to execute one or more scripts with regard to the selected object. For example, a script may be selected and executed for a Cell object to automatically perform certain tasks applicable to that object. The \u201cView Datasheet\u201d option allows a user to see information for a particular electronic component associated with a particular design object. For example, a datasheet for the Res Cell object () could include information such as manufacturer name, part number, tolerances, etc.","In , the designer has right-clicked a Representation object to display another context menu . The \u201cDelete Representation\u201d option allows a designer to delete the object. The \u201cRename\u201d option allows renaming of the object. The \u201cSet Default\u201d option allows the designer to make a particular representation the default representation for its associated Cell object. The \u201cEdit Schematic,\u201d \u201cEdit Block Diagram\u201d and \u201cEdit Verilog\u201d permit a designer to edit these types of views of the object.","Editing of a schematic for a selected object is shown in . After selecting \u201cedit schematic\u201d in context menu , a separate schematic editor  is invoked. Using schematic editor , the user can move symbols in the schematic, add or delete symbols, etc. In some embodiments, viewer  can also operate as an editor. Changes made to the schematic are back-propagated to the selected representation object, and any necessary changes to the project tree automatically made. In at least some embodiments, graphics for a schematic are automatically generated in real-time based on the connectivity information for a selected element in the DDM projects tree. A specific graphical symbol for a particular type of component may be associated with a Cell object (e.g., as an attribute). Even if a specific symbol is not associated with a Cell object, a block or other graphic having the proper number of ports can be automatically generated. As another example of automatic schematic generation, a group of Net objects can be selected in the DDM and a graphic automatically generated to show components receiving the signals corresponding to those Net objects.","Returning to , \u201cedit block diagram\u201d in menu  allows a user to edit (using a separate block diagram editor or viewer ) a block diagram for the selected object. In at least some embodiments, a block diagram is similar to a schematic diagram, but may not use conventional schematic symbols. \u201cEdit Verilog\u201d in menu  allows a user to edit (using a separate HDL editor, a text editor, or viewer ) Verilog or other HDL code for a selected object. As with the \u201cedit schematic\u201d option, changes made to a block diagram or HDL code for an object are back propagated to the object, and the projects tree updated automatically.","In , the designer has right-clicked a representation node within a hierarchy shown under the Configurations node to invoke a context menu . If the selected Representation object is not currently specified by the active Configuration object for the top level Cell object in the hierarchy, the \u201cconfigure\u201d command causes the Representation object to be specified by the active Configuration object. If a Representation object is already specified by the active configuration of the top level Cell object, \u201cunconfigure\u201d will cause the Representation object to no longer be specified.","DDM user interfaces for editing a design can be invoked in other manners. In at least some embodiments, a designer may first select an element in the projects tree (by, e.g., clicking once with a left mouse button), and then select various pull-down menus from a tool bar or other menu. Changes to a design can also be made using other plug-ins in combination with the DDM plug-in. For example, a designer may select a design element listed in another plug-in window (e.g., a window for a parts library database viewer) and then drag and drop that element into a particular location on the projects tree. Upon doing so, a dialog (not shown) can be automatically displayed to obtain any additional information needed from the designer to complete the modification. In some embodiments, a separate interconnect table plug-in (not shown in the drawings) can be invoked. Upon selection of a Representation object in the projects tree, for example, a table is displayed. Rows of that table may correspond to Net objects, with columns corresponding to CellInstance objects. An appropriate symbol in a row\/column intersection signifies a connection between a Net object and a specified PortInstance object. By selecting a field of the table and modifying the entry (e.g., \u201cB\u201d for bidirectional connection), connectivity between Nets and CellInstances is changed. These changes are then back-propagated to the appropriate objects and the projects tree updated. The interconnect table (or other spreadsheet) can also be used to initially populate a projects tree.",{"@attributes":{"id":"p-0112","num":"0111"},"figref":["FIG. 8J","FIG. 8K","FIG. 8K","FIG. 8K"],"b":["90","90","82","82"]},"Projects tree  also contains a node for \u201clibraries\u201d (see, e.g., ). A libraries node in the projects tree lists Library objects associated with a particular Project object. For example, the libraries node in  would contain Library objects associated with the \u201cDesign \u201d Project object. The libraries tree  under the \u201cLibraries\u201d tab lists Library objects accessible by a particular user. This will often (though not necessarily always) include more Library objects than are listed under a projects tree libraries node.","Communicating Design Changes","In , a user has modified the \u201cDesign \u201d Project object by adding a new Cell object (\u201cNew\u201d). The associated design data changes have not been incorporated into design database  () at this point, and are thus shown in a different color in projects tree . If the user wishes the changes to be incorporated into design database , the user can select the \u201cCommit\u201d command. Upon doing so, a transaction containing the requested changes is sent from the client to DOS , as described below. If the user wishes to save the changes, but does not yet wish to make those changes part of design database , the user can select the \u201cSave\u201d command. Saved changes are stored by DOS  and can be retrieved by the user for further consideration and\/or modification. Upon later retrieval of the saved changes, the user can commit those changes, further edit those changes, or discard those changes. The \u201cChange Request\u201d button is described below.","In at least some embodiments of the invention, each editing action by a user at a client is tracked by DOS . When a first user at a first client selects an object for editing, DOS  detects that selection and sends a message to other clients. DDM plug-ins at those other clients then lock the object. Users at those other clients are prevented from editing the selected object while it is locked. As the first user makes design data edits pertaining to the selected object, each edit is detected by DOS  and cached in a temporary memory. When the first user decides to incorporate those edits into design database  and selects the \u201cCommit\u201d command, a transaction manager plug-in on the first client forwards a transaction to DOS  instructing that those changes (which have been cached by DOS ) be updated to design database . After DOS  does so, DOS  sends transactions to other clients instructing the DDM plug-ins at those clients to release the locked object, as well as providing information to the other clients, about the changes made by the first client. The other clients may then update their local copies of the design data to reflect those changes.",{"@attributes":{"id":"p-0117","num":"0116"},"figref":["FIGS. 10A-10C","FIG. 10A","FIG. 10A"],"b":["1","58","58","2","3","2","3","2","3"]},"In , the client  user has made a first edit (\u201cedit \u201d) using the DDM plug-in. The user may have added a new object that is associated with the selected object, may have modified the connectivity or an attribute of the selected object, or may have performed numerous other types of editing tasks. The user does not yet wish to incorporate the edit into design database . The client  transaction manager plug-in also detects the edit, notes same, and sends a message advising DOS  of the edit. DOS  caches the edit in temporary memory, but does not notify other clients or attempt to update the edit to design database . Activity then proceeds in a similar manner with regard to additional edits. In alternate embodiments (not shown in ), modifications to DDOM objects are not transmitted to DOS  until a user decides to incorporate those changes into the design database.","In , the client  user has made n edits (\u201cedit \u201d through \u201cedit n\u201d). If the client  user had decided not to incorporate edits  through n into design database , but still wanted to save those edits for future consideration, the client  user could have selected the \u201cSave\u201d command. The edits cached by DOS  would then be saved to a file storage system or other non-volatile storage (not shown in ), and would be available for future retrieval by the client  user, but would not be incorporated into design database . In the current example, the client  user decides to incorporate edits  through n into design database . Upon selecting the Commit command in the client  DDM plug-in, the client  transaction manager plug-in sends a transaction to DOS  instructing that edits  through n be incorporated into design database . DOS  does so via data APIs . DOS  also sends transactions to clients  and  containing edits  through n (e.g., copies of objects modified or added, scripts containing instructions to delete objects that may have been deleted, etc.), as well as an instruction to release locked objects.","Upon receiving the transaction from DOS , the transaction manager plug-ins executing at clients  and  provide information about the transaction to users of clients  and . The information may include a description of the transaction and the changes made, as well as the identity of the user submitting the transaction. However, the transaction managers at clients  and  do not automatically incorporate edits  through n into the local design data at clients  and . Instead, the client  and client  users may choose to apply the design changes made by the client  user to the local design data at client  and at client .  shows, according to at least some embodiments of the invention, a user interface for a transaction manager application executing on client  after the transaction of  has been received. The transaction manager user interface has a button or tab for each currently active user. By selecting a tab for a particular user, the client  user is able to see the transactions submitted by other users, as well as the individual design changes in each transaction. In , for example, the client  user has selected the button for the client  user (\u201cUser X\u201d) and sees information regarding the transaction of  submitted by user X. Listed below that transaction are the individual design changes included in the transaction. For simplicity, those changes are depicted generically in  as \u201cedit \u201d through \u201cedit n.\u201d In at least some embodiments, a description of the changes would be included (e.g., \u201cadd Cell New\u201d). If the client  user presses the \u201cApply\u201d button, the changes in the transaction are shown in the projects tree of the DDM plug-in. Those changes are shown in a different color or otherwise differentiated from other parts of the design (). Fur purposes of example,  assumes that one of \u201cedit \u201d through \u201cedit n\u201d is addition of a Cell object named \u201cNew.\u201d If the client  user is satisfied with those changes, he or she can select the \u201cAccept\u201d command in the DDM plug-in. Upon doing so, the selected changes are incorporated into the local copy of the design data stored at client . If the user selects the Reject command, the changes are not made to the local design data copy at client , and the projects tree is returned to its previous condition.","Although only a single transaction is submitted to clients  and  in , this need not be the case. If client  had submitted additional transactions, for example, each of those transactions could be displayed in the client  (or client ) transaction manager (e.g., as separate \u201ctransaction\u201d nodes in the transaction manager window). If the client  user chooses not to accept changes from the transactions regarding the client  user, the client  user may still accept those changes at a later time. The client  user may also save the local design data stored at client  in design database  as a separate version, which separate version may not include some or all of the changes made by other users. Even if the client  user does not accept all changes made by other users, the design data loaded by the client  user at the next logon will include those changes. If the client  user has saved a separate version lacking those changes, however, the user may retrieve that version.","In at least some embodiments, a transaction manager is configurable to filter design changes reported to a client. For example, one user may only be concerned with other users' changes to specific areas of the design data, and may not care what is occurring in other areas. As another example, a user may be concerned with changes to certain types of design elements, but less concerned about changes to other types of design elements. By appropriately setting a filter within the transaction manager plug-in, the transaction manager will only report transactions (or changes within transactions) affecting design elements within the filter settings. In at least some embodiments, a user may also set the transaction manager to automatically apply the filtered changes (i.e., the changes excluded by the filter settings) to the local design data copy at the user's client.",{"@attributes":{"id":"p-0123","num":"0122"},"figref":["FIG. 12","FIG. 10B"],"b":["50","58","50"]},"In at least some embodiments, some or all of the data for a design can be subject to additional restrictions regarding who may edit the data, and\/or under what circumstances that data may be edited. For example, a company may not wish to change a design (or portions thereof) for a device currently being produced without taking additional steps to ensure the change is warranted. In such a circumstance, the corresponding data in design database  is assigned a lifecycle state of \u201cIn Production.\u201d If a user selects design elements having an In Production state, the DDM application at the user's client will not allow the user to submit a normal transaction regarding those elements. Instead, the user must initiate a Change Request. Only after the Change Request obtains required approvals can the requested design changes proceed.","In , a user has selected a design (\u201cCPU Board\u201d) having a lifecycle state of In Production. If the user invoked a context menu, all of the editing options would be shown in gray, indicating those options are not currently available. If the user attempts to edit the object in another manner (e.g., dragging and dropping an object from a parts viewer), the user is notified that the design can only be modified using a Change Request. Accordingly, the user initiates a Change Request dialog, shown in . Upon initiating the Change Request, the user may then minimize or move the Change Request dialog and proceed to edit the selected object. As such changes are made, a description is automatically added to the description field. The user may also modify that description by restoring the dialog window and typing in the description field. When all of the desired changes have been made, the user can then cause the change request to be transmitted to other users by selecting \u201cOk.\u201d As seen in , the Change Request dialog can include a listing of other users. The listed users may not currently be connected to DOS . The change requestor may select from the listed users the persons to which the Change Request should be forwarded. Those selected users' names will be copied to the Selected Users field. In some embodiments, the permission of certain users (e.g., department managers, etc.) may be required for a particular change order and automatically included in the Selected Users field. In some embodiments, the user may also specify a voting threshold of the selected users required to approve the Change Request, or indicate (by checking the required checkbox under \u201cSelected Users\u201d) that the Change Request should not be approved unless specific users approve.","After the initiating user presses the \u201cOK\u201d button, and as shown in , an e-mail message is sent to the selected users indicating that the initiating user has sent a Change Request. If a receiving user wishes to approve the change request, he or she may select the \u201cYes\u201d hyperlink. In at least some embodiments, and as shown in , the e-mail recipient is also provided a hyperlink (\u201cClick here\u201d) to a web page (not shown) containing information about other pending change requests. The web page may also include additional details of those change requests, as well as a check box or other UI that can be used to indicate approval or rejection of the Change Request.","Once the required approvals are received, the Change Request is automatically processed similar to the transaction of . In this case, however, the notification of the changes (i.e., the transaction containing the new\/modified objects and information about the changes) is also sent to user initiating the Change Request. Because the initiating user does not know if the desired design changes would be allowed until other users respond to the Change Request, those design changes are not made to the initiating user's local design data copy at the time of preparing a Change Request. If the Change Request is not approved (e.g., a required user rejects the change, a sufficiently large number of optional users reject the change, etc.), the initiating user is notified via an e-mail (not shown).","Although the preceding description of change requests has focused upon \u201cIn Production\u201d designs, the invention is not limited to this particular context. For example, a user may be able to edit a design or a portion thereof, but not wish to do so until other persons have had the opportunity to review the proposed changes. Moreover, a Change Request can be used to change numerous aspects of a design. For example, changing lifecycle state for a design could be implemented using (or could require) a Change Request. If a Change Request is required before an object can be edited, the requirement can be built into the object itself. For example, the DDM plug-in (and\/or other plug-ins) can be configured to examine a \u201clifecycle state\u201d attribute and not allow editing, without a Change Request, if that attribute has an \u201cIn Production\u201d or other specified value. A user could also prepare a Change Request while other edits (not implicating a Change Request) are in process. For example, after making several edits outside of a Change Request (which edits are being recorded in a transaction by the transaction manager), the user could initiate a Change Request. Upon doing so, the transaction containing those edits is temporarily put aside, and a new transaction begun for the Change Request. When the Change Request is completed and sent out for approval (i.e., the \u201cOk\u201d button is pressed in ), the previously set aside transaction once again becomes the active transaction.","Communication Between Front and Back End Designers","The discussion thus far has focused upon front end design, and in particular, the creation, modification and storage of design data for elements in the logical domain. Ultimately, however, logical design data will be used to generate physical design data during the layout (or \u201cback end\u201d) design process. In particular, actual electronic components providing the desired function of one or more logical design elements are identified and are placed on one or more printed circuit boards (PCBs). Interconnections between pins of these components are then made based on the required connections set forth in the logical design data. In many cases, logical and layout design are performed by different teams of individuals. In some cases, those individuals may work for different companies. Often, layout designers will perform their tasks using a different set of software applications than were used by the front end designers.","Although layout design may be based upon information generated during the logical design process, there is often not a one-to-one correspondence between data types in the front and back ends. As seen in , for example, the signal path from port A_ to port C_ includes three nets: E_c, Net and F_a. In the layout domain, however, this is a single net. As another example, cells E and F will generally have little meaning or use in the layout domain. In other words, a hierarchical logical design must be \u201cflattened\u201d into a collection of parts at the same level. As yet another example, and as previously described, multiple logical elements could be implemented as different slots of the same physical element.","Using existing methods, transition from front to back end design is traditionally performed in a batch processing fashion. In other words, the front end design would be completed and provided to the back end designers. The back end designers would then convert the logical data to another form (or forms) in order to extract design information needed to perform layout. In addition to being time consuming, this method inhibits design changes. If it becomes necessary to make a few front end design modifications after layout has already begun, the entire front end design data must often be reconverted to a form usable by layout designers, who must then determine which aspects have changed. Similar problems occur when design changes are made in the back end. For example, a layout designer may decide to add a part (e.g., a filter capacitor) during the layout process. This newly added part should be included in the logical design data, but doing so requires converting layout data for the entire design to a form usable by the front end designers, determining what has been changed, and then updating the logical data accordingly.","In at least some embodiments of the invention, mapping between front and back end design data is performed dynamically. In other words, as changes are made to the logical design data, corresponding changes are made to certain data objects having significance to back end designers. These data objects are then communicated to the back end designers and usable for layout purposes. Conversely, design changes made during the layout process are also incorporated into these data objects, which then make corresponding changes to logical design data objects.","This is shown schematically in . In , client FE is performing editing operations to logical design data using a DDM plug-in. As these edits are made, DDOM objects are added, deleted and\/or modified. In addition to the DDOM objects, a collection of Layout Logical Object Model (LLOM) objects is also loaded. The LLOM, as is described in more detail below, is a collection of interrelated objects used to describe various physical design aspects of one or more designs. In response to DDOM editing events, methods within various LLOM objects add, delete and\/or otherwise modify LLOM objects. DOS  monitors the actions by the user at client FE and caches DDOM and LLOM changes in a temporary memory. When the designer at client FE wishes to commit a group of logical and layout design data changes to design database , a corresponding transaction is sent to DOS . In response to that transaction, DOS  updates design database  to include the DDOM and LLOM changes in the DOS temporary memory.","Upon updating design database  to include changes to objects to logical (DDOM) and layout (LLOM) data, DOS  also sends a transaction containing the changes to back end client BE. Client BE maintains a local copy of LLOM objects. Client BE also executes one or more back end applications  for performing various layout design tasks (e.g., locating components on a printed circuit board, routing connections between those components, generating machining and other manufacturing information, performing simulation or analysis, etc.). Back end applications  may not be browser-based. Indeed, back end applications  may be written in a different programming language than plug-ins executing at client FE, may be designed for a different operating system than that used by client FE, may have a different data model than the front end design system, and may otherwise function in a different computing environment. However, back end applications are able to access LLOM objects via APIs within those objects. Upon receiving a transaction from DOS , back end applications  are notified of changes to LLOM objects. The precise form of this notification will vary between back end applications. Upon receiving such notice, back end applications  process the new layout data as may be appropriate. In some cases, back end applications may permit a user to accept or reject the changes in a manner similar to that described in connection with .","Certain changes to design data by the back end designer are also communicated to the front end designer. As indicated above, it is sometimes necessary for a back end designer to add a component to a circuit that might not be included in the logical design data. As shown in , certain design changes made using back end applications  invoke various APIs within locally stored LLOM objects. Those APIs cause changes to be made to LLOM objects so as to reflect design changes made using back end applications . As with activity at client FE, DOS  monitors the actions by the user at client BE and caches LLOM changes in a temporary memory. DOS  also caches DDOM changes corresponding to these LLOM changes. Such DDOM changes are generated by a copy of the DDOM at DOS . When the back end designer wishes to update design database  to include the layout changes that have been made, a transaction is sent from client BE to DOS  (not shown). Upon receiving that transaction, DOS  updates design database  to include those layout and logical design changes. DOS  also forwards those changes to client FE in a transaction. Upon receiving that transaction, client FE processes it as described in connection with .",{"@attributes":{"id":"p-0137","num":"0136"},"figref":["FIG. 15","FIG. 15","FIG. 4","FIG. 15","FIG. 15"]},"Beginning at the top of , the LLOM includes a main object . The main object can be analogized to a container for other objects of the LLOM. Main object  is often the starting point from which other objects are accessed. For example, when initially loading layout data for one or more designs, main object  is first accessed so as to determine what other LLOM objects may be available. In some cases, main object  also detects various events that occur in a program for editing logical or layout design data. In response, main object  passes necessary data to one or more other LLOM objects and\/or appropriate methods within other LLOM objects.","The LLOM generally includes one or more Board objects (block ). Each board corresponds to layout data for a particular PCB. Each board has name, version and unique id fields. The board name is the name assigned to that PCB within the layout application (e.g., \u201cBoard ,\u201d etc.). Each board also has a version. As with logical data, one or more back end designers may generate multiple versions of layout data for a board so as to, e.g., maintain information about alternative layout designs. The unique id for a board object is an identifier used to reference the Board object by other data objects, by DOS  and by the design database . In some embodiments, this may be an alphanumeric string that is automatically assigned when the object is created. Each Board object additionally has a layout id field. The layout id is an identifier used by back end applications to reference the object, and may have no significance outside of the back end applications. Although the layout id may be the same as the object name, the object name will typically be chosen by a human so as to have significance to designers or other persons. The layout id may be automatically generated by the back end application(s). Each Board object further has constraint class and constraint overrides fields. These fields hold unique ids for ConstraintClass and ConstraintOverride objects. In general, constraints refer to limitations upon how a circuit may be physically arranged (e.g., minimum trace separation, maximum signal path length, etc.). ConstraintClass and ConstraintOverride objects are part of a Constraint Data Object Model (CDOM), which is discussed in more detail below.","Each Board object references one or more Part objects (block ). Each Part object corresponds to an actual electronic component (e.g., an IC, resistor, capacitor, memory chip, etc.) to be placed on a PCB. Each Part object also has name, version, unique id, layout id, constraint overrides and constraint class fields. In the case of a Part object, the name is typically a reference designator (e.g., \u201cU\u201d) for the part in the layout system. In addition, each Part object has one or more slot fields. A \u201cslot\u201d field is used to hold an identifier of a design element in the logical domain (DDOM). If, for example, a Part object corresponds to CellInstance object \u201cA\u201d of , a slot field for that Part object would contain the unique id for CellInstance \u201cA.\u201d The slot field also holds context information for a particular CellInstance object. As explained above in connection with , a particular CellInstance object may be reachable through multiple paths through the design hierarchy. In , there are two instances of the \u201cBlock E\u201d Cell object, each of which lists CellInstance objects \u201cA,\u201d \u201cB\u201d and \u201cR.\u201d The context information for a Part object corresponding to CellInstance object \u201cA,\u201d \u201cB\u201d or \u201cR\u201d would indicate the path through the hierarchy (i.e., via E or via E) used to reach the CellInstance object. For example, one slot field of a Part object would have the unique id for CellInstance A and information corresponding to the E context, while another slot field of the same (or a different) Part object would have the CellInstance A unique id and information corresponding to the E context.","In some cases, a Part object has multiple slot fields. For example, and as shown in , a single chip may actually contain multiple components. In the example of , chip  contains four AND gates, each of which connects to separate pins of the chip. A Part object corresponding to chip  would thus have four slot fields. If the Part object corresponded to CellInstance \u201cC\u201d (), one of those slots would be mapped to (and thus hold the unique id and context information for) CellInstance \u201cC.\u201d If CellInstance \u201cC\u201d is located in multiple parts of the design (e.g., similar to CellInstances \u201cA\u201d and \u201cB\u201d in ), one slot may be mapped to CellInstance \u201cC\u201d with a first context information value, and another slot mapped to CellInstance \u201cC\u201d with a second context value.","Each Part object references one or more Pin objects (block ). Each Pin object corresponds to a pin of an actual electronic component (i.e., of the component corresponding to the parent Part object). Each Pin object also has name, version, unique id, layout id, constraint overrides and constraint class fields. In the case of a Pin object, the name is a name such as \u201cClk,\u201d \u201cReset,\u201d etc. retrieved from a database for the component. The \u201cnumber\u201d field of a Pin object contains a pin number assigned by a manufacturer of the component corresponding to the Part object with which the Pin Object is associated. The logical id field of a Pin object contains the unique id for a design element in the logical domain (i.e., a PortInstance object), as well as context information for that logical design element. As with a CellInstance object, a PortInstance object can appear in numerous locations in a design hierarchy; the context information identifies how a PortInstance object is reached through the design hierarchy.","In addition to Part Objects, each Board object references one or more Physical Net objects (block ). Each Physical Net object corresponds to one or more logical nets that make up an entire signal path. For example, and as shown in , the signal path from port A_ to port C_ include nets E_c, Net and F_a. A Physical Net object for this signal path would correspond to Net objects for nets E_c, Net and F_a. The \u201clogical ids\u201d field of the Physical Net object would contain the unique ids for the E_c, Net and F_a net objects, as well as context information for those objects. Similar to other LLOM objects, a Physical Net object also includes name, version, unique id, layout id, constraint overrides and constraint class fields.","Each Board object may also reference one or more Electrical Net objects (block ). Unlike a Physical Net object, which often corresponds to a signal path between two circuit components, an Electrical Net object corresponds to a signal path that includes one or more components. An example could include two signal paths connected by a resistor, as shown in . The input signal is essentially the same as the output signal, except for a reduction in voltage. An Electrical Net object, which would typically be used for analysis purposes (e.g., evaluating crosstalk), references one or more Part objects and one or more Physical Net objects. Similar to other LLOM objects, an Electrical Net object also includes name, version, unique id, layout id, constraint overrides and constraint class fields.","Each Board object may further reference one or more Differential Pair objects (block ). Each Differential Pair object references two Physical Net objects, thereby corresponding to a pair of nets in a circuit. Differential Pair objects, which are typically used for trace routing and\/or analysis purposes, include name, version, unique id, layout id, constraint overrides and constraint class fields.","The remaining object shown in  is a Pin Pair object (block ). A Pin Pair object corresponds to a pair of component pins (usually of different components) connected by a net of a circuit. Accordingly, a Physical Net object references one or more Pin Pair objects, each of which in turn reference two Pin Objects. A Pin Pair object also has name, version, unique id, layout id, constraint overrides and constraint class fields.",{"@attributes":{"id":"p-0147","num":"0146"},"figref":["FIGS. 18A-18D","FIGS. 18A-18D"]},{"@attributes":{"id":"p-0148","num":"0147"},"figref":"FIG. 18A","b":["202","204"]},"At block , the LLOM packages the logical elements of the flattened design hierarchy. In other words, after the DDOM determines how many parts must be added, the LLOM assigns the unique ids and context information corresponding to those new parts to available slots of existing Part objects. If no slots are available, the LLOM creates new Part objects and assigns the unique ids and context information to slots of those new objects. If the LLOM creates new Part objects, associated Pin objects are also created. If a part was added or slot filled in step , the flow proceeds to block . At block , the DDOM assigns to the appropriate Pin objects the unique id and context information for the PortInstance objects associated with the new CellInstance objects (or with new contexts for pre-existing CellInstance objects).",{"@attributes":{"id":"p-0150","num":"0149"},"figref":"FIG. 18B","b":["210","212","214"]},{"@attributes":{"id":"p-0151","num":"0150"},"figref":"FIG. 18C","b":["220","222","224","222"]},"At block , the LLOM identifies Pin objects corresponding to the PortInstance objects (and contexts thereof) associated with the Connection objects (and\/or contexts) that were added and\/or deleted in the DDOM. The LLOM then creates and\/or deletes new Pin Pair objects as is required. The LLOM then associates new Pin Pairs with the appropriate Physical net object. In some cases, the LLOM may associate an existing Pin Pair object with a different Physical Net object or vice versa. At block , the LLOM creates, deletes and\/or modifies associations for Differential Pair and Electrical Net objects based on the connectivity changes.",{"@attributes":{"id":"p-0153","num":"0152"},"figref":"FIG. 18D","b":["232","234","236","240","240"]},"In at least some embodiments, the processes described by  are performed on the fly. In other words, as each DDOM change is made, the corresponding LLOM changes are made (and vice versa). In certain embodiments, the processes described by  are performed as periodic updates.","In some embodiments, a Board object is created by a user selecting a command from a context menu generated by selecting a Configuration object in a projects tree (not shown in the FIGS.). As previously discussed, a Cell object in the DDOM can have multiple configurations. In some cases, a separate set of LLOM objects is generated for different configurations of the same Cell object.","By mapping logical domain design objects to physical domain design objects, a front end designer is also able to access physical domain data more conveniently. For example, a front end designer may wish to know what reference designator is being used in the back end design system to refer to a particular logical design element. By searching LLOM objects for Part, Pin or Physical Net objects having the logical element's unique id, this can quickly (and automatically) be determined. By frequently mapping DDOM objects to LLOM objects, numerous problems associated with synchronizing data between front and back ends are avoided.",{"@attributes":{"id":"p-0157","num":"0156"},"figref":["FIGS. 19A and 19B","FIG. 19B"],"b":["90","66","92","92","90","90","92"]},"Constraint Data","In at least some embodiments of the invention, and as previously indicated, constraint data is mapped to layout data and is accessible by front end designers. Although constraints (e.g., maximum signal path length, minimum separation between nets, etc.) are often applied by a back end designer when laying out a board, a front end designer may establish or otherwise provide input to those constraints. In known prior art systems, constraint data is stored in multiple places, often resulting in data synchronization problems, and there is often no established method for transferring constraint information between front and back end designers. Conversely, embodiments of the present invention store constraint data in a collection of objects (a Constraint Data Object Model, or CDOM) accessible by both front and back end designers, and which can be easily associated with logical design elements through related layout data.",{"@attributes":{"id":"p-0160","num":"0159"},"figref":["FIG. 20A","FIG. 20A"],"b":["1","2","3","4"]},"As with logical design changes previously discussed, DOS  monitors the actions by the user at client FE and caches CDOM changes in a temporary memory. When the designer at client FE wishes to commit a group of constraint changes to design database , a corresponding transaction is sent to DOS  (step ). In response to that transaction, DOS  updates design database  to include the CDOM changes in the temporary memory (step ). Upon updating design database  to include those CDOM changes, DOS  also sends a transaction containing the changes to back end client BE (step ). Client BE maintains a local copy of LLOM objects and of CDOM objects. Client BE also executes one or more back end applications for performing various layout design tasks (e.g., locating components on a printed circuit board, routing connections between those components, generating machining and other manufacturing information, performing simulation or analysis, etc.). Upon receiving a transaction from DOS , the back end applications are notified of changes to CDOM objects. The precise form of this notification will vary between back end applications. Upon receiving such notice, the back end applications process the new constraint data as may be appropriate. In some cases, back end applications may permit a user to accept or reject the changes in a manner similar to that described in connection with .","In at least some embodiments, a back end designer may also modify or impose a constraint. As shown in , certain design changes made using back end applications invoke various APIs within locally stored CDOM objects (step ). Those APIs cause changes to be made to CDOM objects that reflect design changes made using back end applications; corresponding changes may also be made to LLOM objects (step ). As with activity at a front end client, DOS  monitors the actions by the user at the back end client and caches CDOM changes in a temporary memory. When the back end designer wishes to update design database  to include the constraint changes that have been made, a transaction is sent from the back end client to DOS  (step ). Upon receiving that transaction, DOS  updates design database  to include those constraint changes (step ). DOS  also forwards those changes to the front end client (step ). Upon receiving that transaction, the front end client processes it as described in connection with .",{"@attributes":{"id":"p-0163","num":"0162"},"figref":["FIG. 21","FIG. 4","FIG. 21"]},"Beginning at the center of , the CDOM includes a main object . The main object can be analogized to a container for other objects of the CDOM. Main object  is often the starting point from which other objects are accessed. For example, when initially loading constraint data for one or more designs, main object  is first accessed so as to determine what other CDOM objects may be available. In some cases, main object  also detects various events that occur in a program for editing constraint or other data. In response, main object  passes necessary data to one or more other CDOM objects and\/or invokes methods within other CDOM objects.","Associated with main object  are one or more Constraint objects (block ). A Constraint object corresponds to a constraint to be applied to an aspect of the physical design (e.g., maximum length for a signal path, etc.). The Constraint object includes name, version, unique id, default value, min value, max value, title and type fields. The name field may be used to hold a constraint name assigned by a user (e.g., \u201cMIN_TRACE_WIDTH\u201d). The version and unique id fields are similar to the version and unique id fields in DDOM and LLOM objects. The \u201cdefault value\u201d field holds a value that is automatically used for the constraint unless an override is set (overrides are described below). The \u201cmin value\u201d and \u201cmax value\u201d fields hold, respectively, minimum and maximum values between which the constraint can be varied through use of an override. The \u201cdescription\u201d field holds a textual description of the constraint. The \u201ctitle\u201d field holds additional description of the constraint. The \u201ctype\u201d field indicates a data type for the constraint. The data type can include \u201cinteger\u201d, \u201cfloating point\u201d and \u201cchoice.\u201d A \u201cchoice\u201d data type indicates that the constraint is one several discrete values (e.g., top or bottom; left, right or middle; etc.).","A ConstraintOverride object (block ) is used to specify a particular value, or override, for an associated Constraint object. For example, the default, minimum and maximum values for a net separation constraint may be 10, 8 and 15 millimeters, respectively. A ConstraintOverride object might (via the \u201cvalue\u201d field) specify that the default constraint value should be overridden by a value of 12 millimeters. A ConstraintOverride object also includes name, version and unique id fields.","A Constraint Object references one or more ConstraintOwner objects (block ). A ConstraintOwner object corresponds to the particular LLOM object (e.g., Pin, Part, Differential Pair, etc.) to which the constraint is to be applied. A ConstraintOwner object has name, version and unique id fields. The ConstraintOwner object is used, when working with constraint data, to indicate the type of LLOM object with which a particular Constraint object is associated. In at least some embodiments, ConstraintOwner objects are hard coded in database , as are the associations for ConstraintOwner objects. For example, a ConstraintOwner object associated with a Constraint object for a net would have a hard-coded association with LLOM Physical Net objects.","One or more Constraint objects are referenced by a ConstraintSet object (block ). A single Constraint Object can be referenced by multiple ConstraintSet objects. A ConstraintSet object includes name, version, unique id, title and description fields. The description and title fields may contain information describing the Constraint objects associated with the ConstraintSet object (e.g., a textual description of the constraints within the constraint set). An \u201cowner system\u201d field contains the name of the front end or back end system that created the ConstraintSet object. An \u201cowner type\u201d field contains an indication of whether the owner system is a front end or back end system.","A ConstraintClass object (block ) references one or more ConstraintSet objects and may reference one or more Constraint Override objects. In addition to name, version and unique id fields, a ConstraintClass object includes a description field that may be used to hold a textual description of the constraints and constraint overrides contained within the object. The \u201cvalues\u201d field contains values which override values in the ConstraintOverride objects associated with the ConstraintClass object.","Returning to , LLOM objects have fields for \u201cconstraint classes\u201d and \u201cconstraint overrides.\u201d A constraint class field holds unique ids for one or more ConstraintClass objects. Similarly, a constraint override field may hold unique ids for one or more ConstraintOverride objects. When a particular LLOM object is accessed by a back end design application, the values in the constraint class and constraint override fields for that object are used to reference the appropriate CDOM objects so that constraint data associated with a particular LLOM object may be retrieved.","Common Data Object Model (CoDOM)","In at least some embodiments of the invention, object models for layout data and constraint data are combined into a single object model known as a Common Data Object Model (CoDOM).  are an object diagram for a CoDOM according to at least some of those embodiments. Lines connecting blocks across pages are linked with like off-page connectors (e.g., connector Co in  and connector Co in ). As with other data models described above, CoDOM objects are implemented (in at least some embodiments) using the JAVA programming language. A line between two blocks in  having an arrow at both ends indicates a two-way association between those two blocks. In other words, a data object of the type at one end of the double-arrow line refers to a data object of the type at the other end of that line. An asterisk (*) on one end of a line indicates that there may be one or more objects of the type at the end of the line having the asterisk; a line without an asterisk indicates there is one object of the type at one end associated with another object of a type at the other end. Unlike , a line in  having an arrow at only one end indicates that an object of the type at the headless end of the line references an object of the type indicated at the other end of the line, but does not indicate that an object is an instance of another object. For lines connecting blocks across two pages, the type of object association (i.e., one-way or two-way) is determined based on the ends of the lines opposite the off-page connectors. For example, a CoBoard object (block , ) has a two-way association with one or more CoTVForScheme objects (block , ); a CoNetClass object (block , ) has a one-way association with one or more CoDiffPairProps object (block , ).","Beginning at the top of , the CoDOM includes a main object . The main object can be analogized to a container for other objects of the CoDOM. Main object  is often the starting point from which other objects are accessed. For example, when initially loading layout and constraint data for one or more designs, main object  is first accessed so as to determine what other CoDOM objects may be available. In some cases, main object  also detects various events that occur in a program for editing logical, layout or constraint data. In response, main object  passes necessary data to one or more other CoDOM objects and\/or appropriate methods within other CoDOM objects.","Associated with main object  are one or more CoBoard objects (block ). A CoBoard object has name, version and unique id fields which are used in a manner similar to the name, version and unique id fields previously described for other object models. Although not specifically shown in each block, other object types described in  also include name, version and unique id fields. A CoBoard object may reference one or more viaSpan objects (shown within block  for simplicity). A viaSpan object (not shown in  as a separate block) could contain information regarding a via in a PCB. Also associated with a CoBoard object may be one or more CoLayer objects (block ) containing information regarding one or more PCB layers. A CoBoard object is also associated with one or more CoNetClass objects (block ). A CoNetClass object is used to group together specific types of nets (e.g., based on function or level of importance within a design) so that one or more rules can more easily be applied to all objects in the group. A CoNetClass object, which includes data indicating a type of class (\u201cclassType\u201d), thus has one-way associations with one or more CoNet objects (by off-page connector Co to block  on ), with one or more CoDiffPair objects (by off-page connector Co to block  on ) and a CoDiffPairProps object (by off-page connector Co to block  on ). A CoDiffPairProps object contains differential pair constraints assigned to a CoNetClass object.","Returning to block , a CoBoard object may also be associated with one or more CoScheme objects (block ). A scheme represents distinct rule areas on a PCB. A CoScheme object includes information regarding a scheme type, and has a one-way association with one or more CoClToClClrRule objects (block ). A CoClToClClrRule object contains information establishing a rule for clearance to be maintained, as to a scheme, between collections of objects that have been grouped into net classes (e.g., a CoNetClass object). A CoClToClClrRule object is thus associated with two CoNetClass objects (shown inside block  as \u201cfromClass\u201d and \u201ctoClass\u201d in lieu of an arrow connecting blocks  and ).","A CoBoard object may also be associated with a CoGenClRule object (block ). A CoGenClRule object specifies a default set of clearance rules that are used initially by each net class created. After a net class is created, the general clearance rules can be modified per the specifications of that net class. A CoGenClRule object may specify default clearance values between mounting holes (\u201cMtHoleToMtHole\u201d), between mounting holes and a non-plane conductor (\u201cMtHoleToNonPlConductor\u201d), between mounting holes and a plane conductor (\u201cMtHoleToPlConductor\u201d), etc. A CoBoard object may also be associated with one or more CoClrRuleClass objects (block ), which contains (or references) various clearance rules.","Continuing around block , a CoBoard object may also be associated with one or more CoConstraintClass objects (block ). A CoConstraintClass object groups specific nets together so that the same electrical rules can be applied to all nets within the constraint class. For example, a CoConstraintClass object may reference, by connector Co to , a CoNetProps object (block ) and may references a CoEstCrosstalkProps object (block , ).","Again returning to block , a CoBoard object may be associated with one or more CoPRAssignment objects (connector Co to block  in ) and one or more CoParallelismRule objects (connector Co to block  in ). Parallelism rules allow definition of pairings of net properties that specify acceptable distances and parallelism run lengths between specific nets and net classes. For example, rules can be created to define parallelism for net segments that are on the same layer, adjacent layers, or both. When a rule is created, specification is made of a combination of edge-to-edge spacing between segments and the maximum length that segments can run in parallel without violation. Defining parallelism rules can help control the amount of crosstalk by restricting excessive segment parallelism. The two arrows connecting block  and  indicate that both sameLayerSegs and adjacentLayerSegs information is stored as CoLayerSegment objects. A CoPRAssignment object (block ) references a CoParallelismRule object, and specifies the net or net class objects for which the referenced CoParallelismRule object rule is to be applied.","Also associated with a CoBoard object () may be one or more CoTVForScheme objects (connector Co to block , ). A CoTVForScheme object references a CoScheme object and a CoNetClass object (shown as \u201cscheme\u201d and \u201cnetClass\u201d within block  in lieu of connecting arrows to blocks  and ). A CoTVForScheme object also references a CoTraceViaProp object (block ), which includes fields having information regarding allowable parameters for vias and traces, such as whether routing is allowed through a PCB via (\u201cRoutingAllowed\u201d), minimum and maximum trace widths (\u201cminTraceWidth\u201d and \u201cmaxTraceWidth\u201d), impedance for a signal passing through a via or trace (\u201ctypicalImpedance\u201d) and spacing between differential pairs (\u201cdiffPairSpacing\u201d). A CoTVForScheme object may also reference one or more CoLayerTraceViaProp objects (block ). A CoLayerTraceViaProp object references a CoLayer object (shown as \u201cLayer\u201d in block  in lieu of a connecting arrow to block ) and a CoTraceViaProp object.","Again returning to , a CoBoard object further references one or more CoClrForScheme objects (connector Co to block  in ). A CoClrForScheme object references a CoScheme object and a CoClrRuleClass object (shown as \u201cScheme\u201d and \u201cruleClass\u201d in block  in lieu of connecting arrows to blocks  and ), as well as a CoClearanceRule object (block ). A CoClearanceRule object contains fields establishing various clearance rules between traces (\u201ctraceToTrace\u201d), between traces and pads (\u201ctraceToPad\u201d), between traces and vias (\u201ctraceToVia\u201d), between traces and planes (\u201ctraceToPlane\u201d), etc. A CoClrForScheme object references one or more CoLayerClearanceRule objects (block ). A CoLayerClearanceRule object references a CoLayer object (shown as \u201cLayer\u201d in block  in lieu of a connecting arrow to block  in ) and a CoClearanceRule object.","As seen by connector Co linking block  () with block  (), a CoBoard object references one or more CoNet objects. A CoNet object includes a field for listing logical domain nets that form a physical net (\u201clogical ids\u201d). A CoNet object also includes a field \u201cTopoFromToList\u201d holding (as CoTopoFromTo objects) from-to pairs defining how the net should be routed. Although not shown, a CoNet object could also reference one or more pin pair objects. A CoNet object also references a CoNetProps object (block ). A CoNetProps object contains fields providing various information about a particular net, such as the type of net topology (\u201ctopoType\u201d), whether the topology has been ordered if it is a custom topology (\u201ctopoOrdered\u201d); the maximum distance between a net junction and a component lead (\u201cstubLength\u201d), the maximum number of vias allowed (\u201cmaxVias\u201d), the supply voltage (\u201csupplyVoltage\u201d), etc. A CoNetProps object is referenced by a CoConstraintClass object (connector Co to block  in ). A CoNet object (block  in ) also references a CoEstCrosstalkProps object (connector Co to block  in ).","As seen by connector Co linking block  () and block  (), a CoBoard object references one or more CoDiffPair objects. A CoDiffPair object represents a pair of physical nets and is typically used for trace routing and\/or analysis purposes. A CoDiffPair object thus references two CoNet objects (see arrow to block ). A CoDiffPair object includes a \u201clayout id\u201d field holding an identifier used by back end applications to reference the object. A CoDiffPair object references a CoDiffPairProps object (block ). A CoDiffPairProps object includes \u201cpairTolMax\u201d and \u201cpairTolActual\u201d fields for pair tolerance, i.e., the length of delay tolerance for the pair. For example, if a set of differential pairs needs to be routed to a matched length or time of flight delay, this rule can be used to define a very tight pair tolerance, but also define a more loose matched group tolerance. A \u201cconvDistTol\u201d field holds a convergence distance tolerance (i.e., a maximum allowed difference in trace length distance from a pad to the point where the traces start routing differentially at the Differential Spacing). A \u201cmaxDistConv\u201d field holds a maximum distance to convergence (i.e., the maximum allowed trace distance from a pad to the point where the traces start routing differentially at Differential Spacing). A \u201cmaxSepDist\u201d field holds the maximum separation distance (i.e., maximum allowed distance that differential traces are allowed to be routed at a spacing greater or less than Differential Spacing). A diffspacing field holds the Differential Spacing (i.e., the spacing at which differential pair traces must be routed). In some embodiments, differential spacing is defined by layer, and may be a read-only field.","Finally, a CoBoard object () also references one or more CoPart objects (connector Co to block  in ) and one or more CoElectricalNet objects (connector Co to block  in ). A CoPart object has a fields for layout id (holding an identifier used by back end applications), slots (holding identifiers for components in the logical domain, similar to the \u201cslots\u201d field of the Part object in the LLOM of ) and reference designator (\u201crefdes\u201d). A CoPart object references one or more CoPins objects (block ). The CoPins object includes fields for layout id, logical id (holding an identifier for a PortInstance in the DDOM) and number (containing a pin number assigned by a manufacturer of a component corresponding to the CoPart object with which the CoPin Object is associated). A CoElectricalNet object (block ) references one or more CoPart objects and one or more CoNet objects (connector Co to block  in ).","Objects of the CoDOM may be substituted for corresponding LLOM and\/or CDOM objects in various operations described herein (e.g., operations described in connection with , B and A-B).","Scripting","In at least some embodiments of the invention, some or all of the DDOM, LLOM, CDOM and CoDOM objects are exposed to scripting. As is known in the art, a script is a collection of commands in a scripting language (e.g., the VBScript, Jscript and JavaScript languages). When executed by a browser, a script can be used to configure a plug-in, to open a connection with DOS , to create\/delete\/modify a DDOM, LLOM, CDOM or CoDOM object, and numerous other functions. One or more scripts can be associated with an object, either automatically or by user action. In at least some embodiments, scripts are used to create parameterized objects, i.e., objects which can be specially configured in response to certain parameter values a user provides during script execution.","Scripted objects are shown generally in the block diagram of . In step  a user at client FE selects one or more parameterized objects from a library and places the object(s) in a projects tree of a DDM. The selection is noted by DOS , which responds at step  by transmitting one or more \u201cblank\u201d objects and one or more scripts. The blank objects could be partially configured, with remaining configuration to be performed during script execution. At step , the browser runs the script. The script may automatically configure the new object based on information from the projects tree. In some cases, a script may generate a dialog or other user interface which obtains necessary information from the user. As a result of executing the script(s), one or more new objects are created (black object boxes in ), modified (partially blackened object boxes) and\/or deleted in the local copy of the DDOM at the client. Related LLOM (or CODOM) changes may also be made (not shown). Addition of new objects, and modification and deletion of existing objects, are monitored by a transaction manager plug-in at the client (not shown) and by DOS , as previously described in connection with . The user may then \u201cCommit\u201d the data changes (i.e., instruct DOS  to update to database  the new and\/or modified and\/or deleted objects resulting from script execution), discard the changes, save the changes, or continue making more changes.",{"@attributes":{"id":"p-0188","num":"0187"},"figref":["FIGS. 23A and 23B","FIG. 23A","FIG. 23B"]},"Distributed Design Environment",{"@attributes":{"id":"p-0190","num":"0189"},"figref":["FIG. 24","FIG. 24"],"b":["62","62","62","48","48","58","58","50","1","62","48","48","62","2","3","62","58","48"]},"After the connection is made by client , DOS  downloads to client  an XML (extensible markup language) configuration file (step ). This configuration file specifies additional plug-ins to be loaded within the container applet (e.g., a design data manager, a transaction manager, etc.). The plug-ins to be downloaded are controlled based on user roles and permissions, which are discussed below. For example, user A may be authorized to access one collection of plug-ins and user B may be authorized to access different plug-ins. When scripts in the configuration file execute, the identity of the client  user is determined (based on, e.g., the login i.d. used to connect to DOS ), and based on that identity, user role determined. Once the user role is determined, plug-ins for that role and scripts for configuring those plug-ins are downloaded. In other embodiments, instead of a single configuration file for all users, each user may have a separate XML configuration file which is sent to a client based on the user i.d. of the client user connecting to DOS . A configuration file may also contain information regarding one or more \u201cworkspaces\u201d which have been specified for a user. Because the amount of space available within a container applet window is limited, certain plug-in windows are automatically set to certain sizes, some plug-in panes may be minimized, etc.","In step , the client downloads one or more plug-ins (as specified by the configuration file from step ) and scripts related to those plug-ins. As each plug-in is loaded, an event (on load) is generated, in response to which one or more scripts may be executed. These scripts configure the plug-in for the user. For example, the commands, menus and other features available to the user may be limited based on the user's role. After all plug-ins are loaded and configured, the user may then download from database  data for one or more projects (e.g., DDOM, LLOM and\/or CDOM objects)(step ). In some embodiments, CoDOM objects are downloaded instead of LLOM and CDOM objects. The projects for which a user may retrieve project data is similarly controlled based on user role. Once project data has been loaded, the user may begin editing.",{"@attributes":{"id":"p-0193","num":"0192"},"figref":["FIG. 25","FIG. 25"],"b":["1","2"]},"Associated with a user role is one or more privileges. Each privilege defines some action (or group of actions) a user may take. Examples include editing data for a specific project, editing certain types of data in a specific project, viewing data in a specific project, creating a project, deleting a project, approving a change request, assigning a role to a user, creating a role, editing a role, creating a library, adding or deleting a component or Cell from a library, etc.","One or more preferred libraries are also associated with each role. In some cases, a preferred library will include electrical components that are appropriate for design tasks of a given user role. For example, a design engineer  role (computer designer) may be associated with preferred libraries that include such things as memory chips, processors, etc. A preferred library may also include previously created functional blocks (i.e., previously-created Cell objects) that are typically used in particular field. In some embodiments, a user can access libraries in addition to those associated with his or her role(s). In other embodiments, a user may only access preferred libraries associated with his or her role(s).","One or more plug-ins are also associated with a role. A user may only download from DOS  the plug-ins associated with that user's role(s). Plug-ins for a design engineer role could include a design data manager, transaction manager, output window, viewer, schematic editor, HDL editor, and parts viewer. Plug-ins for a manufacturing engineer could include a DDM, transaction manager, a schematic viewer, and one or more plug-ins to program manufacturing equipment. A purchasing agent role may have a DDM plug-in, a parts viewer and a schematic viewer.","The workspace associated with a role defines which of the plug-ins for that role are initially loaded when a user having that role connects a client computer to DOS  (see, e.g., ). The workspace further defines how windows for those initially-loaded plug-ins will be sized and arranged on a client display. If the user wishes to close an opened plug-in or open a new plug-in, the user can uncheck (to close) or check (to open) the appropriate plug-in in a pull-down menu, as shown in . Listed in the \u201cadd-in\u201d pull-down menu are all plug-ins associated with a user's role(s). The user may also resize and\/or rearrange plug-in windows.",{"@attributes":{"id":"p-0198","num":"0197"},"figref":"FIG. 27","b":["58","50","58","50","1","5","1","5","1","2","3","1","2"]},"In at least some embodiments of the invention, a design environment loaded upon a client is in a language specific to a given user. For example, Users W and V may speak English, but User U may speak Japanese. Accordingly, when User U connects a client computer to DOS \/database , the plug-ins and design data are displayed in Japanese. Transactions, system messages, etc. are also in Japanese. In at least some embodiments implemented using the JAVA programming language, support for different languages is implemented using JAVA internationalization. JAVA internationalization is known in the art (see, e.g., <http:\/\/java.sun.com\/docs\/books\/tutorial\/i18n\/intro\/index.html>), and thus not described in detail herein. In brief, each supported language has a resource bundle in which strings to be displayed at a client are localized in that supported language. A default language preference is stored as part of a user profile, and can be changed by the user.","Certain embodiments of the invention also implement technology filtering. In particular, a specific technology type may be associated with a particular project. Technology types can include PCB technology, embedded component technology, certain soldering or other manufacturing methods, RF communication technology, digital logic, etc. This list is not exhaustive, and there may be overlaps between technology types. Available libraries for use with a particular project are then filtered by the user's role and by the technology(ies) associated with the project. For example, a user role may allow that user to access all libraries, but the user will only be presented with libraries applicable to a particular project on which he or she is working.","Although several examples of carrying out the invention have been described, those skilled in the art will appreciate that there are numerous variations and permutations of the above described examples that fall within the spirit and scope of the invention as set forth in the appended claims. The algorithms, system configurations, user interfaces, object models and other aspects described are merely examples. Modifications of the described algorithms, systems, interfaces, object models and other aspects are within the scope of the invention, as are numerous other algorithms, configurations, interfaces, object models and aspects."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 2A","FIG. 2"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 3A-3D"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 5B-5E"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIGS. 6A-6T"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIGS. 8A-8J"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 8K"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 10A-10C"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 11A"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 11B"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIGS. 13A-13C"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIGS. 14A and 14B"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 18A"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 18B"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 18C"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 18D"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIGS. 19A and 19B"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIGS. 20A and 20B"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIGS. 23A and 23B"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIGS. 28A-28D"}]},"DETDESC":[{},{}]}
