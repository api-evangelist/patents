---
title: Generating random sequences based on stochastic generative model having multiple random variates
abstract: Random sequences are generated based on a stochastic generative model having multiple random variates. Inputs representative of the stochastic generative model are received. The inputs include a first random variate having a finite set of alphabets, a second random variate having a set of alphabets, and a third random variate having a finite set of alphabets. Outputs representative of the random sequences are generated based on the stochastic generative model. The outputs include a first random sequence that is a finite-length random sequence of alphabets randomly selected from the first random variate, a second random sequence having a set of alphabets selected from the second random variate, and a third random sequence having a set of alphabets randomly selected from the third random variate.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08161329&OS=08161329&RS=08161329
owner: International Business Machines Corporation
number: 08161329
owner_city: Armonk
owner_country: US
publication_date: 20091111
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE DRAWINGS","DEFINITIONS","EXAMPLE","General System, Implementation Details, and Conclusion"],"p":["The present invention is generally related to generating random sequences of messages, which may be used to test a software entity that has an application programming interface (API). More particularly, the present invention is related to generating such random sequences based on a stochastic generative model having multiple random variates.","The task of verifying the functionality of a software entity, such as a software component or a web service, which exposes an application programming interface (API), typically involves constructing a test model of the software entity, designing test cases, designing test data, developing test scripts, and executing the test cases using the test scripts in relation to the test model. Automating the generation of test cases and corresponding tests data, from a test model can, however, be difficult to achieve.","For instance, typically software entities are governed by a programming model that describes rules and guidelines for interacting with the entity. A test case for a software entity is a sequence of messages (i.e., an API operation) that can stimulate the system in a desirable or undesirable manner. Since a large system will have many interacting software entities, which can exchange combinations of messages among them, the programming model in question defines the boundary conditions that distinguish valid combinations from invalid combinations. In order to maximize the possibility of detecting defects, it can be desirable to generate random sequences of messages as test cases. However, a collection of the random sequences must nevertheless satisfy a probability distribution governed by the programming model. As such, generating random, or stochastic, test cases has however proven difficult to accomplish in practice.","The present invention relates to generating random sequences based on a stochastic generative model that has multiple random variates. The random sequences may be used to test a software entity that has an application programming interface (API), for instance. A method of one embodiment of the invention is thus for generating random sequences based on a stochastic generative model having multiple random variates. The method is implemented by one or more computer programs executed by one or more processors such that execution of the computer programs by the processors causes performance of the method.","The method receives inputs representative of the stochastic generative model. The inputs include: a first random variate having a finite set of alphabets; a second random variate having a set of alphabets; and a third random variate having a finite set of alphabets. The method generates outputs representative of the random sequences based on the stochastic generative model.","The outputs include a first random sequence, a second random sequence, and a third random sequence. The first random sequence is a finite-length random sequence of alphabets randomly selected from the first random variate. The second random sequence has a set of alphabets selected from the second random variate. The set of alphabets of the second random sequence correspond to each alphabet of the first random sequence. The third random sequence has a set of alphabets randomly selected from the third random variate. The set of alphabets of the third random sequence correspond to each alphabet in the first random sequence.","A computer program product of an embodiment of the invention stores one or more computer programs. The computer programs are executable by one or more processors to perform a method to generate random sequences, including a first random sequence, a second random sequence, and a third random sequence, based on a stochastic generative model having multiple random variates. The method reads inputs representative of the stochastic generative model.","The inputs include: a first random variate having a finite set of alphabets; a second random variate having a set of alphabets; and, a third random variate having a finite set of alphabets. The inputs further include a first relative probability of occurrence of each alphabet within the first random variate to be found in the first random sequence, as well as a positional population density of the alphabets within the second random variate to be found along a length of the first random sequence. The inputs also include a second relative probability of occurrence of each alphabet within the third random variate to be found in the third random sequence.","The method validates the positional population density, processes the inputs, and normalizes the first relative probability of occurrence and the second relative probability of occurrence. The method then performs the following for each current position of a number of positions of a length of each of the first, second, and third random sequences, from a first position to a last position. First, the method generates the current position of the first random sequence based on the inputs. Second, the method generates the current position of the second random sequence based on the inputs. Third, the method generates the current position of the third random sequence based on the inputs.","A computing system of an embodiment of the invention is for generating random sequences based on a stochastic generative model having multiple random variates. The computing system includes hardware and a random sequence generator implemented via the hardware. The random sequence generator receives inputs representative of the stochastic generative model, and generates outputs representative of the random sequences based on the stochastic generative model.","The inputs include: a first random variate having a finite set of alphabets; a second random variate having a set of alphabets; and, a third random variate having a finite set of alphabets. The outputs include a first random sequence that is a finite-length random sequence of alphabets randomly selected from the first random variate. The outputs also include a second random sequence having a set of alphabets selected from the second random variate. The set of alphabets of the second random sequence correspond to each alphabet of the first random sequence. The outputs further include a third random sequence having a set of alphabets randomly selected from the third random variate. The set of alphabets of the third random sequence correspond to each alphabet in the first random sequence.","In the following detailed description of exemplary embodiments of the invention, reference is made to the accompanying drawings that form a part hereof, and in which is shown by way of illustration specific exemplary embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention. Other embodiments may be utilized, and logical, mechanical, and other changes may be made without departing from the spirit or scope of the present invention. The following detailed description is, therefore, not to be taken in a limiting sense, and the scope of the present invention is defined only by the appended claims.","In this section of the detailed description, various terms that are used throughout the remainder of the detailed description are defined in a general a non-limiting sense. Statistical randomness can be defined as a quality that a sequence has. In particular, a sequence is said to be statistically random when it contains no recognizable patterns or regularities. Examples of such sequences include the results of an ideal dice roll, as well as the digits of Pi.","A random sequence is a sequence of alphabets (selected from E) or numbers (selected from a range R), having a length L, where the following is true. L may be of infinite length or finite length. E is a set of independent or dependent alphabets. E is said to have independent alphabets, if its probability transition matrix is an identity matrix or a unit matrix. A probability transition matrix defines the probability of transitioning from one alphabet to another alphabet in a sequence, for all combinations. Some desired properties of random sequences can include unpredictability, a period length, a resolution, efficiency, and repeatability. Unpredictability is a very high degree of randomness, whereas as to period length, the longer the period the better. The resolution of the numbers in the sequence can be considered as multiples of 2, where 2is the resolution for L fractional binary digits between [0, 1]. Efficiency is the length of the sequence generated per a unit of time, such as per second. Repeatability is the ability to replicate the same random sequence, which can be useful in repeating simulating experiments.","A pseudo-random sequence is a sequence that appears to be random, but is not. A quasi-random sequence progressively covers a d-dimensional space with a set of points that are uniformly distributed. A low-discrepancy sequence has the property that for all N, the sub-sequence x, . . . , xis almost uniformly distributed, where x, . . . , xis almost uniformly distributed as well.","A stochastic pattern can be defined as follows. Stochastic models are models involving or containing a random variable or variables, and involve chance or probability. A pattern is a perceptual structure or feature within a domain, which can be used to make or to generate things or parts of a thing. A stochastic pattern is thus a recognizable stochastic model exhibit by a thing within a domain. It can be used to generate things or parts of a thing that are\u2014approximately or stochastically\u2014similar to the original thing.","A variate is a generalization of a concept of a random variable defined without reference to a particular type of probabilistic experiment. It is defined as the set of all random variables that obey a given probabilistic law. A random variate generation algorithm for real numbers is a program that halts with probability one and exits with real number X.","Problem Statement","In this section of the detailed description, a description or statement of the problem that is solved by at least some embodiments of the present invention is formally described. A system includes the following input random variates: \u03a9 having a finite set of alphabets X; \u03c8 having a set of alphabets Y; and, \u03bb having a finite set of alphabets W. The relationships among the random variates are as follows. \u03a9 is dependent on \u03bb, in that the alphabets in \u03a9 describe and control the nature of and the number of alphabets sampled from \u03bb. \u03c8 and \u03bb are independent of one another. \u03c8 is dependent on \u03a9, in that some of the alphabets in \u03a9, which are referred to as control alphabets, determine the creation and destruction or deletion of Yalphabets in \u03c8, and where the rate of creation and destruction is defined for each control alphabet in \u03a9.","The problem that is solved by at least some embodiments of the invention is to generate a multivariate sequence, as output, where each element in the sequence includes {S{N}, {V}}, and where the following is true: S\u2192{X}, i=1 to sequence length; N\u2192{Y}, j=1 to fy(X); V\u2192{W}, k=1 to fw(X)}. The function fy(X) defines the length of Nfor the given X, where the function fw(X) defines the length of Vfor the given X.","S is a finite-length sequence of alphabets random selected from \u03a9, with the following embedded, known spatio-temporal stochastic patterns defined for each alphabet in the sequence. The first pattern is the relatively probability of occurrence of each alphabet in the string S, the second pattern is the positional probability density for each alphabet in the string S. The third pattern is the probability of co-occurrences of alphabets as a function of distance between them and order, in the string S. The fourth pattern is the positional population density of alphabets in \u03c8, due to the presence of control alphabets in S.","N is a random sequence with a set of alphabets selected from \u03c8, corresponding to each alphabet in the sequence S, with the following embedded and known spatio-temporal stochastic patterns defined for each alphabet in \u03c8. The first pattern is fy(X), which is the number of alphabets from \u03c8, for Xin S. The second pattern is the distribution function describing the lifetime of alphabets in \u03c8.","V is a random sequence with a set of alphabets randomly selected from \u03bb, corresponding to each alphabet in the sequence S, with the following embedded and known spatio-temporal stochastic patterns defined for each alphabet in \u03bb. The first pattern is fw(X), which is the number of alphabets from \u03bb, for Xin S. The second pattern is the relative probability of occurrence of each alphabet, within the string V. The third pattern is the positional probability density for each alphabet, within the string V. The fourth pattern is the probability of co-occurrences of alphabets, as a function of distance between them and order, within the string V.","The method is to generate a final output sequence that is merged from the above three sequences: {<S, N, V>}. For example, an output sequence could be {<X, {Y, Y, Y}, {W, W}; <X, { }, {W, W}>}. The following observations regarding the problem statement are further noted. First, \u03a9, \u03c8, and \u03bb are representative random variates, in which a problem can include one of two things. First, the problem can include many \u03bb random variates, provided the \u03bb's are independent of one another and is independent of <\u03a9 & \u03c8>. Second, the problem can include many random-variate tuples <\u03a9, \u03c8>, provided they are independent of one another and are independent of \u03bb's in the system.","The second observation is that \u03a9 is similar to \u03bb, except for some alphabets that affect the random variate \u03c8. The third observation is that the system may include just the following types of stochastic patterns. The first type of stochastic pattern is the relative probability of occurrence of each alphabet in the generated string, which is applicable to \u03a9 and \u03bb. The second type is the positional probability density for each alphabet in the generated string, which is also applicable to \u03a9 and \u03bb. The third type is the co-occurrence probability of alphabets, as a function of distance between them and order, within the generate string, which is also applicable to \u03a9 and \u03bb.","The fourth type includes the pattern(s) described based on the relationship between the random-variable tuple <\u03a9, \u03c8>. Such patterns of the fourth type include the positional population density of alphabets in \u03c8, due to the presence of control alphabets in the generated sequence S, which is applicable to \u03a9. Such patterns of the fourth type also include the lifetime distribution of alphabets in \u03c8, due to the presence of control alphabets in the generated sequence S, which is applicable to \u03c8. The fifth type includes patterns in which the functions fy( ) and fw( ) for the alphabets in \u03a9 just specifies the number of alphabets sampled from \u03c8 and \u03bb for the final output sequence.","Overview of Generating Random Sequences",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1","b":["100","100","102","104","102","104","100"]},"In general, inputs  are provided to the random sequence generator , which correspondingly generates random or stochastic sequences as its outputs . The outputs  are the parameters and other inputs specified by the API of the sequence consumer  in one embodiment. Furthermore, in one embodiment, some degree of feedback  may be provided by the sequence consumer  to the random sequence generator , although this is not required. For instance, the feedback  may be based on outputs of the sequence consumer , which can then guide the random sequence generator  as to providing additional relevant random sequences for consumption by the consumer .","The random sequence generator  accepts the following generative model parameters as the inputs . The first input is X, which is the set of alphabets in \u03a9. This set of alphabets includes C, which is a set of alphabets in \u03a9 that will result in creation of Yin \u03c8; D, which is a set of alphabets in \u03a9 that will result in deletion of Yfrom \u03c8; and, Z, defined as Xminus the union of Cand D. The second input is Y, which is the set of alphabets in \u03c8, and the third input is W, which is the set of alphabets in \u03bb.","Additional generative model parameters that are part of the inputs  can include dependencies between \u03a9 and \u03c8. Such dependencies include vector functions fy(C), fy(D), and fy(Z). The vector function fy(C) describes the creation characteristics of alphabets in C and the number of Ycreated in \u03c8. The vector function fy(d) describes the deletion characteristics of alphabets in D and the number of Ydeleted from \u03c8. The vector function fy(Z) describes the operation characteristics of the alphabets in Z and is the number of Yused by Z.","Additional generative model parameters that are part of the inputs  can include dependencies between \u03a9 and \u03bb, specifically the vector function fw(X). The vector function fw(X) describes the operation characteristics of alphabets in \u03a9 and the number of Wused by X. Another generation model parameter that is part of the inputs  is a unique random sequence of numbers U within the range [0, 1], generated by a function G.","The outputs  generated by the random sequence generator  includes random sequences S, N, and V. The random sequence S is a sequence with alphabets from \u03a9, and has a sequence length seq-len. The random sequence N is a sequence of an ordered collection of Y, with alphabets from \u03c8. The size of each entry in the sequence N is determined by the corresponding alphabets in S and fy( ) and the sequence N has the sequence length seq-len as well. The random sequence V is a sequence of an ordered collection of W, with alphabets from \u03c8. The size of each entry in the sequence V is determined by the corresponding alphabets in S and fw( ) and the sequence V has the sequence length seq-len, too.","The generative model of the random sequence generator  may also have the following stochastic pattern definitions, which may be built into the generator , or provided by the inputs , and which have to be presented in the generated output sequences. The first pattern is Rx, which is the relative probability of occurrence of Xin S, the second pattern is Px, which is the positional probability distribution for Xin S, and the third pattern is Mx, which is the probability distribution function describing a pair-wise co-occurrence of alphabets in S, as a function of distance between them.","A fourth pattern is Qy, which is the position population density of Y in \u03c8, along the length of the output sequence S, and a fifth pattern is Ty, which is a lifetime distribution function of the alphabets in \u03c8. A seventh pattern is Rw, which is the relative probability of occurrence of Win V, an eighth pattern is Pw, which is the positional probability distribution for the Win V, and a ninth pattern is Mw, which is the probability distribution function describing a pair-wise co-occurrence of alphabets in V, as a function of distance between them.","Furthermore, the generative model of the random sequence generator  may also have the following generative rules, which may be built into the generator , or provided by the inputs , and which prescribe the rules of generation of the generator . These rules include the presence or absence of \u03bb in the generative model, as well as the presence or absence of each of the following stochastic patterns in S: Rx, Px, Mx, and Qy. The rules further include the presence or absence of the stochastic pattern Ty in N, as well as the presence or absence of each of the following stochastic patterns in V: Rw, Pw, and Mw.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 2","b":["200","200","200","200","202","200","204"]},"In one embodiment, part  of the method  is performed as follows. The position population density Qy is validated (), to determine whether this expected Qy is achievable, based on the knowledge of the ability of the alphabets in C and D to create and\/or delete elements, respectively, in \u03c8. The inputs are then processed and initialization is performed (). For instance, processing may include analyzing the input for the presence or absence of the stochastic patterns (Rx, Px, Mx, Qy, Ty, Rw, Pw, and Mw), and initializing these patterns with default values. Likewise, the output sequences S, N, and V is initialized, an age vector Yage for the alphabets in \u03c8 is initialized, and the actual population of Yin \u03c8, represented as Ay, is initialized. The probabilities of occurrence\u2014i.e., the vectors Rx and Rw\u2014are then normalized ().","Thereafter, for each current position of a sequence length ranging from a first position in each sequence to a last position in each sequence\u2014i.e., 0<=k<seq-len\u2014the following is performed (). The current position of the first random sequence, S, is generated based on the inputs (). More specifically, the input vector Px is normalized for the k-th position, and the probability distribution vector for the alphabets in \u03a9, Py, is determined based on the expected population of Yin \u03c8 (i.e., Qy) and on the actual population of Y(i.e., Ay). The probability distribution vector for alphabets in \u03a9, MPx, is also determined, based on the co-occurrence probability Mx for the previously generated alphabets in S. The overall probability distribution vector of \u03a9 for the k-th position of S is then determined, keeping in mind any applicable generative rules, which may be represented as G. The overall probability distribution vector is VPx, and is equal to Rx\u00d7Px\u00d7MPx\u00d7Py. Finally, Sis obtained by sampling the non-uniform random variate \u03a9 having the probability distribution vector VPx for an alphabet, using the uniform random variate U.","The current position of the second random sequence, N, is also generated based on the inputs (). More specifically, Nis obtained by sampling the non-uniform random variate \u03c8 having the age distribution vector Yage, for fy(S) alphabets. As part of part , Ay may also be determined as the modified population of Yin \u03c8. Finally, the current position of the third random sequence, V, is generated based on the inputs as well (). More specifically, the input vector Pw is normalized for the k-th position, and the probability distribution vector for alphabets in \u03c8, MPw, is also determined, based on the co-occurrence probability Mw for the previously generated alphabets in V. The overall probability distribution vector of \u03bb for the k-th position of V is then determined, keeping in mind any applicable generative rules, which may be represented as G. The overall probability distribution vector is VPw, and is equal to Rw\u00d7Pw\u00d7MPw. Finally, Vis obtained by sampling the non-uniform random variate \u03bb having the probability distribution vector VPw for fw(S) alphabets.","The random sequences are then output (). That is, {S, {N}, {V}} is output for 0<\u2212k<seq-len. These outputs can then be used to test a software entity, for instance (). In particular, elements from the sequence S, N, and V form tuples <s, n, v> that are used as input for a sequence consumer, such as a software entity represented by a simulation engine or a system being tested. It is noted that in the method , generating Sand generating Nare used to sample the random-variate tuple <\u03a9, \u03c8> to generate Sand N, respectively. Furthermore, generating Vis used to sample the \u03bb random variate, to generate V.","The method  can be extended for additional random variates, in addition to \u03a9, \u03c8, and \u03bb, provided that such additional random variates subscribe to the properties described in the problem statement above. That is, for all additional random-variate(s), which are similar to \u03bb and there is a need to generate a corresponding sequence comparable to V, the method  is extended to provide additional such sequence in the same way as Vis generated. Likewise, for all additional random-variate tuples, which are similar to <\u03a9, \u03c8>, the method  can be extended to provide additional generations of sequences comparable to Sand N, in the same way as Sand Nare generated.","It is further noted that the random variates in the generative model are assumed to operate on a sample space with finite and uniquely identifiable elements. Another assumption is that the size of the in-memory representation of the distribution function associated with the random variates is limited by a given system's memory. A third assumption is that interference between random variates\u2014particularly between the probability distribution functions\u2014may exist within the generative model but will not be discovered by the generator.","It is finally noted that the generation of random or stochastic sequences via the method  has various measurable desirable characteristics. These characteristics include repeatability, which is that a given random sequence is reproducible for the same input data values. These characteristics also include faithfulness, which is that a stochastic pattern is faithfully reproduced within the resulting sequences for non-interfering patterns. These characteristics finally include extensibility, which is that multiple random sequences are efficiently generated. Tests performed by the inventors on an embodiment of the invention show that high repeatability, faithfulness, and extensibility are provided, which is an advantage of the present invention.","In the context of software entity testing, the test input vector used to verify the behavior of the entity in question is a series of tuples <O, M, P>. Mis an application program interface (API) method of the software component, Ois the target entity (i.e., state variable), and Pincludes parameters of the method M. In a simplified scenario a multivariate sequence generator can use a random-sequence-generation approach to generate a series of methods from M, objects from O, and parameter values from domain D. However, in actuality, a programming model of the software entity typically imposes various constraints on the API.","Such constraints include the order of invocation of the methods. For example, in socket programming, a typical program will open a socket, then open an input stream, then read from the stream, then close the stream, and finally close the socket. Another constraint is the parameter passing between method invocations in a call sequence. In the previous example, for instance, the read-from-stream operation needs the output of the previous operation (namely, the open-stream operation) as its input parameter. This is a type of feedback that has been described in the previous section of the detailed description. A third constraint includes the initialization and exit conditions of the state variables, if the software entity being tested is a stateful software entity.","In the context of software entity testing, then, \u03c8 is a finite, discrete sample space including all the entities (i.e., target object instances) that the API methods will operate on, where Y is the discrete random variable on \u03c8. Furthermore, \u03bb is a finite, discrete sample space including all the data values that the API methods will use as parameters, where W is the discrete random variable on \u03bb. Additionally, \u03a9 is a finite, discrete sample space including all the API methods of the software entity, where X is the discrete random variable representing all of \u03a9, and where fy is a function that describes the operation characteristics of the API method in \u03a9, and which maps an API method in \u03a9 to a random collection of entities in w for its execution.","Also in the context of software entity testing, C is the discrete random variable representing the set of all the creation API methods in \u03a9. The execution of the creation API methods results in the addition of uniquely identifiable entities Y to \u03c8. Fy(c) is a function that describes the creation characteristics of the API method in \u03a9. Fy(c) maps an API method in \u03a9 to a random collection of entities in \u03c8 after its execution.","Furthermore, D is the discrete random variable representing the set of all destruction or deletion API methods in \u03a9. The execution of these API methods results in the removal of uniquely identifiable entities Y from \u03c8. Fy(D) is a function that describes the deletion characteristics of the API method in \u03a9. Fy(D) maps an API method in \u03a9 to a random collection of entities in \u03c8 before its execution.","Furthermore, other sample spaces include \u03be, \u03b7, and \u03c7. The sample space \u03be includes all the random sequences of API methods (from \u03a9), where each operates on an entity selected from \u03c8. S is a discrete random variable representing all of \u03be. The sample space \u03b7 includes all the random sequences of entities (from \u03c8) to be operated on by the API methods selected from \u03a9. N is a discrete random variable representing all of \u03b7. The sample space \u03c7 includes all the random sequences of entities (from \u03bb) to be used as parameter values by the API methods selected from \u03a9. V is a discrete random variable representing all of \u03c7.","Detailed Embodiments for Generating Random Sequences","In this section of the detailed description, detailed embodiments for generating random sequences using stochastic generative models are presented. In its simples form, a multivariate sequence generator \u03b6 maps a random list of <X> (from \u03a9) to S (from \u03be), maps a random list of <Y> (from \u03c8) to N (from \u03b7), and maps a random list of <W> (from \u03bb) to V (from \u03c7). The length of S, N, and V are the same, and the elements of S, N, and V form a sequence of tuples <s, n, v> for the sequence consumer. The stochastic patterns in the resulting sequences S, N, and V are known a priori to the generator \u03b6, and are referred to as a stochastic generative model, or SGM, herein.","The SGM includes multiple random variables, such as X, Y, W, S, N, and V), by sampling from the respective random spaces (such as \u03a9, \u03c8, \u03be, \u03b7, and \u03c7) as described by an expected arbitrary probability, or EAD. The EAD are the embedded stochastic patterns in S, N, and V. The SGM can be incrementally constructed by analyzing each random variate and its associated EAD as follows.","First, R(X) is the EAD of Xin \u03a9, where R is the relative probability of occurrence of each element from \u03a9, in the sequence S. For example, if R follows a uniform distribution function, then all the elements in \u03a9 will have an equal probability of occurrence in the sequence S, generated by the generator. In another example, if \u03a9 is the set of {X, X, X, X, and X} and the corresponding R(X) is {0.2, 0.1, 0.05, 0.05, and 0.6}, then the random sequence generator takes into account this non-uniform distribution function while generating the sequence. Hence, the generated sequence will have more Xthan X, X, X, and X, in that order.","Second, P(X, t) is the EAD of Xin \u03a9, at time T=t. In other words, the relative probability of occurrence of each element from \u03a9 is dependent on its position in the generated random sequence S. For example, \u03a9 may be a set of {X, X, X, X, and X} and the probability density function may vary with time tin which the change in the probability of occurrence of Xoccurs at T=t, t, . . . , t. The change in the probability of occurrence of Xalong the t-axis (i.e., the index position in the sequence) acts as an EAD pattern P(X, t) for the sequence generator. For example, the EAD pattern may state that Xwill not occur at T, T, T, and T, since the probability of occurrence is zero. The EAD pattern as another example may state that at T=T, the arbitrary probability distribution pattern can be read as X=0.3, X=0.1, X=0.3, X=0, and X=1. After normalization, this can be transformed into an arbitrary non-uniform probability distribution function that influences the sequence generation.","Third, M(X, X, d) is the EAD that governs the probability of occurrence of Xat position m in the sequence S, as a function of distance d, given the occurrence of Xat position n, where m>n. This aspect of the stochastic model describes the affinity (or repulsion) between two elements of \u03a9 as a function of its distance d, as well as the order of occurrence of the elements of \u03a9. For example, if M(X, X, d) follows an exponential probability density (\u03bbe), where d is 1\/\u03bb, given the occurrence of X(at n), a smaller value of d will influence the generator to generate Xas close to Xas possible. Similarly, this also influences the order of occurrence in S.","Fourth, Q(Y, t) is the population density (i.e., EAD) of Yin \u03c8, at time T=t. The population density of elements in \u03c8 can thus vary along the length of S. Therefore, P(Y, t) has an indirect impact on the distribution and occurrences of C and D within the sequence S. For example, if Q(Y, t) follows a normal distribution, then the generated application programming interface (API) method sequence initially has higher density of elements from C, to ensure an increase in population density in accordance with such a distribution. The latter half of the random sequence has a higher density of elements from D, to again ensure reduction in population and conform to the normal distribution. Therefore, the rate of change of the EAD population density function determines the positional probability distribution function of the elements in C and D.","Initially, the generator is based on equal probability of occurrences of all elements \u03a9 (including C and D) in S. Subsequent occurrences of elements from C and D are affected by the EAD Q(Y, t) as follows. First, a positive rate of change in the population density function means that the probability of occurrences of an element from C has to be greater than D, and the magnitude is determined by the rate of change. Second, a negative rate of change in population density gives a higher probability of occurrences of an element from D than from C.","Fifth, T(y) is the EAD of the lifetime of an entity from \u03c8 in Y. If S is the sequence selected by the generator, the lifetime distribution T(Y) will have an impact on the selection of Y's in the corresponding sequence N generated by the same generator. Primarily, the occurrences of elements from D in S impacts the choice of the Y's in N, to ensure adherence to T(Y). For example, if T(Y) follows a normal distribution, the following is true. For every occurrence of an alphabet from C in the control sequence C, creations of Y's in \u03c8 result. Furthermore, for every occurrence of an alphabet from X (other than C or D) within the control sequence S, a random selection of Y elements from \u03c8 results, depending on the number of Y elements needed by the element (from X). Finally, for every occurrence of an alphabet from D in the control sequence S, a random selection of Y elements from \u03c8 results, such that the termination time of the randomly selected Y elements follows T(Y)\u2014the normal distribution function. That is, from the sample space \u03c8, entities are sampled such that the age of the selected Y elements fit T(Y)\u2014the normal distribution function.","Sixth, R(W) is the EAD of Win \u03bb, where R is the relative probability of occurrence of each element from \u03bb, within the sequence V. Seventh, P(W, t) is the EAD of Win \u03bb, at time T=t. That is, the relative probability of occurrence of each element from \u03bb is dependent on its position in the generated random sequence V. Eighth, M(W, W, d) is the EAD that governs the probability of occurrence of Wat position m in the sequence V, as a function of distance d, given the occurrence of Wat position n, where m>n.","In summary, then, the SGM is a combination of the following random variates (and one or more of their associated EAD's). The first random variate is X, where R(X) is the relative probability of occurrence of elements from \u03a9 in S, P(X, t) is the positional probability distribution of elements from \u03a9 in S, and M(X, X, d) is the affinity description function between Xand Xas a function of distance d. The second random variate is Y, where Q(Y, t) is the positional population density function of elements Y in \u03c8, and T(Y) is the expected lifetime of elements Y in \u03c8. The third random variate is W, where R(W) is the relatively probability of occurrence of elements from \u03bb in V, P(W, t) is the positional probability distribution of elements from \u03bb in V, and M(W, W, d) is the affinity description function between Wand Was a function of distance d.","A multivariate sequence generator thus accepts the SGM as input, and generates the following sequences. The first sequence is S, which is an ordered list of elements from \u03a9, such as {X, X, X, X, X}. The second sequence is N, which for each element of S, includes a list of elements from \u03be, such as {{Y, Y, Y}, { }, {Y, Y}, {Y}, {Y, Y, Y}, {Y}}. The third sequence is V, which for each element of S, includes a list of elements from \u03c7, such as {{W, W, W}, {W}, {W, W}, {W, W}, { }}.","Characteristics of the SGM include spatio-temporal characteristics of the EAD, as follows. R(X) specifies a spatial distribution along the X dimension, which affects the choice of elements from \u03a9 uniformly at all positions within the sequence S, has a temporarily uniform and global impact for all t, and has spatially arbitrary and global impact for all elements of X. P(X, t) specifies spatial (along the X dimension) and temporal (along the t dimension) distribution. P(X, t) affects the choice of elements from \u03a9 differently at each position in the sequence S, has a temporally arbitrary and local impact determined by the t variable in the distribution function, and has a spatially arbitrary and local impact determined by the X variable in the distribution function.","M(X, X, d) specifies a temporal distribution across two elements in X, and affects the choice of elements from \u03a9 depending on the occurrence of Xin S for a duration D. M(X, X, d) has a temporally arbitrary and localized impact for duration d and a spatially and localized impact for just two points in space. M(X, X, d) can temporally interfere with itself, in situations where Xis generated within the given duration d. Furthermore, one M(X, X, d1) can interfere with another M(X, X, d2), in situations where Xis generated within the given duration d1.","Q(Y, t) specifies the temporal distribution of Y along the t dimension. Q(Y, t) indirectly affects the choice of elements from \u03a9 (particularly elements in C and D) at each position in the sequence S, and affects the choice of elements from \u03c8 at each position in N, since it results in the creation of new elements in \u03c8. Q(Y, t) has temporally arbitrary and global impact for all t, and a spatially arbitrary and localized impact on the elements in C and D.","T(Y) specifies the temporal distribution of Y along the t dimension, and affects the choice of elements from \u03c8 at each position in N. T(Y) has a temporally arbitrary and global impact for all t, and a spatially arbitrary and localized impact on the elements \u03c8. R(W) specifies a spatial distribution along the W dimension, and affects the choice of elements from \u03c8 uniformly at all positions in the sequence V. R(W) has a temporally uniform and global impact for all t. R(W) further has a spatially arbitrary and global impact for all elements of W.","P(W, t) specifies spatial distribution along the W dimension and temporal distribution along the t dimension. P(W, t) affects the choice of elements from \u03c8 differently at each position in the sequence S. P(W, t) has a temporally arbitrary and local impact determined by the t variable in the distribution function, and a spatially arbitrary and local impact determined by the W variable in the distribution function.","M(W, W, d) specifies a temporal distribution across two elements in W, and affects the choice of elements from \u03a9 depending on the occurrence of Win V for a duration d. M(W, W, d) has a temporally arbitrary and localized impact for duration d, and a spatially arbitrary and localized impact for just two points in space. M(W, W, d) can temporally interfere with itself, in situations where Wis generated within the given duration d. Furthermore, one M(W, W, d1) can temporally interference with another M(W, W, d) in situations where Wis generated within the given duration d1. It is noted that the term arbitrary as used herein refers to a non-linear function.","It is noted that an SGM with more than one EAD\u2014namely R(X), P(X, t), M(X, X, d), Q(Y, t), T(Y), R(W), P(W, t), and M(W, W, d)\u2014will results in non-linear stochastic interference. That is, for a given position within the generated sequence S (or N or V), more than one EAD will affect the occurrence of an element from X (or Y or W). These interference fields can result in unpredictable behavior.","There are two aspects of interference that can affect whether an SGM behaves predictably. The first aspect is the region of interference. Overlapping regions of interference may result in unpredictable behavior, whereas non-overlapping regions do not. A region is defined by the range in the t-dimension and in the X- (or Y-) dimension. For example, a region Rcould be defined as [3<t<6, {X, X}], and another region Ras [0<t<3, {X, X, X}], and a third region R[5<t<8, {X, X}]. In this example, Rand Rare non-overlapping, whereas Rand Roverlap.","The second aspect is the nature of the interference. A conflicting region of interference may result in unpredictable behaviors, whereas a converging region of interference does not. An example of a conflict is, for a given position in S, where R(X) requires a very high probability of occurrence of Xwhereas P(X) requires a very low probability of occurrence of X. An SGM is thus said to have interference if and only if, there exist overlapping regions in the EAD, and the EAD is conflicting in these overlapping regions. A multivariate sequence generator performs predictably for non-interfering EAD's within the SGM.","A multivariate sequence generator has two following core operations, which are referred to herein as uniform-to-arbitrary (U2A) mapping and random-select (RSelect). As to the first operation, OutVal is defined by U2A (InVal, OutSet, Px). Specifically, InSet is a sample space having values in the range [0, 1]. InVal is a discrete input variate on InSet, with a uniform probability distribution. OutSet is a sample space having discrete elements, and OutVal is the discrete random variable on OutSet, with an arbitrary probability distribution Px.","The operation U2A can be effectuated as follows. First, the input <Px> of length Lis sorted in ascending order, and the vector <OutSet> is arranged in the same sorted order as <Px>. Next, a range matrix of Rng dimension L\u00d72 is prepared, where Rng[0] holds minValue and Rng[1] holds maxValue of the range. The Rng is filled with values from the sorted Px, as follows. Rng[0]=0 and Rng[1]=Px. For all i, 0<I<L, Rng[0]=Rng[1] and Rng[1]=Rng[0]+Px. Third, the input InSet is mapped to OutSet, and the OutVal of the given InVal is determined as follows. If (Rng[0]<=Rng[1]), where i=0 to L, then OutVal=OutSet[i], else OutVal=the null set. Finally, OutVal is returned.","As to the second operation, OutVal is defined by RSelect (aSet, inAge, outDist, outSize). <aSet> is a sample space having discrete elements (i.e., an ordered collection); <inAge> associates a number to the elements of <aSet>, which is interpreted as the age of an element in <aSet>. <OutVal> is a discrete random variate on <aSet>, having a probability distribution described by <outDist>, and <outDist> is a distribution function over the age of the elements in <aSet>. For example, a distribution function can be defined as follows:",{"@attributes":{"id":"p-0077","num":"0076"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["P","outDist"]},"mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"0.0"},{"mrow":{"mi":"t","mo":"<","mn":"5"}}]},{"mtd":[{"mrow":{"mn":"0.2","mo":"*","mrow":{"mo":["(",")"],"mrow":{"mi":"t","mo":"-","mn":"5"}}}},{"mrow":{"mn":["5","10"],"mo":["\u2264","\u2264"],"mi":"t"}}]},{"mtd":[{"mn":"1.0"},{"mrow":{"mi":"t","mo":">","mn":"10"}}]}]}}}}},"br":{}},"The operation RSelect can be effectuated as follows. First, a uniform random variate iRand is initialized to generate random numbers within the value range [0, 1]. Next, for all k, 0<k<=outsize, the following is performed. The input <inAge> is sorted in ascending order, and the input <aSet> is rearranged in this same order. The mxAge and mnAge values are determined from <inAge> such that mnAge is the least value in the sorted <inAge> vector and mxAge is the largest value in the sorted <inAge> vector. The value of <outDist> is copied to a probability distribution vector VPx for the age range [mnAge, mxAge], where the index of VPx maps to the age value. Wx is prepared with weights for each index value of VPx by counting the number of elements in <aSet> with the index value (or the age value) in inAge; i.e.:\n\n\u2200,(Age\u2266Age),\n\n{count(Set)inAge\n\nThe weighted VPx is then normalized such that:\n",{"@attributes":{"id":"p-0079","num":"0078"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":"\u2200","mi":"i"},{"mo":["(",")"],"mrow":{"mi":["mnAge","i","mxAge"],"mo":["\u2264","\u2264"]}},{"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":["VPx","i"]},{"mi":["Wx","i"]}],"mo":"\u00d7"}},"mo":"\u2261","mn":"1"}],"mo":[",",","]}}}},"An index vector iVect is prepared, such that for all k, mnAge<=k<=mxAge, iVect=k. A random integer number is generated in the range [1, mxAge], and which follows a distribution <VPx>. Thus, rIndex=U2A (iRand, iVect, VPx), and if rIndex is equal to the empty set, then outValis set to the empty set. However, if rIndex is not equal to the empty set, then an element is selected randomly from the subset of elements in <aSet> that have the same rIndex in <inAge>, and they are stored in outVal; i.e.:\n\nSubSet{\u2200SetinAgeIndex}\n\noutValrandom select an element from {SubSet}\n\nIn this latter step, for the element outVal, its corresponding entry is removed from <aSet>. Finally, <outVal> is returned.\n","To conclude the detailed embodiment for generating random sequences in this section of the detailed description, the method  of  is referred to once again, in more particular but in consistent fashion than as has been described above. The method  generates the random sequences S, N, and V, from the given \u03a9, \u03c8, and \u03bb, given X, R(X), P(X, t), M(X, X, d), given Y, Q(Y, t), and T(Y), and given W, R(W), P(W, t), and M(W, W, d).","First, inputs representative of the SGM are read or otherwise received (). The inputs include the following. One input is a vector <X> of length L, having elements from \u03c9 that include a vector <C>, a function fy(C), a vector <D>, a function fy(D), and a vector <Z>. The vector <C> is of length L, with creation elements from \u03a9; the occurrence of an element from <C> in outSeq results in the creation of Y in \u03c8. The function fy(C) determines the number of Y's created by C. The vector <D> is of length L, having destruction elements from \u03a9; the occurrence of an element from <D> in outSeq results in the deletion of Y in \u03c8. The function fy(D) determines the maximum number of Y's to be deleted by D, whereas the vector <Z> is of length L(defined as L-L-L) and has elements from {X}\u2014{C}-{D}.","Another input includes a uniform random sequence variate U, which generates a pseudo-random sequence <inSeq> of Length L(==L), with range [0, 1]. An input vector <Y> has length Linput vector <Y> has length Lwith elements from \u03c8. An input vector <W> has length Lwith elements from \u03bb.","Additional inputs include the expected arbitrary probability distribution (EAD), including a vector <Rx>, a matrix <Px>, an indexed collection of vectors Mx(X, X), a vector <Qy>, a vector <Ty>, a vector <Rw>, a matrix <Pw>, and an indexed collection of vectors Mw(W, W). The vector <Rx> is of type double[ ] and has length L, and represents an arbitrary non-uniform discrete probability distribution. The matrix <Pis also of type double, has dimensions L\u00d7L, and represents an arbitrary distribution pattern of each Xalong the length of the output sequence (or time axis). The value range is [0, 1], and the sum of all the values along the time axis need not be 1.","The collection Mx(X, X) is indexed by the tuple <X, X>, and has a value that is a vector representing an arbitrary affinity pattern between Xand Xalong the length of the output sequence (or time axis). The elements of the vector are of type double[ ], and have values within the range [\u22121, 1]. The value of 0 indicates no affinity or repulsion, whereas positive values indicate affinity and negative values indicate repulsion. Values closer to 1 indicate greater affinity as compared to values closer to 0. Likewise, values closer to \u22121 indicate greater repulsion as compared to values closer to 0. The length of the vector describes the depth of the dependency between Xand X. The vector for <X, X> need not be the same as <X, X>, since the former captures the relative affinity of X, given the occurrence of X, and the latter captures the relative affinity of X, given the occurrence of X.","The vector <Qy> is of type double[ ] and has a length L. This vector represents an expected arbitrary non-uniform population density of Y's along the length of the output sequence (or time axis). The index of the vector represents the time line, and the vector's values are positive numbers, representing the population of Y's in \u03c8. The initial absolute population of Y in \u03c8 can be 0 (or Qy), however.","The vector <Ty> represents the expected lifetime distribution function of Y's in \u03c8 over the age of elements in \u03c8. For example, the distribution function can be defined as follows:",{"@attributes":{"id":"p-0088","num":"0087"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Ty","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mn":"0.0"},{"mrow":{"mi":"t","mo":"<","mn":"5"}}]},{"mtd":[{"mrow":{"mn":"0.2","mo":"*","mrow":{"mo":["(",")"],"mrow":{"mi":"t","mo":"-","mn":"5"}}}},{"mrow":{"mn":["5","10"],"mo":["\u2264","\u2264"],"mi":"t"}}]},{"mtd":[{"mn":"1.0"},{"mrow":{"mi":"t","mo":">","mn":"10"}}]}]}}}}},"br":{}},"The vector <Rw> is of type double[ ] and has a length L. This vector represents an arbitrary non-uniform discrete probability distribution. The matrix <Pw> is also of type double, and has dimensions L\u00d7L. This matrix represents an arbitrary distribution pattern of each Walong the length of the output sequence or time axis. The range of the values is [0, 1], and the sum of all the values along the time axis does not have to be 1. Finally, Mw(W, W) is an indexed collection of vectors, where the index is a tuple <W, W>, and its value is a vector that represents an arbitrary affinity pattern between Wand Walong the length of the output sequence or time axis.","Still referring to , outputs are generated that are representative of the random sequences, based on the SGM as represented by the inputs (). Specifically, these outputs include pseudo-random sequences S, N, and V all having the length L. The sequence S is a vector of elements from \u03a9. The sequence N is a vector of collections of elements from \u03c8. The sequence V is a vector of collections of elements from \u03bb.","The outputs are generated as follows. First, the position population density, or Qy, if provided is verified or validated (). Specifically, it is verified that the rate of positive change of values in Qy is less than the maximum possible number of Y's that can be created by a Cin <C>. That is, Max of Fy(C), for all <C>,\n\n\u2200()\u2192\u03c8:\u2225\u03c8\u2225\u2212\u2225\u03c8\u2225\n\n\u2200\n\n\u2203max()\u2266max()\u22000\n\nIt is further verified that the rate of negative change of values in Qy is less than the maximum possible number of Y's that can be deleted from \u03c8 by and din <D>. That is, Max of Fy(d), for all <D>,\n\n\u2022()\u2192\u03c8:\u2225\u03c8\u2225\u2212\u2225\u03c8\u2225\n\n\u2022\n\n\u2203max(||)\u2267max(||)\u2200>0\n\nA failure is reported if either of these conditions cannot be met. While the method  can continue after reporting failure, faithfulness as to the specified population profile cannot be guaranteed in this instance.\n","Next, the inputs are processed and initialization is performed (). The output sequences S and N are each initialized as an empty list { }. If input Rx is not provided, an Rx vector of length L=1 is created. If Mx is provided, Lx\u2014the maximum depth of the vectors in Mx\u2014is determined. If Qy is provided, the desired population change vector, DQy is determined as, for all I, (0<I<L), DQy=Qy\u2212Qy. Furthermore, if Qy is provided, the mean \u03bcis determined, and the standard deviation \u03c3is determined, for the desired population change vector DQy. More specifically, \u03bcis the mean of DQy, where 0<i<L, and \u03c3is the standard deviation of DQy, where 0<i<L.","Furthermore, for all X elements in \u03a9, a Y contribution vector YC is prepared as follows. First, if the element in \u03a9 is a member of D, then \u2212fy(D) is copied into the corresponding position of the YC vector. That is,\n\n\u2200\n\n\u2203\n\n()\n\nSecond, if the element in \u03a9 is a member of Z, then 0 is copied into the corresponding position of the YC vector. That is,\n\n\u2192sizeof()\n\n\u2200\n\n\u2203\n\n0\n\nThird, if the element in \u03a9 is a member of C, then the Fy(C) is copied into the corresponding position of the YC vector. That is,\n\n\u2192sizeof()\n\n\u2200\n\n\u2203\n\n()\n","Part  of the method  concludes as follows. For all Y elements in \u03c8, a Yage vector is initialized as zero. Finally, the variable Ay, representing the actual population of Y, is also initialized to zero. Next, the probabilities of occurrence are normalized (). That is, the input vector Rx and the input vector Rw are each normalized. Specifically, the input vector Rx is normalized such that:",{"@attributes":{"id":"p-0095","num":"0094"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":"\u2200","mi":"i"},{"mo":["(",")"],"mrow":{"mn":"0","mo":["\u2264","<"],"mi":"i","msub":{"mi":["L","x"]}}},{"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["Rx","i"]}},"mo":"\u2261","mn":"1"}],"mo":[",",",",","]}}},"br":{}},{"@attributes":{"id":"p-0096","num":"0095"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":"\u2200","mi":"i"},{"mo":["(",")"],"mrow":{"mn":"0","mo":["\u2264","<"],"mi":"i","msub":{"mi":["L","w"]}}},{"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["Rw","i"]}},"mo":"\u2261","mn":"1."}],"mo":[",",","]}}}},"Next, for each current position of the sequence length, from the first position to the last position\u2014that is, for each position k (0<=k<L) the following is performed (). First, the current position of the random sequence S, S, is generated based on the inputs (). If Px is provided, Px is prepared by normalizing the k-th vector within the input matrix Px, such that:",{"@attributes":{"id":"p-0098","num":"0097"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":"\u2200","mi":"i"},{"mo":["(",")"],"mrow":{"mn":"0","mo":["\u2264","<"],"mi":"i","msub":{"mi":["L","x"]}}},{"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":"Px","mrow":{"mo":["(",")"],"mrow":{"mi":["i","k"],"mo":","}}}},"mo":"\u2261","mn":"1."}],"mo":[",",","]}}},"br":{},"sub":"k+1"},"The probability distribution vector for all elements in <X> is also initialized in part :\n\n\u2200\u21920.\n\nNext, the desired population change DPQy is determined as Qy\u2212Ay, and if DPQy is zero, then the probability Py for each element in <X> is determined as:\n\n\u2200(0)\u21921\/sizeOf()\n\n\u2200(0)\u21920\n\nIf DPQy is positive, then the probability Py is determined for each element in <X>, using DPQy as the mean and \u03c3as the deviation of a normal distribution function as follows:\n",{"@attributes":{"id":"p-0100","num":"0099"},"maths":[{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2200","mrow":{"mrow":[{"mrow":{"mi":"i","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"0","mo":["\u2264","<"],"mi":"i","msub":{"mi":["L","x"]}}}},"mo":["\u2062","\u2062"],"msub":{"mi":["x","i"]}},{"mi":["C","Z"],"mo":"\u22c3"}],"mo":"\u2208"}}}},{"@attributes":{"id":"MATH-US-00007-2","num":"00007.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"Py","mrow":{"mo":["(",")"],"mrow":{"mi":["k","i"],"mo":","}}},"mo":"\u2192","mrow":{"mfrac":{"mn":"1","mrow":{"msub":{"mi":["\u03c3","DQy"]},"mo":"\u2062","msqrt":{"mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"\u03c0"}}}},"mo":"\u2062","mrow":{"mrow":[{"mi":"exp","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mo":"-","mfrac":{"msup":{"mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["YC","i"]},"mo":"-","mi":"DPQy"}},"mn":"2"},"mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msubsup":{"mi":["\u03c3","DQy"],"mn":"2"}}}}}},{"mo":"\u2200","mrow":{"mrow":{"mrow":{"mi":"j","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"0","mo":["\u2264","<"],"mi":"j","msub":{"mi":["L","x"]}}}},"mo":["\u2062","\u2062"],"msub":{"mi":["x","j"]}},"mo":"\u2208","mi":"D"}}],"mo":[".","\u2062"],"mstyle":{"mtext":{}}}}},{"msub":{"mi":"Py","mrow":{"mo":["(",")"],"mrow":{"mi":["k","j"],"mo":","}}},"mo":"\u2192","mn":"0"}],"mo":","}}}],"br":{},"sub":"DQy "},{"@attributes":{"id":"p-0101","num":"0100"},"maths":[{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":"\u2200","mrow":{"mrow":[{"mrow":{"mi":"i","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mn":"0","mo":["\u2264","<"],"mi":"i","msub":{"mi":["L","x"]}}}},"mo":["\u2062","\u2062"],"msub":{"mi":["x","i"]}},{"mi":["D","Z"],"mo":"\u22c3"}],"mo":"\u2208"}}}},{"@attributes":{"id":"MATH-US-00008-2","num":"00008.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"Py","mrow":{"mo":["(",")"],"mrow":{"mi":["k","i"],"mo":","}}},"mo":"\u2192","mrow":{"mfrac":{"mn":"1","mrow":{"msub":{"mi":["\u03c3","DQy"]},"mo":"\u2062","msqrt":{"mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mi":"\u03c0"}}}},"mo":"\u2062","mrow":{"mrow":[{"mi":"exp","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mo":"-","mfrac":{"msup":{"mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["YC","i"]},"mo":"-","mi":"DPQy"}},"mn":"2"},"mrow":{"mn":"2","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msubsup":{"mi":["\u03c3","DQy"],"mn":"2"}}}}}},{"mo":"\u2200","mrow":{"mrow":{"mi":"j","mo":["\u2062","\u2062"],"msub":{"mi":["x","j"]}},"mo":"\u2208","mi":"C"}}],"mo":[".","\u2062"],"mstyle":{"mtext":{}}}}},{"msub":{"mi":"Py","mrow":{"mo":["(",")"],"mrow":{"mi":["k","j"],"mo":","}}},"mo":"\u2192","mn":"0"}],"mo":","}}}],"br":{}},{"@attributes":{"id":"p-0102","num":"0101"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":"\u2200","mi":"i"},{"mo":["(",")"],"mrow":{"mn":"0","mo":["\u2264","<"],"mi":"i","msub":{"mi":["L","x"]}}},{"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["Py","i"]}},"mo":"\u2261","mn":"1."}],"mo":[",",","]}}}},"Still referring to part  of the method , if Mx is provided, MPx is prepared. First, a co-occurrence matrix CMx is prepared based on the EAD, Mx for all the previously generated values in S. This entails initializing the co-occurrence matrix CMx (dimension L\u00d7min(Lx, k)) with 0.5 in all of its cells, and for all i, 0<=m<min(Lx, k), if there exists a valid vector for the tuple <S, X> in Mx, setting CMx(i, m) to (Mx<S, X>(m)+1)\/2.0. Second, a VPatx vector is prepared using the co-occurrence matrix Mx. That is, for all I, 0<=I<L, VPatx=",{"@attributes":{"id":"p-0104","num":"0103"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"munderover":{"mo":"\u220f","mi":"m","mrow":{"mi":"min","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["L","MaxDepth"]},"mo":",","mi":"k"}}}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":{"mi":"CMx","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["i","m"],"mo":","}}},"mo":"."}}}},"br":{}},{"@attributes":{"id":"p-0105","num":"0104"},"maths":[{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":"\u2200","mi":"i"},{"mo":["(",")"],"mrow":{"mn":"0","mo":["\u2264","<"],"mi":"i","msub":{"mi":["L","x"]}}}],"mo":[",",","]}}},{"@attributes":{"id":"MATH-US-00011-2","num":"00011.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["MPx","i"]},"mo":"\u21a6","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mi":["VPatx","i"]},"mo":"\/","mrow":{"munderover":{"mo":"\u2211","mi":"k","msub":{"mi":["L","x"]}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["VPatx","k"]}}}},{"mrow":{"mrow":{"munderover":{"mo":"\u2211","mi":"k","msub":{"mi":["L","x"]}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["VPatx","k"]}},"mo":"\u2260","mn":"0."}}]},{"mtd":[{"mn":"0"},{"mrow":{"mrow":{"munderover":{"mo":"\u2211","mi":"k","msub":{"mi":["L","x"]}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["VPatx","k"]}},"mo":"\u2261","mn":"0"}}]}]}}}}}],"br":{},"sub":["x ","x","i ","i","y ","i ","i","(i,k)","i ","i","i","i ","i","(i,k)","k","k","k"]},"Next, the current position of the random sequence N, N, is generated for S(), as follows. If S\u2208 C, then new Y elements are added to \u03c8, as dictated by Fy(S), the actual population Ay is updated with the new value, and the Yage vector is augmented with additional values to cater to the new Y elements in \u03c8, such that the corresponding age value is initialized to zero. If S\u2209 the union of C and D, then Nis determined via RSelect(Y, Yage, U, fz(S)), where U is a uniform sequence of length Lwith each value equal to one, and fz(S) is the number of elements to be selected. If inSeq\u2208 D, then, if Ty is provided, Nis set as RSelect(Y, Yage, Ty, Fy(S)), and if Ty is not provided, Nis set as RSelect(Y, Yage, U, Fy(S)); furthermore, the Y elements listed in Nare removed from \u03c8, the corresponding entries in the Yage vector are removed, and the actual population Ay is updated with the new value. Finally, the entries in the Yage vector are incremented by one.","Finally, the current position of the random sequence V, V, is generated (), as follows. If Pw is provided, Pw is prepared by normalizing the k-th vector in the input matrix Pw, such that:",{"@attributes":{"id":"p-0108","num":"0107"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":"\u2200","mi":"i"},{"mo":["(",")"],"mrow":{"mn":"0","mo":["\u2264","<"],"mi":"i","msub":{"mi":["L","W"]}}},{"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":"Pw","mrow":{"mo":["(",")"],"mrow":{"mi":["i","k"],"mo":","}}}},"mo":"\u2261","mn":"1."}],"mo":[",",","]}}},"br":{},"sub":["w","MaxDepth","w","MaxDepth","k\u2212m","i","k\u2212m","i","w","i"]},{"@attributes":{"id":"p-0109","num":"0108"},"maths":{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"munderover":{"mo":"\u220f","mi":"m","mrow":{"mi":"min","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["Lw","MaxDepth"]},"mo":",","mi":"k"}}}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mrow":{"mi":"CMw","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["i","m"],"mo":","}}},"mo":"."}}}},"br":{}},{"@attributes":{"id":"p-0110","num":"0109"},"maths":{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":"\u2200","mi":"i"},{"mo":["(",")"],"mrow":{"mn":"0","mo":["\u2264","<"],"mi":"i","msub":{"mi":["L","w"]}}},{"mo":["\u220b","\u2062"],"mstyle":{"mtext":{}},"mrow":{"msub":{"mi":["MPw","i"]},"mo":"\u21a6","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mi":["VPatw","i"]},"mo":"\/","mrow":{"munderover":{"mo":"\u2211","mi":["k","Lw"]},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["VPatw","k"]}}}},{"mrow":{"mrow":{"munderover":{"mo":"\u2211","mi":"k","msub":{"mi":["L","w"]}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["VPatw","k"]}},"mo":"\u2260","mn":"0."}}]},{"mtd":[{"mn":"0"},{"mrow":{"mrow":{"munderover":{"mo":"\u2211","mi":"k","msub":{"mi":["L","w"]}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["VPatw","k"]}},"mo":"\u2261","mn":"0"}}]}]}}}}],"mo":[",",","]}}}},"Still in part , the arbitrary population vector VPw, having the dimension L, is determined by copying the resulting normalized vector. That is, for all I (0<=I<L), VPwis initialized to Rw; if Mw is provided then VPwis set as VPw\u00d7MPw; if Pw is provided then VPwis set as VPw\u00d7Pw. VPw is then normalized via:",{"@attributes":{"id":"p-0112","num":"0111"},"maths":{"@attributes":{"id":"MATH-US-00015","num":"00015"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mo":"\u2200","mi":"i"},{"mo":["(",")"],"mrow":{"mn":"0","mo":["\u2264","<"],"mi":"i","msub":{"mi":["L","w"]}}},{"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"msub":{"mi":["VPw","i"]}},"mo":"\u2261","mn":"1."}],"mo":[",",","]}}},"br":[{},{},{},{},{}],"b":["214","200"],"sub":["k ","k","k","k","k","k","k"],"in-line-formulae":[{},{},{},{},{},{}],"i":["i","\u2266i<fw","S","r","V","\u2192{V",":U","A","r","W,VPw"]},"The method  continues by outputting the random sequences that have been generated (). These sequences are the sequences S, N, and V. Finally, these outputs (i.e., the random sequence S, N, and V) can be used to test a software entity (), in one embodiment of the invention, as has been described.","In this final section of the detailed description,  shows the system  of  in a very general representation, according to an embodiment of the invention. In addition to the random sequence generator , the system  includes hardware  and a tester . The hardware  may include processors, memory, and other types of hardware commonly found in computing devices, as can be appreciated by those of ordinary skill within the art. As such, either the random sequence generator , the tester , or both the generator  and the tester  are implemented via the hardware .","The random sequence generator  is implemented as has been described, by performing the methods of embodiments of the invention that have described above. The tester , by comparison, can be used to test a sequence consumer, such as the sequence consumer  of , which is not depicted in . For instance, the sequence consumer may be a software entity exposing an application programming interface (API). As such, the tester  uses the outputs of the random sequence generator  as inputs to the API to test the software entity in question.","As can be appreciated by one those of ordinary skill within the art, aspects of the present invention may be embodied as a system, method or computer program product. Accordingly, aspects of the present invention may take the form of an entirely hardware embodiment, an entirely software embodiment (including firmware, resident software, micro-code, etc.) or an embodiment combining software and hardware aspects that may all generally be referred to herein as a \u201ccircuit,\u201d \u201cmodule\u201d or \u201csystem.\u201d Furthermore, aspects of the present invention may take the form of a computer program product embodied in one or more computer readable medium(s) having computer readable program code embodied thereon.","Any combination of one or more computer readable medium(s) may be utilized. The computer readable medium may be a computer readable signal medium or a computer readable storage medium. A computer readable storage medium may be, for example, but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, or device, or any suitable combination of the foregoing. More specific examples (a non-exhaustive list) of the computer readable storage medium include the following: an electrical connection having one or more wires, a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), an optical fiber, a portable compact disc read-only memory (CD-ROM), an optical storage device, a magnetic storage device, or any suitable combination of the foregoing. In the context of this document, a computer readable storage medium may be any tangible medium that can contain, or store a program for use by or in connection with an instruction execution system, apparatus, or device.","A computer readable signal medium may include a propagated data signal with computer readable program code embodied therein, for example, in baseband or as part of a carrier wave. Such a propagated signal may take any of a variety of forms, including, but not limited to, electro-magnetic, optical, or any suitable combination thereof. A computer readable signal medium may be any computer readable medium that is not a computer readable storage medium and that can communicate, propagate, or transport a program for use by or in connection with an instruction execution system, apparatus, or device. Program code embodied on a computer readable medium may be transmitted using any appropriate medium, including but not limited to wireless, wireline, optical fiber cable, RF, etc., or any suitable combination of the foregoing.","In general, a computer program product includes a computer-readable medium on which one or more computer programs are stored. Execution of the computer programs from the computer-readable medium by one or more processors of one or more hardware devices causes a method to be performed. For instance, the method that is to be performed may be one or more of the methods that have been described above.","The computer programs themselves include computer program code. Computer program code for carrying out operations for aspects of the present invention may be written in any combination of one or more programming languages, including an object oriented programming language such as Java, Smalltalk, C++ or the like and conventional procedural programming languages, such as the \u201cC\u201d programming language or similar programming languages. The program code may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).","Aspects of the present invention have been described above with reference to flowchart illustrations and\/or block diagrams of methods, apparatus (systems) and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and\/or block diagrams, and combinations of blocks in the flowchart illustrations and\/or block diagrams, can be implemented by computer program instructions. These computer program instructions may be provided to a processor of a general purpose computer, special purpose computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","These computer program instructions may also be stored in a computer readable medium that can direct a computer, other programmable data processing apparatus, or other devices to function in a particular manner, such that the instructions stored in the computer readable medium produce an article of manufacture including instructions which implement the function\/act specified in the flowchart and\/or block diagram block or blocks.","The computer program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other devices to cause a series of operational steps to be performed on the computer, other programmable apparatus or other devices to produce a computer implemented process such that the instructions which execute on the computer or other programmable apparatus provide processes for implementing the functions\/acts specified in the flowchart and\/or block diagram block or blocks.","The flowchart and block diagrams in the figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of code, which comprises one or more executable instructions for implementing the specified logical function(s). It should also be noted that, in some alternative implementations, the functions noted in the block may occur out of the order noted in the figures. For example, two blocks shown in succession may, in fact, be executed substantially concurrently, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and\/or flowchart illustration, and combinations of blocks in the block diagrams and\/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts, or combinations of special purpose hardware and computer instructions.","At least some embodiments of the present invention thus generate multivariate random sequences that have arbitrary stochastic patterns. The expected arbitrary stochastic patterns that are to be presented in the generated sequences may be taken as inputs. As such, a test engineer can describe a test model for API testing stochastically, using a multivariate simulation input model. The stochastic test model can describe the test conditions, such as the relative probability of occurrence of a test message in a test vector, a positional probability of every test message in the test vector, the probability of co-occurrences of two or more test messages, and the order of co-occurring test messages. The test vector is a sample of this test model. The random sequences generated are thus instances from the test model to be used to stochastically test the API of a software entity.","It is finally noted that, although specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that any arrangement calculated to achieve the same purpose may be substituted for the specific embodiments shown. This application is thus intended to cover any adaptations or variations of embodiments of the present invention. For example, while embodiments have been described in general terms, and an example has been provided in which the random sequences generated (with embedded spatio-temporal stochastic patterns) may be used to test a software entity having an application programming interface (API), other examples are also amenable to embodiments of the invention. For instance, embodiments of the invention are amenable to a food web model that is used by ecologists, as just one example among many others, such as any type of simulation system. As such and therefore, it is manifestly intended that this invention be limited only by the claims and equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The drawings referenced herein form a part of the specification. Features shown in the drawing are meant as illustrative of only some embodiments of the invention, and not of all embodiments of the invention, unless otherwise explicitly indicated, and implications to the contrary are otherwise not to be made.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
