---
title: System and method for decoding and executing program binaries
abstract: The present disclosure relates to a system and method for decoding program binaries. In one arrangement, the system and method pertain to intercepting program instructions, determining if associated instructions have been decoded and cached, and decoding and copying the program instructions if associated instructions have not been cached.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06920550&OS=06920550&RS=06920550
owner: Hewlett-Packard Development Company, L.P.
number: 06920550
owner_city: Houston
owner_country: US
publication_date: 20011115
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION"],"p":["This disclosure generally relates to dynamic transformation of executing binary program code. More particularly, the disclosure relates to a system and method for decoding and executing program binaries.","Recently, there has been increased interest in decreasing the amount of memory that is used in computing devices, such as personal digital assistants (PDAs) and embedded appliances, to reduce their cost. Unfortunately, the amount of memory that is needed typically increases with the functionality that is provided. Therefore, the greater functionality (e.g., number of applications) the user desires, the more memory that typically is needed.","In view of this situation, several solutions have been proposed to reduce the amount of memory that is needed for computing devices. In one such solution, a microprocessor having a high code density can be used. Although facilitating a reduction in the amount of memory needed, this solution may impact the level of performance achievable by the microprocessor and is therefore undesirable for many applications.","A more promising solution involves the use of code compression. In code compression, program code is compressed off line, i.e., during the code build time. Once compressed, the program code requires less memory and therefore facilitates the reduction of the amount of memory that must be provided in the computing device. The compressed code is stored in, for example, permanent memory (e.g., read only memory (ROM), a hard disk, a flash device) and, when the code is to be executed, it is decompressed.","Where the computing device has limited memory, it is preferable to only decompress blocks (e.g., pages) of code at a time. To do otherwise would defeat the purpose of compressing in the first place at least as far as memory preservation is concerned. Decompression can be accomplished with hardware or software that is configured for that purpose. Although hardware solutions work adequately well, they are somewhat inflexible in that the hardware must be modified or, more likely, replaced each time the underlying system is changed.","Software-based solutions are also viable, but problematic in that they typically require modification of the operating system (O\/S) and normally slow performance in that large portions of code usually must be decompressed, even where only a small amount of code (number of instructions) is needed. In addition to slowing performance, decompression of large portions of code further requires a relatively large amount of memory to be available for the decompressed code. Unfortunately, it is difficult to decompress smaller portions of code in that hardware support is typically needed to accomplish this. Even if such hardware were available, however, the overhead penalty and efficiency decrease that accompanies such a form of decompression would render such a solution unattractive.","From the foregoing, it can be appreciated that it would be desirable to have a system and method for decoding program code so as to, for example, provide code decompression that avoids one or more of the problems identified above.","The present disclosure relates to a system and method for decoding and executing program binaries. In one arrangement, the system and method pertain to intercepting program instructions, determining if associated instructions have been decoded and cached, and decoding and copying the program instructions if associated instructions have not been cached.","The present disclosure also relates to a decoding program stored on a computer-readable medium. In one arrangement, the decoding program comprises logic configured to intercept program instructions, logic configured to determine if associated instructions have been decoded and cached, and logic configured to decode and copy the program instructions that have not been cached.","In addition, the present disclosure relates to a dynamic execution layer interface (DELI) residing between at least one application and computing system hardware. In one arrangement, the DELI comprises a core configured to cache and execute certain application code fragments, an application programming interface configured to provide access to caching and executing functions of the core, and a system control and configuration layer configured to provide policies for operation of the core.","Disclosed is a system and method for decoding and executing program binaries. As is explained below, the nature of the decoding services provided can vary depending upon the particular application. By way of example, this decoding can comprise decompressing and\/or decrypting program code. To facilitate description of the inventive system and method, example systems are discussed with reference to the figures. Although these systems are described in detail, it will be appreciated that they are provided for purposes of illustration only and that various modifications are feasible without departing from the inventive concept. Other example systems are described in U.S. patent application Ser. No. 09\/924,260, filed Aug. 8, 2001, entitled \u201cDynamic Execution Layer Interface for Explicitly of Transparently Executing Application or System Binaries\u201d (attorney docket no. 10011525-1), which is hereby incorporated by reference into the present disclosure. After the description of the example systems, examples of operation of the systems are provided to explain the manners in which decoding and executing of program binaries can be facilitated.","Referring now to , illustrated is an example dynamic execution layer interface (DELI) . Generally speaking, the DELI  comprises a generic software layer written in a high or low level language that resides between applications, including or not including an operating system (O\/S), and hardware to untie application binary code from the hardware. Through this arrangement, the DELI  can provide dynamic computer program code transformation, caching, and linking services which can be used in a wide variety of different applications such as emulation, dynamic translation and optimization, transparent remote code execution, remapping of computer system functionality for virtualized hardware environments program, code decompression, code decrypting, etc. As is discussed in greater detail below, the DELI  can provide its services while operating in a transparent mode, a nontransparent mode, or combinations of the two. In the transparent mode, the DELI  automatically takes control of an executing program in a manner in which the executing program is unaware that it is not executing directly on computer hardware. In the nontransparent mode, the DELI  exports its services through an application programming interface (API) to the application to allow the application to control how the DELI  reacts to certain system events.","As depicted in , the DELI  resides between at least one application  and computer hardware . Depending upon the particular arrangement, the application  can comprise one or more user applications that are unaware of the DELI's presence and\/or a client (e.g., emulator) that is aware of the DELI  and which is configured to utilize the DELI's services. More generally, however, the application  comprises any type of program code containing instructions to be executed by a computer processor. Where an O\/S is used, the DELI  may reside either above or below the O\/S (not indicated) depending upon the nature of the services that are provided. For example, when the DELI  operates above the O\/S, it can only control execution of applications. If the DELI  operates below the O\/S, however, the DELI has access to an instruction stream which can include a mix of system and user code both from the O\/S and applications. The hardware  can comprise various different computer system components but typically at least comprises a computer processor.","The DELI  can include four main components including a core , an application programming interface (API) , a transparent mode layer , and a system control and configuration layer . Generally speaking, the core  exports two main services to both the API  and the transparent mode layer . The first of these services pertains to the caching and linking of native code fragments or code fragments which correspond to the instruction set of the hardware . The second pertains to executing previously cached code fragments. The API  exports functions from the application  that provide access to the caching and linking services of the core  in the nontransparent mode of operation. The transparent mode layer  enables the core  to gain control transparently over code execution in the transparent mode of operation as well as fetch code fragments to be cached. Finally, the system control and configuration layer  enables configuration of the DELI  by providing policies for operation of the core  including, for example, policies for the caching, linking, and optimizing of code. These policies can, for example, be provided to the layer  from the application  via the API . The system control and configuration layer  also controls whether the transparent mode of the DELI  is enabled, thus determining whether the core  receives input from the API , the transparent mode layer , or both.","As is further indicated in , the system  can include a bypass path  that can be used by the application  to bypass the DELI  so that the application can execute directly on the hardware , where desired. It is noted that such operation can be possible in that the DELI  is an optional execution layer which may or may not be utilized.","As is shown in , the core  comprises a core controller , a cache manager , a fragment manager , and an optimization manager . The core controller  functions as a dispatcher that assigns tasks to the other components of the core  that are responsible for completing the tasks. The cache manager  comprises a mechanism (e.g., set of algorithms) that controls the caching of the code fragments within one or more code caches  (e.g., caches 1 through n) according to the policies specified by the system control and configuration layer  as well as the fragment manager  and the optimization manager . The one or more code caches  of the core  can, for instance, be located in hardware caches on one or more processors of the hardware , or can be created in the main local memory of the hardware. Where the code cache(s)  is\/are mapped in hardware caches onboard the processor(s), greatly increased performance can be obtained due to reduced instruction cache refill overhead, increased memory bandwidth, etc. The fragment manager  specifies the arrangement of the code fragments within the code cache(s)  and the type of transformation that is imposed upon the fragments. Finally the optimization manager  contains the set of optimizations that can be applied to the code fragments to optimize their execution.","As noted above, the API  exports functions from the application  that provide access to DELI services. More specifically, the API  exports caching and linking services of the core  to the application , which typically comprises a client that is aware of the DELI's presence. These services exported by the API  enable the application  to control the operation of the DELI  in the nontransparent mode by (i) explicitly emitting code fragments to the core  for caching and\/or by (ii) instructing the DELI  to execute specific code fragments out of its code cache(s) . In addition, the API  also can export functions that initialize and discontinue operation of the DELI . For instance, the API  can initiate transparent operation of the DELI  and further indicate when the DELI is to cease such operation. The API  also, as mentioned above, facilitates configuration of the DELI  by delivering policies specified by the application  to the core  (e.g., to the fragment manager  and\/or the optimization manager ). Use of the API  in facilitating operation in a nontransparent mode is described below in relation to FIG. .","With further reference to , the transparent mode layer  typically includes an injector  which is used to gain control over a running application  transparently. When the DELI  operates in a completely transparent mode (i.e., where the application is unaware of the DELI's presence) the injector  is used to inject the DELI into the application  before the application begins execution so that the application can be run under DELI control. In such circumstances, the DELI  avoids modifying the application's  executable image to avoid impeding exception handling. Control can be gained by the injector  in several different ways, each of which loads the application binaries without changing the virtual address at which the binaries are loaded. By way of example, the O\/S kernel loader can be modified such that the DELI  (e.g., compiled as a shared library) is automatically loaded by the kernel loader when it loads the application's executable image. Alternatively, a user level loader can be used to leverage the kernel loader without modifying it to load the application  in memory in suspended mode and later inject instructions into the application (e.g., on the application stack) that will load the DELI  shared library later when the application is resumed.","In another alternative, ptrace can be used to attach the DELI  to the application . As is known in the art, ptrace is a mechanism often used by debuggers that allows one process to control another. The DELI  can be configured as a separate process that attaches to the application  via ptrace, and runs the application until the point where the execution start-up code at the top of the application's binary image (e.g., crt0) is about to call the application's entry point. Execution of the application  can then be suspended, and the DELI  can be used to fetch the application instructions and execute them on its behalf.","In yet another alternative, the application's text segment can be expanded in a separate copy of the executable file. In particular, the application's binary image can be copied to a temporary location, the application's text segment extended by adding a DELI text segment at the end, and the start symbol (i.e., the entry point that is called by crt0) changed to the DELI entry point. The resulting executable file can then be executed using exec. The original application's text segment is still loaded at the same virtual address that it would normally have, but the DELI  will gain control before the actual application  starts.","In another example, the DELI  can gain control over the application  using a special version of crt0. As is known in the art, the crt0 code is responsible for picking-up the command line arguments, setting up the initial stack and data segment, and then making a call to the value of the start symbol (usually the main() function of the application ). Prior to calling the application  entry point, crt0 maps the dynamic link loader did, which then loads any dynamically linked libraries (DLLs) referenced by the application . A custom version of crt0 can be used to additionally map the DELI code (itself compiled as a DLL), and call the DELI's entry point instead of the one defined by the start symbol.","Irrespective of the manner in which control is obtained over the application , an instruction fetch controller  can then be used to extract (i.e., fetch) copies of fragments (e.g., traces) of the application binary code, pass them to the DELI core  for caching, and direct the core  to execute the appropriate cached copies out of its code cache(s) . Use of the transparent mode layer  in facilitating such operation is described below in relation to FIG. .","It is to be noted that, although the DELI  has been shown and described herein as including the transparent mode layer , persons having ordinary skill in the art will appreciate from this disclosure taken as a whole that this layer may be omitted altogether where operation of the DELI is solely controlled by the application  (i.e., client) via the API .","As noted above, the system control and configuration layer  enables configuration of the DELI  by providing policies for the caching and linking of code. Although the DELI  is not limited to any particular type of policy or policy content, the policies typically determine how the DELI will behave. For instance, the layer  may provide policies as to how fragments of code are extracted from the application , how fragments are created from the original code, how multiple code fragments can be linked together to form larger code fragments, etc. The layer's policies can be static or dynamic. In the former case, the policies can be hardcoded into the DELI , fixing the configuration at build time. In the latter case, the policies can be dynamically provided by the application  through function calls in the API . Implementation of the policies controls the manner in which the DELI  reacts to specific system and\/or hardware events (e.g., exceptions and interrupts). In addition to the policies noted above, the system control and configuration layer  can specify the size of the code cache(s) , whether a log file is created, whether code fragments should be optimized, etc.","The system control and configuration layer  further supports the abstraction of system and hardware functionality by intercepting instructions in the application binary code directed at system and hardware functionality. These instructions are then replaced by the fragment manager  under the direction of the system control and configuration layer  as part of the fragment formation process. The system control and configuration layer  identifies instructions directed at missing or defective hardware and causes the fragment manager  to replace them with corresponding instructions directed at similar, but different, hardware  or with software simulations of the original hardware.","In addition to the above-identified components, the DELI  can, optionally, further include a decoding manager  that, for instance, comprises one or more algorithms responsible for decoding program binaries in some manner. For example, the decoding manager  can provide decompression and\/or decryption services to the application . Use of the decoding manager , where provided, is described below with reference to FIG. .",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2","b":["106","106","108","110","200","124","106","124","104"]},"The core controller  processes these requests and dispatches them to the appropriate core module. A request  to emit a code fragment with a given identifier can then be passed to the fragment manager . The fragment manager  transforms the code fragment according to its fragment formation policy , possibly instruments the code fragment according to its instrumentation policy , and links the code fragment together with previously cached fragments according to its fragment linking policy . For example, the fragment manager  may link multiple code fragments in the cache(s) , so that execution jumps to another code fragment at the end of executing a code fragment, thereby increasing the length of execution from the cache(s). To accomplish this, the fragment manager  issues fragment allocation instructions  to the cache manager . The fragment manager  then sends a request to the cache manager  to allocate the processed code fragment in the code cache(s) .","The cache manager  controls the allocation of the code fragments and typically is equipped with its own cache policies  for managing the cache space. However, the fragment manager  may also issue specific fragment deallocation instructions  to the cache manager . For example, the fragment manager  may decide to integrate the current fragment with a previously allocated fragment, in which case the previous fragment may need to be deallocated. In some arrangements, the cache manager  and fragment manager  can manage the code cache(s)  and code fragments in the manner shown and described in U.S. Pat. No. 6,237,065, issued May 108, 2001, entitled \u201cA Preemptive Replacement Strategy for a Caching Dynamic Translator Based on Changes in the Translation Rate,\u201d which is hereby incorporated by reference into the present disclosure. Alternatively, management of the code cache(s)  and code fragments may be performed in the manner shown and described in U.S. patent application Ser. No. 09\/755,389, filed Jan. 5, 2001, entitled \u201cA Partitioned Code Cache Organization to Exploit Program Locality,\u201d which is also hereby incorporated by reference into the present disclosure.","Prior to passing a fragment to the cache manager , the fragment manager  may pass () the fragment to the optimization manager  to improve the quality of the code fragment according to its optimization policies . In some arrangements, the optimization manager  may optimize code fragments in the manner shown and described in U.S. patent application Ser. No. 09\/755,381, filed Jan. 5, 2001, entitled \u201cA Fast Runtime Scheme for Removing Dead Code Across Linked Fragments,\u201d which is hereby incorporated by reference into the present disclosure. Alternatively, the optimization manager  may optimize code fragments in the manner shown and described in U.S. patent application Ser. No. 09\/755,774, filed Jan. 5, 2001, entitled \u201cA Memory Disambiguation Scheme for Partially Redundant Load Removal,\u201d which is also hereby incorporated by reference into the present disclosure. Notably, the optimization manager  may also optimize code fragments using classical compiler optimization techniques, such as elimination of redundant computations, elimination of redundant memory accesses, inlining functions to remove procedure call\/return overhead, etc.","As mentioned above, the fragment manager  transforms the code fragment according to its fragment formation policy . The transformations performed by the fragment manager  can include code relocation by, for instance, changing memory address references by modifying relative addresses, branch addresses, etc. The layout of code fragments may also be modified, changing the physical layout of the code without changing its functionality (i.e., semantic). These transformations are performed by the fragment manager  on fragments received through the API  and from the instruction fetch controller .","To perform code instrumentation, the fragment manager  gathers data according to the instrumentation policy  for code profiling, such as data on the frequency of execution of code fragments, the frequency with which a memory address is accessed, etc. Program counters can be used to collect these statistics in order to facilitate fragment formation or deallocation. These policies are configured by the system control and configuration layer , which receives policy instructions sent either through the API  or established at DELI build time. The policies may comprise options for different ways to create, instrument, optimize, and link fragments, or the policies may simply be hardcoded algorithms in the DELI  for performing these tasks.","The second type of request accepted by the DELI core  is a request  to execute a fragment identified by a given identifier (e.g., tag). In such a case, the core controller  issues a lookup request  to the fragment manager , which returns a corresponding code cache address  if the fragment is currently resident and active in the cache(s) . By way of example, the fragment manager  can maintain a lookup table of resident and active code fragments in which a tag can be used to identify the location of a code fragment. Alternatively, the fragment manager  or cache manager  can use any other suitable technique for tracking whether code fragments are resident and active. If the fragment is not currently resident and active in the cache(s) , the fragment manager  returns an error code to the core controller , which returns () the fragment tag back to the initial requester as a cache miss address. If, on the other hand, the fragment is currently resident and active, the core controller  then patches () the initial request to the cache manager  along with its cache address. The cache manager , in turn, transfers control to the addressed code fragment in its code cache(s) , thus executing the addressed code fragment. Execution then remains focused in the code cache(s)  until a cache miss occurs, i.e., until a copy for the next application address to be executed is not currently resident in the cache(s). This condition can be detected, for instance, by an attempt of the code being executed to escape from the code chache(s) . A cache miss is reported () from the cache manager  to the core controller  and, in turn, back () to the initial requester.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 3","b":["300","100","300","300","302","304","306","308","310","312","314"]},"The processing device  can include any custom made or commercially available processor, a central processing unit (CPU) or an auxiliary processor among several processors associated with the computer system , a semiconductor based microprocessor (in the form of a microchip), a macroprocessor, one or more application-specific integrated circuits (ASICs), a plurality of suitably configured digital logic gates, and other well known electrical configurations comprising discrete elements both individually and in various combinations to coordinate the overall operation of the computing system.","The memory  can include any one of a combination of volatile memory elements (e.g., random access memory (RAM, such as DRAM, SRAM, etc.)) and nonvolatile memory elements (e.g., ROM, hard drive, tape, CDROM, etc.). The memory  typically comprises an O\/S , one or more applications  (e.g., user application and\/or client), and the DELI , which has already been described in detail. Persons having ordinary skill in the art will appreciate that the memory  can, and typically will, comprise other components which have been omitted for purposes of brevity.","The one or more user interface devices  comprise those components with which the user can interact with the computing system . For example, where the computing system  comprises a personal computer (PC), these components can comprise a keyboard and mouse. Where the computing system  comprises a handheld device (e.g., PDA, mobile telephone), these components can comprise function keys or buttons, a touch-sensitive screen, a stylus, etc. The display  can comprise a computer monitor or plasma screen for a PC or a liquid crystal display (LCD) for a handheld device.","With further reference to , the one or more I\/O devices  are adapted to facilitate connection of the computing system  to another system and\/or device and may therefore include one or more serial, parallel, small computer system interface (SCSI), universal serial bus (USB), IEEE 1394 (e.g., Firewire\u2122), and\/or personal area network (PAN) components. The network interface devices  comprise the various components used to transmit and\/or receive data over a network. By way of example, the network interface devices  include a device that can communicate both inputs and outputs, for instance, a modulator\/demodulator (e.g., modem), wireless (e.g., radio frequency (RF)) transceiver, a telephonic interface, a bridge, a router, network card, etc.","Various software and\/or firmware has been described herein. It is to be understood that this software and\/or firmware can be stored on any computer-readable medium for use by or in connection with any computer-related system or method. In the context of this document, a computer-readable medium denotes an electronic, magnetic, optical, or other physical device or means that can contain or store a computer program for use by or in connection with a computer-related system or method. These programs can be embodied in any computer-readable medium for use by or in connection with an instruction execution system, apparatus, or device, such as a computer-based system, processor-containing system, or other system that can fetch the instructions from the instruction execution system, apparatus, or device and execute the instructions. In the context of this document, a \u201ccomputer-readable medium\u201d can be any means that can store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device.","The computer-readable medium can be, for example but not limited to, an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system, apparatus, device, or propagation medium. More specific examples (a nonexhaustive list) of the computer-readable medium include an electrical connection having one or more wires, a portable computer diskette, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM, EEPROM, or Flash memory), an optical fiber, and a portable compact disc read-only memory (CDROM). Note that the computer-readable medium can even be paper or another suitable medium upon which a program is printed, as the program can be electronically captured, via for instance optical scanning of the paper or other medium, then compiled, interpreted or otherwise processed in a suitable manner if necessary, and then stored in a computer memory.","The general nature of the DELI  having been described above, examples of operation of the DELI will now be discussed with reference to . As identified above, the DELI  operates in two general operating modes, i.e., a transparent mode and a nontransparent mode, as well as combinations thereof. In describing operation in these modes, flow diagrams are provided. It is to be understood that any process steps or blocks in these flow diagrams represent modules, segments, or portions of code that include one or more executable instructions for implementing specific logical functions or steps in the process. It will be appreciated that, although particular example process steps are described, alternative implementations are feasible. Moreover, steps may be executed out of order from that shown or discussed, including substantially concurrently or in reverse order, depending on the functionality involved.","Generally speaking, irrespective of whether the DELI  has gained control over the execution of the application  transparently or nontransparently, the application does not execute directly on the hardware . Rather, application code executes through the DELI  in the form of code fragment that may be maintained in the code cache(s) .",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 4","FIG. 4"],"b":["102","400","100","102","100","102","126","110","402"]},"Once the DELI  has control over the application , the DELI can be used to provide any one of several different services such as those noted above. For instance, the DELI  can facilitate hardware and\/or software emulation, dynamic translation and optimization, transparent remote code execution, remapping of computer system functionality for virtualized hardware environments program, code decompression, code decryption, etc. These different services each involve the caching and the linking of program code fragments within the code cache(s) . By caching certain fragments of code copied from the application binaries and transforming them in some manner, the desired services can be provided by later executing the transformed code from the code cache(s) .","Before caching code, the DELI  must determine which particular fragments of code to cache. In that, when operating in the completely transparent mode, the application  is unaware of the DELI , the DELI does not receive guidance from the application as to which code fragments to cache. Although the caching of code can be dictated through the policies created at the DELI build time, more preferably, the DELI  has the capability to, at least in part, make these determinations on its own. The DELI  can do this by monitoring the execution of code by the application , as indicated in block . In so doing, the DELI  can collect information as to, for instance, which code fragments are most useful to the application  by, for example, determining which fragments are most frequently used.","As the various code fragments are executed by the application  under the control of the DELI , the DELI \u201csees\u201d each piece of code that is executed. Through the monitoring process, the DELI  can, therefore, determine which code fragments are used most frequently. The DELI  can then make the determination of which pieces of code are \u201chot,\u201d i.e., most important to application execution with reference to the policies that are provided by the system control and configuration layer . As noted above, this determination can be made using program counters that track execution instances. Persons having ordinary skill in the art will appreciate that various other methods can be used to make the determination of which pieces of code are hot. Examples of the manner in which this determination can be made are described in U.S. patent application Ser. No. 09\/186,945, filed Nov. 5, 1998, entitled \u201cMethod for Selecting Active Code Traces for Translation in a Caching Dynamic Translator,\u201d and U.S. patent application Ser. No. 09\/312,296, filed May 14, 1999, entitled \u201cLow Overhead Speculative Selection of Hot Traces in a Caching Dynamic Translator,\u201d both of which are hereby incorporated by reference into the present disclosure.","With further reference to , as each code fragment is executed, the DELI  can determine whether an associated code fragment has previously been cached, as indicated in decision element . If so, the DELI  jumps to the code cache(s)  that contains the cached (and typically transformed) code and this code is executed by the hardware  in lieu of the original application code, as indicated in block . The determination of whether the code has been cached can be made with reference to, as noted above, identifiers (e.g., tags) that identify the association between native application code and analogues that have been cached within the code cache(s) . Execution of the cached code then continues, including the execution of linked fragments of code that reside in the code cache(s) , until such time when a reference to code that has not been cached (i.e., a cache miss) is encountered. With reference to decision element , if a reference to uncached code is encountered, the DELI  jumps back to the application code and the execution of that code is resumed, as indicated in block . At this time, the DELI  can resume monitoring of this execution (block ).","Returning to decision element , if the DELI  determines that an associated code fragment does not reside in the code cache(s) , flow continues to decision element  at which it is determined whether the code fragment is hot with reference to a predetermined policy. If the code is not hot, flow returns to block  at which monitoring of the application code execution continues. If, on the other hand, the code is hot, the code fragment is copied, as indicated in block , by fetching the fragment using the instruction fetch controller  of the transparent mode layer .","At this point, the code fragment can be transformed in some manner, as indicated in block . In addition, code fragments within the cache(s)  can be linked according to the policies that have been established for code linking. The nature of the code transformation depends upon the type of services that the DELI  is to provide. For example, where the DELI  is to merely optimize the application execution, this transformation can comprise rearranging and\/or reconfiguring the code for better performance. Irrespective of the nature of the transformation provided, the code structure is modified in a way without modifying the underlying semantic. Once the code fragment has been transformed, the transformed code can be cached within the code cache(s) , as indicated in block , and executed within the DELI  with flow continuing to block  described above.","As noted above, the DELI  operates differently in the nontransparent mode. Generally speaking, when operating in the nontransparent mode, the DELI  may operate, for example, as a DLL or a statically linked module which exports functions in the API  that the application  can access. In the nontransparent mode, the application  (i.e., a client) is aware of the DELI  and is configured to utilize the DELI's services. In the simplest case, the client (e.g., emulator) controls every aspect of DELI operation through the API . In such a case, the DELI  can be utilized to cache, link, and optimize code according to explicit instructions provided by the client via the API . For instance, the DELI  can be instructed to cache certain code fragments believed to be most frequently used during application execution. This can be accomplished by, for instance, providing the location of the code to the DELI  by identifying a tag. In such a case, the DELI  does not monitor but instead records code fragments as commanded by the API . In addition, the client can instruct the DELI  as to which cached fragments to execute via the API  by identifying the applicable tags to the DELI.","In a more typical scenario, however, the client calls upon the DELI  to provide its services in a transparent manner. In such a case, the client invokes operation of the DELI , as well as provides instructions as to when the DELI is to halt its operation.  provides an example of operation in this manner.","Beginning with block , DELI  is initiated. In the nontransparent mode, this initiation occurs when a start command such as \u201cDELI_START\u201d is delivered by the API  that invokes the DELI . Once initiated, the transparent mode layer  can be activated, as indicated in block , and flow can continue in similar manner to the transparent mode described above in relation to FIG. . Accordingly, the DELI  can monitor the execution of code by the application (client) (), determine whether a code fragment has been previously cached (), execute cached code where applicable (), copy hot code fragments (), transform the copied code fragments (), and cache transformed code fragments (). Operation of the DELI  continues in this manner until the DELI encounters a condition which, as required by the client, causes the DELI to halt operation. By way of example, this interruption can be effected with a \u201cDELI_STOP\u201d command placed at the end of a function call sent to the DELI  via the API .","As noted above, the DELI  can be used to facilitate decoding of program binaries. For example, the DELI  can be used to decompress and execute compressed program code. As described above, there are several problems with current decompression\/execution solutions including, for example, decreased system performance and the need for relatively large amounts of memory. These problems can be avoided, however, when the DELI  is used in that the DELI controls very small portions of code such as code fragments and even individual instructions. In operation, the DELI  can be used to decompress code fragments as well as cache the most frequently used code fragments in decompressed form within the code cache(s) . With such operation, smaller portions of the application code are decompressed, thereby reducing decompression overhead and requiring less of the available system memory. Moreover, in that the most frequently used code fragments are cached in decompressed form, much less dynamic decompression is needed, thereby improving performance.","One example of operation of the DELI  in providing decoding and executing of application binaries is shown in FIG. . In this example, the decoding services are provided in the transparent mode of operation. Although the decoding is described in terms of decompression, persons having ordinary skill in the art will appreciate that other forms of decoding can be provided such as program code decryption. Beginning with block , the DELI  is initiated and, as indicated in block , injected into the application  before it starts so as to gain control over its execution. With this control, the DELI  can intercept the various compressed application instructions that are ultimately to be executed, as indicated in block .","As in the mode of operation described in relation to , the DELI  monitors the execution of code so it can be determined which code fragments to cache. Accordingly, as described above, the DELI  can determine whether an associated code fragment has previously been decompressed and cached, as indicated in decision element . If so, the DELI  jumps to the code cache(s)  that contains the decompressed code and this code is executed by the hardware  in lieu of the original application code, as indicated in block . Again, execution of the cached code continues until a reference to code that has not been cached is encountered () at which time the DELI  jumps back to the application code and block .","With reference back to decision element , if no associated code fragment resides in the code cache(s) , flow continues to block  at which the instructions are decompressed (i.e., decoded) by the DELI  so that the instructions can be evaluated. By way of example, this decompression can be provided by the decoding manager . Although this decompression (i.e., decoding) is described as being performed by the decoding manager  of the DELI , persons having ordinary skill in the art will recognize that this function could, alternatively, be performed by another component such as a software component of a client application or a hardware component of the underlying computing system. Once the instructions are decompressed, the DELI  creates a copy of the instructions, as indicated in block , for example to one or more instruction buffers. Next, with reference to decision element , the DELI  determines whether the application instructions are hot with reference to a predetermined policy. If the instructions are not hot, flow continues to block  at which the copied, decompressed instructions are executed. If, however, the instructions are hot, the decompressed instructions are transformed as desired () and cached () in decompressed form so as to be available for execution the next time that particular functionality is required.","Such decompression and execution services can also be provided by the DELI  while operating in the nontransparent mode. For example, the application  (i.e., client) or another component (not shown) can be configured to decompress the application code and invoke the DELI  to cache the decompressed code that is most frequently used. In such a scenario, flow is similar to that shown in  except that the code executed by the application  is previously compressed code.","Whether the decoding services are provided by the DELI  in the transparent or nontransparent mode, several advantages over prior solutions may be achieved both in terms of system performance and memory utilization. For example, where decompression\/execution services are provided, an approximately 10% decompression penalty may be observed as compared with as much as a 50% penalty encountered with software solutions in which large portions of code must be decompressed. In terms of memory, in that most of the application code remains in compressed form, much less memory is needed during execution as compared to current software solutions.","While particular embodiments of the invention have been disclosed in detail in the foregoing description and drawings for purposes of example, it will be understood by those skilled in the art that variations and modifications thereof can be made without departing from the scope of the invention as set forth in the following claims. For instance, although the DELI has been described above as only providing decoding and executing services, it is to be noted that various other services can simultaneously be provided by the DELI. For instance, the decoding and executing services provided by the DELI can be utilized when performing other tasks including, for instance, hardware or software emulation that is facilitated by the client. The present disclosure is intended to include such applications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention can be better understood with reference to the following drawings.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2","b":"1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 5","FIG. 1"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 6","FIG. 1"]}]},"DETDESC":[{},{}]}
