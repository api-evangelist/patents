---
title: Compressed program recording
abstract: Program execution can be monitored and recorded for later playback. Certain state changes that can be predicted via a virtual processor during playback need not be recorded, so a compressed recording can be stored. To facilitate random access with respect to time during playback, key frames can be stored within the compressed recording. An index mechanism can associate key frames with particular memory addresses. Additionally, a snapshot of values for memory addresses can be used to further facilitate determining the value of a memory address without having to simulate execution. Multiprocessor executions can be supported, and playback can be done on a machine type different from that on which recording took place.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07620938&OS=07620938&RS=07620938
owner: Microsoft Corporation
number: 07620938
owner_city: Redmond
owner_country: US
publication_date: 20051031
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","EXAMPLE 1","Exemplary System Employing a Combination of the Technologies","EXAMPLE 2","Exemplary State Information","EXAMPLE 3","Exemplary Method Employing a Combination of the Technologies","EXAMPLE 4","Exemplary Program Recordings","EXAMPLE 5","Exemplary System Generating Information about Machine State Via Compressed Program Recording","EXAMPLE 6","Exemplary Method of Generating Information about Machine State via Playback","EXAMPLE 7","Exemplary Compression Techniques","EXAMPLE 8","Exemplary Compression via Predictability","EXAMPLE 9","Exemplary System for Determining Memory State","EXAMPLE 10","Exemplary Method of Using a Predictor and Compressed Memory State Changes to Determine Memory State","EXAMPLE 11","Exemplary Recording System Employing a Cache to Determine Predictability of Memory Read Operations","EXAMPLE 12","Exemplary Cache Layout","EXAMPLE 13","Exemplary Technique for Managing Cache to Reflect Predictability","EXAMPLE 14","Exemplary Playback System Employing a Cache to Take Advantage of Predictability of Memory Read Operations","EXAMPLE 15","Exemplary Technique for Managing Cache to Take Advantage of Predictability","EXAMPLE 16","Exemplary Method of Determining a Value for a Memory Address at a Particular Time","EXAMPLE 17","Exemplary Request for Value Deep within Playback Data","EXAMPLE 18","Exemplary Key Frames within a Compressed Program Recording","EXAMPLE 19","Exemplary Method of Generating Key Frames","EXAMPLE 20","Exemplary Key Frame","EXAMPLE 21","Exemplary Method of Employing a Key Frame","EXAMPLE 22","Exemplary Request for Memory Value Deep within a Program Recording with Key Frames","EXAMPLE 23","Exemplary Summarization Index","EXAMPLE 24","Exemplary Method for Generating Summarization Index and Method for Processing Requests","EXAMPLE 25","Exemplary Scenario Involving Change to Memory Address Remote from Time of Request","EXAMPLE 26","Exemplary Snapshots","EXAMPLE 27","Exemplary Method of Processing a Request for Memory Address Value","EXAMPLE 28","Exemplary Compressed Program Recording Supporting Multiple Processors","EXAMPLE 29","Exemplary Method for Generating Compressed Program Recording Supporting Multiple Processors","EXAMPLE 30","Exemplary Compressed Program Recording Supporting Multiple Processors with Sequence Indications","EXAMPLE 31","Execution by Simulator","EXAMPLE 32","Function Calls","EXAMPLE 33","Circular Buffer","EXAMPLE 34","Exemplary Additional Compression","EXAMPLE 35","Different Machine Type","EXAMPLE 36","Exemplary User Interface","EXAMPLE 37","Exemplary File Format","EXAMPLE 38","Exemplary Memory","EXAMPLE 39","Exemplary Computing Environment","Methods in Computer-Executable Media","Alternatives"],"p":["Debugging computer software can be a particularly challenging endeavor. Software defects (\u201cbugs\u201d) are notoriously difficult to locate and analyze. One common way to locate bugs is to generate a trace of program execution. In such an approach, processor state and the values of memory locations are recorded after each single step of a program. A programmer can then consult the trace of the program's execution to see if the program is executing as expected.","However, such a conventional approach breaks down if the program is particularly complex or if the program runs for any significant length of time. The pure volume of data generated by such a trace can quickly overwhelm the bandwidth and storage capacity of even advanced computer systems.","During execution, a software program can be monitored to generate a recording of the program's execution. Compression techniques can be used to reduce the size of the recording of the program's execution. For example, if a value for a memory address can be predicted via a virtual processor during playback, the value need not be stored in the recording.","Various other features can be incorporated if desired. For example, key frames can enable playback from an intermediate position (e.g., in random access fashion) within the recording. A summarization index can facilitate efficient location of relevant key frames, and memory snapshots can be used to determine a value for a memory address without playing back the part of the recording that accesses the memory address. Multi processor support can include use of sequence numbers for synchronization.","The foregoing and other features and advantages will become more apparent from the following detailed description of disclosed embodiments, which proceeds with reference to the accompanying drawings.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 1","b":["100","100"]},"In the example, a program recording tool  processes state information  within a software program under test during monitored execution of the program. Such execution can be simulated execution of the program (e.g., by a software simulation engine that accepts an executable version of the program). The program recording tool  can generate a recording  of the execution of the program, which as explained in the examples herein can be compressed. As explained herein, the recording  can include instructions (e.g., code) for the software program under test as well as a series of values that can be consulted to determine values for memory address read operations during playback.","Execution monitoring can monitor state information including read and write operations. For example, the address and size of reads or writes can be monitored.","In practice, the program recording can then be played back to determine the state of the program at various points in time during the monitored execution.","In any of the examples herein, state information can include state changes or other information about the processor state, changes to or values of memory addresses, or any other changes in the state of the machine (e.g., virtual machine) caused during execution of the program (e.g., by the program itself or services invoked by the program).","For example, a register within a processor can change and values for memory locations can change, information about the value of registers or memory locations can be monitored, or both.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 2","FIG. 1","FIG. 1"],"b":["200","210","110","230"]},"At , a compressed version of the program's recorded execution is stored.","A recording of a program's execution (or a \u201cprogram recording\u201d) can include information about state during recorded monitored execution of the program. In practice, the recording can also include executable instructions of the program, which can be used during playback to simulate execution. In some cases, playback of such instructions can be used to determine state changes without having to explicitly store the state (e.g., without having to store a changed value of a register or memory address when the value changes).","For example, if an instruction merely makes a change internal to the processor, the change can be determined by simulating execution of the instruction, without having to store the resulting value. In practice, such instructions include those that increment registers, add constants, and the like. Compression can be achieved by not including state information in the program recording for such instructions.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 3","FIG. 1"],"b":["300","350","310","330","310","150","350"]},"The information  can include the value of a memory address at a particular point in time during the recorded execution of the program (e.g., what is the value of memory location x after execution of the nth instruction\u2014or after n processor cycles).","In practice, the playback tool  can be used as a debugger tool that a software developer can employ to determine the values of memory addresses and registers during execution of the program.","As described herein, certain information about machine state can be predicted via the playback tool ; therefore, the number of values stored in the recording  can be significantly reduced. Because the compressed program recording  can be of a smaller size than an uncompressed trace of the program's execution, the system  can be used to analyze and debug complex programs or programs that run for extended periods of time that could not be efficiently analyzed via an uncompressed trace.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 4","FIG. 3"],"b":["400","310","410","430"]},"In any of the examples described herein, a variety of compression techniques can be used to reduce the size of a program recording.  shows an example  of a compression technique for use in program recordings.","In the example, activity by a processor executing a program under test is shown in the uncompressed series  of operations A-G. The resulting compressed series  of recorded states B, D, F, and G are sufficient to reconstruct the uncompressed series . To conserve space, a count can be stored instead of storing the values for certain memory addresses.","The techniques shown include discarding values for writes, such as the write A. Such a write can be discarded from the compressed series  because the value can be regenerated via the virtual processor and executable instructions of the program under test. So, for example, the value for the write A is not included in the series  because it can be predicted during playback when the write operation is executed (e.g., by a virtual processor). Instead, a count is stored in B to indicate that the next two reads B and C can be correctly predicted based on the value from the write A.","Due to the count stored in B, the series  also does not need to store values for successive reads, if the reads result in the same value. So, for example, the read for operation C need not be recorded because the read before it, B had the same value. In particular, successive identical reads or reads after writes (e.g., when the value has not changed due to an external operation) can be predicted via any of the predictability techniques described herein. The compressed data in  can also indicate the size of read or write operations. However, in practice, the size need not be stored because it can be re-created during playback.","The series  can be stored as a stream. If desired, different streams can be used for the different components of the data (e.g., a separate stream for values and counts, and the like). The information stored in the compressed program recording can also include data about instructions that break virtualization (e.g., instructions that query the time or machine configuration) for consideration during playback.","In practice, the series  can be stored with executable instructions for the program being recorded as a compressed program recording, from which playback can determine the values of the memory addresses without having to store all the values involved in the read and write operations.","The technique of not storing values can also be described as not storing values if they can be predicted. Such predictions can rely on a virtual processor executing instructions of the software program under test and values already loaded (e.g., at playback time) from the compressed program recording.","When executing instructions of the software program under test, it might be expected that the value (e.g., for a memory address) will be a certain value. For example, it is expected that a value read from a memory address will be the value that was last written to it.","In some cases, such an expectation will be wrong. For example, the program may have switched into an unmonitored mode (e.g., kernel mode), which changed the value of the memory address. Further, if other threads or processors are running, they may change the value of the memory address. In such a case, the subsequently monitored value will not have been correctly anticipated, and it can be included in the program recording (e.g., the compressed series ). And further, the value could change yet again, so that the read from the value will be yet a different value.","So, predictability can take advantage of the observation that a value is expected to be what was last written to the memory address, but can also consider which values have already been loaded from the compressed program recording. A value that can be correctly predicted from a write or an entry in the compressed series  that has already been loaded (e.g., at playback time) need not be stored again in the program recording. Instead, for example, a running count of the number of times in a row that values will be correctly predicted by the virtual processor and the entries already loaded (e.g., at playback time) from the series can be stored. For cases in which the prediction is correct, a value need not be stored in the program recording (e.g., the compressed series ). When the prediction is not correct, the value can be stored so that it can be loaded during playback.","Because the same virtual machine (e.g., or an emulator of it) consulting the stored program recording will predict the same values during playback, storing the predictable values is unnecessary. Avoiding storage of the values can significantly reduce the size of the program recording.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 6","b":["600","600","630","640"]},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 7","b":["700","750","710","720"]},"In the example, a playback tool  accepts an initial state and recorded memory state changes  for execution of a program along with a representation  of the executable instructions for the program. Using a predictor  (e.g., which can include a virtual processor that can execute the instructions ), the playback tool  can determine an ending memory state  at a particular point during the execution, which will reflect the memory state of the program when execution was monitored and recorded.","In any of the examples herein, compressed memory state changed can be included in a program recording.  shows an exemplary method  of using a predictor and compressed memory state changes to determine memory state.","At , a virtual processor can be used in conjunction with a representation of executable instructions to generate appropriate values for memory write operations. As a result, values for the memory write operations by the processor need not be stored in the program recording. When determining the value of memory addresses, values for unpredictable memory reads are retrieved from the program recording at .","Predictable memory reads can be predicted via a predictor, and the compressed memory state changes can indicate whether the memory read is predictable or not (e.g., by keeping a count of successive predictable reads). At , the predictable memory reads as indicated in the compressed memory state changes are used to determine the value of memory addresses.","Because the values involved in memory writes and reads can be determined, the value for a particular address in memory can be determined at a specified point in time for the program.","The resulting value of a memory read operation by a processor can often be predicted during playback (e.g., it will remain the same or be written to by the processor) unless it is changed by some mechanism external to that processor or some mechanism that is not monitored during program recording.  shows an exemplary system  employing a cache  to determine predictability of memory read operations. In the example, a representation  of the executable instructions of the program are accepted by a recording tool , that includes a predictor  (e.g., including a virtual processor operable to execute or simulate execution of the instructions in representation ). The recording tool  can generate an appropriate compressed program recording via monitoring execution of the instructions .","As shown in the example, rather than storing successive predictable values for read operations, the cache  can include a hit count. If another read operation involves the value for the address already indicated in the cache , the count can simply be incremented. If a different (unpredictable) value is detected, the entry for the memory address can be stored and a new count started for the different value.","The example shows the cache after having recorded the read E of . The count in the cache  is set to 1 because during playback, there is one value that can be predicted (i.e., 77 for memory address AE02) without having to load another value from the compressed series  (e.g., the value will already have been loaded from recorded entry D).","After recording the read F, the count will be increased to 2 because during playback, there will be one more value that can be predicted (i.e., 90 for memory address ) without having to load another value from the compressed program recording (e.g., the value will already be known based on the write E).","Thus, for example, a value can be correctly predicted during playback because it has already been loaded from the compressed program recording or because a virtual processor will perform a write operation for the memory address. Recording the execution can include determining which values will be correctly predicted. Values that can be correctly predicted at playback need not be written to the compressed program recording.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 10","b":["1000","1010","1030","1040"]},"In any of the examples herein, the cache can take the form of a buffer of fixed size. An index for the cache can be computed using a calculation scheme (e.g., a modulus of the size of the cache) on the address.","The cache can be of any size (e.g., 16 k, 32 k, 64 k, and the like) as desired.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 11","b":"1100"},"At , an operation during monitored execution is analyzed to determine whether it is a read or a write. If the operation is a write, the cache is updated at  (e.g., the value is placed in the cache). As noted elsewhere herein, an indication that the write operation changed the value of memory need not be stored in the compressed program recording because it can be determined via execution of the executable instructions for the program.","If the operation is a read, it is then determined at  whether the value involved in the read is the same as that indicated in the cache (e.g., is it predictable). If so, the hit count for the cache is incremented at , and the analysis continues.","If the value is not predictable, at , the count and value are stored as part of the compressed program recording (e.g., as part of the memory state changes). The count is then reset, and the cache is updated with the new value at . Analysis continues on subsequent reads and writes, if any.","At the conclusion of the method, the information in the cache can be flushed (e.g., to the program recording) so that the remaining information left over in the cache is available during playback.","Playback of a compressed program recording can similarly employ a caching technique to correctly determine the value of a memory address.  shows an exemplary system  that employs a cache to take advantage of predictability of memory read operations. Such a system  can be included, for example, in a debugging tool. In the example, a representation  of the executable instructions of the program and a compressed program recording  are accepted by a playback tool , that includes a predictor  (e.g., including a virtual processor operable to execute or simulate execution of the instructions in representation ). The playback tool  can generate information (e.g., a value of an address) on the state of memory that reflects what was monitored during recording.","As shown in the example, rather than storing successive predictable values for read operations, the cache  can include a hit count, which is read from the compressed program recording . If a read operation involves an address and the hit count indicates the value is unchanged, the count can simply be decremented. If the count goes down to zero, a different (unpredictable) value is indicated; the entry for the memory address can then be read from the recording  together with a new hit count for the cache.","The cache is thus able to store at least one value of a memory address as a single stored value that can be used plural times (e.g., reused as indicated in the hit counts) during playback to indicate successive identical values for memory read operations for the memory address according to the compressed recording.",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 12","b":["1210","540","540","520","520","1210","1240","520","540","520","520","520","530","540"]},"The cache can thus store a predictable value for a memory address and a hit count indicating how many successive times the cache will correctly predict values in succession.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 13","b":["1300","1310","1330","1340"]},{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 14","b":["1400","1400"]},"At , an operation during playback is analyzed to determine whether it is a read or a write. If the operation is a write, the cache is updated at  (e.g., the value is placed in the cache). The value for the write can be determined via execution of the executable instructions for the program.","If the operation is a read, it is then determined at  whether the hit count in the cache is zero. If not, the hit count is decremented at , and the value for the read is taken from the cache.","If the hit count is zero, then a new value and new hit count are loaded (e.g., from the program recording) at . The new value is used for the value of the read. At  the cache is updated to reflect the new value and hit count.","Processing for further operations, if any, continues at .",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 15","b":"1500"},"At , a query is received for the value of an address x at time t. The time may be expressed absolutely (e.g., after this instruction, after this many clock cycles, etc.) or relatively (after the next n instructions, etc.) or implicitly (e.g., at the current point during execution).","At , a program recording is played back until the time t is reached using any of the techniques described herein. Then, at  the value at the address x is indicated. For example, a debugging tool may show the value on a user interface.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 16","b":["1600","1690","1620","1690","1620","1690"]},{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 17","b":["1700","1720","1740","1740","1720"]},"Thus, if playback begins at key frame A, the instructions in the partial compressed program recording A need not be played back. In some cases, such as when determining the value of a memory location that is modified subsequent to the key frame A, the contents of the earlier compressed program recordings (e.g., A) may be immaterial to the result and can be ignored. In this way, the amount of processing performed to determine state can be reduced.",{"@attributes":{"id":"p-0103","num":"0102"},"figref":"FIG. 18","b":["1800","1810","1830"]},"In implementations involving a cache, the cache can be flushed or stored before writing the key frame. As a result, operations involving memory locations will update the cache.","The illustrated technique can involve generating key frames while the program is being monitored or at a later time. In some cases, it may be desirable to generate the key frames in response to activity in a debugger (e.g., by generating key frames for areas proximate the current time location being investigated in a debugger by a developer).","The frequency at which key frames are generated can be tuned (e.g., increased or decreased) to optimize performance and compression.",{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 19","b":["1900","1900","1920","1920"]},"The key frame need to be stored (e.g., if the cache is flushed). Alternatively, the cache could be stored (e.g., if storing results in better compression).",{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 20","b":["2000","2010","2030"]},{"@attributes":{"id":"p-0110","num":"0109"},"figref":"FIG. 21","b":["2100","2190","2120","2140","2140","2130","2130"]},"Although the example can take advantage of the key frames A-N, fulfilling the request  may still involve considerable processing. If, for example, playback is initiated at key frame N, and the value for the address x cannot be determined (e.g., does not appear in the partial compressed program recording N), processing can continue to start playback at each of the key frames (e.g., in reverse order or some other order) to see if the value can be determined.","To avoid the searching situation shown in , an index can be used. A summarization index  associating key frames with memory addresses is shown in . When a request for the value of a memory address is received, the index  can be consulted to determine at which key frames playback can be commenced to determine the value. Addresses for which memory values can be determined via playback of partial compressed program recordings immediately following a key frame are associated with the key frame in the index.","If desired, more detailed information about the instructions or the instructions themselves can be stored in the index. For example, a reference to where the instructions following the key frame involving a particular memory address can be found can be stored.","If desired, basic information about key frames (e.g. when the key frame occurred and where it can be found) can also be stored in the summarization index.",{"@attributes":{"id":"p-0115","num":"0114"},"figref":"FIG. 23","b":["2300","2310","2330"]},{"@attributes":{"id":"p-0116","num":"0115"},"figref":"FIG. 24","b":["2400","2410"]},"Using the index, the key frame(s) are found. At , the one or more key frames starting playback sub-sequences involving the address (e.g., from which the value of the address can be determined, such as those sub-sequences involving reads or writes of the address) are indicated.","In practice, playback can then begin at the key frame closest to and earlier than the time location for which the value of the memory address was requested.",{"@attributes":{"id":"p-0119","num":"0118"},"figref":"FIG. 25","b":["2500","2540","2590","2510","2510","2510","2520","2520"]},"Responsive to receiving the request , a considerable amount of processing may need to be done to determine the value of the address x. Even taking advantage of the key frames may involve executing several of the subsequences A-N to determine within which the memory location appears. And, even with the summarization index, the partial compressed program recording  is consulted. In a program involving a large number of instruction cycles, it may not be efficient to load data for replay to determine activity so remote in time.",{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 26","b":["2600","2610","2610","2610","2620","2620","2630","2630","2610"]},"The snapshots A-N can include a list of memory addresses and their associated values at the point in time during execution associated with the respective snapshot. Accordingly, a request  for the contents of a memory address x can be fulfilled without having to replay the compressed program recording at which the memory address can be found. Instead, the closest snapshot before the request can be consulted (e.g., snapshot N).",{"@attributes":{"id":"p-0123","num":"0122"},"figref":"FIG. 27","b":["2700","2710","2730","2750"]},{"@attributes":{"id":"p-0124","num":"0123"},"figref":"FIG. 28","b":["2800","2800"]},"At , a request for the contents of address x is received. At , it is determined wither the address is in the code space. If it is, the value for the code bytes are returned at .","At , it is determined whether there is a summarization index for the current position (e.g., of execution within the program recording). If not, one is built that goes back from the current position to a point in execution (e.g., a sequence) where a snapshot exists. In some cases, it may be desirable to go back more than one snapshot (e.g., in anticipation of additional requests for other addresses). For example, the summarization index can go back two, three, or more snapshots.","At , it is determined whether the address is accessed in the summarization index. If it is, at , playback begins from the keyframe and finds the instruction that accesses the address to determine the value. At , if the address was found, the value is returned at .","If the address was not found, at , it is determined whether the address's value is in the snapshot that the summarization index borders. If so, the value is returned at . Otherwise, the address is not referenced in the compressed program recording, and an \u201caddress unknown\u201d result can be returned. In practice, such a result can be indicated to a user as a series of question marks (e.g., \u201c???\u201d).","The number of summarizations can be tuned for performance. In practice, snapshots tend to be larger than summarizations, so having too many snapshots can degrade performance. But, having fewer snapshots typically involves more simulation (e.g., via a virtual processor), and simulation is more efficient when a summarization can be consulted to determine where to simulate.",{"@attributes":{"id":"p-0130","num":"0129"},"figref":"FIG. 29","b":["2900","2900","2910","2910"]},"For example, each of the sub-recordings can be a stream or some other arrangement of data indicating a compressed program recording generated via monitoring state changes for a respective processor.","Thus, execution of a program that runs on multiple processors can be recorded. A similar arrangement can be used for multiple threads, or multiple processors executing multiple threads can supported.",{"@attributes":{"id":"p-0133","num":"0132"},"figref":"FIG. 30","b":["3000","3010"]},"At , a separate compressed program recording is written for respective processors. Again, a similar arrangement can be used for multiple threads, or multiple processors executing multiple threads can be supported.",{"@attributes":{"id":"p-0135","num":"0134"},"figref":"FIG. 31","b":["3100","3110","3110","3100","3150","3150","3110","3110","3110","3110"]},"In some cases, the sequences may not be dispositive. For example, it may not be conclusively determined that segment B for the recording B executes after segment A for the recording A. In such a case, when a request for the value of a memory address is received, multiple values may be returned. Such multiple values can be communicated to the developer (e.g., in a debugger) and may be indicative of a program flaw (e.g., a likely race condition).",{"@attributes":{"id":"p-0137","num":"0136"},"figref":"FIG. 32","b":"3200"},"At , the atomically incremented sequence number is maintained and incremented atomically when needed (e.g., an increment-before-write or increment-after-write scheme can be used). At , the sequence is periodically written to the compressed program subsequence.","The sequence writes can be triggered by a variety of factors. For example, whenever a lock or synchronization instruction (e.g., inter-thread atomic communication instructions such as compare-and-exchange and the like) is encountered, the sequence can be written. Also, whenever the program goes into or out of kernel mode, the sequence can be written. For further analysis, the instructions between a pair lock instructions can be associated with the first instruction of the pair.","In any of the examples herein, monitored execution can be accomplished by using a software simulation engine that accepts the program under test as input. In this way, specialized hardware can be avoided when monitoring execution. Similarly, playback can consult a software simulation engine as part of the playback mechanism (e.g., as a predictor).","Any of the technologies herein can be provided as part of an application programming interface (API) by which client programs can access the functionality. For example, a playback tool can expose an interface that allows a program to query values for memory locations, single step execution, and the like.","Further, a client can indicate via function call that it is particularly interested in a range of instructions. In response, key frames can be created during replay for the instructions within the range. Such an approach allows fast random access to positions close to the area of interest in the trace while still allowing for efficient storage of information outside the client's area of interest.","In practice, during program recording, the compressed program recording can be buffered in memory before writing to disk. A circular buffer technique can be used whereby writing to disk is not necessary.","For example, as long as the buffer is large enough to hold a key frame and the information between the key frame and the next key frame, then some of the program's state can be recreated. In practice, with a large circular buffer, typically many key frames are used to support random access.","When using the circular buffer, a threshold size can be specified. When the amount of information for a compressed program recording exceeds the threshold, information from the beginning of the recording is overwritten with later information.","Such an approach can be useful because it is often the end of a recording that is of interest (e.g., shortly before a crash).","The threshold size can be any size accommodated by the system (e.g., 50 megabytes, 100 megabytes, 150 megabytes, and the like).","In any of the examples described herein, the information in a compressed program recording can be further reduced in size by applying any compression algorithm. For example, streams of information about read operations can be compressed, indexes can be compressed, summarization tables can be compressed, or some combination thereof. Any number of compression techniques (e.g., a compression technique available as part of the file system) can be used.","The compressed program recording can be saved in a format that can be transferred to another machine type. For example, execution monitoring can be done on one machine type, and playback can be performed on another machine. Portable compressed program recordings are useful in that, for example, execution can be monitored on a machine under field conditions, and playback can take place at another location by a developer on a different machine type.","To facilitate portability, the executable instructions (e.g., code bytes) of the program under test can be included in the program recording. For example, code (e.g., binaries) from linkable libraries (e.g., dynamic link libraries) can be included. Information useful for debugging (e.g., symbol tables) can also be included if desired.","If desired, the compressed program recording can be sent (e.g., piped) to another machine during recording, allowing near real-time analysis as the information is gathered.","Additional information can be stored to facilitate portability, such as machine configuration information, architecture, endianness (e.g., byte order) of the machine, and the like.","A user interface can be presented to a developer by which the machine state as determined via the compressed program recording is indicated. Controls (e.g., single stepping, stepping backwards, jumping ahead n instructions, breakpointing, and the like) can be presented by which the developer can control the display of the machine state.","To the developer, it appears that the program is being executed in debug mode, but a compressed program recording can be used to avoid the full processing and storage associated with full debug mode.","Any number of formats can be used to store a compressed program recording. For example, the information can be saved in a file (e.g., on disk). In order to reduce contention between different threads of the program being monitored, data can be recorded for each thread independently in different streams within the file. For each stream, the data for simulating program execution during playback can be recorded.","The file format can include sequencing packets, read packets, executable instructions, and the like. For example, the sequencing packets can store the sequence information described herein. A global integer or timer can be used for the sequence. Sequencing events can be made uniquely identifiable so that ordering can be achieved.","On a single processor system, perfect ordering can be achieved by tracking context-swaps between threads. The sequencing events can also be used to track key frames (e.g., when a thread transfers control from kernel mode and user mode).","Read packets can record read operations from memory. Unpredictable reads can be stored.","The executable instructions can include the bytes of the instructions executed in the program. During replay, a simulator can fetch such instructions for simulated execution.","In any of the examples herein, the memory can be virtual memory. For example, memory accesses by a monitored program can be to virtual memory. Playback of a compressed program recording can then be used to determine the value of an address in such virtual memory (e.g., when a request for a value of an address in virtual memory is received).",{"@attributes":{"id":"p-0161","num":"0160"},"figref":"FIG. 33","b":["3300","3300"]},"With reference to , the computing environment  includes at least one processing unit  and memory . In , this most basic configuration  is included within a dashed line. The processing unit  executes computer-executable instructions and may be a real or a virtual processor. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power. The memory  may be volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory, etc.), or some combination of the two. The memory  can store software  implementing any of the technologies described herein.","A computing environment may have additional features. For example, the computing environment  includes storage , one or more input devices , one or more output devices , and one or more communication connections . An interconnection mechanism (not shown) such as a bus, controller, or network interconnects the components of the computing environment . Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment , and coordinates activities of the components of the computing environment .","The storage  may be removable or non-removable, and includes magnetic disks, magnetic tapes or cassettes, CD-ROMs, CD-RWs, DVDs, or any other computer-readable media which can be used to store information and which can be accessed within the computing environment . The storage  can store software  containing instructions for any of the technologies described herein.","The input device(s)  may be a touch input device such as a keyboard, mouse, pen, or trackball, a voice input device, a scanning device, or another device that provides input to the computing environment . For audio, the input device(s)  may be a sound card or similar device that accepts audio input in analog or digital form, or a CD-ROM reader that provides audio samples to the computing environment. The output device(s)  may be a display, printer, speaker, CD-writer, or another device that provides output from the computing environment .","The communication connection(s)  enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer-executable instructions, audio\/video or other media information, or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired or wireless techniques implemented with an electrical, optical, RF, infrared, acoustic, or other carrier.","Communication media can embody computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. Communication media include wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of any of the above can also be included within the scope of computer readable media.","The techniques herein can be described in the general context of computer-executable instructions, such as those included in program modules, being executed in a computing environment on a target real or virtual processor. Generally, program modules include routines, programs, libraries, objects, classes, components, data structures, etc., that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer-executable instructions for program modules may be executed within a local or distributed computing environment.","Any of the methods described herein can be implemented by computer-executable instructions in one or more computer-readable media (e.g., computer-readable storage media).","The technologies from any example can be combined with the technologies described in any one or more of the other examples. In view of the many possible embodiments to which the principles of the disclosed technology may be applied, it should be recognized that the illustrated embodiments are examples of the disclosed technology and should not be taken as a limitation on the scope of the disclosed technology. Rather, the scope of the disclosed technology includes what is covered by the following claims. We therefore claim as our invention all that comes within the scope and spirit of these claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 33"}]},"DETDESC":[{},{}]}
