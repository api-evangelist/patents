---
title: Method and apparatus of performing active update notification
abstract: A method and apparatus of performing active update notification. Components of an application are able to specify interest in a data object or set of data objects by registering an interest object with an update management component of the application. The interest object specifies the interested application component, as well as the identity of one or more data objects or an attribute value or range of values to associate with data objects. When modifications are made to data objects corresponding to the registered interest objects, the interested application component or components receive an update notification from the update management component. In one embodiment, active update notification is performed within a multi-tier application. An update management component exists at the application server on the application tier, as well as at each client in the client tier. In the application tier, the update management component maintains, with respect to clients and servers, a registry of interest objects of sufficient depth to determine which clients or other servers may be interested in changes to data objects. Update notifications are then sent only to the interested clients or servers. The interest registry of the update management component in the interested client is used to resolve the interested application component, and to forward the update notification appropriately.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06895401&OS=06895401&RS=06895401
owner: Sun Microsystems, Inc.
number: 06895401
owner_city: Palo Alto
owner_country: US
publication_date: 20030513
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This is a continuation of application Ser. No. 09\/092,356, filed Jun. 5, 1998, now U.S. Pat. No. 6,721,740, which claims the benefit of U.S. Provisional Application No. 60\/087,130, filed May 29, 1998, and which is incorporated herein by reference.","1. Field of the Invention","This invention relates to the field of computer software, and, more specifically, to object-oriented applications.","Portions of the disclosure of this patent document contain material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure as it appears in the Patent and Trademark Office file or records, but otherwise reserves all copyright rights whatsoever. Sun, Sun Microsystems, the Sun logo, SPARC, Java, JavaBeans and all Java-based trademarks and logos are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries.","2. Background Art","In the computer industry, an application architecture that is becoming more widely used, particularly in the Internet environment, is the three-tier application architecture, or three-tier architecture. In this architecture, a client communicates requests to a server for data, software and services, for example, and the server responds to the requests which may entail communication with a database management system for the storage and retrieval of persistent data. The three tier architecture includes a database tier that includes a database server, an application tier that includes an application server and application logic (i.e., software application programs, functions, etc.), and a client tier. The application server responds to application requests (e.g., a request for a software applet, etc.) received from the client. The application server forwards data requests to the database server. An enterprise's application (e.g., a scheduling, accounting or personnel application) may involve all three tiers as data that is used by the application may be stored in a database.","Enterprise applications often consist of displaying data to a user and allowing the user to modify that data. In a multi-tier application, multiple users may each access the application and the enterprise data at the same time. It is desirable that each user be able to see the effects of his or her own modifications in near real time. It is also desirable that the effects of other users' modifications, as well as those modifications performed by the application itself (e.g., time-based changes), be made evident to each user in near real time. For this to happen, many disparate components of the application, across multiple tiers, need to know when data changes. However, typically, an application component is unaware of data changes until the application component next performs a data access, at which time the application component might determine what changes have been made since the last data access operation. There is no mechanism for achieving near real time notification of changes across multiple tiers.","An overview of a multi-tier architecture is described below with reference to FIG. . In the three-tier architecture illustrated in , client tier  typically consists of a computer system that provides a graphic user interface (GUI) generated by a client , such as a browser or other user interface application. Client  generates a display from, for example, a specification of GUI elements (e.g., a file containing input, form, and text elements defined using the Hypertext Markup Language (HTML)) and\/or from an applet (i.e., a program such as a program written using the Java\u2122 programming language that runs when it is loaded by the browser).","Further application functionality is provided by application logic managed by application server  in application tier . The apportionment of application functionality between client tier  and application tier  is dependent upon whether a \u201cthin client\u201d or \u201cthick client\u201d topology is desired. Database tier  contains the data that is accessed by the application logic in application tier . Database server  manages the data, its structure and the operations that can be performed on the data and\/or its structure.","Application server  can include applications such as a corporation's scheduling, accounting, personnel and payroll applications, for example. Application server  manages requests for the applications that are stored therein. Application server  can also manage the storage and dissemination of production versions of enterprise application logic (i.e., the versions that are currently being used by the corporate users). Database server  manages the database(s) that manage data for applications. Database server  responds to requests to access the scheduling, accounting, personnel and payroll applications' data, for example.","Connection  is used to transmit enterprise data between client tier  and application tier , and may also be used to transfer the enterprise application logic to client tier . The client tier can communicate with the application tier via, for example, a Remote Method Invocator (RMI) application programming interface (API) available from Sun Microsystems\u2122. The RMI API provides the ability to invoke methods, or software modules, that reside on another computer system. Parameters are packaged and unpackaged for transmittal to and from the client tier. Connection  between application server  and database server  represents the transmission of requests for data and the responses to such requests from applications that reside in application server .","Elements of the client tier, application tier and database tier (e.g., client , application server  and database server ) may execute within a single computer. However, in a typical system, elements of the client tier, application tier and database tier may execute within separate computers interconnected over a network such as a LAN (local area network) or WAN (wide area network).","A method and apparatus of performing active update notification is described. Components of an application are able to specify interest in a data object or set of data objects by registering an interest object with an update management component of the application. The interest object specifies the interested application component, as well as the identity of one or more data objects or an attribute value or range of values to associate with data objects. When modifications are made to data objects corresponding to the registered interest objects, the interested application component or components receive an update notification from the update management component.","In one embodiment, active update notification is performed within a multi-tier application. An update management component exists at the application server on the application tier, as well as at each client in the client tier. In the application tier, the update management component maintains, with respect to clients and servers, a registry of interest objects of sufficient depth to determine which clients or other servers may be interested in changes to data objects. Update notifications are then sent only to the interested clients or servers. The interest registry of the update management component in the interested client is used to resolve the interested application component, and to forward the update notification appropriately.","Interest objects are provided that allow interests to be registered for individual data objects or sets of data objects. Interests may be further refined by registering other interest objects as sub-interests of existing interest objects to build an interest hierarchy within the registry. Interested components, also referred to as \u201cobservers,\u201d may be registered for each interest object in the hierarchy to receive notification of updates. A further interest object collects data objects that are part of a changed set, either through addition, removal or update, to allow an interested component to access those collected data objects after receipt of an update notification.","The invention is a method and apparatus of performing active update notification. In the following description, numerous specific details are set forth to provide a more thorough description of embodiments of the invention. It will be apparent, however, to one skilled in the art, that the invention may be practiced without these specific details. In other instances, well known features have not been described in detail so as not to obscure the invention.","Though also applicable to stand-alone client applications, in one embodiment of the invention, the apparatus for performing active update notification is embodied in one or more components of a multi-tier application implemented as computer software that is executed by a computer apparatus. A description is given below of an embodiment of a computer apparatus suitable for providing an execution environment for the software apparatus of the invention.","Embodiment of Computer Execution Environment (Hardware)","An embodiment of the invention can be implemented as computer software in the form of computer readable code executed on a general purpose computer such as computer  illustrated in , or in the form of bytecode class files executable within a Java runtime environment running on such a computer. A keyboard  and mouse  are coupled to a bi-directional directional system bus . The keyboard and mouse are for introducing user input to the computer system and communicating that user input to processor . Other suitable input devices may be used in addition to, or in place of, the mouse  and keyboard . I\/O (input\/output) unit  coupled to bi-directional system bus  represents such I\/O elements as a printer, A\/V (audio\/video) I\/O, etc.","Computer  includes a video memory , main memory  and mass storage , all coupled to bi-directional system bus  along with keyboard , mouse  and processor . The mass storage  may include both fixed and removable media, such as magnetic, optical or magnetic optical storage systems or any other available mass storage technology. Bus  may contain, for example, thirty-two address lines for addressing video memory  or main memory . The system bus  also includes, for example, a 32-bit data bus for transferring data between and among the components, such as processor , main memory , video memory  and mass storage . Alternatively, multiplex data\/address lines may be used instead of separate data and address lines.","In one embodiment of the invention, the processor  is a microprocessor manufactured by Motorola, such as the 680\u00d70 processor or a microprocessor manufactured by Intel, such as the 80\u00d786, or Pentium processor, or a SPARC\u2122 microprocessor from Sun Microsystems, Inc. However, any other suitable microprocessor or microcomputer may be utilized. Main memory  is comprised of dynamic random access memory (DRAM). Video memory  is a dual-ported video random access memory. One port of the video memory  is coupled to video amplifier . The video amplifier  is used to drive the cathode ray tube (CRT) raster monitor . Video amplifier  is well known in the art and may be implemented by any suitable apparatus. This circuitry converts pixel data stored in video memory  to a raster signal suitable for use by monitor . Monitor  is a type of monitor suitable for displaying graphic images.","Computer  may also include a communication interface  coupled to bus . Communication interface  provides a two-way data communication coupling via a network link  to a local network . For example, if communication interface  is an integrated services digital network (ISDN) card or a modem, communication interface  provides a data communication connection to the corresponding type of telephone line, which comprises part of network link . If communication interface  is a local area network (LAN) card, communication interface  provides a data communication connection via network link  to a compatible LAN. Wireless links are also possible. In any such implementation, communication interface  sends and receives electrical, electromagnetic or optical signals which carry digital data streams representing various types of information.","Network link  typically provides data communication through one or more networks to other data devices. For example, network link  may provide a connection through local network  to local server computer  or to data equipment operated by an Internet Service Provider (ISP) . ISP  in turn provides data communication services through the world wide packet data communication network now commonly referred to as the \u201cInternet\u201d . Local network  and Internet  both use electrical, electromagnetic or optical signals which carry digital data streams. The signals through the various networks and the signals on network link  and through communication interface , which carry the digital data to and from computer , are exemplary forms of carrier waves transporting the information.","Computer  can send messages and receive data, including program code, through the network(s), network link , and communication interface . In the Internet example, remote server computer  might transmit a requested code for an application program through Internet , ISP , local network  and communication interface . In accord with the invention, one such downloaded application is the apparatus for performing active update notification described herein.","The received code may be executed by processor  as it is received, and\/or stored in mass storage , or other non-volatile storage for later execution. In this manner, computer  may obtain application code in the form of a carrier wave.","Application code may be embodied in any form of computer program product. A computer program product comprises a medium configured to store or transport computer readable code, or in which computer readable code may be embedded. Some examples of computer program products are CD-ROM disks, ROM cards, floppy disks, magnetic tapes, computer hard drives, servers on a network, and carrier waves.","The computer systems described above are for purposes of example only. An embodiment of the invention may be implemented in any type of computer system or programming or processing environment.","General Software Apparatus","An embodiment of the invention includes software apparatus comprising a collection of components forming a multi-tier application. The components may be implemented as one or more instances of object classes in accordance with known object-oriented programming practices, or the components may be implemented under one or more component model definitions. Several component model definitions are currently available, such as COM, CORBA, and the Java component scheme referred to as JavaBeans\u2122.","Each component model provides for encapsulation of related functions and data structures into individual components, similar to what occurs under a standard object-oriented programming (OOP) approach. The particular mechanisms by which the components are managed and interact are defined according to the respective component model. Bridges (e.g., ActiveX) may be constructed which allow components designed under different component model definitions to interact within a single application. Interaction is typically performed through a set of methods implemented by the component. These sets of methods are referred to as \u201cinterfaces\u201d in some component models. The public methods by which OOP object classes interact are often presented in the form of application programming interface (API) definitions.","To provide a better understanding of encapsulation of related data structures and methods, an overview of object-oriented programming is provided below.","Object-Oriented Programming","Object-oriented programming is a method of creating computer programs by combining certain fundamental building blocks, and creating relationships among and between the building blocks. The building blocks in object-oriented programming systems are called \u201cobjects.\u201d An object is a programming unit that groups together a data structure (one or more instance variables) and the operations (methods) that can use or affect that data. Thus, an object consists of data and one or more operations or procedures that can be performed on that data. The joining of data and operations into a unitary building block is called \u201cencapsulation.\u201d","An object can be instructed to perform one of its methods when it receives a \u201cmessage.\u201d A message is a command or instruction sent to the object to execute a certain method. A message consists of a method selection (e.g., method name) and a plurality of arguments. A message tells the receiving object what operations to perform.","One advantage of object-oriented programming is the way in which methods are invoked. When a message is sent to an object, it is not necessary for the message to instruct the object how to perform a certain method. It is only necessary to request that the object execute the method. This greatly simplifies program development.","Object-oriented programming languages are predominantly based on a \u201cclass\u201d scheme. The class-based object-oriented programming scheme is generally described in Lieberman, \u201cUsing Prototypical Objects to Implement Shared Behavior in Object-Oriented Systems,\u201d OOPSLA 86 Proceedings, September 1986, pp. 214-223.","A class defines a type of object that typically includes both variables and methods for the class. An object class is used to create a particular instance of an object. An instance of an object class includes the variables and methods defined for the class. Multiple instances of the same class can be created from an object class. Each instance that is created from the object class is said to be of the same type or class.","To illustrate, an employee object class can include \u201cname\u201d and \u201csalary\u201d instance variables and a \u201cset-salary\u201d method. Instances of the employee object class can be created, or instantiated for each employee in an organization. Each object instance is said to be of type \u201cemployee.\u201d Each employee object instance includes \u201cname\u201d and \u201csalary\u201d instance variables and the \u201cset_salary\u201d method. The values associated with the \u201cname\u201d and \u201csalary\u201d variables in each employee object instance contain the name and salary of an employee in the organization. A message can be sent to an employee's employee object instance to invoke the \u201cset-salary\u201d method to modify the employee's salary (i.e., the value associated with the \u201csalary\u201d variable in the employee's employee object).","A hierarchy of classes can be defined such that an object class definition has one or more subclasses. A subclass inherits its parent's (and grandparent's etc.) definition. The parent class is also referred to as a \u201csuperclass.\u201d Each subclass in the hierarchy may add to or modify the behavior specified by its parent class. Some object-oriented programming languages support multiple inheritance where a subclass may inherit a class definition from more than one parent class. Other programming languages, such as the Java programming language, support only single inheritance, where a subclass is limited to inheriting the class definition of only one parent class. The Java programming language also provides a mechanism known as an \u201cinterface\u201d which comprises a set of constant and abstract method declarations. An object class can implement the abstract methods defined in an interface.","An object is a generic term that is used in the object-oriented programming environment to refer to a module that contains related code and variables. A software application can be written using an object-oriented programming language whereby the program's functionality is implemented using objects. As previously discussed, the encapsulation provided by objects in an object-oriented programming environment may be extended to the notion of components under a component model definition.","Implementation in the Java Programming Language","An embodiment of the software apparatus of the invention is implemented in the Java programming language. The Java programming language is an object-oriented programming language with each program comprising one or more object classes. Unlike many programming languages, in which a program is compiled into machine-dependent, executable program code, Java classes are compiled into machine independent bytecode class files. Each class contains code and data in a platform-independent format called the class file format. The computer system acting as the execution vehicle supports the Java runtime environment; The runtime environment contains a program called a virtual machine, which is responsible for executing the code in Java classes.","Applications may be designed as standalone Java applications, or as Java \u201capplets\u201d which are identified by an applet tag in an HTML document, and loaded by a browser application. The class files associated with an application or applet may be stored on the local computing system, or on a server accessible over a network. Each class is loaded into the Java runtime environment, as needed, by the \u201cclass loader.\u201d","Java classes are loaded on demand from the network (stored on a server), or from a local file system, when first referenced during an application or applet's execution. The runtime environment locates and loads each class file, parses the class file format, allocates memory for the class's various components, and links the class with other already loaded classes. This process makes the code in the class readily executable by the virtual machine.","Java classes may also be incorporated into Java components referred to as \u201cJavaBeans\u201d. JavaBeans are designed in accordance with the JavaBean API Specification to allow for component-based application building. Bridges (e.g., ActiveX bridges) may be used with JavaBeans to allow JavaBeans to be used in other component model environments, such as OLE\/COM and CORBA.","Support for features such as \u201cintrospection,\u201d \u201ccustomization,\u201d \u201cevents,\u201d \u201cproperties\u201d and \u201cpersistence\u201d is provided within the JavaBean framework to facilitate application building and component use. \u201cIntrospection\u201d permits builder tools to analyze how a particular bean works. \u201cCustomization\u201d permits an application builder to customize the appearance and behavior of a bean. \u201cEvents\u201d provide a simple communication metaphor that can be used to connect a bean with other application components or beans. \u201cProperties\u201d are used for bean customization and programmatic use. \u201cPersistence\u201d allows for a bean to have its customized state saved and reloaded later. These features are discussed in the JavaBean API Specification, Version 1.01, by Sun Microsystems (1997), which is available on the World Wide Web at the URL, \u201chttp:\/\/java.sun.com\/beans\/spec.html\u201d, and is incorporated herein by reference.","Embodiments of the software apparatus may be implemented using standard OOP object classes or using components under a known component model definition. For the purposes of the following description, references to components may refer to one or more instances of OOP object classes, or one or more components under a known component model.","Active Update Notification and Interest Objects","An embodiment of the invention provides a mechanism for components of an application to specify an interest in one or more data objects. Once this interest is specified, the application component is notified whenever the data objects associated with the specified interest undergo modification, for example, through creation, deletion or alteration. This notification is provided at the time the modification is made, for example, as a final step in a transaction to apply the modification to the associated data (e.g., to persistent data stored in a database).","Interests are represented as interest objects in an interest registry within an update management component. When a change is made to a data object, the root node of the interest registry is notified. The interest registry is traversed to determine those application components that have registered interest objects specifying interest criteria that matches the changed data object. Notification of the change is sent to those application components whose interest criteria matches the changed data object.","Notification may be performed by an update management component working in association with a change management component to detect when changes are made. Further, the update management component may utilize a query scheme for the specification of some or all registered interests. For example, a query object may specify criteria for data objects that an application component wishes to access. By implementing the query object as an interest object, or by transforming the query criteria into an interest object, interests associated with a query can be registered as part of a query operation.","As a further benefit to application performance, interests registered with an update management component may be used by an object cache for efficient \u201cpruning\u201d of the cache. This means that the object cache may more efficiently serve its associated application components by, for example, maintaining those data objects for which an interest is registered, and deleting those objects for which no interest exists.","In accordance with an embodiment of the invention, interest can be expressed for a single data object or for a set of data objects. Interest for a single data object may be expressed explicitly, such as by specifying a unique identifier of the data object such as an object ID or serial number. Interest for a set of data objects may be expressed either explicitly with a set of unique object identifiers, or the interest may be expressed in terms of interest criteria. Each data object comprises one or more data attributes (or variables), and may further contain one or more metadata attributes. Metadata attributes comprise data or descriptions about a data object or the attributes the data object contains. Interest criteria may include a specific value or range of values for one or more attributes of a data object. To evaluate whether a data object meets the interest criteria, the criteria is tested against attributes of the data object.","Mechanisms are also provided for refining the set of data objects specified in a given interest object or for providing a new interest that is the union of two or more existing interests. Interest refinement may be performed by specifying further interest criteria, for example, by registering a refinement object under an existing interest object, or by registering another interest object as a sub-interest of an existing interest object. A union of interests may be provided by registering existing interest objects under a new union interest object. Also, a collected update mechanism is provided for collecting data objects associated with updates of a transaction to allow registered observers to access those data objects after receiving an update notification.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 4"},"The first class of the hierarchy is Observable , which is an element of the Java.util standard class library. Observable  provides methods for adding observers to and deleting observers from an observer list, methods for notifying observers on the observer list that a change has occurred, and methods for setting and clearing a flag that specifies whether a change has occurred. Notification is performed by calling an update( ) method on all observers. An update notification may include a reference back to the sender of the notification, i.e., the calling interest object.","LiveInterest  is a subclass of Observable . LiveInterest  is configured to receive notification of a change to a data object, with a reference to the changed data object passed as a parameter. Methods to support general interest functions, such as comparison of a data object with interest criteria and registration of sub-interests, are also implemented.","LiveCollectedUpdates , LiveObjectInterest  and LiveSet  are subclasses of LiveInterest . LiveCollectedUpdates  is configured to collect data objects associated with changes made during a transaction, effectively caching those changes. The data objects are collected, for example, in one of several Vectors (e.g., an \u201cadded\u201d Vector, a \u201cremoved\u201d Vector, and an \u201cupdated\u201d Vector) based on whether the data object was added to a set of data objects defined by the given interest, removed from the set of objects, or updated. A registered observer of a LiveCollectedUpdates instance receives, at the end of a transaction, an update notification that includes a reference to the LiveCollectedUpdates instance. Using the reference, a registered observer may query the LiveCollectedUpdates instance to retrieve the \u201cadded\u201d, \u201cremoved\u201d and \u201cupdated\u201d data object Vectors. Based on the data objects contained in the those Vectors, the registered observer can ascertain the changes made to the set of data objects defined by the interest.","LiveObjectInterest  is configured to support an interest in a single object, for example, by specifying an object ID. In one embodiment, when an instance of LiveObjectInterest  is notified of a changed data object, the object ID of the changed object is compared with the object ID specified in the LiveObjectInterest instance, and all registered observers are notified if there is a match. LiveSet  is configured to support an interest in a set of objects. As stated above, a set of objects may be explicitly specified, such as by a set of object IDs, or by specifying attribute values or ranges for data objects to include in the set. LiveEditableSet  extends LiveSet  to support changes to the specified set.","LiveRefinement  and LiveUnion  are subclasses of LiveEditableSet . LiveRefinement  is configured to be appended to an instance of LiveSet  to further refine a given set. For example, if an instance of LiveSet  specifies a set of appointments for the current month, an instance of LiveRefinement  might specify appointments for UserX. For the LiveRefinement instance, the interest set would be those appointments for the current month that are associated with UserX. Registered observers of the LiveRefinement instance would receive notifications relevant to that refined set. The refinement is specified in one embodiment within a shouldContain( ) method of LiveRefinement . The data object is sent as a parameter to an instance of LiveRefinement , and shouldContain( ) returns a boolean value indicating whether the data object should be contained in the set (i.e., indicating that the data object satisfies the designated refinement.","LiveUnion  is configured to support update notification in the event that a changed data object meets the criteria of one or more interest objects associated with an instance of LiveUnion . LiveUnion  is used by obtaining multiple interest objects of any sort and registering them with an update management component in an interest registry. The instance of LiveUnion  is then registered as a sub-interest of each of the multiple interest objects.","In accordance with an embodiment of the invention, for a multi-tier application, update notifications are filtered at each tier by an interest registry. Update notifications traverse the interest registry, and are evaluated against the interest criteria of each interest object. Where the interest criteria are not met, the update notification is halted in its traverse of the given branch of the registry and discarded. Where the interest criteria is satisfied, the update notification is passed on to the next interest object(s) in the given branch (e.g., those interest objects registered as sub-interests of the current interest object). Where application components are registered as observers of an interest object, satisfaction of the interest criteria results in transmission of an update notification to the registered application components at the time the transaction completes.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":["FIG. 5A","FIG. 5A"],"b":["500","500","501","502","503","500"]},"Root node  forwards update notifications to interest objects that register with it. Root node  may be, for example, a general interest object to which other interest objects may register as sub-interests. The interest criteria for the root node encompasses all data objects so that all notifications are passed to registered sub-interests.","The interest objects registered underneath client interest objects in the server interest registry (e.g., -) are typically the same as, or similar to, the first level of interest objects registered in the respective client interest registry (e.g., interest objects -, - and  of FIG. B). Further levels of interest objects, such as those represented by refinement objects and other sub-interests, are typically not represented in the server interest registry to reduce the processing requirements of the application server. A tradeoff exists between the efficiency of sending update notifications to only those clients who are interested in a given data object, and the efficiency of resolving multiple levels of interest objects.","When a data object is changed at the application server, root node  of the server interest registry is notified of the change, and the changed data object is specified in the notification. The notification is passed to each interest object registered to root node  as a sub-interest (e.g., the Client A interest object, the Client B interest object, the Client C\/Server X interest object, etc.). Each client interest object passes the notification to each of its respective registered sub-interests (e.g., ,  or ). Each of those interest objects then tests the changed data object against its respective interest criteria. If the interest criteria are met for any given interest object, the \u201cchanged\u201d flag for the given interest object is set.","In the server interest registry, the setting of a \u201cchanged\u201d flag in any one of the interest objects in groups - result in the setting of the \u201cchanged\u201d flag for the respective client interest object. For example, if one or more interest objects in group  set their respective \u201cchanged\u201d flags, the Client A interest object is triggered to set its own \u201cchanged\u201d flag. Each client interest object, that has its \u201cchanged\u201d flag set at the time the transaction is completed at the server, delivers an update notification to the component registered as an observer on behalf of the respective client. That component then queries the client interest object to obtain the list of changed data objects, and transmits those changed data objects to the client. The root node of the respective client interest registry within the respective client's update management component is then notified of the change.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 5B","FIG. 5B"],"b":["504","504","506","507","508","510","511","513","506","507","505","508","509","509","511","512","513","514","514","515","516"]},"When root node  is notified of an object change, the notification is sent to objects , , , ,  and . If, at any level of the registry, the changed data object does not match the respective interest criteria of a given interest object, the interest object disregards the notification and does not pass the notification on to any underlying interest objects (i.e., sub-interests). However, if the changed data object does match the respective interest criteria of a given interest object, the \u201cchanged\u201d flag of the given interest object is set and the notification is passed to any registered sub-interests. Update notifications are sent, at the time the transaction completes, to all registered observers of those interest objects for which the \u201cchanged\u201d flag is set.","LiveUnion object  represents the union of the interest criteria of both LiveObjectInterest object  and LiveSet object . LiveUnion object  sets its own \u201cchanged\u201d flag if an update notification is received from either of LiveObjectInterest object  or LiveSet object .","LiveSet object  tests the changed data object against its own interest criteria. If there is a match, the \u2018changed\u201d flag is set for LiveSet object , and the shouldContain( ) methods of each of LiveRefinement objects A and B are called to test the changed data object against the respective refinement interest criteria. If, for either of LiveRefinement objects A and B, the shouldContain( ) method returns \u201ctrue\u201d, indicating that the respective refinement criteria is satisfied, the \u201cchanged\u201d flag is also set for the respective refinement object.","LiveObjectInterest object  determines whether the changed data object matches the data object specified in its own interest criteria (e.g., object ID), and sets its \u201cchanged\u201d flag if there is a match.","LiveSet object  determines whether the changed data object meets its respective interest criteria, and, if the determination is positive, sets its own \u201cchanged\u201d flag and passes the update notification to LiveCollectedUpdates object . LiveCollectedUpdates object  determines whether the changed data object matches its own interest criteria, if any is specified. If a match is indicated (or no criteria is specified), the changed data object is placed into an \u201cadded\u201d Vector, a \u201cremoved\u201d Vector, or an \u201cupdated\u201d Vector based on whether the associated change was to add the data object to, or remove the data object from, the object set defined by the interest criteria, or whether the change was to update the data object. The \u201cchanged\u201d flag of LiveCollectedUpdates object  is then set. Any update notification sent to observers registered to LiveCollectedUpdates object  will include a reference to object  to permit the observer to query object  for the contents of the \u201cadded\u201d, \u201cremoved\u201d and \u201cupdated\u201d Vectors.","LiveSet objects - illustrate a successive refinement of an interest set by the registration of a chain of sub-interests. At each node in the chain (i.e., at each interest object), the effective interest criteria of the chain may be refined by the criteria specified for the given node.","Any interest object may be registered as a sub-interest of another interest object. Also, any interest object in an interest registry may have its own registered observers. Reasons for registering sub-interests include, for example, refinement of an existing interest, and notification of changes to a related interest based on changes to the parent interest.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 6","b":["600","601","602","603"]},"In step , if the current interest is being developed as a sub-interest of an existing interest object, the process continues at step , where the current interest object is registered as a sub-interest of the existing interest object in the client interest registry. If, in step , the current interest is not being developed as a sub-interest of an existing interest object, the process continues at step . In step , the interest object is registered with the root node of the client interest registry as part of the top tier of the registry. In step , a corresponding interest object is registered at the server interest registry as a sub-interest of the client interest node of the current client.",{"@attributes":{"id":"p-0086","num":"0085"},"figref":"FIG. 7","b":["700","701","702","703","702","704"]},"In step , the \u201cchanged\u201d flag for the current interest object is set, and, in step , the update notification is passed to any registered sub-interests. In step , the process waits for the end of the current transaction before proceeding to step . In step , an update notification is sent to all components that are registered as observers for the current interest object. The \u201cchanged\u201d flag is then reset in step .","Implementation Within Three-Tier Architecture","An embodiment of the invention is executed within a multi-tier application architecture having system management components that handle the representation of data in the form of data objects on the client tier and application or server tier. Application-specific logic on the client tier and application tier access the data objects in the same manner, with storage and retrieval of persistent information in the database occurring transparently to the application specific logic.","An object cache is provided on the client tier and the application tier to return pointers to data objects in response to object IDs. Application queries are performed via query objects. A query object is resolved against the object cache if the query object contains only object IDs. Otherwise, the query object is converted into a database query. The results of a database query are packaged into one or more data objects and returned.","Changes to data are handled via change objects that encapsulate the changes being made. Change objects are produced automatically by data objects, and propagated transparently from the originating tier to the database tier in a transaction-based scheme by change management components in the client and application tiers. As change objects propagate through the client and application tiers, the change objects may be applied to the corresponding data objects in the object caches. Updates of changes are propagated to interested components via update management components on the client and application tiers that implement an embodiment of the active update notification methods of the invention. Change objects and query objects are transmitted between the client and application tiers by communication management components using serialization and reflection techniques.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 3","b":["300","300","307","311","306","300","300","307","310","307","311","307"]},"Within the client and application tiers, data is maintained in the form of data objects. Application server  maintains a set of objects containing data for the clients it serves. Clients A and B each maintain a subset of objects containing data for their respective user needs. Application server  is responsible for transforming data from the format of database server  into the form of data objects, and, similarly, from the form of data objects into the format of database server . Additionally, queries are transformed from a general query object format into the particular query format expected by database server , such as SQL.","Clients A and B comprise client-side application logic and graphic user interface (GUI) component A, client-side change management component A, client-side object cache component A, client-side update management component A, client-side communication management component A and client-side query management component A. Application server  comprises server-side communication management component B, server-side application logic B, server-side change management component B, server-side object cache component B, server-side update management component B, server-side query management component B, data store component  and database connectivity component  (e.g., a Java data base connectivity or JDBC\u2122 component).","Client-Side Components","Client-side application logic and GUI component A provides the software mechanism by which the user is able to view the data and other output associated with a particular application, to generate input in the form of additions, deletions and modifications of data, and to otherwise exert control over the data and format of what is displayed. Client-side application logic and GUI component A interfaces with client-side change management component A, client-side object cache component A, client-side update management component A and client-side query management component A.","Client-side change management component A provides the software mechanism by which changes to data are handled within the respective client. This entails determining which objects within the client are affected by a change and carrying out the change on those objects. Also, the change is propagated to the application server for handling. In one embodiment, changes are abstracted into change objects. The change object, for example, may contain the state of a given data object before a change is applied, as well as the state of the given data object after the change is applied. Custom change objects for specific data classes may be subclassed from general framework change object superclasses. Client-side communication management component A is used to transmit a change object to application server , or to receive a change object from application server .","Client-side object cache component A maintains a set of objects for the respective client, as well as a hash table of the unique ID of each object thus maintained and an associated pointer to that object. When a user makes a request for data via client-side application logic and GUI component A, client-side object cache component A is first queried to determine whether the data object containing the desired data is already resident at the client. If the data object is resident, as indicated by the presence of its object ID in the hash table, client-side object cache component A returns to the requesting logic a pointer to the data object. If the object is not resident at the client, client-side cache component A sends a request for the given object to application server . When the desired object is transmitted from application server  to the requesting client, a pointer to the object is returned to the requesting application logic, and the object is registered in the hash table for future requests.","To maintain control over the number of data objects resident in the client, client-side object cache component A may perform what is referred to as \u201cpruning the cache.\u201d This means that certain data objects are removed from client-side object cache component A by removing their entries in the hash table. Data objects whose entries have been removed from the hash table may then be garbage collected by the system. In accordance with one embodiment of the invention, the manner in which pruning is performed is based on which data objects are currently represented by interest objects in the registry maintained by the update management component A.","Within update management component A, interest objects are used as previously described to indicate that one or more components are \u201cinterested\u201d in actions involving a particular data object or set of data objects. These interest objects can thus be used to determine which cache objects are subject to registered interest and which are not. Those cache objects for which no interest objects are registered may be removed from the hash table and garbage collected to achieve more efficient cache performance.","Client-side query management component A provides a mechanism for formulating application queries, and, either resolving those queries against client-side object cache component A, or forwarding those queries to application server  for handling. Object requests or queries from application logic are typically encapsulated within one or more query objects. If a query object contains only object IDs, the query object may be resolved against the object cache. If a query object contains query information other than object IDs, the query object is transmitted to application server  to be resolved into an appropriate database query for the database server. Responses to the database query are encapsulated into one or more data objects and returned to the requester. The hash tables of the respective object cache components are updated to include the new data objects.","Custom query objects with application specific semantics may be subclassed from general framework query object superclasses. Further, query object subclasses may extend interest-based object superclasses that implement active update notification through registration of interest objects that identify the query requester with the data objects resulting from the query.","Client-side update management A provides the software mechanism by which updates are applied to data objects and other associated objects within the respective client. Client-side update management component A implements an active update notification scheme in accordance with an embodiment of the invention. This means that not only is a data object affected by changes in the form of an addition, deletion or modification of associated data, those objects in client-side application logic and GUI component A that are dependent on the associated data are also updated. This is opposed to a passive update scheme wherein objects in client-side application logic and GUI component A are not aware of changes to data until and unless a further reference is made to the respective data object, at which time the data object determines whether an update is necessary.","Client-side communication management component A provides the software mechanism by which objects and method calls are transmitted between the client (A or B) and application server . In accordance with an embodiment of the invention, objects that may be transmitted between the client and application tiers are configured with metadata describing the elements of the object, such as the attribute names and types, methods, etc. Objects configured with metadata can be serialized, that is, broken down into a set of data bytes containing the metadata descriptions and object state which may later be reconstituted (i.e., \u201cdeserialized\u201d) by the same or a different application to generate a copy of the original object.","Serialization provides a useful mechanism for object persistence and transmission. With respect to persistence, a serialized object may be stored in memory for any length of time and regenerated with the same state the object had at the time it was serialized. With respect to object transmission, a serialized object may be transmitted between remote clients and servers as data streams or packets in accordance with known communication protocols, such as the protocol implemented by the Remote Method Invocator (RMI) API. Also, serialized objects may be written to a shared portion of memory by one application and read out of the shared memory by another application. Client-side and server-side communication management components A and B implement methods to perform serialization and deserialization functions. Data transport, such as the transmission and reception of serialized objects, may be implemented using any known communication protocol as described above.","Server-Side Components","Server-side communication management component B performs the same general functions for application server  as its counterpart component A does for client A or B, such as serialization, deserialization, and data transport. Method calls and objects received by the server-side communication management component from client-side communication management component A are directed to server-side components B, B, B and B and B as specified by the call either explicitly or implicitly. Method calls or objects destined for the client tier are directed to the client-side communication management component A of the specified client, A or B.","Server-side application logic B provides any application-specific functions for application server , such as data analysis and processing algorithms, etc. Further, automated data functions, such as time-based operations, and multi-client oriented operations may be implemented by server-side application logic B. These functions may also include the implementation of a permissions model for determining access permissions and change permissions for different clients or users. The division of application-specific functionality between client-side application logic and GUI component A and server-side application logic B may be determined by the relative efficiency of shared functions on a server versus local functions on a client. Also, the use of a thin client or thick client topology may determine how functions are divided between clients A and B and application server .","Server-side change management component B provides for the application of changes, for example, in the form of change objects, to data objects in application server . Change objects may be received from either of clients A or B (or from other servers). The changes embedded within change objects are used by datastore management component  to send appropriate calls to database server  to manipulate the persistent data stored therein. In one embodiment, as part of a change operation, a call may be made to one or more permissions objects in the application logic component B, to determine whether the encapsulated change is allowed. The change may then be undone at the client if the change is not permissible, or the change may be carried out on the application server and propagated to the database if the change is permissible.","In one embodiment, changes are handled within a transactional scheme. Change objects allow several benefits in a transactional scheme. For example, change objects may be stored on a stack after the associated changes have been performed. The stack of change objects may then be used to perform transaction rollbacks, that is, the change objects may be used to \u201cundo\u201d or reverse the changes previously performed. \u201cRedo\u201d functions are also easily implemented. In one embodiment, change objects may be collected on a client while the client is offline from an application server. When the client is once again connected to the application server, the change objects may be applied to the application server.","Server-side object cache component B is similar to the client-side object cache component A. When a data object request or query object is received from a client or from the server-side application logic B, the request is resolved against the cache, if possible, by specifying the object ID in the hash table. If a data object is already registered with the object cache component B, a pointer to that object is returned. If the object is not registered with object cache component B, datastore management component  is utilized to obtain the desired object or objects from the persistent store of database server . The newly obtained data object is registered with object cache component B, and the pointer to the data object is returned to the query sender.","Server-side update management component B acts in association with change management component B to ensure that update notifications are transmitted to all interested elements of the system. Under the active update notification scheme using interest objects, update management component B maintains a registry of clients and other servers that wish to be notified when a designated data object is changed. When a change is made, interested elements within application server  and interested clients receive notification of the change. Notification within each client is typically resolved by the respective client-side update management component A.","Server-side query management component B receives query objects from the client tier, from other application servers, or from components of application server . Query objects thus obtained are resolved against server-side object cache B if only object IDs are specified by the query. If the query object cannot be resolved against object cache component B, either because the requested object IDs are not in the hash table, or because the query is not in the form of object IDs, query management component B passes the query object to datastore management component  to be processed.","Datastore management component  responds to calls from the server-side change management component B by making API calls to JDBC component  to create, delete or mutate persistent data within database server . Datastore management component also responds to query objects by submitting database requests to the database server. The results of the database requests are then encapsulated into one or more corresponding data objects. If a data object resulting from a query is already in the server-side object cache component B, the cached data object is returned. If the data object is not in server-side object cache component B, a new data object is obtained, via factory method calls directed to a data class factory object, to encapsulate the data. Typically, the factory method calls result in the instantiation of a desired data object class. However, in other embodiments, the new data object may be obtained from a pool of available data object instances. The new data objects are assigned ID numbers, loaded with appropriate data from database server , and returned.","Datastore management component  performs the conversion from queries encapsulated in query objects to corresponding database calls by resolving the queries with database tables. The JDBC component  provides the conversion between general database calls made by datastore management component  and database-specific commands (e.g., SQL) and communication protocol required by the particular implementation of database server  (e.g., Oracle, Sybase, etc.). Connection  represents the communication link between JDBC component  and database server . In some embodiments, other database connectivity components may be used in place of or in addition to JDBC component .","Database server  may be any form of structured persistent store. For example, database server  may comprise a flat-file data management system, a relational database management system (RDBMS), an object-oriented database management system (ODBMS), etc. The datastore management component  handles mapping of the data objects to the database.",{"@attributes":{"id":"p-0116","num":"0115"},"figref":"FIG. 8","b":["301","303","304","303","308","304","800","800","303","303"]},"When application logic makes a change to data object A, as indicated by arrow , a transaction is initiated that includes the creation of a change object and the propagation of that change object to the database. Change object  is transmitted to the application tier, as indicated by arrow , where change object  is applied to corresponding data object B. Changed data object  is then applied to the database through datastore management component , as indicated by arrow .","As one of the steps in the change transaction, update management component B is informed of the change, as indicated by arrow . Interested clients are identified by update management component B, and a notice of the change is transmitted to the update management component A of the interested clients, as indicated by arrow . The client update management component A then determines, based on its interest registry, which elements on the client should receive notification of the change. The data objects in object cache component A are typically updated at the time the client is notified of the change.","When application logic A makes a database query that cannot be resolved directly by an object cache, the query is transmitted, as shown by arrow , to datastore management component  in the form of query object . Transmission of query object  is performed under management of client-side and server-side query management components (not shown). In response to the query, datastore management component  returns, as shown by arrow , corresponding data objects A and B which are registered with the client-side object cache A and server-side object cache B, respectively. As part of the query process, interest in data objects A and B is registered with update management components A and B, as shown by arrows  and , respectively.",{"@attributes":{"id":"p-0120","num":"0119"},"figref":["FIG. 9","FIGS. 3 and 8"]},"As shown, the design time environment comprises schema metadata , code generator , and generated code . Generated code  further comprises client data class , data object interface , application (i.e., server) data class , factory class  and schema class . For one implementation of the multi-tier application, one client data class , one data object interface  and one application data class  are generated for each data class described by schema metadata . Data classes  and  include metadata describing the attributes and methods, for example, of the respective class. Schema class  includes metadata describing the data management of the system in terms of metaclasses and their constituent elements.","The run time environment comprises the components of the client, application and database tiers as earlier described with respect to FIG. . For example, the client tier comprises one or more clients (A) having application logic and GUI component A, change management component A, object cache component A, update management component A, query management component A and communication management component A. The application tier comprises one or more application servers () having communication management component B, application logic B, change management component B, object cache component B, update management component B, query management component B, datastore management component  and JDBC component . The database tier comprises one or more database servers (). The client and application tiers are joined by connection , and the application and database tiers are joined by connection .","As shown, handling of change objects, such as change application and forwarding operations, is performed by change management components A and B at the client and server tiers. Query management components A and B at the client and server tiers handle query object operations, such as resolving queries against a respective object cache or forwarding to another tier or to the data store component for handling. Object cache components A and B manage data objects for client A and application server , respectively. As suggested above, the client data objects are obtained for object cache component A in the form of instances of client data classes  generated in the design time environment. Similarly, application data objects in object cache component B are obtained in the form of instances of application data classes . Corresponding data objects in the client and application tiers implement the same shared data object interface  generated in the design time environment.","In , arrow  is used to illustrate the propagation of a change transaction through the three-tier system. The transaction begins in application logic and GUI component A, when the application logic initiates a change to a data object, for example, by calling one of the data object's attribute \u201cset\u201d accessor methods. In response to the method call, the data object calls change management component A, where a corresponding change object is obtained. Change management component A adds the change object to a list of change objects associated with a single transaction. Other change objects may be added to the list before the transaction is closed, for example, due to receipt of an \u201cend of transaction\u201d call.","When the transaction is closed, change management component A provides the list of change objects to communication management component A. Communication management component A serializes and transmits the list of change objects to communication management component B at application server . Communication management component B deserializes the list of change objects and provides them to change management component B. Change management component B then applies the list of change objects to the application data objects in object cache component B. The updated data objects in object cache component B are passed to data store management component . Datastore management component , in association with JDBC component , converts the updated data objects into database calls (e.g., SQL calls) to database server  to update the database records corresponding to the updated data objects.","If the transaction fails at the database server, change management component B uses the list of change objects to \u201cundo\u201d the changes made to the data objects in object cache component B and sends notification to client A that the transaction failed to commit. If the datastore management component  receives confirmation of a successful update from the database server, update management component B is notified of the updated data objects in object cache component B. Update management component B notifies all interested components on application server , and sends update notifications to all other interested servers and interested clients.","The update notification to the client includes the updated data objects. Communication management component B serializes the data objects and transmits them to communication management component A. Communication management component A extracts the object IDs from the serial stream and determines whether those data objects exist in object cache A. If a data object already exists, the values of the data object are updated with the values of the corresponding serialized data object. If a data object does not exist in the object cache, a new data object instance is placed in object cache component A and loaded with the values of the corresponding serialized data object.","Once updated data objects have been established in object cache component A, update management component A is notified of the updated data objects in the object cache. Update management component A proceeds to notify all interested components of client A of the updated data objects. The transaction is completed when the initiating element of application logic and GUI component A receives notification of the changed data objects.","In another implementation, the change objects may be applied to the data objects in object cache component A at the time an \u201cend of transaction\u201d is signaled. In this case, object cache component A would not need updating just prior to notifying update management component A of the updated data objects. However, any \u201cundo\u201d operation would include undoing data object changes in object cache component A.","Thus, a method and apparatus of performing active update notification has been described in conjunction with one or more specific embodiments. The invention is defined by the claims and their full scope of equivalents."],"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
