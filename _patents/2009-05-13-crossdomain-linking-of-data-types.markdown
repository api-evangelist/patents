---
title: Cross-domain linking of data types
abstract: In one implementation, a computer-implemented method can include receiving, at a first server corresponding to a first domain, a request from a client computer for a vector graphics file that includes instructions that implement a first method. The method can further include sending the vector graphics file to the client computer, the client computer having received a library file from a second server corresponding to a second domain, wherein the library file includes instructions that implement a second method to direct calls to the first method, and wherein executing the vector graphics file and the library file causes the client computer to perform operations. The operations performed by the client computer can include establishing a link between the first method and the second method and directing a call made to the second method with an argument associated with a data type, to the first method using the established link.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08103740&OS=08103740&RS=08103740
owner: Google Inc.
number: 08103740
owner_city: Mountain View
owner_country: US
publication_date: 20090513
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This document generally describes methods, systems, and products for enabling data types to be shared between files that are associated with different internet domains.","The Internet provides a mechanism by which a server can provide a client with a file to be executed by an application running on the client. A client can use a variety of applications to execute a variety of electronic file formats provided by a server. For example, ADOBE's FLASH PLAYER application (\u201cFLASH application\u201d) executes and displays SHOCKWAVE FLASH files (\u201cFLASH files\u201d or \u201cFLASH executables\u201d).","Generally, the FLASH application running on a client does not permit a FLASH file from a first domain (e.g., www.first-domain.com) to share data types with a FLASH file from a second domain (e.g., www.second-domain.com). This security restriction may be referred to as a \u201cdomain boundary.\u201d The FLASH file from the first domain may grant the FLASH file from the second domain scripting rights, which permits the FLASH file from the second domain to execute methods and access objects associated with the FLASH file from the first domain. When scripting rights are granted, the FLASH application restricts data (e.g., objects) accessed across the domain boundary as generic data (e.g., data accessed and\/or passed without a specified data type).","This document generally describes methods, systems, and products for sharing data types across a domain boundary.","In one implementation, a computer-implemented method can include receiving, at a first server corresponding to a first domain, a request from a client computer for a vector graphics file that includes instructions that implement a first method that is associated with a first unique identifier. The method can further include sending the vector graphics file to the client computer, the client computer having received a library file from a second server corresponding to a second domain, wherein the library file includes instructions that implement a second method to direct calls to the first method, wherein the second method is associated with a second unique identifier, and wherein executing the vector graphics file and the library file causes the client computer to perform operations. The operations performed by the client computer can include associating the first method with the first domain and the second method with the second domain so that the first method is restricted to receiving an argument from the second method as data without an associated data type; establishing a link between the first method and the second method using the first unique identifier and the second unique identifier; directing a call made to the second method with an argument associated with a data type, to the first method using the established link and passing the argument by reference, wherein the argument is received by the first method without the associated data type; and processing the directed call with the argument that was passed by reference using the first method.","In another implementation, a computer-implemented method can include receiving at a first server corresponding to a first domain a request from a client computer for a vector graphics file that includes instructions that implement a first method that is associated with a first unique identifier. The method can further include sending the vector graphics file to the client computer, the client computer having received a library file from a second server corresponding to a second domain, wherein the library file includes instructions that implement a second method to direct calls to the first method, wherein the library file further includes a third method that inherits the first method and has instructions modification at least a portion of the first method, wherein the second method is associated with a second unique identifier, and wherein executing the vector graphics file and the library file causes the client computer to perform operations. The operations performed by the client computer can include associating the first method with the first domain and the second method with the second domain so that the first method is restricted to receiving an argument from the second method as data without an associated data type; establishing a first link between the first method and the second method using the first unique identifier and the second unique identifier; defining a fourth method to correspond to the third method, wherein the defined fourth method has instructions to direct calls to the third method and is associated with the first domain, and wherein the third method is associated with the second domain such that the third method is restricted to receiving an argument from the fourth method as data without an associated data type; and establishing a second link between the fourth method and the third method.","In another implementation, a computer-implemented method can include receiving at a client computer a vector graphics file from a third-party server and receiving at the client computer a library file from a library server corresponding to a first internet domain, wherein the library file includes instructions that implement a first method that is associated with a first identifier, wherein the third-party server corresponds to a second internet domain, wherein the vector graphics file includes instructions that implement a second method to direct calls to the first method, and wherein the second method is associated with a second identifier. The method can further include associating the first method with the first domain and the second method with the second domain so that the first method is restricted to receiving an argument from the second method as data that does not have an associated data type. The method can additionally include establishing a link between the first method and the second method using the first identifier and the second identifier and directing a call made to the second method with an argument associated with a data type, to the first method using the established link and passing the argument by reference, wherein the argument is received by the first method without the associated data type. The method can also include processing the redirected call with the argument that was passed by reference using the first method, wherein the first method is configured to treat the received argument as the associated data type.","In another implementation, a system for performing cross-domain linking of data types can include one or more servers corresponding to a first internet domain and means for creating a library file that includes instructions that implement a first method that is associated with a first unique identifier and a development library file that includes instructions that implement a second method to direct calls to the first method, wherein the first method is associated with a second unique identifier. The system can further include an interface to the one or more servers configured to receive a first request from a third-party server for the development library file to be compiled into a vector graphics file and configured to receive a second request from the client computer for a library file to be used by an application executed by the client computer. The system can additionally include a communication module to transmit the development library file to the third-party server and to transmit the library file to the client computer, wherein the client computer is adapted to receive the compiled vector graphics file containing the development library file from the third-party server, and to establish a link between the first method and the second method so that a call with an argument made to the second method is directed to the first method with the argument being passed by reference when the vector graphics file and the library file are executed by the application on the client computer.","Advantageously, the described methods, systems, and products may provide one or more benefits in certain implementations. For example, syntax errors generated at run-time by passing and\/or referencing typed data across a domain boundary can be reduced. Instead of receiving syntax errors at run-time due to type mismatches, errors can be caught by performing compile-time type checking. The described methods, systems, and products can also enable better data type compatibility across a domain boundary that restricts cross-domain data type sharing. Moreover, convenient communication techniques can be made available to programmers, thereby improving the quality and type of programs they develop.","An additional advantage can include a library server having the ability to update the library that is used by third-party files without needing the participation of third-parties that create these files. For instance, if the library server updates the implementation library used by third-party files, the third-party files will receive and use the updated implementation library when being executed. By contrast, were the implementation library to be compiled into third-party files, use of an updated implementation library could depend on whether the third-parties had recompiled their third-party files with the updated library. The described methods, systems, and products permit for the updated implementation library to be used by third-party files without recompilation.","The details of one or more embodiments are set forth in the accompanying drawings and the description below. Other features, objects, and advantages will be apparent from the description and drawings, and from the claims.","Like reference symbols in the various drawings indicate like elements.","This document generally describes methods, systems, and products for allowing data types to be shared between independent processing environments within an application. An application might use independent processing environments as a security measure to execute files originating from different internet domains. The idea is that, since these files are from different servers, their interaction should be highly restricted. As such, the executables run in different, independent processing environments and are not permitted to share data types that are defined locally to the processing environment (e.g., an object data type that is defined by one of the files).","However, these security restrictions imposed by an application can hamper the use of libraries. When a library is retrieved from a different internet domain than the file that is requesting its use, the file requesting the library can be restricted from accessing and using the data types that the library defines.","This document generally describes methods, systems, and products for sharing data types between separate processing environments by creating a development library to be compiled into files seeking to access a library from another domain. The development library can include the same data type definitions as the implementation library, but the development library can contain stub methods, objects, events, etc. instead of fully implemented methods, objects, events, etc. For instance, an application programming interface (API) can be implemented by objects. For each object implementing the API, there can be a stub object that corresponds and refers to the implementation object.","Stubs can serve at least two purposes. First, they can be used to represent the data types contained in the library within the application file's processing environment. Second, the stubs can be used to \u201cspoof\u201d objects implemented in the library within the application file's processing environment. Stubs can implement the same set of API interfaces as the objects that they \u201cspoof\u201d. However, stubs and their original objects (e.g., the objects they \u201cspoof\u201d) exist in different processing environments. A stub is a representation that can be used to access the original object from the stub's processing environment. A method call made by the third-party application to a stub can be redirected by the stub to the object across the domain boundary to the corresponding original object that implements an API interface. If a method of a stub object accepts an argument that needs to be passed across the domain boundary to a corresponding original object, the stub can either clone the argument or create\/retrieve a stub object that will represent the argument within the processing environment of the corresponding original object.","The methods, systems, and products generally described in this document are illustrated using a FLASH file format and a FLASH application that can restrict FLASH files from different domains to independent processing environments. FLASH files may also be referred to as SWF (short for \u201cSHOCKWAVE FLASH\u201d) files or FLASH executables. Additionally, scripting language files that can be used to create vector graphic files may be referenced (such scripting language files may be compiled into vector graphic files). An example scripting language file used to generate a FLASH file can be referred to as an ACTIONSCRIPT. FLASH files, SWF files, and ACTIONSCRIPT files can be formatted in a variety of ways, for example, as provided in the \u201cSWF File Format Specification Version 10,\u201d published by ADOBE Systems Inc., 345 Park Avenue, San Jose, Calif. 95110-2704. Other similar files and processes may be addressed by other systems such as MICROSOFT SILVERLIGHT.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["100","100","102","104","106"]},"In the example system , the library server  is associated with a first internet domain (e.g., www.firstdomain.com) and the third-party server  is associated with a second internet domain (e.g., www.seconddomain.com). The client computer  can receive a FLASH file (or FLASH executable) from the library server  and a FLASH file (or FLASH executable) from the third-party server . Using a single application (e.g., a FLASH application) to execute both of the received FLASH files, the client computer  can impose a security restriction upon interactions between the received FLASH FILES. More specifically, since these two FLASH files are received by the client computer  from different domains, the application can restrict data type sharing, (e.g., instantiation of a data type, extension of a data type) across a domain boundary (a security restriction imposed because the FLASH files are associated with different internet domains) separating the two FLASH files.","For example, the client computer  can receive a FLASH file from the third-party server , where the file contains instructions to execute a program and display the results to the user (e.g., a game program, a map program, a video program, etc.). To properly render the program, the client computer  can receive a FLASH file from the library server  that is a library that implements a set of data types (e.g., objects, classes, etc.) and methods defined by an API. When executed, the program FLASH file from the third-party server  may attempt to instantiate an object of a data type defined in the library FLASH file. However, the program FLASH file cannot instantiate such a typed object in this circumstance because data types are not shared across the domain boundary (e.g., when instantiating a typed data object defined in the library FLASH executable, the program FLASH executable can instead invoke a generic, untyped object).","To enable data types to be shared across the domain boundary, the library server  can create a library FLASH file  and a development library FLASH file . The library FLASH file  can define a variety of resources, including data types (e.g., classes, objects, etc.), methods that operate on the defined data types (e.g., methods that take defined data types as arguments, methods defined as part of a class, etc.), events and event handlers related to the data types, etc. The definitions within the library FLASH file  can be fully implemented\u2014meaning a definition (e.g., a method, a class, etc.) has sufficient instructions to implement its intended objective (e.g., a method to display a styled dialog box can have instructions that, when executed, display the styled dialog box).","The development library FLASH file  can define all of the same data types, methods, events and event handlers as the library FLASH file . However, the definitions within the development library FLASH file  can be stubs (e.g., shells, wrappers, etc.) that are designed to link to or clone an implemented counterpart definition within the library FLASH file  at run-time.","For instance, a method A that takes an argument of data type B can be defined and implemented in the library FLASH file . A counterpart to method A can be defined in the development library FLASH file  with the same name (method \u201cA\u201d) and with the same number and type of arguments (a single argument of data type \u201cB\u201d). However, the method A defined in the development library FLASH file  can be a stub method that contains instructions to redirect calls (e.g., calls made to the stub method A) to the fully-implemented method A defined in the library FLASH file . Thus, when a call is made to the stub method A with an argument of data type B, the stub redirects that call to the implementation method A. The stub also converts the argument of type B that is passed to the implementation method A to type B defined within the implementation library before invoking the implementation method A.","After the library server  has generated the library flash file  and its corresponding development library FLASH file , the third-party server  can request and receive the development library FLASH file  from the library server  (as depicted by step A). The library FLASH file  and the development library FLASH file  can be derived from ACTIONSCRIPT files that can be compiled into FLASH files. In some implementations, in response to a request from the third-party server , the library server  can send the third-party server  an ACTIONSCRIPT file that represents the development library FLASH file .","The third-party server  can compile the development library FLASH file  (or a received ACTIONSCRIPT file) into a FLASH application file  (as depicted by step B). The FLASH application file  can include instructions that invoke the data types, methods, events, etc., defined in the development library FLASH file . With run-time linking (described in detail below), the stubs defined in the development library FLASH file  (and local to the FLASH application file ) can correspond to full implementations in the library FLASH file . Through such links and\/or clones, the FLASH application file  can use the fully-implemented data types, methods, events, etc. as defined in the library FLASH file  when making local calls to the development library FLASH file .","For example, the FLASH application file  can be any of a variety of interactive programs, such as a game (e.g., a single-player game, a multi-player online game), a mapping application (e.g., display map of a location, determine and display map with driving directions), a streaming content application (e.g., audio, video, stock quotes), a transaction enabling application (e.g., an online store, an application for filling-out and submitting forms online), etc. The library FLASH file  can be used by the third-party server  and\/or other third-party servers for a standard set of functionality (e.g., methods, events) and data types that enable the operation of such applications (e.g., the FLASH application file ).","By compiling the FLASH application file  with the development library FLASH file , an application (e.g., a third-party developer application) running on the third-party server  (or some other machine prior to the FLASH application file  being loaded onto the third-party server ) is able to identify and resolve potential syntax errors before deploying the FLASH application file  on the third-party server . Once deployed (e.g., hosted for client computers to access) on the third-party server , the FLASH application file can be sent to the client computer . Because the development library FLASH file  defines the same data types, methods, events, etc. as the library FLASH file , any syntax errors (e.g., incorrect number of arguments in a method call, wrong data type for an argument, etc.) that may exist can be identified before execution of the FLASH application file . For instance, if the FLASH application file  is not compiled with the development library FLASH file , and it makes an improperly typed call to a method defined in the library FLASH file , the syntax error may not be identified until run-time (e.g., when the call to the method is made) because the two files are not compiled together.","Referring again to the operation of the system , the third-party server  sends a compiled FLASH application file  to the client computer  (as depicted at step C) to be executed by a FLASH application . After receiving the compiled FLASH application file , the FLASH application  can begin executing the compiled FLASH application file  in an independent environment  (e.g., a sandbox) that is associated with the second internet domain. The compiled FLASH application file  can include instructions (via the development library FLASH file ) that identify the library FLASH file  as being needed for the FLASH application file  to function properly. The FLASH application file  (or the development library FLASH file ) can instruct the FLASH application  and\/or the client computer  to obtain the library FLASH file  from the library server .","The client computer  can send a request  for the library FLASH file  to the library server  (as depicted at step D). The library server  can then retrieve the library FLASH file  and send it to the client computer  (as depicted by step E). Having received the library FLASH file , the FLASH application  can begin to execute the library FLASH file  within an independent environment  (e.g., a sandbox) associated with the first internet domain. Since the FLASH application  executes the FLASH application file  and the library FLASH file  in different independent environments  and , respectively, the FLASH application file  and the library FLASH file  may not be able to share data types, instantiated objects, events, etc., under normal conditions.","The FLASH application file  and the library FLASH file  can be termed to be separated by a domain boundary  within the FLASH application . The FLASH application  can permit the FLASH application file  and the library FLASH file  to make method calls across the domain boundary . However, the FLASH application  can restrict data passed across the domain boundary  as generic (e.g., untyped) data.","For illustrative purposes, assume a call to a method A originates from the independent environment  associated with the first internet domain, which has a stub  of method A. The call to the stub  results in the invocation of a method  (from the library file ), which is executed within the independent environment  associated with the second internet domain. Because the definition for the stub  exists at the moment of compilation of application , errors in the name of the method or the type of its parameters will be found during the compilation of the application . If the method A accepts an argument of type B, the stub  can check that the argument is converted to type B defined within domain  before method  is invoked (unless argument B has the data type defined by Flash library). The stub  may have to take care of creating the object of the type B that can be accepted by method  before invoking that method.","In some implementations, the FLASH application  can restrict as generic data only customized data types (e.g., classes defined within the library FLASH file ) that are defined within one of the independent environments  or . In such implementations, standard data types defined by the FLASH application , such as integers, strings, sprites, etc., can be passed as typed data across the domain boundary , whereas all custom data types (defined outside of a FLASH library) are passed as generic untyped data. In other implementations, all data types (including standard data types) can be restricted as generic when they are passed across the domain boundary .","Upon execution of the library FLASH file , the development library FLASH file  compiled into the FLASH application file  can be linked to the library FLASH file . Linking the two library FLASH files  and  over the domain boundary  can involve linking parts (e.g., objects, methods, events, etc.) of the library FLASH file  with corresponding parts of the development library FLASH file . For example, a fully-implemented method A in the library FLASH file  can be linked to a stub method A in the development library FLASH file . In another example, a stub object in the development library FLASH file  can be linked to an object in the library FLASH file  that implements part of an API. A link can be implemented in a variety of ways, including as a pointer to the corresponding part (e.g., a memory address of the corresponding part), a unique name of the corresponding part, etc.","Links can be used to redirect calls to methods of stubs (e.g., instantiated objects, events, etc.) from the development library FLASH file  across the domain boundary  to corresponding fully-implemented objects, methods, events, etc. provided by the library FLASH file . For instance, as depicted, a link  is provided between a method stub  in the development library FLASH file  (which is depicted as part of the FLASH application file ) and a corresponding, fully-implemented method  in the library FLASH file . A call made to the method stub  can be redirected to the fully-implemented method  using the link  (e.g., a pointer to the fully-implemented method).","Additionally, an argument passed to the method stub  when it is called can be passed across the domain boundary  to the implemented method  as generic data  using the link . Since the implemented method  takes the same typed arguments as the method stub , the method stub  can convert the parameter to the desired type before passing it to the implemented method  using the link . Conversion of the parameter by the method stub  can involve invoking a set of methods of a domain wrapper object within FLASH library file . The domain wrapper objects can be created on both sides of the domain boundary. Stub objects can have links to the domain wrappers on both sides to perform object type conversions. Domain wrapper objects within each domain can be responsible for creating a representation (stub or clone) of data types (e.g., objects) coming from another domain within its own domain. For instance, a domain wrapper within FLASH library file  may be responsible for creating the representation of the argument that will be passed to a method within domain . However, if method  returns a result, a domain wrapper within the FLASH application  may be responsible for creating the representation of that result accessible within domain  by the caller of method A .","Arguments can be passed across the domain boundary  in a variety of alternative ways. For instance, cloning an argument from an object in one domain to another object in the other domain can be performed field-by-field across the domain boundary . In another example, a stub for the argument can be created if the argument is a complex object whose implementation only exists on one side of the domain boundary . In a further example, the argument can be passed directly if the argument type is defined within a FLASH standard library. In such an instance, the type definition for the argument will be available on both sides of the domain boundary  and object types will be available on both sides.","The argument can be passed from the method stub  to the implemented method  by-copy (e.g., a copy of the argument is sent to the implemented method ) or by-reference (e.g., a pointer to the argument's memory address in the independent environment  can be passed). If the argument is passed-by-copy, a modification made by the implemented method  to the argument (e.g., a variable, an object, etc.) that is passed across the domain boundary  will not be reflected on the independent environment  associated with the second internet domain (e.g., the argument passed to the stub method  will not reflect a change to the value of the argument passed across the domain boundary ). If the argument is passed-by-reference, a modification made by the implemented method  to the argument (e.g., a variable, an object, etc.) passed across the domain boundary  will be reflected on the independent environment  associated with the second internet domain (e.g., the argument passed to the stub method  will reflect a change to the value of the argument passed across the domain boundary ).","For illustrative purposes, assume the argument passed to the method stub  is an integer containing value 10. If the argument is passed-by-copy to the implemented method  and the implemented method  changes the value of the integer from 10 to 12, when the implemented method  finishes, the value of the argument passed to the method stub  will still be 10 (e.g., the implemented method  will have operated on a copy of the argument passed to the method stub , not the argument itself). By contrast, if the argument is passed-by-reference and the implemented method  changes the value of the integer from 10 to 12, the value of the argument to the method stub  will be 12 when the implemented method  finishes its operations.","Linking can be accomplished using instructions contained within the library FLASH file  and\/or the development library FLASH file  (e.g., a domain wrapper objects within each environment  and  that is responsible for creating a representation (stub or clone) of data types). To establish a link, corresponding portions (e.g., a method, an object, an event, etc.) of the library FLASH file  and the development library FLASH file  can be identified. For instance, the method stub  can be identified as corresponding to the implementation method  (e.g., the method  is a full-implementation to which the method stub  refers). In some implementations, corresponding portions (e.g., objects) are linked together by direct memory references since the FLASH application file  and the library FLASH file  are being executed in the same address space. In such implementations, methods can be accessible directly through method names on their respective objects. When objects are created by the domain wrappers, described above, domain wrappers can establish links between the original object and its new stub","In some implementations, corresponding portions of the FLASH application file  and the library FLASH file  are identified using unique identifiers associated with each portion to be linked. For instance, the stub method  can be associated with a first unique identifier that is paired with a second unique identifier that is associated with the implemented method . The unique identifiers can be unique with respect to each of the independent environments  and  (e.g., a unique identifier A can occur within each independent environment  and ). Alternatively, the unique identifiers can be unique across all of the independent environments  and  (e.g., the unique identifier A can occur once across both independent environments  and ). The unique identifiers can be implemented in a variety of ways, such as using a unique naming convention for portions of the FLASH files  and  (e.g., the stub method  can be uniquely named stub_method_A and the implemented method  can be uniquely named implementation_method_A).","In addition (or as an alternative) to linking, portions of the library FLASH file  can be cloned across the domain boundary  to be used in place of the stubs that are defined in the development library FLASH file . Through cloning, portions (e.g., objects, methods, events, etc.) of the library FLASH file  can be cloned (e.g., copied) from the independent environment  that is associated with the first internet domain into the independent environment  that is associated with the second internet domain. Cloned portions of the library FLASH file  can replace or be linked to by the stubs within the development library FLASH file . For example, an implementation object that is instantiated by the library FLASH file  can be cloned across the domain boundary  and used in place of a stub object by the FLASH application file .","Cloning can be performed when portions (e.g., objects, methods, events, etc.) of the library FLASH file  are instantiated within the independent environment  that is associated with the first internet domain. For instance, an object A that is instantiated when the library FLASH file  is initially executed by the FLASH application  can be cloned before an object B that is not instantiated until a later time (e.g., the object B can be instantiated in response to a method call made across the domain boundary  by the FLASH application file ).","In some implementations, cloning and linking can be used together to provide for usage of data types across the domain boundary . For instance, cloning can be employed for smaller portions (e.g., an object containing a few variables limited to a small size and a few methods) of the library FLASH file  and linking can be used for larger portions (e.g., an object containing many variables and many methods). In another example, cloning can be employed when an implementation is trivial enough to be placed on both sides of the domain boundary , and linking can be used if an implementation is available within only one side of the domain boundary .",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","202","204","206","200","100","202","102"]},"Similar to the system  as described above with reference to , the library server  can host a first internet domain (www.firstdomain.com) and the third-party server  can host a second internet domain (e.g., www.seconddomain.com). The client computer  can use a vector graphics application (e.g., a FLASH application) to execute vector graphics files (e.g., FLASH files) received from the library server  and the third-party server . Through instructions created by the library server  and included in the vector graphics files received by the client computer , data types can be shared across a domain boundary within the vector graphics application by cross-domain linking and\/or cloning data types.","The library server  can be any appropriate sort of computing device that is capable of generating vector graphics files and responding to client requests. For example, the library server  can be a desktop computer, a rack-mounted server, a distributed computing system (e.g., a collection of servers and\/or computers), a portable computing device (e.g., a laptop), etc. Similarly, the third-party server  can be any sort of computing device that is capable of generating vector graphics files and responding to client requests. For instance, the third-party server  can be a desktop computer, a rack-mounted server, a distributed computing system (e.g., a collection of servers and\/or computers), a portable computing device (e.g., a laptop), etc.","The client computer  can be any sort of computing device that is capable of receiving vector graphics files from the library server  and the third-party server , and of executing the received vector graphics files with a vector graphics application (e.g., running a FLASH application at runtime). For example, the client computer  can be a desktop computer, a server (e.g., a home media server), a distributed computing system (e.g., a collection of servers and\/or computers), a portable computing device (e.g., a laptop, a PDA), a mobile phone, a video game system, an embedded computing device (e.g., a navigation computer and display embedded within the console of an automobile), etc.","The system  can additionally include data repositories -and a network . The data repositories -can be any sort of computing device that is capable of data storage and retrieval, such as a desktop computer, a rack-mounted server, a distributed computing system (e.g., a collection of servers and\/or computers), etc. The network  can enable communication between the library server , the third-party server , the client computer , and the data repositories -. The network  can be any type of network enabling communication between such devices, such as the Internet, an intranet, a wide area network (WAN), a local area network (LAN), a tether between devices (e.g., point-to-point connection), a direct connection between devices (e.g., hardwired connection), etc.","The library server  can include an input-output interface  (I\/O interface) that receives instructions regarding the creation of a vector graphics file to perform cross-domain linking within a vector graphics application. The I\/O interface  can receive these instructions from a source (e.g., a user) that is external to the library server  and can forward the instructions to a vector graphics library creation component . The vector graphics library creation component  can create an implementation vector graphics library file that fully-implements classes, objects, methods, even handlers, etc. in such a manner that they can perform cross-domain linking and\/or cloning when executed by a vector graphics application. For example, the implementation vector graphics library creation component  can create the library FLASH file , as described above with reference to .","The vector graphics library creation component  can forward the created implementation vector graphics library file to a development library creation component . The development library creation component  can create a development vector graphics library file that defines stubs (e.g., wrappers) of the classes, objects, methods, even handlers, etc. contained in the implementation vector graphics file. Although independent of each other, the vector graphics library creation component  and the development library creation component  can share the same portions of the same source. This shared source can permit the development library creation component  to create the development vector graphics library file separate from the implementation library. The development vector graphics library file can be created in such a manner that it links to and\/or clones the corresponding classes, objects, methods, even handlers, etc. defined in the implementation vector graphics library file. For example, the development library creation component  can create the development library FLASH file , as described above with reference to .","The vector graphics library creation component  and\/or the development library creation component  can forward the created implementation and development vector graphics library files (e.g., .as\/.mxml source file) to a vector graphics compiler  (e.g., a FLEX compiler). The vector graphics compiler  can compile the library files into a format that a vector graphics application is capable of executing. For example, if the library files are ACTIONSCRIPT files and the vector graphics compiler  is FLASH compiler, the library files can be compiled into SHOCKWAVE FLASH (or FLASH for short) files. In some implementations, the implementation vector graphics library file is compiled and the development vector graphics library file is not.","The vector graphics compiler  can send, via the I\/O interface , the library files to the data repositories -for storage. The data repository can store the (compiled or uncompiled) development vector graphics library file. The data repository can store the compiled implementation vector graphics library file.","The third-party server  can request the created development vector graphics library file from the library server  and\/or from the development library repository . The third-party server  can make such a request and receive the development vector graphics library file via an I\/O interface  contained in the third-party server . The I\/O interface  can forward the development vector graphics library file to a development library integration component , which integrates the development vector graphics library file into a program vector graphics file (e.g., the FLASH application file ). The program vector graphics file can make reference to the data types, methods, events, etc. contained in the development vector graphics library file. For example, the program vector graphics file can be the FLASH application file  described above with reference to .","The development library integration component  can forward the program vector graphics file integrated with the development vector graphics library file to a vector graphics compiler . Similar to the vector graphics compiler  of the library server , the vector graphics compiler  can compile the program vector graphics file with the development library into a file format (e.g., compile from an ACTIONSCRIPT into a SHOCKWAVE FLASH file) that the vector graphics application (e.g., FLASH PLAYER) can execute.","Although not depicted, the vector graphics compiler  can send the compiled program vector graphics file to a repository (similar to the implementation library repository ) for storage until receiving a request for the file from the client computer . Through the network  and the I\/O interface , the third-party server  can receive and process a request from the client computer  for the compiled program vector graphics file. In response, the third-party server  can send the requested program vector graphics file to the client computer .","The client computer  can receive the program vector graphics file at an I\/O interface , which can forward the received file to a vector graphics application  (e.g., a FLASH PLAYER application) running on the client computer . The vector graphics application  can execute the program vector graphics file upon receipt. The program vector graphics file can instruct the vector graphics application  to obtain the implementation library vector graphics file from the library server. As such, the vector graphics application  can send a request to the library server  through the I\/O interface  and the network .","The library server  can receive the request at the I\/O interface , which can in turn forward the request to a library identification component . Based upon the request, the library identification component  can identify the implementation library vector graphics file to fulfill the request. For example, the request may identify a name and version of the development library vector graphics file integrated into the program vector graphics file being executed by the client computer . Based upon this information, the library identification component  can identify a compatible implementation library vector graphics file from the implementation library repository ","Once the appropriate library has been identified, the library identification component  can forward the identification to the request processing component . The request processing component  can retrieve the appropriate library vector graphics file from the implementation library repository and send it to the client computer  via the I\/O interface  and the network .","The client computer  can receive the requested implementation library vector graphics file at the I\/O interface , which in turn forwards the implementation library to the vector graphics application . The vector graphics application  can then proceed to execute the implementation library which, in combination with the program vector graphics file from the third-party server , can perform cross-domain data type sharing via linking and\/or cloning. The vector graphics application  can execute the program and implementation library vector graphics files in separate, independent environments, similar to the independent environments  and . The program and implementation library vector graphics files can perform cross-domain linking and\/or cloning operations when executed (by the vector graphics application ) similar to those described above with reference to the library FLASH file , the FLASH application file , and the FLASH application .","For example, the vector graphics application  can be a FLASH PLAYER application that receives a program FLASH file (e.g., a game, a mapping program, a news feed program, a video player program, a content development program, etc.). The program FLASH file can request an API that contains fully-implemented data types (e.g., objects), methods, and events that are needed to enable the functionality of the program FLASH file. The program FLASH file can request the API from the library server , which in turn can retrieve and send it from the implementation library repository to the client computer . Upon receipt, the API can proceed to share data types, methods, and events it defines with the program FLASH file via linking and cloning across a domain boundary in the FLASH PLAYER application.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":["FIG. 3","FIGS. 1 and 2","FIG. 1"],"b":["300","300","100","200","300","114"]},"The system  includes an implementation library  and a FLASH application file  that are separated by a domain boundary . Similar to the description above with regard to , the implementation library  and the FLASH application file  can be executed in separate, independent execution environments within a FLASH application. As depicted, the implementation library  can be received from a first internet domain (e.g., www.firstdomain.com) and the FLASH application file  can be received from a second internet domain (e.g., www.seconddomain.com).","In executing the FLASH application , a call  to a method B of an object A can be made with an argument C. The call  can be an instruction within the FLASH application file  that is executed. An object A  can be instantiated as a data type defined by a development library . The development library  can be part of the FLASH application file . Similar to the development library FLASH file , the development library  can define stubs of fully implemented objects, methods, event handlers, etc. that are defined in the implementation library . The object A  is depicted as a stub of an implementation object A  that is instantiated by the implementation library . As a stub, the object A  can contain stub methods, stub even handlers, and stub data (e.g., other stub objects) that refer to the object A  for a full implementation.","In the example system  depicted, the stub object A  includes a stub method B  and a stub event listener . In some implementations, the stub method B  and the stub event listener  can include links (e.g., pointers) to corresponding an implemented method B  and an implemented event listener , respectively. In other implementations, a link between the stub object A  and the implementation object A  can be established. The links can be established at run-time (e.g., when the FLASH application file  and the implementation library  are being executed) similar to the manner described above with respect to .","In executing the call , an argument C  can be passed to the stub method B  of the stub object A  (as depicted at step S). The argument C  can be typed data (e.g., not generic, untyped data). For example, the argument C  can be of a data type defined in the development library . Upon receiving the argument , the stub method B  can perform a conversion (e.g., using a domain wrapper) of the argument C  into an object that can be consumed by the implementation method B . The stub method B  can use the link to redirect the call  and the argument C  to the fully-implemented method B  that is part of the implementation object A .","The call  with argument C can be redirected over the domain boundary  to the implementation method B  (as depicted at step S). Since the typed argument C is passed over the domain boundary , the implementation method B  can receive the argument C as generic, untyped data . The implementation method B  can then perform the redirected call using the passed argument .","In some implementations, the argument C is passed to the implementation method B  by-reference. In such implementations, a reference (e.g., memory address) for the argument C can be passed and received as generic data . Any modifications of argument C\u2032s value can be reflected in argument C  received by the stub method B  received as part of the call . In other implementations, the argument C is passed to the implementation method B  by-copy (value). In such implementations, a copy of the argument C  is passed to and received by the implementation method B  as the generic data . Modifications to the received generic data  by the implementation method B  will not be reflected in the argument C  passed to the stub method B .","Upon receiving the redirected call, the implementation method B  (or a domain wrapper on the implementation library  side of the domain boundary ) can determine whether the argument C passed across the domain boundary  as the generic data  is a stub (e.g., another stub object instantiated from the development library ). If the argument C is a stub, then the implementation method B  can resolve the stub to its corresponding implementation on the implementation library  side of the domain boundary . For example, if the argument C  is an instantiated stub object D (not depicted) that is passed (either by-reference or by-copy) to the implementation method B , then the implementation method B  can locate an instantiated implementation object D to which the stub object D corresponds. The implementation method B  can then proceed to use the resolved implementation object (e.g., implementation object D) instead of the stub object for processing the redirected call.","The calls to the stub method B  and the implementation method B  can be synchronous, stack-based method calls. This means that processing of the stub method B  can proceed automatically upon completion of the implementation method  (e.g., without the implementation method B  having to communicate to the stub method B  that processing of the implementation method B  has finished). For example, when these two methods make calls to each other, each successive call is placed at the top of a stack of method calls for processing. The application executing these methods (e.g., a FLASH PLAYER application) then proceeds to process a method at the top of the stack. When processing of the method at the top of the stack is finished, the top method is removed from the stack and processing of the next method on the stack begins. Thus, when the implementation method B  is finished, the application processing these methods can return to processing the stub method B  (the stub method B  can remain on the stack when it calls the implementation method B ). Processing of the stub method B  can resume without the implementation method B  having to communicate to the stub method B  that processing of the implementation method B  has finished.","Once the stub method B  has received and interpreted the generic data , the stub method B  can pass the typed return value  back to the call  (as depicted at step S). Given the use of links between the stub method B  and the implementation method B , the call  can employ the implemented method B  without having to know the complexity involved with cross-domain linking of objects  and . The call  can operate as if though the implementation object A , and its implementation method A , were instantiated on the second internet domain side of the domain boundary .","As mentioned previously, the stub object A  can include the stub event listener  and the implementation object A  can include the implementation event listener . Both the stub object A  and the implementation object A  can additionally include an event dispatcher (e.g., a method, an object). The event dispatcher can be responsible for invoking the appropriate event listeners when an event occurs. The stub event listener  can be a method that is designated to receive a notification when a specified event (e.g., a mouse click, a window receiving focus, etc.) occurs on the second internet domain side of the domain boundary  (e.g., occurs within the independent environment within which the FLASH application file  is executed). Similar to the stub method B , the stub event listener  can have a link to the implemented event listener .","When the stub event dispatcher (not depicted) receives notification that an event has occurred, the event dispatcher can invoke the stub event listener . The stub event listener  can redirect the notification to the implementation event listener  across the domain boundary  to an implementation event dispatcher (not depicted). The implementation event dispatcher can in turn invoke the implementation event listener , which receives information regarding the event (e.g, an argument for an x mouse click coordinate, an argument for an y mouse click coordinate, etc.) as generic data . The stub event listener  can convert the event information , which can be passed across the domain boundary  as generic data, into an appropriate type for the stub event listener  and the implementation event listener .","The implementation event listener  can process the event using the generic data  and, although not depicted, pass a return value to the stub event listener  (similar to the return value passed as the generic data ). In some implementations, there may be predefined event listeners. In such implementations, the above described event linking across the domain boundary  can be enabled by defining the stub event listener  and the implementation event listener  to override the predefined event listeners.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 4","FIGS. 1-3"],"b":["400","400","100","200","300"]},"Similar the system  depicted in , the system  includes an implementation library  and a FLASH application file  that are separated by a domain boundary . The implementation library  and the FLASH application file  can be executed in separate, independent execution environments within a FLASH application. As depicted, the implementation library  can be received from a first internet domain and the FLASH application file  can be received from a second internet domain.","In the system , the implementation library  can define and instantiate an implementation object A  that contains an implementation method B . The FLASH application file  can define and instantiate an object C  that inherits (e.g., extends, overrides, etc.) an implementation object A  (e.g, the class C can inherit the class A). For instance, with a class A defined in the implementation library  and a class stub A defined in the developer library, a class C can extend the class stub A and modify the implementation of method B.","The object C  can define a method B  that overrides the implementation method B  and a method D  that is not provided in the implementation object A . The object C  can further include a stub object A  that refers to the implementation object A . A stub method B  with a link  to the implementation method B can be Included in the stub object A . The object C  can include the stub object A  so that the object C  can call the original (not extended) implementation method B , if needed. For instance, a call to the stub method B  may be included as part of the method B  (e.g., the method B  may define additional instructions that are to be executed before or after the implementation method B  is called).","The steps by which a call from the method B  migrates to the stub method B  and the implementation method B  can be similar to the steps S- described above with reference to .","The implementation library  can additionally include a stub object C  that corresponds to the object C  inheriting the implementation object A . In some implementations, since class \u201cC\u201d extends class \u201cA\u201d defined within the library, objects of type \u201cC\u201d can passed into the implementation library and appear to the implementation library just like objects of type \u201cA\u201d. The implementation library can include a stub for type \u201cA\u201d. Because type \u201cC\u201d implements all the same methods defined publicly in type \u201cA\u201d, an object of type \u201cC\u201d can be passed back into the implementation library to any method call that accepts an argument of type \u201cA\u201d. A stub for an object of type \u201cA\u201d can be created by the library and object C can be called whenever a method of the stub for object A is invoked.","The stub object C  can include a stub method B  having a link  to the method B  (the method overriding the implementation method B ) of the instantiated object C . The stub object C  can additionally include a stub method D  having a link  to the method D  of the object C . In some implementations, the links between the stub methods B  and D  can instead be represented by a single link between the stub object C  and the implementation object C . In such implementations, the methods can be invoked by name through this link.","The stub object C  can be called on the first internet domain side of the domain boundary  in a variety of scenarios. For instance, assume a function making a call to the method B  of object C  is passed as an argument to the implementation method B . When the implementation method B  executes the function argument and, in turn, calls the method B , it will call the stub method B  of the stub object C . When the stub method B  is called, it can use the link  and redirect the call to the method B  of the object C . The method B  can, in turn, call the implementation method B  via the stub method B  and its link  (e.g., the method B  can extend the implementation method B  by having additional instructions before and\/or after calling the method B ). Thus, in this example scenario, the call made to the implementation method B  has gone full-circle. Any values returned from these methods can be passed via the called methods in a reverse order.","The stub objects  and  can be instantiated in a manner similar to object instantiation described above with reference to . The links , , and  can be established in a manner similar to link establishment described above with reference to .",{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 5","b":["500","500","100","400","100","400","500"]},"The timeline  depicts a library server  associated with a first internet domain, a third-party server  associated with a second internet domain, and a client computer  having a first environment  associated with the first internet domain and a second environment  associated with the second internet domain. The library server , the third-party server , and the client computer  may be similar to the library servers ( and ), the third-party servers ( and ), and the client computers ( and ) described above with reference to . The fist environment  and the second environment  may be similar to the environments described on either side of the domain boundaries ( and ) described above with reference to .","At time , the library server  creates a library FLASH file (e.g., library FLASH file , implementation library , implementation library , etc.). As described above, the library FLASH file can be created such that it will enable linking and\/or cloning across a domain boundary in the client compute  at run-time. At time , the library server  creates a development library FLASH file (e.g., development library FLASH file , development library , etc.). As described above, the development library FLASH file contains stubs of the methods, classes, data types, events, etc. that are in the library FLASH file. The stubs in the created development library FLASH file can also be created to enable linking and\/or cloning across a domain boundary in the client compute  at run-time.","The library server  can send the created development library FLASH file to the third-party server . At time , the third-party server  can compile the development library FLASH file into a FLASH application file (e.g., FLASH application file , FLASH application file , FLASH application file , etc.). The FLASH application file can include code that references the stub data types, classes, method, events, etc. defined in the development library FLASH file.","At time , the second environment  of the client computer  can receive (from the third-party server ) and execute the FLASH application file . The FLASH application file  can be executed by the second environment  because the third-party server , from which the FLASH application file was received, is associated with the second internet domain. Execution may be performed by an application running on the client computer  capable of executing FLASH files, such as a FLASH PLAYER application. Upon execution, the FLASH application file may instruct the client computer  to retrieve the created library FLASH file from the library server .","In response to a request from the client computer , the library server  can send the library FLASH file to the client computer (time ). Since the library FLASH file  is received from the library server , which is associated with the first internet domain, the library FLASH file can be executed in the first environment  (time ).","With the library FLASH file being executed on the first environment  separate from the FLASH application file being executed on the second environment , the FLASH application file can link the stubs in the development library FLASH file (compiled as part of the FLASH application file) to corresponding fully-implemented methods, objects, events, etc. in the library FLASH file (time ). As described above, linking can be accomplished using unique identifiers associated with each portion (e.g., method, object, event, etc.) of the two FLASH files that is to be linked. Alternatively (or in combination with linking), portions of the library FLASH file can be cloned from the first environment  into the second environment  (step ).","If the library FLASH file contains stubs (as described with reference to ), the library FLASH file may optionally link its stubs to corresponding fully-implemented methods, objects, events, etc. in the development library FLASH file (time ). Alternatively (or in combination with linking), portions of the development library FLASH file can be cloned from the second environment  into the first environment  (step ).","At time , a call to a stub method A (which can be part of an object) can be made in the second environment  (e.g., call , etc.). The call can be made from the FLASH application file and the stub method A can be defined in the development library FLASH file. Through a link contained in the stub method A, the call to the stub method A can be redirected from the second environment  and to an implementation method A on the first environment . The implementation method A can process the redirected call (time ). Arguments passed with the call can be passed as generic data (e.g., generic data ) that the implementation method A is capable of interpreting with an appropriate type, as described above. At time , a return value can be passed from the first environment  and to the stub method A on the second environment . The sub method A can receive the return value and redirect the return value to a location in the FLASH application file from which the call at time  originated (time ).",{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 6","b":["600","600","100","200","100","200","600","102","202","600"]},"Beginning at step , an implementation library file (e.g., the library FLASH file ) can be created. The created implementation library file can be configured to perform cross-domain linking and cloning of data types in conjunction with a development library file. The implementation library can be a vector graphics file (e.g, a FLASH file) or any other type of formatted file that a vector graphics application (e.g., a FLASH PLAYER application) running on a client computer can reference and\/or execute.","A development library file can be created to link to the created implementation library file (step ). Similar to the development library FLASH file , the created development library can contain stubs of methods, classes, objects, events, etc. that are defined in the implementation library file. The development library file can be a vector graphics file (e.g, a FLASH file) or any other type of formatted file that a vector graphics application (e.g., a FLASH PLAYER application) running on a client computer can reference and\/or execute.","A request can be received from a third-party server for the development library file (step ). In response, the development library file can be sent to the third-party server (step ) (e.g., the development library FLASH file  being sent fro the FLASH library server  to the third-party server  as depicted at step A in ). The third-party server can compile the received development library file with a program file (e.g., the FLASH application file ) that references the stubs defined in the development library file. The third-party server can send the compiled program file to a client computer to be executed by a vector graphics file (e.g., a FLASH PLAYER application).","A request can be received from the client computer for the implementation library file (step ). The request may be triggered when the development library file is executed by the client computer, as discussed above with reference to . In response to the request, the implementation library file can be sent to the client computer (step ). After sending the implementation library file, the process  can end. However, the client computer can link and\/or clone the received implementation library file to the development library file to permit data types to be shared across a domain boundary within the client computer, similar to the description above with regard to .",{"@attributes":{"id":"p-0106","num":"0105"},"figref":"FIGS. 7A-B","b":["700","750","700","750","100","400","100","400","700","750","106","206","700","750"]},"The process  relates to linking a method (or objects that include the method) across a domain boundary and then making a cross-domain method call. The process  can begin at step  by receiving an application vector graphics file from a third-party server (e.g., receiving the FLASH application file  at the client computer , as depicted at step C in ). The application vector graphics file can include a development library containing stubs of methods, classes, object, events, etc. contained in an implementation library, as described above with reference to . A library file (e.g., the library FLASH file ) can be received from a library server (step ). The library file can include fully-implemented methods, classes, object, events, etc. to which the development library file within the application vector graphics file can link and invoke.","In some implementations, an implementation object (e.g., an object that is fully-implemented) can be instantiated along with a corresponding stub object (e.g., an object containing a pointer to a fully-implemented object) (step ). The implementation object can contain an implementation method and the stub object can contain a stub method. The implementation object and\/or the implementation method can be associated with a first domain and the stub object and\/or the stub method can be associated with a second domain (step )\u2014meaning they may be executed within separate environments (e.g., separated by a domain boundary).","In other implementations, an implementation method (defined separately from an object) can be associated with the first domain and a stub method (defined separately from an object) can be associated with the second domain (step ).","A link (e.g., a pointer) can be established between the implementation method and the stub method (step ) (or between the objects implementing the methods). The link can be established similar to the manner described with reference to . A call made to the stub method can be directed to the implementation method using the established link (step ). Such a directed call can traverse the domain boundary separating the stub and implementation methods, as depicted with respect to .","The directed call can pass an argument. In instances where an argument is passed, an attempt can be made to resolve the argument to an instantiated object of the appropriate data type (step ). If the argument can be resolved, then the argument is resolved to the instantiated object (step ). If the argument cannot be resolved, then an object of the data type can be instantiated (step ). The call can be processed by the implementation method using the passed argument (if resolution is not needed, such as for an argument that is passed by copy) or using the resolved or instantiated object corresponding to the argument (step ). Such processing of a call directed over a domain boundary with a resolved or instantiated object can be similar to the manner described with reference to , , and . After processing the directed call, the process  can end.","The process  relates to linking (objects) and making cross-domain method calls with a method that is inherited across a domain boundary. The process  may be similar to the description above with regard to . Similar to the steps  and  described above, an application vector graphic file and a library file can be received (steps  and ). Similar to step , a first implementation method can be associated with a first domain and a first stub method can be associated with a second domain (step ). Similar to step , a link can be established between the first stub method and the first implementation method (or between a first stub object and a first implementation object).","In addition to the first implementation method and the first stub method, the received application vector graphic file and library file can include a second implementation method and a second stub method. The second implementation method can be associated with the second domain and can inherit (e.g., extend, override, etc.) the first implementation method (step ). In response to the second implementation method inheriting the first implementation method, a second stub method can be defined to correspond to the second implementation method (step ). The second stub method can be associated with the first domain (step ). A link between the second stub method and the second implementation method can be established (step ) (or between a second stub object and a second implementation object).","Similar to the step , a call made to the second stub method can be directed to the second implementation method (the method inheriting the first implementation method) (step ). The second implementation method can process the directed call and, as part of the processing the call, can make a call to the first stub method (step ). As described above with reference to , the second implementation method may extend the first implementation method by adding instructions before and\/or after calling the first implementation method. In such instances, the second implementation method can make a call to the first implementation method when being executed.","The call made to the first stub method can be directed to the first implementation method (). The call directed to the first implementation method can then be processed by the first implementation method (). After processing the call directed to the first implementation method, the process  can end.",{"@attributes":{"id":"p-0116","num":"0115"},"figref":"FIG. 8","b":["800","800","800","800"]},"The system  includes a processor , a memory , a storage device , and an input\/output device . Each of the components , , , and  are interconnected using a system bus . The processor  is capable of processing instructions for execution within the system . The processor may be designed using any of a number of architectures. For example, the processor  may be a CISC (Complex Instruction Set Computers) processor, a RISC (Reduced Instruction Set Computer) processor, or a MISC (Minimal Instruction Set Computer) processor.","In one implementation, the processor  is a single-threaded processor. In another implementation, the processor  is a multi-threaded processor. The processor  is capable of processing instructions stored in the memory  or on the storage device  to display graphical information for a user interface on the input\/output device .","The memory  stores information within the system . In one implementation, the memory  is a computer-readable medium. In one implementation, the memory  is a volatile memory unit. In another implementation, the memory  is a non-volatile memory unit.","The storage device  is capable of providing mass storage for the system . In one implementation, the storage device  is a computer-readable medium. In various different implementations, the storage device  may be a floppy disk device, a hard disk device, an optical disk device, or a tape device.","The input\/output device  provides input\/output operations for the system . In one implementation, the input\/output device  includes a keyboard and\/or pointing device. In another implementation, the input\/output device  includes a display unit for displaying graphical user interfaces.","The features described can be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. The apparatus can be implemented in a computer program product tangibly embodied in an information carrier, e.g., in a machine-readable storage device for execution by a programmable processor; and method steps can be performed by a programmable processor executing a program of instructions to perform functions of the described implementations by operating on input data and generating output. The described features can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from, and to transmit data and instructions to, a data storage system, at least one input device, and at least one output device. A computer program is a set of instructions that can be used, directly or indirectly, in a computer to perform a certain activity or bring about a certain result. A computer program can be written in any form of programming language, including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.","Suitable processors for the execution of a program of instructions include, by way of example, both general and special purpose microprocessors, and the sole processor or one of multiple processors of any kind of computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Generally, a computer will also include, or be operatively coupled to communicate with, one or more mass storage devices for storing data files; such devices include magnetic disks, such as internal hard disks and removable disks; magneto-optical disks; and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, such as EPROM, EEPROM, and FLASH memory devices; magnetic disks such as internal hard disks and removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, ASICs (application-specific integrated circuits).","To provide for interaction with a user, the features can be implemented on a computer having a display device such as a CRT (cathode ray tube) or LCD (liquid crystal display) monitor for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball by which the user can provide input to the computer.","The features can be implemented in a computer system that includes a back-end component, such as a data server, or that includes a middleware component, such as an application server or an Internet server, or that includes a front-end component, such as a client computer having a graphical user interface or an Internet browser, or any combination of them. The components of the system can be connected by any form or medium of digital data communication such as a communication network. Examples of communication networks include a local area network (\u201cLAN\u201d), a wide area network (\u201cWAN\u201d), peer-to-peer networks (having ad-hoc or static members), grid computing infrastructures, and the Internet.","The computer system can include clients and servers. A client and server are generally remote from each other and typically interact through a network, such as the described one. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","Although a few implementations have been described in detail above, other modifications are possible. For example, although the examples have been stated mainly in relation to FLASH technology, the mechanisms described here could be used, in appropriate circumstances, with SILVERLIGHT. Moreover, other mechanisms for enabling cross-domain data type sharing may be used. Additionally, other mechanism for performing cross-domain linking and\/or cloning may be used. In addition, the logic flows depicted in the figures do not require the particular order shown, or sequential order, to achieve desirable results. Other steps may be provided, or steps may be eliminated, from the described flows, and other components may be added to, or removed from, the described systems. Accordingly, other implementations are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIGS. 7A-B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
