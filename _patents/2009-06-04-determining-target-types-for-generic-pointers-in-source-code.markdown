---
title: Determining target types for generic pointers in source code
abstract: A system described herein includes a receiver component that receives source code from a computer-readable medium of a computing device and a static analysis component that executes a points-to analysis algorithm over the source code to cause generation of a points-to graph, wherein the points-to graph is a directed graph that comprises a plurality of nodes and a plurality of edges, wherein nodes of the points-to graph represent pointers in the source code and edges represent inclusion relationships in the source code. The system also includes an inference component that infers target types for generic pointers in the source code based at least in part upon known type definitions and global variables in the source code.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09329845&OS=09329845&RS=09329845
owner: Microsoft Technology Licensing, LLC
number: 09329845
owner_city: Redmond
owner_country: US
publication_date: 20090604
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["In the recent past, computing devices have transformed from relatively expensive, low functionality machines to relatively inexpensive machines that can perform a variety of functions including browse the Internet, manage finances, generate documents, perform complex mathematical computations, etc. To allow for such functionality in modern computing devices, processors can be configured to execute relatively complex code. In an example, source code pertaining to a kernel of an operating system may be thousands or millions of lines of code, wherein such code can include generic pointers. Use of generic pointers in code renders it difficult to ascertain a type of a data object pointed to by such generic pointer.","Pursuant to an example, modern operating systems are vulnerable to various types of attacks. For instance, kernel mode malware represents a significant threat because of an ability to compromise the security of the kernel and thus an entirety of a software stack. For instance, kernel mode malware can tamper with kernel code and data to hide itself and collect useful information from certain system events (e.g., keystrokes). To mitigate the security threat, integrity of the kernel code in its entirety and data corresponding thereto should be verified. It is, however, relatively difficult to check integrity of dynamic data corresponding to the kernel of the operating system due to unpredictable memory locations of the dynamic data and constantly changing nature.","Locating dynamic kernel objects in memory in a computing system and identifying types of such objects is a first step toward enabling systematic integrity checks of dynamic kernel data. For example, to locate a dynamic data object, a reference to such object must be found which is often in the form of a pointer. In conventional systems that are configured to traverse memory of the computing system and follow pointer references to determine types of data objects, generic pointers are unable to be followed because such systems leverage type definitions only, and thus cannot ascertain target data object types of generic pointers.","The following is a brief summary of subject matter that is described in greater detail herein. This summary is not intended to be limiting as to the scope of the claims.","Various technologies pertaining to determining\/inferring types of data objects pointed to by generic pointers in source code are described herein. For example, the technologies described herein may be sufficiently robust as to allow source code pertaining to a kernel of an operating system to be analyzed such that target data object types corresponding to generic pointers in the source code of the kernel can be ascertained.","Pursuant to an example, source code for a program or operating system can be received and a static analysis can be undertaken with respect to such source code. For instance, an inter-procedural inclusion-based points-to analysis can be undertaken to generate a points-to graph (also referred to as a points-to analysis graph). A points-to graph is a graph that includes a plurality of nodes and a plurality of edges, where the nodes are representative of pointers existent in the source code and edges are representative of inclusion relationships pertaining to the pointers in the source code. For example, an edge from node X to node Y in the points-to graph can indicate that any object pointers that can be derived from the pointer represented by node X are also derivable from the pointer represented by node Y. Additionally, pursuant to an example, the generated points-to graph can be maintained as a pre-transitive graph (e.g., the points-to graph is not transitively closed).","The pre-transitive points-to graph may then be analyzed to infer candidate target data object types for generic pointers (such as void pointers). Specifically, generic pointers are pointers whose target data object types cannot be extracted from definitions of such data object types. Generic pointers can include void pointers, pointers defined inside linked list related structures that are nested inside objects, or other pointers whose target data object types cannot be extracted from their definitions.","Based at least in part upon the points-to graph and inferred candidate target data object types for generic pointers, a type graph can be generated. The type graph is a directed graph where each node in the graph is either a data object type or a global variable, and each edge connects two nodes with a label of (m, n). The label indicates that a pointer field at offset m in the source node points to the target node at offset n. It is to be noted that such a type graph includes edges corresponding to generic pointer fields that cannot be derived from only data object type definitions.","This type graph may then be used to perform a memory analysis by using such type graph to traverse a snapshot of kernel memory. Such a memory analysis can be used in connection with locating memory leaks corresponding to an operating system, to locate malware executing in an operating system, amongst other applications.","Other aspects will be appreciated upon reading and understanding the attached figures and description.","Various technologies pertaining to inferring target data object types for generic pointers in source code will now be described with reference to the drawings, where like reference numerals represent like elements throughout. In addition, several functional block diagrams of example systems are illustrated and described herein for purposes of explanation; however, it is to be understood that functionality that is described as being carried out by certain system components may be performed by multiple components. Similarly, for instance, a component may be configured to perform functionality that is described as being carried out by multiple components.","With reference to , an example system  that facilitates determining target data object types for generic pointers in source code is illustrated. The system  includes a data repository  that comprises source code . For example, the source code may be source code for an operating system kernel. Thus, the source code  may be thousands or millions of lines of code. In another example, the source code  may pertain to a word processing program. In still another example, the source code  may be configured in connection with supporting an application programming interface. Accordingly, the source code  may be for any suitable program\/operating system, etc.","The system  also includes a receiver component  that receives the source code  from the data repository . It is to be understood that the data repository  may be a hard drive, may be memory or any other suitable computer readable medium of a computing device. A static analysis component  is in communication with the receiver component . The static analysis component  can be configured to execute a points-to analysis algorithm over the source code . Executing such an algorithm over the source code  can cause the static analysis component  to generate and output a points-to graph. For instance, the points-to graph can be a directed graph that comprises a plurality of nodes and a plurality of directed edges that couple nodes in the directed graph. Furthermore, nodes in the points-to graph can represent pointers in the source code and edges in the points-to graph can represent inclusion relationships in the source code . For example, an inclusion relationship can refer to a property such that an edge from a first node in the points-to graph that represents a pointer to a second node in the points-to graph that represents a second pointer indicates that any object pointers that can be derived from the second pointer are also derivable from the first pointer. Furthermore, the points-to graph may be a pre-transitive graph (e.g., the points-to graph is not transitively closed).","The system  further comprises an inference component  that can infer target data object types for generic pointers in the source code  based at least in part upon the points-to graph output by the static analysis component  and known data object type definitions and global variables in the source code  (obtained from a compiler, for instance). Pursuant to an example, generic pointers can refer to pointers whose target data object types cannot be extracted from definitions corresponding to such pointers. Thus, for instance, a generic pointer may be a void pointer and\/or a pointer defined inside a link list related structure that is nested inside a data object.","Pursuant to an example, the inference component  can receive the points-to graph and the known data object type definitions and global variables and generate a type graph, wherein the type graph is based at least in part upon target data object types for the generic pointers in the source code  ascertained by the inference component . For example, the type graph generated by the inference component  can be a directed graph that includes a plurality of nodes and edges that connect nodes. For instance, the type graph can be a directed graph and each edge in the type graph can be labeled to indicate offsets pertaining to data object types and\/or global variables represented by nodes corresponding to the edge. In more detail with respect to the type graph, such type graph can include nodes that represent data object types and\/or global variables and directed edges between such nodes can be labeled with a label of (m, n). This means that a pointer field at an offset m in the data object type or global variable represented by a source node points to a data object type or global variable represented by a target node at offset n. It is to be understood that the type graph generated by the inference component  can include edges corresponding to generic pointer fields which do not exist in a type graph derived solely from type definitions in the source code .","The type graph generated by the inference component  can be used in connection with performing a memory analysis. For instance, a memory snapshot can be generated and the type graph can be utilized to traverse the memory corresponding to the source code  (e.g., the kernel memory). Based upon such traversal an object graph can be generated, wherein nodes are instances of objects in the memory snapshot and edges are pointers connecting these objects. Data integrity checks may then be performed based at least in part upon the object graph.","In an example operation of the system , the receiver component  can receive the source code  which may be for an operating system kernel and written in C or C++ programming language. The static analysis component  can compute a set of logical objects that each pointer in the source code  may point to (referred to as the points-to set for that pointer). Such logical objects can include local and global variables as well as dynamically allocated objects. The points-to algorithm executed by the static analysis component  can be field sensitive and context sensitive. Field sensitive refers to distinguishing fields inside an object while context sensitive refers to distinguishing calling context pertaining to objects. Context-sensitivity can be enforced by checking if a sequence of call\/return operations in the source code is valid. An example set of rules that can be employed by the static analysis component  in connection with executing the points-to analysis algorithm is described in greater detail below. As noted above, the inference component  can receive the points-to graph output by the static analysis component  and can infer candidate data object target types for generic pointers. The inference component  may then generate a type graph based at least in part upon the inferred candidate data object target types and data object type definitions and global variables in the source code . The type graph output by the inference component  may include at least three sets of information: 1) object type definitions; 2) declared types and relative addresses of global variables; and 3) candidate target types for generic pointers. Sets if information  and  can be retrieved from a compiler. Determining target data object types for generic pointers is described in greater detail below.","With reference now to , an example system  that facilitates performing a memory analysis on a type graph is illustrated. The system  includes the inference component  that outputs a type graph, wherein the type graph includes a plurality of nodes that represent data types or global variables and a plurality of edges that connect a subset of the nodes in the type graph. As noted above, the type graph includes three sets of information: object type definitions, declared types and relative addresses of global variables and candidate target data object types for generic pointers.","The system  further includes a memory  of a computing device. A memory analyzer component  can receive a snapshot of the memory . The memory analyzer component  may perform an analysis with respect to the memory  by traversing such memory through utilization of the type graph and output an object graph upon traversing the memory. The object graph output by the memory analyzer component  can include a plurality of nodes and a plurality of edges that can connect nodes in the object graph. A node in the object graph can represent instances of objects in the memory snapshot and edges in the object graph can represent pointers connecting such objects. Integrity checks such as kernel data integrity checks may be performed based at least in part upon the object graph. For instance, memory leaks in connection with an operating system can be located through utilization of the object graph.","Now referring to , an example depiction of the static analysis component  is illustrated. As described above, the static analysis component  can receive source code and generate a points-to graph pertaining to the source code. The static analysis component  can compute a set of logical data objects that each pointer in the source code may point to (referred to as the points-to set for that pointer). The logical data objects include local and global variables as well as dynamically allocated variables. As noted above, an analysis performed by the static analysis component  can be both field sensitive and context sensitive. This is in contrast to field-based analysis where all instances of a field are treated as one variable. In field-sensitive analysis, each field instance is treated separately and thus field-sensitive analysis is more precise. The static analysis component  uses a plurality of rules in connection with performing a field sensitive and context sensitive analysis with respect to generating the points-to graph. For example, for utilization of temporary variables, pointer assignments can be transformed into four canonical forms: x=y, x=&y, *x=y, and x=*y. To handle pointer offsets, the first two assignment forms as shown in the static analysis component  can be x=y+n and x=&y+n, where n is the pointer offset. To enable context sensitivity, each assignment can have a variable op that specifies the call or return operation involved in the assignment. It can be ascertained that op is null when the assignment occurs inside a single function. Without use of the offset n and the variable op, an edge in the points-to graph can be a pair (src, dst) and four deduction rules can be used to compute the points-to graph. To consider pointer offsets and culling context changes, semantics of edges in the points-to graph can be a four tuple (src, dst, n, ops).","Turning briefly to , for instance given the pointer assignment _Entry=t286, due to the function call at line  the corresponding edge in the points-to graph generated by the static analysis component  can be (_Entry, t286, 0, call @file: 25).","As the semantics of edges can be enhanced, the deduction rules shown in the static analysis component  can be employed. In the Assign rule, the pointer offset n can be placed in the four tuple of the edge. In the Trans rule, the pointer offset can be summed. In the Star rules, a node z.n can be created to represent an instance of the pointer field at offset n in logical object z in connection with achieving field sensitivity. Furthermore, when a new edge is created, the sequence of call return operations involved is checked to ensure such sequence of call return operations is valid to achieve context sensitivity. A sequence is valid if it can be instantiated from a valid call path. It can also be noted that an assumption can be made that there are no recursive functions in the source code. Thus, a valid call path has at most a single call at each call site. Moreover, special rules need not be applied to global variables since a single node for each global variable is created disregarding the function context corresponding thereto. Thus, information can flow through global variables between different functions.","As noted above, the points-to graph can be a pre-transitive graph. Example pseudo code for computing such pre-transitive graph is shown below.",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"1: PointsTo(x, prev_n, prev_ops, curr_n, curr_ops) {"]},{"entry":[{},"2: if (!isValidCallPath(prev_ops + ops)) {"]},{"entry":[{},"3: \u2003\u2003\u2002\/\/ invalide control flow"]},{"entry":[{},"4: \u2003\u2003\u2002return emptySet;"]},{"entry":[{},"5: } else if (onPath(x)) { \/\/ a cycle"]},{"entry":[{},"6: \u2003\u2003\u2002return (emptySet);"]},{"entry":[{},"7: } else {"]},{"entry":[{},"8: \u2003\u2003\u2002onPath(x) = 1; \/* put the node on path *\/"]},{"entry":[{},"9: \u2003\u2003\u2002prev_n = prev_n + curr_n; \/\/ adjust pointer"]},{"entry":[{},"\u2003\u2009 \u2003\u2003shift"]},{"entry":[{},"10: \u2003\u2003prev_ops = curr_ops + prev_ops; \/\/ merge ops"]},{"entry":[{},"11: \u2003\u2003ptSet = emptySet;"]},{"entry":[{},"12: \u2003\u2003for each <&z, n, ops> in x.baseElements {"]},{"entry":[{},"13: \u2003\u2003\/\/ visit each &z"]},{"entry":[{},"14: \u2003\u2003\u2003\u2003if (isValidCallPath(prev_ops + ops)) {"]},{"entry":[{},"15: \u2003\u2003\u2003\u2003\/\/ a valid control flow"]},{"entry":[{},"16: \u2003\u2003\u2003\u2003ptSet.Add(<&z, prev_n+n, prev_ops+ops>);"]},{"entry":[{},"17: \u2003\u2003\u2003\u2003}"]},{"entry":[{},"18: \u2003\u2003}"]},{"entry":[{},"19: \u2003\u2003for each <z, n, ops> in x.edges {"]},{"entry":[{},"20: \u2003\u2003\u2003\u2003\/\/ continue the search of points-to on"]},{"entry":[{},"\u2003\u2009 \u2003\u2003\u2003\u2003each edge"]},{"entry":[{},"21: \u2003\u2003\u2003\u2003ptSet.Add("]},{"entry":[{},"22: \u2003\u2003\u2003\u2003PointsTo(z, prev_n, prev_ops, n, ops));"]},{"entry":[{},"23: \u2003\u2003}"]},{"entry":[{},"24: \u2003\u2003onPath(x) = 0; \/\/ remove from the path"]},{"entry":[{},"25: \u2003\u2003return ptSet;"]},{"entry":[{},"26: \u2002}"]},{"entry":[{},"27: }"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"It is to be noted that in the above pseudo code, context sensitivity can be enforced by checking if a sequence of call\/return operations is valid. Further, when a cycle is found, path traversals can be terminated.","Referring now to , example source code  of a function is illustrated, wherein such source code will be used in connection with describing operations of the inference component .",{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 5","FIG. 4","FIG. 5","FIG. 4"],"b":["500","400","400"]},"With reference now to , an example graph  that is a combination of a points-to graph and a type graph that is based upon the source code of , is illustrated. Nodes shown as ellipse nodes and solid arrows are included in the points-to graph. Rectangular nodes and thicker arrows are part of the type graph. Dashed arrows are derived from type definitions of variables. As will be shown below, the graph  can be used in connection with deriving\/inferring candidate target data object types for generic pointers by leveraging type definitions of local and global variables.","The points-to graph  includes a plurality of nodes - that represent pointers in the source code  of . Specifically, a first node  represents the pointer _WrapData, a second node  represents the pointer data, a third node  represents the pointer _txt_data, and a fourth node  represents the pointer _bin_data. Furthermore, the points-to graph  includes a fifth node  that represents a pointer t284 in the medium level intermediate representation of the example InsertWrapList function of the source code of . The points-to graph also includes nodes sixth, seventh, and eighth nodes , , and , respectively, that represent data object types in the example source code . Specifically, the sixth node  represents WRAP_DATA, the seventh node  represents TXT_DATA, and the eighth node  represents BIN_DATA. It can be ascertained that the data object types each comprise at least one field.","The points-to graph  further includes an edge  between the node fifth node  and the first node  with pointer offset . Another edge  connects the first node  and the sixth node. Based on the type definitions it can be understood that _wrapdata points to WRAP_DATA. The third node , which represents _bin_data, is coupled to the eighth node  by way of an edge  which indicates that _bin_data points to a particular field in BIN_DATA. The third node  representing _txt_data is coupled to the seventh node  that represents TXT_DATA by way of an edge , thereby indicating that _txt_data points to the TxtData field of TXT_DATA. Moreover, edges  and  indicate that a pointer represented by the second node  points to pointers represented by the third and fourth nodes  and , respectively, with an offset of zero.","Given an assignment *t284=_data, it can be inferred that WRAP_DATA+8, which is WRAP_DATA.PData, may point to either BIN_DATA or TEXT_DATA. Thus, although a pointer like _WrapData may not point to any logical object, a type definition corresponding to _WrapData can be leveraged to derive target data object types for WRAP_DATA.PData. Furthermore, with pointer offsets in the points-to graph , it can be identified that WRAP_DATA.List does not just point to an SLIST_ENTRY object but actually a WRAP_DATA object.","Referring now to , an example type graph  that can be output by the inference component  () based upon the example source code shown in  is illustrated. The example type graph  includes a first node  representing WrapDataListHead, which is a global variable, a second node  that represents a data object type WRAP_DATA, a third node  that represents a data object type BIN_DATA, and a fourth node  represents an object data type TXT_Data. Fields ,  and  corresponding to the second node  are included in such second node . Additionally, the third node  includes two fields  and  and the fourth node  includes one field . An edge  indicates that a pointer field corresponding to the node  points to the field  in the node . An edge  indicates that a pointer field in the field  points back to the field . Additionally, pointer fields in the field  of the second node  can point to the field  of the node  and the field  of the node  as indicated by edges  and . As described above, the edges can have labels that indicate at what offset m the source node points to the target node at offset n.","The inference component  can generate such a type graph  as follows: for each assignment in the form *x=y, all reachable nodes in the pre-transitive graph can be searched for x and y separately (e.g., the points-to graph such as the points-to graph  of ). These reachable nodes can be referred to as target set x and target set y, respectively. Then for each node a in target set x and each node b in target set y, a determination can be made to insure that a valid call path exists from a to b. If a valid call path exists, a candidate target data object type can be derived for a pointer field in the data type of a. Similarly, candidate types can be derived from assignments of the form x=*y. For example, when y is a generic pointer such as void*, such pointer will be cast back to its actual type before the program accesses the data pointed to by the pointer. Specifically, for each assignment, nodes that can reach x can be searched for which can be referred to as source set x. Thereafter, for each node a in source set x, and each node b in target set y, a determination can be made regarding whether there is a valid call path from a to b. If a valid call path exists, a candidate type for a pointer field in a data type of a can be derived\/inferred.","To increase precision, a constraint can be introduced when deriving candidate types for generic pointers and linked list constructs. For example, a pointer field in SLIST_ENTRY should point to an SLIST_ENTRY structure. Such a constraint can reduce a number of incorrect candidate target types and therefore reduce possibility of errors in memory analysis.","With reference now to , various example methodologies are illustrated and described. While the methodologies are described as being a series of acts that are performed in a sequence, it is to be understood that the methodologies are not limited by the order of the sequence. For instance, some acts may occur in a different order than what is described herein. In addition, an act may occur concurrently with another act. Furthermore, in some instances, not all acts may be required to implement a methodology described herein.","Moreover, the acts described herein may be computer-executable instructions that can be implemented by one or more processors and\/or stored on a computer-readable medium or media. The computer-executable instructions may include a routine, a sub-routine, programs, a thread of execution, and\/or the like. Still further, results of acts of the methodologies may be stored in a computer-readable medium, displayed on a display device, and\/or the like.","Referring now to , a methodology  that facilitates inferring target data object types for generic pointers in source code is illustrated. The methodology  begins at , and at  source code is received. For instance, the source code can be source code for an operating system kernel that is contained in a computer readable medium of a computing device. In another example the source code can be written in C\/C++ programming language.","At , a points-to graph is generated based at least in part upon execution of a points-to analysis algorithm over the source code received at . As noted above, the points-to graph can be a directed graph that comprises a plurality of nodes and a plurality of edges, wherein nodes of the points-to graph represent pointers in the source code and edges represent inclusion relationships in the source code. Pursuant to an example, the points-to graph can be generated based at least in part upon rules shown in .","At , target data object types for generic pointers in the source code can be inferred based at least in part upon the points-to graph. At , the target types for the generic pointers in the source code are caused to be stored in the computer readable medium. As noted above, these target data object types for generic pointers can be used in connection with generating a type graph. The type graph can be a directed graph where nodes represent data types or global variables and edges represent relationships between the data types or global variables connected thereby. Furthermore, each edge in the type graph can be labeled to indicate offsets pertaining to data types and\/or global variables connected by an edge. For instance, a first edge in the type graph can couple a first node that represents a first data type or global variable to a second node that represents a second data type or global variable. The first edge can be labeled with a first value and a second value, wherein the first value indicates that a pointer field at a first offset in the first data type or global variable points to the second data type or global variable at a second offset.","The type graph can also include object type definitions, declared types and relative addresses of global variables and candidate target types for generic pointers. Furthermore, with respect to act , the points-to analysis algorithm used to generate the points-to graph can be a field sensitive algorithm as well as a context sensitive algorithm, wherein context sensitivity can be enforced by checking if a sequence of call return operations in the source code is valid. The methodology  completes at .","Referring now to , a methodology  that facilitates determining candidate types for generic pointers in source code is illustrated. The methodology  starts at , and at  source code of an operating system kernel is received. For example, a data repository can be accessed to retrieve the source code of the operating system kernel.","At , a field sensitive and context sensitive points-to algorithm is executed over the source code to generate a points-to graph. As described above, the points-to graph can be a directed graph that includes a plurality of nodes and a plurality of edges, wherein the plurality of nodes represent pointers in the source code and the plurality of edges represent inclusion relationship between pointers. Furthermore, the points-to graph can be intransitive (pre-transitive).","At , candidate target types of generic pointers in the source code are determined, where generic pointers are pointers whose target types are unextractable from definitions corresponding to the pointers and wherein the determined candidate target types of the generic pointers are determined based at least in part upon the points-to graph. The methodology  completes at .","Now referring to , a high-level illustration of an example computing device  that can be used in accordance with the systems and methodologies disclosed herein is illustrated. For instance, the computing device  may be used in a system that supports inferring\/determining data object types with respect to generic pointers in source code. In another example, at least a portion of the computing device  may be used in a system that supports generating a type graph. The computing device  includes at least one processor  that executes instructions that are stored in a memory . The instructions may be, for instance, instructions for implementing functionality described as being carried out by one or more components discussed above or instructions for implementing one or more of the methods described above. The processor  may access the memory  by way of a system bus . In addition to storing executable instructions, the memory  may also store source code, type graphs, points-to graphs, etc.","The computing device  additionally includes a data store  that is accessible by the processor  by way of the system bus . The data store  may include executable instructions, source code, a points-to graph, a points-to analysis algorithm, etc. The computing device  also includes an input interface  that allows external devices to communicate with the computing device . For instance, the input interface  may be used to receive instructions from an external computer device, from an individual, etc. The computing device  also includes an output interface  that interfaces the computing device  with one or more external devices. For example, the computing device  may display text, images, etc. by way of the output interface .","Additionally, while illustrated as a single system, it is to be understood that the computing device  may be a distributed system. Thus, for instance, several devices may be in communication by way of a network connection and may collectively perform tasks described as being performed by the computing device .","As used herein, the terms \u201ccomponent\u201d and \u201csystem\u201d are intended to encompass hardware, software, or a combination of hardware and software. Thus, for example, a system or component may be a process, a process executing on a processor, or a processor. Additionally, a component or system may be localized on a single device or distributed across several devices.","It is noted that several examples have been provided for purposes of explanation. These examples are not to be construed as limiting the hereto-appended claims. Additionally, it may be recognized that the examples provided herein may be permutated while still falling under the scope of the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 7","FIGS. 4 and 5"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
