---
title: Compositional query comprehensions
abstract: The claimed subject matter relates to an architecture that can facilitate query comprehension that are constructed in a compositional manner. In accordance therewith, the query comprehensions can be assembled together in virtually in order without common requirements that force query operators of a query expression to follow ordering/syntactic rules. In addition, the architecture can provide for query expressions that arbitrarily composable and which can be terminated at any point. If the query expression terminates without a Select or Return clause at the end, the architecture can facilitate generation of an implicit Select or Return, and output results.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07865533&OS=07865533&RS=07865533
owner: Microsoft Corporation
number: 07865533
owner_city: Redmond
owner_country: US
publication_date: 20070205
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application is related to co-pending U.S. application Ser. No. 11\/671414 (MSFTP1549US), filed Feb. 5, 2007, entitled \u201cQUERY PATTERN TO ENABLE TYPE FLOW OF ELEMENT TYPES.\u201d The entirety of this application is incorporated herein by reference.","In the domain of computer languages that support query operations, there have traditionally been two distinct approaches. According to one approach query comprehensions can be employed and according the an alternative approach method calls to an Application Programming Interface (API) can be utilized. One of the benefits of calling an API directly is that an associated query expression can be more composable in the sense that a user can piece together query clauses and\/or small independent queries into larger queries. Unfortunately, one difficulty with using the underlying API in conventional frameworks is that users of this approach are forced to pass in delegates and\/or lambda expressions in order to introduce new variables in scope.","In contrast conventional languages with query support that employ comprehensions or query expressions is that the comprehensions can be utilized to introduce a scope for control variables that can potentially span over several clauses of the query. While this can provide for an advantage over using API calls, there exist associated disadvantages to this approach as well. For example, in many languages that support query comprehensions such as Structure Query Language (SQL), XQuery, Haskell, etc., the comprehensions ubiquitously exist as monolithic constructs. Thus, the comprehensions are inherently less composable, and users cannot, e.g., arbitrarily stitch together larger queries from smaller ones","Standard varieties of SQL represent primary examples of non-compositional languages that impose many restrictions on how and where queries can be nested inside other queries and how queries can be stacked together. The basic syntax of an SQL query is: Select, From, Where, Groupby, Having, OrderBy, from which the user is largely restricted from introducing additional query operators and\/or in different orders. These and other monolithic constructs allow for very little flexibility in, for instance, placing another From clause after the Where clause, or when nesting queries inside the Select clause. Another example is XQuery that utilizes the For, Let, Where, Order By, Return (FLWOR), which suffers from similar shortcomings.","The following presents a simplified summary of the claimed subject matter in order to provide a basic understanding of some aspects of the claimed subject matter. This summary is not an extensive overview of the claimed subject matter. It is intended to neither identify key or critical elements of the claimed subject matter nor delineate the scope of the claimed subject matter. Its sole purpose is to present some concepts of the claimed subject matter in a simplified form as a prelude to the more detailed description that is presented later.","The subject matter disclosed and claimed herein, in one aspect thereof, comprises computer-implemented techniques for evaluating query expressions with query comprehensions constructed in a compositional manner. In accordance therewith, the claimed subject matter can unite various beneficial aspects of two heretofore disparate approaches. Namely, the claimed subject matter can facilitate a more composable query expression that can allow assembly and nesting of query clauses in a modular fashion; and, moreover, the claimed subject matter can further do so with wide scoping rules generally associated with query comprehensions.","To the accomplishment thereof, all or portions of a query comprehension can introduce new control variables, hide existing control variables, and\/or use the existing control variables. In accordance with an aspect of the claimed subject matter at any point in a query expression virtually any query operator can be employed, irrespective of the type of the previous query operator or some monolithic syntax template. Moreover, after any given query clause, a query expression can be terminated, whereby the, e.g., compiler or other similar component can insert an implicit Select or Return clause to automatically finish the query expression and output results of the query. It is to be appreciated that format for the results can vary depending on the number of control variables in scope when the implicit clause is appended. For example, if only one control variable is in scope, the underlying values of a collection can be returned. However, if two or more control variables are in scope, the output can be structured as a collection of tuples.","The following description and the annexed drawings set forth in detail certain illustrative aspects of the claimed subject matter. These aspects are indicative, however, of but a few of the various ways in which the principles of the claimed subject matter may be employed and the claimed subject matter is intended to include all such aspects and their equivalents. Other advantages and distinguishing features of the claimed subject matter will become apparent from the following detailed description of the claimed subject matter when considered in conjunction with the drawings.","The claimed subject matter is now described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the claimed subject matter. It may be evident, however, that the claimed subject matter may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to facilitate describing the claimed subject matter.","As used in this application, the terms \u201ccomponent,\u201d \u201cmodule,\u201d \u201csystem\u201d, \u201cinterface\u201d, or the like are generally intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a controller and the controller can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers. As another example, an interface can include I\/O components as well as associated processor, application, and\/or API components, and can be as simple as a command line or a more complex Integrated Development Environment (IDE).","Furthermore, the claimed subject matter may be implemented as a method, apparatus, or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof to control a computer to implement the disclosed subject matter. The term \u201carticle of manufacture\u201d as used herein is intended to encompass a computer program accessible from any computer-readable device, carrier, or media. For example, computer readable media can include but are not limited to magnetic storage devices (e.g., hard disk, floppy disk, magnetic strips . . . ), optical disks (e.g., compact disk (CD), digital versatile disk (DVD . . . ), smart cards, and flash memory devices (e.g., card, stick, key drive . . . ). Additionally it should be appreciated that a carrier wave can be employed to carry computer-readable electronic data such as those used in transmitting and receiving electronic mail or in accessing a network such as the Internet or a local area network (LAN). Of course, those skilled in the art will recognize many modifications may be made to this configuration without departing from the scope or spirit of the claimed subject matter.","Moreover, the word \u201cexemplary\u201d is used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as preferred or advantageous over other aspects or designs. Rather, use of the word exemplary is intended to present concepts in a concrete fashion. As used in this application, the term \u201cor\u201d is intended to mean an inclusive \u201cor\u201d rather than an exclusive \u201cor\u201d. That is, unless specified otherwise, or clear from context, \u201cX employs A or B\u201d is intended to mean any of the natural inclusive permutations. That is, if X employs A; X employs B; or X employs both A and B, then \u201cX employs A or B\u201d is satisfied under any of the foregoing instances. In addition, the articles \u201ca\u201d and \u201can\u201d as used in this application and the appended claims should generally be construed to mean \u201cone or more\u201d unless specified otherwise or clear from context to be directed to a singular form.","As used herein, the terms to \u201cinfer\u201d or \u201cinference\u201d refer generally to the process of reasoning about or inferring states of the system, environment, and\/or user from a set of observations as captured via events and\/or data. Inference can be employed to identify a specific context or action, or can generate a probability distribution over states, for example. The inference can be probabilistic\u2014that is, the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher-level events from a set of events and\/or data. Such inference results in the construction of new events or actions from a set of observed events and\/or stored event data, whether or not the events are correlated in close temporal proximity, and whether the events and data come from one or several event and data sources.","Referring now to the drawing, with reference initially to , a computer-implemented system  that can employ query patterns to facilitate type flow of element types is depicted. Generally, the system  can include a user-interface  that can be operatively coupled to well-known computer-based hardware (e.g., controllers), software (e.g., applications), as well as other components described herein. The user-interface  can receive a query expression , which can include a first query clause and one or more next query clause(s). It is to be appreciated that the first query clause can include a queryable source type (e.g., a collection, a stream, etc.) as well as an element type that can be introduced by the first query clause as, for example, a control variable in connection with the source type. Typically, all query clauses include a query operator, however, as will be seen, the next query clauses of the query expression  need not be complete, but rather can be received incrementally in portions, such as while the clause is being input by a user. Query expression  and related subcomponents are described in more detail infra in connection with .","The system  can also include a query operator pattern  for any valid query operator (e.g., query operators associated with the first query clause and subsequent next query clauses). Accordingly, any number of query operator patterns  can exist in, for example, a pattern store  that can be operatively coupled to the system . In particular, the query clauses (e.g., each with a specific query operator) from the query expression  can conform to associated query operator patterns , which can define, e.g., accessible instance methods. By conforming to the query operator pattern , it can be substantially guaranteed that there is a known relationship between one query clause and the next query clause, and therefore a relationship from one query operator to the next query operator. The query operator patterns  are described in more detail in connection with .","It should be understood that by placing constraints on the query expression  such that the operators of the query expression  conform to the query operator patterns , the system  can ensure type flow of element types from one query clause\/operator of the query expression  to the next query clause\/operator. Further, by ensuring that the element types flow as described herein, certain advantageous type inferences and\/or contextual determinations can be effectuated on the fly without the need for conventional translation\/compilation of the query expression , as discussed in more detail with reference to . Moreover, the aforementioned inferences and\/or determinations can be provided before the query expression  is complete and even when the query expression  is malformed. By way of further explanation but not limitation, an example query expression  that conforms to the query operator patterns  and some of the advantages associated with this schematization are described in more detail below.","While still referring to , but turning also to , an exemplary query expression  is illustrated. Generally, the query expression  can be an expression that applies a series of query operators to a particular collection. A query operator is an operator (e.g., FROM, WHERE, SELECT . . . that can be applied to a collection of values across the entire collection at once. The query expression  can include a first query clause  and any number of next query clauses , , etc, each of which contains one of the query operators.","While many other query operators can exist and are contemplated to be within the spirit and scope of the claimed subject matter, a number of concrete examples along with a brief description for each are provided infra.\n\n","The translation of query operators in a query expression  can take place in the order in which the operators occur in the query expression , from left to right. Typically, first query clause  of the query expression  includes the FROM operator, since the FROM operator introduces a collection to query over. In addition, the last query clause in the query expression  generally includes a RETURN and the SELECT operator that specifies the final shape of the collection that results from the query. It is to be appreciated, however, that the final SELECT or RETURN operator can be omitted. For example, if the query expression  does not end with a RETURN or SELECT operator, an implicit SELECT operator can be assumed, which can lift all of the control variables in scope to be a property of the returned anonymous type. Furthermore, it should be appreciated that the query expression  can continue after a SELECT operator is applied in which case the control variables accessible to subsequent operators can be limited only to those control variables in scope.","In accordance with one aspect of the claimed subject matter, the query expression  can be schematized as follows:",{"@attributes":{"id":"p-0033","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"QueryExpression ::= QueryOperatorList"]},{"entry":[{},"QueryOperatorList ::="]},{"entry":[{},"\u2003\u2003FromOperator |"]},{"entry":[{},"\u2003\u2003QueryOperatorList QueryOperator"]},{"entry":[{},"QueryOperator ::="]},{"entry":[{},"\u2003FromOperator |"]},{"entry":[{},"\u2003SelectOperator |"]},{"entry":[{},"\u2003ReturnOperator |"]},{"entry":[{},"\u2003DistinctOperator |"]},{"entry":[{},"\u2003WhereOperator |"]},{"entry":[{},"\u2003OrderByOperator |"]},{"entry":[{},"\u2003PartitionOperator |"]},{"entry":[{},"\u2003SetOperator |"]},{"entry":[{},"\u2003GroupByOperator |"]},{"entry":[{},"\u2003JoinOperator |"]},{"entry":[{},"\u2003GroupJoinOperator"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In order to provide additional context for the claimed subject matter as well as a high level overview of related programmatic implementations and\/or languages, consider the entirety of the exemplary query expression :",{"@attributes":{"id":"p-0035","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim names = "]},{"entry":[{},"\u2003From C In Customers "]},{"entry":[{},"\u2003Where C.State = \u201cWA\u201d "]},{"entry":[{},"\u2003Select C.Name"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":"104"},"It is readily apparent that the query expression  syntax can be reasonably close to standard relational Structure Query Language (SQL) syntax, with the intent that anyone familiar with SQL will be able to use query expressions  with very little further instruction. The syntax need not, however, be constrained by SQL, and, further, the query expressions  need not be a translation of SQL into another programming language. Because SQL was designed around a purely relational model, some of its idioms do not work as well in a type system that embraces notions of hierarchy. Additionally, some of the syntactic and semantics elements often employed by SQL conflict or do not integrate well with existing programming language syntax or semantics. Thus, while query expressions  can be intuitive to a user familiar with SQL, there can also be some distinctions.","For example, in SQL and in other languages such as Procedural Language\/Structured Query Language (PLSQL) queries and the results of the queries are bound by evaluating the entirety of the query. As such, there is no need to be able to interpret the element type for specific query operators that are applied. Moreover, such a determination cannot be made until the entire, error-free query is input and bound by relatively expensive translation process. In contrast, the claimed subject matter can provide for binding query expression  input and the results of the query expression  in terms of individual query operations over a particular source type. These and other advantages can be illustrated in greater depth with reference to .",{"@attributes":{"id":"p-0038","num":"0049"},"figref":"FIG. 2B","b":["104","202","206","208","210","202","212","204","204","212","214","204","204","212","204","216","212","204","104"],"sub":["1 ","1","1 ","2 "]},"In particular, query operations for each of the next query clauses  can be based upon a set of methods (e.g., query operator pattern ), each associated with a particular query operator, and which are applied to a collection or sequence (e.g., the source type). These query operators can be defined in relation to the element type (or row) of the collection. However, given a particular source type with an element type of T and the application of a query operator, the result that flows  to a next query operator  can be a collection with an element type of S. Hence, the element types that flow  can be transformed in accordance with the query operator patterns  associated with a given query operator. For example, query operator patterns  associated with projection query operators such as SELECT and RETURN generally return a different element type than the element type that received from the flow .","In the present example, an element type, T, (that can be, e.g., an aggregation of all the control variables  associated with the Customer type ) flows  to the WHERE operator  of the next query clause . As will be described in connection with , the query operator pattern  associated with the WHERE operator  can filter the values of the collection, but otherwise does not typically change the element type. Here, Customers not in the state of Washington are filtered from the collection, but the results that flow  to the next query operator, the SELECT operator , are still a collection with an element type of Customer .","On the other hand, if it is assumed that the Name property is of type String, the results of the SELECT operator  is a collection with an element type of String. The combination of supporting both the SELECT and RETURN operators for query results can provide predictable semantics of the inputs and outputs to the operators. In addition, more flexibility can be facilitated to closely mimic expected SQL semantics when interacting with relational data. Further, greater simplicity can be facilitated when producing non-tabular results, as well as improved locality of compiler errors and required changes when iteratively developing a query expression.","Additionally, as with certain query languages that can query collections of eXtensible Markup Language (XML) data (e.g., XQuery, which is a query language that includes some programming language features); the claimed subject matter can also be employed in conjunction with XML literals. For example, the following exemplary query expression  can be employed to return a collection of XML elements that include the names of all customers in Washington, similar to the results of the exemplary query expression  discussed above.",{"@attributes":{"id":"p-0043","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim names ="]},{"entry":[{},"\u2003\u2003\u2003From c In Customers"]},{"entry":[{},"\u2003\u2003\u2003Where c.State = \u201cWA\u201d"]},{"entry":[{},"\u2003\u2003\u2003Return <Name><%= c.Name %><\/Name>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"It is to be further appreciated that some query operators such as, e.g., FROM, SELECT, and GROUPBY, can introduce a special kind of local variable called a control variable (e.g., control variable C ). By default, a control variable can be scoped from the introducing operator to an operator that can hide the control variable and can represent a property or column of the individual row in a collection as the query evaluates. For example, in the following query:",{"@attributes":{"id":"p-0045","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim WACusts ="]},{"entry":[{},"\u2003\u2003\u2003From C As Customer In Customers"]},{"entry":[{},"\u2003\u2003\u2003Where C.State = \u201cWA\u201d"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"Some query operators, such as DISTINCT, need not use or change the control variables. Other query operators such as SELECT can hide the current control variables in scope and can introduce new control variables. For example, in the query:",{"@attributes":{"id":"p-0047","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim YourUncles ="]},{"entry":[{},"\u2003\u2003\u2003From C In Customers"]},{"entry":[{},"\u2003\u2003\u2003Select LastName = C.Name"]},{"entry":[{},"\u2003\u2003\u2003Where LastName.StartsWith(\u201cBo\u201d)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"With reference now to  (while still referring to ), numerous non-limiting examples of query operator patterns are provided. The query operator patterns - are concrete illustrations of the query operator pattern , and can be referred to herein individually by reference numerals - or collectively as query operator patterns . It is to be further appreciated that several of the query operator patterns  can be applicable to a plurality of query operators even though each of the plurality of query operators that relate to a single one of the query operator patterns - can have characteristics that distinguish it from others of the plurality of query operators. Moreover, in some cases a particular query operator can be employed in connection with more than one of the query operator patterns - (e.g., overloading functions).","In general, the query operator pattern  can be a method signature that a type, C, has to implement in order to be queryable. Recall that the query expression  can apply a series of query operators to a particular collection. The control variables of each of the query operators can be all or a subset of all variables in scope for the application of that particular query operator, whereas the element type, T, which can flow from one query operator to the next query operator, can be an anonymous type that is an aggregation of all the control variables in scope. Hence, the query operator pattern  can, inter alia, help ensure that a type C is a queryable type. For any given query expression , a type, C, is a queryable type if at least one of the following is true:\n\n","With reference to the query operator patterns -, query operator pattern  can include the FROM operator. Within a query expression  the FROM operator is typically employed in the first query clause. As such, the FROM pattern  can introduce the source of a query as well as the control variable to be used, and can output a queryable type with element type, T. It should be understood that prior to evaluation of the query expression, if the type of C does not satisfy the design pattern (e.g., does not conform to query operator pattern ), then the AsQueryable or AsEnumerable method can be invoked on the query expression  and the return value of the function can be stored in a temporary location.","As recited above, the FROM operator can introduce a collection that can be queried and a control variable that can represent the individual members of the collection. The query expression:",{"@attributes":{"id":"p-0052","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003From b As Book In Books . . ."]},{"entry":[{},"can be thought of as equivalent to"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003For Each b As Book In Books"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003. . ."]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Next b"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The collection expression operand generally must be classified as a value and must be a queryable type. The control variable declared by the FROM operator typically must follow the regular rules for declaring local variables with respect to naming and scoping (as implied by the above syntax translation). Thus, a control variable normally cannot hide the name of a local variable or parameter in the enclosing method.","It should be understood that a FROM operator can also introduce a control variable whose value can be determined by an expression rather than by a collection. Such a feature can be useful to, e.g., calculate a value that will be used multiple times in later query operators (e.g., calculate the value once rather than each time it is used subsequently). For example:",{"@attributes":{"id":"p-0055","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Dim TaxedBookPrices ="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From b in Books"]},{"entry":[{},"From Tax = b.Price * 0.088"]},{"entry":[{},"Where Tax > 3.50"]},{"entry":[{},"Select b.Price, Tax, Total = b.Price + Tax"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"can be thought of as equivalent to:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"For Each b in Books"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim Tax = b.Price * 0.088"]},{"entry":[{},". . ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Next b"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The syntax of the FROM operator that declares an expression control variable can be the same as a control variable declaration in a FOR LOOP, with the exception that the control variable is generally initialized through an explicit initializer. An expression control variable is not required to reference another control variable, since doing so may be of dubious value. An expression control variable usually cannot be the first control variable declared in the query expression .","For the sake of brevity and\/or convenience, the operand of the FROM operator can omit the AS clause, in which case the type of the control variable can be inferred from the collection or expression over which the variable ranges. If the type of the control variable cannot be derived from the query operator methods, a compile-time error will result. The FROM operator can be schematically defined as follows:",{"@attributes":{"id":"p-0058","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FromOperator ::="]},{"entry":[{},"\u2003\u2003\u2003From FromDeclarationList"]},{"entry":[{},"FromDeclarationList ::="]},{"entry":[{},"\u2003\u2003\u2003FromDeclaration |"]},{"entry":[{},"\u2003\u2003\u2003FromDeclarationList , FromDeclaration"]},{"entry":[{},"FromDeclaration ::="]},{"entry":[{},"\u2003\u2003\u2003VariableIdentifier [As TypeName ] In Expression |"]},{"entry":[{},"\u2003\u2003\u2003VariableDeclarator"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Additionally, while the FROM operator generally appears as the query operator for the first query clause , a query expression  can include more than one FROM operator. Accordingly, when a FROM operator is the query operator for a next query clause , then a cross-product (e.g., simple, implicit join) can result. In this case, the FROM operator can join (see JOIN operator pattern , infra) new control variable to the existing set of control variables. The result can be the cross-product of all the elements in the joined collections. So, for example, the expression",{"@attributes":{"id":"p-0060","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003From b In Books"]},{"entry":[{},"\u2003\u2003\u2003From p In Publishers"]},{"entry":[{},"\u2003\u2003\u2003. . ."]},{"entry":[{},"can be thought of as equivalent to the nested For Each loop"]},{"entry":[{},"\u2003\u2003\u2003For Each b In Books"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003For Each p In Publishers"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003. . ."]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003Next p"]},{"entry":[{},"\u2003\u2003\u2003Next b"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The control variables introduced in previous query operators can be in scope and can be used within a FROM operator that included in a next query operator . In terms of SQL, the aforementioned features can be thought of as supporting \u201ccorrelated subqueries\u201d. For example, in the following query expression, the second FROM operator refers to the value of the first control variable:",{"@attributes":{"id":"p-0062","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From c As Customer In Customers"]},{"entry":[{},"From o As Order In c.Orders"]},{"entry":[{},"Select c.Name, o"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In addition, multiple FROM operators can appear in a single query clause, in which case a comma between operands can be exactly equivalent to another FROM operator in a next query clause . Thus, the example:",{"@attributes":{"id":"p-0064","num":"0078"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003From b In Books, p In Publishers"]},{"entry":[{},"\u2003\u2003\u2003Select b, p"]},{"entry":[{},"can be equivalent to"]},{"entry":[{},"\u2003\u2003\u2003From b In Books"]},{"entry":[{},"\u2003\u2003\u2003From p In Publishers"]},{"entry":[{},"\u2003\u2003\u2003Select b, p"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Query operator pattern  can include a query operator that is an accessible instance method named SELECT or SELECTMANY, which can receive a function as an argument. The function can include an argument of type, T, and results in a type, S. The method can return a queryable type with element type, S.","The SELECT operator can describe the results of the query expression . The SELECT operator can take a list of declarations and construct an element type of the resulting collection. For example, if the query expression  is:",{"@attributes":{"id":"p-0067","num":"0081"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim CustAndOrderNames ="]},{"entry":[{},"\u2003\u2003From c In Customers, o In c.Orders"]},{"entry":[{},"\u2003\u2003Select c.Name, o.Product"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"This query (e.g., query expression ) that follows can be equivalent to explicitly returning an anonymous type:",{"@attributes":{"id":"p-0069","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim CustAndOrders ="]},{"entry":[{},"\u2003\u2003From c In Customers, o In c.Orders"]},{"entry":[{},"\u2003\u2003Return New With { c.Name, o.Product }"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"If the SELECT operator has only one declaration, the result can be an anonymous type with one property. As such the result type can be Ienumerable (Of {Name As String}) since Name is of type String. For example,",{"@attributes":{"id":"p-0071","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim CustNames ="]},{"entry":[{},"\u2003\u2003From c In Customers"]},{"entry":[{},"\u2003\u2003Select c.Name"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The expressions within the declarations used within a SELECT operator are bound before the conversion to the underlying anonymous type. More specifically, expressions within the declarations in a SELECT operator can begin a member access in which the dot operator need not bind to the control variables in the query. Rather, the dot operator can instead bind to an enclosing WITH block if one is present.","It should be appreciated that in addition to the SELECT operator, the query expression  can also include other projection operators. For example, the query expression can include a RETURN operator with which there can be an associated query operator pattern . Similar to the SELECT operator, the RETURN operator can describe the result of the query expression . The RETURN operator can take an expression which produces the elements of the resulting collection. For example, the query:",{"@attributes":{"id":"p-0074","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim ReducedBookPrices ="]},{"entry":[{},"\u2003\u2003\u2003From b in Books"]},{"entry":[{},"\u2003\u2003\u2003Return b.Price * .8"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The result of a query expression  that ends with a RETURN operator can be a collection whose element type is the type of the returned expression. For example, in the following query expression the result type is IEnumerable (OF String), since c.Name is of type String:",{"@attributes":{"id":"p-0076","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim CustNames = "]},{"entry":[{},"\u2003\u2003From c In Customers "]},{"entry":[{},"\u2003\u2003Return c.Name"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"If a query expression  ends without a RETURN or SELECT operator, the resulting element type of the collection can be an anonymous type with properties for all of the control variables in scope:",{"@attributes":{"id":"p-0078","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2018 Result type is IEnumerable(Of {Name As String, Product As String})"},{"entry":"Dim CustNames = "},{"entry":"\u2003\u2003From c In Customers, O In C.Orders"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Even though a SELECT operator can describe the results of a query expression , any query expression  can continue after a SELECT operator. In that case, the control variables introduced by the SELECT statement are the control variables in scope, but all previous control variables are typically out of scope:",{"@attributes":{"id":"p-0080","num":"0094"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"CustNames = "]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From c In Customers, O In C.Orders "]},{"entry":[{},"Select Name = C.Name, Price = O.Price"]},{"entry":[{},"Where Price > 500"]},{"entry":[{},"Return Name"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":"104"},{"@attributes":{"id":"p-0081","num":"0095"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim CustNames = "]},{"entry":[{},"\u2003\u2003From X In (From c In Customers, O In C.Orders "]},{"entry":[{},"\u2003\u2003\u2003\u2003Return New With { C.Name, O.Price }), "]},{"entry":[{},"\u2003\u2003\u2003Name = X.Name, Price = X.Price"]},{"entry":[{},"\u2003\u2003Where Price > 500"]},{"entry":[{},"\u2003\u2003Return Name"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The RETURN and SELECT operators, respectively, can be defined based upon the following example:",{"@attributes":{"id":"p-0083","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ReturnOperator ::="]},{"entry":[{},"\u2003\u2003Return Expression"]},{"entry":[{},"SelectOperator ::= Select SelectDeclarationList"]},{"entry":[{},"SelectDeclarationList ::="]},{"entry":[{},"\u2003\u2003SelectDeclaration |"]},{"entry":[{},"\u2003\u2003SelectDeclarationList , SelectDeclaration"]},{"entry":[{},"SelectDeclaration ::="]},{"entry":[{},"\u2003\u2003VariableDeclarator"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Query operator pattern  can include a query operator that is an accessible instance method named WHERE that takes as an argument a function. A type, T, can be an argument of the function and results can be in a type that can be implicitly convertible to a boolean type. For example, the results type may have the same rules as the type of an expression that can be used in an IF, WHILE, or DO statement. Hence, the type may have either an implicit conversion to Boolean types or the IsTrue and IsFalse operators may need to have been defined. The WHERE operator can return a queryable type with element type T.","The WHERE operator can restrict the values in a collection to those that satisfy a given condition. A WHERE operator can receive a Boolean expression that is evaluated for each set of control variable values. If the value of the expression is True, then the values can appear in the output collection, otherwise the values can be skipped. The query expression:",{"@attributes":{"id":"p-0086","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003From b In Books, p In Publishers "]},{"entry":[{},"\u2003\u2003Where b.PublisherID = p.PublisherID "]},{"entry":[{},"\u2003\u2003. . ."]},{"entry":[{},"can be thought of as equivalent to the nested loop"]},{"entry":[{},"\u2003\u2003For Each b In Books"]},{"entry":[{},"\u2003\u2003\u2003\u2003For Each p In Publishers"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003If b.PublisherID = p.PublisherID Then"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003. . ."]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003End If"]},{"entry":[{},"\u2003\u2003\u2003\u2003Next p"]},{"entry":[{},"\u2003\u2003Next b"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The WHERE operator can be defined as:\n\nWhereOperator::=Where BooleanExpression\n","Query operator pattern  can include a query operator that is an accessible instance method named ORDERBY or ORDERBYDESCENDING that can take as an argument a function, which in turn can take in an argument of type, T, and results in a type, S. The method associated with pattern  can return an ordered collection with element type, T.","The ORDERBY operator can order the values that appear in the control variables based upon an order. The ORDERBY operator can take an expression that specifies the value that should be used to order the control variables. For example, the following query returns book titles sorted by price:",{"@attributes":{"id":"p-0090","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From book In Books "]},{"entry":[{},"Order By book.Price"]},{"entry":[{},"Select book.Title"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The ordering can be ascending, in which case smaller values come before larger values, or descending, in which case larger values come before smaller values. The default for an ordering is ascending. For example, the following query returns book titles sorted by price with the most expensive book first:",{"@attributes":{"id":"p-0092","num":"0106"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From book In Books "]},{"entry":[{},"Order By book.Price Descending"]},{"entry":[{},"Select book.Title"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The ORDERBY operator may also specify multiple expressions for ordering, in which case the collection can be ordered in a nested manner. For example, the following query expression orders authors by state, then by city within each state, and then by ZIP code within each city:",{"@attributes":{"id":"p-0094","num":"0108"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From author In Authors "]},{"entry":[{},"Order By author.State, author.City, author.ZIP "]},{"entry":[{},"Select author.Name, author.State, author.City, author.ZIP"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The ORDERBY operator can be schematized based upon the following example:",{"@attributes":{"id":"p-0096","num":"0110"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OrderByOperator ::= Order By OrderExpressionList"]},{"entry":[{},"OrderExpressionList ::="]},{"entry":[{},"\u2003\u2003OrderExpression |"]},{"entry":[{},"\u2003\u2003OrderExpressionList , OrderExpression"]},{"entry":[{},"OrderExpression ::="]},{"entry":[{},"\u2003\u2003Expression [ Ordering ]"]},{"entry":[{},"Ordering ::= Ascending | Descending"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"In addition, query operator pattern  can include a query operator that is an accessible instance method named DISTINCT. Typically, the method does not require an input and can return a queryable type with the same element type as the source type, C. The DISTINCT operator can restrict the values in a collection to only those with distinct values (e.g., does not return repeated values). For example, the query:",{"@attributes":{"id":"p-0098","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From c In Customers, o In c.Orders "]},{"entry":[{},"Select c.Name, o.Price "]},{"entry":[{},"Distinct"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":[{},{}],"in-line-formulae":[{},{}]},"Referring now to query operator pattern , the pattern  can include a query operator that is an accessible instance method named CONCAT, UNION, INTERSECT, or EXCEPT. The method can receive as an argument a collection with the same element type, T, as the source, C, and can return a queryable type with element type, T.","The next query operator pattern, pattern  can include a query operator that can be an accessible instance method named TAKE or SKIP, which can receive a value as an argument, and which can return a queryable type with the same element type as the source type, C.","The TAKE operator can result in a given number of elements from a collection. When used with the WHILE modifier (see e.g., query operator pattern ), the TAKE operator can result in a sequence of elements while the condition holds true.","The SKIP operator can ignore a given number of elements from a collection and then returns the remainder of the collection. When used in conjunction with the WHILE modifier, the SKIP operator skips elements while a condition holds true and then returns the rest of the collection. An example schema for TAKE and SKIP are provided below.",{"@attributes":{"id":"p-0103","num":"0117"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PartitionOperator ::="]},{"entry":[{},"\u2003\u2003TakeExpression |"]},{"entry":[{},"\u2003\u2003SkipExpression"]},{"entry":[{},"TakeExpression ::="]},{"entry":[{},"\u2003\u2003Take\u2003[ While ] Expression |"]},{"entry":[{},"SkipExpression ::="]},{"entry":[{},"\u2003\u2003Skip\u2003[ While ] Expression"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Query operator pattern  can include a query operator that is an accessible instance method named TAKEWHILE or SKIPWHILE. The method can take as an argument a function, wherein the function can receive an argument of type, T, and results in a Boolean. The method can return a queryable type with element type T.","Query operator pattern  can include a query operator that is an accessible instance method named SUM, MIN, MAX, COUNT, or AVERAGE. The method can receive as an argument a function, which in turn receives an argument of type, T, and results in a numeric type. The method can return a numeric type.","Query operator pattern  can include a query operator that is an accessible instance method named MIN or MAX that can take as an argument a function with an argument of type, T, and results in a type, S. The method can return a queryable type with element type, S.","Query operator pattern  can include a query operator that is an accessible instance method named ANY or ALL that can receive as an argument a function. The function can include an argument of type, T, and results in a type that can be implicitly convertible to Boolean. The method can return a type that can be implicitly convertible to Boolean.","It is to be understood that the query operators associated with patterns - can be employed in conjunction with an AGGREGATE operator. Within an Aggregate query clause, the set of standard AGGREGATE operators can be applied to the grouped control variable in scope. The AGGREGATE operators can include but are not limited to: ANY, ALL, COUNT, LONGCOUNT, SUM, MIN, MAX, AVERAGE, and\/or GROUP.","The ANY aggregate operator can ascertain whether there is an element in the group that satisfies a given condition. The ALL aggregate operator can determine whether all elements in the group satisfy a given condition. For example, the example query expression  below can check whether there are any customers younger than 18 years old:",{"@attributes":{"id":"p-0110","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From cust In Customers "]},{"entry":[{},"Group By cust.State "]},{"entry":[{},"Aggregate YoungerThan18 = Any(cust.Age < 18)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"104"},{"@attributes":{"id":"p-0111","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From cust In Customers "]},{"entry":[{},"Group By cust.State "]},{"entry":[{},"Aggregate AtLeast5 = All(cust.Orders.Count( ) > 5)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The COUNT and LONGCOUNT aggregate operators can take an optional Boolean expression and count the number of elements in the group that satisfy the given condition.",{"@attributes":{"id":"p-0113","num":"0127"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From cust In Customers "]},{"entry":[{},"Group By cust.State "]},{"entry":[{},"Aggregate Seniors = Count(cust.Age > 50)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The SUM aggregate operator can compute the sum of the elements of a group based on a particular selector expression. For example, the following exemplary query expression  can compute the total values of all orders grouped by category:",{"@attributes":{"id":"p-0115","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From order In Orders "]},{"entry":[{},"Group By order.Category"]},{"entry":[{},"Aggregate Total = Sum(order.Price)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The MIN and MAX aggregate operators can calculate the minimum (or maximum) of the elements of a group based on some selector expression. For example, the following example query expression  can compute the youngest and the oldest customer for each state:",{"@attributes":{"id":"p-0117","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From cust In Customers "]},{"entry":[{},"Group By cust.State"]},{"entry":[{},"Aggregate Oldest = Max(cust.Age), Youngest = Min(cust.Age)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The AVERAGE aggregate operator typically computes the average of the elements of a group based on a particular selector expression. For example, the following example query expression  can compute the average price for all products grouped per category:",{"@attributes":{"id":"p-0119","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From prod In Products "]},{"entry":[{},"Group By prod.Category"]},{"entry":[{},"Aggregate AveragePrice = Average(prod.Price)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The special GROUP aggregate operator can accumulate all the elements of the group, based on an optional selector expression, into an explicit collection. For example, the following exemplary query expression  can collect all the names of customers in a given state into a single collection.",{"@attributes":{"id":"p-0121","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From cust In Customers "]},{"entry":[{},"Group By cust.State"]},{"entry":[{},"Aggregate Names = Group(cust.Name)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Query operator pattern  can include a query operator that is an accessible instance method named JOIN. The method can that take as an argument a queryable type, S, with an element of type T\u2032; a function that acts as the inner selector which can take an argument of type, T, and results of a type representing a key, K; a function that acts as the outer selector that can take an argument of type, T\u2032, and results in a type representing the key, K; and\/or a function that acts as the join condition which takes two arguments of type T and T\u2032, respectively and results in a hash value of type, V. The method can return a queryable type with an element type, V.","Hence, the JOIN operator can take two collections and produce a single collection based on matching keys derived from the elements. Some restrictions can apply when specifying the condition on which to join. For example, the operands to the conditional expression may be required to be implicitly convertible to Boolean. One example of a JOIN schema follows.",{"@attributes":{"id":"p-0124","num":"0138"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"JoinOperator ::="},{"entry":"\u2003\u2003Join LoopControlVariable [As TypeName ] In Expression Where"},{"entry":"JoinConditionExpression"},{"entry":"JoinConditionExpression ::="},{"entry":"\u2003\u2003RelationalOperatorExpression |"},{"entry":"\u2003\u2003LikeOperatorExpression"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Query operator pattern  can include a query operator that is an accessible instance method named GROUPJOIN that can receive as an argument a queryable type, S, with an element of type, T\u2032; a function that acts as the outer key selector that takes an argument of type, T, and results in a type representing the key, K; a function which acts as the inner key selector which takes an argument of type, U, and results in a type representing the key, K; and\/or a function that can yield the results, wherein the function can take an argument of type, T, and an argument that is a collection with an element type, U, that results in a selected type, V. The method can return a queryable type with element type, V.","The GROUPJOIN operator can create a grouped join of two collections based on matching keys extracted from the elements. The operator can produce hierarchical results (e.g., outer elements paired with collections of matching inner elements) and requires no direct equivalence in relational database terms. The following example query expression  can perform a grouped join of customers with their orders, producing a collection of anonymous types with the customer name and the total of that customer's orders:",{"@attributes":{"id":"p-0127","num":"0141"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From cust In db.Customers "]},{"entry":[{},"Group Join order In db.Orders On cust.ID = order.CustID "]},{"entry":[{},"Aggregate TotalOrders = Sum(order.Total) "]},{"entry":[{},"Select cust.Name, TotalOrders"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"There can be any number of additional operators that operate on fixed sets to compute single values. In the context of a query, one can say that these operators aggregate computed values. To aggregate over a set, the set must generally first be introduced. Within a query, there can be various ways to specify a collection for aggregate computation. After a group is introduced, that group can be aggregated over to compute single values. Hence, in addition to the grouping operators GROUPJOIN (as well as GROUPBY discussed in connection with query operator pattern , below), other grouping operators can exist. One such example is the OVER operator.","The OVER operator can specify that a group should be accumulated for aggregate comprehension. The Over operator can be used as a stand-alone expression or it can be used to specify that a pre-formed collection should be employed for aggregate computation. For example, the following example query expression  can aggregate the sum of all the order totals before Jan. 1, 2006:",{"@attributes":{"id":"p-0130","num":"0144"},"tables":{"@attributes":{"id":"TABLE-US-00037","num":"00037"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Over order In Orders "]},{"entry":[{},"Where order.Date <= #01\/01\/2006# "]},{"entry":[{},"Aggregate Sum(order.Total)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Each application of the OVER operator typically must be closed by a corresponding AGGREGATE operator to compute a single value based on the contents of the collection. The result of the query can be a single value which corresponds to the aggregate computation, which in this case is an Integer that represents the sum total of all the orders before 2006.","Between the OVER and AGGREGATE operators potentially any query operator can be used. Within the AGGREGATE operator, only AGGREGATE operators (e.g., operators associated with patterns -, described supra) may be used on the control variables specified by the previous OVER operator.","When a set is already formed, as is often the case with hierarchical object graphs, the OVER operator can be used to specify that a set should be used for aggregate computation. For example, the following exemplary query expression  can aggregate the sum total of all the orders placed by customers in Washington before 2006:",{"@attributes":{"id":"p-0134","num":"0148"},"tables":{"@attributes":{"id":"TABLE-US-00038","num":"00038"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From cust In db.Customers "]},{"entry":[{},"Where cust.State = \u201cWA\u201d "]},{"entry":[{},"Over order In Orders "]},{"entry":[{},"Where order.Date <= #01\/01\/2006# "]},{"entry":[{},"Aggregate Sum(order.Total)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The result of the query can be a queryable type whose element type is an anonymous type with two properties: 1) a Customer property called cust and an Integer property called Sum.","Query operator pattern  can include a query operator that is an accessible instance method named GROUPBY that takes as an argument a function that acts as the key selector receiving an argument of type, T, and results in a type representing the key, K; and\/or a function that yields the result, which takes an argument of type, K, and an argument that is a collection with an element type, T, that results in a selected type, V. The method can return results in a queryable type with element type, V.","The GROUPBY operator can group (e.g., logically) the elements of a collection based on one or more common key expressions. For each of these partitions of the initial collection, a subsequent AGGREGATE statement can specify how each of these groups is aggregated into a single value or row.","For example, the following exemplary query expression  can group all customers by State, and then compute the count and average age of each group:",{"@attributes":{"id":"p-0139","num":"0153"},"tables":{"@attributes":{"id":"TABLE-US-00039","num":"00039"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From cust In Customers "]},{"entry":[{},"Group By cust.State"]},{"entry":[{},"Aggregate Total = Count( ), AverageAge = Avg(cust.Age)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Like the SELECT operator, the GROUPBY operator can bring the variables declared in the key selectors in scope as control variables and can hide all control variables that were previously in scope. In contrast, unlike the certain aspects of the SELECT operator, these hidden control variables can be brought in scope again by AGGREGATE operators used inside a subsequent AGGREGATE operator. Furthermore, unlike some implementations of the OVER operator, no other query operators can be used between the GROUPBY and the AGGREGATE operators.",{"@attributes":{"id":"p-0141","num":"0155"},"tables":{"@attributes":{"id":"TABLE-US-00040","num":"00040"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From cust In Customers "]},{"entry":[{},"Group CustomersByState By cust.State"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"This construct can be equivalent to constructing the group by way of an explicit aggregation, but can be useful when terminating the query immediately after a GROUPBY operator clause. Thus, the above expression can be equivalent to the expression:",{"@attributes":{"id":"p-0143","num":"0157"},"tables":{"@attributes":{"id":"TABLE-US-00041","num":"00041"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From cust In Customers "]},{"entry":[{},"Group By cust.State "]},{"entry":[{},"Aggregate CustomersByState = Group(cust)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The actual implementation of the GROUPBY operator need not be required to actually build a representation of each individual group. Instead the implementation may use an underlying implementation that combines the grouping with the subsequent aggregation into a single operation.","It is to be appreciated that the type and name of the control variables can be inferred from the target of the query expression  and the query operator being applied (which is discussed in more detail, below in connection with ). As such, the element type (which is an aggregation of the control variables in scope), can be inferred in a similar manner. For each of the rules supra, the inferred type of the element type can be T, and the element type typically must match the element type, T, when the queryable type, C, is the collection used in, e.g., a FOR EACH . . . NEXT statement.","It should be further appreciated that an ordered collection can be defined as a collection that implements a subset of the following operators: an accessible instance method named THENBY or THENBYDESCENDING that takes as an argument a function, which takes in an argument of type, T, and results in a type, S. The method can return an ordered collection with element type, T.","Since the query operator patterns  can facilitate binding query syntax to methods that implement a particular query operation, order preservation need not be dictated by the underlying language employed. Rather, order preservation can be determined by the implementation of the operator itself. This can be similar to user-defined operators in that the implementation to overload, e.g., the addition operator for a user-defined numeric type may not perform anything resembling an addition. However, to preserve predictability inherent in the claimed subject matter, implementing an operator that does not match user expectations may not be a recommended course.","To aid in a more complete understanding of the claimed subject matter, additional features, aspects and\/or implementations can now be further discussed. For example, some of the sections below detail exemplary manners in which each query operator maps to calls to standard query operator methods. Other sections describe ways in which element type information flows as was introduced above and will be employed in later sections (e.g., in connection with  and the associated description infra).","Query Operator Translation","It is to be understood that each of the various query operators can map directly to method calls that can be defined according to a standard query operator pattern (e.g., query operator pattern ). Thus, the meaning of a query operator (or a query expression as whole) can be expressed in terms of the query operator methods that are to be called. The methods can be instance methods of the object being queried or extension methods that are external to the object. For example, the query:",{"@attributes":{"id":"p-0150","num":"0164"},"tables":{"@attributes":{"id":"TABLE-US-00042","num":"00042"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Dim names = "]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From c In Customers "]},{"entry":[{},"Where c.State = \u201cWA\u201d "]},{"entry":[{},"Return c.Name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"can be equivalent to:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim names = Customers.Where(c -32 > c.State).Select"]},{"entry":[{},"(c => c.Name)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"While control variables can be employed by the claimed subject matter for various purposes described herein, it is to be appreciated that control variable are not generally directly accessible to an end-user. Some query operators such as WHERE or SELECT take expressions that can refer to control variables that are in scope in the query. These expressions are expressed as local functions that take the control variable and return the result of the expression. For example, the query:",{"@attributes":{"id":"p-0152","num":"0166"},"tables":{"@attributes":{"id":"TABLE-US-00043","num":"00043"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Dim WACusts = "]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From cust In Customers "]},{"entry":[{},"Where cust.State = \u201cWA\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"can be equivalent to:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim WACusts = Customer.Where(c => c.State =\u201cWA\u201d)"]},{"entry":[{},".Select(c => New With {c.Name})"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0153","num":"0167"},"tables":{"@attributes":{"id":"TABLE-US-00044","num":"00044"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Dim WACustsAndOrders ="]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From cust In Customers"]},{"entry":[{},"From order In cust.Orders"]},{"entry":[{},"Where cust.State = \u201cWA\u201d AndAlso order.Price > 10.50"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"can be equivalent to:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Function Filter1(it As {c As Customer, o As Order}) As Boolean"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Return it.c.State = \u201cWA\u201d AndAlso it.o.Price > 10.50"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End Function"]},{"entry":[{},"Function Join1(c As Customer) As"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IEnumerable(Of {c As Customer, o As Order})"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Function Select1(o As Order) As {c As Customer, o As Order}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Return New {c, o}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End Function"]},{"entry":[{},"Return c.Orders. Select(AddressOf Select1)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End Function"]},{"entry":[{},"Dim WACustsAndOrders ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Customers.SelectMany(AddressOf Join1).Where(AddressOf"]},{"entry":[{},"Filter1)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"It is to be further appreciated that support for Lambda Expressions can be provided as well and is to be considered within the spirit and scope of the claimed subject matter. As a further note, composite control variables are usually not nested. As an example:",{"@attributes":{"id":"p-0155","num":"0169"},"tables":{"@attributes":{"id":"TABLE-US-00045","num":"00045"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From b In Books"]},{"entry":[{},"From ba In BookAuthors"]},{"entry":[{},"From a In Authors"]},{"entry":[{},". . ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"can be equivalent to:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Function Join1(b As Book) As IEnumerable(Of {b As Book, ba As"]},{"entry":[{},"BookAuthor})"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Function Select1(ba As BookAuthor) As {b As Book, ba As"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BookAuthor}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Return New { b, ba }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End Function"]},{"entry":[{},"Return BookAuthors.Select(AddressOf Select1)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End Function"]},{"entry":[{},"Function Join2(it As {b As Book, ba As BookAuthor}) As"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IEnumerable(Of {b As Book, ba As BookAuthor, a As"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"7pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"210pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Author})"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Function Select2(a As Author) As"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{b As Book, ba As BookAuthor, a As Author}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Return New {b, ba, a}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End Function"]},{"entry":[{},"Return Authors.Select(AddressOf Join2)"]},{"entry":[{},"End Function"]},{"entry":[{},"Books.SelectMany(AddressOf Join1).SelectMany(AddresOf Join2)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"A standard FROM operator generally only introduces the source of a query and the control variable to be used. In essence, it does not translate into any specific query operator call. In the case of a JOIN, the FROM operators can be translated into a call to the SELECTMANY query operator method when joining with a regular control variable and a call to the SELECT query operator method when joining with an expression control variable. So the query expression:",{"@attributes":{"id":"p-0157","num":"0171"},"tables":{"@attributes":{"id":"TABLE-US-00046","num":"00046"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From b In Books, p In Publishers"]},{"entry":[{},"Select b.Title, p.Name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"can be equivalent to:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Function Join1(b As Book) As IEnumerable(Of {b As Book,"]},{"entry":[{},"p As Publisher})"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Function Select2(p As Publisher) As {b As Book,"]},{"entry":[{},"p As Publisher}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Return New With {b, p}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End Function"]},{"entry":[{},"Return Publishers.Select(AddressOf Select2)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End Function"]},{"entry":[{},"Function Select1(it As {b As Book, p As Publisher}) As"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{Title As String, Name As String}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Return New With {it.b.Title, it.p.Name}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End Function"]},{"entry":[{},"Books.SelectMany(AddressOf Join1).Select(AddressOf Select1)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0158","num":"0172"},"tables":{"@attributes":{"id":"TABLE-US-00047","num":"00047"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From b In Books, Tax = b.Price * 0.088"]},{"entry":[{},"Select b.Title, Tax"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"can be equivalent to:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Function Select1(b As Book) As {b As Book, Tax As Double}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Return New With {b, Tax =b.Price * 0.088}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End Function"]},{"entry":[{},"Function Select2(it As {b As Book, Tax As Double})"]},{"entry":[{},"As {Title As String, Tax As Double}"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Return New With {it.b.Title, it.Tax}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"End Function"]},{"entry":[{},"Books.Select(AddressOf Select1).Select(AddressOf Select2)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Each query operator can be bound to an underlying method on the source type that adheres to a particular pattern. This pattern dictates the element type of the result of the operator and, in some cases, puts constraints on the expressions that can be passed into the underlying methods.","Explicitly Typed Control Variables","If the FROM operator specifies a target type Object for the control variable using an As clause and the type for T cannot be inferred from the source type, then the element type can be converted using the Cast (Of Object) operator. The query expression:",{"@attributes":{"id":"p-0161","num":"0175"},"tables":{"@attributes":{"id":"TABLE-US-00048","num":"00048"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim nums ="]},{"entry":[{},"\u2003\u2003From addrNum As Object In publisher.Address"]},{"entry":[{},"\u2003\u2003Where addrNum < 5"]},{"entry":[{},"is equivalent to:"]},{"entry":[{},"Function Filter1(addrNum As Integer) As Boolean"]},{"entry":[{},"\u2003\u2003Return addrNum < 5"]},{"entry":[{},"End Function"]},{"entry":[{},"Dim names = publisher.Address.Cast(Of Object)( ).Where(AddressOf"]},{"entry":[{},"Filter1)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"If the FROM operator specifies a target type T (not Object) for the control variable using an As clause and the type for T cannot be inferred from the source type or if the target type does not match the element type of the source, then the element type can be converted using the Cast query operator to Object and a subsequent SELECT operator can be utilized to obtain the target type. For example, the query expression:",{"@attributes":{"id":"p-0163","num":"0177"},"tables":{"@attributes":{"id":"TABLE-US-00049","num":"00049"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim nums = "]},{"entry":[{},"\u2003\u2003From addrNum As Integer In publisher.Address "]},{"entry":[{},"\u2003\u2003Where addrNum < 5"]},{"entry":[{},"is equivalent to:"]},{"entry":[{},"Function Filter1(addrNum As Integer) As Boolean"]},{"entry":[{},"\u2003\u2003Return addrNum < 5"]},{"entry":[{},"End Function"]},{"entry":[{},"Function Select1(addrNum As Integer) As String"]},{"entry":[{},"\u2003\u2003Return addrNum"]},{"entry":[{},"End Function"]},{"entry":[{},"Dim names = publisher.Address.Cast(Of Object)( ).Select(AddressOf"]},{"entry":[{},"Select1).Where(AddressOf Filter1)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"If the FROM operator specifies a target type T for the control variable using an As clause and the type for T matches the element type of the source, then there need be no subsequent application of the Cast or SELECT operators.","WHERE Operator Translation","The WHERE operator can be translated to a call to the Where query operator method. For example the query expression:",{"@attributes":{"id":"p-0166","num":"0180"},"tables":{"@attributes":{"id":"TABLE-US-00050","num":"00050"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From book In Books"]},{"entry":[{},"Where book.PublisherID = 10"]},{"entry":[{},"Return book.Title"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"can be equivalent to:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Books.Where(b => b.PublisherID = 10).Select(b => b.Title)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The ORDERBY operator can be translated into a call to the ORDERBY or ORDERBYDESCENDING query operator method (depending on the type of sort) for the first sort and then into a call to the THENBY and THENBYDESCENDING query operator method for following sorts. For example the query expression:",{"@attributes":{"id":"p-0168","num":"0182"},"tables":{"@attributes":{"id":"TABLE-US-00051","num":"00051"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From a In Authors"]},{"entry":[{},"Order By a.State, a.City Descending"]},{"entry":[{},"Return a.Name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"can be equivalent to:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Authors.OrderBy(a=> a.State).ThenByDescending(a => a.City)."]},{"entry":[{},"Select(a => a.Name)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The RETURN operator can be translated into a call to the SELECT query operator method. For example:",{"@attributes":{"id":"p-0170","num":"0184"},"tables":{"@attributes":{"id":"TABLE-US-00052","num":"00052"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From e In Employees"]},{"entry":[{},"Return e.Name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"can be equivalent to:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Employees.Select(e => e.Name)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The SELECT operator can be translated into a call to the SELECT query operator method and the construction of an anonymous type. For example:",{"@attributes":{"id":"p-0172","num":"0186"},"tables":{"@attributes":{"id":"TABLE-US-00053","num":"00053"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From e In Employees"]},{"entry":[{},"Select e.Name, e.Salary"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"can be equivalent to:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Employees.Select(e => new With {e.Name, e.Salary})"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The DISTINCT operator can be translated into a call to the DISTINCT query operator method. For example:",{"@attributes":{"id":"p-0174","num":"0188"},"tables":{"@attributes":{"id":"TABLE-US-00054","num":"00054"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From e In Employees"]},{"entry":[{},"Distinct"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"can be equivalent to:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Employees.Distinct( )"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The TAKE or SKIP operators can call the respective TAKE or SKIP query operator method. For example:",{"@attributes":{"id":"p-0176","num":"0190"},"tables":{"@attributes":{"id":"TABLE-US-00055","num":"00055"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From e In Employees"]},{"entry":[{},"Order By e.Salary Descending"]},{"entry":[{},"Return e.Name"]},{"entry":[{},"Take 5"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"can be equivalent to:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Employees.OrderByDescending(e => e.Salary)."]},{"entry":[{},"Select(e => e.Name).Take(5)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0177","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00056","num":"00056"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"From e In Employees"]},{"entry":[{},{},"Order By e.Salary Descending"]},{"entry":[{},{},"Return e.Name"]},{"entry":[{},{},"Skip 5"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},"can be equivalent to:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"Employees.OrderByDescending(e => e.Salary)."]},{"entry":[{},{},"Select(e => e.Name).Skip(5)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"When used in conjunction with the WHILE modifier, a conditional expression can be created to apply to the underlying TAKEWHILE or SKIPWHILE query operator. For example, the query:",{"@attributes":{"id":"p-0179","num":"0193"},"tables":{"@attributes":{"id":"TABLE-US-00057","num":"00057"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From e In Employees"]},{"entry":[{},"Order By e.Salary Descending"]},{"entry":[{},"Take While e.Salary > 50000"]},{"entry":[{},"Return e.Name"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"can be equivalent to:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Employee.OrderByDescending(e => e.Salary)."]},{"entry":[{},".TakeWhile(e => e.Salary > 50000).Select(e => e.Name)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The GROUPBY operator followed by an aggregating SELECT or RETURN operator can be translated into a call to the GROUPBY query operator method followed by an aggregation over the constructed groups. For example the query:",{"@attributes":{"id":"p-0181","num":"0195"},"tables":{"@attributes":{"id":"TABLE-US-00058","num":"00058"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From C In Customer"]},{"entry":[{},"Group By C.State"]},{"entry":[{},"Aggregate Youngest = Min(c.Age), Oldest = Max(c.Age)"]},{"entry":[{},"Select State, Youngest, Oldest"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"can be equivalent to:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Customers"]},{"entry":[{},".GroupBy(c => New Witth { .State = c.State }, "]},{"entry":[{},"(g, k) => New With { .State = k, "]},{"entry":[{},".Youngest = g.Min(c => c.Age),"]},{"entry":[{},".Oldest = g.max(c => c.Age) })"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"All of the examples included herein use one of two separate sets of objects. The Company objects can represent information about a company, and can be connected hierarchically:",{"@attributes":{"id":"p-0183","num":"0197"},"tables":{"@attributes":{"id":"TABLE-US-00059","num":"00059"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class Company"]},{"entry":[{},"\u2003\u2003Dim Name As String"]},{"entry":[{},"\u2003\u2003Dim Employees As List(Of Employees)"]},{"entry":[{},"\u2003\u2003Dim Customers As List(Of Customer)"]},{"entry":[{},"End Class"]},{"entry":[{},"Class Customer"]},{"entry":[{},"\u2003\u2003Dim Name As String"]},{"entry":[{},"\u2003\u2003Dim Orders As List(Of Order)"]},{"entry":[{},"End Class"]},{"entry":[{},"Class Order"]},{"entry":[{},"\u2003\u2003Dim Product As String"]},{"entry":[{},"\u2003\u2003Dim Price As Integer"]},{"entry":[{},"End Class"]},{"entry":[{},"Class Employee"]},{"entry":[{},"\u2003\u2003Dim Name As String"]},{"entry":[{},"\u2003\u2003Dim Birthday As Date"]},{"entry":[{},"\u2003\u2003Dim Position As String"]},{"entry":[{},"\u2003\u2003Dim Salary As Decimal"]},{"entry":[{},"End Class"]},{"entry":[{},"Dim Employees As List(Of Employee)"]},{"entry":[{},"Dim Customers As List(Of Customer)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The Book objects can represent information about books stocked in, e.g., a bookstore, and can be connected relationally:",{"@attributes":{"id":"p-0185","num":"0199"},"tables":{"@attributes":{"id":"TABLE-US-00060","num":"00060"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Class Book"]},{"entry":[{},"\u2003\u2003Dim BookID As Long"]},{"entry":[{},"\u2003\u2003Dim Title As String"]},{"entry":[{},"\u2003\u2003Dim PublisherID As Long"]},{"entry":[{},"\u2003\u2003Dim Price As Double"]},{"entry":[{},"End Class"]},{"entry":[{},"Class Author"]},{"entry":[{},"\u2003\u2003Dim AuthorID As Long"]},{"entry":[{},"\u2003\u2003Dim Name As String"]},{"entry":[{},"\u2003\u2003Dim Address As String"]},{"entry":[{},"\u2003\u2003Dim City As String"]},{"entry":[{},"\u2003\u2003Dim State As String"]},{"entry":[{},"\u2003\u2003Dim ZIP As String"]},{"entry":[{},"End Class"]},{"entry":[{},"Class BookAuthor"]},{"entry":[{},"\u2003\u2003Dim BookID As Long"]},{"entry":[{},"\u2003\u2003Dim AuthorID As Long"]},{"entry":[{},"End Class"]},{"entry":[{},"Class Publisher"]},{"entry":[{},"\u2003\u2003Dim PublisherID As Long"]},{"entry":[{},"\u2003\u2003Dim Name As String"]},{"entry":[{},"\u2003\u2003Dim Address As String"]},{"entry":[{},"\u2003\u2003Dim State As String"]},{"entry":[{},"End Class"]},{"entry":[{},"Dim Books As List(Of Book)"]},{"entry":[{},"Dim Authors As List(Of Author)"]},{"entry":[{},"Dim BookAuthors As List(Of BookAuthor)"]},{"entry":[{},"Dim Publishers As List(Of Publisher)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"With the foregoing in mind and turning now to , a computer-implemented system  that can infer in real-time an element type and\/or incrementally provide context information based upon the inferred element type is depicted. Generally, the system  can include the user-interface  that can receive a query expression  as substantially described supra in connection with . In addition, the system  can include the pattern store  that can be operatively coupled (not shown) to the user-interface  and\/or to a context component . The context component  can examine the query expression  and make inferences in real-time that relate to element types. For example, as previously described, since the query operator for each query clause conforms to a specific patter (e.g., the query operator patterns  from ), and further, since the element type can flow from one query clause to the next query clause, these two pieces of information can be employed to determine an element type for any given next query clause.","When the query operators are described as method calls and the query operations are applied as a pure mechanical transforms, it is generally required that the type resolution take place during overload resolution. In this way, given that the query operators can flow types from one operator to another, an operator generally must be fully bound to be able to provide the type to the next operator to be applied. As a result, if overload resolution fails due to a syntax error or some other problem, there is no conventional mechanism through which to provide type information to the next operator that is applied. Compositional query operators (discussed in more detail infra beginning with ) without this type flow mechanism results in odd error messages, different expression semantics, a lack of context information for autocompletion, and slower compiler throughput overall.","As described, the claimed subject matter can adopt a formalization of the pattern of the query operators that can allow the element type to not rely on full method binding and instead depend upon the pattern of the particular operator being employed. By way of further illustration, consider the present exemplary query expression  that is received by the user-interface  (e.g., as the query expression  is being typed):",{"@attributes":{"id":"p-0189","num":"0203"},"tables":{"@attributes":{"id":"TABLE-US-00061","num":"00061"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Dim q = From cust In Customers"]},{"entry":[{},"\u2003\u2003Where cust.Name = \u201cXYZ\u201d & errorUnresolvedVarName"]},{"entry":[{},"\u2003\u2003Select cust."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The element type that flows into the SELECT clause can now serve as a source type for that particular query clause. The context component  can, thus, infer in real-time the element type (e.g., cust) for this query clause based upon the source type and the query operator. Accordingly, the inference can be entirely local and without the need for full translation of the query expression . Rather, the context component  can perform the inferences in a manner similar to a background compiler.","In addition, the inferences of the context component  can facilitate greater efficiency in a number of ways. For example, inferences need only be performed a single time when translations are performed. Thus, if there are two WHERE operators in the query expression , then the translation for the second WHERE operator need not be required. In addition, the inferences can be employed in connection with the full and customarily more expensive compilation so as to short circuit the type discovery that generally must be performed. As such, inferring the element types in advance can be employed in a variety of ways to hasten compilation time.","Moreover, once the context component  infers the element type (here, \u201ccust\u201d in the \u201cSelect cust.\u201d query clause), the context component  can in real-time provide context information . For example, when the dot is typed in \u201ccust.\u201d the context information  can be provided in the form of a convenient and familiar pop-up window to allow for autocompletion as illustrated, or in another form. It is to be understood, that such a feature is not conventionally available for query expressions since query expressions (conventionally) must be translated first before the element types can be determined. And since supplying a complete and error-free query expression is a prerequisite for conventional translation\/compilation, any similar context and\/or autocompletion mechanism has heretofore been precluded.","While the context information  can be of great utility for query expressions, and is largely illustrated in the context of providing contextual feedback in an IDE, neither case is necessary. For example, what is described herein can be applicable to more than just query operators of a query expression. In particular, the notions of type flows from and relationships between one operator and the next could apply to any operator or any API where the type flow can be of use. One such example exists in chaining API calls together (e.g., pipelines included in a command line where it is intended that the type flows from one command to the next. Another example can be late binding where there are no types, but some form of flow can be employed such as for late-bound optimization.","It is to be further understood that the inferences performed by the context component  can be entirely predetermined based upon the known information received (e.g., a source type in connection with a known and defined query operator), or in accordance with other aspects, the inferences can be probabilistic. For example, when employed with different types of operators, the context component  can be employed to examine the entirety or a subset of the data available and can provide for reasoning about or infer states of the system, environment, and\/or user from a set of observations as captured via events and\/or data. Inference can be employed to identify a specific context or action, or can generate a probability distribution over states, for example. The inference can be probabilistic\u2014that is, the computation of a probability distribution over states of interest based on a consideration of data and events. Inference can also refer to techniques employed for composing higher-level events from a set of events and\/or data.","Such inference can result in the construction of new events or actions from a set of observed events and\/or stored event data, whether or not the events are correlated in close temporal proximity, and whether the events and data come from one or several event and data sources. Various classification (explicitly and\/or implicitly trained) schemes and\/or systems (e.g., support vector machines, neural networks, expert systems, Bayesian belief networks, fuzzy logic, data fusion engines . . . ) can be employed in connection with performing automatic and\/or inferred action in connection with the claimed subject matter.","A classifier can be a function that maps an input attribute vector, x=(x1, x2, x3, x4, xn), to a confidence that the input belongs to a class, that is, f(x)=confidence(class). Such classification can employ a probabilistic and\/or statistical-based analysis (e.g., factoring into the analysis utilities and costs) to prognose or infer an action that a user desires to be automatically performed. A support vector machine (SVM) is an example of a classifier that can be employed. The SVM operates by finding a hypersurface in the space of possible inputs, where the hypersurface attempts to split the triggering criteria from the non-triggering events. Intuitively, this makes the classification correct for testing data that is near, but not identical to training data. Other directed and undirected model classification approaches include, e.g., na\u00efve Bayes, Bayesian networks, decision trees, neural networks, fuzzy logic models, and probabilistic classification models providing different patterns of independence can be employed. Classification as used herein also is inclusive of statistical regression that is utilized to develop models of priority.",{"@attributes":{"id":"p-0197","num":"0211"},"figref":"FIG. 5"},"With reference now to , a computer-implemented method for facilitating type flow of element types is illustrated. Generally at reference numeral , a portion of a query clause including a query operator can be received. The query operator can be mapped to an associated method call that can receive arguments (e.g., functions, values, collections . . . ) and can return typed results (e.g., queryable types, numeric types, ordered collections . . . ). The method call can be defined according to a query operator pattern.","At reference numeral , a source type and the query operator can be utilized for determining an element type. For example, since the query operator pattern can be formalized, the pattern of the query operator can be employed in connection with the source type to infer the element type. At reference numeral , the element type of a previous query can be employed as the source type for the act of utilizing discussed at reference numeral . In accordance therewith, the element type can flow from one query clause to a next query clause in a recursive manner.","With the foregoing in mind, it will be appreciated and understood that certain features and\/or aspects can be employed for extending query capabilities of programming languages in other ways. As one example, the aspects developed herein can be effectively utilized in order to provide computer-based and\/or language-based constructs such as comprehensions with the compositional abilities conventionally associated with API calls. A description of these and other related concepts can be found with reference to ","Turning now to , a block diagram of a computer-implemented system  that can facilitate composable query comprehensions and\/or extensible query expressions is provided. In general, the system  can include a transformation component  that can receive initialization data . As depicted, the initialization data  can be the first query clause in exemplary query expression , wherein the first query clause is typically limited to being a FROM clause (e.g., the query operator of the first query clause is a FROM operator). The initialization data  can include a collection (e.g., Customers, as shown) or an expression (e.g., Tax=b.Price*0.088, as described supra in connection with the FROM operator detailed with regard to ). In either case, the initialization data can also include a control variable that, depending upon the application, is associated with either the collection (e.g., C is a control variable) or the expression (e.g., Tax is a control variable).","The transformation component  can also receive a set of query clauses  in a sequence characterized by the query expression . It is to be appreciated that the set of query clauses  can be an empty set, in which case the query expression  is comprised of a single query clause (e.g., the FROM clause employed as initialization data ), as will be described in more detail infra. As can be done with the initialization data , the transformation component  can also resolve (e.g., populate or transform) the control variables in scope for each query clause in the set . For example, the transformation component  can process each query clause in the set , in turn, in the order dictated by the query expression  by applying the query operator of each query clause to the available types.","It is to be appreciated that in accordance with the claimed subject matter, the set of query clauses  need not be restricted by a ubiquitous syntactical template such as, e.g., FLWOR\/FLWR as defined by versions of XQuery-brand languages or Select-From-Where as expected in implementations of SQL. Rather, the set  can be compositional in nature such that individual query clauses can be validly supplied, pieced together in a modular way, and yield intuitive results even when the order of the operators is arbitrary.","In accordance therewith, the system  can also include a comprehension component  that can manage the scope for all control variables introduced by the query expression . The scope of a control variable can be determined based upon the operator of a query clause, and the control variables in scope can be passed to the next query clause. For example, the transformation component  can establish what can be thought of as a pipeline such that certain information can flow from one query clause to the next query clause by way of the pipeline. Thus, the transformation component can receive a collection in connection with a query clause, transform (e.g., filter, project . . . ) the collection based upon the operator associated with the query clause, and output the transformed collection to the pipeline such that it is available to the next query clause.","Analogously, the control variables in scope can also be passed to the next query clause, and precisely what control variables are in scope can be defined by the comprehension component  based upon the types of query clauses received. Typically, the next query clause can only have access to the variables that are in scope. This feature as well as others can be further described by referring to  in addition to .",{"@attributes":{"id":"p-0206","num":"0220"},"figref":"FIG. 7","b":["606","610","610","610","702","704","604","608","710"]},"Clause  introduces the Customer collection and the control variable C. Hence, this information can be supplied by way of a pipeline to the next query clause. Accordingly, {C As Customer} can be made available the clause . Clause  is also a FROM clause, which is possible due to the compositional nature of the claimed subject matter. Clause  employs the control variable C to introduce a new collection, C.Orders (e.g., all orders for all customers) as well as the new control variable, O, which the comprehension component  can bring into scope. Thus, the next query clause  has access to both control variables in scope, C and O.","As substantially described above, while certain query clause types can affect the variables in scope, other query clause types (e.g., WHERE, ORDERBY, DISTINCT, etc.) need not. Thus, while query clauses  and  can affect the collection, the variables in scope (e.g., C and O) can be the same, and thus accessible by query clause  and , respectively, as each clause is received by the transformation component .","In accordance with an aspect of the claimed subject matter, the comprehension component  can take an existing control variable out of scope based upon a type of query clause received. The SELECT query clause  provides a characteristic illustration of this feature. Query clause  is exposed to control variables C and O, but one of the features of a SELECT clause can be to hide the current control variables in scope and introduce new control variables in scope (e.g., Name As String and Price As Int). Query clause  can be supplied with these new control variables, Name and Price, but generally cannot access the previous control variables (e.g., C and O) that the comprehension component  took out of scope in connection with the SELECT clause .","A second feature to be noted is that the WHERE clause  follows the SELECT clause . Conventional query languages terminate the query upon application of a query clause with a projection operator such as SELECT, RETURN, or a like operator. If a user of such conventional query languages desires to continue query operations after a projection, a new query must be implemented that can reference the results of a previous query. Yet due, e.g., to the compositional nature of the claimed subject matter, the query expression  can include multiple SELECT clauses and the query expression  can continue after the occurrence of a SELECT clause (e.g., as illustrated by clause ). In a similar vein, while mentioned in a previous section, it should be pointed out that the query expression  includes two FROM clauses as well (e.g., clauses  and ), which is a further aspect that conventional query languages fail to provide for.","While not depicted by express examples, the query expression  can also include other query clause types, and in particular, many of these other query clause types can affect the scope of control variables. For example, upon receipt of a RETURN clause, the comprehension component  can bring all control variables out of scope. As another example, based upon a type of query clause, the comprehension component  can declare and scope (e.g., bring into scope) new control variables while scoping extant control variables (e.g., control variables in scope for a previous query clause) for a particular set of subsequent query clauses. GROUPBY, AGGREGATE, et al. can facilitate such behavior whereby the extant control variables can be scoped over a range of AGGREGATE query clauses spanning the each GROUP operator.","According to another aspect of the claimed subject matter, the comprehension component  can generate an alias for a tuple of all control variables in scope based upon a type of query clause received. For example, an INTO query clause can facilitate the creation of the alias, e.g., by the comprehension component , even though the alias need not itself be a control variable.","While still referring to , various additional aspects of the claimed subject matter can be underscored. While a number of advantages that relate to the extensibility of valid query expressions  (e.g., the query expression  can be extended with virtually any number of query clauses of virtually any type), another advantage can be that the query expression  can terminate at any point as well. Thus, while the query expression  has the potential to include an indefinite number of query clauses, the entire query expression  can also be comprised of only a single query clause that terminates after the introduction of a single control variable. Hence one of the simplest examples of a complete and valid query expression  is a query expression  that includes only the initialization data :","From C In Customers","without a requirement that the query expression  include an explicit SELECT, RETURN, or other terminal query operator.","By way of explanation, the transformation component  can be configured to append an implicit SELECT or RETURN to each query clause received. Thus, as long as a resultant collection included in the pipeline is in a desired shape, there is no need to for an explicit statement to select or return these intermediate results. Rather, if the query expression  ends after any one of the given clauses, say, -, the collections in the pipeline can be output a result and a format of the output can be inferred based upon the number of control variables in scope.","For example, if the query expression  terminated after any of the clauses - (where in each case there are two control variables in scope, C and O), it can be inferred that the desired output should exist as a collection of name-value pairs. Accordingly, the output can be a tuple with a field for each control variable. On the other hand, in the case where there is only one control variable in scope, such as after clause , an implementer of the query expression  would not normal expect to get back a tuple with a field c. Rather, the implementer would likely desire the collection of customers. So in the case where there is only one control variable in scope, the output can be simply the underlying values of the collection.","In accordance with an aspect of the claimed subject matter, control variables introduced by a FROM clause can be associated with an expression as well as a collection. As a representative example, consider the following query fragment introduced above:",{"@attributes":{"id":"p-0218","num":"0232"},"tables":{"@attributes":{"id":"TABLE-US-00062","num":"00062"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"From b in Books"]},{"entry":[{},"From Tax = b.Price * 0.088"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The first FROM clause introduces a control variable b for the collection, Books, which is brought into scope and accessible to the next query clause. The next FROM clause introduces the control variable Tax associate with an expression (rather than a collection), b.Price*0.088. With the latter of the two FROM clauses, an effect can be that an accessible name is provided for the results of the expression. This name can be referred to by the control variable tax that can remain in scope until, e.g., a subsequent SELECT clause. This feature can be thought of as similar to a procedural statement within the query, which can allow values of an expression to be computed once even though the values may be employed numerous times subsequently, the values need not be recomputed.","According to another aspect of the claimed subject matter, set operations can be employed within the context of a single query expression . While conventional query languages typically only provide for a single collection as an input, the transformation component  can receive two collections as input. For example, the transformation component  can be configured to receive multiple collections and can output a single collection with control variables associated with the multiple collections merged according to a type of the query clause (e.g., a UNION clause, an INTERSECT clause . . . ). The merged control variables can be brought into scope, pass through the associated set operator, and be made accessible to the next query clause, so the query expression  can be continued. The control variables generally must be of the same type and generally must have the same name, but they can, of course, be associated with two different collections.","Turning now to , a computer-implemented method  for facilitating construction of query comprehensions in a compositional manner is illustrated. Beginning with reference numeral , a collection (or expression) and a control variable associated with the collection (or expression) can be obtained. In general, this obtained data is a product of the first query clause of a query expression, which is usually a FROM clause. At reference numeral , a current query clause from a set of query clauses included in a query expression can be received. It is to be appreciated that unlike conventional languages that require comprehensions to be monolithic, no syntactical ordering restriction need be placed on the current query clause or, for the most part, on the query expression as a whole.","At reference numeral , the collection can be modified in accordance with the current query clause. Simply put, the collection received as input can be transformed based upon the guidelines of the query operator associated with the current query clause. It is to be appreciated that the current query clause can be evaluated in accordance with an expected type associated with the current query clause rather than based upon monolithic syntactical templates. Next, at reference numeral , the modified collection can be piped to a next query clause. Hence, the output of the current query clause can be employed as an input for the next query clause.","At reference numeral , a scope for the control variable can be determined based upon the current query clause. For example, some types of query clauses do not facilitate any change to the extant control variables, while other query clauses can facilitate introduction of new control variable (in some cases only for a particular series of next query clauses), while still others can facilitate bringing extant control variables out of scope while (optionally) introducing new control variables. At reference numeral , access to the control variables in scope for the current query clause can be provided to the next query clause.","Referring now to , there is illustrated a block diagram of an exemplary computer system operable to execute the disclosed architecture. In order to provide additional context for various aspects of the subject invention,  and the following discussion are intended to provide a brief, general description of a suitable computing environment  in which the various aspects of the invention can be implemented. Additionally, while the invention has been described above in the general context of computer-executable instructions that may run on one or more computers, those skilled in the art will recognize that the invention also can be implemented in combination with other program modules and\/or as a combination of hardware and software.","Generally, program modules include routines, programs, components, data structures, etc., that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the inventive methods can be practiced with other computer system configurations, including single-processor or multiprocessor computer systems, minicomputers, mainframe computers, as well as personal computers, hand-held computing devices, microprocessor-based or programmable consumer electronics, and the like, each of which can be operatively coupled to one or more associated devices.","The illustrated aspects of the invention may also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules can be located in both local and remote memory storage devices.","A computer typically includes a variety of computer-readable media. Computer-readable media can be any available media that can be accessed by the computer and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer-readable media can comprise computer storage media and communication media. Computer storage media can include both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer-readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disk (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by the computer.","Communication media typically embodies computer-readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier wave or other transport mechanism, and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, RF, infrared and other wireless media. Combinations of the any of the above should also be included within the scope of computer-readable media.","With reference again to , the exemplary environment  for implementing various aspects of the invention includes a computer , the computer  including a processing unit , a system memory  and a system bus . The system bus  couples to system components including, but not limited to, the system memory  to the processing unit . The processing unit  can be any of various commercially available processors. Dual microprocessors and other multi-processor architectures may also be employed as the processing unit .","The system bus  can be any of several types of bus structure that may further interconnect to a memory bus (with or without a memory controller), a peripheral bus, and a local bus using any of a variety of commercially available bus architectures. The system memory  includes read-only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS) is stored in a non-volatile memory  such as ROM, EPROM, EEPROM, which BIOS contains the basic routines that help to transfer information between elements within the computer , such as during start-up. The RAM  can also include a high-speed RAM such as static RAM for caching data.","The computer  further includes an internal hard disk drive (HDD)  (e.g., EIDE, SATA), which internal hard disk drive  may also be configured for external use in a suitable chassis (not shown), a magnetic floppy disk drive (FDD) , (e.g., to read from or write to a removable diskette ) and an optical disk drive , (e.g., reading a CD-ROM disk  or, to read from or write to other high capacity optical media such as the DVD). The hard disk drive , magnetic disk drive  and optical disk drive  can be connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface  and an optical drive interface , respectively. The interface  for external drive implementations includes at least one or both of Universal Serial Bus (USB) and IEEE1394 interface technologies. Other external drive connection technologies are within contemplation of the subject invention.","The drives and their associated computer-readable media provide nonvolatile storage of data, data structures, computer-executable instructions, and so forth. For the computer , the drives and media accommodate the storage of any data in a suitable digital format. Although the description of computer-readable media above refers to a HDD, a removable magnetic diskette, and a removable optical media such as a CD or DVD, it should be appreciated by those skilled in the art that other types of media which are readable by a computer, such as zip drives, magnetic cassettes, flash memory cards, cartridges, and the like, may also be used in the exemplary operating environment, and further, that any such media may contain computer-executable instructions for performing the methods of the invention.","A number of program modules can be stored in the drives and RAM , including an operating system , one or more application programs , other program modules  and program data . All or portions of the operating system, applications, modules, and\/or data can also be cached in the RAM . It is appreciated that the invention can be implemented with various commercially available operating systems or combinations of operating systems.","A user can enter commands and information into the computer  through one or more wired\/wireless input devices, e.g., a keyboard  and a pointing device, such as a mouse . Other input devices (not shown) may include a microphone, an IR remote control, a joystick, a game pad, a stylus pen, touch screen, or the like. These and other input devices are often connected to the processing unit  through an input device interface  that is coupled to the system bus , but can be connected by other interfaces, such as a parallel port, an IEEE1394 serial port, a game port, a USB port, an IR interface, etc.","A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , a computer typically includes other peripheral output devices (not shown), such as speakers, printers, etc.","The computer  may operate in a networked environment using logical connections via wired and\/or wireless communications to one or more remote computers, such as a remote computer(s) . The remote computer(s)  can be a workstation, a server computer, a router, a personal computer, portable computer, microprocessor-based entertainment appliance, a peer device or other common network node, and typically includes many or all of the elements described relative to the computer , although, for purposes of brevity, only a memory\/storage device  is illustrated. The logical connections depicted include wired\/wireless connectivity to a local area network (LAN)  and\/or larger networks, e.g., a wide area network (WAN) . Such LAN and WAN networking environments are commonplace in offices and companies, and facilitate enterprise-wide computer networks, such as intranets, all of which may connect to a global communications network, e.g., the Internet.","When used in a LAN networking environment, the computer  is connected to the local network  through a wired and\/or wireless communication network interface or adapter . The adapter  may facilitate wired or wireless communication to the LAN , which may also include a wireless access point disposed thereon for communicating with the wireless adapter .","When used in a WAN networking environment, the computer  can include a modem , or is connected to a communications server on the WAN , or has other means for establishing communications over the WAN , such as by way of the Internet. The modem , which can be internal or external and a wired or wireless device, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the computer , or portions thereof, can be stored in the remote memory\/storage device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.","The computer  is operable to communicate with any wireless devices or entities operatively disposed in wireless communication, e.g., a printer, scanner, desktop and\/or portable computer, portable data assistant, communications satellite, any piece of equipment or location associated with a wirelessly detectable tag (e.g., a kiosk, news stand, restroom), and telephone. This includes at least Wi-Fi and Bluetooth\u2122 wireless technologies. Thus, the communication can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices.","Wi-Fi, or Wireless Fidelity, allows connection to the Internet from a couch at home, a bed in a hotel room, or a conference room at work, without wires. Wi-Fi is a wireless technology similar to that used in a cell phone that enables such devices, e.g., computers, to send and receive data indoors and out; anywhere within the range of a base station. Wi-Fi networks use radio technologies called IEEE802.11(a, b, g, etc.) to provide secure, reliable, fast wireless connectivity. A Wi-Fi network can be used to connect computers to each other, to the Internet, and to wired networks (which use IEEE802.3 or Ethernet). Wi-Fi networks operate in the unlicensed 2.4 and 5 GHz radio bands, at an 11 Mbps (802.11a) or 54 Mbps (802.11b) data rate, for example, or with products that contain both bands (dual band), so the networks can provide real-world performance similar to the basic 9BaseT wired Ethernet networks used in many offices.","Referring now to , there is illustrated a schematic block diagram of an exemplary computer compilation system operable to execute the disclosed architecture. The system  includes one or more client(s) . The client(s)  can be hardware and\/or software (e.g., threads, processes, computing devices). The client(s)  can house cookie(s) and\/or associated contextual information by employing the invention, for example.","The system  also includes one or more server(s) . The server(s)  can also be hardware and\/or software (e.g., threads, processes, computing devices). The servers  can house threads to perform transformations by employing the invention, for example. One possible communication between a client  and a server  can be in the form of a data packet adapted to be transmitted between two or more computer processes. The data packet may include a cookie and\/or associated contextual information, for example. The system  includes a communication framework  (e.g., a global communication network such as the Internet) that can be employed to facilitate communications between the client(s)  and the server(s) .","Communications can be facilitated via a wired (including optical fiber) and\/or wireless technology. The client(s)  are operatively connected to one or more client data store(s)  that can be employed to store information local to the client(s)  (e.g., cookie(s) and\/or associated contextual information). Similarly, the server(s)  are operatively connected to one or more server data store(s)  that can be employed to store information local to the servers .","What has been described above includes examples of the various embodiments. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the embodiments, but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly, the detailed description is intended to embrace all such alterations, modifications, and variations that fall within the spirit and scope of the appended claims.","In particular and in regard to the various functions performed by the above described components, devices, circuits, systems and the like, the terms (including a reference to a \u201cmeans\u201d) used to describe such components are intended to correspond, unless otherwise indicated, to any component which performs the specified function of the described component (e.g., a functional equivalent), even though not structurally equivalent to the disclosed structure, which performs the function in the herein illustrated exemplary aspects of the embodiments. In this regard, it will also be recognized that the embodiments includes a system as well as a computer-readable medium having computer-executable instructions for performing the acts and\/or events of the various methods.","In addition, while a particular feature may have been disclosed with respect to only one of several implementations, such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore, to the extent that the terms \u201cincludes,\u201d and \u201cincluding\u201d and variants thereof are used in either the detailed description or the claims, these terms are intended to be inclusive in a manner similar to the term \u201ccomprising.\u201d"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
