---
title: Improving performance of database queries
abstract: A system, method, and program for improving the performance for SQL queries. Multidimensional metadata associated with a cube model metadata object is obtained. One or more summary tables to be built are automatically identified based on the obtained multidimensional metadata. One or more indexes to create are automatically identified based on the obtained multidimensional metadata.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07895191&OS=07895191&RS=07895191
owner: International Business Machines Corporation
number: 07895191
owner_city: Armonk
owner_country: US
publication_date: 20030409
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Additional Implementation Details"],"p":["This application is related to commonly owned and co-pending application Ser. No. 10\/341,763 entitled \u201cMETHOD, SYSTEM, AND PROGRAM FOR SPECIFYING MULTIDIMENSIONAL CALCULATIONS FOR A RELATIONAL OLAP ENGINE,\u201d by N. Colossi, et al., filed on Jan. 13, 2003, and which is incorporated by reference herein in its entirety.","1. Field of the Invention","The present invention is directed to creating a consistent copy of data.","The present invention is related to improving the performance of database queries.","2. Description of the Related Art","On-line analytical processing (OLAP) has become increasingly popular. Instead of reviewing piles of static reports printed on green-bar paper, an OLAP analyst can explore business results interactively, dynamically adjusting the view of the data and asking questions and getting answers almost immediately. This freedom from static answers to fixed questions on a fixed schedule allows business analysts to operate more effectively and to effect improvements in business operations.","Nigel Pendse introduced the term \u201cFASMI\u201d to characterize OLAP systems. The FASMI characteristics are: Fast, Analysis, Shared, Multidimensional, and Information. For further information, see N. Pendse, \u201cWhat Is OLAP?\u201d The OLAP Report.","As for fast, in keeping with the spirit of the \u201c0\u201d in OLAP, such systems need to provide results very quickly usually in just a few seconds, and seldom in more than 20 or 30 seconds. This level of performance is key in allowing analysts to work effectively without distraction.","As for analysis, considering the \u201cA\u201d in OLAP, OLAP systems generally provide rich analytic functions appropriate to a given application, with minimal programming.","As for shared, an OLAP system is usually a shared resource. This means that there is a requirement for OLAP systems to provide appropriate security and integrity features. Ultimately, this can mean providing different access controls on each cell of a database.","As for multidimensional, multidimensionality is the primary requirement for an OLAP system. OLAP products present their data in a multidimensional framework. Dimensions are collections of related identifiers, or attributes (product, market, time, channel, scenario, or customer, for example) of the data values of the system. The identifiers (\u201cThe Lord of the Rings-DVD,\u201d \u201cSan Jose, Calif.,\u201d \u201c2002,\u201d \u201cRetail Rental,\u201d and \u201cJohn Q. Public,\u201d for example) belonging to the collection for a particular dimension generally have some sort of structure, such as hierarchical. Sometimes there is more than one natural structure for these identifiers.","The multidimensional characteristic means that an OLAP system can quickly switch among various orientations of dimensions, as well as among various subsets and structural arrangements of a dimension. Because of the multidimensional nature of OLAP systems, the collections of data that they implement are referred to as cubes. As for information, OLAP systems store and calculate information. Data for OLAP systems often come from one or more operational systems. Analytical models are applied to these data, and the results are either stored in the system or generated at query time. The quantity of information that a particular OLAP system can manage is one characteristic of that system.","Enterprises have been storing multidimensional data, using a star or snowflake schema, in relational databases for many years. Over time, relational database vendors have added optimizations that enhance query performance on these schemas. During the 1990s many special purpose databases were developed that could handle added calculational complexity and that generally performed better than relational engines.","OLAP systems perform analysis of data that typically comes from relational databases. There are different types of OLAP systems: relational OLAP (ROLAP), hybrid OLAP (HOLAP), and multidimensional OLAP (MOLAP). The different types of OLAP systems vary in the degree to which they use relational databases. ROLAP systems issue queries directly against relational databases and analyze the results. MOLAP products have a proprietary data store, which they populate by reading from a relational database. Then, the MOLAP product responds to queries by reading from the data store. HOLAP products route selected queries to the relational database to obtain data that does not fit in the limited MOLAP data store.","Multidimensional OLAP (MOLAP) refers to the family of OLAP systems in which special-purpose file systems or indexes are used to store cube data. Express Web Publisher, Essbase\u2122, TM1, and Pilot Suite are a few examples of products based on special-purpose storage and indexing technology. Microsoft's OLAP offering also includes a MOLAP engine. These systems are often read-only systems that are loaded with base data periodically, then derived results are calculated, stored, and indexed. Scalability of MOLAP systems is often limited by the size of the batch window within which derived results are calculated and stored. To improve scalability, such systems often have a means for deferring calculation of some derived results until query time.","For relational OLAP (ROLAP), star schemas have been used for many years as a means for representing multidimensional data in a relational database. Many commercial software development companies, such as MicroStrategy, Brio, Business Objects, Metacube, Hyperion, and Metaphor, have developed batch or interactive multidimensional reporting and exploration interfaces for relational star schemas. These systems were all designed and implemented before super aggregate operators were added to the Structured Query Language (SQL) language definition.","In particular, until a few years ago, relational databases allowed the calculation of aggregates at only a single level per query. For example, one SELECT statement with a GROUP BY clause would be used to retrieve a result set at a quarter level (i.e., for a set of quarters), while another SELECT statement with a GROUP BY clause would be used to retrieve a result set at a month level (i.e., for a set of months). This forced relational OLAP systems to run multiple queries against the database in order to calculate cells at varying levels.","To facilitate OLAP-type query creation and provide more advanced optimizations, a DB2\u00ae Relational Database Management System (RDBMS), available from International Business Machines Corporation, implemented three new super aggregate operators that were added to the SQL standard to allow a single query to generate multiple aggregates: ROLLUP, CUBE, and GROUPING SETS. These super aggregate operators are extensions to the GROUP BY clause and specify that aggregates be generated at multiple levels. For example, one SELECT statement may be used to obtain a result set of calculations of aggregates at multiple levels (e.g., both quarter and month).","Note that these super aggregate operators are more than mere shorthand for generating multiple grouping sets. Because multiple grouping sets are requested in a single statement, the DB2\u00ae RDBMS can build an execution plan that generates the grouping sets in such a way that each input row needed for the calculation is referenced only once. This can result in performance improvements of orders of magnitude, especially when the set of input rows does not fit in the buffer pool (i.e., cache).","Prior art systems are designed to produce multidimensional reports showing results with different levels of granularity by issuing multiple queries. Multiple result sets are obtained for the multiple queries, and the result sets are merged to form a single report. Such systems depend on some sort of description (metadata) of the roles for the tables and columns in a star schema for generating the necessary SQL to retrieve the data to produce the multidimensional reports. The precise metadata varies from product to product.","Multidimensional on-line analytical processing (OLAP) systems (e.g., from companies such as Hyperion, Cognos, and Microsoft) are designed to return multidimensional result sets naturally, when given sets of members for each edge of a multidimensional cube. The multidimensional OLAP systems are also designed to compute some or all of the results in advance of any query.","Multidimensional analysis has been done using SQL since the introduction of relational databases, but relational OLAP systems have not been able to return multidimensional results sets naturally or compute some or all of the results in advance of a query.","OLAP systems issue multidimensional queries. These queries may request data to be aggregated at various levels of the dimension hierarchies. The relational database system reads the data and aggregates the data to the appropriate level. In some cases, most of the time spent in responding to a query is spent reading and aggregating data rather than in returning the data. Relational databases provided materialized views in which data can be aggregated at particular levels and made persistent. A materialized view is a table that represents a view and that is generated prior to receiving a query referencing the view. If a query requests data from that level, the RDBMS can directly read the data from the materialized view rather than reading and aggregating large quantities of lower level data. If queries refer to data that is in higher levels of the hierarchies than that already aggregated, the RDBMS may be able to make use of the existing aggregation. The use of materialized views to store pre-calculated aggregates improves performance.","Determining the most cost effective materialized views to be created is based on several factors (e.g., overhead in terms of storage vs. query performance improvement) and is a complex and time consuming task.","Thus, there is a need in the art to improve the performance of a relational database management system (RDBMS) used by an OLAP system.","Provided are a method, system, and program improving the performance for SQL queries. Multidimensional metadata associated with a cube model metadata object is obtained. One or more summary tables to be built are automatically identified based on the obtained multidimensional metadata. One or more indexes to create are automatically identified based on the obtained multidimensional metadata.","In the following description, reference is made to the accompanying drawings which form a part hereof and which illustrate several implementations of the present invention. It is understood that other implementations may be utilized and structural and operational changes may be made without departing from the scope of the present invention.","A. Multidimensional Metadata Introduction","In certain implementations, the invention provides multidimensional metadata objects and techniques for using the multidimensional metadata objects. For ease of reference, the invention will be referred to as an \u201cOLAP multidimensional metadata system \u201d herein, and multidimensional metadata objects will be referred to as \u201cmetadata objects.\u201d","In certain implementations, the OLAP multidimensional metadata system  is implemented in a DB2\u00ae Universal Database (UDB) relational database management system (RDBMS), available from International Business Machines Corporation. Although the present specification describes the use of IBM's DB2\u00ae UDB RDBMS software, those skilled in the art will recognize that the present invention can use other RDBMS software, such as RDBMS software available from Oracle, IBM Informix, Sybase. Additionally, the present invention can run on computers using various operating systems, such as IBM z\/OS\u00ae, IBM AIX\u00ae, Microsoft Windows\u00ae 2000, Microsoft Windows\u00ae XP, or Linux, Solaris, HP-UX.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 1","b":["110","120","110","130","130","140","130","140"]},"An OLAP multidimensional metadata system  includes the multidimensional stored procedure , which includes advisor component  (e.g., a stored procedure application programming interface (API)), a user interface , and multidimensional metadata objects . The advisor component  makes recommendations for optimization of database queries. In particular, the advisor component  reads metadata from metadata objects , analyzes the metadata, and outputs recommended SQL for summary tables.","Note that summary tables may also be referred to as \u201cautomated summary tables\u201d (ASTs). A summary table is a particular type of materialized view in which aggregations are used. Moreover, a summary table is a hybrid of a view and a table. A summary table is defined like a view, but is physical like a table. Just like regular tables, a summary table can be optimized. A summary table can have indexes, be partitioned, and exist in a tablespace. The process of populating a summary table may be a lengthy process and, in certain implementations, is integrated with other data warehouse maintenance. In certain implementations, when data is added to a warehouse (e.g., the latest sales data), then the summary tables will be updated also. There are two ways to update summary tables. The first is to rebuild the entire summary table. The second mechanism is to incrementally maintain summary tables. In this approach, the RDBMS  will automatically update the summary table based on modifications being made to the warehouse. In certain implementations, the RDBMS  supports incremental maintenance if the analytic used is SUM.","Components of the multidimensional stored procedure  (other than the advisor component ) create, describe, alter, drop, rename, validate, and import metadata objects . Optionally, a user interface  may be provided for a user or administrator to send commands to the advisor component .","In certain implementations, the OLAP multidimensional metadata system  provides an add-on feature for an RDBMS , such as DB2\u00ae Universal Database (referred to herein as DB2\u00ae UDB), that improves the ability of the RDBMS  to perform OLAP processing.","An OLAP system accesses data from the RDBMS  by generating SQL queries. In certain implementations, the OLAP system can either be a client system used directly by an end user or a server system that interacts with the end users systems. The invention streamlines the deployment and management of OLAP solutions, and improves the performance of OLAP tools and applications.","In particular, the OLAP multidimensional metadata system  provides new metadata objects . The new metadata objects  are stored in, for example, a database catalog (e.g., the DB2\u00ae UDB catalog) that describes the dimensional model and OLAP constructs of existing relational data. The database catalog provides a single repository from which OLAP applications can capture multidimensional metadata. In certain implementations, the metadata objects  may reside on a data store other than the database catalog or may reside across multiple data stores. With the information in the central repository, a database optimizer is able to use techniques specific to star schemas for optimizing the execution of queries.","With the metadata objects , the invention can optimize OLAP query performance by aggregating data in summary tables and by creating indexes. The OLAP multidimensional metadata system  also provides a metadata programming interface. In particular, the OLAP multidimensional metadata system  provides a SQL-based and extensible mark-up language (XML)-based application programming interface (API) for OLAP tools and application developers. Through, for example, Command Line Interface (CLI), Open Database Connectivity (ODBC), or Java Database Connectivity (JDBC\u2122) connections or by using, for example, embedded SQL to DB2\u00ae UDB, applications and tools can use a single stored procedure to create, modify, and retrieve metadata objects . In certain implementations, multiple stored procedures may provide the functionality for creating, modifying, and retrieving multidimensional metadata objects .","Metadata objects  describe relational information as intelligent OLAP structures, but the metadata objects  of the OLAP multidimensional metadata system  provided by the invention are different from traditional OLAP objects. The metadata objects  store metadata, meaning the metadata objects  store information about the data in the base tables. Metadata objects describe where pertinent data is located and can also describe relationships within the base data. For example, a facts metadata object is a specific metadata object that stores information about related measures, attributes and joins, but does not include the data specifically from the base fact table.","Metadata provides a new perspective from which to understand data. Without metadata objects , a database catalog only knows about metadata describing tables and column names and cannot store information about the meanings of the tables and columns or how the tables and columns relate to each other. With metadata objects , this information may be stored.","Each metadata object completes a piece of the big picture showing what the relational data means. Some metadata objects  act as a base to directly access relational data by aggregating data or directly corresponding to particular columns in relational tables. Other metadata objects  describe relationships between the base metadata objects  and link these base metadata objects  together. Ultimately, all of the metadata objects  can be grouped together by their relationships to each other, into a metadata object called a cube model. A cube model represents a particular grouping and configuration of relational tables. The purpose of a cube model is to describe OLAP structures to a given application or tool. A cube model groups dimensions and facts, and offers the flexibility of multiple hierarchies for dimensions. A cube model conveys the structural information needed by query design tools and applications that generate complex queries on star schema databases.","The multidimensional metadata object model is designed to describe the schemas used in relational databases to represent multidimensional data. One way to organize such data is by using a star or snowflake schema (in snowflake schemas the dimension tables are normalized). However, the model is flexible enough to handle any type of schema (e.g., more normalized schemas).","A.1 Multidimensional Metadata Overview","The multidimensional metadata enables maintenance of metadata about OLAP structures stored in data warehouses. This information was not previously available in the database catalog and frequently is not documented by data warehouse metadata repositories. Multidimensional metadata helps the data warehouse designer represent the structural relationship among tables and their columns. Once this metadata exists in the database catalog, other components of the RDBMS , such as a database optimizer (e.g., a DB2\u00ae UDB optimizer), can take advantage of the structural information and perform queries, against data described by these new metadata objects , faster. The metadata objects  can also assist business intelligence tools by providing the base structural information needed to generate multidimensional queries against the data warehouse. In order to capture OLAP structural information, the OLAP multidimensional metadata system  defines several new metadata objects . These metadata objects  are able to describe key aspects of schemas frequently used to model OLAP data, such as star-join and snowflake schemas.","Adding the metadata objects  to a database catalog provides full functionality and integration with other database components. The new metadata objects  are owned by a schema, in the same way as regular tables. Another design point for the metadata objects  is that most of them are independently useful. That is, the metadata objects  provide information about the underlying relational schema, whether or not the metadata objects  are included in a more complex multidimensional structure.","A cube model can be constructed in many ways, but is often built to represent a relational star schema or snowflake schema. A cube model based on a simple star schema is built around a central facts metadata object that describes aggregated relational data from a fact table. Measure metadata objects describe data calculations from columns in a relational table and are joined together to create the facts metadata object.  illustrates that a facts metadata object  and measure metadata objects ,  relate to relational data  in accordance with certain implementations of the invention.","Dimension metadata objects are connected to the facts metadata object in a cube model just as the dimension tables are connected to the fact table in a star schema. Columns of data from relational tables are represented by attribute metadata objects that are joined together to make up a dimension metadata object.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":"FIG. 3","b":["310","320","330","300","300","310","320","330","310","320","330","330"]},"Three joins join each dimension table , ,  to the central facts table  on the corresponding dimensional key attributes. In this example, the dimension tables , ,  are joined with the facts table  based on either the TimeID, ProductID, or RegionID attributes.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 4","b":["406","410","450","406","408","408","452","410","412","414","416","454","456","450"]},"Hierarchies store information about how the attributes within a dimension are related to each other and structured. As a metadata object, a hierarchy provides a way to calculate and navigate a dimension. Each dimension has a corresponding hierarchy with levels defined for each member attribute. For example, the Region dimension has a RegionH hierarchy with levels defined for the State and City attributes, and also references the CityPop AR attribute relationship. In a cube model, each dimension can have multiple hierarchies, but the example star schema has one hierarchy defined for each dimension.","In a star schema, all of the dimension metadata objects are connected in a star shape to a central facts metadata object to create a cube model. Join metadata objects can join tables to create a facts metadata object or a dimension metadata object. Join metadata objects can also act as glue within the cube model by joining facts metadata objects to dimension metadata objects. The dimension metadata objects have information about all of their component hierarchies, attributes, attribute relationships and related joins. Facts metadata objects have information about all of their component measures, attributes, and related joins.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 5","b":["500","550","510","512","514","516","518","520"]},"Cube model metadata objects are flexible metadata objects whose components may be reused to create more precise cube metadata objects for specific applications. For example, a cube model metadata object may have 37 facts, but one cube metadata object generated from the cube model metadata object may eliminate one or more dimension metadata objects, one or more levels of a dimension metadata object, and\/or one or more measures metadata objects.","In addition to cube model metadata objects, there is a more specific metadata object called a cube metadata object. A cube metadata object is the closest metadata object to an OLAP conceptual cube. A cube metadata object is a specific instance or subset of a cube model metadata object. A cube metadata object has a specific set of similar but more restrictive metadata objects derived from the parent cube model metadata object including: cube dimensions, cube hierarchies, and cube facts. For example, a RegionCubeDim is a cube dimension that is a subset of attributes derived from the Region dimension. RegionCubeDim references the State and City attributes, but does not reference the City_Population attribute or CityPop AR attribute relationship. The RegionCubeDim references the Region dimension that it scopes and all of the structural information, including the join information, stays with the cube model Region dimension.","In certain implementations, a cube metadata object has one cube hierarchy defined per cube dimension, while a dimension metadata object can have many hierarchies defined for the cube model metadata object. This structural difference between a cube metadata object and a cube model metadata object allows retrieval of a cube metadata object with a single SQL statement.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 6","b":["600","610","620","600","610","600","620","620"]},"An example is provided for better understanding of the invention. The example is based on a common structure used in data marts, a star-join schema. For the star join schema, instances of the metadata objects are created based on the Base\/Relational, Multidimensional, and OLAP layers.  illustrates a simple star-join schema consisting of a fact table , Fact, and three dimension tables Time , Product , and Region  in accordance with certain implementations of the invention.","Existing database catalogs typically store table and column names. The information about what roles these tables and columns play, and how the tables and columns relate to each other is lost. However, with the OLAP multidimensional metadata system , this information is captured by creating metadata objects.",{"@attributes":{"id":"p-0094","num":"0093"},"figref":"FIG. 7","b":"700"},{"@attributes":{"id":"p-0095","num":"0094"},"figref":"FIG. 8","b":["800","810","820","800","810","820","820","850","860","870","850","860","870","850","860","870"]},{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 9","b":["900","900","910","920","930"]},{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 10","b":["1000","1010","1020","1030","1000"]},"The OLAP layer is composed by cube model and cube metadata objects. A cube model metadata object describes the facts and dimensions that are interesting to a given application. The dimensions of a cube model metadata object can have multiple hierarchies defined, which makes a cube model metadata object a very flexible structure. A cube metadata object is derived from a cube model metadata object, and so all cube dimensions, cube hierarchies, and cube facts metadata objects are derived from the cube model metadata object. A difference between a cube model metadata object and a cube metadata object is that in a cube metadata object one hierarchy is defined per dimension, which makes it possible to retrieve a cube metadata object with a single SQL statement.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":["FIG. 11","FIG. 3"],"b":["1100","1150"]},"A.2 Metadata Object Properties","Each metadata object has a set of general properties in addition to metadata object-specific properties. The general properties are used to identify the metadata object instances, to describe the usage or role of the metadata object instances, and to track metadata object instance changes. In certain implementations, the metadata objects are named using a schema in the same way that other database metadata objects are named. Full qualifications of the metadata object may be required when the default user name schema is not desired.","Table 1 describes the general properties that exist for all metadata objects in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0102","num":"0101"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Property","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Name","Name of the metadata object."]},{"entry":[{},"Schema","Schema that owns the metadata object."]},{"entry":[{},"Business","Name presented to the end user. This"]},{"entry":[{},"name","name may be used in graphic user interfaces"]},{"entry":[{},{},"as a name more meaningful to the end user."]},{"entry":[{},"Comments","Textual description or comment on the"]},{"entry":[{},{},"nature or usage of the metadata object."]},{"entry":[{},"Create time","Time the metadata object was created."]},{"entry":[{},"Creator","User (schema) that defined the metadata object."]},{"entry":[{},"Modify time","Time the metadata object was last modified."]},{"entry":[{},"Modifier","User (schema) that performed the modification."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In addition to a common set of general properties shared by all metadata objects, each metadata object has a set of metadata object specific properties. These metadata object specific properties describe the components and qualities that define the metadata object.","The cube model is a representation of a logical star schema. The cube model is a grouping of relevant dimension metadata objects around a central facts metadata object. Each dimension can have multiple hierarchies, which increases the flexibility of the cube model. The structural information about how to join the tables used by the facts and dimension metadata objects is stored in the cube model. Also stored in the cube model is enough information to retrieve OLAP data. Other reporting and OLAP tools that understand the cube model and can handle multiple hierarchies of a specific dimension can benefit from the use of a cube model.","Cube models define a complex set of relationships and can be used to selectively expose relevant facts and dimensions to an application. Each join metadata object connecting a dimension to the central facts metadata object is stored with the corresponding dimension as a set. Subsets of cube model components can be used by many cubes for different analysis purposes.","An empty cube model may be created that does not have a facts metadata object or any dimensions. However, the cube model is completed before creating a corresponding cube. The OLAP multidimensional metadata system  validates a cube model by ensuring that the cube model includes a facts metadata object, at least one dimension, and joins between the existing facts and dimensions, and that all of the attributes reference valid tables. A hierarchy is not required to consider a cube model complete, however, to be able to define a cube from a cube model, at least one hierarchy per dimension is defined.","Each metadata object has a set of metadata object-specific properties that describe the components and qualities that define the metadata object. The metadata object specific properties of a cube model are described Table 2 in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0108","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Property","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Facts","Facts used in the cube model."]},{"entry":[{},"Set of","Dimensions that are used in the cube"]},{"entry":[{},"(dimension,","model and their corresponding joins."]},{"entry":[{},"join)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The facts metadata object groups related measures which are interesting to a given application. Multiple relational fact tables can be joined on specific attributes to map additional related measures. The facts metadata object stores information about the attributes used in fact to dimension joins, and the attributes and joins used to map the additional measures across multiple database tables. Therefore, in addition to a set of measures, a facts metadata object stores a set of attributes and a set of joins. A facts metadata object is used in a cube model as the center of a star schema.","The facts metadata object plays the role of a fact table in a star schema. Just as a fact table does, a facts metadata object gathers measurement entities, represented in the database catalog by measures. These need not come from the same table, allowing the designer to group measures as required for any OLAP application.","The metadata object specific properties of a facts metadata object are described in Table 3 in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0112","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Property","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Set of","Set of all related measures in"]},{"entry":[{},"measures","the facts metadata object."]},{"entry":[{},"Set of","Set of all attributes used in"]},{"entry":[{},"attributes","the facts metadata object."]},{"entry":[{},"Set of joins","Set of all joins needed to join all"]},{"entry":[{},{},"of the specified measures and attributes."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The dimension metadata object plays the role of a dimension table in a star schema. Dimensions group related attributes, which together describe some aspect of one or more measures. Thus, the dimension metadata object provides a way to categorize a set of related attributes that together describe one aspect of a measure. Dimensions are used in cube models to organize the data in the facts metadata object according to logical categories such as Region, Product, or Time. Related attributes and the joins needed to group these attributes together are defined in the dimension metadata object specific properties.","Dimensions reference one or more hierarchies. Hierarchies describe the relationship and structure of the dimensional attributes and can be used to drive navigation and calculation of the dimension.","Dimensions also have a type that describes whether the dimension is time oriented. For example, a dimension called Time might contain attributes such as Year, Quarter, and Month, and would be a time type. Another dimension called Region might contain attributes such as Country, State, City, and Population and would be a regular type. Type information can be used by applications to intelligently and appropriately perform time related functions.","The metadata object specific properties of dimension metadata objects are described in the following Table 4 in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0117","num":"0116"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 4"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Property","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Set of","Set of all attributes used in the dimension."]},{"entry":[{},"attributes"]},{"entry":[{},"Set of joins","Set of all joins needed to join all of the"]},{"entry":[{},{},"specified attributes. The joins needed to join"]},{"entry":[{},{},"the dimension tables are specified here."]},{"entry":[{},"Set of","Set of hierarchies that apply to the dimension."]},{"entry":[{},"hierarchies"]},{"entry":[{},"Type","Dimension type."]},{"entry":[{},"[REGULAR,"]},{"entry":[{},"TIME]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"A hierarchy defines relationships among a set of one or more attributes within a given dimension of a cube model. Defining these relationships provides a navigational and computational means of traversing a given dimension. Multiple hierarchies can be defined for a dimension of a cube model. The hierarchy metadata object also references a set of attribute relationships that link attributes in the hierarchy to other related attributes. The attributes that are directly related by an attribute relationship can be queried as part of the hierarchy. For example, a hierarchy for a Region dimension can have a City attribute, and an attribute relationship can link City to a City_Population attribute. This hierarchy can include City_Population information in a query that includes City.","A hierarchy describes parent-child relationships among attributes. This information is referred to by a dimension to indicate how dimension members can be browsed, and how to aggregate data in the dimension.","The hierarchy type describes the relationship among the attributes within the hierarchy. The following four hierarchy types are supported: balanced, unbalanced, ragged, and network.",{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 12","b":["1200","1200","1210","1220","1230"]},{"@attributes":{"id":"p-0122","num":"0121"},"figref":"FIG. 13","b":["1300","1300"]},"A ragged hierarchy is one in which each level has a consistent meaning, but the branches have inconsistent depths because at least one member attribute in a branch level is unpopulated. A ragged hierarchy can represent a geographic hierarchy in which the meaning of each level such as city or country is used consistently, but the depth of the hierarchy varies.  illustrates a ragged hierarchy  in accordance with certain implementations of the invention. The ragged hierarchy  shows a geographic hierarchy that has Continent, Country, Province\/State, and City levels defined. One branch has North America as the Continent, United States as the Country, California as the Province\/State, and San Francisco as the City. However the hierarchy  becomes ragged when one member does not have an entry at all of the levels. For example, another branch has Europe as the Continent, Greece as the Country, and Athens as the City, but has no entry for the Province\/State level because this level is not applicable to Greece. In this example, the Greece and United States branches descend to different depths, creating a ragged hierarchy .","A network hierarchy is one in which the order of levels is not specified, but in which levels do have semantic meaning.  illustrates a network hierarchy  that describes product attributes such as Color, Size, and PackageType in accordance with certain implementations of the invention. Because the attribute levels do not have an inherent parent-child relationship, the order of the levels may vary. A widget company might have member entries, such as white for Color, small for Size, and shrink wrap for PackageType. A second member entry might have red for Color, large for Size, and box for PackageType.","A hierarchy (balanced, unbalanced, ragged, or network) also specifies deployment mechanisms for the hierarchy. A deployment mechanism defines how to interpret the attributes of a hierarchy. The following two deployment mechanisms are supported: standard and recursive.","The standard deployment mechanism uses the level definitions of the hierarchy, where each attribute in the hierarchy defines one level. For example, a balanced hierarchy for a Time dimension would be organized by each defined level including Year, Quarter, and Month. Standard deployment can be used with all four hierarchy types. Table 5 shows how some of the balanced hierarchy attributes for a Time dimension are organized using a standard deployment in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0127","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 5"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Year","Quarter","Month"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"2001","1 quarter","January"]},{"entry":[{},"2001","1 quarter","February"]},{"entry":[{},"2001","1 quarter","March"]},{"entry":[{},"2002","1 quarter","January"]},{"entry":[{},"2002","1 quarter","February"]},{"entry":[{},"2002","1 quarter","March"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The recursive deployment mechanism uses the inherent parent-child relationships between the attributes of the hierarchy. An unbalanced hierarchy using a recursive deployment is represented as parent-child attribute pairs. For example, Table 6 shows the attribute pairs for the unbalanced hierarchy describing an organization chart shown in  in accordance with certain implementations of the invention. The parent-child attribute pairs include: chief executive officer and executive secretary, chief executive officer and chief operating officer, chief operating officer and director of communications, director of communications and communications specialist. Recursive deployment may be used with an unbalanced hierarchy.",{"@attributes":{"id":"p-0129","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 6"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Parent Attribute","Child Attribute"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Chief executive officer","Executive secretary"]},{"entry":[{},"Chief executive officer","Chief operating officer"]},{"entry":[{},"Chief operating officer","Director of communications"]},{"entry":[{},"Director of communications","Communications specialist"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The metadata object specific properties of a hierarchy metadata object are described in the following Table 7 in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0131","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 7"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Property","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"List of attributes","Ordered list of attributes from the"]},{"entry":[{},{},"top to the bottom of a hierarchy. In"]},{"entry":[{},{},"the case of a recursive hierarchy, two"]},{"entry":[{},{},"attributes are used as parent and child."]},{"entry":[{},"Set of attribute","Set of all attribute relationships that link"]},{"entry":[{},"relationships","hierarchy attributes to other attributes."]},{"entry":[{},"Type","Hierarchy type."]},{"entry":[{},"[BALANCED,"]},{"entry":[{},"UNBALANCED,"]},{"entry":[{},"RAGGED,"]},{"entry":[{},"NETWORK]"]},{"entry":[{},"Deployment","Hierarchy deployment."]},{"entry":[{},"[STANDARD,"]},{"entry":[{},"RECURSIVE]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"A measure metadata object defines a measurement entity and is used in facts metadata objects. Measures become meaningful within the context of a dimension. For example, a revenue of 300 is not meaningful by itself. When a revenue measure is put in the context of a dimension, such as Region, the measure becomes meaningful. For example, the revenue for Vermont is 300. Common examples of measure metadata objects are Revenue, Cost, and Profit.","The measure object makes explicit the existence of a measurement entity. Measures are defined by one or more SQL expression which can be as simple as a mapping to a table column, or can involve multiple columns and other measures or attributes. For each measure, a list of aggregations is defined for calculations in the context of a cube model, or cube. Each aggregation in the list specifies a aggregation function, such as SUM, COUNT, MIN, MAX, and a list of dimension in which the aggregation function is applied. An empty list of dimensions in an aggregation indicates that all remaining dimensions, non-explicitly referenced in the measure, are to be used. A measure will have more than one SQL expression template when the first aggregation function used requires more than one input, such as CORRELATION. A measure can have an empty list of aggregations when it has a single SQL expression template, and it only refers to other measures. In this case, the aggregation of the referenced measures take place. Measures and attributes share the same name space, meaning that the names, when fully qualified by a schema, have to be unique among measures and attributes. Common examples for measures are Sales, Costs, Profit, etc.","Measures are defined by the aggregation of SQL expressions. Table columns, attributes and measures are mapped to a template to build SQL expressions (i.e., a \u201cSQL expression template\u201d). The resulting SQL expressions are then used as input for the first aggregation function of the measure. If a measure has more than one aggregation, the aggregation functions are performed in the order they are listed, with each subsequent aggregation taking the result of the previous aggregation as input. If the SQL expression of the measure metadata object only references other measures, the aggregation function is optional. The aggregation function is optional because the referenced measures provide the aggregation.","A SQL expression of a measure is created by the combination of two properties: a SQL expression template and a list of columns, attributes, and measures. The SQL expression template uses a token notation where {$$n} is the token and n references a specific column, attribute, or measure from the list. The list of columns, attributes, and measures is ordered, and the position in the list of a column, attribute or measure corresponds to the token \u201cn\u201d value.","SQL expressions are used as input to the first aggregation. Each aggregation specifies a function that is applied to a corresponding list of dimensions. The aggregation function can be any aggregation function supported by the underlying database, including, for example, SUM, COUNT, MIN, MAX, and CORRELATION. In certain implementations, each dimension is aggregated once by the measure metadata object. If the list of dimensions is empty, the aggregation function is applied to all dimensions in the cube or cube model that are not specifically being used by another aggregation in the list.","An example of a simple measure is Revenue. The Revenue measure can be created for a cube model with three dimensions: Product, Market and Time. Revenue has a SQL expression template (template=\u201c{$$1}\u201d), which represents a simple mapping to the column specified in the one item list of columns, attributes, and measures, where list=\u201cColumn Fact.Rev\u201d. The aggregation list is (SUM, <NULL>) where SUM is the aggregation function, and <NULL> is an empty list of dimensions. The SQL expression is used as input for the SUM aggregation function, resulting in the SQL: SUM(Fact.Rev).","A more complicated measure, Profit, might have a SQL expression template (template=\u201c{$$1}-{$$2}\u201d), where the list of attributes, columns, and measures is list=\u201cMeasure Revenue, Column Fact.Cost\u201d. Replacing the tokens with the correct references, the SQL expression becomes: \u201cRevenue\u2014Fact.Cost\u201d. Expanding the revenue measure reference to its column reference, the SQL expression becomes: \u201cFact.Rev\u2014Fact.Cost\u201d. The aggregation list of the Profit measure is: (SUM, <NULL>). Using the profit SQL expression as input for the SUM aggregation function, the SQL for the Profit measure is: SUM(Fact.Rev\u2014Fact.Cost).","If the measure has an aggregation function, such as CORRELATION, that requires two or more parameters, the measure will have two or more SQL expressions.","Measures also have a data type that is based on SQL data types. The OLAP multidimensional metadata system  automatically determines the data type of the measure. Additionally, measures and attributes share the same name space. Therefore, each name, when fully qualified by a schema, is unique among measures and attributes. The metadata object specific properties of a measure metadata object are described in the following Table 8 in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0141","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Property","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["List of SQL","List of SQL expression templates used as"]},{"entry":["expression templates","input for the first aggregation function of the"]},{"entry":[{},"measure. The templates reference columns,"]},{"entry":[{},"attributes, and measures by using a \u2018{$$n}\u2019"]},{"entry":[{},"notation. In the template, n is an ordinal"]},{"entry":[{},"number corresponding to the list of columns,"]},{"entry":[{},"attributes, and measures."]},{"entry":["List of columns,","For each SQL expression template, an"]},{"entry":["attributes, and","ordered list of columns, attributes, and"]},{"entry":["measures","measures is supplied. These columns,"]},{"entry":[{},"attributes, and measures are applied as"]},{"entry":[{},"specified in the SQL expression template."]},{"entry":["List of aggregations","List of aggregations that specify how a"]},{"entry":["(function, list of","measure is calculated. Each aggregation is"]},{"entry":["dimensions)","composed by a SQL aggregation function"]},{"entry":[{},"and an optional list of dimensions to apply"]},{"entry":[{},"the function to."]},{"entry":["Data type (schema,","Determines the data type of the attribute."]},{"entry":["name, length, scale)","Based on SQL data types, and composed"]},{"entry":[{},"by data type schema, name, length, and"]},{"entry":[{},"scale."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"An attribute represents the basic abstraction of the database table columns. An attribute is defined by a SQL expression that can be a simple mapping to a table column, can involve multiple columns and other attributes, and can involve all functionalities of the underlying database, such as user-defined functions. In certain implementations, when other attributes are used in the defining SQL expression, the other attributes cannot form attribute reference loops. For example, if Attribute A references Attribute B, then Attribute B cannot reference Attribute A.","A SQL expression definition of an attribute is created by the combination of two properties: a SQL expression template and a list of columns and attributes. The SQL expression template uses a token notation where {$$n} is the token with n referencing a specific column or attribute from the list. The list of columns and attributes is ordered, and position in the list of a column, attribute or measure corresponds to the token \u201cn\u201d value.","For example, the SQL expression template (template=\u201c{$$1} \u2225\u2018 \u2019\u2225 {$$2}\u201d) can be used with a corresponding list such as list=\u201cColumn CUSTOMER.FIRSTANME, Attribute LastName\u201d to concatenate customers' first and last names with a space between them. Replacing the SQL expression template tokens with the correct list references, the SQL expression is: \u201cCustomer.FirstName \u2225\u2018 \u2019\u2225 LastName\u201d. The attribute reference is further expanded to a column reference to form the SQL expression:\n\n","An attribute can serve multiple roles in the design of a data warehouse or data mart. The roles that an attribute can serve are: level, description, dimensional attribute, dimensional key, or key.","A level attributed is used in hierarchies. Examples of common level attributes are: Year and Quarter, State and City. A description attribute is used in a description type of attribute relationship and associates additional descriptive information to another attribute. For example, a table called Product might have an attribute with a product code and a description attribute with a textual description. The dimensional attribute is used in a dimensional type of attribute relationship and defines specific characteristics and qualities of another attribute. Examples of common dimensional attributes are: Population, Size, and Weight. The dimensional key attribute is used to join facts and dimension metadata objects and represents the primary key in a dimension table, or a foreign key from a dimension table to be used in a fact table. The key attribute is used to join tables within a facts or dimension metadata object. Key attributes are often used in a snowflake schema.","Attributes and measures share the same name space. Therefore, each name, when fully qualified by a schema, is unique among attributes and measures. Attribute and measure metadata objects are abstractions of a relational database column. However, they are defined by an SQL expression that can include multiple columns. Measures are more specialized than attributes-they include aggregation functions (column functions) that are used to calculate higher-level summaries from lower-level data.","Table 9 describes the metadata object specific properties that define an attribute metadata object in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0149","num":"0149"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Property","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SQL expression","SQL expression that defines the attribute. The"]},{"entry":["template","SQL expression template references columns"]},{"entry":[{},"and attributes by using a{$$n} notation,"]},{"entry":[{},"where n is an ordinal number corresponding"]},{"entry":[{},"to the list of columns and attributes."]},{"entry":["List of columns","Ordered list of all columns and attributes"]},{"entry":["and attributes for","composing the attribute. These columns and"]},{"entry":["SQL","attributes are applied as specified in the SQL"]},{"entry":["expression","expression template."]},{"entry":["Data type","Determines the data type of the attribute."]},{"entry":["(schema, name,","Based on SQL data types, and composed by"]},{"entry":["length, scale)","data type schema, name, length, and scale."]},{"entry":["Role [LEVEL,","Roles that the attribute serves."]},{"entry":"DESCRIPTION,"},{"entry":"DIMATTR,"},{"entry":"DIMKEY, KEY]"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"An attribute relationship describes relationships of attributes in general. The relationships are described by a left and a right attribute, a type, a cardinality, and whether or not the relationships determine a functional dependency. The type describes what the role of the right attribute is with respect to the left attribute. For example, a ProductName right attribute describes a ProductCode left attribute. The relationship type between ProductName and ProductCode is DESCRIPTION. The cardinality describes how the instances of the left and right attributes are related and it is interpreted based on cardinality. In a 1:1 cardinality, there is at most one left attribute instance for each right attribute instance, and at most one right attribute instance for each left attribute instance. In a 1:N cardinality, there is at most one left attribute instance for each right attribute instance, and any number of right attribute instances for each left attribute instance. In a N:1 cardinality, there is any number of left attribute instances for each right attribute instance, and at most one right attribute instance for each left attribute instance. In a N:N cardinality, there is any number of left attribute instances for each right attribute instance, and any number of right attribute instances for each left attribute instance.","The functional dependency property tells whether the attribute relationship can also be used as a functional dependency. A functional dependency defines a functional relationship between two attributes. For example, a functional dependency can be defined between attributes such as City and Mayor or Product and Color. The functional dependency tells that every City value determines a Mayor value or that every Product value determines a Color value. This means that the cardinality described in the relationship is set by the designer, which is useful for query optimizations.","One use of an attribute relationship is within the context of a hierarchy in a dimension. Attributes that are directly related to the hierarchy attributes can be queried as part of the hierarchy. This allows each level of the hierarchy to define attributes that complement the information of a given level. For example, a hierarchy can have a City attribute. The City attribute can be related to a City_Population attribute with an attribute relationship. With the attribute relationship information, City_Population information can be included in a query that includes City.","The metadata object specific properties defining an attribute relationship metadata object are described in the following Table 10 in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0154","num":"0154"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 10"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Property","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Left attribute","Left attribute used in the relationship."]},{"entry":[{},"Right attribute","Right attribute used in the relationship."]},{"entry":[{},"Type","Type of relationship described by the"]},{"entry":[{},"[DESCRIPTION,","attribute relationships. The type is"]},{"entry":[{},"ASSOCIATED]","used to determine what role an attribute"]},{"entry":[{},{},"plays."]},{"entry":[{},"Cardinality [1:1,","Cardinality expected in the join."]},{"entry":[{},"1:N, N:1, N:N]"]},{"entry":[{},"Functional","Determines if the attribute relationship"]},{"entry":[{},"dependency","is also a functional dependency."]},{"entry":[{},"[YES, NO]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The join metadata object joins relational tables that are referenced by two metadata objects. Two metadata objects can be joined on one or more pairs of attribute metadata objects mapping to relational table columns. In a facts to dimension join, a join metadata object joins attributes from the facts metadata object and attributes from the dimension metadata object. In a composite join, the set of attribute pairs is from the same set of tables. For example, to join relational Table1 with a compound key of FirstName and LastName, with a relational Table2 that has a compound key of FName and Lname, one relational join with two join predicates is used; one join predicate for Table1.FirstName and Table2.FName, a second join predicate for Table1.LastName and Table2.LName. The information about this composite join is stored in one join metadata object.","The join metadata object is defined by a list of the left attribute, right attribute, and join operator. Also, the join type and expected cardinality are specified. Joins can be used between two facts, two dimensions, or a fact and a dimension. Join metadata objects are referred to by cube model, facts, and dimension objects.","The metadata object specific properties that define a join metadata object are described in the following Table 11 in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0158","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 11"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Property","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"List of (left","Left attribute: The attribute on the left side of"]},{"entry":[{},"attribute, right","the join. Right attribute: The attribute on the"]},{"entry":[{},"attribute,","right side of the join. Operator: Operator"]},{"entry":[{},"operator)","expected in the join [=, <, >, <\u2009>, >=, <=]."]},{"entry":[{},"Type [INNER,","Type of join expected."]},{"entry":[{},"FULL OUTER,"]},{"entry":[{},"LEFT"]},{"entry":[{},"OUTER, RIGHT"]},{"entry":[{},"OUTER]"]},{"entry":[{},"Cardinality [1:1,","Cardinality expected in the join."]},{"entry":[{},"1:N, N:1, N:N]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"A cube is a very precise definition of an OLAP cube that can be delivered using a single SQL statement. Each cube is derived from a single cube model. The cube facts and list of cube dimensions are subsets of those in the referenced cube model. A cube view name is also defined which represents the cube in the database. Cubes are appropriate for tools and applications that do not use multiple hierarchies because cube dimensions allow one cube hierarchy per cube dimension.","The purpose of a cube is to define a standard relational view of an OLAP structure. In addition to the relational view, a cube provides an extended describe (e.g., XML document) that describes the roles of its columns in multidimensional terms. In the process of defining a cube, the designer selects a subset of the possible elements, choosing a single hierarchy for each dimension. This ensures that the cube unambiguously defines a single relational result set. The simplicity of a cube makes the cube useful to less sophisticated OLAP applications, such as portable devices powered by World Wide Web (\u201cWeb\u201d) services.","The metadata object specific properties of a cube metadata object are described in the following Table 12 in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0162","num":"0162"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Property","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Cube model","Cube model from which the cube is derived."]},{"entry":["Cube facts","Cube facts used in the cube. The cube facts is derived"]},{"entry":[{},"from the facts metadata object in the cube model."]},{"entry":["List of cube","Ordered list of cube dimensions used in the cube."]},{"entry":["dimensions","The cube dimension is derived from the dimensions"]},{"entry":[{},"in the cube model. One cube hierarchy is associated"]},{"entry":[{},"with each cube dimension."]},{"entry":["Cube view","View in the database that represents the cube."]},{"entry":["Extended","XML document describing roles of columns and their"]},{"entry":["Describe","relationships in terms of a multidimensional model"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A cube facts metadata object has a subset of measures in an ordered list from a specific facts metadata object. A cube facts metadata object gives a cube the flexibility to scope facts of a cube model. The structural information, such as the joins and attributes, is referenced from the parent facts metadata object. The metadata object specific properties that define a cube facts metadata object are described in the following Table 13 in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0164","num":"0164"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Property","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Facts","Facts from which the cube facts is derived."]},{"entry":["List of","Ordered list of measures used in a cube. All measures"]},{"entry":["measures","are part of the facts from which the cube facts is"]},{"entry":[{},"derived."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A cube dimension metadata object is used to scope a dimension for use in a cube. The cube dimension metadata object references the dimension from which it is derived and the relevant cube hierarchy for the given cube. In certain implementations, one cube hierarchy can be applied to a cube dimension. The joins and attributes that apply to the cube dimension are referenced from the dimension definition. The metadata object specific properties that define a cube dimension metadata object are described in the following Table 14 in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0166","num":"0166"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Property","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Dimension","Dimension from which the cube dimension is derived."]},{"entry":["Cube","Cube hierarchy that applies to the cube dimension"]},{"entry":"hierarchy"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"A cube hierarchy metadata object is a scoped version of a hierarchy and is used in a cube. A cube hierarchy references the hierarchy from which it is derived and can have a subset of the attributes from the parent hierarchy. Additionally, a cube hierarchy metadata object references the attribute relationships that apply on the cube. In certain implementations, one cube hierarchy can be defined for a cube dimension of a cube. A cube hierarchy metadata object has the same hierarchy types and deployment mechanisms as the hierarchy from which the cube hierarchy metadata object is derived.","A cube hierarchy is very similar to a hierarchy; however, a cube dimension refers to a single cube hierarchy. This allows a single SELECT statement to calculate the cells of a cube.","The metadata object specific properties that define a cube hierarchy metadata object are described in the following Table 15 in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0170","num":"0170"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Property","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Hierarchy","Hierarchy from which the cube hierarchy is derived."]},{"entry":["Lists of","Ordered list of all attributes from the top to the"]},{"entry":["attributes","bottom of the cube hierarchy. The order of the"]},{"entry":[{},"attributes should be the same as in the parent"]},{"entry":[{},"hierarchy."]},{"entry":["Set of","Set of all attribute relationships that link cube"]},{"entry":["attribute","hierarchy attributes to other attributes."]},{"entry":"relationships"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0171","num":"0171"},"figref":"FIG. 16","b":["1610","1600"]},{"@attributes":{"id":"p-0172","num":"0172"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 16"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Metadata",{},{}]},{"entry":["Metadata object",{},"Metadata"]},{"entry":["1","References","Metadata object 2"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Cube Model","zero or one","Facts"]},{"entry":["Cube Model","zero or more","Dimension\/Join"]},{"entry":["Cube","one","Cube model"]},{"entry":["Cube","one","Cube Facts"]},{"entry":["Cube","one or more","Cube Dimension"]},{"entry":["Facts","one or more","Measure"]},{"entry":["Facts","zero or more","Attribute"]},{"entry":["Facts","zero or more","Join"]},{"entry":["Dimension","one or more","Attribute"]},{"entry":["Dimension","zero or more","Join"]},{"entry":["Dimension","zero or more","Hierarchy"]},{"entry":["Cube Facts","one","Facts"]},{"entry":["Cube Facts","one or more","Measure"]},{"entry":["Cube Dimension","one","Dimension"]},{"entry":["Cube Dimension","one or more","Attribute"]},{"entry":["Cube Dimension","one","Cube Hierarchy"]},{"entry":["Hierarchy","one or more","Attribute"]},{"entry":["Hierarchy","zero or more","Attribute Relationship"]},{"entry":["Cube Hierarchy","one","Hierarchy"]},{"entry":["Cube Hierarchy","one or more","Attribute"]},{"entry":["Cube Hierarchy","zero or more","Attribute Relationship"]},{"entry":["Measure","zero or more","Measure"]},{"entry":["Measure","zero or more","Attribute"]},{"entry":["Measure","zero or more","Dimension"]},{"entry":["Attribute","zero or more","Attribute"]},{"entry":["Attribute","two","Attribute"]},{"entry":"Relationship"},{"entry":["Join","multiple of two","Attribute"]},{"entry":[{},"(minimum of two)"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In accordance with certain implementation, there is a metadata object naming convention and rules for naming. Naming conventions and rules other than those described herein may be used without departing from the scope of the invention. There are two different naming conventions to name objects: ordinary and delimited. For the metadata objects, due to its flexibility, the delimited convention is used when naming objects and referring to database tables and columns. The delimited convention allows mixed case names, spaces, and special characters, such as national language characters. The complete set of characters is determined by the codepage of the database in which the objects reside.","Besides the naming conventions, some rules apply to the different identifiers in the objects in certain implementations. For example, a schema has a length of 1-30 bytes and schema names do not begin with \u2018SYS\u2019; a name has a length of 1-128 bytes; a business name has a length of 1-128 bytes; comments have a length of 0-254 bytes; a table schema (used in referencing columns) has a length of 1-128 bytes; a table name (used in referencing columns) has a length of 1-128 bytes; and a column name (used in referencing columns) has a length of 1-128 bytes.","In addition to the relationships that are enforced, additional rules are described for each metadata object. That is, every metadata object has its own set of rules, and an instance of a metadata object is valid if the metadata object follows all of the metadata object rules for that metadata object. The rules are separated in three categories: Base Rules, Cube Model Completeness Rules, and Optimization Rules. The following discussion of specific rules provides a set of rules for certain implementations of the invention. In other implementations, the set of rules for one or more metadata objects may be modified without departing from the scope of the invention.","The base rules for a cube model metadata object are: (1) the cube model metadata object refers to zero or one facts metadata object; (2) the cube model metadata object refers to zero or more dimension(s); (3) dimension-join pairs have both a dimension and a join; (4) a join associated with a dimension is valid if all attributes of one side of a join are found in the facts attribute list and all other side attributes are found in the attribute list of the dimension; and (5) for each measure referenced in the facts of the cube model facts, all the explicit dimension references in the aggregations of the measure are referenced by the cube model. When the cube model references at least one dimension, an aggregation with an empty list of dimensions matches to at least one dimension from the cube model that was not previously referenced.","The base rules for a cube metadata object are: (1) the cube metadata object refers to one cube facts; (2) the cube metadata object refers to at least one cube dimension; (3) cube facts is derived from the facts used in the cube model; and, (4) cube dimensions are derived from the dimensions used in the cube model.","The base rules for a facts metadata object are: (1) a facts metadata object refers to at least one measure; (2) all attributes and measures referenced by a facts are joinable; (3) in a facts metadata object context, a single join can be defined between two given tables; (4) there are no join loops in a facts metadata object; and, (5) all joins referenced by a facts metadata object refer to fact metadata object attributes.","The base rules for a dimension metadata object are: (1) the dimension metadata object refers to at least one attribute; (2) attributes referenced by a dimension are joinable; (3) there are no join loops; (4) in a dimension context, a single join is defined between any two given tables; (5) hierarchies referenced by a dimension refer to the attributes of the dimension; (6) attribute relationships that are referenced by hierarchies of a dimension refer to the attributes of the dimension; and (7) joins referenced by a dimension refer to the attributes of the dimension.","The base rules for a cube facts metadata object are: (1) the cube facts metadata object refers to at least one facts; (2) the cube facts metadata object refers to at least one measure; and, (3) measures referenced by a cube facts metadata object are part of the facts metadata object.","The base rules for a cube dimension metadata object are as follows: (1) the cube dimension metadata object refers to one dimension; (2) the cube dimension metadata object refers to a cube hierarchy; and, (3) the cube hierarchy referenced by the cube dimension metadata object is derived from a hierarchy that is referenced dimension by the dimension of the cube dimension metadata object.","The base rules for a hierarchy metadata object are: (1) the hierarchy metadata object refers to at least one attribute; (2) two attributes are required for a recursive deployment; (3) every attribute relationship within a hierarchy has a left attribute as part of the hierarchy; (4) every attribute relationship within the hierarchy has a cardinality of 1:1 or N:1; and, (5) certain combinations of hierarchy types and hierarchy deployments are allowed as indicated in Table 17 in accordance with certain implementations of the invention:",{"@attributes":{"id":"p-0183","num":"0183"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 17"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Type\/Deployment","Standard","Recursive"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Balanced","X",{}]},{"entry":[{},"Ragged","X"]},{"entry":[{},"Unbalanced","X","X"]},{"entry":[{},"Network","X"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"The base rules for a cube hierarchy metadata object are: (1) the cube hierarchy metadata object refers to one hierarchy; (2) the cube hierarchy metadata object refers to at least one attribute; (3) attributes referenced by the cube hierarchy metadata object are part of the hierarchy; (4) the order of the attributes in the cube hierarchy metadata object are the same as in the hierarchy (with the exception of hierarchies defined as a network); (5) every attribute relationship within a hierarchy has a left attribute as part of the hierarchy; and, (6) attribute relationships referenced in the cube hierarchy metadata object are also referenced in the hierarchy that defines the cube hierarchy.","The base rules for a measure metadata object are: (1) a measure metadata object can have, as parameters for each SQL expression template, attributes, columns, measures, or none of them; (2) attributes and measures, used as SQL template parameters, can not generate a dependency loop among attributes and\/or measures; (3) every SQL template defined in the measure metadata object is not an empty string; (4) the SQL template does not use aggregation functions; (5) aggregation is not required if at least one measure and only measures are referenced; (6) the number of SQL templates matches the number of parameters of the first aggregation function, if an aggregation is present; (7) a measure metadata object with multiple SQL templates defines at least one step in an aggregation script; (8) if measure metadata object A refers to measure metadata object B, which defines multiple SQL templates, then measure metadata object A does not have an aggregation script; this rule applies for all levels in a measure reference tree; (9) a multi-parameter aggregation function is used as the first aggregation; (10) if a measure metadata object defines one or more aggregations, one aggregation may have an empty list of dimensions; (11) within a measure metadata object, a dimension may not be referenced more than once either within an aggregation or across aggregations; (12) within a SQL expression template, token indicators (i.e., {$$#}) begin numbering with 1 and are consecutive with no numbering gaps; and, (13) within a SQL expression, every column, attribute and measure is referenced at least once.","The base rules for an attribute metadata object are: (1) an attribute metadata object can have, as parameters for the SQL template, attributes, columns, or none of them; (2) the attributes, used as parameters for SQL template, can not generate a dependency loop among attributes; (3) the SQL template can not be an empty string or blank string; (4) no aggregation function is allowed to be part of the SQL template; (5) within a SQL expression template, token indicators (i.e., {$$#}) begin numbering with 1 and are consecutive with no numbering gaps; and, (6) within a SQL expression, every column, attribute and measure is referenced at least once.","The base rules for an attribute relationship metadata object are: (1) the attribute relationship metadata object refers to two attributes; and, (2) the attribute relationship metadata object cannot be defined as having a cardinality=N:N and a functional dependency-YES.","The base rules for the join metadata object are: (1) the join metadata object refers to at least one triplet of left attribute, right attribute, and operator; (2) all left attributes in the join metadata object resolve into one or more columns of a single table; (3) all right attributes in the join metadata object resolve into one or more columns of a single table; and, (4) each triplet of the join metadata object defines a valid operation; the datatypes of left and right attributes, as well as the operation defined for them, are compatible.","The cube model completeness rules extend the base rules in order to ensure that a cube model has the required links to other metadata objects to allow effective warehouse SQL queries to be formed. The cube model completeness rules for a cube model metadata object are: (1) a cube model metadata object refers to one facts; (2) a cube model metadata object refers to one or more dimensions.","The optimization rules extend the cube model completeness rules in order to ensure that optimization of warehouse SQL queries can be performed.","The optimization rules for a cube model metadata object is: (1) the join used in the facts to dimension has a cardinality of 1:1 or N:1 and joins a facts table to a primary table of a dimension.","The optimization rules for a dimension metadata object is: (1) considering the join network formed by the joins of the dimension, there is at least one table, primary table, in which all joins radiating from this table have cardinality of N: 1 or 1:1.","The optimization rules for a join metadata object are: (1) there is a constraint defined on the columns that participate in the join; if the join is a self-join, i.e. the same set of columns is used in both sides of the equality, a primary key is defined matching the set of columns; in all other cases, when the set of columns of one side are different from the other side of the join, a primary key matches the columns of one side of the join, and a foreign key matches the other set of columns as well as references the primary key; (2) the join cardinality is 1:1, N:1 or 1:N; if the join is a self-join, the cardinality is 1:1; in all other join cases, the cardinality is 1 on the side in which a primary key is defined and N on the side in which a foreign key is defined; if the foreign key side has also a primary key defined on it, a 1 is used as cardinality; (3) all attributes used in the join resolve to non-nullable SQL expressions; and, (4) the join type is INNER JOIN.","A.3 Metadata Object Example",{"@attributes":{"id":"p-0194","num":"0194"},"figref":["FIG. 17","FIGS. 18A-18E","FIG. 17","FIGS. 18A-18E","FIGS. 18A-18E"],"b":["1710","1720","1700","1730","1740","1700","1710","1720","150","130","130","1800","1802","1804","1806","1808","1810","1812","1814","1816","1818","1820","1822","1824","1826","1828","1830","1832","1834","1848"]},"A user may use the user interface  to create metadata objects. After creating an empty cube model metadata object, a facts metadata object and dimension metadata objects are created and joined to the cube model metadata object by creating appropriate join metadata objects.","The properties of the metadata objects discussed herein may be modified without departing from the scope of the invention.","B. Improving the Performance of Relational Database Management System (RDBMS) Processing Queries Issued by an On-line Analytical Processing (OLAP) System","Implementations of the invention automatically recommend summary tables and indexes to be created. In certain implementations, the invention improves the performance of OLAP queries issued by OLAP systems against relational databases. Furthermore, traditional non-OLAP systems that issue aggregation style queries to the RDBMS  against a traditional normalized schema also see performance improvement with the techniques of the invention. In particular, implementations of the invention exploit multidimensional metadata, database statistics, sampling, query type, diskspace limitations, time limitations, and multidimensional regions to be optimized to make recommendations about which summary tables and indexes should be created.","B.1 Overview of Optimization Techniques","This section provides an overview to concepts used in this invention. In particular, this section describes the metadata objects and the type of SQL queries for which optimization is performed.","In certain implementations, the advisor component  recommends summary tables based on the cube model metadata. As discussed in Section A above, a cube model represents a particular grouping and configuration of relational tables. The purpose of a cube model is to describe multidimensional structures to a given application or tool. A cube model groups dimensions and facts, and offers the flexibility of multiple hierarchies for dimensions.","The front end query systems and applications can generate complex SQL queries against the relational tables based on the structural information in the cube model. Some front end systems and applications generate SQL queries based on their own metadata. In that case, a bridge can be used to import the cube model and populate the metadata repository managed by the front end systems and applications. Furthermore, a designer can construct the cube model metadata based on existing metadata or queries from the front end systems and applications. Since the summary tables recommended by the advisor component  are based on the structural information of the cube model, the summary tables also match the SQL queries generated by the front end systems. As a result, the relational database engine can improve query performance by using the full or partial results pre-aggregated in the summary table.","Also as discussed in Section A above, a cube metadata object (i.e., a \u201ccube\u201d) consists of a subset of the dimensions and facts in a cube model. Cubes can be used to describe multidimensional regions of the cube model to be optimized. In addition, some simple and pervasive applications (e.g. Web based analytical applications) generate SQL queries based on the structure information in the cube object. The performance of these queries can also be improved by the summary tables recommended based on the cube model metadata.","Cube models are a conceptual object based on top of a set of database tables. For some SQL queries, the RDBMS  can simply read a subset of data from database tables. Other SQL queries require the RDBMS  to dynamically calculate results. For example, suppose there is a cube model with dimensions for time and product. The base tables may contain daily sales figures by product, but a typical query might aggregate the sales by month. While this query is written against the base table, the query matches the logical structure of the cube model. For example, a hierarchy in the time dimension may contain day, month, and quarter attributes, which defines the aggregation for the daily sales data. For large tables, this process of aggregating data can be time consuming. Therefore, RDBMS  provides summary tables, in which aggregations of data can be calculated and stored into physical tables. Subsequent queries that refer to these aggregations will be automatically rerouted to the summary tables, thereby improving performance significantly.","Queries are optimized by exploiting the summary tables. In certain implementations, the process starts with, for example, a database administrator (DBA) defining a cube model using either a user interface  or by importing metadata from other products via bridges. In certain implementations, a bridge is a piece of software that connects two products. In the OLAP multidimensional metadata system  context, bridges map metadata between the metadata objects  and other products that have multidimensional metadata. By using a bridge that maps metadata from an existing OLAP metadata repository to the metadata objects , the metadata catalog of the OLAP multidimensional metadata system  may be filled without requiring users to manually enter the information. In either case, the OLAP multidimensional metadata system  understands the relationship between the aggregations and base data. In particular, applications will generate SQL that matches the structural information in the cube model object. For example, a generated SQL that might specific that aggregations be by month maps to the month level within a time dimension hierarchy. Knowing the structure of the summary tables, applications may also see performance improvements by issuing a SQL query directly against the summary table.","If the DBA knows how the data in the star schema will be accessed, the DBA may be able to provide optimization hints. For example, for a spreadsheet based application that generates OLAP-style queries, the user may start at the top of the cube (e.g., total revenue for the year) and drill down into quarterly and monthly aggregations. Since the users are less likely to drill down deeply into the data, the DBA may recommend that the optimization be concentrated at the top of the cube model.","Once the summary tables and indexes to be built are identified, the OLAP multidimensional metadata system  generates a set of SQL statements to build summary tables and indexes to improve query performance. In particular, the advisor component  provides a SQL script that creates one or more summary tables, creates indexes on the summary tables, reorganizes the tables, etc. In certain implementations, the DBA executes the SQL that was provided by the OLAP multidimensional metadata system  to actually create the summary tables and indexes.","A cube model is defined on top of a relational database. In certain implementations, the database may be a data warehouse or datamart, but it may be another type of database, such as a transaction database. Detailed data is contained in tables and aggregations of this detailed data can be calculated. One sample cube may be generated with sales data for a line of products. The data that exists shows the sales for each product, customer and store by day. For example, John Doe spent $600 on a particular digital camera in the TechMart store in San Jose on Jan. 1, 2002. The dimensions are time, store, customer and product. Hierarchies define how data is aggregated within the dimensions.","Although multidimensional data is difficult to represent in a 2-dimensional diagram,  attempts to represent a cube model in accordance with certain implementations of the invention. In , each column of boxes , , ,  represents a hierarchy in a dimension. Each triangle , , ,  contains the dimension name. The top box , , ,  in each column represents all the data for that dimension. The top box , , ,  appears different than the boxes below it to indicate there is not a corresponding level attribute for this box , , , . The remaining boxes in each column , , ,  represent level attributes. For example, the time dimension has year, quarter, month and day level attributes.","The order of the boxes reflects how the aggregations are done. For example, in the time hierarchy, daily data is aggregated to obtain monthly data, monthly data aggregates to quarter, quarter to year and year to all time.","The data that actually exists is for the bottom box in each hierarchy\u2014data by customer and store and product and day. All other data is calculated.","SQL queries can refer to data from any combination of boxes (i.e., levels). For example, a query could obtain monthly sales data for a particular product line sold in a particular state and purchased by customers from a particular region.","Some simple queries will be described to show how they map to the cube model diagram and to show how a summary table could improve performance. Query (1) shows the most detailed sales data available for a particular customer. Query (1) goes against the grain of the warehouse, the lowest level of each hierarchy. The resulting data from executing query (1) is illustrated in Table 18 in accordance with certain implementations of the invention.\n\nselect Year, Month, Day, StoreName, ProductName, Revenue\u2003\u2003(1)\n\n",{"@attributes":{"id":"p-0212","num":"0220"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 18"},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}},{"entry":["Year","Month","Day","Store Name","Product Name","Revenue"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["2000","1","1","TechMart","TurboPhone","3500"]},{"entry":[{},{},{},{},"2001"]},{"entry":["2000","1","5","Cowabunga","Turbo","9000"]},{"entry":[{},{},{},"Mart","Quadrophonic"]},{"entry":[{},{},{},{},"5000"]},{"entry":["2000","1","31","Tech Mart","Blaster","2200"]},{"entry":[{},{},{},{},"Speakers 45C"]},{"entry":["2000","1","31","Slug Mart","Blaster","4000"]},{"entry":[{},{},{},{},"Speakers 45C"]},{"entry":["2000","5","17","Snow Mart","Blaster","8000"]},{"entry":[{},{},{},{},"Speakers 45C"]},{"entry":["2001","1","1","Tech Mart","TurboPhone","1600"]},{"entry":[{},{},{},{},"2001"]},{"entry":["2001","12","1","Cowabunga","Blaster","8000"]},{"entry":[{},{},{},"Mart","Speakers 45C"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"Query (2) shows the sales of electronics products for each state in the western United States, and the resulting data from executing query (2) is listed in Table 19 in accordance with certain implementations of the invention. Query (2) subsets the data using a where clause to restrict the data to electronics products in the western USA. The data is grouped by store state and product line since we wanted aggregated revenue rather than detailed data for each store and product. Also, the sum aggregation function is applied to the revenue column.\n\nselect StoreState, ProductLine, sum(revenue) as \u201crevenue\u201d\u2003\u2003(2)\n\n",{"@attributes":{"id":"p-0214","num":"0229"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":[{},"TABLE 19"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"StoreState","ProductLine","Revenue"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Alaska","Stereo","3800"]},{"entry":[{},"California","Radio","11300"]},{"entry":[{},"California","Stereo","17699"]},{"entry":[{},"California","TV","12100"]},{"entry":[{},"Hawaii","Stereo","17000"]},{"entry":[{},"Nevada","Stereo","5100"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0215","num":"0230"},"figref":"FIG. 20","b":["2010","2020","2030"]},"The first line  represents query (2) that showed revenue by product line and store state. Note the line  connects the boxes for \u201cAll Time\u201d\u2014\u201cStore State\u201d\u2014\u201cAll Customers\u201d\u2014\u201cProduct Line\u201d. This reflects that query (2) displays data aggregated by store state and product line for all time and all customers. In other words, since no grouping was done on either time or customers, the data shown is for all of them. This result is a slice of the cube model, the intersection of one level from each hierarchy.","The second line  represents query (1) that obtained detailed sales data for a particular customer. The line  connects the lowest box in each hierarchy because query (1) does not aggregate data. An aggregator was not applied to the revenue measures. Query (1) simply reads a subset of the data from the actual table.","The third line  represents actual data. The detailed sales data is stored in the relational database. This data is the actual sales figures by customer and product for each store and day. While more detailed data may be available in a transaction database, this is the most detailed data available in the warehouse.","When RDBMS  processes query (1) requesting the non-aggregated data, the RDBMS  simply reads the requested subset of data. The RDBMS  does not need to aggregate the data since the RDBMS  already has data at the appropriate level of aggregation. In order to process query (2) requesting the data aggregated by store and product, the RDBMS  reads data from the base tables (the thick line ) and dynamically aggregates the data. Any query that references a combination of boxes above the thick line  will require the RDBMS  to perform additional processing.","Performance of query (2) that does aggregation could be improved by creating a summary table at a higher level of aggregation.  illustrates a representation of a cube model in accordance with certain implementations of the invention. In particular, in  line  represents a summary table at the quarter\u2014store state\u2014customer state\u2014product line aggregation level. If this summary table existed when the query was run, then the RDBMS  would read from the summary table instead of from the warehouse. This would save the RDBMS  work because the RDBMS  would need to aggregate less data, as the data will have already been aggregated several levels.","A summary table could be built containing the exact slice that the query specified. This would improve the performance the most because the RDBMS  would read data, but would not need to perform any calculations. However, there are some tradeoffs involved. The more slices that are preaggregated, then the odds of an exact match increase. However, this increases the time to build and maintain the summary table. On the other hand, having fewer slices at the right levels of each of the hierarchies can lower the cost of maintaining the summary table. Queries that do not have an exact match to the slices in the summary table can be aggregated at runtime. This also improves the query performance.","Imagine a slice built for [Year, Store Country, Customer Country, Product Group]. If a query refers to [Year, All Stores, Customer Country, Product Group], then the RDBMS  aggregates the data from store country to all stores. If there are stores in 32 countries, then 32 rows are read and calculated. In order for the RDBMS  to use a summary table, the query slice should be at or above the slice in the summary table. For example, a query that accessed [Quarter, All Stores, Customer City, All Products] would not be able to use the summary table slice  shown in  with a dashed line because Customer City is below Customer State.","Tables 20-24 provide details of the fact and dimension tables for which the cube model illustrated in  in accordance with certain implementations of the invention. The following hierarchies exist in the cube model:\n\n",{"@attributes":{"id":"p-0224","num":"0243"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 20"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Sales"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Measure",{},"Sample"]},{"entry":[{},"Name","Measure Description","Values"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Revenue","How much money was","12000,"]},{"entry":[{},{},"received by selling products.","\u20028500"]},{"entry":[{},"Cost","How much it cost to produce","11000,"]},{"entry":[{},{},"products.","\u20027400"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0225","num":"0244"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 21"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Time"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Attribute","Attribute","Sample"]},{"entry":[{},"Name","Description","Values"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Year","The year.","2000, 2001"]},{"entry":[{},"Quarter","The quarter of the year.","Quarter 1,"]},{"entry":[{},{},"There are 4 quarters per","Quarter 2,"]},{"entry":[{},{},"year. Each quarter has 3","Quarter 3,"]},{"entry":[{},{},"months and 13 weeks.","Quarter 4"]},{"entry":[{},"Month","The month of the year.","1-12"]},{"entry":[{},"Week","The week of the year.","1-52"]},{"entry":[{},"Day","The day of the month.","1-31"]},{"entry":[{},{},"There are 28\u201331 days per"]},{"entry":[{},{},"month."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0226","num":"0245"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 22"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Store"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Attribute","Attribute","Sample"]},{"entry":[{},"Name","Description","Values"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Store","The name of the country","USA, Canada,"]},{"entry":[{},"Country","the store is in.","Mexico"]},{"entry":[{},"Store","The name of the region","West,"]},{"entry":[{},"Region","within the country the","Northeast"]},{"entry":[{},{},"store is in."]},{"entry":[{},"Store State","The name of the state or","California,"]},{"entry":[{},{},"province the store is in.","Alberta"]},{"entry":[{},"Store City","The city the store is in.","San Jose,"]},{"entry":[{},{},{},"New York"]},{"entry":[{},"Store","The name of the store.","Branch 173"]},{"entry":[{},"Name"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0227","num":"0246"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 23"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Customer"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Attribute","Attribute","Sample"]},{"entry":[{},"Name","Description","Values"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Customer","The name of the country","USA, Canada,"]},{"entry":[{},"Country","the customer is in.","Mexico"]},{"entry":[{},"Customer","The name of the region","West,"]},{"entry":[{},"Region","within the country the","Northeast"]},{"entry":[{},{},"customer is in."]},{"entry":[{},"Customer","The name of the state or","California,"]},{"entry":[{},"State","province the customer is","Alberta"]},{"entry":[{},{},"in."]},{"entry":[{},"Customer","The city the customer is","San Jose,"]},{"entry":[{},"City","in.","New York"]},{"entry":[{},"Customer","The name of the","John Doe,"]},{"entry":[{},"Name","customer.","Jane Doe"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0228","num":"0247"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 24"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Product"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Attribute","Attribute","Sample"]},{"entry":[{},"Name","Description","Values"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Product","The name of a group of","Communications,"]},{"entry":[{},"Group","products. A more general","electronics"]},{"entry":[{},{},"set of products than product"]},{"entry":[{},{},"line."]},{"entry":[{},"Product","The name of a set of","Cell phone, stereo,"]},{"entry":[{},"Line","products that represent a","VCR"]},{"entry":[{},{},"line of products."]},{"entry":[{},"Product","The name of the specific","Turbo"]},{"entry":[{},"Name","product.","quadrophonic"]},{"entry":[{},{},{},"stereo 2001, VCR"]},{"entry":[{},{},{},"3000"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"Business Intelligence tools and applications that deal with data in the relational database may issue all sorts of queries against the relational tables. Using the multidimensional metadata that matches the cube model definition, tools and applications are generally performing aggregations based on the granular data in the tables. There are four broad categories of queries that are seen depending on the type of tools and applications being used. The four broad categories include: drilldown, reports, extracts, and drillthrough.","Drilldown refers to the set of queries that are navigating through the aggregated data starting at the highest levels and drilling down into more detailed data. For example, a user is using a spreadsheet based application. Initially, the overall revenue for all regions and time might be displayed. The user then drills down into a hierarchy, such as region, to see revenue by state or drills into time to see revenue by quarter and month. Based on the user's interaction, the application generates a set of drilldown queries against the relational database.","Reports refer to queries that are generated to produce data (e.g., defined by a report designer) that matches slices of the cube model. Unlike the drilldown queries, which start at the top of the hierarchies, report queries, initially, can be the request for data at a particular level or slice (e.g. sales figures for the West region for all products). Then, there may be a drill up for more summary level data or drilldown for more detailed data based on user interactions.","Extracts refer to queries that are generated against the relational database for the purpose of populating an external data store or cache. For example, Multidimensional OLAP (MOLAP) products typically have a data load process which build and refresh the MOLAP data structures based on data that matches a particular slice in the cube model. An example of this is the Essbase\u2122 multidimensional database. Essbase\u2122 runs SQL queries against a relational database to aggregate the data and stores aggregations within its own proprietary data store.","Another type of OLAP system is called Hybrid OLAP (HOLAP). Typically, HOLAP uses two storage systems to store data for a single logical cube. The higher (summary) levels of the cube are stored in a proprietary data store, while lower level data remain in relational base tables. For example, the Essbase\u2122 multidimensional database from Hyperion Solutions provides a mechanism to navigate out of a MOLAP cube and drill down into the relational database, which allows users to see detailed data that does not exist in the MOLAP cube. Drillthrough refers to queries generated by the HOLAP products when a user navigates across from the external data store to the relational database.","B.2 Drilldown Query Example","The following queries in this section are example queries that may be used if a spreadsheet with OLAP add-in was used to drill down into lower level data from the top of the hierarchies. In particular, the following query displays revenue for all years:\n\n","The following query displays revenue for each year:\n\n","The following query displays revenue for each quarter of the year 2000:\n\n","The following query displays revenue for each country:\n\n","The following query displays revenue for each region within the United States:\n\n",{"@attributes":{"id":"p-0239","num":"0278"},"figref":"FIG. 22","ul":{"@attributes":{"id":"ul0015","list-style":"none"},"li":["[All Time, All Stores, All Customers, All Products] ,","[Year, All Stores, All Customers, All Products] ,","[Quarter, All Stores, All Customers, All Products] ,","[All Time, Store Country, All Customers, All Products] , and","[All Time, Store Region, All Customers, All Products] ."]}},"A summary table with the slice [Quarter, Store Region, Customer Region, Product Line] would improve the performance of all these queries as well as any other query that drilled down to no further than the third level in each hierarchy. Building additional slices above this slice might improve query performance further at the expense of additional space and build time.","B.3 Report Query Example","Report queries can be for any slices in a cube model. Suppose three queries are executed and then read the following slices:\n\n",{"@attributes":{"id":"p-0242","num":"0289"},"figref":"FIG. 23","b":["2310","2320"],"ul":{"@attributes":{"id":"ul0017","list-style":"none"},"li":["[Year, Store Region, Customer Region, Product Group] ","[Quarter, Store State, Customer State, Product Line] "]}},"The first query could be routed to the second summary table slice. The second query could be routed be routed to the first summary table slice. The third query, however, could not be handled by either preaggregated slice. Instead the RDBMS  would aggregate from the base data.","B.4 Extract Query Example","Extract queries are generated by OLAP tools to pull data into an external data store (e.g. MOLAP database). Although multiple level of the data can be loaded into the external data store, typically the extract queries read data from relational database that matches the bottom level of the external data store.  illustrates an extract that might be done in accordance with certain implementations of the invention. A middle level slice provides the level of data that can be used to populate the MOLAP cube. In this example, both the extract query and the bottom level of the MOLAP cube are: [Quarter, Store State, Customer State, Product Line] .","An improvement to extract performance would be achieved by building slice  in a summary table. This would allow the extract to be completely satisfied by reading the summary table rather than reading the base tables and doing dynamic aggregations.","B.5 Drillthrough Query Example","In HOLAP products, a cube is a logical representation of data from the MOLAP data structure as well as data directly read or calculated from the relational database tables. MOLAP cubes are generally smaller in size for optimizing query performance and lowering the cost of maintenance. In such logical cubes, data at the lower levels of the hierarchies can reside in the relational database, while higher level data is extracted into a MOLAP data structure. When a user drills down from a level within the MOLAP data structure into the relational part of the logically cube, SQL queries are generated against the relational database to retrieve data. The Essbase\u2122\/DB2\u00ae OLAP relational partition feature is an example of this.","Suppose a user is looking at the following grid in relational partitions:\n\n","Suppose also that the user wants to drill-down on California to the city level. The following query may be generated for this drill-down:\n\n","Since this query drills below the store state level, the OLAP tools would require the relational RDMBS  to read and aggregate the base tables.","C. Advisor","C.1 Introduction","Implementations of the invention provide an advisor component , which exploits the multidimensional metadata in a database catalog for a specified cube model metadata object and recommends summary tables and indexes to be created in order to optimize queries. Implementations of the invention improve the performance of a relational database management system (RDBMS) used by OLAP systems. OLAP systems perform analysis of data that typically comes from relational databases. The advisor component  improves the performance of OLAP systems when the OLAP systems issue queries against the relational database. Furthermore, traditional non-OLAP systems that issue aggregation style queries can also see performance improvements.","OLAP systems issue multidimensional queries. These queries may request data to be aggregated at various levels of the dimension hierarchies. The RDBMS  reads the data and aggregates the data to the appropriate level. Frequently most of the time is spent reading and aggregating the data, rather than returning the data.","Relational databases provide summary tables in which data can be aggregated at particular levels and made persistent. If a query requests data from that level the RDBMS  can directly read the data rather than reading and aggregating large quantities of lower level data. If queries refer to data that is in higher levels of the hierarchies than that already aggregated, the RDBMS  can frequently still make use of the existing aggregation. The performance improvements by exploiting summary tables to store pre-calculated aggregates can be great. However, determining the most cost effective summary tables to be created can be a complex and time consuming task for a person.","Implementations of the invention provide an automatic technique for recommending which summary tables should be created. The advisor component  exploits multidimensional metadata, database statistics, sampling, diskspace limitations, time limitations, and multidimensional regions to be optimized to make recommendations. In addition users can provide hints to optimize queries for their particular OLAP system.","The advisor component  can simultaneously improve the performance of multiple OLAP systems from different vendors, as well as queries, issued by non-OLAP products, unlike prior art solutions that optimize a particular OLAP system. Although some OLAP systems require that queries be issued against an OLAP engine rather than a relational database, with implementations of the invention, traditional SQL queries may be issued against the relational database, either directly or via a product that generates SQL queries. Moreover, the advisor component  provides a mechanism to improve Decision Support Systems (DSS) performance at the relational database level.","By leveraging multidimensional metadata in a relational database, a smaller set of optimization objects (e.g., materialized aggregates, indexes, etc.) are created and maintained to improve performance for one or more subject specific cubes. Implementations of the invention reduce data redundancy in storing aggregated data, as well as, improve efficiency for refreshing a summary table when granular data from which the summary table was generated is updated.","Improving the relational database as a platform for OLAP systems allows database administrators to optimize performance within the relational database for both proprietary OLAP systems and SQL based applications.","An optimization component of the OLAP multidimensional metadata system  improves the performance of OLAP style SQL queries issued by various vendor products. Performance is improved by exploiting, for example, multidimensional metadata, summary tables (which are a specialized form of materialized views), multi-dimensional clustering (MDC) indexes, clustered indexes, regular indexes, and database catalog statistics. The optimization component may be implemented as operations of the OLAP multidimensional metadata system  application programming interface (API), which passes requests and responses as XML documents.","Table 25 describes some optimization operations in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0259","num":"0334"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE 25"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Operation","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Advise","Recommends summary tables that will improve"]},{"entry":[{},"query performance for a cube model."]},{"entry":["List","List summary tables associated with a cube model."]},{"entry":["Drop","Drop summary tables associated with a cube model."]},{"entry":["Statistics","Statistics help with selection of which aggregations"]},{"entry":[{},"(e.g., slices and regions) to put into summary tables."]},{"entry":[{},"Statistics may be provided about slices and regions,"]},{"entry":[{},"such as: row width (i.e., tables are not wider than the"]},{"entry":[{},"tablespace they are put in); size (e.g., estimated)"]},{"entry":[{},"(i.e., the larger an aggregation the more costly it is);"]},{"entry":[{},"row count (e.g., estimated) (i.e., the larger an"]},{"entry":[{},"aggregation the more costly it is); number of"]},{"entry":[{},"columns; whether a slice\/region is logically stacked"]},{"entry":[{},"(derived from) another slice\/region; estimated time"]},{"entry":[{},"to populate (refresh) the summary table; whether"]},{"entry":[{},"refresh immediate could be used if a summary table"]},{"entry":[{},"contained this aggregation; and estimate of query"]},{"entry":[{},"improvement."]},{"entry":[{},"Most conventional performance advisors are geared"]},{"entry":[{},"for unsophisticated users and do not allow users the"]},{"entry":[{},"flexibility of controlling what gets done or else are"]},{"entry":[{},"geared for sophisticated users and are unusable by"]},{"entry":[{},"regular users. Implementations of the invention"]},{"entry":[{},"provide an advisor component 122 that supports a"]},{"entry":[{},"range of users from \u201cjust make my queries faster\u201d to"]},{"entry":[{},"\u201cI want to tell you the advisor precisely what needs"]},{"entry":[{},"to be faster and have you give me the analyst the"]},{"entry":[{},"necessary statistics so I can decide what to"]},{"entry":[{},"aggregate\u201d."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Table 26 describes some objects (e.g., C++ objects) used for optimization in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0261","num":"0336"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 26"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Object","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Advise","An operation that recommends summary"]},{"entry":[{},{},"tables and indexes given a set of input"]},{"entry":[{},{},"criteria."]},{"entry":[{},"Summary","Represents a summary table. It contains a"]},{"entry":[{},"table","set of slices and ROLLUP slices"]},{"entry":[{},{},"representing the aggregations to be done"]},{"entry":[{},{},"and a set of index objects."]},{"entry":[{},"Slice","The slice object represents a subset of a"]},{"entry":[{},{},"cube model obtained by using one level"]},{"entry":[{},{},"attribute for each hierarchy. In SQL"]},{"entry":[{},{},"terminology, this would be grouping by"]},{"entry":[{},{},"each specified level attribute plus any other"]},{"entry":[{},{},"level attributes higher in its hierarchy. The"]},{"entry":[{},{},"ROLLUP is a special variant in which"]},{"entry":[{},{},"ROLLUPs of the hierarchy attributes are"]},{"entry":[{},{},"done rather than just grouping."]},{"entry":[{},"Level","A level represents an attribute within a"]},{"entry":[{},{},"particular hierarchy of a dimension."]},{"entry":[{},"Index","Represents a database index. Variations"]},{"entry":[{},{},"include MDC index, clustered index and"]},{"entry":[{},{},"regular indexes."]},{"entry":[{},"SQLGen","Represents a SQL engine that understands"]},{"entry":[{},{},"cube models and slices. The SQLGen object"]},{"entry":[{},{},"works on a given cube model and can"]},{"entry":[{},{},"generate a SQL statement that represents"]},{"entry":[{},{},"one or more slices passed in a generate SQL"]},{"entry":[{},{},"call. Another use of SQLGen is to generate"]},{"entry":[{},{},"variations of these queries to assist the"]},{"entry":[{},{},"advisor component 122 in making"]},{"entry":[{},{},"recommendations. These queries include,"]},{"entry":[{},{},"for example, sampling data from the base"]},{"entry":[{},{},"tables and estimating row counts and widths"]},{"entry":[{},{},"more efficiently."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0262","num":"0337"},"figref":["FIG. 26A","FIGS. 26B and 26C"]},"C.2 Advise Operation","In certain implementations, the advise operation is implemented as advisor component . The advise operation recommends summary tables that should be built to improve query performance for a specified cube model. Additional arguments guide the advise operation by specifying the type of queries to be issued and restricting the diskspace that should be used. The advise operation returns SQL that, if executed, will create summary tables and indexes. In addition, SQL is returned that, if executed, will refresh the summary table to keep the summary table in synch with changes made to the base tables. In certain implementations, the user or application that calls the advise operation executes the SQL.","C.2.1 Advise Request","Table 27 describes advise request components in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0265","num":"0340"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 27"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"XML",{},{}]},{"entry":["Name","element","Values","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["cubeModelRef","XML",{},"Cube model to optimize."]},{"entry":[{},"string"]},{"entry":["drilldown","XML","Yes\/No","Specifies if drilldown style"]},{"entry":[{},"string",{},"queries that typically"]},{"entry":[{},"[optional]",{},"access the top slices of the"]},{"entry":[{},{},{},"model will be issued."]},{"entry":["report","XML","Yes\/No","Specifies if report style"]},{"entry":[{},"string",{},"queries that can reference"]},{"entry":[{},"[optional]",{},"any slice of the model will"]},{"entry":[{},{},{},"be issued."]},{"entry":["extract","XML","Yes\/No","Specifies if extract style"]},{"entry":[{},"string",{},"queries will be issued. An"]},{"entry":[{},"[optional]",{},"example would be"]},{"entry":[{},{},{},"extracting data into a"]},{"entry":[{},{},{},"MOLAP store."]},{"entry":["drillthrough","XML","Yes\/No","Specifies if drillthrough"]},{"entry":[{},"string",{},"queries will be issued. An"]},{"entry":[{},"[optional]",{},"example would be using"]},{"entry":[{},{},{},"drilling from hybrid into a"]},{"entry":[{},{},{},"database."]},{"entry":["tablespaceName","XML",{},"Tablespace to put the"]},{"entry":[{},"string",{},"summary tables in."]},{"entry":[{},"[optional]"]},{"entry":["indexspaceName","XML",{},"Tablespace to put the"]},{"entry":[{},"string",{},"summary table indexes in."]},{"entry":[{},"[optional]"]},{"entry":["diskspaceLimit","XML",{},"Diskspace (in bytes)"]},{"entry":[{},"double",{},"available for the summary"]},{"entry":[{},"[optional]",{},"tables and their indexes."]},{"entry":[{},{},{},"Allows users to make"]},{"entry":[{},{},{},"tradeoffs between query"]},{"entry":[{},{},{},"performance and"]},{"entry":[{},{},{},"diskspace. Specifying 0"]},{"entry":[{},{},{},"means unlimited. Default"]},{"entry":[{},{},{},"is unlimited."]},{"entry":["timeLimit","XML",{},"The amount of time (in"]},{"entry":[{},"integer",{},"seconds) that may be used"]},{"entry":[{},"[optional]",{},"in making"]},{"entry":[{},{},{},"recommendations. This"]},{"entry":[{},{},{},"allows users to tradeoff"]},{"entry":[{},{},{},"time between the"]},{"entry":[{},{},{},"optimization stage and"]},{"entry":[{},{},{},"query performance. This is"]},{"entry":[{},{},{},"useful since at some point"]},{"entry":[{},{},{},"the advisor component 122"]},{"entry":[{},{},{},"will be unable to come up"]},{"entry":[{},{},{},"with better"]},{"entry":[{},{},{},"recommendations no"]},{"entry":[{},{},{},"matter how much time it"]},{"entry":[{},{},{},"spends on analysis."]},{"entry":[{},{},{},"Specifying 0 means"]},{"entry":[{},{},{},"unlimited. Default is"]},{"entry":[{},{},{},"unlimited."]},{"entry":["sampling","XML","Yes\/No","Specifies if data sampling"]},{"entry":[{},"string",{},"should be done of the base"]},{"entry":[{},"[optional]",{},"tables of the cube model."]},{"entry":[{},{},{},"Sampling can improve the"]},{"entry":[{},{},{},"recommendations but will"]},{"entry":[{},{},{},"increase the time for the"]},{"entry":[{},{},{},"advisor component 122 to"]},{"entry":[{},{},{},"run. If sampling is not"]},{"entry":[{},{},{},"allowed, then the advisor"]},{"entry":[{},{},{},"component 122 makes"]},{"entry":[{},{},{},"recommendations based on"]},{"entry":[{},{},{},"database statistics."]},{"entry":[{},{},{},"Sometimes users have a"]},{"entry":[{},{},{},"small replica of the"]},{"entry":[{},{},{},"original data. They can"]},{"entry":[{},{},{},"tweak the database"]},{"entry":[{},{},{},"statistics to make it look as"]},{"entry":[{},{},{},"though the tables are the"]},{"entry":[{},{},{},"same size as the original"]},{"entry":[{},{},{},"tables and then specify that"]},{"entry":[{},{},{},"sampling should not be"]},{"entry":[{},{},{},"done. The advisor"]},{"entry":[{},{},{},"component 122 will then"]},{"entry":[{},{},{},"make recommendations"]},{"entry":[{},{},{},"based on the database"]},{"entry":[{},{},{},"statistics."]},{"entry":["refresh","XML","immediate","Specifies whether the"]},{"entry":[{},"string","or","RDBMS 110 will refresh"]},{"entry":[{},"[optional]","deferred","the summary tables"]},{"entry":[{},{},{},"immediately when the base"]},{"entry":[{},{},{},"tables change in order to"]},{"entry":[{},{},{},"ensure they are"]},{"entry":[{},{},{},"synchronized or defer the"]},{"entry":[{},{},{},"update. The refresh script"]},{"entry":[{},{},{},"varies based on the choice"]},{"entry":[{},{},{},"made here. For example,"]},{"entry":[{},{},{},"refresh deferred means the"]},{"entry":[{},{},{},"user specifies when the"]},{"entry":[{},{},{},"summary tables are to be"]},{"entry":[{},{},{},"refreshed. For refresh"]},{"entry":[{},{},{},"immediate, the user may or"]},{"entry":[{},{},{},"may not need to run the"]},{"entry":[{},{},{},"refresh script (it depends"]},{"entry":[{},{},{},"on how the user updates"]},{"entry":[{},{},{},"the base tables)."]},{"entry":[{},{},{},"In any case, the refresh"]},{"entry":[{},{},{},"script for the immediate"]},{"entry":[{},{},{},"case does a simple refresh"]},{"entry":[{},{},{},"which the RDBMS 110"]},{"entry":[{},{},{},"will do \u201cincrementally\u201d"]},{"entry":[{},{},{},"(i.e., update the"]},{"entry":[{},{},{},"aggregations that were"]},{"entry":[{},{},{},"affected by changes to the"]},{"entry":[{},{},{},"base tables, which is faster"]},{"entry":[{},{},{},"than building complete"]},{"entry":[{},{},{},"aggregations). In certain"]},{"entry":[{},{},{},"implementations, a refresh"]},{"entry":[{},{},{},"from cursor options"]},{"entry":[{},{},{},"provides a faster refresh."]},{"entry":["hints","XML",{},"User provides additional"]},{"entry":[{},"element",{},"information to the advisor"]},{"entry":[{},"[optional]",{},"component 122 to improve"]},{"entry":[{},{},{},"the recommendations. For"]},{"entry":[{},{},{},"example, the user specifies"]},{"entry":[{},{},{},"regions (slices and"]},{"entry":[{},{},{},"ROLLUPs) of the cube"]},{"entry":[{},{},{},"model that guide the"]},{"entry":[{},{},{},"advisor component 122 in"]},{"entry":[{},{},{},"its optimization. Regions"]},{"entry":[{},{},{},"can be specified as"]},{"entry":[{},{},{},"required, suggested or"]},{"entry":[{},{},{},"ignored. Those specified"]},{"entry":[{},{},{},"as required will be created."]},{"entry":[{},{},{},"Those specified as"]},{"entry":[{},{},{},"suggested will be treated as"]},{"entry":[{},{},{},"defining which portions of"]},{"entry":[{},{},{},"the cube model is most"]},{"entry":[{},{},{},"important to optimize."]},{"entry":[{},{},{},"Those specified as ignore"]},{"entry":[{},{},{},"specify that a portion of a"]},{"entry":[{},{},{},"cube model is in the"]},{"entry":[{},{},{},"MOLAP data store so there"]},{"entry":[{},{},{},"is no need to optimize that"]},{"entry":[{},{},{},"portion within the"]},{"entry":[{},{},{},"relational database."]},{"entry":[{},{},{},"Experienced DBAs can"]},{"entry":[{},{},{},"specify regions to more"]},{"entry":[{},{},{},"precisely control what data"]},{"entry":[{},{},{},"is summarized. For"]},{"entry":[{},{},{},"example, the DBA could"]},{"entry":[{},{},{},"specify how deep in a"]},{"entry":[{},{},{},"hierarchy it is necessary to"]},{"entry":[{},{},{},"optimize. The advisor"]},{"entry":[{},{},{},"component 122 will still"]},{"entry":[{},{},{},"recommend indexes. In"]},{"entry":[{},{},{},"certain implementations,"]},{"entry":[{},{},{},"specification of the hybrid"]},{"entry":[{},{},{},"pivot attributes which are"]},{"entry":[{},{},{},"always included in hybrid"]},{"entry":[{},{},{},"queries are allowed."]},{"entry":[{},{},{},"In certain implementations,"]},{"entry":[{},{},{},"the hints are a set of XML"]},{"entry":[{},{},{},"elements, in which each"]},{"entry":[{},{},{},"XML element references a"]},{"entry":[{},{},{},"slice or region and has an"]},{"entry":[{},{},{},"attribute indicating"]},{"entry":[{},{},{},"whether the slice or region"]},{"entry":[{},{},{},"was required or"]},{"entry":[{},{},{},"recommended."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"The following is a sample advise request in XML:",{"@attributes":{"id":"p-0267","num":"0342"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<?xml version=\u201c1.0\u201d encoding=\u201cUTF-8\u201d ?>"},{"entry":"- <olap:request xmlns:olap=\u201chttp:\/\/www.ibm.com\/olap\u201d"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"xmlns:xsi=\u201chttp:\/\/www.w3.org\/2001\/XMLSchema-instance\u201d"]},{"entry":[{},"xmlns:xsd=\u201chttp:\/\/www.w3.org\/2001\/XMLSchema\u201d"]},{"entry":[{},"version=\u201c8.1.2.1.0\u201d> -"]},{"entry":[{},"<advise diskspaceLimit=\u201c75000\u201d timeLimit=\u201c300\u201d sampling=\u201cyes\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"refresh=\u201cimmediate\u201d drilldown=\u201cyes\u201d report=\u201cyes\u201d"]},{"entry":[{},"drillthrough=\u201cno\u201d"]},{"entry":[{},"extract=\u201cno\u201d tablespaceName=\u201cTS_TABLES\u201d"]},{"entry":[{},"indexspaceName=\u201cTS_TABLES\u201d> <cubeModelRef"]},{"entry":[{},"name=\u201cSalesModel\u201d"]},{"entry":[{},"schema=\u201cMDSAMPLE\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<\/advise>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<\/olap:request>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Table 28 describes advise response components in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0269","num":"0344"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 28"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"XML","Return code, type, and"]},{"entry":["Status","element","message for operation"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["info","XML","Provides additional details of"]},{"entry":[{},"element","advise operation to provide users"]},{"entry":[{},{},"an understanding of key"]},{"entry":[{},{},"decisions made by the advisor"]},{"entry":[{},{},"component 122. This may show"]},{"entry":[{},{},"conditions that caused some"]},{"entry":[{},{},"parts of the model to not be"]},{"entry":[{},{},"optimized or additional"]},{"entry":[{},{},"information about what"]},{"entry":[{},{},"optimizations were done."]},{"entry":["returnCode","XML","Return code for operation."]},{"entry":[{},"integer"]},{"entry":["returnMessage","XML","Return message for operation."]},{"entry":[{},"string"]},{"entry":["query Improvement","XML","An estimate of how much query"]},{"entry":[{},"integer","performance will be improved if"]},{"entry":[{},{},"the recommended summary"]},{"entry":[{},{},"tables are created. In certain"]},{"entry":[{},{},"implementations, this is an"]},{"entry":[{},{},"approximation."]},{"entry":["diskspace","XML","An estimate of total diskspace"]},{"entry":[{},"integer","required for the recommended"]},{"entry":[{},{},"summary tables and indexes."]},{"entry":["SQL","XML","SQL to create and populate a"]},{"entry":[{},"element","summary table and create"]},{"entry":[{},{},"indexes on it. User or"]},{"entry":[{},{},"application executes the SQL."]},{"entry":["refreshSQL","XML","SQL to refresh the summary"]},{"entry":[{},"element","tables to synchronize them with"]},{"entry":[{},{},"base tables that have been"]},{"entry":[{},{},"updated. Refresh may not be"]},{"entry":[{},{},"applicable for refresh immediate"]},{"entry":[{},{},"summary tables (depending on"]},{"entry":[{},{},"how users update the base"]},{"entry":[{},{},"tables)."]},{"entry":["improvedRegion","XML","This shows the regions that will"]},{"entry":[{},"element","see a performance improvement."]},{"entry":[{},{},"If there are multiple slices for a"]},{"entry":[{},{},"virtual cube then the region that"]},{"entry":[{},{},"will improve is from the bottom"]},{"entry":[{},{},"slice generated to the top of the"]},{"entry":[{},{},"cube. A complicating factor is"]},{"entry":[{},{},"that non-distributive functions"]},{"entry":[{},{},"such as STDDEV will only be"]},{"entry":[{},{},"improved in the ROLLUP case,"]},{"entry":[{},{},"not the slice case. The"]},{"entry":[{},{},"optimized regions will be"]},{"entry":[{},{},"specified as a set of slices."]},{"entry":["aggregations","XML","The slices and regions that will"]},{"entry":[{},"element","be preaggregated in order to"]},{"entry":[{},{},"optimize queries."]},{"entry":[{},{},"[slice] [week (time)] [city"]},{"entry":[{},{},"(market)] [SKU (product)]"]},{"entry":[{},{},"[diskspace]"]},{"entry":[{},{},"[region] [all-quarter (time)]"]},{"entry":[{},{},"[all-region (market)]"]},{"entry":[{},{},"[all-category (product)]"]},{"entry":[{},{},"[diskspace]"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The following is a sample advise response in XML, which provides the user with feedback about what aggregations were recommended in OLAP metadata terms. The advise response summarizes the recommended SQL from the perspective of an OLAP user rather than a SQL user.",{"@attributes":{"id":"p-0271","num":"0346"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"- <olap:response xmlns:olap=\u201chttp:\/\/www.ibm.com\/olap\u201d"},{"entry":"xmlns:xsi=\u201chttp:\/\/www.w3.org\/2001\/XMLSchema-instance\u201d"},{"entry":"xmlns:xsd=\u201chttp:\/\/www.w3.org\/2001\/XMLSchema\u201d"},{"entry":"version=\u201c8.1.2.1.0\u201d>"},{"entry":"- <advise>"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<status id=\u201c0\u201d text=\u201cOperation completed successfully. No"]},{"entry":[{},"errors were encountered.\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"type=\u201cinformational\u201d \/>"},{"entry":"- <info>"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<message id=\u201c7401\u201d text=\u201cThe DB2INFO.MQT0000000041T01"]},{"entry":[{},"summary table is"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"recommended. It is estimated to have 100 rows, 55KB table size and"},{"entry":"5KB index size.\u201d \/>"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<message id=\u201c7401\u201d text=\u201cThe DB2INFO.MQT0000000041T02"]},{"entry":[{},"summary table is"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"recommended. It is estimated to have 8 rows, 4KB table size and"},{"entry":"1KB index size.\u201d \/>"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<message id=\u201c7406\u201d text=\u201cThe PART dimension does not"]},{"entry":[{},"have any hierarchies that can"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"be optimized by the Optimization Advisor. The recommendations"},{"entry":"will not optimize for"},{"entry":"any attributes from this dimension.\u201d \/>"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/info>"]},{"entry":[{},"<recommendation queryImprovement=\u201c55\u201d"]},{"entry":[{},"diskspace=\u201c65108\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"- <sql>"},{"entry":"- <![CDATA["},{"entry":"--"},{"entry":"*******************************************************"},{"entry":"-- * Script to create\/refresh summary tables."},{"entry":"-- *"},{"entry":"-- * Cube model schema: MDSAMPLE"},{"entry":"- * Cube model name: SalesModel"},{"entry":"- * Diskspace limit: 75000"},{"entry":"-- * Time limit: 300"},{"entry":"-- * Sampling: Yes"},{"entry":"-- * Drill down: Yes"},{"entry":"-- * Report: Yes"},{"entry":"-- * Drill through: No"},{"entry":"-- * Extract: No"},{"entry":"-- * Refresh type: Refresh immediate"},{"entry":"-- * Tablespace name: TS_TABLES"},{"entry":"- * Indexspace name: TS_TABLES"},{"entry":"-"},{"entry":"*******************************************************"},{"entry":"DROP TABLE DB2INFO.MQT0000000041T01;"},{"entry":"DROP TABLE DB2INFO.MQT0000000041T02;"},{"entry":"UPDATE COMMAND OPTIONS USING c OFF;"},{"entry":"CREATE SUMMARY TABLE DB2INFO.MQT0000000041T01 AS"},{"entry":"(SELECT"},{"entry":"SUM(T2.\u201cCOGS\u201d) AS \u201cCOGS\u201d,"},{"entry":"SUM(T2.\u201cMARKETING\u201d+T2.\u201cPAYROLL\u201d) AS \u201cEXPENSE\u201d,"},{"entry":"SUM(T2.\u201cMARKETING\u201d) AS \u201cMARKETING\u201d,"},{"entry":"SUM(T2.\u201cPAYROLL\u201d) AS \u201cPAYROLL\u201d,"},{"entry":"SUM(T2.\u201cSALES\u201d\u2212(T2.\u201cCOGS\u201d+"},{"entry":"(T2.\u201cMARKETING\u201d+T2.\u201cPAYROLL\u201d)))AS"},{"entry":"\u201cPROFIT\u201d,"},{"entry":"SUM(T2.\u201cSALES\u201d) AS \u201cSALES\u201d,"},{"entry":"COUNT(*) AS \u201cCOUNT\u201d,"},{"entry":"T5.\u201cREGION\u201d AS \u201cREGION\u201d,"},{"entry":"T5.\u201cDIRECTOR\u201d AS \u201cDIRECTOR\u201d,"},{"entry":"T6.\u201cFAMILY\u201d AS \u201cFAMILY\u201d,"},{"entry":"T6.\u201cFAMILYNAME\u201d AS \u201cFAMILYNAME\u201d,"},{"entry":"T3.\u201cSKU\u201d AS \u201cSKU\u201d,"},{"entry":"T3.\u201cCAFFEINATED\u201d AS \u201cCAFFEINATED\u201d,"},{"entry":"T3.\u201cOUNCES\u201d AS \u201cOUNCES\u201d,"},{"entry":"T3.\u201cPKGTYPE\u201d AS \u201cPKGTYPE\u201d,"},{"entry":"T3.\u201cSKUNAME\u201d AS \u201cSKUNAME\u201d,"},{"entry":"T4.\u201cYEAR\u201d AS \u201cYEAR\u201d"},{"entry":"FROM"},{"entry":"\u201cMDSAMPLE\u201d.\u201cMARKET\u201d AS T1,"},{"entry":"\u201cMDSAMPLE\u201c.\u201dSALESFACT\u201d AS T2,"},{"entry":"\u201cMDSAMPLE\u201c.\u201dPRODUCT\u201d AS T3,"},{"entry":"\u201cMDSAMPLE\u201d.\u201cTIME\u201d AS T4,"},{"entry":"\u201cMDSAMPLE\u201c.\u201dREGION\u201d AS T5,"},{"entry":"\u201cMDSAMPLE\u201c.\u201dFAMILY\u201d AS T6"},{"entry":"WHERE"},{"entry":"T1.\u201cSTATEID\u201d=T2.\u201cSTATEID\u201d AND"},{"entry":"T3.\u201cPRODUCTID\u201d=T2.\u201cPRODUCTID\u201dAND"},{"entry":"T4.\u201cTIMEID\u201d=T2.\u201cTIMEID\u201d AND"},{"entry":"T1.\u201cREGIONID\u201d=T5.\u201cREGIONID\u201d AND"},{"entry":"T3.\u201cFAMILYID\u201d=T6.\u201cFAMILYID\u201d"},{"entry":"GROUP BY"},{"entry":"T5.\u201cREGION\u201d,"},{"entry":"T5.\u201cDIRECTOR\u201d,"},{"entry":"T6.\u201cFAMILY\u201d,"},{"entry":"T6.\u201cFAMILYNAME\u201d,"},{"entry":"T3.\u201cSKU\u201d,"},{"entry":"T3.\u201cCAFFEINATED\u201d,"},{"entry":"T3.\u201cOUNCES\u201d,"},{"entry":"T3.\u201cPKGTYPE\u201d,"},{"entry":"T3.\u201cSKUNAME\u201d,"},{"entry":"T4.\u201cYEAR\u201d)"},{"entry":"DATA INITIALLY DEFERRED"},{"entry":"REFRESH IMMEDIATE"},{"entry":"IN \u201cTS_TABLES\u201d"},{"entry":"INDEX IN \u201cTS_TABLES\u201d"},{"entry":"NOT LOGGED INITIALLY;"},{"entry":"COMMENT ON TABLE DB2INFO.MQT0000000041T01 IS"},{"entry":"\u2018AST created for cube"},{"entry":"model MDSAMPLE.SalesModel\u2019;"},{"entry":"REFRESH TABLE DB2INFO.MQT0000000041T01;"},{"entry":"CREATE INDEX DB2INFO.IDX0000000041T0101 ON"},{"entry":"DB2INFO.MQT0000000041T01(\u201cFAMILY\u201d,"},{"entry":"\u201cSKU\u201d);"},{"entry":"CREATE INDEX DB2INFO.IDX0000000041T0102 ON"},{"entry":"DB2INFO.MQT0000000041TO1(\u201cREGION \u201d);"},{"entry":"RUNSTATS ON TABLE DB2INFO.MQT0000000041T01 AND"},{"entry":"INDEXES ALL;"},{"entry":"CREATE SUMMARY TABLE DB2INFO.MQT0000000041T02 AS"},{"entry":"(SELECT"},{"entry":"SUM(T2.\u201cCOGS\u201d) AS \u201cCOGS\u201d,"},{"entry":"SUM(T2.\u201cMARKETING\u201d+T2.\u201cPAYROLL\u201d) AS \u201cEXPENSE\u201d,"},{"entry":"SUM(T2.\u201cMARKETING\u201d) AS \u201cMARKETING\u201d,"},{"entry":"SUM(T2.\u201cPAYROLL\u201d) AS \u201cPAYROLL\u201d,"},{"entry":"SUM(T2.\u201cSALES\u201d\u2212(T2.\u201cCOGS\u201d+"},{"entry":"(T2.\u201cMARKETING\u201d+T2.\u201cPAYROLL\u201d)))AS"},{"entry":"\u201cPROFIT\u201d,"},{"entry":"SUM(T2.\u201cSALES\u201d) AS \u201cSALES\u201d,"},{"entry":"COUNT(*) AS \u201cCOUNT\u201d,"},{"entry":"T1.\u201cYEAR\u201d AS \u201cYEAR\u201d,"},{"entry":"T1.\u201cQUARTER\u201d AS \u201cQUARTER\u201d"},{"entry":"FROM"},{"entry":"\u201cMDSAMPLE\u201c.\u201dTME\u201d AS T1,"},{"entry":"\u201cMDSAMPLE\u201c.\u201dSALESFACT\u201d AS T2"},{"entry":"WHERE"},{"entry":"T1.\u201cTIMEID\u201d=T2.\u201cTIMEID\u201d"},{"entry":"GROUP BY"},{"entry":"T1.\u201cYEAR\u201d,"},{"entry":"T1.\u201cQUARTER\u201d)"},{"entry":"DATA INITIALLY DEFERRED"},{"entry":"REFRESH IMMEDIATE"},{"entry":"IN \u201cTS_TABLES\u201d"},{"entry":"INDEX IN \u201cTS_TABLES\u201d"},{"entry":"NOT LOGGED INITIALLY;"},{"entry":"COMMENT ON TABLE DB2INFO.MQT0000000041T02 IS"},{"entry":"\u2018AST created for cube"},{"entry":"model MDSAMPLE.SalesModel\u2019;"},{"entry":"REFRESH TABLE DB2INFO.MQT0000000041T02;"},{"entry":"CREATE INDEX DB2INFO.IDX0000000041T02C ON"},{"entry":"DB2INFO.MQT0000000041T02(\u201cQUARTER\u201d) CLUSTER;"},{"entry":"REORG TABLE DB2INFO.MQT0000000041T02;"},{"entry":"RUNSTATS ON TABLE DB2INFO.MQT0000000041T02 AND"},{"entry":"INDEXES ALL;"},{"entry":"COMMIT;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"]]>"]},{"entry":[{},"<\/sql>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"- <refreshSql>"},{"entry":"- <![CDATA["},{"entry":"--"},{"entry":"*******************************************************"},{"entry":"-- * Script to create\/refresh summary tables."},{"entry":"- *"},{"entry":"-- * Cube model schema: MDSAMPLE"},{"entry":"- * Cube model name: SalesModel"},{"entry":"- * Diskspace limit: 75000"},{"entry":"-- * Time limit: 300"},{"entry":"-- * Sampling: Yes"},{"entry":"-- * Drill down: Yes"},{"entry":"-- * Report: Yes"},{"entry":"-- * Drill through: No"},{"entry":"-- * Extract: No"},{"entry":"-- * Refresh type: Refresh immediate"},{"entry":"-- * Tablespace name: TS_TABLES"},{"entry":"- * Indexspace name: TS_TABLES"},{"entry":"--"},{"entry":"*******************************************************"},{"entry":"UPDATE COMMAND OPTIONS USING c OFF;"},{"entry":"REFRESH TABLE DB2INFO.MQT0000000041T01;"},{"entry":"REFRESH TABLE DB2INFO.MQT0000000041T02;"},{"entry":"COMMIT;"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"]]>"]},{"entry":[{},"<\/refreshSql>"]},{"entry":[{},"<\/advise>"]},{"entry":[{},"<\/olap:response>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":[{},{}]},{"@attributes":{"id":"p-0272","num":"0347"},"figref":["FIGS. 27A-27E","FIG. 27"],"b":["122","2710","122","2712","122","122","110","122"]},"In block , the advisor component  reads cube model metadata from, for example, one or more database catalogs. This includes metadata for any objects that are logically part of the cube model, including, for example, facts, dimensions, hierarchies, attributes, measures, and cubes. In block , the advisor component  analyzes the metadata. The metadata is analyzed to assist the optimizations. In certain implementations, the presence of non-distributed measures or nullable attributes prevents the use of refresh immediate.","In block , the advisor component  determines one or more measure sets. The measures are analyzed to determine if they are symmetric or asymmetric. All symmetric measures are put in one measure set. For each group of asymmetric measures with the same dimensionality an additional measure set is created. Each measure set is optimized separately. The resources provided in the request are apportioned across the measure sets based on their perceived priority. In certain implementations, the symmetric measures are given more resources. In certain implementations, the distributive measures are put in their own measure set and given more resources. In certain other implementations, measures used frequently are placed into a high priority measure set based on usage information or appearance in cubes of the cube model.","In block , the advisor component  selects the next measure set to be a current measure set, starting with a first measure set. In block , the advisor component  determines one or more summary tables to create for the current measure set. In block , the advisor component  determines one or more indexes to create on the one or more summary tables. In block , the advisor component  determines whether there are more measure sets. If so, processing continues to block  to select the next measure set, otherwise, processing continues to block . In block , the advisor component  generates SQL to create the one or more summary tables and indexes. In block , the advisor component  returns a response (e.g., writes an XML response). The response contains, for example, the recommended SQL as well as additional information about the optimization that was done.",{"@attributes":{"id":"p-0276","num":"0351"},"figref":"FIG. 27B","b":"122"},"In , control begins at block  with the advisor component  determining whether an extract query is to be run. If so, processing continues to block , otherwise, processing continues to block . In block , the advisor component  defines one or more summary tables to optimize the extract query.","In block , the advisor component  determines whether a drilldown query, a report query, or a drillthrough query is to be run. If so, processing continues to block , otherwise, processing is done. In block , the advisor component  consolidates hierarchies. If any dimensions have multiple hierarchies, then an attempt is made to consolidate these hierarchies to reduce the number of virtual cubes that are optimized. In block , the advisor component  determines filters. It is determined whether there are any filters that increase or decrease the optimization of a region of a virtual cube. For drillthrough queries, the optimization is restricted to the region of the cube model defined by cubes. In certain implementations, filters are derived from workload usage history.","In block , the advisor component  gets a set of virtual cubes. In block , the advisor component  optimizes one of the filtered virtual cubes, starting with a first virtual cube. In block , the advisor component  determines whether there is another virtual cube to process. If so, processing loops back to block , otherwise, processing is done.","That is, each virtual cube in a set of virtual cubes is optimized. The number of virtual cubes is determined by the number of hierarchies remaining after the hierarchy consolidation step. In certain implementations, the resources available are divided equally among the virtual cubes. In certain other implementations, more resources are provided to the virtual cubes that are larger, which are deemed more important because there are cubes defined or based on usage history. The advisor component  loops through each virtual cube performing the appropriate optimization.",{"@attributes":{"id":"p-0281","num":"0356"},"figref":"FIG. 27C","b":["122","122"]},"In , control begins at block  with the advisor component  obtaining a lowest slice (i.e., a bottom slice) for each cube based on the cube model. In certain implementations, for an extract query, the advisor component  analyzes the details of the cubes created for the cube model and generates slice candidates. For each cube, a slice candidate is created from the lowest level of each cube hierarchy in the cube.","In block , the advisor component  consolidates slices. Any duplicate slice candidates are removed. In certain implementations, slices are consolidated if they are a subset of other slices. Slice consolidation can also be done by creating a lower level slice that can satisfy two or more other candidate slices.","In block , the advisor component  makes one summary table for each slice. That is, each remaining slice becomes a summary table. In block , the advisor component  determines whether the summary tables fit in the disk limit. If there is a diskspace limit, for each summary table, the amount of diskspace used is estimated. If so, processing is done, otherwise, processing continues to block . In block , the advisor component  removes the largest summary table, and processing loops back to block . In certain implementations, metadata is used to distinguish between regular cubes (e.g., Essbase\u2122 cubes and hybrid cubes) so that better optimization may be done for drillthrough queries. In certain implementations, the advisor component  also estimates improvement based on the recommended summary tables remaining on the list.",{"@attributes":{"id":"p-0285","num":"0360"},"figref":"FIG. 27D"},"One technique for selecting slices is to pick stacked slices. An alternative technique is to select crossing slices.  illustrates logic for selecting stacked slices merely for illustration of one technique, however, it is to be understood that the invention may be practiced with other techniques for selecting slices without departing from the scope of the invention. When evaluating slices and rollups one consideration is whether the slices and rollups meet predefined limitations. These limitations, which are checked in several places in the logic include, for example: 1) limits imposed by the user, such as disk space restrictions; 2) advisor limits, such as row limits to ensure slices are sufficiently different in size to make their existence worthwhile; and, 3) system limits, such as the maximum number of columns that can be in a table.","In , control begins at block  with the advisor component  restricting a region and\/or limits based on facts size and user limits. In block , the advisor component  selects the highest rated slice in the region that meets the limits. In block , the advisor component  determines whether there should be an increase in coverage. If so, processing continues to block , otherwise, processing continues to block . In block , the advisor component  restricts the region and\/or limits based on a previously selected slice.  illustrate slices and ROLLUP slices in accordance with certain implementations of the invention. For example, in , a region  is selected, a slice  in the region  is selected, a region  above the slice  is selected, and another slice  is selected.","In particular, a slice is selected by selecting a region of the cube model that the slice must reside in, establishing limits that restrict the slice (e.g., diskspace and row count), and iterating through the slices within the region looking for the highest rated slice that meets the limits until there is sufficient coverage. The amount of slices required is dependent on several factors, including, for example, the size of the base tables and how optimized the queries are to be. On the initial pass, the region to be optimized is the entire virtual cube. The diskspace limit is set based on the user provided value. The row limit is set to be 10\u00d7 less than the number of fact rows. The logic iteratively drills down one level at a time. For each drill, the possible slices are rated and the highest rated slice selected. The looping stops when no more levels can be drilled because the limits have been reached or the bottom slice of the region has been selected. On subsequent passes, the region is restricted to the subset of the virtual cube that is at or above the previously selected slice. The limits for diskspace and row count are set to a value (10\u00d7-100\u00d7) less than the previously selected slice. Once sufficient coverage has been provided the loop exits.","In block , the advisor component  determines whether there are drilldown queries. If so, processing continues to block , otherwise, processing is done. In block , the advisor component  determines whether there are non-distributed measures. If so, processing continues to block , otherwise, processing is done. In block , the advisor component  restricts the region to correlated dimensions and scope limits. In block , the advisor component  selects the highest rated rollup in the region that meets the limits. In block , the advisor component  determines whether there should be an increase in coverage. If so, processing loops back to block , otherwise, processing is done. For example, in , a region  is selected, a rollup  in the region  is selected, another region  is selected, and another rollup  in the region  is selected.","Drilldown queries may require faster response times than report queries, so more slices may be recommended for them. When drillthrough queries are specified, only lower slices are selected and crossing slices may be more optimal. For drilldown queries, if there are non-distributive measures, then one or more rollups may be generated. Rollups can be very computationally complex and are constrained to a small number of dimensions. If the cube model has many dimensions, then several rollups may be created, each on a different subset of dimensions. When creating rollups, a set of dimensions that are highly correlated are selected. This means dimensions that tend to appear in queries together. This may be determined by looking at the dimensions contained in cubes or by usage metrics. A region is specified to cover a set of correlated dimensions. Then, the best rated rollup that meets limits and is within the region is selected. The process repeats, selecting additional sets of related dimensions to be regions and selecting the best rollup within the region. The processing stops when either resources have been exhausted or sufficient coverage provided.","In certain implementations, for drillthrough queries, the advisor component  will first attempt to select a slice that corresponds to the bottom of the region to be optimized. If this slice meets the diskspace restriction, then this slice will be used. Additional crossing slices will be chosen from candidate slices with the highest dimensional cardinality. In certain implementations, metadata is used to distinguish between pure multidimensional OLAP (MOLAP) and hybrid (HOLAP) cubes so that better optimization can be done of drillthrough queries.",{"@attributes":{"id":"p-0292","num":"0367"},"figref":"FIG. 27E"},"In , control begins at block  with the advisor component  creating a clustering index. As for creating the clustering index, in certain implementations, a hierarchy index is created from one of the hierarchies to serve as the clustering index. If possible, a hierarchy from the Time dimension is used. If there is more than one hierarchy fitting this criteria, then the Time dimension hierarchy with the highest cardinality is used. If there is no Time dimension, then the hierarchy with the highest cardinality, compared to any of the other hierarchies in the cube model. If the clustering index fits within the diskspace limit allotted for the indexes, then this is used as a clustering index for the summary table. In certain implementations, if the selected clustering index does not fit in the index diskspace limit, no clustering index is defined.","In block , the advisor component  creates regular index candidates. In block , the advisor component  determines whether there are any candidates left. If so, processing continues to block , otherwise, processing is done. In block , the advisor component  selects the highest rated candidate. In block , the advisor component  determines whether the index fits and is not a duplicate of the clustering index or other index selected for the summary table. If so, processing continues to block , otherwise, processing continues to block  and the index is discarded. In block , the advisor component  adds the candidate as a regular index. In block , the advisor component  determines whether the index limit has been reached. If so, processing is done, otherwise, processing loops back to block .","As for creating normal indexes, hierarchy indexes are created out of each of the hierarchies represented in the summary table to form a list of potential indexes for the summary table. From the list of potential indexes, indexes are selected for the summary table. In certain implementations, all of the indexes are hierarchy indexes, and the indexes that are selected are the ones with the highest cardinality on the bottom level. If the estimated index size fits within the index diskspace limit, and is not a duplicate of the clustering index or any other indexes selected for the summary table, then the index is added as a regular index, otherwise, the index is discarded and another index is selected. As many indexes as can fit within the index diskspace limit are selected for the summary table. In certain implementations, a maximum of four indexes are selected.",{"@attributes":{"id":"p-0296","num":"0371"},"figref":"FIGS. 28A-28D","b":["122","2800","2810","2820","2830","2830"]},"The following table 29 lists the metadata objects and for each shows how the metadata object affects the optimization process in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0298","num":"0373"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 29"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Object","Affect on Optimization"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Cube Model","The object that is being optimized."]},{"entry":["Join","Joins generally do not impact the optimization."]},{"entry":[{},"The required joins will be included in the"]},{"entry":[{},"generated SQL. The number of joins eliminated"]},{"entry":[{},"may be considered as part of the evaluation of"]},{"entry":[{},"determining the cost of the queries without the"]},{"entry":[{},"presence of the summary table."]},{"entry":["Facts","Individual measures are considered within the"]},{"entry":[{},"facts."]},{"entry":["Dimension","Dimensions and their hierarchies determine the"]},{"entry":[{},"virtual cubes which are optimized. Time"]},{"entry":[{},"dimensions are given preferential treatment and"]},{"entry":[{},"are considered good candidates for clustered"]},{"entry":[{},"indexes and are given priority when selecting"]},{"entry":[{},"aggregations."]},{"entry":["Hierarchy","Hierarchies are useful in the optimization"]},{"entry":[{},"process. The number and depth of the"]},{"entry":[{},"hierarchies has a large affect on the complexity"]},{"entry":[{},"of optimizing and how complex the resulting"]},{"entry":[{},"recommended summary tables are. The time"]},{"entry":[{},"required to develop recommendations increases"]},{"entry":[{},"when there are more hierarchies or deeper"]},{"entry":[{},"hierarchies because this increases the number of"]},{"entry":[{},"possible slices that must be considered. The"]},{"entry":[{},"advisor component 122 attempts to consolidate"]},{"entry":[{},"multiple hierarchies within a dimension. When"]},{"entry":[{},"the advisor component 122 is unable to do so,"]},{"entry":[{},"then the advisor component 122 optimizes a"]},{"entry":[{},"larger number of virtual cubes. Network"]},{"entry":[{},"hierarchies are transformed into regular"]},{"entry":[{},"hierarchies. Recursive hierarchies are ignored."]},{"entry":["Attribute","Use to determine which additional attributes"]},{"entry":["Relationship","should be brought into the summary table."]},{"entry":["Attribute","Attribute widths and nullability are used to"]},{"entry":[{},"calculate summary table and index widths."]},{"entry":[{},"Attribute widths and nullability are used to rate"]},{"entry":[{},"the desirability of including the attribute in an"]},{"entry":[{},"aggregation. If there are nullable attributes, then"]},{"entry":[{},"each summary table will contain a single"]},{"entry":[{},"one-slice aggregation."]},{"entry":["Measure","Measure widths and nullability are used to"]},{"entry":[{},"calculate summary table widths. The"]},{"entry":[{},"aggregations used in measures are analyzed to"]},{"entry":[{},"determine what type of aggregations to do."]},{"entry":[{},"Categories of measures include symmetric"]},{"entry":[{},"versus asymmetric and distributive versus"]},{"entry":[{},"non-distributive. Each of these affects"]},{"entry":[{},"subsequent optimization. If all measures are"]},{"entry":[{},"distributive, then a small number of slice"]},{"entry":[{},"aggregations are created. If there are"]},{"entry":[{},"non-distributive measures, then a large number"]},{"entry":[{},"of contiguous slices (rollups) will be"]},{"entry":[{},"recommended."]},{"entry":["Cube","If optimizing for extract queries, then the cubes"]},{"entry":[{},"are used to determine which slice needs to be"]},{"entry":[{},"optimized. If optimizing for drillthrough"]},{"entry":[{},"queries, the cube is used as a filter to restrict"]},{"entry":[{},"which portions of the cube model to optimize."]},{"entry":[{},"The cube can also be used to provide hints about"]},{"entry":[{},"which dimensions and measures are closely"]},{"entry":[{},"correlated because they are referenced from the"]},{"entry":[{},"same cube."]},{"entry":["Cube Facts","Use to rate the relative importance of measures."]},{"entry":[{},"Measures that appear in multiple cubes are rated"]},{"entry":[{},"higher."]},{"entry":["Cube Dimension","Use to rate the correlation between dimensions."]},{"entry":[{},"Dimensions that appear in the same cubes are"]},{"entry":[{},"considered to be synergistic and are considered a"]},{"entry":[{},"higher priority to have in the same summary"]},{"entry":[{},"table."]},{"entry":["Cube Hierarchy","Use to determine the slices that should be"]},{"entry":[{},"defined for extract queries. Map to regular"]},{"entry":[{},"hierarchies."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The number of potential aggregate slices in a cube model can be enormous. A slice is defined as selecting one level from each dimension hierarchy.  illustrates a representation of a cube  in accordance with certain implementations of the invention. The cube  illustrated in  has 4 dimensions that contain 5, 6, 6, 4 levels respectively (including the top \u201call\u201d level). That means cube  has 720 possible slices (5*6*6*4). This number grows rapidly as the number of dimensions increases. For models that have over 15 dimensions, it is common to have over 1,000,000 potential slices. Thus, it is efficient to minimize both the number of slices included in list of summary tables and the number of slices analyzed to determine if they should be included in the list of summary tables.","Since RDBMS  can dynamically aggregate from one slice to one that is logically higher, not all slices need to be included in the list of summary tables. Consider the slices shown in . There are two slices ,  indicated by thin lines. Additionally, the thick line  represents the grain of the datamart. The quarter-store state-customer state-product group slice is at or above the month-store city-customer city-product line slice. This allows the RDBMS  to build the slices faster because one can be built from the other. This may be referred to as \u201cstacking.\u201d A stacked slice can be aggregated from a lower slice.",{"@attributes":{"id":"p-0301","num":"0376"},"figref":["FIG. 30","FIG. 30"],"b":["3010","122","122"]},"The number of non-crossing slices is much less than the number of total possible slices. The possible slices increase based on the product of the levels in the dimensions. The number of non-crossing slices is equal to the number of levels that can be drilled to plus one. The number of drillable levels in each dimension is the number of non-all levels. For the example illustrated in , there are 18 non-crossing slices (4+5+5+3+1).","The advisor component  analyzes slices to identify slices to be in the list of recommended summary tables. The advisor component  attempts to provide reasonable recommendations quickly. The technique used by the advisor component  is to move one level down at a time. That is, the advisor component  considers the slices that it could drill to and rates each of these candidate slices. The advisor component  will drill to the highest rated candidate. So with four dimensions, the advisor component  might compare the four slices that are possible by drilling down one level. Once the advisor component  decides to \u201cdrilldown\u201d a level, the advisor component  no longer considers the higher levels in that hierarchy. By only considering non-crossing slices, the number of slices that are analyzed by the advisor component  is substantially reduced. However, it is useful to look at more than the minimum non-crossing slices so that in selecting one slice for a summary table, several slices are considered and compared from a performance perspective, which includes comparing estimated size and other metrics.","The advisor component  calculates the space required for slices that should be considered. A cost (e.g., diskspace and build time) is assigned for each slice. Additionally, a benefit (e.g., estimate of query improvement) is assigned for each slice. Moreover, a number of members per level is determined. Sparsity ratings are determined. The advisor component  then determines if multiple slices should be put into a summary table or if there should be one slice per summary table. Moreover, in certain implementations, the advisor component  avoids generating too many summary tables since when there are many candidate summary tables (e.g., 20 or more), compile time increases. The advisor component  makes use of specific information within the database catalog, including, for example, statistics. The advisor component  generates summary tables that contain ROLLUP slices if the cube model contains non-distributive measures, such as standard deviation. The advisor component  ensures that the lowest aggregation built is above the grain of the base tables. This can be done by estimating the row counts of the base slice and candidate slices. Moreover, the advisor component  does not build a slice that corresponds to the grain of the warehouse. The advisor component  ignores dimensions that do not have hierarchies.","The following illustrate formulas used to estimate certain metrics:\n\n","The following illustrates a formula used to estimate the size of the summary table:\n\n","To obtain the summary table Row Size, a PREPARE (supported by RDBMS ) of the summary table is performed to select statement to get the columns of the summary table. The lengths of each of the summary table columns is summed to get the size of one summary table row.","There are several alternatives for estimating the number (#) of rows in the summary table. In certain implementations, a sampling of the one or more fact tables and the summary table query is used to get a sample of the summary table, and the full amount is extrapolated by multiplying the result by 1\/(sampling rate).","In certain implementations, the sampling statement is performed for the summary table at increasing sampling rates. The trend of the sampling results at increasing rates is used to try to extrapolate the result of the summary table statement at 100% sampling. For example, suppose a 1% sample results in 10,000 rows and a 10% sample results in 30,000 rows. The 10\u00d7 increase in sampling data resulted in a 3\u00d7 increase in rows. If the trend continues, then assume that going from 10% to 100% sampling (another 10\u00d7increase) will result in another 3\u00d7 increase in rows. In certain implementations, this will not be a linear relationship, and, most likely when going from 0.01% to 0.1% to 1% to 10% to 100% (each of which is a 10\u00d7 increase in sampled rows), the increase in the aggregated rows will tend to flatten. So in the first increase of sampling, the aggregated row count might increase 7\u00d7, but by the last summary table interval, the aggregated row count might only increase 2\u00d7.","In certain implementations, a further improvement is to adjust the estimate based on where the slice is in the hierarchies. The higher a slice in the hierarchies, the more rapidly an estimated row count approaches the actual row count. The summary table select statement can be prepared by the relational database to get the estimated number of rows of the summary table. This value may be adjusted based on position of the levels in the summary table.","If the summary table consists of only 1 slice, the maximum cardinality of the summary table can be calculated by determining the cardinalities of each dimension at the level of the summary table slice and multiplying the cardinalities together. The actual number of rows of a summary table usually will not be the maximum cardinality. So an estimate of the number of summary table rows may be determined by creating a multiplier for the maximum cardinality, based on the levels of the slice and their position in the hierarchies of the cube model, and the number of rows in the base fact table.","There are several techniques for improving the efficiency of sampling. For example, when creating the sampling statement for the summary table, the measures in the sampling statement are not included. The result of the measures from the sample are not needed, only the count of rows resulting from the sampling statement. This reduces the amount of processing that needs to be done during the sampling statement. Also, a sample of the data taken from the base tables may be put into a temporary table, which can then be reused. This may be faster than having to resample from the base tables multiple times.","In certain implementations, the slice max cardinality is obtained by multiplying the max cardinalities of the levels; level max cardinality is obtained by multiplying the max cardinalities of the attributes; and, from the top of the hierarchy to the attribute specified by level, the attribute max cardinality is read from database statistics.","The advisor component  provides an explanation of why it choose the recommendations. The following are sample messages that the advisor component  may return as explanations: 1) Summary tables have not been defined as refresh immediate because the model contains non-distributive measures; 2) Database statistics were not available for some tables or columns; 3) Dimension &1 had &2 hierarchies consolidated into &3 hierarchies; and, 4) Clustered index was defined by selecting the highest cardinality columns.","C.3.4 Multiple Hierarchies","Dimensions can contain multiple hierarchies. If a cube model has dimensions with multiple hierarchies, then the cube model contains multiple virtual cubes. A virtual cube is a unique combination of dimension hierarchies. If there are five dimensions with 1, 1, 2, 1, 3 hierarchies respectively then there are 1*1*2*1*3=6 virtual cubes. This complicates the optimization since aggregates built for one virtual cube may not be able to be used by another virtual cube. Therefore, a separate summary table is built for each virtual cube.","To maximize the sharing of aggregates among virtual cubes, optimization consolidates hierarchies. In certain implementations, the optimization process is performed by the advisor component . Consolidation of hierarchies is done by comparing the attributes from multiple hierarchies within the same dimension. An attempt is made to replace multiple hierarchies with a single virtual hierarchy that contains an appropriate set of attributes from each hierarchy. This ensures the summary table can satisfy any of the hierarchies. There are a number of relationships that can exist between hierarchies. Table 30 provides some examples where Hn (with n being equal to an integer or character for use as an identifier) refers to a hierarchy.",{"@attributes":{"id":"p-0317","num":"0396"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 30"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Hierarchy Scenario","Optimization"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["H1 and H2 have no attributes","Since there are no attributes in"]},{"entry":["in common","common, there is no consolidation."]},{"entry":["H1 = calendarYear,","The hierarchies will remain"]},{"entry":["calendarMonth, calendarDay","separate and the advisor component"]},{"entry":["H2 = fiscalYear, fiscalMonth,","122 will process the hierarchies as"]},{"entry":["fiscalWeek","separate virtual cubes."]},{"entry":["H2 is subset from H1 by","These hierarchies can be merged"]},{"entry":["removing lowest level","into a new hierarchy:"]},{"entry":["attribute","Hx = Country, State, City,"]},{"entry":["H1 = Country, State, City,","Customer."]},{"entry":["Customer","The new hierarchy Hx satisfies"]},{"entry":["H2 = Country, State, City","both hierarchies H1 and H2."]},{"entry":[{},"Since the attributes country, state,"]},{"entry":[{},"and city were used in multiple"]},{"entry":[{},"hierarchies they will be rated higher"]},{"entry":[{},"when selecting aggregations."]},{"entry":["H2 and H3 are subsets of H1","These hierarchies H1, H2, and H3"]},{"entry":["H1 = year, quarter, month,","can be merged into a new hierarchy"]},{"entry":["day","Hx = year, quarter, month, day."]},{"entry":["H2 = year, quarter, month","This hierarchy Hx satisfies all"]},{"entry":["H3 = year, month","hierarchies."]},{"entry":[{},"Since year and month attributes"]},{"entry":[{},"appear in all three hierarchies H1,"]},{"entry":[{},"H2, and H3, the advisor component"]},{"entry":[{},"122 considers it high priority to put"]},{"entry":[{},"the common attributes in the"]},{"entry":[{},"summary table."]},{"entry":["H1 and H2 have a common","These hierarchies can be merged"]},{"entry":["attribute at the lowest level","into a new hierarchy, but since the"]},{"entry":["H1 = Country, State, City,","shared attribute is at the bottom of"]},{"entry":["CustomerId","the hierarchy, the cardinality might"]},{"entry":["H2 = CustomerGroup,","be so high that it would make the"]},{"entry":["CustomerType, CustomerId","summary table too large. The"]},{"entry":[{},"advisor component 122 will"]},{"entry":[{},"determine whether to consolidate"]},{"entry":[{},"this hierarchy based on the"]},{"entry":[{},"cardinality of the hierarchies if they"]},{"entry":[{},"were merged compared to the"]},{"entry":[{},"cardinality of the facts."]},{"entry":["H1 and H2 have the same","Since the only attribute the"]},{"entry":["attribute as the top level","hierarchies have in common is at"]},{"entry":["H1 = year, quarterOfYear,","the top level, consolidating may not"]},{"entry":["monthOfYear, dayOfMonth","be useful. So, the hierarchies are"]},{"entry":["H2 = year, weekOfYear,","not consolidated and are processed"]},{"entry":["dayOfWeek","as separate virtual cubes."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"If the hierarchies contain the same attributes, but in the opposite order, and if there are non-distributive measures, then ROLLUP slices may be generated instead of consolidating hierarchies.","C.3.5 Symmetric Vs Asymmetric Measures","Measures can be classified as symmetric, when a single aggregation function is applied to all dimensions, or asymmetric, when multiple aggregation functions are applied. If the cube model only contains symmetric measures, a simple select statement is able to calculate such measures. Likewise, the optimization will use a simple select statement to optimize all the measures. If the cube model has asymmetric measures, a multi-step select is performed for each set of compatible measures. For this type of measure, the inner-most select statement can be optimized by creating a summary table that matches the asymmetric measure. If the inner-most select statement is aggregating a very small number of dimensions, compared to the number of dimensions in the cube model, this approach may be too expensive.","In certain implementations, the incompatible measures may be combined by restructuring aggregation steps so that they are compatible (which is also referred to as \u201cnesting\u201d). Initially, a set of measures are accessed. The next measure in the set of measures is selected, starting with one (e.g., the first). It is determined whether the measure is compatible with previous measures. For the first measure processed, the determination is that the measure is compatible (as there are no previous measures for the first measure). If the measure is not compatible, it is determined whether one or more measures may be rewritten so that the selected measure is compatible with the previous measures. If one or more measures may be rewritten, one or more measures are rewritten. Then, it is determined whether there is another measure to be processed, and, if so, the next measure is processed. If there are no more measures, the rewritten measures are processed to generate a SQL statement for retrieving multidimensional information. If the selected measure is not compatible with previous measures, and cannot be rewritten, the measures are joined with another technique.","Symmetric and asymmetric measures are further described in the above cross-referenced application entitled \u201cMETHOD, SYSTEM, AND PROGRAM FOR SPECIFYING MULTIDIMENSIONAL CALCULATIONS FOR A RELATIONAL OLAP ENGINE, which is incorporated herein by reference in its entirety. In particular, the advisor component  addresses key problems in calculating multiple measures with a single SQL statement (i.e., symmetry of a measure, distributiveness of aggregation functions involved, and order dimensions appear in the aggregation script).","C.3.6 Network Hierarchies","In network hierarchies, any organization of attributes could be formed during query time, when the user is generating reports. Because of this nature, there is no parent-child relationship defined among the hierarchy attributes. The technique used to optimize this type of hierarchy is to create arbitrary parent-child relationships, and then use the same techniques for regular (i.e., non-network) hierarchies. To do that, two factors are taken into consideration: the cardinality of each attribute and the functional dependency among these attributes. It is desired to have low cardinality attributes towards the top of the hierarchy and also have functionally dependent attributes towards the top. Once this order is defined, the optimization for the hierarchy is performed as if this was a regular hierarchy.","C.3.7 Rating Slices","When considering several alternative slices, the slices are rated to determine which is the better candidate. In certain implementations, one or more of the following criteria are used to evaluate slices: 1) coverage, 2) space, 3) width, 4) column count, 5) nullability, 6) time, 7) usage history, 8) usage assumed, and 9) threshold.","As for coverage, a benefit of a slice is that if the slice is included in a summary table, then queries that use distributive measures can be satisfied by the summary table, provided the query is at or above the slice. This leads to the concept of coverage which is the number of slices of a virtual cube that are covered by a particular slice. The top slice (all levels in each hierarchy) only covers a single slice (the all slice). The bottom slice, which includes the lowest level of each hierarchy, covers all slices.","As for space, part of the cost of a slice is the diskspace required for the aggregations. As for width, the tablespace specified for the summary table determines the maximum row width. This is relevant when hierarchies have many large attribute relationships as the slices may become constrained by width before space.","As for column count, the number of columns may be considered, since there is a certain amount of fixed processing per column. As for nullability, columns that are nullable are considered less desirable. There is some overhead for dealing with nullable columns. Nullable columns also eliminate the possibility of using refresh immediate summary tables. As for time, the time dimension is considered an important dimension. A high percentage of queries are expected to use attributes from the time dimension.","As for usage history, if metrics are available that provide information about the usage patterns of slices, then usage history can be considered. Slices that provide coverage for frequently used queries would be rated higher. As for usage assumed, if no usage history is available, then the usage is surmised based on the types of queries. For example, drilldown queries will use the higher level slices far more often than lower level slices. Report style queries on the other hand tend to hit slices fairly evenly. Drillthrough queries tend to not access the upper level slices.","As for threshold, when the size or width limits are approached, the rating may be adjusted to weight these more heavily. In other words, when there is plenty of space available using more is not a critical issue. But if 90% of the space has been used, then additional usage is minimized.","When optimizing a virtual cube, there is a specified amount of diskspace available. In addition, the optimization is constrained by the width of the tablespace. As the code drills deeper into the cube model considering additional slices, the ability to drill deeper is constrained by how much space and width remain. Once either the space or width limits are reached then no more slices can be considered.","The following provide formulas for certain metrics:\n\n","An indexing strategy of the advisor component  consists of two parts: creating the clustering index and creating the non-clustering (\u201cnormal\u201d) indexes.","Several alternative strategies have been designed to determine an optimal index strategy for a summary table. A performance evaluation is done to identify one strategy as the optimal technique or to determine whether different techniques should be applied, depending on the cube model. There is a clustered index for each summary table. In addition there are several additional indexes.","C.4.1 Clustering Index","A clustered index is created on a subset of the attributes included in the summary table. A clustering index helps to keep the data in the table clustered according to the index, which can significantly reduce the number of I\/Os on queries that hit that clustered index. Currently, a hierarchy index is created from one of the hierarchies to serve as the clustering index. In certain implementations, a hierarchy from the Time dimension is used because users typically drill by the Time dimension. If there is more than one hierarchy for the Time dimension, then the Time dimension hierarchy with the highest cardinality is used. If there is no Time dimension, then a hierarchy with the highest cardinality, compared to any of the other hierarchies in the cube model, is selected. Attributes can also be included from different hierarchies and different levels. Table 31 describes criteria used to determine which attributes to include in the clustered index in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0334","num":"0419"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 31"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Criteria","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"High","Attributes with many discrete"]},{"entry":[{},"cardinality","values allow the RDBMS 110 to"]},{"entry":[{},{},"quickly eliminate most rows from"]},{"entry":[{},{},"consideration."]},{"entry":[{},"Low correlation","Including attributes that have low"]},{"entry":[{},"with other","correlation with other attributes"]},{"entry":[{},"attributes","reduces rows quickly."]},{"entry":[{},"Top of a","The higher up a hierarchy that an"]},{"entry":[{},"hierarchy","attribute is, the more likely that a"]},{"entry":[{},{},"rewritten query will include the"]},{"entry":[{},{},"attribute. This makes it more likely"]},{"entry":[{},{},"the index can be used."]},{"entry":[{},"Even","If an attribute has data distributed"]},{"entry":[{},"distribution","evenly across its discrete values,"]},{"entry":[{},"of data","then query performance should be"]},{"entry":[{},{},"more consistent than if the data is"]},{"entry":[{},{},"badly skewed."]},{"entry":[{},"Narrow","If all other factors have been"]},{"entry":[{},"width","considered and it is necessary to"]},{"entry":[{},{},"decide between competing"]},{"entry":[{},{},"attributes, then the attribute that is"]},{"entry":[{},{},"narrower is selected to conserve"]},{"entry":[{},{},"space."]},{"entry":[{},"Time","Time attributes might be good"]},{"entry":[{},{},"candidates when the data will be"]},{"entry":[{},{},"extracted in new increments by"]},{"entry":[{},{},"time."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In certain implementations, attributes are ordered in the index as follows: highest cardinality to lowest cardinality and upper levels of hierarchies to those in lower levels of hierarchies.","If the clustering index fits within the diskspace limit allotted for the indexes, then the clustering index is used for the summary table. In certain implementations, if the clustering index does not fit within the diskspace limit allotted for the indexes, then no clustering index is used.","C.4.2 Composite Index","A slice index is a composite index that includes attributes from different hierarchies. A slice index can be viewed as a horizontal index that is somewhat similar to a slice. For example, if a summary table contains dimensions for product, location and time, then a composite index might be built that includes the product line, state, and month attributes. The slice index follows the same criteria for attribute selection as the clustered index. Slice indexes are selected to complement the clustered index and to further enhance optimization.","A hierarchy index is a composite index that includes attributes from the same hierarchy. For each dimension hierarchy included in the summary table, a composite index is built. The attributes in the composite index are in the same order as they are in the hierarchy. For example, a hierarchy index created on the Time dimension could have its index columns in the following order: Year, Quarter, Month. Since there can be many dimensions, it the number of hierarchy indexes may be limited. The hierarchies that are the best candidates are those whose attributes have high cardinalities and low correlation.","Hierarchy indexes are created out of each of the hierarchies represented in the summary table to form a list of potential indexes for the summary table. From the list of potential indexes, indexes for the summary table are selected. In certain implementations, all of the indexes are hierarchy indexes, and the indexes that are selected are the ones with the highest cardinality, compared to any of the other hierarchies in the cube model.","If the estimated index size of a hierarchy index fits within the index diskspace limit, and is not a duplicate of the clustering index or any other indexes selected for the summary table, then the hierarchy index is added as an index. Otherwise, the hierarchy index is discarded and the next hierarchy index on the list of potential indexes is selected for a determination of whether the estimated index size fits within the index diskspace. In certain implementations, as many indexes as can fit within the index diskspace limit are selected for the summary table, up to a maximum of four.","C.4.3 Estimating Index Size","The index size estimate is based on the average size of the attributes used as index keys and the estimated number of rows in the summary table (which is explained in C.3.5 below). The following formula may be used to estimate index size:\n\n","There are many different metrics to measure the effectiveness of an index. One metric could be an estimate of the cost of using the index. This can be determined by estimating what portion of the table will typically be read if a particular index exists. The following table 32 illustrates sample columns and some characteristics in accordance with certain implementations of the invention. Table 33 illustrates use of some sample indexes in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0343","num":"0429"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 32"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Column",{},{}]},{"entry":[{},"Name","Cardinality","Distribution"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Sex","2","Even"]},{"entry":[{},"Age Group","10","Skewed"]},{"entry":[{},"Year","5","Even"]},{"entry":[{},"Quarter","4","Even"]},{"entry":[{},"Month","12","Even"]},{"entry":[{},"Cities","100","Skewed"]},{"entry":[{},"Product","1000","Skewed"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0344","num":"0430"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 33"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Index",{},{},{}]},{"entry":"Rating"},{"entry":["Index","Leaf"]},{"entry":["Columns","Cardinality","Rows Read","Notes"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["no index","1","100.00%","With no index, the"]},{"entry":[{},{},{},"RDBMS 110 reads all"]},{"entry":[{},{},{},"rows and then applies"]},{"entry":[{},{},{},"predicates."]},{"entry":["Sex","2","50.00%","If predicate is on sex, the"]},{"entry":[{},{},{},"RDBMS 110 reads"]},{"entry":[{},{},{},"approximately half the"]},{"entry":[{},{},{},"rows. The RDBMS 110"]},{"entry":[{},{},{},"may still perform a table"]},{"entry":[{},{},{},"scan."]},{"entry":["Age","10\u2002","10.00%"]},{"entry":"Group"},{"entry":["Sex + Age","\u2003\u20022 * 10","5.00%"]},{"entry":"Group"},{"entry":["Cities","100\u2003","1.00%","One row in 100 is read."]},{"entry":["Product","1000\u2003\u2002","0.10%"]},{"entry":["Product + Age","1000 * 10","0.01%","One row in 1000 is read."]},{"entry":"Group"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"Some factors which can be used to determine the effectiveness of a clustering index include, for example, calculating (#summary table rows)\/(estimated index cardinality) to get an estimated average number of rows per index entry. A number is set (based on the number of summary table rows per page and tablespace prefetch size) to indicate a minimum number of useful rows fetched during one prefetch before it becomes advantageous to use prefetching. An index may be a useful clustering index if the average number of rows per index entry is at least above this number. So a very high cardinality index, with only one row per index entry, may not be a good clustering index. On the other hand, an index with one row per index entry might make a good non-clustering index because it reduces the number of rows searched so quickly. Among multiple possible indexes in which the average rows per index entry are above this defined number, the indexes with higher cardinality may make better clustering indexes, since the higher cardinality eliminates more rows from consideration.","Possible considerations for rating both clustering and non-clustering indexes include, for example, 1) rating indexes with time dimension attributes higher than other indexes; 2) even distribution of data among the index entries; and, 3) using the query type being optimized to determine what kind of indexes to use. In particular, data is often loaded in by time, which will make it easier to keep data clustered on time attributes. Also, queries often constrain on time, making it desirable to index time attributes. As for even distribution of data among the index entries, this can be approximated by sampling the distribution of data on the index keys and looking at the average and standard deviation of the sample. As for the query type being optimized being used to determine what kind of indexes to use, hierarchy indexes may be good for drilldown queries.","C.4.5 Additional Considerations","In certain implementations, there are a maximum of 16 columns in an index, and the width of the index does not exceed the database limit for index width. Performance may be improved by including the same attribute(s) in multiple indexes, but varying the order.","In certain implementations, some hierarchies have attributes whose values depend on other attributes. For example, for the hierarchy [year,quarter,month,day] the month value is January-March for the 1 st quarter, April-June for the 2nd quarter, etc.","In certain implementations, any attributes having a cardinality of one may not be included in the index, since queries on that attribute will not reduce the number of rows read.","In certain implementations, the advisor component  also considers creating indexes on the base fact and dimension tables. That is, it may be better to use the diskspace provided by the user to define indexes on the base tables rather than additional summary table aggregations. These indexes on the base tables can complement the summary tables that have been created, optimizing slices of the cube model which are not optimized by the summary tables.","In certain implementations, columns most often known are placed first in an index, assuming the columns have sufficient cardinality to be useful.","C.5 Referential Integrity","Most customers do not enforce referential integrity through the database due to the expense of the RDBMS  doing the additional checking. Most customers enforce integrity through the data warehouse process, if at all. In particular, having the referential integrity definitions can improve query performance for Decision Support Systems (DSS). In certain implementations in which the invention is implemented on a DB2\u00ae UDB RDBMS, a new informational constraint offered by the DB2\u00ae UDB RDBMS is used. The new information constraint allows a customer to promise the data is clean so the RDBMS  does not need to do any referential integrity checking, yet the RDBMS  will still perform semantic optimization.","The semantic optimization that the RDBMS  is able to perform is due to the fact that a query can take advantage of a summary table, even if the query refers to a subset of the tables involved in the summary table. Referential integrity allows the RDBMS  to determine that the absence of some tables and joins will not change the results of the measures. For instance, consider the scenario of  and a summary table created at a level described by dashed line . This summary table will include tables and joins for all dimensions in the cube model. An example incoming query may be represented by line  and will only reference tables and joins for the Store and Product dimensions at the Store State level and Product Line level, respectively. The query represented by line  does not reference tables and joins for the Time and Customer dimensions once the query is at the All level. In this scenario, the RDBMS  determines, by using the referential integrity information, that the query can use the summary table, since the missing joins and tables will not affect the result of the measures.","C.6 Database Catalog Statistics","In certain implementations, the database optimizer of the RDBMS  uses statistics directly (such as using cardinalities in determining which columns to include in indexes), indirectly (by preparing SQL statements and getting estimated row counts returned by the database optimizer who uses the statistics to get the estimate), and sometimes not at all (such as when we use sampling). That is, the database optimizer of RDBMS  may use statistics contained in its database catalogs to make optimization decisions, such as whether to use a summary table or which index to use.","The advisor component  may use the statistics to recommend when a summary table should be reorganized or otherwise modified.","There are several design considerations for using database catalog statistics. The statistics associated with attributes may be read and used in determining which slices and indexes to create. If statistics are unavailable, then the advisor component  makes conservative assumptions, such as the column being low cardinality with equal distribution of values.","In a partitioned database, the statistics are an approximation obtained by multiplying the statistics for one node by the number of nodes. If statistics are unavailable, then a default cardinality may be assumed or sampling is performed. There are two reasons statistics could be unavailable for an attribute. One reason is if the RUNSTATS utility has not been run, and this would be unexpected as there are severe performance consequences of not having statistics. The second reason would be if the attribute is an expression.","There are two cardinalities of the attributes. There is the cardinality of the dimension table column and the cardinality of the aggregated data obtained by joining the fact and dimension tables. For example, the product name column in the product dimension table might have 20,000 products listed, but if the fact table only references 12,000 products, then the cardinality for products in the summary table will be 12,000. In general these values should be comparable. An exception to this might be Time, since there may be 1000 days in the time dimension but the initial data load only loads one day of data in the fact table.","Cardinality can be obtained, for example, in three ways: from database statistics, sampling, and from multidimensional metadata. The advisor component  may determine the cardinality of some attributes based on functions used by the attributes, such as time functions. For example, the month function by definition has a cardinality of 12.","Table 34 shows the statistics that are available and how they can be used in accordance with certain implementations of the invention.",{"@attributes":{"id":"p-0361","num":"0447"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 34"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Information","Column","Usage"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Table Statistics","TABNAME","Shows the total number of rows"]},{"entry":[{},{},"in tables. This can be used to"]},{"entry":[{},{},"determine how many rows are"]},{"entry":[{},{},"in the fact or dimension tables."]},{"entry":["Column Statistics","COLCARD","Number of distinct values in the"]},{"entry":[{},{},"column."]},{"entry":["Column","AVGCOLLEN","Average column length."]},{"entry":["Distribution",{},"In certain implementations, this"]},{"entry":["Statistics",{},"may be used to help in"]},{"entry":[{},{},"estimating the size of summary"]},{"entry":[{},{},"tables and making decisions"]},{"entry":[{},{},"about which attributes to"]},{"entry":[{},{},"include in the index."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The summary table recommendations from the advisor component  are SQL scripts, composed of SQL statements. The main SQL statements are the creation of summary tables and the creation of indexes. The creation of a summary table is part of a SQL query. When creating a summary table, the RDBMS  receives the name of the summary table and an indication of the type of maintenance type to be used. The SQL query used to populate the contents of the summary table is generated by the SQL query generation component, described in the next section. The create index statements are created based on the internal representation of the recommended indexes. A translation of the internal representation to the RDBMS  is performed here.","C.7.1 SOL Query Generation","In the advisor component , SQL query generation is used to create summary tables and to perform sampling of data. Sampling of data is used while investigating the size of arbitrary slices in a cube model.","In certain implementations, the generation of SQL queries is performed by an advisor SQLGen component , which is part of the advisor component , using a SQLGen object (listed in table 26), which works as a SQL generation engine that understands cube model and slice objects. The advisor SQLGen component  takes into consideration the type of environment in which the SQL query is going to be used, such as type of summary table. The input ,  and output  of the advisor SQLGen component  is illustrated according to a first scenario in .","In , the input parameters are (1) the cube model metadata , set once for a SQLGen object, and (2) a given set of slice objects along with the query type . Each slice can also be a ROLLUP defined from a given level up to the top of the cube model. The query type can be DEFERRED or IMMEDLATE, according to the context in which the SQL query string will be used. The output  is a SQL query.","The second scenario illustrates the use of an advisor SQLGen component , which is part of the advisor component  in certain implementations, to generate SQL Queries for sampling. The input parameters ,  are very similar to the parameters on the first scenario. However, in the second scenario (), sampling options are also passed as input . The SQL Query  generated is used for sampling purposes, in the process of estimating the size of candidate slices.","In both scenarios, the SQL query generated will reflect the set of slices given as parameter: For each slice, a grouping set is created in the SQL query. For each hierarchy mentioned in the slices, all attributes are included from the top of the hierarchy down to the attribute mentioned in the slice. For slices marked as ROLLUP, a SQL ROLLUP is used per hierarchy, for the same set of attributes. For SQL query calls, all measures in the facts of the cube model are also included in the SQL query.","For multi-slice or ROLLUP input parameters, special grouping columns are included in the query for each nullable attribute. This allows the database optimizer of RDBMS  to find the correct slice in a summary table. For SQL queries generated for query type IMMEDIATE, a count column is included for each nullable measure. Also, a measure corresponding to a COUNT (*) is included for the IMMEDIATE type. This allows the RDBMS  to incrementally maintain the summary table.","The SQLGen object will selectively include measures in the SQL statement that is generated. In order to save space and computation time during the creation of the summary tables, the SQLGen component will filter out measures that can be derived from other measures of the cube model. For instance, if a measure A is represented by SUM(X)\/SUM(Y), and the cube model includes measures B=SUM(X) and C=SUM(Y), the SQLGen component will not include measure A in the SQL statement for the summary table, since the RDBMS  can dynamically calculate measure A during the processing of the query.","IBM, DB2, ZIOS, and AIX are trademarks of International Business Machines Corporation in the United States and\/or other countries. Windows is a trademark of Microsoft Corporation in the United States and\/or other countries. Solaris and JDBC are trademarks of Sun Microsystems in the United States and\/or other countries. Linux is a trademark of Linus Torvalds in the United States and\/or other countries. HP-UX is an Open Group UNIX 95 branded product in the United States and\/or other countries. Pilot Suite is a trademark of Pilot Software in the United States and\/or other countries. Express is a trademark of Oracle Corporation in the United States and\/or other countries. Essbase is a trademark of Hyperion Solutions Corporation in the United States and\/or other countries. TM1 is a trademark of Applix, Inc. in the United States and\/or other countries.","The described techniques for improving performance of database queries may be implemented as a method, apparatus or article of manufacture using standard programming and\/or engineering techniques to produce software, firmware, hardware, or any combination thereof. The term \u201carticle of manufacture\u201d as used herein refers to code or logic implemented in hardware logic (e.g., an integrated circuit chip, Programmable Gate Array (PGA), Application Specific Integrated Circuit (ASIC), etc.) or a computer readable medium, such as magnetic storage medium (e.g., hard disk drives, floppy disks, tape, etc.), optical storage (CD-ROMs, optical disks, etc.), volatile and non-volatile memory devices (e.g., EEPROMs, ROMs, PROMs, RAMs, DRAMs, SRAMs, firmware, programmable logic, etc.). Code in the computer readable medium is accessed and executed by a processor. The code in which preferred embodiments are implemented may further be accessible through a transmission media or from a file server over a network. In such cases, the article of manufacture in which the code is implemented may comprise a transmission media, such as a network transmission line, wireless transmission media, signals propagating through space, radio waves, infrared signals, etc. Thus, the \u201carticle of manufacture\u201d may comprise the medium in which the code is embodied. Additionally, the \u201carticle of manufacture\u201d may comprise a combination of hardware and software components in which the code is embodied, processed, and executed. Of course, those skilled in the art will recognize that many modifications may be made to this configuration without departing from the scope of the present invention, and that the article of manufacture may comprise any information bearing medium known in the art.","Implementations of the invention provide a model based performance advisor. Alternative implementations of the invention include, for example: 1) capturing query workload based information into metadata and extending the advisor component  to consider this workload history; 2) extending the advisor component  to generate synthetic query workloads based on the metadata and query choices; and, 3) extending the advisor component  to produce recommendations of aggregations and to pass the queries that represent these aggregations to a workload based advisor.","The logic of  describes specific operations occurring in a particular order. In alternative implementations, certain of the logic operations may be performed in a different order, modified or removed. Moreover, steps may be added to the above described logic and still conform to the described implementations. Further, operations described herein may occur sequentially or certain operations may be processed in parallel, or operations described as performed by a single process may be performed by distributed processes.","The logic of  was described as being implemented in software. This logic may be part of the operating system of the host systems or an application program. In yet further implementations, this logic may be maintained in storage areas or in a read only memory or other hardwired type of device. The preferred logic may be implemented in hard disk drives or in programmable and non-programmable gate array logic.",{"@attributes":{"id":"p-0375","num":"0461"},"figref":"FIG. 33","b":["100","100","3300","3302","3304","3306","3306","3306","3304","3302","3308","3310","3302","3312","3302"]},"The foregoing description of the preferred implementations of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto. The above specification, examples and data provide a complete description of the manufacture and use of the composition of the invention. Since many implementations of the invention can be made without departing from the spirit and scope of the invention, the invention resides in the claims hereinafter appended."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Referring now to the drawings in which like reference numbers represent corresponding parts throughout:",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIGS. 18A-18E"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 26A"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIGS. 26B and 26C"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIGS. 27A-27E"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIGS. 28A-28D"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 32"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 33","FIG. 1"]}]},"DETDESC":[{},{}]}
