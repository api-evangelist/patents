---
title: Method and system for efficient file-based backups by reverse mapping changed sectors/blocks on an NTFS volume to files
abstract: Changed files since a last backup are identified to be backed up by reverse mapping changed blocks to files. Block identifiers specifying blocks on a storage volume are received. A location of a file table zone is determined. The file table zone stores a file table of records. Each record stores a last modified timestamp for a file associated with the record. An intersection is created from the file table zone location and the block identifiers. The intersection includes a subset of records where each record in the subset is associated with a block from the file table zone that corresponds to a block identified by the block identifiers. The subset is parsed to extract timestamps. The timestamps are compared with the storage volume's last backup date. If the associated file was modified after the last backup date, a determination is made that the file should be backed up.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09158804&OS=09158804&RS=09158804
owner: EMC CORPORATION
number: 09158804
owner_city: Hopkinton
owner_country: US
publication_date: 20111223
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["The present invention relates to the field of information technology, including, more particularly, to systems and techniques for backing up and restoring data.","A backup or the process of backing up is making copies of data which may be used to restore the original after a data loss event. Examples of data loss events include data deletion or corruption (e.g., natural disasters, fire, floods, earthquake, human error, software bugs, hardware failure, or software viruses). Backups may also be used to recover data from an earlier time.","Making backups, however, can involve significant resources and time. For example, running a backup process can interfere with normal operations, there can be a performance impact on the system being backed up. For example, for the period of time that a computer system is being backed up, the hard drive is busy reading files for the purpose of backing up, and its full bandwidth is no longer available for other tasks. Backups across a network can affect network bandwidth.","Thus, there is a need to provide systems and techniques to increase the efficiency of data backup and recovery systems.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["100","100","113","116","119","122","124","128","124","100"]},"Communication network  may itself be comprised of many interconnected computer systems and communication links. Communication links  may be hardwire links, optical links, satellite or other wireless communications links, wave propagation links, or any other mechanisms for communication of information. Various communication protocols may be used to facilitate communication between the various systems shown in . These communication protocols may include TCP\/IP, HTTP protocols, wireless application protocol (WAP), vendor-specific protocols, customized protocols, and others. While in one embodiment, communication network  is the Internet, in other embodiments, communication network  may be any suitable communication network including a local area network (LAN), a wide area network (WAN), a wireless network, a intranet, a private network, a public network, a switched network, and combinations of these, and the like.","Distributed computer network  in  is merely illustrative of an embodiment and is not intended to limit the scope of the invention as recited in the claims. One of ordinary skill in the art would recognize other variations, modifications, and alternatives. For example, more than one server system  may be connected to communication network . As another example, a number of client systems , , and  may be coupled to communication network  via an access provider (not shown) or via some other server system.","Client systems , , and  typically request information from a server system which provides the information. For this reason, server systems typically have more computing and storage capacity than client systems. However, a particular computer system may act as both a client or a server depending on whether the computer system is requesting or providing information. Additionally, although aspects of the invention have been described using a client-server environment, it should be apparent that the invention may also be embodied in a stand-alone computer system. Aspects of the invention may be embodied using a client-server environment or a cloud-computing environment.","Server  is responsible for receiving information requests from client systems , , and , performing processing required to satisfy the requests, and for forwarding the results corresponding to the requests back to the requesting client system. The processing required to satisfy the request may be performed by server system  or may alternatively be delegated to other servers connected to communication network .","Client systems , , and  enable users to access and query information stored by server system . In a specific embodiment, a \u201cWeb browser\u201d application executing on a client system enables users to select, access, retrieve, or query information stored by server system . Examples of web browsers include the Internet Explorer browser program provided by Microsoft Corporation, and the Firefox browser provided by Mozilla Foundation, and others.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 2","FIG. 2","FIG. 2"],"b":["201","203","205","207","209","211","211","213","207","217"]},"Mass storage devices  may include mass disk drives, floppy disks, magnetic disks, optical disks, magneto-optical disks, fixed disks, hard disks, CD-ROMs, recordable CDs, DVDs, recordable DVDs (e.g., DVD-R, DVD+R, DVD-RW, DVD+RW, HD-DVD, or Blu-ray Disc), flash and other nonvolatile solid-state storage (e.g., USB flash drive), battery-backed-up volatile memory, tape storage, reader, and other similar media, and combinations of these.","A computer-implemented or computer-executable version of the invention may be embodied using, stored on, or associated with computer-readable medium or non-transitory computer-readable medium. A computer-readable medium may include any medium that participates in providing instructions to one or more processors for execution. Such a medium may take many forms including, but not limited to, nonvolatile, volatile, and transmission media. Nonvolatile media includes, for example, flash memory, or optical or magnetic disks. Volatile media includes static or dynamic memory, such as cache memory or RAM. Transmission media includes coaxial cables, copper wire, fiber optic lines, and wires arranged in a bus. Transmission media can also take the form of electromagnetic, radio frequency, acoustic, or light waves, such as those generated during radio wave and infrared data communications.","For example, a binary, machine-executable version, of the software of the present invention may be stored or reside in RAM or cache memory, or on mass storage device . The source code of the software may also be stored or reside on mass storage device  (e.g., hard disk, magnetic disk, tape, or CD-ROM). As a further example, code may be transmitted via wires, radio waves, or through a network such as the Internet.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 3","FIG. 2"],"b":["201","201","203","209","217","201","302","304","306","308","312","318","320","302"]},"Arrows such as  represent the system bus architecture of computer system . However, these arrows are illustrative of any interconnection scheme serving to link the subsystems. For example, speaker  could be connected to the other subsystems through a port or have an internal direct connection to central processor . The processor may include multiple processors or a multicore processor, which may permit parallel processing of information. Computer system  shown in  is but an example of a suitable computer system. Other configurations of subsystems suitable for use will be readily apparent to one of ordinary skill in the art.","Computer software products may be written in any of various suitable programming languages, such as C, C++, C#, Pascal, Fortran, Perl, Matlab (from MathWorks), SAS, SPSS, JavaScript, AJAX, Java, SQL, and XQuery (a query language that is designed to process data from XML files or any data source that can be viewed as XML, HTML, or both). The computer software product may be an independent application with data input and data display modules. Alternatively, the computer software products may be classes that may be instantiated as distributed objects. The computer software products may also be component software such as Java Beans (from Oracle Corporation) or Enterprise Java Beans (EJB from Oracle Corporation). In a specific embodiment, the present invention provides a computer program product which stores instructions such as computer code to program a computer to perform any of the processes or techniques described.","An operating system for the system may be one of the Microsoft Windows\u00ae family of operating systems (e.g., Windows 95, 98, Me, Windows NT, Windows 2000, Windows XP, Windows XP x64 Edition, Windows Vista, Windows 7, Windows CE, Windows Mobile), Linux, HP-UX, UNIX, Sun OS, Solaris, Mac OS X, Alpha OS, AIX, IRIX32, or IRIX64. Other operating systems may be used. Microsoft Windows is a trademark of Microsoft Corporation.","Furthermore, the computer may be connected to a network and may interface to other computers using this network. The network may be an intranet, internet, or the Internet, among others. The network may be a wired network (e.g., using copper), telephone network, packet network, an optical network (e.g., using optical fiber), or a wireless network, or any combination of these. For example, data and other information may be passed between the computer and components (or steps) of the system using a wireless network using a protocol such as Wi-Fi (IEEE standards 802.11, 802.11a, 802.11b, 802.11e, 802.11g, 802.11i, and 802.11n, just to name a few examples). For example, signals from a computer may be transferred, at least in part, wirelessly to components or other computers.","In an embodiment, with a Web browser executing on a computer workstation system, a user accesses a system on the World Wide Web (WWW) through a network such as the Internet. The Web browser is used to download web pages or other content in various formats including HTML, XML, text, PDF, and postscript, and may be used to upload information to other parts of the system. The Web browser may use uniform resource identifiers (URLs) to identify resources on the Web and hypertext transfer protocol (HTTP) in transferring files on the Web.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4"},"In a first tier is the core of a database management system, a central storage  that holds or stores a database or repository . The database typically resides on one or more hard drives, and is generally part of a larger computer system. The information may be stored in the database in a variety of formats. An example is an Extensible Markup Language (XML) database. An XML database is a data persistence software system that allows data to be stored in XML format. Another example is a relational database management system (RDMS) which uses tables to store the information.","In a second tier are database servers . The database servers are instances of a program that interacts with the database. Each instance of a database server may, among other features, independently query the database and store information in the database. Depending on the implementation, the database servers  may or may not include user-friendly interfaces, such as graphical user interfaces.","In a third tier is an application server . There may be multiple application servers. In an implementation, the application server provides the user interfaces to the database servers. By way of example, the application server may be a web application server on the Internet or any other network. The application server may also be a virtual database server or a virtual directory server. The application server may provide user-friendly mechanisms and interfaces for accessing the database through the database servers. In an implementation, a web browser  is utilized to access the application server.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 5","FIG. 5"],"b":["505","510","515","520","525","530","535","540","545","550","560"]},"In a specific implementation, the tool receives as input one or more data block identifiers  (e.g., identifiers 1 . . . N). In this specific implementation, the identifiers do not include actual data content of a block and instead include an indication, identification, or specification of the blocks on the storage device or volume where the actual data content is located. This helps to conserve system resources because the actual data in the block is not being received. The tool can map or reverse map the data blocks to the files that they belong to. For example, as shown in , a file  can include one or more blocks of data such as blocks A and B having content JK and LM, respectively. Generally, a file is stored on media (e.g., hard disk) in one or more blocks. In other words, a file or a file's contents may be divided into one or more blocks of content. Typically, a block is of a predetermined uniform size such as 1 kilobyte, 4 kilobytes, and so forth. The size can range from about 512 bytes to about 64 kilobytes, but the range and size of a block can vary depending on, for example, the particular file system and size of the storage media. A block may be referred to as a sector, cluster, disk space unit, or allocation unit.","Referring to , in a specific implementation, the tool outputs  a list including one or more files or file paths that the received blocks (or a subset of the received blocks) have been mapped to. For example, the tool may map received data blocks  and  to file A and output a list including file A. The tool may map received data block  to file B and the outputted list may include file B, and so forth. The output may provided programmatically such as in response to an API request so that further processing can occur, provided to an electronic display or printer, provided in an e-mail, e-mail attachment, or other notification, or combinations of these. The output may be in any suitable format such as XML, HTML, text file, ASCII, and so forth.","In a specific embodiment, the tool is implemented in a file-based backup system. Generally, in file-based backup systems, backups of files and folders are made by traversing the file system tree. In the case of incremental backups, the tool can identify the files, folders, or both to be backed up without the back up system having to traverse the full file system and compare timestamp or archive bit information for each file to find out the modified or new files for incremental backups. Further, the tool can be used without journaling being enabled to find the modified or new files.","Traversing the entire file system to find the files that should be backed up can take a significant amount of time and resources. For example, in some cases the backup window for dense file system backups may be longer than a day. This can cause an undesirable level of interruption in the normal operations of a company or organization because there can be performance impacts on the system being backed up. For the period of time that a computer system is being backed up, the hard drive may be busy reading files for the purpose of backing up, and its full bandwidth may not be available for other tasks. Indeed, traversing the file system tree may take more time than actually backing up the data. Enabling journaling to find modified or new files can also result in performance overhead or impacts. Further, journaling typically requires adequate space (e.g., disk space) for the journal and journal overflow.","For file-based backup systems, the reverse mapping techniques as described in this application can identify the data objects (e.g., files, directories, or both) on a storage volume to be backed up to a backup volume without traversing the entire file system tree, without journaling being enabled (i.e., journaling is disabled, turned off, or not turned on), and without having to maintain file system state information. This allows for more efficient backups of files, less consumption of resources, less interruption, and shorter backup windows. The data objects on the storage volume to be backed up may be changed data objects. That is, the data object (e.g., file) has been changed, modified, or altered since the last backup. Alternatively, the data object on the storage volume to be backed up may be a new data object, such as a file that was created on the storage volume after the last backup of the storage volume.","In another specific embodiment, the tool is implemented in a block-based backup system. Block-based systems backup changed blocks in the file system. For example, in a block-based system the portion or block of a data object (e.g., file) that has changed since the last backup is backed up rather than the entire data object (e.g., entire file). It is desirable to identify or index the changed files or backed-up files between backups in order to allow for efficient file-based recoveries out of block-based backups. However, in some cases indexing results in walking the entire file system tree or indexing files that have already been indexed. Re-indexing files already indexed can be an inefficient use of resources.","For block-based backup systems, the reverse mapping techniques as described in this application can identify the data objects (e.g., files, directories, or both) whose blocks have been backed up without traversing the entire file system tree, without journaling being enabled, and without having to maintain file system state information. The tool can allow for indexing of just the changed data objects (e.g., files), new data objects, or both between backups or incremental backups instead of all the data objects.","In a specific implementation, the tool is adapted for use with the file system or file system format referred to as the New Technology File System (NTFS) provided by Microsoft. In other embodiments the tool may be implemented for use with other file systems such as the Unix File System (UFS), VMware Virtual Machine File System (VMFS), Hierarchical File System (HFS), Hierarchical File System Plus (HFS Plus), File Allocation Table (FAT), Oracle Automatic Storage Management Cluster File System (Oracle ACFS), Journaled File System (JFS), second extended file system (Ext2), third extended file system (Ext3), fourth extended file system (Ext4), and many others.","An NTFS file system includes a layout  on the disk including an NTFS boot sector A, a file table B, a file system data or a data region C for storing file content, and an file table copy D. The boot sector includes information regarding the layout of the file system (offset to the file table), and details related to booting from the file system.","In NTFS, the file table is referred to as the Master File Table (MFT). The MFT is organized to include file information via a set of MFT records. The MFT is itself treated like a file in NTFS. Each MFT record and as an extension each file includes information regarding the file such as timestamps, 48-bit MFT record number, and 16-bit update sequence number. The combination or concatenation of the MFT record number and update sequence number yield a 64-bit number referred to as the File Reference Number (FRN). In other words, on a typical NTFS volume, file information such as file name, creation date, access permissions, contents and so forth, are stored as metadata in the Master File Table (MFT). Each file, directory, or both in the file system is represented by a unique MFT record in the MFT. Also, each file, directory, or both in the file system can be referred by means of a File Reference Number (FRN). On a typical NTFS volume, sectors can be segregated into three sets: MFT zone sectors, files or actual data, and index records.","When a file, directory, or both is created on an NTFS volume, a record is created for the file or directory. The record is used to store information about the file or directory. There is at least one entry in the MFT for every file on an NTFS file system volume, including the MFT itself. Information about a file, including its size, time and date stamps, permissions, and data content, is stored either in MFT entries, or in space outside the MFT that is described by MFT entries. As files are added to an NTFS file system volume, more entries are added to the MFT and the MFT increases in size. When files are deleted from an NTFS file system volume, their MFT entries are marked as free and may be reused. However, disk space that has been allocated for these entries is not reallocated, and the size of the MFT does not decrease. The NTFS file system reserves space for the MFT to keep the MFT as contiguous as possible as it grows. The space reserved by the NTFS file system for the MFT in each volume is called the MFT zone.","Since the MFT tracks file system metadata, it follows that any change to a file, directory, or both on the file system translates to a corresponding change in the MFT record for the file or directory within the MFT zone. The tool can examine the MFT zone sectors for these changes.","In a specific implementation, upon receipt of the data block identifiers by the tool, intersection module  intersects the received data block identifiers with the MFT zone blocks to make, create, produce, or generate an intersect. The intersect includes the MFT records corresponding to the data block identifiers. That is, the intersect may include a subset of the MFT records rather than all the MFT records. MFT record parser  is responsible for parsing each record in the subset of MFT records to select the desired MFT records. From the selected MFT records of the subset, the tool obtain the FRNs. Using the FRN, the tool can send a request through API interface  to API services  to obtain file name information. The technique allows parsing of a subset of the MFT records or at most a subset of records rather than all of the MFT records. That is, the changed files, directories, or both between back-ups or between incremental backups can be identified without having to parse each record of the MFT.","For example,  shows an example of an NTFS layout  where areas A-F represent changed blocks. In a specific implementation, in a first step, the tool finds what changed blocks are part of Master File Table (by using MFT record zero). Thus, in the example shown in , blocks A and B are part of the MFT. The tool can ignore the rest of the blocks. The tool can parse the relevant MFT records which are part of Master File Table and obtain FRN for each relevant MFT record. Then by using Windows provided APIs the tool can get the full file path.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 8","b":"805"},"In brief, in a specific implementation, the tool receives data blocks in the form of extents. An extent is a contiguous area of storage in a file system. In this specific implementation, the extent is tuple (A, B) where A denotes the block number and B refers to the length of the extent. For example (10000, 200) can mean starting from 10000th block till 10200 blocks are modified. That is, the extent identifies a set of blocks where the set starts at block  and ends at block , e.g., start at block  and count  blocks to block . In this specific implementation, the tool parses MFT record zero to locate an MFT Zone. The MFT Zone includes an array of MFT records. This location information can be converted to an extent. For example if the MFT Zone is starting from 10000th block till 15000th block then the corresponding extent is (10000, 5000). Once this extent is identified, the tool compares this with the input data block identifiers. The tool finds the common blocks between these two extents.","For example, if the MFT zone is (10000, 5000) and input data block identifiers are {(1000, 100), (5000, 100), (10000, 100), (20000, 200)}, then the common blocks are {(10000, 100)}. Generally, the resultant extents of this intersection operation is within the MFT Zone. In this specific implementation, the tool may now parse only these common blocks. These common blocks are MFT records. The rest of the data block identifiers including actual data blocks and index records and can be ignored.","In this specific implementation, analysis of these MFT records includes extracting Standard Information or information from the standard information attribute of an MFT record to see whether the file has indeed been modified. In some cases, this step is performed because sometimes operating system files are run for the operating system to fulfill its functionalities. In this case, the file may not have been modified, but the file's \u201cLast access time\u201d is modified. In this case, the file's corresponding data blocks may be part of the input of received data block identifiers and thus may be excluded. In this specific implementation, the result of the exclusion includes MFT records which are actually modified or correspond to modified data files.","In a specific implementation, the data block identifiers refer to, specify, or identify changed blocks (or sectors) on the volume. A changed block may refer to a block whose data content has changed since the last backup. Given a set of changed blocks on an NTFS volume, the tool reverse maps each changed sector or block to the file that it belongs to. From the set of changed sectors on the volume, the tool extracts the sectors in use by NTFS. From these, the tool filters out the sectors belonging to the data section of the MFT itself. At this point in time, there is a list of MFT records (one MFT record=at least 2 NTFS sectors). Each MFT record is further processed to extract an MFT record sequence number (16 bits) and an MFT record number (48 bits). The FRN of the file corresponding to this record is a concatenation of the sequence number and the record number, i.e., a 64-bit FRN=16-bit sequence number+48-bit MFT record number. From the list of FRNs the tool opens the file in question by using its FRN via the NtCreateFile API using the FILE_OPEN_BY_FILE_ID option. Once a handle to the file is obtained, the tool uses the GetFileInformationByHandle API to obtain the file information.","In other words, any change to a file changes the MFT record for the file itself due to changes to timestamps, and so forth. In a specific implementation, the tool examines the changed blocks and segregates blocks into the categories MFT records and other data (superset of the actual file blocks) by using MFT record zero (the first record in Master File Table). This record includes information about Master File Table location information. From each changed MFT record the tool extracts the file reference number (FRN). The tool uses the API NtCreateFile (FILEOPEN_BY_FILE JD option) to open a handle to the file using the FRN instead of the path. Upon obtaining the handle, the tool uses the GetFileInformationByHandle API to obtain the file name.","Referring now to , in a specific implementation, in a step , the tool receives one or more block identifiers. As discussed above, in a specific implementation, a block identifier is received as an extent. In this specific implementation, the extent includes a first value, and a second value. The first value indicates a starting location or starting block of the extent. The second value indicates a length of the extent. It should be appreciated, however, that a block identifier may be any value or combination of values that identify a particular block or set of blocks. For example, in another specific implementation, the second value may indicate an ending block of the extent. An identifier may include a block address, a starting address or location, an ending address or location, a number of blocks between a starting and ending address or location, a virtual cluster or block number, a starting logical cluster or block number, or combinations of these. An identifier may be in a hexadecimal or decimal format. An identifier may include numbers, letters, characters, or combinations of these.","In a specific implementation, the identifiers are received from a VMware module referred to as the Changed Block Tracking (CBT) module or feature. In another specific implementation, the identifiers may be received from a file system driver. The file system driver may be an in-house developed file system driver. The identifiers may be received from an external source or a source that is external or not integrated or built-in to the file system. That is, the source may include code or a code component that is not native to the file system.","In a step , the tool determines a block location of a file table zone for a file table. The file table stores a record for each data object (e.g., file) on the volume including a record for the file table itself. The file table may include a record for the file table and other records for other files on the volume. That is, a record may be associated with a file and may store metadata for the associated file such as a timestamp indicating a date, time, or both when the associated file was modified or last modified. As discussed above, in a specific implementation, the file table is a Master File Table (MFT) as provided in or maintained by the NTFS file system or operating system.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 9","b":["905","910","910","910","910"]},"The standard information attribute may include information such as read\/write permissions of the associated file, creation time of the associated file, last modification time of the associated file, a count or number of how many directories point to the associated file (e.g., a hard link count). The file name attribute describes the file name in the Unicode character set. There can be multiple file names such as when the file has multiple links or the file has an MS-DOS short name. The security descriptor attribute lists which user owns the associated file, which users can access the associated file, and how the users can access the associated file.","Depending on the size of the associated file, the data attribute can include the actual file data such as in the case of a small file or small file size. Alternatively, if the file size is large, the data attribute can include pointers or an index to the actual file data (or pointers to the objects that point to the actual file data). The pointers to the data may include pointers to sequences of logical clusters or blocks on the disk. Each sequence may be identified by three parts including a starting cluster in the file referred to as the virtual cluster number (VCN), a starting logical cluster (LCN) of the sequence on the disk, and a length that is counted as a number of clusters. The run of clusters may be referred to as an extent. In other words, the data attribute of a record can be used to specify or identify the data blocks of the file that is associated with the record.","In this specific implementation, an initial record of the MFT (e.g., MFT record or entry 0) is parsed to identify the block location of the MFT zone where the MFT is stored. For example, parsing the initial record can identify a starting and ending block of the MFT zone. In a specific implementation, the starting and ending blocks of the MFT zone are converted into an extent that may be referred to as the block location of the MFT zone. It should be appreciated, however, that the block location of the MFT zone can be any value or set of values that can identify the blocks reserved or allocated to the MFT zone.","Referring now to , in a step , the tool intersects the block location of the file table zone with the received block identifiers to create an intersect of common blocks. In a specific implementation, the intersect includes a subset of file table records where each record in the subset is associated with a block from the file table zone that corresponds to a block identified by the received block identifiers.","For example, if a file table record is associated with a block identified as \u201c\u201d in the file table zone and the received block identifiers includes an identifier identifying block \u201c\u201d then the record may be included in the subset of file table records. Conversely, if the received block identifiers do not include an identifier identifying block \u201c\u201d then the record may be excluded or omitted from the subset. That is, a file table record that is associated with a block from the file table zone may be excluded or omitted from the subset if the block does not correspond to a block identified by the received block identifiers. The intersecting may include scanning or comparing the block location of the file table zone and the received block identifiers to find matching blocks.","In a step , the tool parses the subset of file table records to extract the timestamps indicating the last modified dates of the files associated with the subset of file table records. The technique allows for parsing at most a subset of the file table records rather than all of the file table records because a number of file table records in the subset may be less than a number of file table records in the file table. That is, the number of file table records may be greater than the number of file table records in the subset. A number of timestamp extractions may be less than a number of file table records in the file table. The number of file table records may be greater than the number of timestamp extractions.","In other words, there can be a remaining subset of file table records that are not parsed or analyzed. The remaining subset of file table records may not be parsed because the file table records in the subset may be associated with blocks from the file table zone that do not correspond to blocks identified by the block identifiers. Depending upon factors such as the number of data blocks identified by the received data block identifiers, a number file table records in the remaining subset may be greater than the number of file table records in the subset. Thus, the number of file table records parsed may be less than the number of file table records in the remaining subset. Limiting the number of file table records that need to be parsed or analyzed can improve system performance.","In a step , the tool compares the extracted file table record timestamps indicating the last modified dates of the associated files with a date. In a step , if the comparison indicates the associated file was modified after the date, the tool derives file information for the associated file such as a file path to the associated file. The comparison allows the tool to confirm or verify that the associated file was indeed modified. For example, some operating systems will track or record a file's last access time including a last access time of operating system files. Data blocks associated with these accessed operating system files may be included with the received block identifiers (step ) even if the files have not been modified. Thus, the comparison may be performed in order to exclude or omit these files. As discussed below, in a specific implementation, the date (steps  and ) is a date of the last backup (see ). In another specific implementation, the date is a date of the next-to-last backup (see ).","Referring now to , a specific implementation or application of the tool is in a file-based backup system. An example of such a system is shown in .  shows a block diagram of a specific implementation of the tool to facilitate file-based backups. As shown in the figure, there is reverse mapping tool  receiving block identifiers , a storage volume , a backup volume , and a backup engine  to back up files on the storage volume to the backup volume. The tool can quickly identify the files on the storage volume that should be backed up to the backup volume. For example, in the case of incremental backups, it is desirable to backup files that have changed since a date of a last backup, files that have been created since the date of the last backup (i.e., new files), or both. Files that have not changed since the date of the last backup may not be selected for backed up in a current backup because these files may have been already backed up in a previous backup (e.g., a backup before the last backup).","For example, as shown in , the storage volume includes files A, B, C\u2032, D, and E\u2032 and the backup volume includes files A, B, C, D, and E. Files A, B, C, D, and E have been backed up to the backup volume in a last backup (or a backup before the last backup). Files C\u2032 and E\u2032, however, have not been backed up to the backup volume. For example, files C and E may have been changed, modified, or altered since the last backup as indicated by the prime symbol shown in the figure. In this specific implementation, upon receiving the block identifiers specifying data blocks on the storage volume that have changed since the last backup, the tool consults the file table and can quickly identify files C\u2032 and E\u2032 as having been changed since the date of the last backup without having to parse each record of the file table. The tool can derive file information for the files (e.g., a file path) and provide the file information to the backup engine. The backup engine can then access the storage volume to backup files C\u2032 and E\u2032 to the backup volume.",{"@attributes":{"id":"p-0074","num":"0073"},"figref":["FIG. 11","FIG. 10","FIG. 8"],"b":["1105","825","825","1110","1115"]},"For example, the extracted timestamp from the file table record may indicate that the file was modified Oct. 7, 2011, 7:31:05 PM, and the date of the last backup may be Oct. 6, 2011, 4:22:34 PM. Thus, in this example, the tool determines that the file should be backed up because it was modified after the date of the last backup. As another example, the extracted timestamp from the file table record may indicate that the file was modified Oct. 5, 2011, 7:31:05 PM. Thus, in this example, the tool determines that the file should not be backed up (or included in the current backup) because it was modified before the date of the last backup and thus would have been backed up in the last backup (or a backup before the last backup). The timestamp, date, or both may include any value or combination of values to identify a particular point in time (e.g., month, day, year, time, hour, or seconds).","In a step , upon determining that the file associated with the file table record should be backed up, the tool derives a file path for the associated file. In a specific implementation (e.g., an implementation with an NTFS file system), a method to derive the file path includes extracting from the selected file table record a first value and a second value, and joining the first value and the second value to form a third value. In this specific implementation, the first value includes the 16-bit MFT record sequence number. The second value includes the 48-bit MFT record number. Generally, each MFT record is addressed by a 48-bit MFT entry value and has a 16-bit sequence number that is incremented when the entry is allocated. The third value may be referred to as the file reference number (FRN). The FRN is the concatenation of the sequence number and the record number, i.e., 16-bit sequence number+48-bit MFT record number=64-bit FRN. The 16-bit sequence number may be located at the 6th byte and the MFT record number may be at the 20th byte in the MFT record.","In this specific implementation, the method further includes generating and sending a first request including the third value to a first API, receiving a response including a fourth value from the first API, generating and sending a second request including the fourth value to a second API, and receiving a fifth value from the second API, the fifth value being the file or directory information. In this specific implementation, the first API is the API \u201cNtCreateFile.\u201d The second API is the API \u201cGetFileInformationByHandle.\u201d In other words, in this specific implementation, given an FRN, the tool opens or accesses the file in question by using its FRN via the \u201cNtCreateFile\u201d API using the \u201cFILE_OPEN_BY_FILE_ID\u201d option. Once a handle to the file is obtained, the tool uses the \u201cGetFileInformationByHandle\u201d API to obtain the file name information.","In this specific implementation, the APIs are provided by the Windows operating system. These APIs allow a full, complete, or absolute file path to be obtained which may be desirable for certain backup systems. The file name attribute of an MFT record may provide only a partial path. For example, in a case where the file \u201cC:\\windows\\system32\\config\u201d is changed and should be backed up; the corresponding MFT record will have the file name attribute as \u201cconfig\u201d and not the full file path (e.g., \u201cC:\\windows\\system32\\config\u201d). Some backup systems, however, require the full file path. Thus, the tool by calling the appropriate APIs can provide the full file path.","It should be appreciated, however, that depending upon the particular file system, backup engine, or both calling such APIs will be optional. For example, if a particular file table records full path information for the associated files then the full path can be determined by extracting the full path from the file table record. An API may not be called. Likewise, if a particular backup engine does not require a full file path and a file name is sufficient, the API may not be called. Thus, in another specific implementation, the tool provides a relative path or a filename not including the file path.","A path may include any value or combination of values to specify a particular file or directory in a file system. For example, a path may include a filename, directory name, subdirectory, drive letter, server name, device name, volume name, root directory, user directory, file extension, or combinations of these. A path may include one or more path components defined by a delimiting character such as a slash (e.g., \u201cI\u201d), backslash (e.g., \u201c\\\u201d), colon (e.g., \u201c:\u201d), or other depending upon the operating system. For example, the path component \u201cC:\\\u201d represents the drive letter \u201cC:\u201d or root directory.","In a step , the tool provides or transmits the file information (e.g., file path) to the backup engine to permit the backup engine to back up the file, directory, or both.",{"@attributes":{"id":"p-0082","num":"0081"},"figref":["FIGS. 12-13","FIG. 12"],"b":["510","515","1220","1225","1230"]},"For example, as shown in , the storage volume includes files A, B, C\u2032, D, and E\u2032. Similarly, the backup volume includes files A, B, C\u2032, D, and E\u2032. In a last backup, the block-based backup system has backed up data blocks that happened to be associated with files C and E because these files had been modified after a next-to-last backup (e.g., a penultimate backup or a backup immediately before the last backup) as indicated by the prime symbol for files C and E as shown in the figure. In this specific implementation, the tool can quickly map these recently backed up blocks to the files they are associated with (e.g., files C\u2032 and E\u2032) so that the files can be indexed without having to re-index the other files (e.g., files A, B, and D) that have already been indexed.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":["FIG. 13","FIG. 12","FIG. 8"],"b":["1305","825","825","1310","1315"]},"For example, the extracted timestamp from the file table record may indicate that the file was modified October 7th, the date of the last backup may be October 10th, and the date of the next-to-last backup may be October 5th. In this example, the one or more (changed) data blocks of the file would have been included in the October 10th backup because the file (or more particularly, the one or more data blocks of the file) was modified after the date of the next-to-last backup, i.e., the October 5th backup. Thus, this file should be indexed.","In a step , the tool derives a file path for the file that is associated with the file table record. A technique to derive the file path may be similar to the derivation technique shown in step  () and discussed above. In a step , the tool provides the file path to an indexing engine to permit the indexing engine to index the file. The indexing can allow a user such as backup administrator to see what files are part of the backup.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIGS. 12-13","b":["1235","1240"]},"In the description above and throughout, numerous specific details are set forth in order to provide a thorough understanding of an embodiment of this disclosure. It will be evident, however, to one of ordinary skill in the art, that an embodiment may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form to facilitate explanation. The description of the preferred embodiments is not intended to limit the scope of the claims appended hereto. Further, in the methods disclosed herein, various steps are disclosed illustrating some of the functions of an embodiment. These steps are merely examples, and are not meant to be limiting in any way. Other steps and functions may be contemplated without departing from this disclosure or the scope of an embodiment."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
