---
title: Secondary processor execution kernel framework
abstract: Preparing one or more secure media effect programs, generating a binary image of the programs and associated data, loading the binary image into memory of a secondary processor, and executing the programs of the binary image with the secondary processor, substantially independent from a primary processor. A binary image builder automatically maps one or more programs and data to secondary processor memory by changing encoded binary instructions of each program before execution by the secondary processor. The changes identify locations at which the programs and data will be stored in secondary processor memory, identify locations of parameters that can be updated in real time, and enable execution control to return to a secondary processor execution kernel. The secondary processor execution kernel polls flags in a main memory to determine whether to download new or updated state data and/or program code from main memory to the secondary processor memory.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06996699&OS=06996699&RS=06996699
owner: Microsoft Corporation
number: 06996699
owner_city: Redmond
owner_country: US
publication_date: 20020910
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["This invention generally relates to a secondary processor execution kernel, such as an execution kernel for a digital signal processor (DSP), and more particularly, to a framework for loading the secondary processor execution kernel, loading a secondary processor program and corresponding data with the secondary processor execution kernel, and executing the secondary processor program under control of the secondary processor execution kernel.","Many electronic devices include both a primary and a secondary processor. The primary processor is typically used to perform core functions of the electronic device. The secondary processor performs other functions, such as media processing, math coprocessing, and other specialized functions, freeing the primary processor from such processing tasks. Typically, the functions are performed in real time by both processors to increase the overall processing speed of the electronic device. To further relieve the primary processor, it is preferable that the secondary processor perform its functions with little control by the primary processor. Thus, it is preferable for the secondary processor to load programs and data and to execute such programs independently of the primary processor. Enabling such capabilities requires a secondary processor control program to manage input\/output (I\/O) tasks, communication with the primary processor, and other overhead. This control program is sometimes referred to as an execution kernel.","Effectively, the execution kernel is a secondary operating system specifically for the secondary processor. Since the secondary processor is frequently a DSP that is used for real time functions, the execution kernel is often referred to as \u201ca DSP execution kernel\u201d or \u201ca real time DSP operating system.\u201d A number of such real time DSP operating systems are currently available for general purpose DSPs, including the Visible Caching Operating System (VCOS\u2122) by AT&T Corp., SPOX\u2122, which was originally developed by Spectron Microsystems, Inc. (later acquired by Texas Instruments, Inc.), and MWAVE\u2122 by International Business Machines, Inc.","The above-identified real time DSP operating systems are generally multitasking operating systems with some interrupt and memory management capabilities. However, such capabilities are achieved at the expense of throughput speed, because interrupt and memory management tasks are relatively high overhead tasks. These capabilities and their corresponding overhead accommodate branching and other non-sequential instructions and are often included in application programs, designed for and executed by the DSP under the control of the real time DSP operating system. As with any programming language, such non-sequential instructions provide DSP application program developers with flexibility and high level programming capability. Requiring developers to employ only sequential programs could reduce or eliminate at least some of the corresponding overhead. However, use of only sequential programs would limit the desired flexibility, are difficult to write, and would not necessarily avoid the need for memory management overhead. To reduce overhead without sacrificing flexibility, many techniques used by conventional compilers and assemblers may be adopted or adapted for DSPs. Compiled or assembled DSP application programs can interface with the real time DSP operating system so as to reduce overhead tasks. However, compilers and assemblers have not eliminated the interrupt handling, memory management, and other overhead that must be performed by a real time DSP operating system.","To improve processing efficiency of a secondary processor such as a DSP, it would be preferable to minimize or eliminate the need for overhead processing functions in the secondary processor's real time operating system, without sacrificing functionality of application programs, without overburdening the application programmer, and without pushing overhead processing up to the primary processor. For example, it would be desirable to minimize or eliminate the need for interrupt handling, without sacrificing an ability to modify DSP application program values during run time. Similarly, it would be desirable to minimize or eliminate memory management functions, without requiring the DSP application programmer to predefine a memory map, and without pushing the memory management functions up to the primary processor.","Conventional compiler, assembler, and linking techniques are inadequate to achieve these desirable capabilities, because they assume that many interrupt handling, memory management, and other overhead processing functions are available through the real time operating system. However, the overhead processing functions cannot be eliminated from the real time operating system without pushing these functions back to the primary processor, to the compiler, to the assembler, to the linker, or to the programmer. It is clearly undesirable to impose a great deal of rigid design requirements on the programmer. Thus, no single aspect can be changed to achieve the desired efficiencies. Instead, a hybrid of minimal programming guidelines, automatic compile time memory mapping, and a minimal DSP execution kernel is warranted.","The present invention provides a method and system for loading and executing a binary image of data and program code into a secondary processor memory, without using a secondary processor to determine memory locations for the data and the program code. Instead, an efficient secondary processor execution kernel works independently from, but in some coordination with a subsystem that runs on the primary processor. Initially, a portion of a main memory is preallocated. This preallocated portion is sometimes referred to herein as the scratch space. The scratch space is mapped to the secondary processor memory and the scratch space is accessible by the secondary processor. A kernel location is predefined within the scratch space to store the secondary processor execution kernel. Preferably, the subsystem loads the secondary processor execution kernel into the scratch space at the kernel location, and initiates a boot routine of the secondary processor. The boot routine is hard coded to download anything at the predefined kernel location in the scratch space of the main memory. Thus, the secondary processor execution kernel is downloaded from the scratch space to a predefined kernel location in the secondary processor memory that corresponds to the predefined kernel location in the scratch space of the main memory.","In a similar fashion, an image location is predefined in the scratch space of the main memory. The subsystem loads the binary image into the scratch space at the image location. Preferably, the binary image is encoded to protect individual programs in the binary image and\/or the entire binary image. The subsystem decodes the binary image in the scratch space. A command flag is then set, indicating that data and\/or program code are available to be downloaded to the secondary processor memory. The command flag is set at a predefined flag location within the scratch space of the main memory, so that the secondary processor can poll the predefined flag location and determine whether the command flag is set. If the command flag is set, the data and\/or program code in the binary image is copied from the scratch space of the main memory into the secondary processor memory. Preferably, the data portion of the binary image is copied to a data memory subdivision of the secondary processor memory. Similarly, the program code of the binary image is preferably copied to a program memory subdivision of the secondary processor memory. Because the binary image is predefined by a binary image builder to replicate the secondary processor memory, the secondary processor need not determine locations in the secondary processor memory to store the binary image. Once the binary image is loaded into the secondary processor memory, the secondary processor can execute the programs of the binary image without further intervention from the secondary processor execution kernel.","Another aspect of the invention includes updating parameter values of the programs or other portions of the binary image while the programs are being executed by the secondary processor. The parameter values are included in the state data of the binary image. Because a copy of the binary image is stored in the scratch space of the main memory, a parameter value can be modified in the scratch space without having to interrupt the secondary processor. Instead, the location of the parameter value is determined in the scratch space of the main memory, and the parameter value is changed to an updated parameter value in the scratch space. The location of the parameter value is preferably available in a description header associated with the binary image. A state flag is then set at another predefined location in the scratch space. Similar to the command flag discussed above, this state flag location is also polled to detect a change in the status of the state flag. If the state flag is set, the updated parameter value is copied to a location in the secondary processor memory that corresponds to the parameter location within the scratch space of the main memory. Preferably, the state flag is polled and the updated parameter value is downloaded at intervals of execution frames, so that the secondary processor need not be interrupted. Thus, the updated parameter value is used in the next execution frame of the secondary processor. Executable program code can also be update in the above manner. Other aspects, features, and benefits of the invention will become apparent from the following description.","A preferred embodiment of the present invention is described below in regard to an exemplary use in preparing audio effects on a personal computer and for performing the audio effects with a DSP on an electronic gaming system that is designed to execute gaming software distributed on a portable medium, such as a digital versatile disk (DVD). Those skilled in the art will recognize that the present invention may also be implemented in conjunction with a set-top box, an arcade game, a hand-held device, and other systems that utilize a secondary processor, such as a DSP. It should also be apparent that the present invention may be practiced on a single machine, such as a single PC, or practiced in a network environment, with multiple consoles or computing devices interconnected in peer-to-peer arrangement and\/or with one or more server computers.","Exemplary Development Environment",{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 1","FIG. 1"]},"Although not required, the present invention will be described in the general context of computer executable instructions, such as program modules, which are executed by a PC and\/or a gaming console. Generally, program modules include application programs, such as computer simulations, routines, objects, components, functions, data structures, etc. that perform particular tasks or implement particular abstract data types. Also, those skilled in the art will appreciate that this invention may be practiced with other computer system configurations, particularly in distributed computing environments, where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in either or both local and remote memory storage devices.","With reference to , an exemplary system for use as a server computer, or a development system for developing software used in the present invention includes a general purpose computing device in the form of a conventional PC . PC  is provided with a processing unit , a system memory , and a system bus . The system bus couples various system components, including the system memory, to processing unit  and may be any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within the PC , such as during start up, is stored in ROM . PC  further includes a hard disk drive  for reading from and writing to a hard disk (not shown) and may include a magnetic disk drive  for reading from or writing to a removable magnetic disc , and an optical disk drive  for reading from or writing to a removable optical disc , such as a CD-ROM or other optical media. Hard disk drive , magnetic disk drive , and optical disk drive  are connected to system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical disk drive interface , respectively. The drives and their associated computer readable media provide nonvolatile storage of computer readable machine instructions, data structures, program modules, and other data for PC . Although the exemplary environment described herein includes a hard disk, removable magnetic disc , and removable optical disc , it will be appreciated by those skilled in the art that other types of computer readable media, which can store data that are accessible by a computer, such as magnetic cassettes, flash memory cards, DVDs, Bernoulli cartridges, RAMs, ROMs, and the like, may also be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk, magnetic disc , optical disc , ROM  or RAM , including an operating system , one or more application programs , other program modules , and program data . A user may enter commands and information into PC  through input devices such as a keyboard  and a pointing device . Pointing device  may include a mouse, stylus, wireless remote control, or other pointer. Other input devices (not shown) may include a joystick, game pad, wheel, pedal, microphone, satellite dish, scanner, digital camera, digital video recorder, or the like. These and other input\/output (I\/O) devices are often connected to processing unit  through an I\/O interface  that is coupled to the system bus . The term I\/O interface is intended to encompass each interface specifically used for a serial port, a parallel port, a game port, a keyboard port, and\/or a universal serial bus (USB). A monitor  or other type of display device is also connected to system bus  via an appropriate interface, such as a video adapter , and is usable to display application programs, Web pages, a simulated environment, and\/or other information. In addition to the monitor, PCs are often coupled to other peripheral output devices (not shown), such as speakers (through a sound card or other audio interface (not shown)) and printers.","As indicated above, the invention may be developed and practiced on a single computing device; however, PC  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . Remote computer  may be another PC, a server (which is typically generally configured much like PC ), a router, a network PC, a game console, a peer device, a satellite, or other common network node. Remote computer  may include many or all of the elements described above in connection with PC , may include the elements described below in connection with a gaming console, or may include typical elements of other electronic devices that utilize a secondary media processor. So as not to make  unnecessarily complex, remote computer  is shown with only an external memory storage device . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are common in offices, enterprise wide computer networks, intranets, and the Internet.","When used in a LAN networking environment, PC  is connected to LAN  through a network interface or adapter . When used in a WAN networking environment, PC  typically includes a modem , or other means such as a cable modem, Digital Subscriber Line (DSL) interface, or an Integrated Service Digital Network (ISDN) interface, for establishing communications over WAN . One type of WAN commonly used for communication is the Internet. Modem , which may be internal or external, is connected to the system bus  or coupled to the bus via I\/O device interface , i.e., through a serial port. In a networked environment, program modules depicted relative to PC , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used, such as wireless communication and wide band network links.","Exemplary Performance Environment","As shown in , an exemplary electronic gaming system  includes a game console  and support for up to four user input devices, such as controllers and . Game console  is equipped with an internal hard disk drive (not shown in this Figure) and a portable media drive  that supports various forms of portable optical storage media, as represented by an optical storage disc . Examples of suitable portable storage media include DVD discs and CD-ROM discs. In this gaming system, game programs are preferably distributed for use with the game console on DVD discs, but it is also contemplated that other storage media might instead be used on this or other types of systems that employ the present invention.","On a front face of game console  are four ports  for connection to supported controllers, although the number and arrangement of ports may be modified. A power button , and an eject button  are also disposed on the front face of game console . Power button  controls application of electrical power to the game console, and eject button  alternately opens and closes a tray (not shown) of portable media drive  to enable insertion and extraction of storage disc , so that the digital data on the disc can be read for use by the game console.","Game console  connects to a television or other display monitor or screen (not shown) via audio\/visual (A\/V) interface cables . A power cable plug  conveys electrical power to the game console when connected to a conventional alternating current line source (not shown). Game console  includes an Ethernet data connector  to transfer and receive data over a network (e.g., through a peer-to-peer link to another game console or through a connection to a hub or a switch\u2014not shown), or over the Internet, for example, through a connection to an xDSL interface, a cable modem, or other broadband interface (not shown). Other types of game consoles may be coupled together in communication using a conventional telephone modem.","Each controller and is coupled to game console  via a lead (or alternatively, through a wireless interface). In the illustrated implementation, the controllers are USB compatible and are connected to game console  via USB cables . Game console  may be equipped with any of a wide variety of user devices for interacting with and controlling the game software. As illustrated in , each controller and is equipped with two thumbsticks and , a D-pad , buttons , and two triggers . These controllers are merely representative, and other gaming input and control devices may be substituted for or added to those shown in  for use with game console .","A removable function unit  can optionally be inserted into controller  to provide additional features and functions. For example, a portable memory unit (MU) enables users to store game parameters and port them for play on other game consoles, by inserting the portable MU into a controller connected to the other game console. Another removable functional unit comprises a voice communication unit that enables a user to verbally communicate with other users locally and\/or over a network. Connected to the voice communication unit is a headset , which includes a boom microphone . In the described implementation, each controller is configured to accommodate two removable function units, although more or fewer than two removable function units or modules may instead be employed.","Gaming system  is capable of playing, for example, games, music, and videos. It is contemplated that other functions can be implemented using digital data stored on the hard disk drive or read from optical storage disc  in drive , or using digital data obtained from an online source, or from the MU. For example, gaming system  is capable of playing:\n\n",{"@attributes":{"id":"p-0041","num":"0043"},"figref":"FIG. 3","b":["100","102","200","202","204","206","208","106","200","1","210","2","212","200","202"]},"As an example of one suitable implementation, CPU , memory controller , ROM , and RAM  are integrated onto a common module . In this implementation, ROM  is configured as a flash ROM that is connected to memory controller  via a PCI bus and a ROM bus (neither of which are shown). RAM  is configured as multiple Double Data Rate Synchronous Dynamic RAMs (DDR SDRAMs) that are independently controlled by memory controller  via separate buses (not shown). Hard disk drive  and portable media drive  are connected to the memory controller via the PCI bus and an Advanced Technology Attachment (ATA) bus .","A three-dimensional (3D) graphics processing unit (GPU)  and a video encoder  form a video processing pipeline for high-speed and high-resolution graphics processing. Data are carried from graphics processing unit  to video encoder  via a digital video bus (not shown). An audio processing unit  and an audio encoder\/decoder (CODEC)  form a corresponding audio processing pipeline for high fidelity and stereo audio data processing. Audio data are carried between audio processing unit  and audio CODEC  via a communication link (not shown). The video and audio processing pipelines output data to an A\/V port  for transmission to the television or other display monitor. In the illustrated implementation, video and audio processing components \u2013 are mounted on module .","Also implemented by module  are a USB host controller  and a network interface . USB host controller  is coupled to CPU  and memory controller  via a bus (e.g., the PCI bus), and serves as a host for peripheral controllers \u2013. Network interface  provides access to a network (e.g., the Internet, home network, etc.) and may be any of a wide variety of various wire or wireless interface components, including an Ethernet card, a telephone modem interface, a Bluetooth module, a cable modem interface, an xDSL interface, and the like.","Game console  has two dual controller support subassemblies and , with each subassembly supporting two game controllers \u2013. A front panel I\/O subassembly  supports the functionality of power button  and eject button , as well as any light-emitting diodes (LEDs) or other indicators exposed on the outer surface of the game console. Subassemblies , , and  are coupled to module  via one or more cable assemblies .","Eight function units \u2013are illustrated as being connectable to four controllers \u2013, i.e., two function units for each controller. Each function unit  offers additional functionality or storage on which games, game parameters, and other data may be stored. When an MU is inserted into a controller, the MU can be accessed by memory controller . A system power supply module  provides power to the components of gaming system . A fan  cools the components and circuitry within game console .","To implement the present invention, a game software application  comprising machine instructions stored on a DVD or other storage media (or downloaded over the network) is loaded into RAM  and\/or caches ,  for execution by CPU . Portions of software application  may be loaded into RAM only when needed, or all of the software application (depending on its size) may be loaded into RAM . Software application  is described below in greater detail.","Gaming system  may be operated as a stand-alone system by simply connecting the system to a television or other display monitor. In this standalone mode, gaming system  enables one or more users to play games, watch movies, or listen to music. However, with connectivity to the Internet or other network, which is made available through network interface , gaming system  may be further coupled to another gaming system or operated as a component of a larger network gaming community, to enable online multiplayer interaction in games that are played over the Internet or other network with players using other gaming systems.","Network System",{"@attributes":{"id":"p-0049","num":"0051"},"figref":"FIG. 4","b":["300","100","100","302","302","302","302"],"i":["a","n "]},"In addition to gaming systems , one or more online services , . . . are accessible via network  to provide various services for the participants, such as serving and\/or hosting online games, serving downloadable music or video files, hosting gaming competitions, serving streaming A\/V files, enabling exchange of email or other media communications, and the like. Network gaming environment  may further employ a key distribution center  that plays a role in authenticating individual players and\/or gaming systems  for interconnection to one another as well as to online services , . . . . Distribution center  distributes keys and service tickets to valid participants that may then be used to form game playing groups including multiple players, or to purchase services from online services , . . . ","Network gaming environment  introduces another memory source available to individual gaming systems , i.e., online storage. In addition to optical storage disc , hard disk drive , and MU(s), gaming system can also access data files available at remote storage locations via network , as exemplified by remote storage  at online service ","Network gaming environment  further includes a developer service  with which developers can produce media effects, updated media data, game code, and other services. Such services can be distributed between the online services and the gaming systems, and between other devices within, and outside of network gaming environment .","Exemplary Media Processing System and Audio Configuration","A preferred embodiment of the present invention comprises an audio effects binary image builder, and a DSP execution kernel for processing an audio effects binary image on audio processing unit  of .  illustrates a preferred system for building an audio effects binary image. A method for building an audio effects binary image is described below with regard to .  illustrates a preferred architecture of audio processing unit  for executing a DSP execution kernel to produce audio effects according to the audio effects binary image. The audio processing unit includes a setup engine  that is responsible for controlling access between console system memory and other processors within the audio processing unit. Preferably, setup engine  performs direct memory access (DMA) processing to gather data from console system memory and to convert the data, as necessary, to signed pulse code modulation (PCM) data, which is used by other components of the audio processing unit. Setup engine  also handles data addressing, including loop processing for downloadable sounds (DLS) compliance. Setup engine  communicates with a voice processor  (sometimes referred to as a VP), which is a primary PCM synthesis and sub-mixing engine.","Voice processor  and setup engine  are in communication with a global processor  (sometimes referred to as a GP). Global processor  is a DSP that performs audio effects processing and creates final linear PCM stereo or multichannel output. Global Processor  comprises a programmable DSP core  in communication with a global processor memory . Global processor memory  preferably includes a ROM  and a RAM . Further, RAM  preferably comprises a data RAM that includes an X-RAM  and a Y-RAM  for concurrent processing of two data items in a single instruction. Those skilled in the art will recognize that a reference to X-RAM  could alternatively reference Y-RAM  and vise versa The data RAM stores DSP program state data and other data needed to execute audio effect DSP programs. Global processor RAM  also preferably includes a program RAM  for storing audio effect programs and a DSP execution kernel. Program RAM  is sometimes referred to as P-RAM.","Global processor  and setup engine  communicate with an encode processor . Encode processor  provides real time Dolby digital and Dolby surround encoding. Encode processor  also monitors peak and root mean square (RMS) levels for individual audio streams as well as downmix for stereo output.","In general, audio data, such as audio data provided in a software game, flows from the console system memory to setup engine , to voice processor , to global processor , to encode processor , and ultimately to one or more speakers. During the flow of audio data through the gaming system, one or more audio effects may be applied to the audio data by global processor . Audio effects include reverberation, filtering, distortion, echo, amplitude modulation, chorus, mixing, and other conventional or custom audio effects. Such effects are implemented by software loaded from console system memory and executed by global processor . Global processor  applies the software instructions to process the audio data in voice processor  and provides the resultant output to encode processor .",{"@attributes":{"id":"p-0057","num":"0059"},"figref":"FIG. 6","b":["350","360","352","362","364","354","366","370","365","375","360","370","365","362","366","372","360","370"]},"If the game developer wishes to apply one or more audio effects, the global processor uses audio data from selected voice processor mixbins as input to one or more audio effect programs , and routes the corresponding output to predefined global processor mixbins. For example, the game developer may choose to apply a reverberation program  to audio data associated with FX send zero voice processor mixbin . In this example, reverberation program  complies with interactive 3D audio rendering guidelines, level two (I3DL2). The sample audio configuration of  illustrates that the global processor executes reverberation program  and mixes the output with audio data from front left speaker voice processor mixbin . The mixed result is routed to front left speaker global processor mixbin . Effectively, the mixbin memory location is overwritten with the mixed audio data.","Multiple audio effects can be chained or applied in a sequence, such as the sequence illustrated by a chain . Chain  comprises an infinite impulse response, second order (IIR2) filter program  and a distortion program . IIR2 filter program  is applied to audio data associated with FX send two voice processor mixbin . Because there are multiple audio effects applied in chain , a temporary mixbin  is used to temporarily store intermediate output. Preferably, temporary mixbin  is associated with a different physical memory space than the memory space associated with voice processor mixbins  and global voice processor mixbins . The intermediate output stored in temporary mixbin  is then used as input to distortion program . The output of distortion program  is also the output of the entire chain  and is routed to a global processor mixbin, such as one of FX send  global processor mixbins .","Overall Process",{"@attributes":{"id":"p-0060","num":"0062"},"figref":"FIG. 7","b":["400","410","420"]},"In more detail, an audio effect developer may utilize a development system, such as that shown in , to create, assemble, and link one or more individual audio effect programs, at a step . Preferably, the audio effect developer writes the audio effect programs in an assembly language suitable for creating machine instructions to control operation of a DSP. The audio effect developer then assembles the audio effect programs with an appropriate DSP assembler, such as a widely available Motorola Corp. DSP assembler program. The assembler preferably produces an individual binary file for each audio effect program. Also for each audio effect program, the assembler preferably produces a memory layout header file, independent of any other audio effect program. In addition to the assembled binary and header files, this embodiment of the invention requires the audio effect developer to create a small initialization file that specifies certain DSP resource requirements, some audio effect parameter information, some I\/O information, and simple settings to be used by a binary image builder. A sample assembly language program and a sample initialization file are provided in Appendix A in regard to an amplitude modulation audio effect.","At a step , the audio effect developer scrambles the binary code of each individual audio effect to produce a scrambled binary file. A variety of well known encoding and\/or encryption techniques may be used to secure each binary file, including public-private key encryption. Scrambling each individual audio effect provides some protection against copying and preparation of derivative works for the audio effect developer, who may be independent of a game developer that wishes to use one or more proprietary audio effects in a computer game or other application.","At a step , the game developer creates a configuration of audio effects, such as the configuration described above with regard to audio effect programs  in . Preferably, the audio effects configuration specifies one or more chains of audio effects, wherein each chain specifies one or more audio effects to be applied. Correspondingly, the audio effects configuration is sometimes referred to herein as a \u201cchains configuration.\u201d The chains configuration is preferably implemented as a separate initialization file, which identifies the audio effects and I\/O routing for each chain. The game developer may manually write the chains configuration file or employ an appropriate graphics user interface, such as a DSP chains builder interface described below with regard to . A sample chains configuration file is provided in Appendix B.","At a step , the game developer invokes an audio effects binary image builder (different from the DSP chains builder user interface mentioned above). The binary image builder validates the chains configuration and creates a binary image of all of the audio effect programs and initialization data, as defined by the chains configuration. The resulting binary image comprises all of the audio effect programs scrambled binary code and data, arranged in execution order of the chains configuration and stored in a form that replicates the global processor RAM blocks. Effectively, the binary image predefines DSP RAM for efficient sequential execution of the audio effect programs by the DSP core of the global processor. By predefining the memory layout for sequential execution, interrupt handling, memory management, and other overhead is minimized. With overhead minimized, an efficient DSP execution kernel can be used.","To assist in memory layout, the audio effects binary image builder also creates a description header file, which describes the memory mapping of the resulting binary image. The description header is used in a manner similar to a standard C-file header. Further details regarding the audio effects binary image builder and its outputs are described below with regard to . A sample description header file is also included in Appendix B.","At a step , the game developer compiles the description header into the overall game code and adds the binary image to the overall set of game files. The game developer also adds a sound subsystem library that includes the efficient DSP execution kernel. The game developer may also optionally add a different header file that maps individual parameters of the audio effect programs to DSP RAM, so that the game may change the audio effect parameter values in real-time during execution of the game and audio effect programs. By predefining this parameter map, the game can control audio effect parameter values without interrupt handling. Instead, the game simply pokes a new parameter value to a predefined location in DSP RAM holding the parameter value. The DSP then uses the new parameter value the next time that the DSP reads the predefined DSP RAM location. A sample parameter map header is provided as Appendix C.","Once a user receives a complete set of game files and initiates a game on a game console, the game software initializes the sound subsystem, at a step . The game sound subsystem triggers the DSP core of the global processor to copy the DSP execution kernel from the sound subsystem library into the DSP RAM and begin running the DSP execution kernel. At a step , the game software further instructs the sound subsystem to copy the binary image from the game files to a scratch memory space of the game console memory. The scratch memory space is a predefined area of console system memory that is accessible to the DSP. The sound subsystem also sets a number of command flags that the DSP execution kernel regularly polls. When the DSP execution kernel detects the set command flags, the DSP execution kernel instructs the DSP core, at a step , to load the binary image from the console scratch memory into the RAM of the global processor. Finally, the DSP execution kernel begins executing the audio effects programs of the binary image.","Exemplary Audio Effects DSP Chains Builder and Binary Image Builder",{"@attributes":{"id":"p-0068","num":"0070"},"figref":"FIG. 8","b":["440","442","444","446","440","450","452","454","456","440","460"],"i":"a "},{"@attributes":{"id":"p-0069","num":"0071"},"figref":["FIG. 9","FIG. 9"],"b":["440","470","450","450","472","472","472","452","452","474"],"i":["b","b "]},"Other audio effect programs may be inserted into the chain in a similar manner with conventional menu functions. For example, clicking a right mouse button may cause DSPBuilder  to display a list of editing functions , and an additional list of audio effects . When satisfied with the configuration of audio effects, the game developer preferably invokes another function of DSPBuilder  to generate a chains configuration initialization file, such as the example shown in Appendix B.","The game developer then invokes an audio effects binary image builder to generate the binary image of the audio effects configuration and to generate the corresponding description header.  is a flow diagram illustrating logic used by the audio effects binary image builder to first validate the configuration of audio effects. At a step , the image builder parses the chains configuration initialization file for a chain of audio effects. Recall that a chain may comprise a single audio effect. At a decision step , the binary image builder determines whether multiple audio effects are defined in the current chain. If multiple effects are defined in the current chain, the binary image builder determines, at a step , a number of temporary mixbins required for the inputs and\/or outputs of the audio effects in the current chain.","After the number of temporary mixbins is determined, or if no temporary mixbins are required for the current chain, the binary image builder accesses an audio effect initialization file (e.g., effect.ini). The audio effect initialization files for each audio effect in all of the chains are identified in the chains configuration initialization file. At a step , the binary image builder parses the current audio effect initialization file for resources required by the audio effect, as defined by the audio effect developer when creating the audio effect initialization file. For example, the binary image builder searches for the number of DSP cycles required to execute the audio effect, the number of inputs to the audio effect, the number of outputs from the audio effect, the amount of scratch space required in memory, the number of parameters for the audio effect, and other resources required by the audio effect. At a decision step , the binary image builder determines whether a running total for each of the required resources exceeds the resources available from the DSP. If one of the running totals exceeds the corresponding available resources of the DSP, the binary image builder processes an error at a step . The game developer must then modify the configuration of audio effects to bring the overall configuration of audio effects within the resource limitations of the DSP.","If the current running totals of required resources do not exceed the resource limitations of the DSP, the binary image builder adds the resources required by the current audio effect to the corresponding running totals, at a step . Those skilled in the art will recognize that an alternative approach is to subtract the resources required by the current audio effect from the associated total resources available for the DSP. In that approach, decision step  would instead determine whether a running total of available resources is less than zero. In any case, at a step , the binary image builder validates inputs and outputs of the current audio effect. Validation includes ensuring that inputs to the audio effect are connected to a mixbin or other source of audio data if the audio effect requires such input. Similarly, the binary image builder ensures that outputs from the audio effect are connected to a temporary or permanent mixbin. Those skilled in the art will recognize that a variety of other validations may be performed. If the inputs and outputs of the current audio effect cannot be successfully validated, the binary image builder processes an error for the game developer to correct.","After successful validation of the current audio effect is complete, the binary image builder determines, at a decision step , whether another audio effect exists in the current chain. If another audio effect exists in the current chain, control returns to step  to parse a next audio effect initialization file and perform the validations described above. Once all of the audio effects in the current chain have been validated, the binary image builder determines, at a decision step , whether another chain of audio effects exists in the audio configuration (i.e., as indicated in the chains configuration initialization file). If another chain exists, control returns to step  to obtain the needed information from the chains configuration initialization file and validate the audio effects of the next chain as described above.","Once the configuration of audio effects has been validated, the binary image builder generates the binary image according to logic illustrated in . Specifically, at a step , the binary image builder obtains the scrambled binary file of a first audio effect in a chain (e.g., effect.scr). Based on information from the corresponding audio effect initialization file (e.g., effect.ini) and the chains configuration initialization file (e.g., chainsconfig.ini), the binary image builder determines, at a step , the memory resources required by the audio effect. The binary image builder also determines a sequential location in DSP RAM to store state data and binary program code for the current audio effect. Effectively, the binary image builder determines a pointer offset from a predefined location in DSP RAM for the audio effect state data and another pointer offset from the state data for the binary machine code of the audio effect program. At a step , the binary image builder unscrambles the scrambled binary machine code of the audio effect. With the machine code unscrambled, the binary image builder will later be able to modify pointer values.","The binary image builder then places the audio effect state data into a binary image held in memory of the game developer's system, at a step . The state data are placed at a location of the binary image that is associated with the location determined at step  for the state data in DSP RAM. Specifically, the state data location in the binary image corresponds to a location in DSP X-RAM. Similarly, the binary image builder places the binary machine code of the audio effect program into a location of the binary image that corresponds to a location of DSP P-RAM, which was also determined at step . Because the binary image replicates storage locations of the DSP RAM, the binary image provides a mapping from a scratch space of console system memory to DSP RAM. This mapping sequentially packs the state data of each audio effect into the DSP X-RAM, and packs the binary machine code of each audio effect program into the DSP P-RAM. By consolidating all of the program machine code together and all of the state data together, the DSP core can sequentially execute the program instructions and sequentially refer to corresponding state data. Preferably, the DSP core will simply execute each instruction in order, without any breaks between audio effect programs and without having to determine the location of each successive instruction. This sequencing, minimizes the need for DSP branching, which often requires interrupt handing and memory management overhead. Branching may occur within an audio effect as defined by its program instructions. However, no branching is required between audio effects, so the DSP execution kernel need not be involved in transferring control from one audio effect to another audio effect.","However, because the state data and the binary machine code of an audio effect program have been relocated, the binary machine code of the program must be modified to point to the new location of the state data. Thus, at a step , the binary image builder modifies a first op code of the current audio effect program, so that the first op code points to the new location in DSP X-RAM where the audio effect state data will be stored. To enable this modification, each audio effect program must contain a predefined instruction as the first line of the audio effect program. Specifically, the first line of each audio effect program must comprise the following move instruction.\n\nmove #>$40, r\n","The binary image builder moves a new base pointer from register r into address . Those skilled in the art will recognize that the exact instruction format and register number may differ, depending on the secondary processor used and its corresponding assembly language. In this exemplary embodiment, the new base pointer points to the location in DSP X-RAM where the state data are to be stored. Preferably, the above instruction is provided in an effects entry point macro that is defined in a utility header, which is included in each audio effect program.","Once the first op code of the audio effect program block is modified, the binary image builder determines, at a decision step , whether the current audio effect program was previously determined to require one or more temporary mixbins. The determination was made at step  of . If one or more temporary mixbins are required, the binary image builder reserves a portion of DSP X-RAM, at a step  of . For each temporary mixbin required, the binary image builder reserves a predefined number of words of DSP X-RAM. At a step , the binary image builder then modifies the corresponding I\/O pointers of the audio effect program to point to the reserved DSP X-RAM locations associated with the required temporary mixbins.","After accounting for temporary mixbins, or determining that the current audio effect program does not require any temporary mixbins, the binary image builder places the DSP X-RAM address and length of the state data (and any required temporary mixbins) in a command block of the binary image, at a step . Similarly, the binary image builder places the DSP P-RAM address and length of the audio effect program code in the command block in the binary image. The command block is stored at a predefined location in the binary image corresponding to a predefined location in the DSP X-RAM, so that the DSP execution kernel will always know where to find the address of each block of audio effect program code and the address of each corresponding block of state data. The information in the command block is used for coordinating data transfers between the DSP RAM and the scratch space of the console system memory.","At a step , the binary image builder rescrambles the current audio effect in the binary image. This rescrambling does not alter the length of the program code, and thus, does not affect the P-RAM address and length determined above. At a decision step , the binary image builder determines whether another audio effect exists in the current chain. If another audio effect is defined for the current chain, control returns to step  to process a next audio effect into the binary image. When all audio effects of the current chain have been processed, the binary image builder determines, at a decision step , whether another chain exists in the configuration of audio effects. If another chain is defined, control returns to step  to process another chain of audio effects into the binary image.","Once all chains of audio effects have been processed into the binary image, the binary image builder changes a final \u201cno op\u201d instruction into a \u201creturn\u201d instruction, at a step . This return instruction will cause the DSP core to transfer execution control back to the DSP execution kernel after all audio effects in the program block have executed. The DSP execution kernel can then determine whether any command flags were set and reinitiate execution of the audio effects in the binary image at the next frame. To enable the binary image builder to add the return instruction, regardless of which audio effect program is last in the program block, each audio effect program must include a no op instruction as its last instruction. When an audio effect is not the last effect in the program block, the no op instruction enables the DSP core to execute the next audio effect program placed in DSP P-RAM, without returning control to the DSP execution kernel. However, as indicated above, control must be returned to the DSP execution kernel after the very last audio effect program has completed execution. Therefore, the no op instruction of the very last audio effect program is changed to a return instruction. Rather than changing the final no op instruction, those skilled in the art will recognize that a return instruction could alternatively be added after the final no op instruction.","At a step , the binary image builder writes out the binary image to a file, which is then included with other game files. As discussed above, the binary image builder also generates and writes a binary image description header file, at a step , to be included with the game files. The description header includes public parameter values, scratch offsets, scratch lengths, and other standard header info from each audio effect initialization file. As part of these write steps, the entire binary image and\/or description header may also be scrambled, encrypted, or otherwise secured as another layer of protection for the audio effects and the entire configuration of audio effects.",{"@attributes":{"id":"p-0084","num":"0086"},"figref":"FIG. 12","b":["530","530","532","532","530","532"]},"Following blank block  is a command block . Command block  begins at a predefined location of binary image . As indicted above, the beginning of command block  corresponds to a predefined location in scratch space of consol system memory. Also as indicated above, the scratch space is an area of console system memory that is reserved for exclusive use by the DSP, and replicates the DSP RAM. Specifically, the predefined location in scratch space for command block  corresponds to a predefined location in DSP X-RAM. Command block  comprises pointers and lengths for state data blocks of binary image  to be loaded into DSP X-RAM. Similarly, command block  includes pointers and lengths for audio effect programs of binary image  to be loaded into DSP P-RAM.","The state data of each audio effect in the configuration of audio effects are stored in a states block . States block  begins at a predefined relative offset from the beginning of command block . As above, the predefined relative offset of states block  corresponds to a predefined relative offset from the beginning of DSP X-RAM.","Directly after the end of states block  is a programs block . Programs block  comprises all of the machine code for the audio effect programs included in the configuration of audio effects. Because states block  may vary in length from one binary image to another binary image, programs block  does not begin at a predefined offset. Instead, programs block  begins at a relative offset from the beginning of command block , wherein that relative offset is determined during generation of the binary image so as to be located just after the end of states block . The relative offset of programs block  is mapped to a predefined offset from the beginning of DSP P-RAM. The predefined offset in DSP P-RAM falls after the area of DSP P-RAM that is used to store the DSP execution kernel. Although the binary image replicates portions of DSP RAM, it is the DSP execution kernel that actually copies and maps the binary image data and program code between the scratch space of console system memory and DSP RAM.","Exemplary DSP Execution Kernel","The above discussion explains a preferred embodiment of the present invention that enables a developer to generate a binary image of audio effects on a development system such as a PC. The following discussion is directed to another aspect of the present invention for a preferred embodiment employed for loading and executing the audio effect programs of the binary image on a DSP in a game console under the direction of an efficient DSP execution kernel. To begin,  is a flow diagram illustrating logic for loading the DSP execution kernel into DSP RAM of the game console. At a step , the game console loads controlling game code to the console system memory. At a step , the game code initializes a sound subsystem. The sound subsystem obtains the DSP execution kernel from a sound subsystem library that was included with the game files. At a step , the sound subsystem loads the DSP execution kernel to the predefined location in console system memory referred to as the scratch space. Preferably, the sound subsystem utilizes an application programming interface (API), such as Microsoft Corporation's DirectSoundCreate API.","Once a DSP execution kernel is loaded into the scratch space of console system memory, the sound subsystem instructs the DSP to boot, at a step . The DSP is hard wired to execute a boot routine stored in a DSP ROM. The DSP boot routine is a basic input\/output system (BIOS) that is appropriate for the particular DSP hardware. As with most BIOSs, the DSP boot routine is hard coded to obtain further instructions from a predefined location in memory. Here the DSP boot routine is hard coded to obtain further instructions from the predefined location in console system memory referred to as the scratch space. Thus, at a step , the DSP boot routine downloads the DSP execution kernel from the scratch space of console system memory into a predefined beginning location of DSP P-RAM.","While the DSP is downloading the DSP execution kernel, the game code may be loading the binary image file into the scratch space of console system memory.  is a flow diagram illustrating logic for loading the binary image file into scratch space of console system memory. At a step , the game obtains the binary image file and the description header from among the other game files and copies the binary image file to a convenient location of console system memory. At a step , the game instructs the sound subsystem to copy or move the binary image to the predefined location of console system memory referred to as the scratch space. Preferably, the sound subsystem places the binary image in the scratch space via an API such as Microsoft Corporation's DownloadEffectsImage APT.","With the binary image in scratch space, the game instructs the sound subsystem to unscramble each audio effect of the binary image, at a step . The sound subsystem uses information stored in the binary image description header to locate the program code of each audio effect in the binary image. After unscrambling each audio effect, the sound subsystem sets a number of command flags, at a step . The command flags are located at predefined locations in the scratch space that the DSP execution kernel regularly polls. Setting the command flags indicates to the DSP execution kernel that the DSP execution kernel should load portions of, or all of, the binary image to DSP RAM. For example, one command flag indicates that the DSP execution kernel should load the programs block from the binary image into the DSP P-RAM. Similarly, another command flag indicates that the DSP should load the states block from the binary image to the DSP X-RAM.",{"@attributes":{"id":"p-0092","num":"0094"},"figref":"FIG. 15","b":["560","562","564"]},"After the state status flag is set, the DSP execution kernel maps the state information of the audio effects from the scratch space to the DSP X-RAM, at a step . To map the information, the DSP execution kernel preferably uses a virtual address interface. The audio processing unit preferably provides an interface that maintains virtual addresses in the console system memory. The virtual addresses point to addresses in DSP RAM. By having virtual access to the DSP RAM, the game can modify audio effect parameters in real time.","Once the DSP execution kernel begins mapping audio effect state information, or if the state flag was not set, the DSP execution kernel determines, at a decision step , whether a program flag is set. If the program flag is set, the DSP execution kernel sets a program status flag to pending, at a step . In a manner similar to that described above, the DSP execution kernel then maps the audio effects program code from the scratch space to the DSP P-RAM, at a step .","When the desired code and state information are loaded into DSP RAM, the DSP execution kernel resets the status flags back to \u201cfree,\u201d at a step . In response, the primary processor of the game console resets the command flags to free, so that the DSP execution kernel does not attempt to redownload the same information. At a step , the DSP execution kernel jumps to the fixed location in DSP P-RAM that holds the audio effects program code and begins to execute the audio effects program. At a decision step , the DSP execution kernel determines whether the current DSP execution frame is complete. If the DSP execution frame is not complete, control returns to step  to continue executing the audio effects program. Once a DSP execution frame is complete, control returns to a step , at which time the DSP execution kernel again polls the command flags and repeats the above downloading process if either command flag is set.",{"@attributes":{"id":"p-0096","num":"0098"},"figref":"FIG. 16","b":["580","582"]},"Knowing the locations of the desired parameters in the program code stored in the scratch space, at a step , the API then writes the updated parameter values to the scratch space locations. It will be recalled that the parameter value locations in scratch space are virtual addresses of the DSP X-RAM. At a step , the game then sets the state flag to inform the DSP that new parameter values are available. As discussed above, and as shown by a step , the DSP downloads and uses the updated parameter values at the next DSP execution frame. To ensure that an audio effect uses updated parameter values, entry point code of each audio effect program preferably includes the following instructions to initialize the audio effect.",{"@attributes":{"id":"p-0098","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"move x:(rD+FXSTATEFLAGS),x0"]},{"entry":[{},"brset #BITFXSTATEFLAGINITIALLZED,x0,ComputeFX"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"InitFX"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"bset #BITFXSTATEFLAGINITIALIZED,x0"]},{"entry":[{},"move x0,x:(rD+FXSTATEFLAGS)"]},{"entry":[{},"endm"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The above entry point code instructs the DSP core to check whether an audio effect state flag is set. If an audio effect state flag is already set, then the audio effect is already initialized and can branch immediately to the main portion of the audio effect code, which is labeled by ComputeFX. This technique enables the audio effect to use previous parameter values, rather than rereading parameter values at each frame. However, if the audio effect is not initialized, the code instructs the DSP core to set an initialization bit, which causes the audio effect to reinitialize and use the new parameter value.","Although the present invention has been described in connection with the preferred form of practicing it, those of ordinary skill in the art will understand that many modifications can be made thereto within the scope of the claims that follow. Accordingly, it is not intended that the scope of the invention in any way be limited by the above description, but instead be determined entirely by reference to the claims that follow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWING FIGURES","p":["The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same becomes better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
