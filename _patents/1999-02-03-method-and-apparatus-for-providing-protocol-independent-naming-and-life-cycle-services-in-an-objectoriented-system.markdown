---
title: Method and apparatus for providing protocol independent naming and life cycle services in an object-oriented system
abstract: A framework based Java naming and lifecycle services system includes a Moniker class which universally identifies an instance of any object model, whether the instance exists or not. Moniker objects instantiated from the Moniker class operate with a set of directory service classes and object adapters to create a directory service framework and a mechanism for connecting the directory service framework to existing directory services. A set of runtime classes provide “in process” services for objects. For example, the Moniker class is automatically substituted for a client reference when the underlying object instance is streamed or persisted. In accordance with one embodiment, life cycle services are provided by associating a predefined policy with each Moniker object, which policy specifies how and when life cycle services should be performed. Remote objects are then created or bound in accordance with these policies which eliminates the need for the client to directly incorporate life cycle services code into its logic.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07127724&OS=07127724&RS=07127724
owner: International Business Machines Corporation
number: 07127724
owner_city: Armonk
owner_country: US
publication_date: 19990203
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The present invention relates, in general, to frameworks for distributed object systems, and, more specifically, to frameworks for providing naming, lifecycle and security services as part of a complete distributed object environment.","Software is increasingly becoming a major portion of cost associated with computer systems because it is very \u201clabor-intensive.\u201d Some of this cost is due to the effort involved in writing and debugging programs, other costs involve maintaining programs after they have been written. Accordingly, considerable effort has been expended in order to reduce the time and costs involved with writing, debugging and maintaining moderate and large software programs. Much of this effort has been related to developing programming languages and programming techniques which will allow programmers to build on or \u201creuse\u201d programs and code segments that have been written by others.","Until very recently, software programming was heavily dominated by an approach referred to as \u201cstructured programming.\u201d Common software programming languages used in this approach were, and remain, BASIC, FORTRAN, and PASCAL. These are considered \u201chigher order\u201d languages that are written in human readable code and ultimately translated into machine or computer readable code by a compiler. Typically, structured programs have consisted of a combination of defined variables of specific data types, e.g. integer, real, and character, and a complimentary set of functions or routines which operate on these variables. Often, a program would include sub-routines which are smaller routines within a program or larger routine that carry out certain operations, e.g. printing data in a given output format. The emphasis to this approach was inputs\u2014functions\u2014outputs and they were often represented as flowcharts by the designers, which logically represented how the program functioned and branched into different functional paths. As an increasing number of programs became large (tens of thousands of lines of code and above) structured programs became increasingly complex and difficult to write, troubleshoot and maintain.","Flowcharts became unwieldy and the tracking of errors through permutations of variables, lengthy code, and a wide variety of program branches was time and cost intensive and often produced less than adequate results. Consequently, a new approach to software programming called Object-Oriented Design (OOD) or Object-Oriented Programming (OOP) emerged and has gained increasing popularity among software developers. OOP promised greater reuse and maintainability than its structured programming predecessor because of an emphasis on well-defined and self contained objects, rather than the structured programming emphasis on a proliferation of relatively loosely-related data manipulating functions and subroutines.","Object Oriented Programming techniques involve the definition, creation, use and destruction of \u201cobjects.\u201d These objects are software entities comprising data elements, or attributes, and methods, or functions, which manipulate the data elements. The attributes and related methods are treated by the software as an entity and can be created, used and destroyed as if they were a single item. Objects are defined by creating \u201cclasses\u201d which are not objects themselves, but which act as templates that instruct the computer how to construct the actual object. A class may, for example, specify the number and type of data variables and the steps involved in the methods which manipulate the object's data.","Object-Oriented Programming languages include C++ and Java, as well as other languages. Each language has an express or implied \u201cobject model.\u201d Generally speaking, an object model is a unifying set of rules that describe object structure, object life cycle, and inter-object communication. Object structure relates to the physical layout of objects in memory, while object life cycle refers to how applications create and destroy objects. Inter-object communication refers to protocols by which objects communicate with one another. Object models are useful in contexts where all objects in a given system need to conform to a given protocol governing these parameters.","In addition to object-oriented programming languages, code sharing has been facilitated by distributed object systems. In a distributed object system a client object can invoke methods in a server object as if the methods were local to the client object. The server object may be located locally with respect to the client object or may be remote and accessible by a network. Such distributed object systems offered the promise of allowing objects written by different programmers to easily communicate.","However, initially, the promise of reusability and economy of OOP and distributed object systems was not realized. Standards were not in place to insure interoperability of objects or cross-platform interoperability and the proliferation of objects conforming to different object models prevented significant reuse, as originally envisioned. This problem became even more evident when the Internet and the World Wide Web (Web) emerged as widely-used resources and ensured that a wide variety of platform configurations would attempt to access and use commonly-available information on the Internet. As a result, applications designed to operate on the Web used languages designed specifically for the Web, such as hyper-text mark-up language (HTML) as a way to provide a static, but commonly useable, form of coded information while object-oriented programming was applied in other applications. But the problem of cross-platform interoperability persisted and grew as it became more desirous to add dynamic capability to the Web and as many organizations were using multiple platforms and grappling with interoperability internally.","In order to solve these problems, a number of common object models were developed for use with distributed object systems. These models are based on a well-known application programming interface (API), predefined life cycle steps and a homogeneous distributed object model. Such models typically included some type of interface definition language which allows objects written in different languages to have standardized interfaces so that the objects will be able to communicate. Some object models also include predefined mechanisms for transporting communications between remotely-located objects which have interfaces that conform to their specifications. Finally, some object models have also included naming services which allowed client objects to locate server objects when the server objects were located remotely.","Even with such systems the promise of reusability and economy of OOP and distributed object systems has still not been realized because there are a myriad of object models commonly in use, including RMI, CORBA, BOSS, San Francisco, PDO, OpenDoc, COM\/DCOM and proprietary object models. There are a further group of persistent store protocols including RDBMS, flat files, ODBMS, ODBC, JDBC, CICS\/IMS and proprietary protocols. Finally, there is a proliferation of naming services including LDAP, DNS, X.500, StreetTalk, DCE CDS, URL, Lotus Address Book, Novel NDS, Whois++, SOLO, IDS and various proprietary systems. Therefore, the environment with which client applications and the program developers which develop and support them must work is chaotic.","Consequently, a need exists for a method and apparatus for providing distributed object systems with consistent naming and life cycle policies. A further need exists for providing such services without requiring the users to completely complete their existing systems.","An inventive method and system provide a framework based Java naming and lifecycle services system. The framework includes a Moniker class which universally identifies an instance of any object model, whether the instance exists or not. Moniker objects instantiated from the Moniker class operate with a set of directory service classes and object adapters to create a directory service framework and a mechanism for connecting the directory service framework to existing directory services. Finally a set of runtime classes provide \u201cin process\u201d services for objects. The Moniker class is automatically substituted for a client reference when the underlying object instance is streamed or persisted.","In accordance with one embodiment, life cycle services are provided by associating a predefined policy with each Moniker object, which policy specifies how and when life cycle services should be performed. Remote objects are then created or bound in accordance with these policies which eliminates the need for the client to directly incorporate life cycle services code into its logic.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":"100"},"Computer system  includes a central processing unit (CPU) , which may be implemented with a conventional microprocessor, a random access memory (RAM)  for temporary storage of information, and a read only memory (ROM)  for permanent storage of information. A memory controller  is provided for controlling RMA .","A bus  interconnects the components of computer system . A bus controller  is provided for controlling bus . An interrupt controller  is used for receiving and processing various interrupt signals from the system components.","Mass storage may be provided by diskette , CD ROM , or hard drive . Data and software may be exchanged with computer system  via removable media such as diskette  and CD ROM . Diskette  is insertable into diskette drive  which is, in turn, connected to bus  by a controller . Similarly, CD ROM  is insertable into CD ROM drive  which is, in turn, connected to bus  by controller . Hard disk  is part of a fixed disk drive  which is connected to bus  by controller .","User input to computer system  may be provided by a number of devices. For example, a keyboard  and mouse  are connected to bus  by controller . An audio transducer , which may act as both a microphone and a speaker, is connected to bus  by audio controller , as illustrated. It will be obvious to those reasonably skilled in the art that other input devices, such as a pen and\/or tabloid may be connected to bus  and an appropriate controller and software, as required. DMA controller  is provided for performing direct memory access to RAM . A visual display is generated by video controller  which controls video display . Computer system  also includes a communications adaptor  which allows the system to be interconnected to a local area network (LAN) or a wide area network (WAN), schematically illustrated by bus  and network .","Operation of computer system  is generally controlled and coordinated by operating system software, such as the OS\/2\u00ae operating system, available from International Business Machines Corporation, Austin, Tex. The operating system controls allocation of system resources and performs tasks such as processing scheduling, memory management, networking, and I\/O services, among other things.","The Java programming language is rapidly emerging as the preferred OOP language for Internet and cross platform use because Java programs consist of bytecodes, which are architecture and operating system independent and can be sent over the Internet and other networks. The bytecode is actually executed on a particular platform by means of a \u201cvirtual machine\u201d (VM) which allows a Java program to be run on any platform, regardless of whether the Java program was developed on, or for, the particular platform which attempts to run the Java program. Java bytecodes which arrive at the executing machine are interpreted and executed by the embedded VM.","A complete Java program is known as an application, while a segment of Java code, which does not amount to a full application, but is reusable, is referred to as an \u201capplet\u201d. Java also includes a component model where a component is a self-contained object with a predefined interface. A component within Java is referred to as a \u201cbean,\u201d and includes such a defined interface. Java beans are used within applets and applications and a programmer need not know the internal structure of the Java bean to use it, he need only know the interface. In addition, once the interface of a bean is known, a programmer can create a new customized component from the base Java bean component. The Java bean contains properties and methods, which can be changed when another bean is derived created from the bean, which is how customization of the new component is achieved.","Since Java is well-suited to operation over networks, the following description of the illustrative embodiment is directed toward the Java programming language. However, it will be obvious to those skilled in the art that the invention could be implemented for other OOP languages as well, e.g. C++.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2","b":["200","200","220","210","220","230","240","220","210"]},"Referring to , the development kit  is illustrated in greater detail and includes several software packages. In accordance with conventional Java program organization, these packages include both interfaces and implementation classes. The interfaces are classes which include methods used to define the syntax an object must implement in order to ensure compatibility of the object with other relevant methods. Some interfaces and implementation classes are only used on the server side while other interfaces and classes may be used on either the client or server sides. More specifically, the development kit  includes an object handling package , a server package , a runtime package , a console utility package , a CORBA package , and an RMI package . Each package is discussed more fully below.","Referring to , the individual classes of the object handling package  (illustrated as  in ) are shown. The Uuid class  includes a method which provides a unique identification number for each instance of an object. This unique identification number is used internally by the inventive framework in order to track a particular instance of an object over its lifetime. A method within the Uuid class  creates the unique identification number using a random number generator which is seeded with a date and time at which the instance is created.","The Service class  is a subclass of the Uuid class  and includes a method which, instead of providing a unique identification number, provides a \u201cwell-known\u201d identification number which is used to identify a \u201cknown\u201d service related to an object, such as an Internet phone book service. Such a \u201cwell-known\u201d ID is available and known by typical users and the service is one which is standard within the framework and available to users.","The Parcel class  encapsulates associations between moniker objects, instances of the inventive framework, and objects. In accordance with the principles of the invention, moniker objects are lightweight shells of an actual object and, therefore, are always associated with an object. The moniker objects are discussed in greater detail below and are substituted for instances or references to an actual object in streaming and persistence operations, thereby allowing additional services, such as life cycle services to be associated with the object. Framework instances, as opposed to the framework itself, are running instances of the framework . Methods within the Parcel class  track these associations in a client-side virtual machine. The preferred method for locating an object with the inventive system is to retrieve an associated parcel object.","The OutputStream class  is derived from the java.io.object.OutputStream class in the standard java.io.object library  and is used in lieu of the parent Java class any time that an object is streamed-out. In accordance with the principles of the present invention, when the OutputStream class is used and an object is encountered in the stream, a related moniker object is substituted for the actual object in the stream.","The InputStream class  is also derived from the java.io.object.InputStream class in the standard java.io.object library  and is used in lieu of the parent Java class when data is to be streamed-in which data was originally streamed-out by the OutputStream class . During a streaming-in process using the InputStream class , any moniker object encountered in the stream is resolved to find the actual object which is then substituted within the stream for the moniker object The PolicySet class  is used to provide life cycle services for moniker objects and contains a predetermined, enumerated set of specific life cycle services which can be applied to a particular instance of an object over the lifetime of that object. Associating specific policies with an object is done by specifying the policies or rules to use when creating, locating, persisting, resurrecting, destroying, and copying objects via the inventive framework. These policies are stored in the PolicySet object and are set when an object is created and are represented by defined Boolean constants. Each constant can be \u201con\u201d or \u201coff\u201d, as follows;",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Policy","On","Off"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["a) kCreate","Create new instance.","Resurrect persisted object."]},{"entry":["b) kUseMoniker","Use existing moniker.","Create a new moniker."]},{"entry":["c) kKeep","Keep persistent storage","Delete persistent storage"]},{"entry":[{},"after resurrection.","after resurrection."]},{"entry":["d) kResStationary","Use stationary storage.","Use storage located by"]},{"entry":[{},{},"moniker."]},{"entry":["e) kPersist","Persist immediately","Do not persist immediately"]},{"entry":[{},"before returning from"]},{"entry":[{},"moniker resolve"]},{"entry":[{},"method."]},{"entry":["f) kPerAtShutdown","Persist at shutdown.","Do not persist at"]},{"entry":[{},{},"Shutdown."]},{"entry":["g) kPerUnreferenced","Persist when no","Do not persist when no"]},{"entry":[{},"longer referenced.","longer referenced."]},{"entry":["h) kDisAtShutdown","Delete all storage at","Do not delete all storage"]},{"entry":[{},"at shutdown.","at shutdown."]},{"entry":["i) kLog","Log each transaction.","Do not log each"]},{"entry":[{},{},"transaction."]},{"entry":["j) kRtUnreferenced","Delete from memory","Keep alive even if no"]},{"entry":[{},"when no longer","longer referenced."]},{"entry":[{},"referenced."]},{"entry":["k) kCopy","Return an object copy.","Return the object itself."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The PolicySet object is then associated with the moniker object for an instance in order to set the lifecycle policies for that instance.","Referring to , the server package  (also referred to as  in ) is decomposed into its interface and implementation classes. Interface names and implementation class names appended with an \u201c(s)\u201d in the figure reside only on the server side. Many of the classes and interfaces in this package deal with providing object persistence. When an object is \u201cpersisted\u201d, it is saved at a place in memory, e.g. a file system, an object store, etc. The portion of memory where it is saved is called a \u201crepository\u201d. The repository may be a runtime repository, for example, if the storage is RAM, or a persistent repository if the storage is persistent, for example, disk storage.","The IRepository interface  defines four methods which indicate the responsibilities of a repository, whether persistent or runtime. These methods perform the following functions:\n\n","The Repository(s) class  implements the methods of the IRepository interface  to accomplish persistence.","The IPersistentRepository(s) interface  extends the IRepository(s) interface  and serves as a marker for other adapter classes which support persistence in the inventive development framework. Interface  is implemented by the PersistentRepository(s) class  which extends the Repository(s) class . PersistentRepository(s) class  uses the \u201clocal\u201d file system to persist the state of a remote object implementing an interface which operates with a transport mechanism. Objects are persisted in a directory structure reflective of the name of the package to which the class belongs. This package-related directory is also related to the root directory of a repository, so that multiple repositories can be simultaneously operational.","The PersistentRepositoryException(s) server side class  includes methods which throw an exception when problems arise with the methods involved in storing, deleting, or retrieving objects instantiated from the PersistentRepository(s) class .","The ILifeCycleServices(s) server side interface  and its implementation LifeCycleServices(s) class  provide runtime and persistent store life cycle services. These classes are used to abstract the source and type of an object as well as the services which will manage the object. This abstraction is required in order to enable the use of different object models such as Java, RMI or CORBA. Classes  and  hide the miscellaneous methods in the framework class  from implementations used in the object model adapter. The methods defined in the llifeCycleServices(s) interface  add and fetch framework-managed instances of a particular object model adapter.","IObjectModelAdaptor(s)  is a server side interface and ObjectModelAdaptor(s)  is an implementation class which orchestrates the scheduling of life cycle services and most intricacies of a particular object model, such as RMI or CORBA. Its only method is used to fetch a Parcel object using the object's moniker and an implementation of the IlifeCycleServices(s) interface associated with the object. The LifeCycleServicesException(s) class  includes methods which throw an exception when an error providing life cycle services occurs. Finally the ObjectModelException(s) class  includes methods which throw an exception when an error occurs during execution of an object model adapter instantiated from class .","The Talon(s) interface  provides several methods which the Talon(s) class  implements. These methods include methods for performing the following operations:\n\n","The Talon(s) class is designed as a framework which provides various services provided by \u201cplug-in\u201d modules. These services include a persistent repository, a runtime repository, an object model adapter and a security manager. The Talon(s) server side class  also provides life cycle services and policies implemented by the classes outlined above.","Referring to  of the illustrative embodiment, the runtime package , (referred to as package  in ) is further decomposed into its classes and interfaces. These classes are put into the runtime package for the most part to take advantage of the well-known \u201cpackage private\u201d construct in the Java language which allows related code to operate together more closely and efficiently. The DirectoryService class  is an abstract class which provides the entry point into conventional directory service adapters and is generally used by the moniker class  to locate an object. The DirectoryService class  allows the look-up of an object, based on a moniker, and can also be used to export an object to the directory space. The DirectoryServiceException class  contains methods which provide an indication when some form of an exception has occurred in the execution of methods in the DirectoryService class .","The Moniker class  identifies an instance of a class and includes information about the class, such as whether it currently exists or not, in a universal manner. Instances of the Moniker class  include:\n\n","The framework name identifies the life cycle services adapter used for the moniker and associated object. The policy set associated with an object specifies the relevant life cycle services or policies invoked. The identification number identifies a unique instance of an object or, in the case of a service class, it identifies a well-known service or policy, such as the logging policy, which is controlled by the defined constant kLog, as described above. Finally, the directory service implementation allows the moniker object to resolve itself by implementing a resolve( ) method of the moniker class. The resolve( ) method within the moniker class  fetches the object associated with the moniker using a specified directory service and replaces the moniker with the object. The moniker object can be adapted to use any existing directory service and to address any namespace.","If the directory services of the moniker object have not been specified, i.e. policies have not been turned \u201con\u201d, then there are no policies or services associated with the moniker object. In that case, the resolve( ) method will attempt to use default directory services, which are specified in the abstract DirectoryService class . If the default directory services are not set, an exception will be thrown.","When a moniker object is serialized, or marshaled, the directory services are also serialized-out, along with the development framework name, policy set, and Uuid identification number. If the directory services have not been set during the serialization-out process of the moniker object, but the default directory services are set, the default directory services will be substituted during serialization-out process. However, regardless of which services were serialized, the moniker uses whichever it finds in the serialized stream during the serialization-in, or unmarshaling, process and sets it as the directory services for that particular moniker instance.","A hash code method, also in the Moniker class , which is conventionally used for identifying objects, always returns a zero when used, since the Uuid class provides the actual identification of the object, therefore, in order to determine whether two moniker objects are equal, the identification number included in moniker objects is compared by the \u201cequals\u201d method.","Directory service adapters which are used with moniker objects are generated by subclasses of the DirectoryService class . For example, the SimpleDirectoryService class  is a sub-class of the DirectoryService class  and is used as the RMI directory service adapter. It is used in conjunction with the Server Package RMIObjectModelAdaptor class (illustrated as class  in .) The SimpleDirectoryService class  includes methods to perform a simple look-up of the named development framework class and to fetch information from the framework, via RMI-compatible calls. The SimpleDirectoryServiceException class  is a sub-class of the DirectoryServiceException  and includes a method which throws an exception when an error condition occurs in the execution of a simple directory service object created from the SimpleDirectoryService class .","The LdapDirectoryService class  is a sub-class of the DirectoryService class  which adapts a moniker object to use the LDAP directory service. The LdapDirectoryServiceException class  includes a method to throw an exception when an error condition has occurred in the execution of an LDAP directory service object created from the LDAP directory service adapter object.","The IRuntimeRepository interface  extends the IRepository interface (interface  in ) and adds methods for fetching a moniker object from the repository using an object as a key, as well as copying moniker-object associations to another IRepository in order to duplicate them. The RuntimeRepository class  is an implementation of the IRuntimeRepository interface  and includes methods to track the runtime associations of moniker-object pairs. When an object is added to a runtime repository created from class , the object uses the directory service implementation included with the moniker object which is associated with the object to export the object to that directory service. The RuntimeRepositoryException class  includes a method which throws an exception when an error condition in the runtime repository occurs.","DirectoryServiceFactory class  is a concrete class which contains a method that locates and creates directory service adapters from the above classes, using a moniker object uniform resource locator (\u201cURL\u201d which is illustrated in .) For example, given a moniker object URL of \u201cIdap:\\\\super.com:80\\ . . . \u201d, the DirectoryServiceFactory class method creates a directory service adapter for the moniker object using the following steps:\n\n","This implementation simplifies the creation of adapters, minimizes the code that a client must create in order to begin to use the inventive framework and alleviates any need to hard code class declarations in client's code or some type of runtime registry mechanism.","The Protocol class  contains methods responsible for parsing the moniker URL text string into the directory service type, IPE, protocol elements, policy set, resource name, and Uuid identifier or service identification number. The ProtocolException class  contains a method which throws an exception when a problem occurs parsing the URL string.","As mentioned above, the moniker addresses a namespace by means of a uniform naming scheme which divides the responsibilities for locating an object between the inventive framework and the directory service which manages the namespace. The format for a uniform resource locator (URL) namespace addressing scheme for a Moniker class  in accordance with the illustrative embodiment and which identifies an instance of a class for any object model, is shown in . Each item, i.e. the protocol, initial point of entry (IPE), framework name, protocol elements (PEs), and the resource name, is referred to as a \u201cunit.\u201d Units are separated by a unit separator which illustratively may be the \u201c\/\u201d character or the \u201c:\/\/\u201d character string. The protocol unit is a case-sensitive alphanumeric string which identifies the directory service protocol to be used, e.g. Lightweight Directory Access Protocol (LDAP).","IPEs are alphanumeric strings separated by colons which follow well-known Internet-based naming conventions, e.g \u201cwww.taligent.com:80.\u201d Here, \u201cwww.taligent.com\u201d indicates the relevant machine or server, while \u201c80\u201d indicates the port on the machine. The development framework name is a case-sensitive character string based on the name of the server being accessed, e.g. \u201cPlaces.\u201d The PEs are key-value pairs of alphanumeric strings where the key and value(s) are separated by an equal sign and multiple values are separated by commas, e.g. \u201cPresidents=Clinton, Bush, Reagan\u201d or \u201cdn=Library.\u201d The resource names are alphanumeric strings which, in the case of Java classes, follow standard naming conventions and identify an instance of a class, e.g. foo.bar.Library. For example, using the \u201cSimple\u201d directory service protocol, described herein, the following URL might be possible:\n\n",{"@attributes":{"id":"p-0073","num":"0094"},"figref":"FIG. 7","b":"645"},"Referring to , the Console Utility package  (also illustrated as package  in ), is comprised of two classes. The ArrayUtility class  and the ConsolePairArrayException class  are used to perform search and enumeration tasks upon arrays, as well as to parse command line flags at the command prompt. The ArrayUtility class  has two methods. The first method tests for the existence and possible position of an object in a array of objects. The second method takes an array of keys and produces a hash table wherein the keys are strings prefixed with a hyphen and the values are the strings which immediately follow such hyphen prefixed strings. For example, if an array of {\u201c\u22121\u201d, \u201c\u22122\u201d, \u201cvalue 2\u201d, \u201c\u22123\u201d, \u201cvalue 3\u201d} is the input, the hash table {key=\u201c\u22121\u201d value=\u201c \u201d; key=\u201c\u22122\u201d value=\u201cvalue 2\u201d; key=\u201c\u22123\u201d value=\u201cvalue 3\u201d} is the output. These keys are used by clients to locate values which represent command line arguments. The ConsolePairArrayException class  contains a method which throws an exception when an error occurs while parsing an array of keys according to the second method described above, namely CreateFromConsolePair(string ARGS \u25a1).","Referring to , the CORBA package  (also referred to as package  in ) is decomposed into its classes. These classes include the CORBAObjectModelAdaptor class , which creates a CORBA adapter that allows use of CORBA compliant code with the inventive development framework. The CORBAParcel class  contains methods which allow objects created from the CORBAObjectModelAdaptor class  to transfer binding logic code to the client, which preserves the properties of CORBA compliant objects. The CORBAParcel class  include methods which parallel those of the Parcel class  (.) The CORBAAdaptorException  class includes a method which throws an exception when an error occurs using the CORBAObjectModelAdaptor class  or objects created therefrom.","Referring to , the RMI package  (also referred to as package  in ) is further decomposed into its classes. The classes in this package relate to the RMIObjectModelAdapter . The RMIObjectModelAdapter class  creates a RMI adapter object, which allows use of RMI compliant code with the development framework. In particular, the RMIObjectModelAdaptor class  encapsulates the basic services of an RMI Adapter. When asked for an instance of a particular class, via a moniker object, this adapter first checks the LifeCycleServices object for such an instance or service. If a reference is found, the object created from the RMIObjectModelAdapter class  includes a method which returns the reference. If no reference or instance is being managed by LifeCycleServices object, the RMI adapter object uses the class name, indicated by the resource name of the moniker, to locate and instantiate the remote RMI class. If, by adhering to the properties of the given moniker, the adapter object is able to create a manageable RMI object, the adapter adds the RMI object to the LifeCycleServices object and then returns the reference to the requester of the RMI object. If an error occurs when trying to locate or create an RMI object, an object created from the RMIObjectModelAdapterException class  will include a method which throws an exception.",{"@attributes":{"id":"p-0077","num":"0098"},"figref":["FIG. 11","FIG. 12","FIG. 11","FIG. 12"],"b":["1100","1108","1102","1104","1108","1200","1202"]},"Next, the object model adapter  uses a life cycle services object  in the Talon server  to apply the moniker object name to the runtime repository  as indicated in step . As previously mentioned, runtime repository  contains a database of moniker name-object reference pairs. Using the moniker name supplied by the life cycle services object , the runtime repository  attempts to locate the associated object reference as indicated in step . If an object reference is located, it is returned to the client  in a parcel object  as recited in step  and the process ends in step .","Alternatively, if, in step , an object reference is not located in the runtime repository , the process proceeds to step  in which the object model adapter  uses the moniker object to create a directory service adapter  by means of the directory service factory object previously described.","The directory service adapter  then applies the object name to an existing directory service  and, in step , the existing directory service is used to locate either the object or the class information for instantiating the object.","If, in step , the object is located then in step  an object reference is returned to the client  by means of the directory service adapter  and the object model adapter . As before, the object reference is returned in a parcel object as indicated in arrow .","Alternatively, if, in step , the object is not located, then, in step , the object model adapter  uses the location of the class information retrieved from the existing directory service  together with the life cycle services object  to create the object and add references to the instance to the runtime repository . The runtime repository  then adds the object reference to the existing directory service  as indicated in step . Finally, the object reference is returned in step  and the process ends in step .",{"@attributes":{"id":"p-0083","num":"0104"},"figref":["FIGS. 13 and 14","FIG. 13","FIG. 11","FIG. 11","FIG. 13","FIG. 14"],"b":["1100","1300","1300","1308","1302","1400","1402","1304","1300","1324","1404"]},"The client  also streams the object into a local repository  as indicated by data stream . The local repository can be a file system or, in the case that the client is a Java program, a JAR file. The local repository  holds the local state of the client program, whereas the actual state of the remote object is held in the persistent repository  which could be a file system or a relational or object-oriented database.","In accordance with the principles of the invention, the client q streams the object data to the local repository  using a TalonOutputStream object. When the TalonOutputStream object encounters the object, or a reference to the object, in the stream, it substitutes the moniker for the object or reference in the data stream which is stored in the local repository  as indicated in step .","The object model adapter  also applies the moniker to the life cycle services object  as indicated in step . The life cycle services object then removes the object from the runtime repository . In addition, as indicated in step , the moniker is used to create a directory service adapter  which, as indicated in step , removes any object references from the existing directory service .","Next, the life cycle services object  sends the object data to a persistent repository  as indicated by arrow  and as set forth in step . The persistence operation then finishes in step .",{"@attributes":{"id":"p-0088","num":"0109"},"figref":["FIGS. 15 and 16","FIG. 15","FIGS. 11 and 13","FIG. 11","FIG. 13","FIG. 15","FIG. 16"],"b":["1100","1300","1500","1500","1508","1502","1600","1602","1602","1508"]},"The client  also requests the object from the local repository  utilizing a TalonInputStream object, as described previously. When a moniker object is encountered in the data stream , the TalonInputStream object forwards the moniker object to the object model adapter  as indicated schematically by arrow . In step  the object model adapter  receives the moniker from the local data stream.","Next, the object model adapter  uses a life cycle services object  to resurrect the requested object from the persistence repository  as indicated schematically by arrow  and as set forth in step . Next, the moniker object is used by the life cycle services object  to add object references to the runtime repository  as illustrated in step .","In step , the directory service adapter implementation in the moniker (illustrated as directory service adapter ) adds object references to the existing directory service . The object model adapter  then returns the object references in a parcel object as indicated schematically by arrow . The local data stream then replaces the moniker in the data stream  with the object references in the parcel object  as indicated in step . The process then finishes in step .","A software implementation of the above-described embodiment may comprise a series of computer instructions either fixed on a tangible medium, such as a computer readable media, e.g. a diskette, a CD-ROM, a ROM memory, or a fixed disk, or transmissible to a computer system, via a modem or other interface device over a medium. The medium can be either a tangible medium, including, but not limited to, optical or analog communications lines, or may be implemented with wireless techniques, including but not limited to microwave, infrared or other transmission techniques. It may also be the Internet. The series of computer instructions embodies all or part of the functionality previously described herein with respect to the invention. Those skilled in the art will appreciate that such computer instructions can be written in a number of programming languages for use with many computer architectures or operating systems. Further, such instructions may be stored using any memory technology, present or future, including, but not limited to, semiconductor, magnetic, optical or other memory devices, or transmitted using any communications technology, present or future, including but not limited to optical, infrared, microwave, or other transmission technologies. It is contemplated that such a computer program product may be distributed as a removable media with accompanying printed or electronic documentation, e.g., shrink wrapped software, pre-loaded with a computer system, e.g., on system ROM or fixed disk, or distributed from a server or electronic bulletin board over a network, e.g., the Internet or World Wide Web.","Although an exemplary embodiment of the invention has been disclosed, it will be apparent to those skilled in the art that various changes and modifications can be made which will achieve some of the advantages of the invention without departing from the spirit and scope of the invention. For example, it will be obvious to those reasonably skilled in the art that, although the description was directed to a particular language, other object-oriented languages would also be suitable for the invention. Similarly, although a particular hardware system and operating system is described, other hardware and operating system software could be used in the same manner as that described. Other aspects, such as the specific instructions utilized to achieve a particular function, as well as other modifications to the inventive concept are intended to be covered by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The above and further advantages of the invention may be better understood by referring to the following description in conjunction with the accompanying figures, described below.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 12","FIG. 11"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 14","FIG. 13"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 16","FIG. 15"]}]},"DETDESC":[{},{}]}
