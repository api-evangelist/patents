---
title: Reconfiguration of a programmable logic device using internal control
abstract: A method of partially reconfiguring an IC having programmable modules that includes the steps of reading a frame of configuration information from the configuration memory array; modifying at least part of the configuration information, thereby creating a modified frame of configuration information; and overwriting the existing frame of configuration information in the configuration memory array with the modified frame, thereby partially reconfiguring the IC.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06920627&OS=06920627&RS=06920627
owner: XILINX, Inc.
number: 06920627
owner_city: San Jose
owner_country: US
publication_date: 20030228
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present invention relates to reconfiguration of an Integrated Circuit (IC) having programmable modules. More specifically, the present invention relates to the full or partial self-reconfiguration of the programmable modules.","Dynamic reconfiguration and self-reconfiguration are two of the more advanced forms of field programmable gate array (FPGA) reconfigurability. Dynamic reconfiguration involves the active FPGA being fully or partially reconfigured, while ensuring the correct operation of those active circuits that are not being changed. Self-reconfiguration extends the concept of dynamic reconfigurability. It assumes that specific circuits on the FPGA itself are used to control the reconfiguration of other parts of the FPGA. Both dynamic reconfiguration and self-reconfiguration rely on an external reconfiguration control interface to boot an FPGA when power is first applied or the device is reset.",{"@attributes":{"id":"p-0004","num":"0003"},"figref":["FIG. 1","FIG. 1"],"b":["90","102","104","106","108","112","114","92","120","92","90","90","1","90"]},"In general, FPGA  is configured in response to a set of configuration data values, which are loaded into a configuration memory array of FPGA  (not shown) from an external memory, e.g., a read-only memory (ROM), via configuration interface  and configuration logic . Configuration interface  can be, for example, a select map interface, a JTAG interface, or a master serial interface. The configuration memory array can be visualized as a rectangular array of bits. The bits are grouped into frames that are one-bit wide words that extend from the top of the array to the bottom. The configuration data values are loaded into the configuration memory array one frame at a time from the external memory via the configuration interface .",{"@attributes":{"id":"p-0006","num":"0005"},"figref":["FIGS. 2-1","FIGS. 2-1","FIGS. 2-1","FIG. 1. A"],"b":["2","2","100","101","106","108","104","102","2","2","2","2","122","100"]},"The processor block is either a hard-core processor, e.g., processor block  of  and processor  of , such as the PowerPC\u00ae of IBM Corp. of Armonk, N.Y., or a soft core processor having CLBs, e.g., processor block  of , such as the MicroBlaze\u2122 processor core of Xilinx Inc. of San Jose, Calif.","In order to provide self-reconfiguration for the FPGA, the internal configuration access port (ICAP)  was added. The ICAP  gives access by the FPGA's internal logic (e.g., CLB's A and BRAMs A) to the configuration memory array  (and ). In other words, one part of the configured FPGA can reconfigure another part of the FPGA. Conventionally, this self-reconfiguration was done by loading pre-generated reconfiguration frames in the BRAM, and using customized logic, over-writing pre-targeted frames in the configuration memory array with these pre-generated reconfiguration frames.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3","b":["120","210","218","212","120","214","216","220","120"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4","b":["310","210","120","3","310","312","316","318","320","314","314","316","112","100","112","318"]},"There are several disadvantages with using the above custom logic self-reconfiguration approach. First, for example, the approach lacks flexibility, as what is to be reconfigured must be predetermined, i.e., the frames pre-generated and the custom logic set. Second, any changes to the reconfiguration take a significant amount of time, as the modified reconfiguration must be pre-loaded. Third, pre-loading entire frames, when only parts of the frames need to be reconfigured is inefficient. And fourth, more complex dynamic reconfiguration scenarios, such as modifying selected resources, generating parameterized circuits on the fly, relocating partial bitstreams to other locations on the array are very difficult to implement in custom logic.","Accordingly, it would be desirable to have an improved scheme for implementing the self-reconfiguration of an FPGA, which overcomes the above-described deficiencies.","The present invention relates to the self-reconfiguration of an IC, having a plurality of programmable modules, using on-chip processing to perform a read-modify-write of the configuration information stored in the configuration memory array.","Accordingly, an exemplary embodiment of the present invention provides a method of partially reconfiguring an IC having programmable modules, that includes the steps of (1) loading a base set of configuration information into a configuration memory array for the programmable modules, thereby configuring the IC; (2) reading a frame of configuration information from the configuration memory array; (3) modifying at least part of the configuration information, thereby creating a modified frame of configuration information; and (4) overwriting the existing frame of configuration information in the configuration memory array with the modified frame, thereby partially reconfiguring the IC. The steps of reading, modifying and writing are performed under the control of a processor located on the IC.","An embodiment of the present invention includes a method for reconfiguring an integrated circuit, having a plurality of programmable logic modules, a processor, a memory array having configuration information for the plurality of programmable logic modules, and a memory module. The method includes the steps of: first, reading a section of the configuration information from the memory array. Next, the section is stored in the memory module. The processor then modifies at least some of the section. And lastly, the modified section of the configuration information is written back to the memory array.","Another embodiment of the present invention includes a method for reconfiguring a programmable logic device, where the programmable logic device has a plurality of programmable components, a configuration memory array, a processor, and a plurality of block memory modules. The method includes the steps of: first, reading configuration data for a programmable component from the configuration memory array. Next, the configuration data is stored in a block memory. The processor then partially modifies the stored configuration data. And lastly, and the partially modified configuration data is written back to the configuration memory array.","A further embodiment of the present invention includes an integrated circuit having programmable logic components. The IC further includes: a first memory storing configuration information for the programmable logic components; an access port having access to the first memory; a processor connected by a first bus to a second memory; and a control module connected to the access port and the first bus, where the control module receives control information from the processor via the first bus, and the control information configures the control module to transfer part of the configuration information to the second memory from the first memory via the access port.","Another embodiment of the present invention includes a programmable logic device having: a processor, a memory, a configuration memory array for configuring the programmable logic device, an access port having access to the configuration memory array, and a control module for controlling the access port. The control module includes: an address module configured to determine one or more addresses in the memory for storing data from the configuration memory array, where the address module receives a start address from the processor; and a status register connected to the processor and having a flag indicating to the processor an end of a transfer cycle.","An aspect of the present invention includes a graphical user interface (GUI) for reconfiguring bits of a configuration memory array of a programmable logic device. The GUI includes: a window displaying at least part of the configuration memory array; a first region in the window having a first set of bits of the configuration memory array; a memory configured to store a copy of the first set, when a user selects a control to copy the first region; and a second region in the window having a second set of bits of the configuration memory array, said second set over-written by the copy of the first set in response to a command by the user.","Another aspect of the present invention includes an application programming interface having computer routines stored in a computer readable medium for controlling transfer of a frame between a configuration memory array and a random access memory (RAM) of a programmable logic device, where the computer routines are executed by an processor of the programmable logic device. The computer routines include: a first routine for reading the frame from the configuration memory array to the RAM; and a second routine for writing the frame from the RAM to the configuration memory array.","Yet another aspect of the present invention includes an integrated circuit having programmable logic components. The IC further includes: a configuration memory array for storing configuration information for the programmable logic components; an access port having access to the configuration memory array; a first processor connected by a first bus to a memory; a second processor connected by the first bus to the memory; a semaphore module having a semaphore, wherein only one processor of the first or second processor is granted the semaphore until a predetermined event occurs; and a control module connected to the access port and the first bus, where the control module receives control information from the one processor granted the semaphore, and where the control information configures the control module to transfer part of the configuration information to the memory from the configuration memory array via the access port.","The present invention will be more full understood in view of the following description and drawings.","In the following description, numerous specific details are set forth to provide a more thorough description of the specific embodiments of the invention. It should be apparent, however, to one skilled in the art, that the invention may be practiced without all the specific details given below. In other instances, well known features have not been described in detail so as not to obscure the invention.","In accordance with the described embodiments of the present invention, an IC having programmable modules and one or more on-chip processors is configured to implement an efficient partial reconfiguration scheme. The reconfiguration is performed on one or more frames of the configuration memory array, which includes configuration information or data for the programmable modules, e.g., the CLBs, BRAMs, IOs and MGTs. The term \u201cframe\u201d used herein is any set of one or more bits of configuration information and is not limited to a one-bit vertical column.","Some of the modules used in some embodiments of the present invention are similar to or the same as the modules given in , -, -, and  and are given the same labels in order to not obscure the invention.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 5","b":["110","332","108","330","120","112","110","332","108","110","330","330","120","3"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 6","b":["340","325","120","110","325","334","110","106","325"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 7","FIG. 9","FIG. 11","FIG. 16","FIG. 7","FIG. 7"],"b":["110","338","350","334","338","108","350","120","120","112","350","352","380","382","350","336","338","334","110","338","333","110","350","335","110","338","110","350","333","335","334"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 8","FIG. 8","FIG. 7","FIG. 7","FIG. 7"],"b":["352","350","110","338","333","110","350","335","7"]},"ICAP control module  includes a direct memory access (DMA) engine  and a device control register (DCR) . These elements - are formed by CLBs, which are configured in response to the base set of configuration data values. As described in more detail below, commands are issued to DMA engine  through device control register .","The ICAP control module  is connected to ICAP . Configuration logic  is coupled between ICAP  and the configuration memory cells, e.g., MGT B, CLB B, BRAM B, and I\/O B, of the configuration memory array. The ports () of ICAP  are accessible to the user logic of FPGA  via the general interconnection grid.","A data side on-chip memory (DSOCM) , which is formed by one or more BRAMs A, is an example of the BRAM  in FIG. . The DSOCM  has a direct connection to the ICAP control  (ICAP control  in ) via bus  and is also connected to processor block  via bus . DSOCM  stores, for example, program data, configuration frame data, and bit stream commands for read and write operations.","An instruction side on-chip memory (ISOCM)  (not shown in ) is also formed by one or more BRAMs A and is connected to processor block  via bus . ISOCM  stores, for example, instruction code necessary to operate processor block . In an alternative embodiment ISCOM  is merged into DSCOM , so that there is only a DSOCM having the contents of both the DSCOM  and ISCOM .",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 9","b":["204","204"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 10","FIG. 8"],"b":["90","361","204","110","204","362","204","110","363","371","377"]},"First, processor  modifies a read bitstream header in the DSOCM  to identify an address of a frame (e.g., Frame_) of the configuration memory array (Step ). Then, processor  sets the write enable entry (WR) of device control register  to a logic \u201c1\u201d value, clears the done flag (DONE) and the reconfiguration done flag (CONFIG_DONE) in device control register , and sets the start and end addresses (START_ADDR and END_ADDR) in device control register . The start address (START_ADDR) is set to identify the address in DSOCM  where the read-back bitstream header begins, and the end address (END_ADDR) is set to identify the address in DSOCM  where the read bitstream header ends. Upon detecting the logic \u201c1\u201d write enable entry (WR) in device control register , DMA engine  routes the read-back bitstream header stored in DSOCM  to ICAP  (Step ). DMA engine  then sets the DONE flag to a logic \u201c1\u201d state.","ICAP  initiates a configuration frame read operation in response to the received read bitstream header commands. As a result, a frame that includes the configuration data values is retrieved from the configuration memory array, and provided to ICAP .","In response to the logic \u201c1\u201d DONE flag, processor  resets the write enable entry (WR) to a logic low value, sets the read-back entry (RB) to a logic \u201c1\u201d value, resets the instruction done flag (DONE) to a logic \u201c0\u201d value, and sets the start and end addresses (START_ADDR and END_ADDR) in device control register . The start address and the end address (START_ADDR and END_ADDR) identify a block in DSOCM  where the retrieved frame is to be written. Upon detecting the logic \u201c1\u201d read-back entry (RB) in device control register , DMA engine  routes the retrieved frame from ICAP  to the location in DSOCM  defined by START_ADDR and END_ADDR (Step ). DMA engine  then sets the DONE flag to a logic \u201c1\u201d value.","Upon detecting the logic \u201c1\u201d DONE flag, processor  modifies select configuration bits stored DSOCM , by overwriting these configuration bits with new configuration bits. These new configuration bits are selected by processor  in response to the PORT_ID value retrieved from device control register  (Step ).","Processor  then resets the DONE flag to a logic \u201c0\u201d value, resets the read-back entry (RB) to a logic \u201c0\u201d value, and sets the write enable entry (WR) to a logic \u201c1\u201d value in device control register . Processor  also sets the start and end addresses (START_ADDR and END_ADDR) in device control register . The start address (START_ADDR) is set to identify the address DSOCM  where the write bitstream header begins, and the end address (END_ADDR) is set to identify the address DSOCM  where the write bitstream header ends. Upon detecting the logic \u201c1\u201d write enable entry (WR) in device control register , DMA engine  routes the write bitstream header stored in DSOCM  to ICAP , thereby initiating a write access to the configuration memory array (Step ). DMA engine  then sets the DONE flag to a logic \u201c1\u201d state.","Upon detecting the logic \u201c1\u201d DONE flag, processor  resets the DONE flag to a logic \u201c0\u201d state, sets the write enable signal (WR) to a logic \u201c1\u201d value, and sets the start and end addresses (START_ADDR and END_ADDR) in device control register . The start address (START_ADDR) is set to identify the address in DSOCM  where the modified frame begins, and the end address (END_ADDR) is set to identify the address in DSOCM  where the modified frame ends. Upon detecting the logic \u201c1\u201d write enable entry (WR) in DCR , DMA engine  routes the modified frame stored in DSOCM  to ICAP . In response ICAP  writes the modified frame of configuration data values back to the configuration memory array, such that this modified frame of configuration data values overwrites the previously retrieved frame of configuration data values (Step ). DMA engine  then sets the DONE flag to a logic \u201c1\u201d value.","Upon detecting the logic \u201c1\u201d DONE flag, processor  resets the DONE flag to a logic \u201c0\u201d state, sets the write enable signal (WR) to a logic \u201c1\u201d value, and sets the start and end addresses (START_ADDR and END_ADDR) in DCR . The start address (START_ADDR) is set to identify the address in DSOCM  where the write bitstream trailer begins, and the end address (END_ADDR) is set to identify the address in DSOCM  where the write bitstream trailer ends. Upon detecting the logic \u201c1\u201d write enable entry (WR) in DCR , DMA engine  transfers the write bitstream trailer stored in DSOCM  to ICAP , thereby instructing ICAP  to complete the write access to the configuration memory array (Step ). DMA engine  then sets the DONE flag to a logic \u201c1\u201d value, and processing returns to Step . Sub-steps - are then repeated until all of the one or more frames storing configuration data values that are to modified, have been read, modified and written in the foregoing manner. At step  processor  sets the reconfiguration done flag (CONFIG_DONE) in device control register  to a logic \u201c1\u201d value, thereby indicating that the one or more frames have been properly reconfigured. FPGA  then begins normal operation (Step ).",{"@attributes":{"id":"p-0064","num":"0063"},"figref":["FIG. 11","FIG. 7"],"b":["380","350","7","336","432","432","380","432","432","210","218","442","432","432","380","412","420","410","410","110","410","534","14","120","120","410","411","212","120","3","412","414","526","220","110","110","412"]},"The address control module  includes a BRAM offset register , a cycle size register , a comparator , a cycle counter , and an adder . The address control module  generates the memory addresses (BRAM Address ) for the BRAM data  that is being read from and written to by the ICAP . The memory addresses are sent to BRAM  via a bus . The generation is done by adding via adder , the starting or base address given in the BRAM offset register  to the current integer count (i.e., index for the array) of the cycle counter . The cycle counter  counts up to the value given in the cycle size register  which has the number of (bytes\u20141) to be read\/write per cycle. The comparator  compares the current cycle_count  from the cycle counter  to the cycle_size  from the cycle size register . Both the BRAM offset register  and the cycle_size register  can be written to and read from the processor block  via bus .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":["FIG. 12","FIG. 13","FIG. 14"],"b":["426","426","518","518","514","426","512","526","425","220","120","512","532","220","120","426","380","532","120"]},{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 13","FIG. 12"],"b":["425","520","424","1","518","426","2","425","526"]},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 14","b":["380","530","426","532","120","338","420","520"]},"The FSM begins in the IDLE state  and changes to the CYCLE state  when there is a start_transfer signal  which is asserted when there is a write to the read\/write register  by the processor block . When the (cycle_done AND not Busy) signal  is asserted, i.e., the transfer of data is complete, the FSM goes back to the IDLE state  from the CYCLE state .",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 15","b":["380","338","120","550","110","422","388","112","552","380","338","120","410","554","110","110","410","380","218","442","432","110","442","556","558","110","420","380","338","112","120","110","410","380","120","560","380","442","210","432","562"]},"In  the arrangement of the BRAM  was that there was a first area in BRAM  where the ICAP read instructions were stored followed by a reserved space where the one or more frames read from the configuration memory array were to be stored. There was a second area for the ICAP write instructions followed by the modified one or more frames to be written back to the configuration memory array. In addition there was a third area in BRAM  storing the computer program that the processor block  executes. The foregoing BRAM memory arrangements were for illustration purposes only, and one of ordinary skill in the arts will recognize that many different storage locations and arrangements are possible.","As an example implementation for ICAP Control  assume that BRAM  looks to system bus  (and the processor block ) as a 512\u00d732 bit RAM and to the ICAP Control  via buses , A and B, as a 2048\u00d78 bit memory. In other words the BRAM  is a dual port RAM. Let all data transfers be 32 bits (words). The BRAM offset register  and cycle size register  are assumed to be 11 bits wide.","In this example there are nine driver routines which are used by the processor block  to read and write both control information and data to and from the ICAP Control  and the BRAM . The nine driver routines are as follows:","1. void storageBufferWrite(unsigned int addr, unsigned int data), which writes a 32 bit data value from a register in the processor block  to a particular address in the BRAM via system bus . The address addr refers to a word address (4 consecutive bytes).","2. unsigned int storageBufferRead(unsigned int addr), which reads a 32 bit data value from a particular address in BRAM  to a register in the processor block  via system bus .","3. void setCycleSizeReg(unsigned int size), which sets the value of the cycle size register , as the total number of the bytes to be transferred from the BRAM  to the ICAP  (or ICAP  to the BRAM ) in one cycle. The number is an 11 bit count of bytes (not words) as the BRAM  looks to the ICAP control  via bus  () as a 2048\u00d78 bit memory.","4. unsigned int getStorageBufferSizeReg( ), which gets the value currently stored in the cycle size register , as an 11 bit count of bytes.","5. extern void setOffsetReg(unsigned int offset), which sets the value of the BRAM offset register  to the start address (or offset from the base address) of the data to be transferred between the BRAM  and the ICAP .","6. extern unsigned int getOffsetReg( ), which gets the value currently stored in the offset register .","unsigned int setBaseAddr(unsigned int newBaseAddr), which optionally sets the base address of the BRAM.","7. extern unsigned int getStatusReg( ), gets the current status of the data transfer between BRAM and ICAP, i.e., contents of the status register . In an alternative embodiment, reading the status register  does not clear the register. Rather, it is polled until cycle_done and not busy is asserted, and then after the result is ignored until a new transfer is started.","9. extern void setDirectionReg(unsigned int wrb); sets the direction of the transfer between the BRAM and ICAP, and also initiates the transfer.","The above device drivers can be used to create a routine to read from the device (ICAP ) to BRAM  and to write to the device (ICAP ) from BRAM .",{"@attributes":{"id":"p-0084","num":"0083"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Reading From The Device:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"int deviceRead(int offset, int numBytes) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/* Make sure we aren't trying to read more than we have"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"room for. *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (numBytes > MAX_BUFFER_BYTES) return"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BUFFER_OVERFLOW_ERROR;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"setOffsetReg(offset);"]},{"entry":[{},"setCycleSizeReg(numBytes);"]},{"entry":[{},"setDirectionReg(DEVICE_READ);"]},{"entry":[{},"\/* Wait for completion of operation. *\/"]},{"entry":[{},"while (getStatusReg( ) != cycle_done and not busy);"]},{"entry":[{},"return 0;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"};"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Writing To The Device:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"int deviceWrite(int offset, int numBytes) {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/* Make sure we aren't trying to read more than we have"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"room for. *\/"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (numBytes > MAX_BUFFER_BYTES) return"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"BUFFER_OVERFLOW_ERROR;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"setOffsetReg(offset);"]},{"entry":[{},"setCycleSizeReg(numBytes);"]},{"entry":[{},"setDirectionReg(DEVICE_WRITE);"]},{"entry":[{},"\/* Wait for completion of operation. *\/"]},{"entry":[{},"while (getStatusReg( ) != cycle_done and not busy);"]},{"entry":[{},"return 0;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The processor block  in interfacing with the ICAP control module  and BRAM  via system bus  as configuration data is read from the ICAP  to BRAM , modified by processor block , and written from BRAM  to ICAP , executes some of the above functions. In the case of , in steps  and  deviceWrite( ) causes the ICAP read instructions to be written from BRAM  to the configuration logic  (see FIG. ). In step  the processor executes a deviceRead( ) which causes, for example, a frame of configuration memory array information to be transferred from the configuration logic  to BRAM  via ICAP , ICAP control , and bus . At step  the processor block  retrieves a selected word from the frame from BRAM using a storageBufferRead( ), modifies the word and writes it back to the BRAM  when a storageBufferWrite( ) is executed. The processor repeats the above process in order to modify some or all the words in the frame. At steps , , and  a deviceWrite( ) transfers the ICAP write instructions followed by the modified frame data from BRAM  to the configuration logic  via bus .",{"@attributes":{"id":"p-0086","num":"0085"},"figref":["FIG. 16","FIG. 7","FIG. 3"],"b":["382","350","7","336","632","632","16","330","432","432","210","338","632","614","218","338","632","382","610","612","616","614","110","310","612","110","338","120","610","110","612","618"]},"The address control module  includes a BRAM address register , a cycle size register , a cycle counter , and an adder . The address control module  generates the memory addresses (BRAM Address ) for the BRAM data  that is being read from and written to by the ICAP . The memory addresses are sent to BRAM  via a bus . The generation is done by adding via adder , the starting or base address given in the BRAM address register  to the current integer count (i.e., index for the array) of the cycle counter . The cycle counter  counts up to the value given in the cycle size register  which has the number of (bytes\u20141) to be read\/write per cycle. The cycle size register  gets the total count from the word count  in ICAP data packet  () stored in packet register .","An example of the steps to performing a read\/write operation is as follows:\n\n",{"@attributes":{"id":"p-0089","num":"0095"},"figref":["FIG. 17","FIG. 17","FIGS. 6"],"b":["110","8","11","16","712","114","722","730"]},{"@attributes":{"id":"p-0090","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Routines","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"storageBufferWrite( )","Writes data to the BRAM 338"]},{"entry":[{},"storageBufferRead( )","Reads data from BRAM 338"]},{"entry":[{},"deviceWrite( )","Writes specified number of"]},{"entry":[{},{},"bytes from BRAM 338 to ICAP"]},{"entry":[{},{},"120"]},{"entry":[{},"deviceRead( )","Reads specified number of"]},{"entry":[{},{},"bytes from ICAP 120 to BRAM"]},{"entry":[{},{},"338"]},{"entry":[{},"deviceAbort( )","Aborts the current operation"]},{"entry":[{},"deviceReadFrame( )","Reads one frame from ICAP 120"]},{"entry":[{},{},"into the BRAM 338"]},{"entry":[{},"deviceReadFrames( )","Reads multiple frames from"]},{"entry":[{},{},"ICAP 120 into the BRAM 338"]},{"entry":[{},"deviceWriteFrame( )","Writes one frame to ICAP 120"]},{"entry":[{},{},"from the BRAM 338"]},{"entry":[{},"deviceWriteFrames( )","Writes multiple frames to"]},{"entry":[{},{},"ICAP 120 from the BRAM 338"]},{"entry":[{},"setConfiguration( )","Loads a configuration from a"]},{"entry":[{},{},"specified memory location"]},{"entry":[{},"getConfiguration( )","Writes current configuration"]},{"entry":[{},{},"to a specified memory"]},{"entry":[{},{},"location"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The routines in API  are also layered and the layers for Table 1 are given in Table 2 below. The layered approach allows the replacement of lower layers with faster hardware implementations without making changes to the higher layers.",{"@attributes":{"id":"p-0092","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Layers","Routines in Layer"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Layer 0","storageBufferWrite( ), storageBufferRead( ),"]},{"entry":[{},{},"deviceWrite( ), deviceRead( ), deviceAbort( )"]},{"entry":[{},"Layer 1","deviceReadFrame( ), deviceWriteFrame( )"]},{"entry":[{},"Layer 2","deviceReadFrames( ), deviceWriteFrames( )"]},{"entry":[{},"Layer 3","setConfiguration( ), getConfiguration( )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"A toolkit  providing routines to the application  for dynamic resource modification, i.e., resource modification on the fly, including relocatable modules. Like the routines in Table 2 above, these routine may be readily incorporated by a user in application programs written in high level languages such as C, C++, C#, VB\/VBA, and the like. Examples of such level 3 routines are given in Table 3 below.",{"@attributes":{"id":"p-0094","num":"0100"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Routines","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["setLUT( )","Sets the value of a LUT on the FPGA"]},{"entry":["getLUT( )","Gets the value of a LUT on the FPGA"]},{"entry":["getFF( )","Gets the value of a FF on the FPGA"]},{"entry":["setCLBBits( )","Sets the value of a selected CLB resource on"]},{"entry":[{},"the FPGA"]},{"entry":["getCLBBits( )","Gets the value of a selected CLB resource on"]},{"entry":[{},"the FPGA"]},{"entry":["setModule( )","Place the module at a particular location on"]},{"entry":[{},"the FPGA"]},{"entry":["copyModule( )","Given a bounding box copy the module is copied"]},{"entry":[{},"to a new location on the FPGA"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{}},"The setLUT( ) command, for example, includes the following steps:\n\n","The toolkit  provides two functions for dealing with relocatable modules:\n\n","The setModule( ) function moves the bits in a region of the configuration memory array from one location to another. The setModule( ) works on a partial bitstream that contains information about all of the rows in the included frames. It works by modifying the register address  () located in the command portion  of the configuration data packet .",{"@attributes":{"id":"p-0098","num":"0111"},"figref":["FIG. 18","FIGS. 2-1"],"b":["812","1","812","2","2","2","812","1","1","814","812","2","1","816"]},"The copyModule( ) function copies any sized rectangular region of the configuration memory array and writes it to another location. The copied region contains just a subset of the rows in a frame. This allows the creation of dynamic regions that have static regions above and\/or below it. The copyModule( ) function employs a read\/modify\/write strategy like the resource modification functions. This technique works well for changing select bits in a frame and leaving the others bits in their current configured state.",{"@attributes":{"id":"p-0100","num":"0113"},"figref":["FIG. 19","FIGS. 2-1"],"b":["820","1","820","2","2","2","820","1","1","830","2","832","1","840","2","842","820","1","1","844","1","834"]},"Other functions include setting and retrieving the particular configuration memory array bits for a selected resource such as a CLB, e.g.:\n\n","The setCLBBits( ) is a more generalized function than the setLUT( ) function. The setCLBBits( ) can be used to set the value of a LUT instead of setLUT( ). However, in one embodiment the setCLBBits( ) is not as efficient as setLUT( ). This is because setLUT( ) knows that all the bits that control the LUT are located in one frame, so that setLUT( ) can read one frame, modify the M bits (where M is a predetermined integer value), and then writes back the modified frame. On the other hand setCLBBits( ) does a read\/modify\/write M times, as there is no assumed predetermined location for the frame each bit is in.","The above API and toolkit functions allow for use of high level programming constructs and even a graphical user interface (GUI) for the full or partial reconfiguration of an IC, comprising a plurality of programmable logic modules, such as an FPGA. For example, in  a copy and paste in a PC window could copy the region - to region -. A GUI such as in Microsoft\u00ae Visio\u00ae would permit a user-friendly graphical means to relocate regions in an FPGA.","When there is an processor such as a soft core Microblaze\u2122 processor or a hard core PowerPc\u00ae processor, then the interface to the configuration memory array is via the ICAP control module and the ICAP . If there is an external processor then access to the configuration memory array is via the configuration interface , such as the select map interface. The layered architecture of , allows the API  and toolkit  to be hardware independent. In addition the Application layer  is written in a high level language such as C or C++.","In an IC having programmable logic modules, there may be more than one processor. , -, and - only show one processor in order not to obscure the invention. However, for example, the Virtex II Pro\u2122 of Xilinx Inc. of San Jose, Calif. has upto four PowerPC\u00aes. Hence embodiments of the present invention are not limited to one processor, but include one or more processors.","In the case of multi-processors that access a shared resource on the IC, an arbitration mechanism, such as a semaphore, is needed to control access to the shared resource, so that only one processor accesses the shared resource at a time. In the specific case of the ICAP  of which there is only one, the ICAP  is a shared resource to the multiple processors. In one embodiment of the present invention a semaphore is used to control access to the ICAP.",{"@attributes":{"id":"p-0107","num":"0122"},"figref":["FIG. 20","FIG. 20","FIG. 20"],"b":["7","910","110","334","338","920","350","338","350","350","110","920","110","110","110","350","110","930","920","110","930","350","930","930","110","920","110","350"]},{"@attributes":{"id":"p-0108","num":"0123"},"figref":"FIG. 21","b":["338","350","110","1","940","920","942","2","110","944","350","946","948","350","110","950","920","2","910","952","920","350","110","952","910","954","910","920","956","958","950","3","910","960","962","920","338","350"]},"Although the above functionality has generally been described in terms of specific hardware and software, it would be recognized that the invention has a much broader range of applicability. For example, the software functionality can be further combined or even separated. Similarly, the hardware functionality can be further combined, or even separated. The software functionality can be implemented in terms of hardware or a combination of hardware and software. Similarly, the hardware functionality can be implemented in software or a combination of hardware and software.","Although the invention has been described in connection with several embodiments, it is understood that this invention is not limited to the embodiments disclosed, but is capable of various modifications, which would be apparent to one of ordinary skill in the art. For example, although only one processor is shown on FPGA , it is understood that more than one processor may be present in other embodiments. Thus, the invention is limited only by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 2-1","b":["2","2"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 3","b":"120"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 9","FIG. 8"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 10","FIG. 8"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 21"}]},"DETDESC":[{},{}]}
