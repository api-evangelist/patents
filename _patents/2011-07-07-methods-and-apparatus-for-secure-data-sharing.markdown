---
title: Methods and apparatus for secure data sharing
abstract: This disclosure relates to methods and apparatus for securely and easily sharing data over a communications network. As communications services on a communications network are continuously becoming cheaper, faster, and easier to use, more users are becoming receptive to the idea of sharing data over the communications network. However, although E-mails and web folders, to a certain degree, provide easy-to-use or secure data sharing mechanisms, none of the existing data sharing methods is both easy-to-use and highly secure. This disclosure provides methods and apparatus for easily and securely sharing data over a communications network.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08732462&OS=08732462&RS=08732462
owner: ZIPTR, Inc.
number: 08732462
owner_city: Burlington
owner_country: US
publication_date: 20110707
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE DISCLOSURE","BACKGROUND","SUMMARY OF THE INVENTION","DESCRIPTION OF EXAMPLE EMBODIMENTS"],"p":["This disclosure relates generally to a system and method for providing secure communication between two or more clients using a server.","Communications services on communication networks are continuously becoming cheaper, faster, and easier to use, and are enabling myriads of new, important applications. Data sharing is one of them. As the performance of communication networks improves, more users, both individuals and institutions, resort to communication networks to share data with others. Over communication networks, users can now share multi-gigabyte videos in a matter of minutes; users can exchange real-time messages from all around the world using an instant messenger program; and users can share documents with others almost instantaneously. Communication networks have shaped and modified the way users communicate with others.","As users became accustomed to using communication services over a communication network, users have become more receptive to sharing confidential and private data over public networks as well. One popular communication medium for this purpose is E-mail. E-mails can carry confidential messages and important documents almost instantaneously, and can reduce the burden of printing hard copies and sending them via expensive and slow mail services. Unfortunately, although the E-mail system provides an easy way to share information, the E-mail system fails to provide the level of security desired in many scenarios. For example, financial professionals need to share confidential client information securely; lawyers need to send confidential legal documents to clients; human resources personnel need to share private employee data upon request; and medical professionals need to discuss patient health information with other medical professionals, potentially located off-site. Such confidential information should not be revealed to anyone else but the desired recipient, and the E-mail system as it currently stands does not guarantee that. In fact, an E-mail can be eavesdropped during transfer over public communication networks, and once the E-mail is eavesdropped, the content of the E-mail can be readily viewed by the intruder. Furthermore, anything that is stored on the E-mail server can also be readily accessed by the E-mail service provider. E-mail is not a secure medium for sharing confidential information.","Another popular mechanism for data sharing is a web folder. Some web services provide users with password-protected folders accessible via the web. Using this service, users can store data in a password-protected folder and send the password for the folder to targeted recipients, often using a separate communication medium such as E-mail. The password recipient can, in turn, access the folder using the received password and retrieve the stored data. These web folders can store large files, so they are especially useful for sharing large amounts of information. However, the web folder services are often not user-friendly and are not scalable when many users want to share multiple files. Every time a user wants to share information with another user, the user has to (1) make a password-protected folder for the recipient, (2) store the information in the folder, and (3) send the password for the folder over a communication medium to the recipient. Although this work flow can be manageable for sharing information with a small number of people, this work flow can quickly grow out of hand if a user wants to share information with a large number of people. Web folder services are also not secure enough for many applications. If a third party eavesdrops on the password, then the third party can easily access the information stored in the folder. Furthermore, anything stored in the service provider's server can be readily accessed by the service provider. Therefore, a web folder service is also not suitable for sharing confidential information in a scalable manner.","Certain embodiments disclose a host server that provides data sharing services. The host server is configured to receive, from a first client, a communication request that includes an encrypted conversation, a first key, and authentication bits. The communication request requests that the host server sends the encrypted conversation and a decryption key for the encrypted conversation to a second client, where the first key is the decryption key that has been encrypted using a first public key associated with a first user at the first client. In order to retrieve the decryption key from the first key, the host server retrieves an encrypted secret key associated with the first user and decrypts the encrypted secret key using the authentication bits included in the communication request received from the first user, thereby retrieving a secret key associated with the first user. Then, the host server retrieves an encrypted private key associated with the first user and decrypts the encrypted private key using the secret key associated with the first user, thereby retrieving a private key associated with the first user. Subsequently, the host server decrypts the first key using the private key associated with the first user, thereby retrieving the decryption key. Once the decryption key is retrieved, the host server encrypts the decryption key using a second public key associated with a second user at the second client to generate a second key, and sends to the second client the encrypted conversation and the second key.","The system and method of the present invention address the security issues and scalability issues found in known systems. At a high level, the design philosophy for this data sharing system is that (1) the system should be as easy to use as E-mail and (2) the system should be secure to the extent that in a rare event in which the data sharing system is breached by a third party, data stored on the system are not readily revealed to the third party. To this end, in a preferred embodiment of the present invention, the data sharing system employs a conversation model with added security features. Using this system, a user initiates a conversation with other users and shares documents with them by adding the documents to the conversation. Such a conversation model can allow for an easy, seamless sharing of messages and documents among all users participating in the conversation.","In a preferred embodiment of the present invention, the data sharing system performs tasks to enhance security of the conversation. These tasks are performed in the background and are completely transparent to users. For example, the data sharing system encrypts the conversation using an encryption key so that third parties that do not participate in the conversation cannot view the conversation. To read encrypted conversation, users participating in the conversation might need to decrypt the encrypted conversation using a decryption information. This decryption information is called a decryption key. The data sharing system shares the decryption key in the background in such a way that only the users participating in the conversation are capable of decrypting the encrypted conversation. To further improve the security, the data sharing system also encrypts the decryption key before sharing the decryption key with users in the conversation. This way, even if a third party eavesdrops on the decryption key, the third party cannot immediately gain access to the conversation.","The data sharing system maintains encrypted shared data and the encrypted decryption information in a server. For improved security, the server does not maintain the information to decrypt the encrypted decryption information, so even if the server is breached by a third party, the third party does not have the information to decrypt the encrypted decryption information. Therefore, even in a rare event a third party breaches the security protections of the server, the third party cannot decrypt the encrypted shared data in the server. In some embodiments, the data sharing system encrypts each conversation using a unique encryption key so that even if a third party identifies one of the decryption keys in the server, the third party cannot access all the shared data.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 1","FIG. 1","FIG. 1"],"b":["100","108","100","102","104","105","106","100","108","100","100","100","100","100","108","104","104","104"],"i":["a","d","a","d ","a","d ","a","d ","a","b","c","d"]},"The communication network  provides a communication channel  between the host server  and the clients . The communication network  includes the internet, a cellular network, a telephone network, a computer network, a packet switching network, a line switching network, and\/or any other networks that accommodate data communication between network nodes. The management server  oversees operations of the host server . The management server  provides information to decrypt and retrieve shared data maintained in the host server . This can be useful when, for instance, a user misplaces the password to access the data sharing system. The host server  and the clients  support the public key cryptography mechanism. Each client  maintains a unique X.509 public\/private key pair. The public key is used to transform (i.e., encrypt) data into an unreadable form, and the encrypted data can only be restored (i.e., decrypted) into a readable form using the paired private key. By publishing the public key to a general public, anyone can create data content that can only be read by the owner of the private key paired with the public key. In a preferred embodiment, the host server  also maintains client's private key, but in an encrypted form, so that when given a permission, the host server  can decrypt data content that had been encrypted with client's public key.","In a preferred embodiment, the client  includes a communication interface to communicate with the host server . The communication interface in the client  accommodates a secure communication channel  between the computing device  and the host server . In a preferred embodiment, the communication interface establishes a secure communication channel  using a transport layer security (TLS) cryptographic protocol. However, the communication interface can establish a secure communication channel  using other cryptographic protocols, including a secure shell (SSH), an IP security (IPSec), and a virtual private network (VPN). The client  can be implemented as (1) a program running on the computing device , (2) a web application that runs inside a web browser on the computer device , or (3) a mobile device application. The client  can also include a user interface supporting a conversation model.  illustrates the conversation model supported by the user interface in accordance with certain embodiments of the present invention. A group of users can participate in a conversation , which include a message , zero or more shared documents -, and a list of participants . The message  can include both text and image information. Participants share the conversation  via the host server . One of the participants initiates a conversation  by sending a conversation request to the host server . The conversation request includes the conversation  and other decryption information described in detail below. The host server  subsequently relays the received conversation  to other participants, essentially serving as an anchor node for the conversation .","The data sharing system of  can be vulnerable to security breaches at (1) the communication channel  between the host server  and the client  and (2) the host server  itself. The communication channel  is relatively secure from security breaches since the communication channel employs a cryptographic protocol for secure communication. Furthermore, the data communication is transient and does not leave traces of shared information. Therefore, if a third party does not eavesdrop on the conversation at the right time, the third party may never be able to access the sought information. However, the host server  can leave traces of shared conversation. In fact, the host server  maintains the shared conversation for future access. Although the host server  can employ firewalls to protect the shared conversation from third party security attacks, firewalls can be breached under certain circumstances. Therefore, the security problem can be more prominent and noticeable at the host server . To protect the shared information from third party attacks even when the host server  is breached, in a preferred embodiment, the client  encrypts the conversation  before sending the conversation  to the host server . This can effectively bar the host server , as well as any potential security breakers, from accessing the shared conversation. The client  also encrypts the decryption key for the encrypted conversation before sending the decryption key to the host server  to ensure that the host server  cannot decrypt the shared information. This way, even if the third party accesses all the information stored in the host server , the third party cannot decrypt the encrypted conversation.","In a preferred embodiment, a host server  identifies a user with a unique username and the associated password. Therefore, a user logs onto the data sharing system by providing a username and a password. For authentication purposes, a host server  maintains usernames and associated passwords of all users in a database. When one of the users requests authentication by providing a username and a password, the host server  accesses the database to verify (1) if the username exists in the database, and if so, (2) if the provided password matches the password associated with the username. In a preferred embodiment, the host server  does not maintain passwords in its original form. Instead, the host server  maintains only an encrypted version of the passwords without any decryption information. The passwords can be encrypted using a cryptographic hash function, but they can also be encrypted using conventional symmetric\/asymmetric cryptographic methods.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3","b":["142","108","144","108","104","104","146","108","104","148","104","108","104"]},"In accordance with certain embodiments, once a user logs into the data sharing system, the user can initiate a conversation. As is illustrated in , in a preferred embodiment, the conversation includes fields such as a message, shared documents, and the list of conversation participants. A user initiates the conversation by completing these fields in the conversation and by sending a conversation request to the host server. The conversation request includes the conversation to be relayed to conversation participants. Upon receiving the conversation request, the host server  extracts the list of conversation participants and relays the conversation to those participants. The client for each participant receives the conversation and stores the conversation in a local storage device so that whenever a user wants to view the conversation, the client can rapidly retrieve the conversation from the local storage device and provide the conversation to the user. In a preferred embodiment, the client stores an encrypted version of the conversation so that the conversation can only be accessed and decrypted by logging into the client. If the client had generated the conversation, the client encrypts the conversation itself before storing the conversation; if the client had received the conversation from the host server , then the client does not have to encrypt the conversation itself since the received conversation is already encrypted.","In a preferred embodiment, the host server  also maintains the conversation in its storage device so that if another user joins the conversation at a later time, the host server  will relay the stored conversation to the added user. Because the host server  maintains the conversation, the conversation can be vulnerable to third party security attacks. Therefore, in a preferred embodiment, the client initiating the conversation, named client A, encrypts the conversation before sending the conversation request to the host server.  illustrates, in accordance with a preferred embodiment, how client A encrypts the conversation before sending a conversation request to the host server . In step , client A receives a conversation that includes a message and shared documents. In step , client A encrypts the message and the shared documents in the conversation using a cryptography method. As mentioned earlier, the cryptography method uses an encryption key X to encrypt the data and uses a decryption key Y to decrypt the encrypted data. Since the conversation participants receive an encrypted conversation, the conversation participants need to receive the decryption key Y from the client A in order to read the encrypted conversation. Therefore, the client A sends the decryption key Y, as well as the encrypted conversation, to the host server  so that the host server  will relay both the encrypted conversation and the decryption key Y to the conversation participants. In preferred embodiment, each message\/document is encrypted using a unique encryption key X, each associated with a unique decryption key Y. Before client A sends the decryption key Y to the host server, client A encrypts the decryption key Y using client A's public key, as shown in step . This can ensure that even if a third party eavesdrops on the decryption key Y, the third party cannot recover the un-encrypted version of the decryption key Y. In step , the client A sends a conversation request to the host server . In a preferred embodiment, the conversation request includes at least (1) the encrypted conversation, (2) the encrypted decryption key Y, and (3) the authentication bits. As is detailed below, the authentication bits can provide a permission to the host server  to decrypt the encrypted decryption key Y. The authentication bits include a password encrypted using a salt value. As is mentioned earlier, the salt value is fixed for a particular use. In other words, the salt value for the decryption purpose can be different from the salt value for the authentication purpose, described in relation to .","In accordance with certain embodiments, upon receiving the conversation request from client A, the host server  relays the encrypted conversation and the encrypted decryption key Y to other conversation participants. Before relaying the encrypted decryption key Y, the host server processes the encrypted decryption key Y so that the encrypted decryption key Y is in a form that other conversation participants can decrypt. In a preferred embodiment, the host server (1) decrypts the encrypted decryption key Y using client A's private key, (2) re-encrypts the decryption key Y for each conversation participant using the participant's public key, and (3) sends the re-encrypted decryption key Y, which is distinct for each participant, to the participants. This process assumes that client A's private key is available at the host server.","In a preferred embodiment, the host server maintains the private key of each user. Each private key in the host server is encrypted using a secret key, which is unique to the user. The secret key is selected such that the same secret key can encrypt the private key and decrypt the encrypted private key. In a preferred embodiment, the secret key is a 256-bit Advanced Encryption Standard (AES) key. The secret key is maintained by the host server in an encrypted form, and the decryption key for the encrypted secret key is the authentication bits provided by the client in the conversation request. Therefore, once the client provides the authentication bits to the host server, the host server uses the authentication bits to decrypt the secret key and uses the decrypted secret key to decrypt the client's private key.","The host server then uses the decrypted private key to decrypt the encrypted decryption key Y. This decryption chain shows that the client grants a permission to decrypt the encrypted decryption key Y by providing the authentication bits. Once the host server has the decryption key Y, the host server re-encrypts the decryption key Y and sends the encrypted conversation and the re-encrypted decryption key to other conversation participants. Upon receiving the encrypted conversation and the re-encrypted decryption key, the conversation participants use their own private keys to decrypt the re-encrypted decryption keys Y and use the decrypted decryption key Y to decrypt the encrypted conversation.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5","b":["180","182","184","104","104"]},"In step , the host server  uses the decrypted private key to decrypt the encrypted decryption key Y. In the following steps, the host server  re-encrypts the decryption key Y in such a way that the conversation participants can decrypt the re-encrypted decryption key Y. In step , the host server  encrypts the decryption key Y using each of the other participant's public key, generating N\u22121 encrypted decryption keys. N represents the total number of conversation participants. Once the host server  re-encrypts the decryption key Y, the host server  erases the decryption key Y. In step , the host server sends the encrypted conversation and the re-encrypted decryption key to conversation participants. In step , the host server stores the encrypted conversation and the encrypted decryption key Y in a database. The step  is independent of the decryption key transformation steps (steps -); the step  can be performed before or after each of the decryption key transformation steps.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 5","FIG. 5","FIG. 8","FIG. 5","FIG. 5"],"b":["104","192","104","104","104"]},"In a preferred embodiment, the secret key is unique to each user. In this embodiment, there is no single key that would grant access to all the data stored on a host server. In order to access all the data stored on the host server, the third party will have to (1) access encrypted secret keys for all users, (2) decrypt each of the encrypted secret keys by trying out all possible password combinations, which is also called a brute-force attack, and (3) decrypt the encrypted data stored on the server. As mentioned above, secret keys are transparent to a third party. Therefore, accessing secret keys for all users is a challenging problem. Even if the third party does access all the secret keys, decrypting the encrypted secret keys using a brute-force attack is time-consuming, if at all possible. Therefore, it is unlikely that a third party can perform these steps to access all the data stored on the host server.","Once a conversation is established, any client participating in the conversation can add a message or a document to the conversation. In certain embodiments, a client encrypts the added information using steps illustrated in , and the host server  relays the encrypted information and the decryption key using steps illustrated in . In another embodiment, every client participating in the conversation maintains an encryption key X and its decryption key Y for the conversation. These clients receive the encryption key X and the decryption key Y when the client A initiates the conversation. For instance, the client A sends the encryption key X and the decryption key Y to the host server  in step  of  and the host server  relays the encryption key X and the decryption key Y to other conversation participants in step  of . In this embodiment, when a client wants to add information to the conversation, the client encrypts the information using the received encryption key X and send the encrypted information to the host server. Since every client in the conversation maintains the decryption key Y, the host server simply relays the encrypted information to the other participants without performing the decryption key transformation steps of .","If a client was disconnected from the network, or if a user is accessing a conversation from a different computing device, the conversation stored in the local computing device may not be up-to-date. In a preferred embodiment, the data sharing system accommodates a timestamp protocol to synchronize conversations stored in clients and the host server. In the timestamp protocol, a client and a host server  maintain a separate timestamp for each object type, which includes a message in a conversation, a document in a conversation, a conversation etc. The client and the host server  communicate to compare the timestamps and if the timestamps are different, the client or the host server  initiates the synchronization procedure to synchronize the data stored in the client and the host server.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 6","b":["104","200","108","104","108","104","104","108","108","108"]},"At some point, one of the conversation participants can add information to the conversation. In step , client A adds new information to the conversation and sends the added information to the host server . In step , the host server  stores the information received from client A , calculates a new timestamp for the conversation, and updates the timestamp on the host server  to the new timestamp.","Sometime later, each client  sends a timestamp request message. In step , each client  sends a timestamp request message to the host server  to request the maximum timestamp value for each object type in the shared conversation. As in step , the host server  sends a timestamp response message to the clients , the timestamp response message including the maximum timestamp value for each object type in the shared conversation. Then each client  compares the received maximum timestamp values to the stored maximum timestamp values. Since client A added new information to the conversation in step , the maximum timestamp value corresponding to the object type of the added information would not match. Therefore, each client  becomes aware that the object type with different timestamp values has been updated.","When the client  notices that the object type has been updated in the conversation, the client  sends a timestamp profile request to the host server  to request a description or summary of what has changed for that specific object type. The timestamp profile request includes the locally stored (i.e., stored at the client ) maximum timestamp value of the specified object type. The host server  replies to the timestamp profile request by sending a timestamp profile response to the client . The timestamp profile response indicates the changes made to the specified object type since the time indicated by the received timestamp (i.e., the maximum timestamp value of the specified object type that was stored at the client). The timestamp profile response can include the identification of the object type and state information that includes at least whether the object type has been deleted\/read\/updated. The client  analyzes the timestamp profile response and sends a data update request to the host server , the data update request requesting the host server  to send changes corresponding to the specified object type.","In certain embodiments, the timestamp profile request can trigger the host server  to send a summary of all the changes made to any of the conversations associated with the user at the client . In this case, the timestamp profile response includes a description or summary of all the conversations that have changed. The client  then analyzes the timestamp profile response and sends a data update request, associated with one of the changed conversations, to the host server . The client  can send the data update request until every conversation is synchronized with the host server .","In step , the client  receives, from the host server , (1) the difference between the information stored at the client  and the information stored at the host server  and (2) the new timestamp to be used for the updated object type.","In another embodiment, the timestamp request message and the timestamp profile request can be merged into a single message. In step , the clients  sends a timestamp check message to the host server  to ask for changes in timestamp values across all object types in the shared conversation. The timestamp check message performs the functionality of a timestamp request message and a timestamp profile request. The timestamp check message sent from the client  to the host server  includes timestamp values across all object types maintained at the client . If the timestamp values in the timestamp check message matches the timestamp values stored in the host server , then the host server  does not initiate any actions. However, if one of the timestamp values in the timestamp check message does not match the corresponding timestamp value stored in the host server , then the host server  initiates data transfer for the object type associated with the timestamp value. In step , the each client -receives, from the host server , (1) the difference between the information stored at the respective clients -and the information stored at the host server  and (2) the new timestamp to be used for the updated object type.","In yet another embodiment, the client , instead of the host server , can calculate the timestamp and send the new timestamp to the host server . In step , when client A adds new information to the conversation, client A can also update the timestamp locally to the time at which the client A received the new information. Then client A sends the updated timestamp, along with the added information, to the host server . In step , the host server  stores the information received from client A and updates the timestamp on the host server  to the new timestamp received from client A . In step , the clients -communicate with the host server  to ask for changes in timestamp values across all object types in the shared conversation, and client B and client C notice the timestamp discrepancies. In step , client B and client C receive, from the host server , (1) the difference between the information stored at the respective clients -and the information stored at the host server  and (2) the new timestamp to be used for the updated object type.","In another embodiment, all communication between the clients and the host server are timestamp-based. In this embodiment, the host server  can initiate a timestamp check to check whether one of its clients has updated the conversation or initiated a conversation. For example, instead of step  in , in which the client A sends a conversation request to the host server, the client A simply (1) prepares a conversation request, (2) places the conversation request in a communication queue between the client and the host server, and (3) updates the timestamp for the conversation request. Then the host server  can initiate a timestamp check with all clients associated with itself. When the host server  recognizes that client A has added a conversation request to the communication queue, the host server  can trigger the transfer of the conversation request.","In certain embodiments, client A encrypts a conversation using a symmetric encryption method. In some embodiments, the client A encrypt messages and documents in a conversation using two different encryption keys or using two different encryption methods. In other embodiments, the secret key is derived from an asymmetric encryption method. One skilled in the art can modify  to implement these distinct, yet closely related, embodiments.","In some cases, a user might misplace the user's password. If a user misplaces the password, the user cannot log onto the data sharing system nor provide authentication bits to retrieve and decrypt the encrypted data stored on the host server. Therefore, the loss of password might result in the loss of user data. To prevent the loss of user data in such events, a preferred embodiment of the data sharing system maintains an encrypted copy of the secret keys at the host server, as shown in . These copies are encrypted with a master public key, which is generated from a powerful encryption method, for instance using the RSA algorithm with a 2048-bit key. The encrypted copy of the secret keys are called the backup secret keys.","Although the backup secret keys are maintained at the host server, encrypted using a master public key, the host server does not have access to the master private key to decrypt the secret key. The master private key is only available at the maintenance server . Therefore, if the host server wants to decrypt the backup secret key to retrieve the secret key, the host server has to ask the maintenance server  to decrypt the backup secret key. This way, even if a third party attacks the host server  and accesses the backup secret key, the third party would not be able to decrypt the backup secret key within a reasonable amount of time.","When a user misplaces the user's password, the user can send a password reset notification to notify the data sharing system that the password is lost and to request that a new password is set for the account. In a preferred embodiment, the user sends the password reset notification to the data sharing system using a client of the data sharing system. To verify that the correct user is requesting the password changes, the data sharing system (e.g., the host server ) sends a verification request to the user using other communication media associated with the user. The communication media can include an E-mail, a Short Message Service (SMS), and a telephonic communication medium.","Upon verifying the identity of the requester, the host server  receives from the client a new password to be associated with the account. In a preferred embodiment, the host server  receives the new password in an encrypted form, in a manner similar to steps  and  of . The host server  can also receive from the client the authentication bits associated with the new password. The host server  subsequently sends a password reset request to the maintenance server . The password reset request includes (1) the username for the account, (2) the backup secret key associated with the account, (3) an access key of the host server, and (4) a response key, which is a AES 256 bit key, that the maintenance server  should use to encrypt the response to the password reset request. The access key of the host server is described in more depth with respect to . The password reset request can be encrypted with the master public key that was used to encrypt the backup secret key. This ensures that all the information in the password reset request is protected from a third party and can only be viewed by the maintenance server .","When the maintenance server  receives the password reset request, the maintenance server  first decrypts the password reset request using the master private key. Then the maintenance server  verifies the identity of the maintenance server  by verifying the access key. When the password reset request passes the verification check, the maintenance server  decrypts the backup secret key included in the password reset request using the master private key. The maintenance server  then sends the password reset response to the host server . The password reset response includes the backup secret key. The password reset response is encrypted using the response key, which was included in the password reset request. When the host server  receives the password reset response, it (1) decrypts the password reset response, (2) encrypts the secret key using the new authentication bits, and (3) stores the encrypted secret key in its database. This way, the host server  can use the updated secret key for future data access. This completes the password update.","In another embodiment, the data sharing system stores backup authentication bits  at a maintenance server , as shown in , as opposed to storing backup secret keys at the host server . The backup authentication bits are authentication bits derived from the old password that the user had misplaced. The backup authentication bits  in the maintenance server  are encrypted using the master public key. As with the preferred embodiment, when a user misplaces the user's password, the user can notify the data sharing system to change the password to the new password specified by the user.","Upon verifying the identity of the requester, as in the preferred embodiment, the host server  receives a new password for the account and sends a password reset request to the maintenance server . The password reset request includes (1) the username for the account, (2) the account's new authentication bits, derived from the new password, (3) the secret key encrypted with the old authentication bits (i.e., associated with the old password which is no-longer known), (4) the access key of the host server, and (5) the AES 256 bit key that the maintenance server  should use to encrypt the response to the password reset request. As with the preferred embodiment, the password reset request is encrypted with a master public key that only the maintenance server  can decrypt.","When the maintenance server  receives the password reset request, the maintenance server  first verifies the identity of the maintenance server  by verifying the access key. When the password reset request passes the verification check, the maintenance server  decrypts the encrypted, backup authentication bits using the master private key. Then, the maintenance server  decrypts the encrypted secret key received from the host server using the decrypted backup authentication bits. Subsequently, the maintenance server  re-encrypts the decrypted secret key using the new authentication bits received from the host server , and sends to the host server  a password reset response, which includes the re-encrypted secret key. As in the preferred embodiment, the password reset response is encrypted using the AES 256 bit key that was included in the password reset request. When the host server  receives the password reset response, it decrypts the password reset response and stores the encrypted secret key received from the maintenance server . This way, the host server  can use the updated secret key for future data access. In the meanwhile, the maintenance server  also updates the backup authentication bits for the account. The maintenance server  encrypts the new authentication bits using the master public key, and stores the encrypted authentication bits in its storage as a backup.","In some cases, a user can communicate with the host server  using multiple clients running on different computing devices. Also, multiple users can time-share a single client to access the data sharing system. In certain embodiments, when an existing user accesses a client for the first time, the client is registered with the host server . The registration serves two purposes: (1) guard against third party security breaches and (2) provide the client with the user's private key.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 8","b":["240","242"]},"In step , the client sends a registration request to the server. In a preferred embodiment, the registration request includes at least (1) the username, (2) the encrypted password, and (3) authentication bits. The password is encrypted using a method described in relation to .","In step , the host server  tries to authenticate the user and if the host server is able to authenticate the user based on the authentication information stored on its database, the host server sends an alert message to the user. The alert message can be in the form of a conversation in the data sharing system, an electronic mail, a short message service (SMS) message to the user's cell phone, or a phone call. The alert message notifies the user that the user accessed the data sharing system using a new client. If the user did not access the data sharing system using a new client, then the user knows that the user's account has been breached by a third party. In this case, the user can notify the system administrator to change the user's password or to disable the registered client from accessing the user's information. In some embodiments, the alert message is part of a verification message. The verification message includes a code that the user should provide to the data sharing system in order to proceed with the registration process. Such a verification step introduces a physical item to the client registration, which can further reduce security risks.","In step , the host server determines if the client is newly installed and is being used, by the user that is currently logged-in, for the first time. If so, the host server audits the client-related information and stores the client-related information in a database. The client-related information includes the client's IP address. Then the host server generates a client key. In a preferred embodiment, the client key is an 256-bit AES key. However, the client key can be any other types of encryption keys. In a preferred embodiment, the host server generates a unique client key for each unique user on each machine, encrypts the client key using the user's secret key, and maintains the encrypted client key in its database. Because the client key is unique for each user on each machine, a single machine can maintain multiple client keys, each corresponding to different users. In step , if the host server generated the client key, the host server sends the client key to the client. This way, the host server can use the client key to encrypt information sent to the client, especially when the host server does not have the user's public key.","In step , the client sends a key request to the host server in order to retrieve the account's X.509 public key\/encrypted private key. In step , the host server decrypts the user's private key using the user's authentication bits. This step includes (1) decrypting the user's secret key using the authentication bits and (2) decrypting the private key using the decrypted secret key. The details of this step are similar to relevant steps of . In step , the host server encrypts the user's private key using the client key, and in step , the host server sends the encrypted private key to the client over a secure communication channel. As a last step, the host server encrypts the client key using the user's secret key (retrieved in step ) and stores the encrypted client key in its database. This completes the client registration process. Although  illustrates the client key as a symmetric encryption key, one skilled in the art can modify the steps illustrated in  to accommodate a client key for an asymmetric encryption method.","Host Server Architecture","In certain embodiments, a host server  includes a plurality of server groups, each performing dedicated functions.  illustrates a host server architecture in accordance with certain embodiments of the present invention. A host server  includes a timestamp server group (T-S) , a user interface server group (UI-S) , an application programming interface server group (API-S) , and a document server group (DOC-S) , and each of these server groups communicates with a master database , a slave database , and a storage device . The host server  communicates with a management server  as well as other devices over a communication network . The host server  is decomposed into distinct server groups based on the type of data handled by the groups. In one embodiment, each server group is implemented as a software module on a single server. In another embodiment, each server group is implemented using at least one server. If a server group has more than one server, the server group includes load balancer -, which is capable of distributing work load among servers within the same server group.","In some embodiments, the T-S  manages timestamp information of all the conversations hosted by the host server . When a client communicates with the host server  to send a timestamp request message and receive a timestamp request response, as illustrated the preferred embodiment of , it is the T-S  that serves the client. The API-S  serves the clients. The API-S  hosts conversation requests, manages messages in conversations, and responds to application programming interface calls received from the clients. When a client communicates with the host server  to send a timestamp profile request and receive a timestamp profile response, as illustrated the preferred embodiment of , it is the API-S  that serves the client.","The DOC-S  communicates with clients to receive document files from clients and send document files to clients. The DOC-S  is dedicated to providing client-server interactions that demand high bandwidth usage. The UI-S  is responsible for providing administrative services and management services to users. For example, the UI-S  handles account creation, registration processes, and any type of information presented to the users including web pages and log-in modules. The UI-S  also communicates with the management server  to provide services related to backup secret keys or backup authentication bits.","In a preferred embodiment, the server groups cooperates with one another to provide an integrated service to users. For example, if the T-S  recognizes that a new document has been added to the conversation, the T-S  notifies the clients to download the new document from the DOC-S ; if the T-S  recognizes that a new message has been added to the conversation, the T-S  notifies the clients to download the new message from the API-S .","The host server architecture of  provides a scalable platform for service providers. As the number of clients using the host server increases, the service provider can increase the capacity of the host server  by increasing the number of servers per server groups. In some embodiments, the host server  maintains scaling criteria for controlling the number of servers dedicated to a server group. The scaling criteria depends on (1) bandwidth usage on network adaptors and (2) the amount of work load on the central processing units (CPU.) The host server  can be configured to monitor itself to determine if a server group needs more servers. In other embodiments, an external management system maintains and detects criteria for increasing the number of servers in a server group. In some embodiments, if the service provider decides to provide more functionalities to the clients and if the service provider decides to provide dedicated servers for those functionalities, the service provider can (1) add a new server group to the host server  or (2) divide an existing server group into two or more server groups. Because server groups communicate with one another using a communication protocol, as long as the new server groups accommodate the communication protocol, the addition of new server groups is transparent to existing server groups. In a preferred embodiment, the host server runs in a cloud computing environment, for example, Amazon Web Service (AWS).","The host server architecture is easily scalable to accommodate communication across a large-scale communication network using gateway services.  illustrates an embodiment in which each host server resides in a sub-network such as a local area network (LAN) and the host servers communicate across sub-networks through gateways. Communications between the gateways follow a secure protocol. Prior to communication, gateways negotiate a special key to be included in all communications between the gateways. This way, gateways can identify whether a message was sent from a secure source or not.","In one embodiment, each host server can maintain, in its database, the location and the public key of every user using the data sharing system. This database keeps track of all registered users in the data sharing system. When client A in sub-network A initiates a conversation with client B in sub-network B , client A sends an encrypted version of the conversation to the host server , as illustrated in relation to . The encrypted conversation includes (1) documents and messages encrypted using an encryption key X and (2) the decryption key Y paired with the encryption key X. The decryption key Y in the conversation is encrypted using the public key of client A. Upon receiving the encrypted conversation, the host server decrypts the encrypted decryption key using the private key of client A and re-encrypts the decryption key using the public key of client B. This operation is illustrated in relation to steps - of .","Subsequently, the host server routes the encrypted conversation to Gateway A . Gateway A then relays the encrypted conversation and the previously negotiated special key to Gateway B that interfaces the sub-network B . Upon verifying that the message from Gateway A includes the special key, Gateway B relays the encrypted conversation to the host server that serves client B. The host server then relays the encrypted conversation to client B. Client B uses its private key to decrypt the encrypted decryption key, and uses the decrypted decryption key to decrypt the encrypted documents and messages, thereby securely completing the communication between client A and client B over a large-scale communication network.","In another embodiment, each gateway and each host server has its own X.509 public\/private key. In this embodiment, a host server does not maintain the public key of every user using the data sharing system. Instead, a host server maintains the public key of all gateway associated with itself, and each gateway maintains the public key of all host servers associated with itself and all gateways residing in the communication network. When client A in sub-network A initiates a conversation with client B in sub-network B , client A sends an encrypted version of the conversation to the host server , as illustrated in relation to . The encrypted conversation includes (1) documents and messages encrypted using an encryption key X and (2) the decryption key Y paired with the encryption key X. The decryption key Y in the conversation is encrypted using the public key of client A. Upon receiving the encrypted conversation, the host server decrypts the encrypted decryption key using the private key of client A, as illustrated in relation to steps - of .","Subsequently, the host server re-encrypts the decryption key using the public key of Gateway A and routes the encrypted conversation to Gateway A . Upon receiving the encrypted conversation, Gateway A decrypts the encrypted decryption key using its private key and re-encrypts the decryption key using the public key of Gateway B . Gateway A transmits the encrypted conversation and the negotiated special key to Gateway B that interfaces the sub-network B . After verifying that the message from Gateway A includes the special key, Gateway B (1) decrypts the encrypted decryption key using its private key, (2) re-encrypts the decryption key using the public key of the host server that serves client B, and (3) transmits the encrypted conversation to the host server . The host server then (1) decrypts the encrypted decryption key using its private key, (2) re-encrypts the decryption key using the public key of client B, and (3) transmits the encrypted conversation to client B. Client B uses its private key to decrypt the encrypted decryption key, and uses the decrypted decryption key to decrypt the encrypted documents and messages, thereby securely completing the communication between client A and client B over a large-scale communication network.","The host server  can communicate with a management server  to change password for users, as illustrated in . The communication between the host server  and the management server  follows a communication protocol. Under this protocol, a request from the host server  to the management server  includes an access key. The access key is a signature that the server requesting service from the management server  is authorized to request the service. This protects a third party from requesting service from the management server . In a preferred embodiment, the access key is an AES 256 key, but other types of encryption\/decryption keys can be used. The access key is maintained in an encrypted form, in the database  or in the storage . The encrypted access key is decrypted only at the boot-up of the host server . In a preferred embodiment, the decryption key for the encrypted access key is provided from a management system, which is illustrated in detail in . Once the encrypted access key is decrypted, the access key is maintained at the host server . As is the case with the secret key, the access key is entirely internal to the host server , and is not visible or accessible from the network. In other words, there are no application programming interface (API) functions or instructions to request the access key from an external device. Therefore, the access key is completely transparent to conversation participants and a third party.","In a preferred embodiment, the server groups communicate with one or more of the following to access service-related information: a master database , a slave database , and a storage device . The databases  and\/or the storage device  can reside in the host server  or reside in an external device. The storage device  maintains all the information stored on the host server , including conversations, authentication information, private keys, secret keys, client keys etc. The storage device  is implemented on a computer readable medium. In a preferred embodiment, the storage device  is hosted on Amazon Simple Storage Service (Amazon S3). The database  is also implemented on a computer readable medium. In a preferred embodiment, the database  is a cache of the storage device : the database  maintains a copy of the information stored in the storage device  for fast information retrieval. The database  includes users' authentication information and users' conversations.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 11","b":["274","286","286","220","280","222","282","288","128","274","274"]},"In certain embodiments, the host server  manages a digital signature of data stored on the storage device . If a third party modifies the digitally signed data, the third party modifies the digital signature on the data at the same time. Therefore, when the host server  reads the stored data, the host server  can identify whether the data have been modified by a third party. When the host server  detects that a third party has modified the stored data, the host server  notifies the system administrator and returns an error to the client so that the modified data are not used by the client.","In some embodiments, a server in the server groups is configured by executing configuration procedures using a configuration file. For example, when a server is booted up, the server can use information in a configuration file to configure initial settings of the server environment. The configuration file includes credential information for providing access to the storage device of . In a preferred embodiment, the configuration file is implemented using an extensible markup language (XML). However, other types of configuration files can be used, including YAML or a system-specific format such as a dotfile for UNIX and INI file for Windows and IBM OS\/2.","In a preferred embodiment, the host server  maintains its configuration information in a list of key-value pairs stored in a property file and generates a configuration file from the property file using a configuration file template. This process involves (1) mapping each parameter in the configuration file template to one of the keys in the property file and (2) substituting each parameter in the configuration file using the value paired with the mapped key. For enhanced security, a key-value pair in the property file is encrypted, in which case the key-value pair is tagged as such. For example, the encrypted key-value pair is represented with a key starting with a positive value or by a key tagged with a \u201c+\u201d sign. To further reduce the security risk, the host server  might not maintain the decryption key for the encrypted key-value pair. Therefore, even if a third party attacks the server and gains access to the property file, the third party cannot read the configuration information in the property file, which includes the credential information to access data in the storage device.",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 12","b":["104","300","104","302","104","104","104","308","104","304"]},"In step , the host server  sends a decryption key request to the management system in order to receive the decryption key for the encrypted key-value pair. The management system is aware of which host servers are in the key request state to send the decryption key request. The management system would provide the decryption key only to the host server  in the key request state, but reject decryption key requests from any other host servers not in the key request state. In a preferred embodiment, the management system communicates with the host server  over a local network connection (i.e., via a domain socket or loopback, but not over a network) so that a third party cannot snoop on the decryption key request\/response between the management system and the host server . In some embodiments, the decryption key request includes the key of the encrypted key-value pair to identify the key-value pair to the management system. The host server  then waits until the host server  receives the decryption key from the management system.","In step , the host server  receives the decryption key for the key-value pair and decrypts the key-value pair. After the decryption, the host server  erases the decryption key so that the decryption key does not remain in the host server . In step , the host server  (1) finds the parameter in the configuration file template that is mapped to the key in the key-value pair and (2) substitutes the parameter using the value paired with the mapped key. In step , the host server  checks whether there are any remaining key-value pairs that should be substituted into the configuration file, and repeats steps - until all the key-value pairs in the property file have been substituted into the configuration file. In step , the host server  executes the generated configuration file. Once the host server  completes the configuration, the host server  erases the configuration file for security.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 13","b":["100","322","324","332","334","332","326","328","330"]},"An encryption module  encrypts user credential information, conversation, and other private information before they are sent to other devices, including a host server. The encryption module  encrypts a user password using a salt value and a key derivation function or using other known encryption methods; the encryption module  generates authentication bits from the user password using a salt value and a key derivation function or using other known encryption methods; and the encryption module  encrypts conversation information using a symmetric or an asymmetric encryption method.","A decryption module  decrypts encrypted information using a decryption key. The encrypted information includes an encrypted conversation and an encrypted private key. The decryption module  can use a decryption key received over an interface  or a decryption key that is maintained by the computing device  at a key management module .","A key management module  maintains encryption keys and decryption keys for users of the computing device . These keys include at least (1) public\/private keys and (2) salt values for authentication purposes. The key management module  also maintains client specific key information, including a client key. In some cases, the key management module  can include as a database, which may be stored in a memory .","The encryption module , the decryption module , and the key management module  comprise a client module . The client module  is implemented in software, which may be stored in a memory . The memory  can be a computer readable medium, a programmable read only memory (PROM), or flash memory. The software runs on a processor  capable of executing computer instructions or computer code. The client module  might also be implemented in hardware using an application specific integrated circuit (ASIC), programmable logic array (PLA), field programmable gate array (FPGA), or any other integrated circuit.","An interface  provides an input and\/or output mechanism to communicate over a network. The interface  enables communication with servers, as well as other core network nodes to send and receive data. The interface  is implemented in hardware to send and receive signals in a variety of mediums, such as optical, copper, and wireless, and in a number of different protocols some of which may be non-transient.","The computing device  can be a long term evolution (LTE) user equipment. The user equipment  communicates with one or more radio access networks and with wired communication networks. The user equipment  can be a cellular phone having phonetic communication capabilities. The user equipment  can also be a smart phone providing services such as word processing, web browsing, gaming, e-book capabilities, an operating system, and a full keyboard. The user equipment  can also be a tablet computer providing network access and most of the services provided by a smart phone. The user equipment  operates using an operating system such as Symbian OS, iPhone OS, RIM's Blackberry, Windows Mobile, Linux, HP WebOS, and Android. The screen might be a touch screen that is used to input data to the mobile device, in which case the screen can be used instead of the full keyboard. The user equipment  can also keep global positioning coordinates, profile information, or other location information.","The computing device  also includes any platforms capable of computations and communication. Non-limiting examples can include televisions (TVs), video projectors, set-top boxes or set-top units, digital video recorders (DVR), computers, netbooks, laptops, and any other audio\/visual equipment with computation capabilities. The computing device  can have a memory such as a computer readable medium, flash memory, a magnetic disk drive, an optical drive, a programmable read-only memory (PROM), and\/or a read-only memory (ROM). The computing device  is configured with one or more processors  that process instructions and run software that may be stored in memory. The processor  also communicates with the memory and interfaces to communicate with other devices. The processor  can be any applicable processor such as a system-on-a-chip that combines a CPU, an application processor, and flash memory. The computing device  can also provide a variety of user interfaces such as a keyboard, a touch screen, a trackball, a touch pad, and\/or a mouse. The computing device  may also include speakers and a display device in some embodiments.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 14","b":["104","104","342","344","354","274","346","348","350","352"]},"A decryption key sharing module  processes an encrypted decryption key to transform the encrypted decryption key into a form that a conversation participant can decrypt. The transformation involves decrypting the encrypted decryption key using a private key of a conversation initiator and re-encrypting the decryption key using a public key of a conversation participant.","A data synchronization module  maintains a timestamp for data maintained by the host server. When a client sends a timestamp request message associated with a conversation, the data synchronization module  sends the maximum timestamp value for each object type in the conversation. When the client sends a timestamp profile request for a particular object type in the conversation, the data synchronization module  sends a timestamp profile response that describes the changes made to the specified object type. When the client requests updated information, the data synchronization module  initiates data synchronization by sending the updated information to the client.","A server configuration module  securely configures the host server  using a property file. The configuration module  extracts key-value pairs from the property file, decrypts the key-value pairs as applicable, and substitutes parameters in a configuration file template with the values in the key-value pairs to generate a valid configuration file. The configuration module  executes the configure procedure using the generated configuration file.","A client registration module  registers a client to the data sharing system. The registration process can be triggered by a client serving a new user or a newly installed client. The registration module  generates a client key that is unique to each client. The client key is used to encrypt public\/private key associated with the user at the client, which is subsequently sent to the client over an interface. The registration module  audits client-related information and stores the client-related information in the database .","The decryption key sharing module , the data synchronization module , the server configuration module , and the client registration module  are implemented in software, which is stored in a memory . The memory  includes a computer readable medium, a programmable read only memory (PROM), or flash memory. The software runs on a processor  capable of executing computer instructions or computer code. These modules might also be implemented in hardware using an application specific integrated circuit (ASIC), programmable logic array (PLA), field programmable gate array (FPGA), or any other integrated circuit.","An interface  provides an input and\/or output mechanism to communicate over a network. The interface  enables communication with servers, as well as other core network nodes to send and receive data. The interface  is implemented in hardware to send and receive signals in a variety of mediums, such as optical, copper, and wireless, and in a number of different protocols some of which may be non-transient.","The host server  operates using an operating system (OS) software. In a preferred embodiment, the OS software is based on a Linux software kernel and runs specific applications in the host server such as monitoring tasks and providing protocol stacks. The OS software allows host server resources to be allocated separately for control and data paths. For example, certain packet accelerator cards and packet services cards are dedicated to performing routing or security control functions, while other packet accelerator cards\/packet services cards are dedicated to processing user session traffic. As network requirements change, hardware resources are dynamically deployed to meet the requirements in some embodiments.","The host server's software is divided into a series of tasks that perform specific functions. These tasks communicate with each other as needed to share control and data information throughout the host server . A task is a software process that performs a specific function related to system control or session processing. Three types of tasks operate within the host server  in some embodiments: critical tasks, controller tasks, and manager tasks. The critical tasks control functions that relate to the host server's ability to process calls such as host server initialization, error detection, and recovery tasks. The controller tasks mask the distributed nature of the software from the user and perform tasks such as monitor the state of subordinate manager(s), provide for intra-manager communication within the same subsystem, and enable inter-subsystem communication by communicating with controller(s) belonging to other subsystems. The manager tasks can control system resources and maintain logical mappings between system resources.","Individual tasks that run on processors in the application cards are divided into subsystems. A subsystem is a software element that either performs a specific task or is a culmination of multiple other tasks. A single subsystem includes critical tasks, controller tasks, and manager tasks. Some of the subsystems that run on the host server  include a system initiation task subsystem, a high availability task subsystem, a shared configuration task subsystem, and a resource management subsystem.","The system initiation task subsystem is responsible for starting a set of initial tasks at system startup and providing individual tasks as needed. The high availability task subsystem works in conjunction with the recovery control task subsystem to maintain the operational state of the host server  by monitoring the various software and hardware components of the host server . Recovery control task subsystem is responsible for executing a recovery action for failures that occur in the host server  and receives recovery actions from the high availability task subsystem. Processing tasks are distributed into multiple instances running in parallel so if an unrecoverable software fault occurs, the entire processing capabilities for that task are not lost. User session processes can be sub-grouped into collections of sessions so that if a problem is encountered in one sub-group users in another sub-group will not be affected by that problem.","Shared configuration task subsystem provides the host server  with an ability to set, retrieve, and receive notification of host server  configuration parameter changes and is responsible for storing configuration data for the applications running within the host server . A resource management subsystem is responsible for assigning resources (e.g., processor and memory capabilities) to tasks and for monitoring the task's use of the resources.","In a preferred embodiment, the host server  resides in a data center and forms a node in a cloud computing infrastructure. The host server  provides services on demand. A module hosting a client is capable of migrating from one host server to another host server seamlessly, without causing any program faults or system breakdown. The host server  on the cloud can be managed using a management system, which can include the Rightscale Cloud Management Platform provided by Rightscale, Inc.","In some embodiments, cryptography methods are used to encrypt and decrypt information. The cryptography method can include the RSA algorithm, the Data Encryption Standards (DES), the triple-DES, the Advanced Encryption Standard (AES), the blowfish algorithm, the International Data Encryption Algorithm (IDEA), the Software-optimized Encryption Algorithm (SEAL), the Message Digest algorithms, and the RC4 algorithm.","In some embodiments, the software needed for implementing a process or a database includes a high level procedural or an object-orientated language such as C, C++, C#, Java, or Perl. The software may also be implemented in assembly language if desired. The language can be a compiled or an interpreted language. Packet processing implemented in a host server includes any processing determined by the context. For example, packet processing may involve high-level data link control (HDLC) framing, header compression, and\/or encryption. In certain embodiments, the software is stored on a storage medium or device such as read-only memory (ROM), programmable-read-only memory (PROM), electrically erasable programmable-read-only memory (EEPROM), flash memory, or a magnetic disk that is readable by a general or special purpose-processing unit to perform the processes described in this document. The processors can include any microprocessor (single or multiple core), system on chip (SoC), microcontroller, digital signal processor (DSP), graphics processing unit (GPU), or any other integrated circuit capable of processing instructions such as an x86 microprocessor.","Although the present disclosure has been described and illustrated in the foregoing example embodiments, it is understood that the present disclosure has been made only by way of example, and that numerous changes in the details of implementation of the disclosure may be made without departing from the spirit and scope of the disclosure, which is limited only by the claims which follow. Other embodiments are within the following claims. For example, the server groups in the host server can each be a logical module running on a single server."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 14"}]},"DETDESC":[{},{}]}
