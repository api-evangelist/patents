---
title: Reducing programming complexity in applications interfacing with parsers for data elements represented according to a markup language
abstract: According to an aspect of the present invention, a parser provides the portion identifiers (e.g., Xpath(s) in case of XML data files) of at least some of the data elements to the applications. As a result, the applications may be relieved from the task of computing the XPath(s) for various data elements. The implementation of applications may be simplified as a result. In one embodiment, prior API (application programming interface) is extended to provide the XPath(s). In an alternative embodiment, custom API is provided to enable the applications to obtain the XPath(s).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08918710&OS=08918710&RS=08918710
owner: Oracle International Corporation
number: 08918710
owner_city: Redwood Shores
owner_country: US
publication_date: 20041005
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION","1. Overview","2. Example Environment","3. Operation of Parser","4. Operation of an Application","5. XPaths for an Example XML Data File","6. Extensions to DOM Parsers","7. Extensions to Event-Based Push Parser","8. Extensions to Event-Based Pull Parser","9. Parsers with Custom API","10. Applications Using Parsers with Custom API","11. Software-Driven Implementation","12. Conclusion"],"p":["1. Field of the Invention","The present invention relates to applications programming environment using markup languages such as XML, and more specifically to reducing programming complexity in applications interfacing with parsers for data elements represented according to a markup languages.","2. Related Art","Markup languages such as XML are generally used to represent various data of interest. A typical markup language generally contains tags which indicate one or more of various aspects such as what the data represents or how the data is to be displayed, etc. For example, in XML, relevant data is enclosed between a start tag and an end tag, indicating what the enclosed data represents. The relevant data and the tags are referred to as data elements in the present application.","Applications, which require data represented according to markup languages, often interface with a parser for the various data elements of interest. In a typical scenario, the XML data is stored in an XML data file, and the parser retrieves the data elements and provides the retrieved elements to the applications according to a pre-specified approach.","According to one pre-specified approach often referred to as \u2018pull parsing\u2019, an application generally requests that the \u2018next\u2019 data element be provided. In response, a parser retrieves (e.g., from an XML document) the next data element (in sequential order) from the XML data file and provides the next data element to the application. Since the data elements are generally retrieved in sequential order, the parsers are referred to as sequential parsers.","According to another sequential parsing approach, often referred to as \u2018push parsing\u2019, a parser retrieves data elements in an XML data file without necessarily receiving a request for a next data element, and \u201cpushes\u201d the retrieved data element to the application (after the application has specified the file identifier of the XML data file). The applications are designed to process such data elements received from the push-based parsers. SAX and XNI are the two industry standards, which support push parsing.","The pull and push based parses are broadly referred to as event based parsers since the requests (from application) of pull parsing and the pushing of data elements in push parsing can be viewed as events. It may be appreciated that the data elements are provided one at a time in event based parsing techniques.","In another broad prior approach, commonly referred to as \u2018Object based parsing\u2019, the parser generally creates a hierarchical representation of data elements in an XML data file while parsing the XML data file and saves the hierarchical representation (in the form of a data structure) of the data elements into a random access memory (RAM) which is accessible to the application. The memory resident data structure is referred to as DOM (Document Object Model). The object based parsers return the DOM to the application, typically after parsing of the XML data file is complete. Thus, the applications are designed to access the RAM for any desired data element thereafter. Two commonly used DOM standards are W3C DOM and J-DOM.","An advantage of the object based parsing over the event parsers is that the data elements are available quickly to the applications. However, the memory (RAM) requirements are substantially more since a data structure representing the entire XML data file may be saved in the RAM.","Applications often require an identifier (\u201cportion identifier\u201d) of portions (containing one or more data elements) of a data file. In the case of XML, the portion identifier is referred to as an XPATH, and is defined in a hierarchical fashion similar to the file paths in various computer systems. The portion identifier may be required, for example, to determine a parent\/ancestor of a data element. As an illustration, assuming that an XML data file contains data related to a school and that a retrieved data element corresponds to the name of a student of a section, and it is desirable to determine the teacher of the section. The name of the teacher may be structured as an ancestor of the retrieved data element, and accordingly it may be desirable for an application to have the XPath of the name of the student.","In a prior approach, applications may include program logic to build\/construct XPath (or portion identifier, in general) of such desired parts of an XML data file. The need to build such portion identifiers of data elements of interest generally adds to the programming complexity of applications. At least for such a reason, there is a general need to reduce programming complexity in applications interfacing with parsers for data elements represented according to markup languages.","In the drawings, like reference numbers generally indicate identical, functionally similar, and\/or structurally similar elements. The drawing in which an element first appears is indicated by the leftmost digit(s) in the corresponding reference number.","In an embodiment of the present invention, a parser provided determines identifiers (\u201cportion identifiers\u201d) of at least some portions of XML data provided to an application, and makes the portion identifiers available to the application. As a result, the application may not need to construct the portion identifiers of various portions of the XML data of interest, and the programming complexity of applications can be reduced as a result.","In the case of event-based parsers, the portion identifiers can be provided along with the data elements as parameters of a single procedure call. In the case of object-based parsers, the portion identifiers can be made available in the data structures (random access memory) from which applications typically access the data elements. In alternative embodiments, additional procedure calls (often referred to as function calls) can be used to provide the portion identifiers, as described below with examples.","A parser may construct the portion identifiers while parsing the XML data files. By constructing the portion identifiers while parsing the data files, the implementation of parsers also can be simplified.","Several aspects of the invention are described below with reference to examples for illustration. It should be understood that numerous specific details, relationships, and methods are set forth to provide a full understanding of the invention. One skilled in the relevant art, however, will readily recognize that the invention can be practiced without one or more of the specific details, or with other methods, etc. In other instances, well-known structures or operations are not shown in detail to avoid obscuring the invention.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","b":["110","130","140","110","130","130","110"]},"Various example embodiments described below can be implemented on workstations\/servers\/systems available from vendors such as Sun Microsystems, IBM, and Dell supporting the JAVA application environment. Java concepts are described in further detail in a book entitled, \u201cJava\u2122. The Complete Reference, Fifth Edition\u201d by Herbet Schildt, ISBN Number: 0-07-049543-2.","Application  generally needs to be implemented consistent with the interface (shown as ) provided by parser . Parser  can be implemented by modifying any of the parsers (e.g., the event-based and object based parsers noted above in the background section) available in the marketplace to implement various aspects of the present invention. Alternatively, custom API (application programming interface) may be defined to suitably provide the XPaths associated with various data elements.","Some example interfaces (shown as path ) between applications and parsers, and the manner in which the interfaces can be implemented is described below with examples. First, the manner in which parser  and application  operate according to several aspects of the present invention is described below first.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 2","FIG. 1"],"b":["201","210"]},"In step , parser  may receive the identifier (\u201cfile identifier\u201d to distinguish from the portion identifiers of portions data file) of an XML data file from an application. It should be appreciated that the file represents any data source (whether or not stored in secondary medium) and the file identifier identifies the data source.","In the example environment of , parser  receives the file identifier of XML data file  from application  according to interface . Parser  may identify the XML data file  in the corresponding operating environment (e.g., Sun server with Java application environment), based on the received file identifier.","In step , parser  retrieves a data element from the XML data file. In general, the retrieval needs to be consistent with the medium and access mechanism by which the data in the XML data file can be accessed, and the retrieval may be performed in a known way.","In step , parser  determines XPath expression of the data element. In an embodiment, the loop of steps - is executed for each data element in the XML data file. The data elements are retrieved sequentially from the XML data file, and the XPath may be computed as each data element is retrieved. The content of the XML data file can be used in determining the XPath expression. The XPath expression can also be computed in a known way.","Continuing with , in step , parser  may provide XPath expression associated with the data element to the application. The XPath expression may be provided using various interfaces (). In an embodiment described below, a parser using an event-based parsing technique provides XPath to the application as a parameter while providing corresponding data element. In another embodiment below, parser  using object-based parsing technique provides Xpath expression in the data structure representing XML data file  in RAM.","In yet another approach described below, parser  provides XPath of each data element using API procedure calls defined according to various aspects of the present invention. In the case of data elements having data values, the data value is contained in the provided XPath. Each of the approaches is described in further detail below.","In step , a determination may be made as to whether there are additional data elements to be provided to the application. Control passes to step  if such additional data elements are present, and to step  otherwise. The flow chart of  ends in step . It may thus be appreciated that the flow chart of  operates to provide XPath expressions associated with at least some data elements to applications. The description is continued with respect to the operation of application  in view of the availability of the XPath expressions.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 3","FIG. 1"],"b":["301","310"]},"In step , application  instructs a parser to parse an XML data file of interest. With reference to , application  may specify an identifier of XML data file  while instructing parser . Any other initialization tasks, as necessary for the specific operating environment, may also be performed as a part of such instruction. In general, the instruction causes parser  to provide data elements contained in the specified data file to application .","In step , application  obtains XPath expression associated with an element from the parser. In embodiments described below, the XPath expression is obtained with respect to at least all the data elements, which have corresponding data values. However, alternative embodiments can be implemented in which XPath expressions are obtained in association with only some of the data elements of interest (e.g., by having the applications indicate such data elements of interest).","In step , application  may process the data element and XPath expression obtained from the parser. Such processing generally depends on the \u2018business logic\u2019 sought to be implemented by application . The XPath expression may be conveniently used to simplify the implementation of such business logic.","In step , application  determines if there are more elements to be obtained from XML data file. Control passes to step  if there are more elements to be obtained, and otherwise control passes to step , in which the flow chart ends. It may be appreciated that the implementation of applications can be simplified due to the availability of XPath. The description is continued with reference to an example illustrating the various XPaths provided to an application in the context of an example data file.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 4A","FIG. 4B"],"b":["401","415"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 4B","FIG. 4A","FIG. 4A"],"b":["420","440","420","440","420","421","440","402","415"]},"Lines - contain XPaths for the corresponding four data elements of lines - respectively. Similarly, lines - and - represent XPaths for the data elements of lines - and - respectively. An XPath\/books\/book would represents the data portion corresponding to all the three book elements.","It may be appreciated that the XPaths thus generated can be made available to applications using different interfaces, as described below. The description is continued with reference to an approach in which the interfaces provided by some prior parsers can be extended to provide the XPath expressions.","As noted above, DOM parser represents an object-based parser. DOM parser provides a pre-specified interface using which applications can obtain data elements from a data file of interest. DOM parser is described in a document entitled, \u201cEffective XML\u201d by Elliotte Rusty Harold, available from Addison-Wesley Professional, ISBN: 0321 504 06 The manner in which such a parser can be modified is illustrated below with reference to .",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 5A"},"Lines ,  and  are respectively shown importing the classes in a java application code, available in java.xml.parsers.*, org.w3c.dom.*, and java.util.Vector respectively. The package org.w3c.doc contains functions for accessing (traversing, modifying, creating) a (data structure) DOM according to W3C standards.","Line  defines class DOM parsing as being public, and the corresponding body (of the class) is contained in lines -, as shown. Line  defines a variable \u2018xpaths\u2019 as a vector. The xpaths variable is then used to store XPath, as described below.","Line  causes the execution of the code corresponding to lines - to be executed. Line  initiates a new instance of the DOM parser, and the corresponding handle is saved in variable dbf. In line , the factory instantiates the underlying registered DOM parser, and returns the pointer of the DOM parser class.","Line  specifies the file identifier of the XML data file to be parsed. Thus, the code of lines ,  and  together perform the necessary initializations and completing instructing the DOM parser to parse a data file of interest.","In response, DOM parser provided\/modified according to an aspect of the present invention parses the specified XML data file and load a data structure in the memory, with the data structure containing both the data elements and the corresponding XPaths. A pointer to the data structure is returned to the application.","The data structure may be designed to store the corresponding XPaths as well. Any convention can be used to store the XPaths, and applications need to be designed consistently. An example convention is described below with reference to lines  and .","Line  calls procedure traverse( ) and the corresponding code is provided in . As described below, traverse( ) procedure operates to fill the xpaths data structure with the XPath of each data element, as well the data element. Lines - merely print the XPath values of the data elements for illustration, however, more complex business logic can be employed to use the received XPaths, as suitable for specific scenarios.",{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 5B","b":"555"},"In lines -, the parser traverses through each node in the DOM data structure and computes corresponding XPath expressions. As may be appreciated, there are various types of nodes in a DOM tree. The Node.DOCUMENT_NODE is the hook node from which the entire DOM tree follows. Node.ELEMENT_NODE represents an element tag. For example, for the XML portion <salutation>hello<\/salutation>, a node of the type ELEMENT_NODE would be created in the DOM tree for the tag salutation, and a node of the type TEXT_NODE would be created for the value hello. Line  would be executed when the current node is of type ELEMENT_NODE. At line , all the immediate children of the current node is collected in NodeList. Lines - recursively call the method traverse for every node collected in the NodeList.","Thus, using techniques such as those described above, XPath can be provided to applications in the context of DOM-type parsers. The description is continued with an illustration of pseudo-code implementation of an interface between an application and an event-based push parser according to the present invention.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 6"},"Lines , ,  and  are respectively shown importing the classes available in source files java.xml.parsers.*, org.xml.sax.*, org.xml.sax.helpers.* and java.util.Vector.* respectively. Once imported, the classes in the source files can be referred to directly in the application code.","Line  defines class SAXParsingXPath2 as being public, and the corresponding body (of the class) is contained in lines -, as shown. Class SAXParsingXPath2 represents an implementation of SAX Parser according to an aspect of the present invention which returns XPath corresponding to each data element as a parameter. It may be appreciated that the procedure may return XPath in addition to the attributes and values of the data element.","Line  initiates the execution of class SAXParsingXPath2 corresponding to lines -. Line  causes execution of the code corresponding to lines -. Line  initiates a new instance of the SAX Parser-Factory, and the corresponding handle is saved in variable spf.","Line  initiates a new instance of the SAX parser and the corresponding handle is saved in variable sp. Line  creates a handle (saved in variable handler) while executing the code corresponding to the class SAXParsingXPath2.","Line  specifies the file identifier of the XML data file to be parsed. Since the application is assumed to be interfacing with a push parser, the parsing operations begin in response to execution of line , and the data elements of the specified data file (here \u201c . . . \/something.xml\u201d) are made available. Lines - are shown printing the XPath for each data element, even though more complex business logic can process the XPaths.","Lines -, - and - represent classes which obtain the XPaths provided by SAX parser according to various aspects of the present invention, add the XPaths to the variable vector (as indicated by lines  and ), and process the corresponding attributes and XPath. As may be readily observed, XPath corresponding to a data element is shown obtained as a parameter value in each of lines ,  and .","Accordingly, the SAX parser may need to be implemented to construct the XPath while parsing the XML data file, and provide the XPath value as a parameter with each class. The description is continued with an illustration of pseudo-code implementation of an interface between an application and an event-based pull parser in an embodiment of the present invention.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":"FIG. 7"},"Lines , , , and  are respectively shown importing the classes available in source files java.io.*, javax.xml.stream.*, javax.xml.stream.events.*, java.util.Vector.*. Once imported, the classes in the source files can be referred to directly in the application code.","Line  defines class PullParsingXPath as being public, and the corresponding body (of the class) is contained in lines -, as shown. Class PullParsingXPath represents an implementation of event based PULL Parser according to an aspect of the present invention which returns XPath corresponding to each data element as a parameter.","Line  defines a variable \u2018xpaths\u2019 as a vector. The xpaths variable is then used to store XPath, as described below.","Line , application request the parser to begin parsing by providing the file identifier. Lines - begins parsing and retrieves data elements from the XML data file and a variable pullParser is defined to contain the data elements.","The program loop in lines -, the parser determines XPath for each data element and adds the XPath value to the vector xpaths. Lines - illustrate the manner in which different business logic can be applied (even though only a print statement is shown in all cases, for simplicity) for different node-types. Similarly, the for loop of lines - prints the Xpaths in the vector xpaths. In general, a programmer may provide a desired business logic instead of the print statements.","It may be appreciated that the embodiments described above with respect to  represents extensions to conventional parsers, in which XPath values are obtained as parameters. However, various aspects of the present invention can be implemented using other approaches as well. For example, new parsers providing custom application programming interfaces (API) may be implemented, as described below with an example.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":["FIGS. 8A-8F","FIGS. 8 and 9","FIGS. 8A-8F","FIGS. 8A-8F"],"b":["8","9"]},"Lines - of  indicate names of procedures accessible via XPathParserFactory API. The procedure of line  is used by an application to create an instance of the parser (). The application can access procedures of push parser (line ). The setFeature procedure of line  enables an application to assign a value to a property, as described below with reference to  in further detail. The hasFeature procedure of line  checks whether a particular property is already set\/initialized. The getFeature procedure of line  enables an application to retrieve a presently assigned value (and can be used after checking with hasFeature procedure).","The methods setProperty (line ) and setFeature (line ) in XpathParserFactory, set corresponding value for property and feature in the parser to the value passed during corresponding function calls. The methods are illustrated with examples below. However, the methods can be used with respect to other types of features and properties, as suited for the specific environment.","Lines - of  correspond to names of procedures that can be used by an application if push based parser is instantiated using the procedure call of line . The procedures of lines - are described with reference to  below.","Lines - of  contain names of procedures which are implemented in push based parser in one embodiment. The startDocument procedure of  opens an XML data file specified as a parameter, and (the file identifier) is generally provided by an application. Line  is shown indicating the name of the procedure, which may close the XML document after parsing of data elements is completed.","One of lines  and  is executed by the parser to provide the XPath value associated with each data element. The emit procedure of line  is used if the application had previously indicated that XPaths for the attributes need not be grouped and provided (by using the setFeature procedure of line ) while providing the XPath of the associated data element. In such a case, separate XPaths are provided for each attribute of the data element. The emit procedure of line  is used otherwise, in which case the attributes are returned as values associated with the data element (along with the XPath).","The NamespaceResolver class of  is used to resolve the prefixes in the XPath expression to the namespace URIs. As may be appreciated, the elements in an XML document may or may not have namespaces, depending on how the XML document is created. The XPath expression for an element, which has a namespace should generally use a prefix, and the mapping of this prefix to the actual namespace of the node must be available in the NamespaceResolver, so that the XPath engine can use the NamespaceResolver to resolve the prefixes to namespace while evaluating the XPath expression.","For example, for the XML document:","<?xml version=\u201c1.0\u201d ?>","<salutation xmlns=\u201cfoo\u201d>hello<\/salutation>","the element\u2014salutation, has a namespace URI=foo. The XPath expression for this element is \u201c\/pfx:salutation\u201d and not \u201c\/salutation\u201d, wherein the prefix pfx could be any name and not necessarily always be pfx. The expr \u201c\/salutation\u201d is incorrect because, the element salutation in the XML document has a namespace URI, and \u201c\/salutation\u201d would mean to look for the element named salutation which has no namespace.","Now, for the XPath engine to be able to evaluate the expr \u201c\/pfx:salutation\u201d correctly, the prefix\u2014pfx must have been bound to some namespace, and there must be a mechanism by which the XPath engine can resolve the prefix to a namespace URI. The XPathPushParser, while parsing the XML document, would bind the prefixes used in the XPath expr to the correct namespace URIs in the NamespaceResolver. This NamespaceResolver would then be made available to the XPath engine to evaluate the XPath expression correctly.","For the example noted above, when the XPathPushParser reports the xpath as \u201c\/pfx:salutation\u201d, the application code can use the NamespaceResolver in the following way to resolve the namespace URI:","String ns=resolver.resolveNamespacePrefix(\u201cpfx\u201d);","The value of the variable \u201cns\u201d would be \u201cfoo\u201d.","When a feature http:\/\/xpath-parser\/features\/group-attributes is set to true, the XPath of all the attributes with their corresponding values, if any, on an element, would be grouped together as XPathAttributes () and reported alongwith the XPath of the element using the method emit(String xpath, String xpath Val, int eventType, XPathAttributes attrs, NamespaceResolver nsResolver).","For every attribute found, the XPath expression of the attribute and the value of the attribute is used to create the function XpathAttribute of . The set of all such XPathAttribute functions can then be accessed from the function XpathAttributes using the function as follows:\n\n","}","The implementation of the procedures of  will be apparent to one skilled in the relevant arts by reading the disclosure provided herein. The description is continued with respect to the manner in which applications can be implemented using the custom API thus provided.",{"@attributes":{"id":"p-0099","num":"0107"},"figref":["FIG. 9","FIGS. 8A-8C"],"b":["8","8","901","904"]},"Line  defines class PushParsingXPath as being public, and the corresponding body (of the class) is contained in lines -. Class PushParsingXPath represents an implementation of an event-based parser, which returns XPath corresponding to each data element according to an aspect of the present invention.","Line  defines a variable \u2018xpaths\u2019 as a vector. The xpaths variable is then used to store XPath, as described below.","Line  is shown initializing an instance of XPathParserFactory and the corresponding handle is stored in a variable xpf to enable access to procedure names indicated by lines - of .","Line  is shown initializing an instance of XPath based PUSH parser, and the corresponding handle is stored in a variable xpp, which enables the application to access corresponding procedures of -.","Line  indicates to the parser that the XPaths are to be provided in a non-abbreviated format, consistent with the definition of the procedure call of line . As a result, each XPath is provided with the beginning of the XML data file as the root (e.g., as depicted in column  of ). On the other hand, if the value were set to true, the XPath are provided in abbreviated format, in which each XPath is defined with reference to a present node.","Continuing with reference to , setFeature procedure of line  requests the parser to provide XPath of attributes corresponding to a data element while parsing the XML data file by executing either of the emit procedures indicated by the lines - and -.","Lines  and  initialize the application to process data elements provided by the parser (by the emit statement, noted above in line  and  of ) and the corresponding handle is stored in variable xpcHandler.","Lines  and  together enable application to report any errors, which may occur during processing in the application. The corresponding handle is stored in a variable xpeHandler. In Line , application provides the file identifier for XML data file to the parser.","In line , the parser begins parsing of XML data file and procedures of , E and F are executed. In particular, as noted above, one of the emit statements of lines  and  is executed depending on the value of the attributes parameter, which is set to true in line . Thus, the statement of line  would be executed due to the set value.","The code of lines - and - respectively inherit the emit classes of lines  and . The xpaths.add( ) procedure is executed by each of the emit classes. However, more complex business logic can be employed, as will be apparent to one skilled in the relevant arts.","It may be observed that the above application is implemented with push parsers.  illustrates the XPaths and values returned by the parser, as described briefly below.",{"@attributes":{"id":"p-0111","num":"0119"},"figref":["FIG. 10A","FIG. 4A","FIGS. 8A-8F","FIG. 4A","FIG. 4A"],"b":["1010","1020","1030","1022","1033","1024","403","1028","1032","407","411"]},{"@attributes":{"id":"p-0112","num":"0120"},"figref":"FIG. 10B","b":["1051","54","1061","1071"]},"In comparison to , it may be readily noted that XPaths are not provided for attributes in rows ,  and . However, the same attribute values are provided as parameters as indicated in rows ,  and  of .","It may be further noted that the XPaths of  are shown in non-abbreviated format since the abbreviated feature is set to false in lines  and  respectively. However, by setting the abbreviated feature to true, the XPaths can be provided in the abbreviated format, and the corresponding XPaths are depicted in . The table of  depicts the Xpaths corresponding to a case in which abbreviated feature and attributes feature are both set to false.","The description is continued with reference to an embodiment in which the above features are implemented in the form of software instructions executing on a digital processing system.",{"@attributes":{"id":"p-0116","num":"0124"},"figref":["FIG. 11","FIG. 11"],"b":["1100","1110","1120","1130","1160","1170","1180","1190","1170","1150"]},"CPU  may execute instructions stored in RAM  to provide several features of the present invention. For example, the instructions may implement one or both of parsers and applications, described above. CPU  may contain only a single general purpose-processing unit or several processing units. RAM  may receive instructions from secondary memory  using communication path .","Graphics controller  generates display signals (e.g., in RGB format) to display unit  based on data\/instructions received from CPU . Display unit  contains a display screen to display the images defined by the display signals. Input interface  may correspond to a keyboard and\/or mouse. Graphics controller  and input interface  may enable a user to interact directly with system .","Secondary memory  may contain hard drive , flash memory  and removable storage drive . Secondary memory  may store the data and software instructions, which enable system  to provide several features in accordance with the present invention. Some or all of the data and instructions may be provided on removable storage unit , and the data and instructions may be read and provided by removable storage drive  to CPU . Floppy drive, magnetic tape drive, CD-ROM drive, DVD Drive, Flash memory, removable memory chip (PCMCIA Card, EPROM) are examples of such removable storage drive .","Removable storage unit  may be implemented using medium and storage format compatible with removable storage drive  such that removable storage drive  can read the data and instructions. Thus, removable storage unit  includes a computer readable storage medium having stored therein computer software and\/or data.","In this document, the term \u201ccomputer program product\u201d is used to generally refer to removable storage unit  or hard disk installed in hard drive . These computer program products are means for providing software to system . CPU  may retrieve the software instructions, and execute the instructions to provide various features of the present invention as described above.","While various embodiments of the present invention have been described above, it should be understood that they have been presented by way of example only, and not limitation. Thus, the breadth and scope of the present invention should not be limited by any of the above-described example embodiments, but should be defined only in accordance with the following claims and their equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention will be described with reference to the accompanying drawings briefly described below.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 8A-8F"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 9","FIGS. 8A-8F"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIGS. 10A","FIGS. 8A-8F"],"b":["10","10","10"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
