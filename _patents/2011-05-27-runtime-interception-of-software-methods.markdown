---
title: Run-time interception of software methods
abstract: The present disclosure involves systems and computer-implemented methods for installing software hooks. One process includes identifying a target method and a hook code, where the hook code is to execute instead of at least a portion of the target method, and wherein the target method and the hook code are executed within a managed code environment. A compiled version of the target method and a compiled version of the hook code are located in memory, where the compiled versions of the target method and the hook code are compiled in native code. Then, the compiled version of the target method is modified to direct execution of at least a portion of the compiled version of the target method to the compiled version of the hook code. The non-compiled version of the target method may be originally stored as bytecode. The managed code environment may comprise a managed .NET environment.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09116717&OS=09116717&RS=09116717
owner: Cylance Inc.
number: 09116717
owner_city: Irvine
owner_country: US
publication_date: 20110527
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The present disclosure relates to modifying software, and more particularly, to run-time interception of software methods by hooking native code.","Since its release in 2002, the Microsoft .NET Framework has become one of the most popular frameworks targeted by developers of Microsoft Windows-based applications. This widespread prevalence ensures that code targeting the .NET Framework will be run in diverse environments by a wide variety of users. Many of those users, particularly at the enterprise level, may have special demands for customizations and enhancements that were not anticipated in the design of the .NET Framework and are not provided by components or platforms built on it. In many cases, third-party software products must meet such needs with hooking\u2014a generic term for technologies that alter or augment the behavior of other software. Hooking is often accomplished by modifying existing code or modifying data structures that influence code execution.","In the execution environment of the .NET Framework, however, most code and data are essentially maintained as part of the internal state of the framework's application virtual machine. The virtual machine accepts platform-agnostic bytecode as input, and both the bytecode and the metadata that describes it are represented in a standardized format. Internally, the bytecode is passed to a just-in-time (JIT) compiler to be translated into platform-specific native code. The virtual machine maintains internal data structures that describe this native code, and both code and data are stored at dynamic locations in memory belonging to the virtual machine. In general, neither the native code nor the associated data is directly exposed to third-party code.","Most hooking solutions for the .NET Framework have focused on modifying bytecode rather than native code. Some solutions alter the bytecode of .NET executables (known as assemblies), either on disk before they are accessed or in memory at load time. Another common technique is to use the .NET profiling API to edit bytecode before it is JIT compiled and executed by the virtual machine for the first time.","The present disclosure involves systems and computer-implemented methods for installing software hooks. One process includes identifying a target method and a hook code, where the hook code is to execute instead of at least a portion of the target method, and wherein the target method and the hook code are executed within a managed code environment. A compiled version of the target method and a compiled version of the hook code are located in memory, where the compiled versions of the target method and the hook code are compiled in native code. Then, the compiled version of the target method is modified to direct execution of at least a portion of the compiled version of the target method to the compiled version of the hook code. The non-compiled version of the target method may be originally stored as bytecode. The managed code environment may comprise a managed .NET environment.","While generally described as computer implemented software embodied on non-transitory, tangible media that processes and transforms the respective data, some or all of the aspects may be computer implemented methods or further included in respective systems or other devices for performing this described functionality. The details of these and other aspects and embodiments of the present disclosure are set forth in the accompanying drawings and the description below. Other features, objects, and advantages of the disclosure will be apparent from the description and drawings, and from the claims.","The present disclosure describes computer systems, software, and computer-implemented methods for installing and using software hooks into code that targets the Microsoft .NET Framework. Generally, the systems and methods are intended for use in general-purpose and\/or specific hooking solutions, where \u201chooking\u201d refers to software techniques for altering or augmenting the behavior of other software. The utility of hooking is well established in the software industry, and is used for such purposes as software development (e.g., debugging, tracing, and performance analysis), computer security (e.g., monitoring and filtering program behavior to prevent unauthorized access), and extension, enhancement, and modification of existing functionality. The method of the present disclosure can be considered to operate in several operations, including (1) ensuring that native code exists for the target method and the hook (or replacement) method, forcing the native code to be generated by a just-in-time (JIT) compiler, as necessary; (2) locating the native code of the compiled target and hook methods in memory; (3) hooking the compiled target method to redirect execution to the compiled hook method; and (4) providing facilities by which the hook method can invoke the original target method. Many variations and alternative implementations are possible. For example, the hook method may be originally implemented in native code (as opposed to managed code). Additionally, there may be multiple hook methods (i.e., both a pre-filter hook method and a post-filter hook method), or there may not be a distinct hook method. Further, it may not be necessary for the hook method to invoke the original target method.","An example glossary of select terms used in the present disclosure is provided herein:\n\n","Prior hooking solutions, such as those which modify bytecode, face many disadvantages. For example, due to the JIT compilation step, bytecode modification is only effective if performed before the code is JIT compiled, and the modification cannot be reversed once the code has been compiled. Consequently, hooks based on bytecode modification generally must be installed early in the lifetime of the target process and cannot be subsequently removed and reinstalled. In the case of precompiled code, bytecode modification is only effective if the precompiled code can be prevented from loading, which is not possible for some significant portions of code implemented as part of the .NET Framework itself. Altering assemblies can cause integrity checking to fail, while using the .NET profiling API may impact performance and is not recommended by Microsoft for production environments. Thus, there is a need for a more powerful, more flexible, and lighter-weight approach to hooking code that targets the .NET Framework as described in the systems and methods of the present disclosure. To answer that need, the systems and methods described herein enable a third-party software developer to alter the behavior of managed code in ways that are already well established for unmanaged code.","Previous techniques used to accomplish software hooking are usually specific to a particular execution environment\u2014in other words, the means of performing hooking must be tailored to the specific platform hosting the code to be hooked. Managed code environments such as the Oracle (formerly Sun Microsystems) Java Runtime Environment and the Microsoft .NET Framework present special challenges for hooking solutions, since in these environments, the target code usually exists either as managed instructions (represented as bytecode) to be interpreted by a virtual machine, or as native code generated from bytecode at a dynamic time and memory address by a JIT compiler. Bytecode instructions are deliberately restricted in their ability to influence the execution state of the virtual machine. For instance, a branch instruction in bytecode cannot redirect execution to an arbitrary memory address, whereas a branch instruction in native code could do so. Bytecode also does not contain embedded function pointers that can be manipulated\u2014one bytecode method can invoke another only by name or token, which the execution environment translates into pointers internally at runtime.","Most attempts to provide hooking under the .NET Framework have therefore focused on manipulating the bytecode of managed methods, either on disk, at load time, or at runtime, and among run-time solutions, use of the .NET Framework's Common Language Runtime profiling API is common. Such approaches sidestep the difficulties of locating and modifying the native code generated by JIT compilation of bytecode by acting on the bytecode itself, but they also face disadvantages. For one, a run-time hooking solution must be active in the process hosting the managed code of interest before that code is JIT compiled, or else the original, unmodified bytecode will be used as input to the JIT compiler. Generally speaking, the native code that the JIT compiler generates will thereafter execute whenever the managed code is invoked, and thus, altering the bytecode after that point is ineffective. Meanwhile, in the important cases of internalcall methods and native (NGen'ed) images, there is not even any bytecode to modify. In all cases, hooks instituted through the manipulation of bytecode have the further disadvantage that they cannot be removed at runtime.","The prevailing practice of using the .NET profiling API carries additional drawbacks, namely that only one profiler can be active in a given process; the profiler must be present and registered in a process of interest before the .NET Framework loads into the process, in order for the profiler to use instrumentation functionality; the profiling API is not recommended by Microsoft for use in production environments; and profiling necessarily has a greater performance impact than other approaches due to notification of many actions and events unrelated to the particular hooking objective. The presence of a profiler will prevent native images from being loaded (except for native images explicitly generated with profiling support), which avoids the difficulties associated with hooking a native image but comes at a further cost to performance. Methods implemented as internalcall, on the other hand, cannot be hooked at all using the profiling API. Similar disadvantages also apply to a less common, run-time approach that involves hooking the JIT compiler itself (specifically, its compileMethod function): the hook must be present before the managed code of interest is JIT compiled, and it is ineffective against native images and internalcall methods.","Another well-known approach to hooking .NET code is to modify the bytecode in a .NET assembly of interest on disk, and then ensure that the modified assembly is somehow loaded in place of the original at load time; the assembly could equivalently be modified in memory when it is loaded. One major drawback to such an approach is that it conflicts with the integrity checking step of .NET Framework's strong-name signing scheme, in cases where the assembly to be modified has a strong name and will be validated when it is loaded. Another drawback, specific to on-disk modification of assemblies, is that an altered assembly could be subsequently upgraded by the user, resulting in the hooking solution's modifications being overridden or the upgrades being ignored unless the solution actively maintains its replacement libraries. Substituting an assembly on disk or in memory could also interfere with, or be complicated by, the .NET Framework's loading of a corresponding native image generated from the original assembly.","Yet another documented approach involves modifying a type's data structures and metadata to override or replace its methods, rather than altering the code within the methods. Such an approach may insert a new class into the class hierarchy below or above the target class, so that its methods get invoked before or by the method implementation of interest, or it may modify the type's method table to replace a method implementation. Due to JIT compilation optimizations, however, such a solution could be partly ineffective if activated at runtime, as the JIT compiled code could contain hard-coded call and branch instructions that transfer execution to native code for some methods without accessing a method table, and thereby avoid the hooking solution's method table modifications. Another approach involves instantiation of a proxy class and substitution of it for instances of a target class, although such an approach could also be ineffective if JIT compiled code for the methods of the target class already exists in memory (or even if instances of the target class already exist), and it could face difficulties relating to inheritance and typecasting when instances of the proxy class are passed to other code.","The methods and systems of the present disclosure avoid these drawbacks by operating on the native code of the method of interest, whether that method was originally stored as bytecode, or as native code residing in a native image or existing as an internalcall implementation. For example, a method can be hooked, unhooked, and re-hooked at will, with the only recurring performance penalty being the cost of executing the replacement method. Because it eschews operating on bytecode in favor of modifying JIT compiled code, the described methods and systems are ideally suited for run-time operation and are not limited to installing hooks prior to JIT compilation. Furthermore, because all hooking is done at runtime, assembly replacement concerns such as strong name integrity checking and upgrade conflicts do not apply. And unlike most other run-time, .NET hooking solutions, the methods and systems do not rely on the .NET profiling API, so they are unrestricted as to when they must load into a process and how many instances can be simultaneously active in a process.","Given the widely-recognized utility and current pervasiveness of hooking, potential applications of the described systems and methods are numerous. A sampling of possible applications include: (1) third-party extensions to .NET system methods for security, reverse-engineering, or compatibility purposes; (2) lighter-weight, at-will profiling of .NET code; (3) enhancement of existing functionality, including \u201csubclassing\u201d of sealed types' methods; (4) transparent proxying of method calls; (5) enablement of aspect-oriented programming in the .NET Framework; and (6) implementation of bug fixes in .NET assemblies for which source code is unavailable.",{"@attributes":{"id":"p-0031","num":"0068"},"figref":"FIG. 1","b":["101","104","102","108","108","110","104","110"]},"In the illustrated example, a hooking system is implemented as an unmanaged hooking interface library  and a managed hooking agent assembly . In other implementations, however, the system may be implemented as any number of managed and\/or unmanaged components. The hooking interface library  is used by extension code (not shown) that desires to hook a target method  implemented as managed code in a target .NET assembly . In other instances, any number of target methods may be hooked, and the hooking system and extension code need not be distinct entities. The hooking interface library  begins by using (as represented by the dashed arrow) functionality provided by the CLR  to load (as represented by the solid arrow) the managed hooking agent assembly  into one or more .NET application domains  (or \u201cAppDomains\u201d). The hooking interface library  can then communicate with the managed hooking agent  to prepare for hooking the target method . Operating from within the virtual machine, or managed code portion , the managed hooking agent  may use (as illustrated by the first pair of dashed arrows) functionality of the BCL\/FCL  to request or force just-in-time (JIT) compilation of the target method  and a replacement method  implemented within the managed hooking agent  that will execute in place of the target method  once the hooking is complete. In other instances, the replacement method may be implemented as managed or unmanaged code separate from the managed hooking agent. The CLR , in turn, instructs (as represented by a second pair of dashed arrows) the JIT compiler  to perform the JIT compilation of the target method  and the replacement method , such that the JIT compiler produces (as represented by the two solid arrows from the JIT compiler ) a JIT compiled replacement method  and a compiled target method .","In some instances, the hooking interface library  and\/or the managed hooking agent  may then use various means and operations to determine the entry point address in memory of each of the target compiled method  and the replacement compiled method . The hooking interface library  can then store (as illustrated by the solid line from the hooking interface library ) the hook code  at or near the entry point of the target compiled method , where the hook code  diverts execution (as represented by the dashed line leaving the hook code ) from the target compiled method  to the replacement compiled method . Alternatively, the hook code  may be stored by the managed hooking agent . In other instances, the hook code  may instead divert execution to intermediate code that may execute any amount of other code, including the original code of the target compiled method  itself. In some instances, the replacement compiled method  may represent an extension to the target compiled method  performed prior to execution of the target compiled method , such that completion of the replacement compiled method  results in execution of the target compiled method . In some instances, the hook code could be included inside the target compiled method , such that some of the operations of the target method may be performed, with the completion of the replacement method resulting in completing the additional portions of the target method , although some difficulties may arise.","In some implementations, the managed hooking agent  may be installed into a Global Assembly Cache (GAC). Installing the agent  into the GAC ensures that the agent's code will execute with full permissions, allowing managed code associated with the agent (such as replacement method ) to perform reflection, interop, or any other suitable privileged actions or operations without issue. Alternatives means for providing full, or otherwise enhanced, permissions to the managed hooking agent  may also be possible.",{"@attributes":{"id":"p-0035","num":"0072"},"figref":["FIG. 2","FIG. 2","FIG. 2"],"b":"201"},"Generally, process  is an example process hosting the .NET Framework. Although a process typically contains many different types of resources, diagram  only considers the process's memory. The rectangles represent entities present in the memory associated with process .","An example .NET application domain (or \u201cAppDomain\u201d)  is illustrated within the process . The application domain  is an isolated environment in which a .NET application executes. Although only a single application domain is illustrated, a .NET process typically contains at least three application domains\u2014a system domain, a shared domain, and a default domain. A more complex host, such as ASP.NET, may create additional application domains. Each application domain in a process could potentially contain its own instance of JIT compiled code for the target and\/or replacement methods. Within the example application domain , the nesting of elements is understood to represent conceptual encapsulation rather than confinement to a particular memory region.","The application domain  includes an example .NET assembly . Generally, an assembly constitutes the fundamental deployable program element\u2014an application or a library\u2014in the .NET Framework, and comprises an assembly manifest (not shown) and one or more modules. An assembly may exist as one or more files loaded from local storage or accessed over a network. Here, the example assembly  is depicted as containing a single example .NET module . A module is a component of a .NET assembly that contains bytecode, type definitions, other metadata, and additional data such as strings and resources. For simplicity's sake, only the bytecode  and metadata  are illustrated in the example .NET module . The example bytecode  is an example common intermediate language (CIL) bytecode. Bytecode is a binary (machine-readable) encoding of platform-agnostic instructions executed by the .NET Framework's application virtual machine. A solid arrow represents that the bytecode  is passed as input to the Just-in-Time (JIT) compiler . Metadata is binary information that describes the types defined and code implemented in the module. Here, metadata  describes an example class (not shown) that is passed to the class loader  (as represented by the solid arrow). In addition to the class's name, visibility, fields, properties, events, attributes, base class, and interfaces implemented (not shown), the metadata  also describes methods implemented by the class and associates them with the corresponding bytecode.","The process  includes an instance of the Microsoft .NET Common Language Runtime (CLR) library , which may be named MSCORWKS.DLL, MSCORSVR.DLL, or CLR.DLL, depending on the system. The library  contains native code implementing the .NET Framework application virtual machine, including components such as the class loader  and native code implementations of internal methods of the .NET Framework, which are represented by a single example internal method implementation . Only one instance of the library  loads in each .NET process . The .NET Framework class loader  receives a type definition (not shown) described in the example metadata  and produces a method table , as represented by the solid arrow from the class loader .","The example method table  is created by the class loader  to describe a particular type (not shown). The method table  contains various data about the type, including various example method slots , , , and  (described below). The method table  provides a list of \u201cslots\u201d that contain pointers to stubs or compiled methods. Example method slot  is associated with an internalcall or runtime method, which is generally a method that is implemented in native code as part of the .NET Framework itself. In the example, the method corresponding to method slot  has an internal implementation  to which the method slot  contains a pointer, as represented by the dashed arrow. The example internal implementation  is depicted as a compiled function residing in the CLR library .","Method slot  is an example method slot for a JIT compiled method. In this instance, the method corresponding to the method slot  has already been JIT compiled to produce a compiled method . The method slot  is depicted as containing a pointer to a stub  that directs execution to the compiled method , as represented by the dashed arrow, although it should be noted that, in other cases, the method slot  could contain a pointer directly to the compiled method . In this example, the method slot  corresponds to a method that has not yet been JIT compiled, which means that no executable implementation of the method exists. Instead, the method slot  contains a pointer to a stub , as illustrated by the dashed arrow, that will initiate JIT compilation of the method the first time any attempt is made to invoke the method. After JIT compilation, the method slot  or stub  will be updated to point to the new compiled method. Method slot  is an example method slot for an ahead-of-time (AOT) compiled method. In some cases, bytecode may be compiled into native code and cached in permanent storage to improve run-time performance for all future executions of that code. In this example, the method slot  contains a pointer to a stub  (as illustrated by the dashed arrow) that directs execution to an AOT compiled method  existing in a native image .","The example JIT\/stub heap  contains native code for both stubs and JIT compiled methods. In this example, the JIT\/stub heap  is a region of executable memory in which native code instructions can be written and executed. The native code of a compiled method  and the native code for various stubs , , and  reside in the JIT\/stub heap . In other instances, the JIT\/stub heap  may be separated into a JIT heap and a stub heap, in which case the compiled method  would reside in the former while the stubs , , and  would reside in the latter. In the present example, compiled method  is an example just-in-time (JIT) compiled method. When a method (not shown) encoded in bytecode  is JIT compiled, the JIT compiler  generates a native code compiled method , as represented by the solid arrow. The compiled method  resides in the memory of the JIT\/stub heap . Example stub  is an example stub for a JIT compiled method. The stub  resides in a JIT\/stub heap  and comprises one or more native code instructions that direct execution to a particular compiled method . Stub  is an example stub for a method that has not been JIT compiled. The stub  receives execution whenever an attempt is made to execute a particular method (not shown), so that the method can be JIT compiled. The stub  resides in the JIT\/stub heap  and comprises one or more native code instructions that initiate JIT compilation of the method, after which the stub  may be updated to instead direct execution to the new compiled method. Stub  is an example stub for an AOT compiled method. The stub  resides in a JIT\/stub heap  and comprises one or more native code instructions that direct execution to a compiled method  within a native image . In some instances, any of the stubs , , or , as well as the compiled method  and\/or native image , may be omitted.","The process  includes a Microsoft .NET Just-In-Time Compiler library , which may be named MSCORJIT.DLL or CLRJIT.DLL depending on the system, in which the .NET Framework houses its JIT compiler functionality . For a method (not shown) that is to be compiled into native code, the JIT compiler  receives bytecode\u2014here, a portion of bytecode \u2014as input and produces native code as output, such as the example compiled method  (as represented by the two solid arrows).","Returning to the AppDomain , an example native image  is illustrated. A native image is a .NET module that contains native code instead of, or in addition to, bytecode. A native image may be generated to improve run-time performance, by obviating the need to JIT compile code at runtime. The code of a native image is termed ahead-of-time (AOT) compiled. In this example, a native image  generated previously, for instance using the .NET Framework's NGen utility, and has been loaded into the process . Here, the native image  is depicted as containing a single compiled method , although in other instances, a native image may contain any number of compiled methods.",{"@attributes":{"id":"p-0045","num":"0082"},"figref":"FIG. 3","b":["301","301","302","303","304","305","306","307","308","301","301","307","308"],"i":["a","a","a","a","a","a","a","a","a "]},"Example NOP-equivalent instruction is illustrated in the target compiled method  prior to installation of the detour hook in the target compiled method . In some instances, a compiler may emit a NOP or equivalent instruction as the first instruction of a compiled method; however, in some instances, the true entry point of the compiled method may be located after the NOP-equivalent instruction . In some instances, installing a method hook may purposely advance past any initial NOP-equivalent instructions in anticipation of the possibility of a second, true entry point after such instructions, as it would be unsafe to overwrite both the first and second entry point with a single detour hook. NOP-equivalent instruction , on the other hand, is illustrated in the target compiled method  after installation of the detour hook. In this example, the initial NOP-equivalent instruction is skipped and therefore persists as an unmodified NOP-equivalent instruction in the hooked target compiled method .","Prior to hooking, a first instruction of prolog code is illustrated in the target compiled method . In many cases, a compiled method begins with a prolog that may allocate stack space, preserve nonvolatile CPU registers, register an exception handler, and other operations. The first instruction of prolog code is illustrated within a hook thunk , as relocated and possibly adjusted, after installation of the detour hook. The region of memory that originally held the prolog instructions , , and is overwritten by the detour hook  during installation of the hook, so the instructions , , and are relocated to another memory location and may be adjusted in the event that their operations or encodings are dependent on the address at which they execute. The instructions , , and will then be executed at the new location prior to executing the unmodified remainder of the target compiled method , in the event that the replacement compiled method  must invoke the original target compiled method . Second, third, and fourth prolog instructions , , and are illustrated prior to the installation of the detour hook, as well as after the installation of the detour hook as relocated and possibly adjusted second and third prolog instructions and in the hook thunk . In this example, the third prolog instruction will not be fully overwritten by the detour hook, but the relocated prolog instruction must nonetheless be copied in its entirety, as a partial instruction may not execute properly. The example fourth instruction of prolog code (after installation of the detour hook) may be the first whole instruction after the region of memory that will be overwritten by the detour hook, meaning it will not be overwritten within the target compiled method . The fourth instruction of prolog code is therefore persisted as an unmodified instruction after installation of the hook.","Prior to installation of the detour hook, the target compiled method  includes an example method body . The method body constitutes the operational portion of the target compiled method's code. As the target compiled method  includes a prolog of sufficient size to be overwritten by the detour hook, the hooked target compiled method  thus retains the original, unmodified method body after installation of the detour hook.","The target compiled method  includes example epilog code . A compiled method may include an epilog at each of its exits that reverses the operations of the prolog, such as unregistering an exception handler, restoring nonvolatile CPU registers, and releasing allocated stack space, among others. As illustrated, the hooked target compiled method  retains the original, unmodified epilog after installation of the detour hook.","As described, the target compiled method  illustrates the method after installation of detour hook. Arrow  represents an example start pointer demarcating the hook site  in the target compiled method . The start pointer  references the address at which the first byte of the hook site  begins. Arrow  is an example end pointer demarcating the hook site  in the target compiled method . The end pointer  references the address of the byte immediately following the last byte of the hook site . In this example, the start pointer  and end pointer  are computed by method  of . The space between the start pointer  and end pointer  is the example hook site  in the target compiled method. The hook site  in the hooked target compiled method  is represented by a bracket to the left of the memory elements that fall within it. It begins at the start pointer  address and ends immediately prior to the end pointer  address. The hook site  must cover an integral number of whole instructions, and in the example CPU architectures considered here, an instruction may comprise multiple bytes. Thus, the hook site  may be some number of bytes larger than is necessary to hold the detour hook  that is written over its initial portion. In this example, the hook site  includes an example partial instruction . In the case where the hook site  is larger than the detour hook , some bytes at the end of the hook site  may not be overwritten. As a result, some partial instruction bytes  no longer representing executable code may remain. Execution will not reach these vestigial bytes, and therefore they are harmless.","Example detour hook  consists of native code that branches to the hook thunk . The target compiled method  is hooked by overwriting the initial portion of the hook site  with an instruction or instruction sequence  that transfers execution to a hook thunk , as represented by a solid arrow. Thus, whenever the hooked target compiled method  is invoked, the hook thunk  will execute instead.","The example hook thunk  consists of native code to conditionally execute either the original target compiled method  or a replacement compiled method  based on whether a hook state indicates that the hook is disabled or enabled, respectively. If the hook is disabled, the hook thunk  executes the instructions , , and that were relocated from the hook site, before executing the unmodified remainder of the hooked target compiled method . To make the determination, example code  comprises native code to check the current hook state for this hook. In this example, the hook thunk  begins with code  that retrieves the contents of a thread-local storage (TLS) slot (or other suitable location) and checks a specific bit indicating the relevant hook state. With reference to other illustrations, the code  was emitted by method  at , , and . In some instances, the hook thunk  may be considered an intermediate layer of native code that executes between the hook  and a more developer-friendly replacement method or filter and is used to determine which operations and instructions to perform.","The hook thunk  contains an instruction or instruction sequence  that conditionally transfers execution to a replacement compiled method  if the hook is enabled, as represented by a solid arrow. Otherwise, execution continues to the instructions , , and relocated from the hook site when the hook state is not enabled (as illustrated by the dashed arrow). The hook thunk  also includes an additional instruction or instructions  that transfer execution to the end pointer address immediately following the hook site . After the relocated instructions , , and have been performed, the instructions  transfer execution to the next instruction within the original, unmodified portion of the target compiled method , allowing the method  to perform its original function. As illustrated, the instructions  may use an indirect call, a relative call, a relative jump, or a return jump to return to the associated target compiled method .","In the after hooking illustration, an example replacement compiled method  is illustrated. A primary purpose of the detour hook  and hook thunk  is to arrange for the replacement compiled method  to execute in place of a target compiled method  whenever the latter is invoked. A secondary purpose of the hook thunk  is to provide a means by which the replacement method  may execute the original target compiled method  as desired, as an alternative to completely reimplementing the target compiled method's functionality within the replacement method . However, in other instances a hook thunk may not exist, or it may enable a replacement method to execute the target compiled method's original functionality through other means, such as by supplying the replacement method with an appropriate delegate or pointer. Where the hook thunk  does not exist, the detour hook  may transfer execution directly to an identified replacement method, where, in some instances, the replacement method can optionally execute one or more of the instructions in the target compiled method  overwritten by the detour hook . In those instances, the replacement method may determine, using one or more global or instance-based variables within the system (i.e., a variable indicating a particular hook state or where the variable is used to accomplish execution, such as a delegate variable), whether the replacement instructions or original instructions are to be executed. As illustrated, the replacement compiled method  includes a prolog instruction , a method body , and an epilog instruction , although in various instances the replacement method  may consist of other sequences of instructions. As illustrated, the method body  includes an instruction  for calling the original target compiled method , where the call allows the hook state to be disabled after the instruction  is executed. In this manner, the replacement compiled method  may be executed once, and the original functionality executed thereafter.","The general format of a replacement method can be represented by the following C#-like pseudocode, although any suitable format would suffice:",{"@attributes":{"id":"p-0056","num":"0093"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"static ReturnType Hook_ImplementingTypeName"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"MethodName("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ImplementingType thisPtr,"]},{"entry":[{},"Argument1Type arg1,"]},{"entry":[{},"...)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"{"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ do pre-work"]},{"entry":[{},"ReturnType ret;"]},{"entry":[{},"DisableThisHook( );"]},{"entry":[{},"try"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ret = thisPtr.MethodName(arg1, ...);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"finally"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"EnableThisHook( );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},"\/\/ do post-work"]},{"entry":[{},"return ret;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In this case, the hooked target compiled method  is an instance method, which the .NET Framework calls as though the this pointer is its first argument. The replacement method is therefore written as a static method that explicitly accepts the this pointer as its first argument. In the above example, the replacement method does some work, calls the original hooked method with its original arguments, and then does more work and returns the result of the hooked method, assuming no exception occurs. However, it should be clear that the replacement method could call the hooked method many times or not at all, with arbitrary arguments or any number of other changes made to the execution environment, among countless other variations.","If the hooked method is non-public, the replacement method may invoke it via reflection (for instance, using System.Type.InvokeMember or System.Reflection.MethodBase.Invoke). If the hooked method has a return value of a non-public type, or accepts arguments of a non-public type, the replacement method may have to replace such types in its declaration with an appropriate, publicly-accessible type, such as System.Object or System.IntPtr.","To apply generically to all methods, including constructors, the original method can be retrieved using System.Type.GetMember or GetMembers (rather than using GetConstructor or GetConstructors, as GetMethod and GetMethods will not return a constructor), and the resulting System.Reflection.MemberInfo object can be cast to a System.Reflection.MethodBase (from which both MethodInfo and ConstructorInfo derive) so that the Invoke method can be called with the original target object specified. Calling ConstructorInfo.Invoke, on the other hand, will instantiate a new object rather than allow reinitialization of an existing object.","As described previously, the detour hook  replaces native code maintained internally by the Common Language Runtime (CLR). Modifying JIT compiled code may cause garbage collection roots (CPU registers and local variables that the garbage collector examines for object references) to hold unexpected values when the modified code is executing. Thus, it is possible for the program's state to become corrupted if garbage collection occurs during execution of modified JIT compiled code. To avoid this problem, garbage collection may be delayed, or the behavior of the garbage collector may be otherwise modified by various means and as necessary. For instance, a hook of the Windows GetThreadContext API function can detect if garbage collection is occurring during execution of a detour hook such as detour hook , based on the instruction pointer in the thread context that GetThreadContext retrieves. In such a case, the GetThreadContext hook may modify the retrieved thread context or return an indication of failure to the garbage collector in a way that delays garbage collection. In another instance, a hook of the Windows SuspendThread API function may likewise delay garbage collection by returning an indication of failure without first invoking the original SuspendThread function. Garbage collection may also be delayed by setting the appropriate field of a .NET Thread object, among other alternatives.","It will be understood that the methods described in  may include additional, fewer, or alternative elements and instruction sets in different implementations.  is an example, and is not intended to be limiting.",{"@attributes":{"id":"p-0062","num":"0099"},"figref":"FIG. 4","b":["400","401","400"]},"At , a determination is performed as to whether both methods are found. If both methods are found, method  continues at . If one or both of the methods cannot be found, method  moves to  where a failure notification or indication is returned. At , operations are performed to ensure that native code exists for both the target method and the replacement method, including forcing native code to be generated, as necessary.  provide additional detail into this process.","At , a determination is made as to whether native code exists for both methods. If so, method  continues at . If native code does not exist and could not be generated for either method, method  continues at . At , the addresses in memory of the native code for both the target compiled method and the replacement compiled method are identified and located. Further explanation of this operation is provided in . At , a determination is made as to whether both compiled methods are found or located. If not, method  continues to . If both are found, method  moves to .","At , a software hook redirecting execution from the target compiled method to the replacement compiled method is installed. The software hook may be initialized and installed using, for example, the methods described in . In some cases, the software hook may redirect execution to intermediate hook code, called a \u201chook thunk,\u201d that selectively executes one or more hook methods and may or may not execute the original target compiled method. At , a determination is made as to whether the software hook was properly installed. If not, method  continues at  to indicate the failure, but if properly installed, method  continues to . Causes of hook installation failure may include low physical or virtual memory conditions, the presence of code in the target compiled method that is incompatible with hooking, or a busy multithreaded environment that prevents thread-safe hooking in a timely fashion, among others.  provides an example method for safely installing the software hook in a multithreaded environment.","In many cases, a replacement method may want to observe calls to the target method and optionally modify the attendant behavior while still allowing the function of the target method to be performed. In such cases, it is generally preferable to execute the original target method, optionally with modified argument values or execution state, rather than reimplement its function in the replacement method. Thus, at , a mechanism is initialized by which the replacement compiled method may execute the original target compiled method, although it should be noted that such a mechanism need not exist in some instances and alternative implementations. At , an indication of successful installation is returned.",{"@attributes":{"id":"p-0067","num":"0104"},"figref":["FIG. 5A","FIG. 4"],"b":["403","403"]},"At , a target or replacement method associated with the hook installation that is to be forced to compile is identified. In one instance, the particular method could be identified by name and signature, while in another, it could be represented by a System.Reflection.MethodBase object, among others. At , the operations check if the current version of the .NET Framework provides the System.Runtime.CompilerServices.RuntimeHelpers class, which can be used to initiate JIT compilation of an arbitrary method. The check can be performed by various means, such as by checking that the .NET Framework version is at least 2.0, or by attempting to access the RuntimeHelpers type by name via reflection, among others. At  a determination is made as to whether the RuntimeHelpers class was found. If found, method  continues at ; otherwise, method  moves to  to try an alternative approach. However, in some cases it may be desirable to use the alternative approach even if the RuntimeHelpers class is found\u2014for instance, in the case of a method of a value type for which an unboxing stub is created when JIT compilation is initiated using the alternative approach.","At , the PrepareMethod method of the RuntimeHelpers class is called with a handle representing the method identified at  supplied as an argument. The operations can use reflection to obtain a reference to the RuntimeHelpers type and invoke its PrepareMethod method, as statically referencing the RuntimeHelpers type would make the implementation incompatible with versions of the .NET Framework prior to version 2.0. The PrepareMethod method does not return any indication of success or failure, so it is assumed to have succeeded unless it throws an exception. If the call to PrepareMethod resulted in an exception, method  continues at  to indicate failure. If no exception occurred during the call, then method  continues at  to indicate success. If the alternative of  is used, an attempt to provoke JIT compilation of the method identified at  is made by invoking the identified method. An example invocation is illustrated and described in . At , the result of the attempted invocation (success or failure) is returned.",{"@attributes":{"id":"p-0070","num":"0107"},"figref":"FIG. 5B","b":["506","510"]},"At , a determination is made as to whether the method identified at  is sufficiently defined to allow it to be invoked. In this example, a System.Reflection.MethodBase object representing the method is obtained, and its IsAbstract and ContainsGenericParameters properties are consulted. If IsAbstract is true, the method is not implemented by the type of which it is a member (for instance, the type may be an abstract class or an interface). If ContainsGenericParameters is true, the method and\/or the type of which it is a member contains one or more type parameters that have not been specified, and therefore the method cannot be invoked. (For compatibility with versions of the .NET Framework prior to version 2.0, it may be necessary to read the ContainsGenericParameters property using reflection, if it exists.) If either property is true, method  moves to  to indicate failure. If both properties are false, method  continues at .","At , a determination is made as to whether the method identified at  is an instance method or a static method. In this example, a System.Reflection.MethodBase object representing the method is obtained, and its IsStatic property is read. If the property is true, then the method is a static method, and method  moves to . Otherwise, the method is an instance method, so method  continues at  to perform additional steps necessary to enable invocation of the method. At , an initial selection is made of the type that implements the method identified at  (determined, for instance, by consulting the System.Reflection.MemberInfo.ReflectedType property of an object representing the method). Other types may be selected, so a data structure that tracks selected types may be initialized at  as well.","The operations of  constitute the beginning of a loop in method . At , a determination is made as to whether the currently selected type is an abstract type. In this example, the System. Type.IsAbstract property of an object representing the selected type is read. If IsAbstract is true, then the selected type is an abstract type and therefore cannot be instantiated, so method  continues at  where another iteration of the loop is performed. If IsAbstract is false, method  continues at .","At , an attempt is made to select a derived type of the implementing type initially identified at . To ensure that the type selected at  has not previously been selected, a data structure that tracks previously selected types may be consulted. In the event that every qualifying type has been selected previously, no type is selected. At , if a type was selected at , method  moves to  to perform another iteration of the loop. Otherwise, method  moves to  to indicate failure, as an instance method cannot be invoked without an instance of a type that implements it.","At , an attempt to instantiate the selected type is made by invoking one of its constructors. In one instance, default values such as null and zero may be supplied if the constructor accepts any arguments. In the event that invocation of the constructor fails or throws an exception, another constructor is invoked, until either a constructor succeeds or all constructors have been invoked and failed. A successful invocation of a constructor creates an instance of the selected type. At , a determination is made as to whether an instance of the selected type is created. If an instance of the currently selected type was created, method  moves to ; otherwise, method  moves to  to perform another iteration of the loop. At , an indication that the instance method identified at  could not be invoked is returned, as no instance of the implementing type or a derived type could be created. In some cases, it may be desirable to programmatically generate and instantiate a derived type of the type identified at  using reflection\u2014for instance, if the type identified at  is abstract and no suitable derived type is created in the loop of method .","At , all code access security permissions except for reflection and any declarative security demands that must be satisfied to invoke the method are explicitly denied. Denying security permissions prior to the invocation reduces the chance that execution of the method will result in side effects. Reflection permission, however, is not denied, as it may be needed to invoke the method in some instances. At , the method identified at  is invoked using reflection. If the method is an instance method, the type instance created at  is specified as the target object. In one instance, default values such as null and zero may be supplied if the method accepts any arguments. As the goal is to provoke JIT compilation of the method while minimizing the incidence of side effects, it is sufficient for execution of the method to begin only; it does not need to complete. Denying code access security permissions at  and passing null argument values increases the chance that execution of the method, once it begins, will subsequently return quickly or throw an exception, but in any case, the method will have been JIT compiled. At , a determination is made as to whether the invocation and\/or compiling succeeded or not. If invocation succeeded (which is to say that System.Reflection.MethodBase.Invoke, for instance, succeeded, not that the invoked method necessarily succeeded), or if invocation resulted in an exception indicating that the invoked method itself threw an exception after commencing execution (for instance, an exception of type System.Reflection.TargetInvocationException), then the method identified at  is assumed to have executed and is therefore JIT compiled. In this case, method  continues at  to indicate success. If invocation failed or threw an exception that does not suggest that the method executed at all, then method  moves to  to indicate failure. At , an indication that execution of the method identified at  was successfully initiated is returned, meaning the method has been JIT compiled. At , an indication that the method identified at  was not executed is returned, meaning that the method may not be JIT compiled.",{"@attributes":{"id":"p-0077","num":"0114"},"figref":["FIG. 6A","FIG. 4"],"b":["405","405","405","601"]},"At , an attempt to locate the compiled method is performed directly. In the illustrated example, a handle for the method identified at  is retrieved by reading the System.Reflection.MethodBase.MethodHandle property, and then the GetFunctionPointer method of the retrieved System.RuntimeMethodHandle object is called. The returned value is a native integer expressing the address of native code associated with the compiled method, although it may not necessarily be the entry point of the compiled method itself. At , a determination is made as to whether the address obtained at  is an address of executable code. In some instances, making this determination may entail checking the permissions of memory at the obtained address (for example, by using the Windows VirtualQuery API). If it is sufficiently likely that the address is an address of executable code, method  continues at . If the address is unlikely to be an address of executable code\u2014including, for example, if the GetFunctionPointer method returned a null address or threw an exception to indicate failure\u2014method  moves to  to try another approach.","At , the instructions at the address obtained at  are examined. The surrounding bytes and numerical properties of the address may also be considered. If the instructions appear to constitute stub code, the address is advanced to the destination of the stub. If the instructions do not resemble a recognized stub, the address is not updated. In this example, the operations illustrated in  can be used to inspect and update the address. At , a determination is made as to whether the address produced at  is the entry point of the compiled method identified at . In one instance, the address may be assumed to correspond to the entry point if the instructions at the address do not match a recognized stub format. In another instance, the address may be considered the entry point only if the instructions at the address resemble expected prolog code. For example, the metadata or bytecode of the method may be used to guide expectations of features that should be present in the prolog code, such as an estimate of how much stack space will be allocated. In some cases, such as on 64-bit platforms, it may be possible to use exception handling data to determine whether or not an address falls within a compiled method. Other alternatives are possible as well. If the address is determined to be the entry point of the compiled method, method  continues at  to indicate success; otherwise, method  moves to  to try another approach. At , an indication that the entry point was successfully located, and moreover, that it was determined to be the address produced at , is returned.","At , an attempt to locate the compiled method via its method descriptor is made. In this example, a handle for the method identified at  is retrieved by reading the System.Reflection.MethodBase.MethodHandle property, and the address of the corresponding method descriptor is obtained from the System.RuntimeMethodHandle.Value property. At , a determination is made as to whether the method descriptor located at  is accompanied by an address of executable code. In some instances, the method descriptor may be an eight-byte structure followed by a pointer to the compiled method generated by JIT compilation. If the method descriptor includes or is accompanied by an address of executable code, then method  continues at . If no code address accompanies the method descriptor, or if the address of the method descriptor could not be obtained, method  moves to .","At , the instructions at the code address accompanying the method descriptor are examined. As at , the address may be updated based on the examined instructions. If the address produced at  is determined (at ) to correspond to the entry point of the compiled method identified at  (i.e., according to the same tests applied at ), then method  moves to  to indicate success. Otherwise, method  continues at .","If the method descriptor located at  contains a value in its slot index field that appears to be valid, method  moves to  to try a third approach for locating the compiled method. Otherwise, method  moves to  to indicate failure. At , method  indicates that no approach produced an address corresponding to the entry point of the compiled method identified at . At , method  identifies the type that implements the method identified at  and retrieves the address of the type's method table. In this example, a handle representing the type is first retrieved by reading the System.Type.TypeHandle property, and then the address of the method table is obtained from the System.RuntimeTypeHandle.Value property. Alternatively, a snitch method could be used to locate an instance of the identified type in memory, which would then permit a pointer to the method table to be retrieved. A snitch method is one way to obtain the precise internal address of a .NET object. In one implementation, a snitch method may receive a number of arguments, with some arguments taking on distinct signature values and other arguments bearing references to an object to be located. Such a method may read its own stack frame from memory, for instance using interop functionality. The method may then identify which memory locations in the stack frame contain the distinct signature values, and thereby determine which memory locations in the stack frame contain the object references, i.e., pointers to the object. The foregoing description assumes that the relevant arguments of the snitch method are pushed or spilled into stack memory. Other alternatives are possible as well. If the slot index of the method descriptor obtained at  appears to be valid according to various fields of the method table (as determined at ), then method  continues at . Otherwise, method  moves to  to indicate failure.","At , an attempt to retrieve the contents of the slot in the method table (located at ) indexed by the method descriptor (located at ) is performed. In some instances, the slot contains a pointer indicating the address of native code associated with the compiled method, while in other instances, the contents of the slot may instead be an offset from the address of the slot itself, in which case a code address must be computed. At , a determination is made as to whether the address obtained or computed at  is an address of executable code (e.g., according to the tests applied at ). If so, method  continues at ; otherwise, method  moves to  to indicate failure. At , method  examines the instructions at the code address produced at . As described at , the address may be updated based on the examined instructions. If the address produced at  is determined at  to correspond to the entry point of the compiled method identified at  (i.e., according to the same tests as were applied at ), then method  continues at  to indicate success. Otherwise, method  moves to  to indicate failure. At , method  indicates that the entry point of the compiled method identified at  was successfully located, and moreover, that it was determined to be the address produced at . Alternatively, at , method  indicates that no approach produced an address corresponding to the entry point of the compiled method identified at .",{"@attributes":{"id":"p-0084","num":"0121"},"figref":["FIG. 6B","FIG. 6A"],"b":["604","604","609","617","604"]},"At , an address of native code is identified for examination. The determination of  corresponds to the beginning of a loop in method . At , a determination is made as to whether the instructions at the code address appear to constitute stub code. If so, method  continues at ; otherwise, it moves to . At , a determination is made as to whether the instructions match a recognized stub format from which a destination address can be ascertained. If so, method  continues at  to perform another iteration of the loop. Otherwise, method  moves to  to indicate failure. At , the code address is advanced to the destination address of the stub code, and method  returns to  to perform another iteration of the loop. In some instances, there may also be useful data near the stub code, with code and data collectively constituting the stub.","At , a determination is made as to whether the instructions at the code address resemble expected prolog code or otherwise constitute the entry point of a compiled method, for instance, according to the same tests applied at . If so, method  continues at  to indicate success; otherwise, it moves to  to indicate failure. At , an indication that the code address identified at  (and possibly updated any number of times at ) corresponds to the entry point of a compiled method is returned. As suggested at , many tests to determine if an address corresponds to an entry point are possible. Alternatively, at , an indication that method  was unable to arrive at a code address that appeared to correspond to an entry point of a compiled method is returned.",{"@attributes":{"id":"p-0087","num":"0124"},"figref":["FIG. 7A","FIG. 4"],"b":["407","407","407"]},"At , a target compiled method to hook is identified. In this example, the target compiled method is identified by the memory address of its entry point, although other alternatives are possible. At , memory in which to store the native code constituting a hook thunk is allocated. The memory should be writable, at least initially, so that instructions can be stored there. Once the memory has been filled, it can be marked as executable so that the hook thunk code it contains can execute. In some instances, an overestimated or maximum amount of memory that the size of the hook thunk will not exceed may be allocated. In other instances, the memory may be allocated after the size of the hook thunk has been determined, although in some cases the size of the hook thunk may be influenced by the address at which it is located. In some instances, the memory may be allocated from a special executable heap, in which multiple hook thunks may share a single page of virtual memory in order to conserve the process's address space. In other instances, memory for each hook thunk may reside in its own page or pages of virtual memory.","At , start and end pointers demarcating the hook site in the compiled method are computed. Once the memory address of the hook thunk is known, it is possible to calculate the minimum size in bytes of a detour hook sufficient to redirect execution from the target compiled method to the hook thunk. In this example, method  of  may be used to generate detour hook code which is measured and then either discarded or retained for use at . Given the entry point of the target compiled method and the number of bytes that will be overwritten by the detour hook, method  delineates a hook site in the native code of the target compiled method, with at a start pointer indicating the first byte of the hook site and an end pointer indicating the first byte after the hook site. In this example, method  of  is used to compute the start and end pointers. If a sufficient hook site was delineated (as determined at ), method  continues at . If the native code at the target compiled method's entry point cannot accommodate a detour hook of the required size, method  moves to  to indicate failure.","At , native code implementing the hook thunk is generated and stored in the memory allocated at . In this example, method  of  is used to generate the hook thunk code. Method  requires specification of a replacement compiled method, and therefore the same must be supplied to method . At , native code constituting the detour hook is generated (e.g., using method  of ), or the native code for the detour hook previously generated at  is retrieved. The native code is then written to the hook site delineated at . In this example, method  of  is used to install the detour hook in a thread-safe manner.","If the detour hook was successfully installed at  (as determined at ), then method  continues at  to indicate success. If the detour hook could not be installed, method  moves to  to indicate failure. At , an indication that a detour hook was installed at the entry point of the target compiled method to redirect execution to a newly generated hook thunk that conditionally executes a given replacement compiled method is returned. At , an indication that a detour hook could not be installed at the entry point of the target compiled method is returned.",{"@attributes":{"id":"p-0092","num":"0129"},"figref":["FIG. 7B","FIG. 7A","FIG. 7C"],"b":["703","710","712","711","703","711","703","712","703","713","712","711","713","703","407","713"]},"At , the end pointer is initialized to equal the start pointer, which was initialized at  and possibly updated any number of times at . The end pointer may be updated at  in the loop that follows. The operations of  constitute the beginning of a second loop in method . At , method  decodes the instruction currently referenced by the end pointer. Decoding an instruction is a CPU instruction set-dependent operation; on the x86 and x64 architectures, it may involve determining an instruction's prefixes, opcode, postbytes, offset value, and immediate values, as applicable. At , a determination is made as to whether the instruction decoded at  can be safely relocated as part of detour hook installation. In this example, many instructions are deemed unsafe to relocate if overwriting the instruction or executing it from a different address could cause an undesired exception or a violation of other code's understanding of the execution environment. For example, relocating a relative branch instruction will likely cause an exception when that instruction is later executed, unless the instruction is adjusted to compensate for the relocation. As another example, relocating a division instruction or an instruction generated by the JIT compiler to test for a null object reference could cause exception handling to fail in the event that the instruction faults, because the relocated instruction would not be executing in an address range recognized by the runtime. If the instruction decoded at  can be safely relocated, method  continues at . Otherwise, method  moves to  to indicate failure. At , the end pointer is advanced to the address immediately following the decoded instruction. If the address of the end pointer is at least the required number of bytes after the address of the start pointer (as determined at ), where the number of bytes is the size calculated at , then method  moves to  to indicate success. If the address of the end pointer is fewer than the required number of bytes after the address of the start pointer, then method  continues at .","At , a determination is made as to whether the instruction decoded at  is terminal (i.e., if instruction decoding can continue past the instruction). In this example, decoding ends after an unconditional branch, return, or call instruction is decoded, because it cannot easily be determined if valid code follows such instructions, although alternative implementations may not be so limited. In the case of a call instruction, decoding ends after the instruction both because the callee could be declared noreturn (meaning execution will never return from the callee to the instruction after the call), and because the call instruction will be rewritten as a sequence consisting of a push instruction followed by an unconditional jump instruction at - and - of . If the decoded instruction is terminal in this sense, method  moves to  to indicate failure, because an insufficient number of bytes were decoded, and yet decoding cannot continue past the terminal instruction. If the decoded instruction is not terminal, method  moves to  to perform another iteration of the second loop. At , an indication that the start and end pointers were computed successfully for the given compiled method is returned. At , an indication that start and end pointers demarcating a hook site of a sufficient size could not be computed for the given compiled method is returned.",{"@attributes":{"id":"p-0095","num":"0132"},"figref":["FIG. 7C","FIG. 7B"],"b":["713","713","703","703","702"]},"At , the CPU instruction set used by application code executing in the current process is identified. In the illustrated example, all application code in a particular process is assumed to use a single instruction set, even though operating system code (such as the Windows on Windows emulation layer for 64-bit platforms) may use a different instruction set. In this example, it is sufficient for a software implementation of method  to determine the instruction set used by its own native code. This information can be retrieved with a run-time check, or it can be hard-coded at compile time through the use of preprocessor directives, among other alternatives. At , a determination is made as to whether the instruction set identified at  is 32-bit x86 (also known as IA32 or IA-32). If so, method  continues at ; otherwise, method  moves to . In this example, a five-byte relative jump is sufficient to transfer execution from any address to any other address in a 32-bit x86 environment. Thus, at , method  emits such a relative jump instruction, encoded as an E byte representing the opcode, followed by a 32-bit integer expressing the difference between the given hook thunk address and the address that will immediately follow the instruction once it is written at the start pointer address (i.e., (hook thunk address\u2212(start pointer address+5)). Implicit 32-bit integer truncation ensures that the relative jump instruction will arrive at the correct destination address regardless of whether the result of the calculation is positive or negative or would cause an arithmetic carry or borrow. Method  then moves to  to indicate success.","At  a determination is made as to whether the instruction set identified at  is 64-bit x64 (also known as x86-64, AMD64, Inte164, EM64T, and IA-32e). If so, method  continues at ; otherwise, method  moves to  to indicate failure, or, alternatively, address other CPU-specific determinations. At , the offset needed to construct a five-byte relative jump that transfers execution from the start pointer address to the hook thunk address is computed. The offset is the difference between the given hook thunk address and the address that will immediately follow the instruction once it is written at the start pointer address (i.e., (hook thunk address\u2212(start pointer address+5)), although in this case, all quantities are 64-bit signed integers). At , a determination is made as to whether the offset computed at  can be represented in 32 bits. If the offset falls within the interval [\u22120x80000000, +0x7FFFFFFF], then it can be expressed as a 32-bit integer, so method  moves to  to emit a comparatively size-efficient, five-byte relative jump. For any other offset, method  continues at  to consider alternative instruction sequences. If the hook thunk address can be expressed as a positive, 32-bit signed integer (as determined at )\u2014in other words, if it falls within the interval [0, +0x7FFFFFFF]\u2014then method  continues at , otherwise it moves to . At , a five-byte push-immediate instruction followed by a single-byte return instruction, for a total of six bytes of code, is emitted. This instruction sequence allows an execution transfer to an arbitrary 31-bit address, although in terms of space, it costs one byte more than a five-byte relative jump. Method  then moves to  to indicate success.","At , a ten-byte instruction that loads the RAX register with an arbitrary address, followed by a two-byte indirect jump instruction that accomplishes the execution transfer to that address, is emitted. Although this instruction sequence allows execution to be transferred to any valid 64-bit address, its relatively large size may prohibit hooking in some situations, and it irrevocably overwrites the original contents of the RAX register, which may not be safe in all cases. Alternative x64 instruction sequences are possible but are omitted from  for the sake of clarity. For example, a six-byte, RIP-relative indirect jump instruction followed by an eight-byte code pointer could transfer execution to an arbitrary 64-bit address without modifying RAX, although it requires a fourteen-byte hook site. After emitting the instructions, method  continues at  to indicate success.","At , an indication that the desired detour hook code was generated successfully is returned. In some instances, the indication may include the detour hook code or an address pointing thereto. At , an indication that the current instruction set is not supported is returned, or other CPU-specific operations may be performed. In this example, only the x86 and x64 instruction sets are supported, although additional instruction sets such as Intel Itanium (IA64 or IA-64) could be supported as well in alternative implementations.",{"@attributes":{"id":"p-0100","num":"0137"},"figref":"FIG. 7D","b":["705","705","705"]},"At , an address of memory in which to store the generated hook thunk code is identified. At , native code that preserves volatile argument registers is generated. For instance, code generated for the 32-bit x86 architecture preserves the contents of the ECX and EDX registers, which are used in the _clrcall and _fastcall calling conventions for passing arguments, but which are generally not preserved by subroutines of any calling convention. Code generated for the 64-bit x64 architecture, meanwhile, preserves the contents of the RCX, RDX, R8, and R9 registers, as these registers are used for arguments but are not required to be preserved, according to the x64 Application Binary Interface specification. Other general-purpose registers of either architecture are not typically expected to contain any meaningful value upon entry to a subroutine, so the example code generated at  does not preserve them unless they are nonvolatile by convention and will be temporarily modified elsewhere in the hook thunk code. In this example, a register is preserved by pushing its contents onto the stack before the first instruction or call that could modify the register, and popping the preserved contents from the stack into the register after the last instruction or call that could access the register. In this example, the only portion of hook thunk code that could modify volatile argument registers is a call to the TlsGetValue API, which is generated at .","At , code that retrieves the applicable hook state from thread-local storage (TLS) is generated. For purposes of this example, hook state is meant to refer to data indicating whether a hook thunk should transfer execution to a replacement compiled method (i.e., if the hook is enabled) or to the original target compiled method (i.e., if the hook is disabled). In this example, hook state is maintained as bits in a TLS slot accessed via the TlsGetValue Windows API function, although a TLS slot could be used to instead reference a data structure, or ThreadStatic variables, global variables, or other alternatives could be used. For purposes of this example, each TLS slot is considered to comprise 32 bits, and thus, an application that deploys more than 32 hooks must group them so that multiple hooks are jointly enabled or disabled by a single hook state bit. Groups of methods that will never directly or indirectly call or be called by one another may share a hook state bit. At , native code is generated that restores the contents of the volatile argument registers preserved by the code generated at .","At , native code is generated that transfers execution to the replacement compiled method if the hook state retrieved by the code generated at  indicates that the hook is enabled. If the hook is disabled, the generated code instead executes the original target compiled method by transferring execution to the displaced code that will be emitted at  and subsequently adjusted. At , a copy of the original code from the hook site in the target compiled method is emitted. Since the code in the hook site will be overwritten by a detour hook, a copy of that code is to be retained so that it can be executed as a prerequisite to executing the rest of the original target compiled method. However, the copy of the hook site code will not be executing at its original address, so certain adjustments may need to be made. These adjustments are the subject of the remainder of method ; however, it should be understood that method  describes an example set of adjustments, and that other adjustments not described in method  may apply to various instructions of various CPU architectures. In some instances, an unadjusted copy of the hook site code may also be maintained, so that a hooked method may be unhooked simply by restoring the hook site to contain the original bytes of the unadjusted copy. In other instances, the adjustments may be reversed at runtime instead of maintaining separate adjusted and unadjusted copies of the hook site code.","At , the last instruction of the original hook site code emitted at  is decoded. Method  continues at  to begin adjusting the instruction as appropriate. In this example, adjustments suitable for the x86 and x64 architectures are considered, although it should be understood that related techniques may apply to other CPU architectures. At , a determination is made as to whether the instruction decoded at  is an indirect call, such as a call to an address stored in a register or memory location. If so, method  continues at  to adjust the instruction. Otherwise, method  moves to .","At , native code is inserted prior to the instruction decoded at , where the inserted instruction pushes an artificial return address onto the stack. The end pointer computed at  (using, for example, method  of ) references the address immediately following the last instruction included in the hook site, which is the return address that would have been pushed if the call instruction had been executed from its original location. Therefore, the end pointer address is pushed as the artificial return address. On the x86 architecture, for instance, a five-byte push-immediate instruction may be emitted, while on the x64 architecture, a twelve-byte sequence to load and push the RAX register may be emitted, among other alternatives. At , the instruction decoded at  is changed from an indirect call to an indirect jump with equivalent arguments by replacing its opcode. In some cases, however, the call instruction may need to be adjusted further, such as if it is an x64 instruction that uses RIP-relative addressing. Thus, the call instruction is replaced by native code to push an artificial return address (emitted at ) followed by a jump instruction that transfers execution to the original destination of the call, which together emulate the operation of the original call instruction. Method  then moves to  to indicate completion and return the generated hook thunk code.","At , a determination is made as to whether the instruction decoded at  is a relative call. If so, method  continues at  to adjust the instruction. Otherwise, method  moves to . At , native code to push the end pointer address is inserted prior to the instruction decoded at . At , the relative call or relative jump instruction decoded at  is replaced with native code that transfers execution to the original destination of the instruction, as relocating a relative call or relative jump changes its destination. On the x86 architecture, an instruction of either type can simply be replaced by a five-byte relative jump with an adjusted offset, while on the x64 architecture, various instruction sequences may be possible based on the source and destination addresses. Method  then moves to  to indicate completion.","If the instruction decoded at  is a relative jump (as determined at ), method  moves to  to adjust or replace the instruction. Otherwise, method  continues to . If the instruction decoded at  is a return instruction or an indirect jump, such as a jump to an address stored in a register or memory location, as determined at , then method  moves to  to indicate completion without emitting any additional code. Otherwise, method  continues to  to emit additional code. At , native code is emitted that transfers execution to the end pointer address, which is the address immediately following the last instruction of the hook site. Here, it is known that a hook site was successfully demarcated, and that the final instruction in the hook site is not a call, jump, return, or other terminal or invalid instruction, so it is assumed that execution will continue from the last instruction of the hook site to the first instruction after the hook site. Thus, an instruction or instruction sequence to transfer execution to the first instruction after the hook site is appended to the adjusted copy of hook site code. Method  then continues to  to indicate completion. At , method  completes by returning the generated hook thunk code.",{"@attributes":{"id":"p-0108","num":"0145"},"figref":"FIG. 7E","b":["706","750","751","706","751","751"]},"At , the current thread context of each suspended thread is retrieved (e.g., by calling the GetThreadContext API function). Rather than retrieving the contexts of all suspended threads at once, it is sufficient to retrieve one thread's context and then examine it at  before retrieving the next thread's context. If a thread is determined at  to have been executing in the hook site, method  can then move to  without examining any other thread's context. At , a determination is made as to whether any suspended thread's context retrieved at  indicates that the thread was suspended while executing within the hook site, according to the instruction pointer recorded in the context. If the instruction pointer address is not less than the start pointer address of the hook site and is less than the end pointer address of the hook site, then the thread was executing within the hook site, and method  continues at . Otherwise, method  moves to  to install the hook.","At , method  resumes all threads suspended at , and also disables the wait condition blocking new threads if one was activated at . In instances where a watchdog thread was started at , the watchdog thread may be signaled by the current thread to resume all suspended threads and unblock new threads. At , a determination is made as to whether an excessive number of attempts (iterations of the loop in method ) have been made to suspend threads such that no thread is suspended while executing in the hook site. If so, then method  moves to  to indicate failure, rather than repeating indefinitely. Otherwise, method  moves to  to perform another iteration of the loop. At , the operations may optionally take a delay or \u201csleep\u201d for a short interval of time to offer any threads that are executing in the hook site a chance to leave it. It is possible threads may not leave the hook site during this time, or that other threads may enter the hook site. Therefore, method  returns to  to perform another iteration of the loop.","At , it is known that all threads of the current process, other than the current thread and any watchdog thread created at , are suspended or blocked while executing outside of the hook site, and therefore it is safe to install the given detour hook at the hook site. In this example, the memory containing the hook site is made writable using the VirtualProtect API function, then the native code generated by method  of  for the detour hook is written over the hook site, the original memory permissions of the hook site are restored with another call to VirtualProtect, and the FlushInstructionCache API function is called to ensure that no processor retains the unhooked code in its cache. In some instances, the hook site may be larger than the detour hook, so it may not be necessary to operate upon the memory at the end of the hook site that is not overwritten by the detour hook. At , as at , all threads suspended at  are resumed, and the wait condition blocking new threads is disabled if one was activated at . At , an indication that the detour hook was successfully installed at the hook site is returned. Conversely, at  an indication that the detour hook could not be safely installed at the hook site is returned.","While various implementations are described in this specification, various alternatives are available and can be used. These and other alternatives are considered in addition to those examples described herein. For example, different alternatives exist for ensuring that native code exists in memory for a particular method, including the alternative of calling the JIT compiler directly. For example, the getJit export of the JIT library provides access to the JIT compiler interface, where the CILJit::compileMethod or PreJit::compileMethod function could be called to JIT compile a method by providing its bytecode.","Alternatives for locating in memory the native code of a compiled method also exist. For example, alternative means of retrieving a code pointer associated with a compiled method are available, including the use of a delegate. Once a new System.Delegate representing the method of interest has been instantiated, the delegate object's private _methodPtr and _methodPtrAux fields can then be accessed via reflection. Further, the .NET profiling API exposes functions such as ICorProfilerInfo2::GetCodeInfo2 that allow a profiler to obtain the address of a compiled method's native code; however, such functionality can only be used by a .NET profiler. Hooking the JIT compiler's compileMethod function could also provide a vantage point for locating the native code of a compiled method, although the function (and therefore the hook) may not be invoked for all methods of interest (precompiled methods, for example).","Although platform-provided means are preferable, approaches that extract internal information by unsupported means are possible. For example, one alternative means of discovering a method's entry point is to pass a delegate representing that method to an unmanaged function, which must then deconstruct the delegate data structure and\/or the unmanaged-to-managed thunk in order to locate the compiled method of interest. Managed code could first call a snitch method with a long list of arguments, some of which reference an object of interest while others serve as distinct signatures. The snitch method could then call an \u201cunsafe\u201d or unmanaged method that reads, or enables the snitch method to read, stack memory for the purpose of locating the argument list, which is accomplished by scanning stack memory for the signatures. The object reference could then be retrieved from beside or among the signatures. In many cases, interop methods, such as those of the System.Runtime.InteropServices.Marshal class, can be used as well as unmanaged functions. With the internal address of the managed object, it is possible to read the object's member fields or locate its method table.","Still further, one approach for locating native code may comprise scanning the JIT code heap for native code matching a particular signature associated with the method of interest, based on characteristics of the method known to the developer or determined by analyzing the method's bytecode. Such characteristics may include the number of arguments, distinct integer and string constants used in the method, and calls made by or to the method. Still other means of locating native code may include using .NET Framework-provided debugging libraries such as MSCORDACWKS.DLL and SOS.DLL.","Additional methods of modifying the native code of the target compiled method to redirect execution to the native code of the replacement compiled method may be available. For example, if the replacement method entirely replaces the target method, in that the original target method will never need to be invoked, then several possibilities exist. The simplest consists of hooking the target compiled method with a branch directly to the replacement compiled method, rather than a branch to a hook thunk. Alternatively, if the replacement compiled method is no larger than the target compiled method, then the target compiled method could instead be overwritten by the native code of the replacement. Instruction pointer-relative offsets in the replacement code would need to be adjusted, or the embodying instructions would need to be translated, which could increase the size of the code in some instances and therefore require more adjustment. Code pointers, such as those of a compiled switch statement, may also be identified and adjusted. Furthermore, to prevent garbage collection from corrupting the program's state, the garbage collector's understanding of the region of overwritten code should be modified, or alternatively, garbage collection can be postponed whenever the replacement method is on the call stack. Exception information likewise should be updated or superseded by custom handling. In another example, instead of a detour hook that implements a branch, a target compiled method could be hooked with an invalid instruction, a software interrupt, a hardware breakpoint, or even a guard page, among other possibilities.","Alternatives and options for providing facilities and operations by which the replacement method can invoke the original code of the target compiled method may also be available. For instance, the replacement method may be provided with a Delegate or System.Reflection.MethodBase object that allows invocation of the original target compiled method, starting at the displaced code rather than at the hooked entry point. With the ability to execute the original target compiled method through a specially-purposed object, the concept of \u201chook state\u201d would become obsolete, as the replacement method would not need to temporarily disable the hook in order to execute the original implementation of the target compiled method. The object could be passed to the replacement method by the hook thunk in the form of an additional argument, although this may require the hook thunk to shift the intercepted arguments in order to insert a new one. The object could also be stored in a static field, or in a global data structure that the replacement method would access using some hook-specific identifier as a key, in order to look up the relevant object.","Alternatively, a different hooking model where the replacement method serves more as a filter could be implemented. In this model, the target compiled method would still be hooked with a branch to a hook thunk, but the hook thunk would then call a \u201cpre-filter\u201d method, which would have the opportunity to examine and modify function arguments and other execution state before the original target method executes, or it could request that the hook thunk return a particular value directly without invoking the original target method at all. If the pre-filter does indicate that processing should continue, the hook thunk calls the original target method, and then passes the return value and original arguments (for reference) to a \u201cpost-filter\u201d method, which may change the return value as desired. Other suitable alternatives can be used or included in the methods and systems of the present disclosure as appropriate.","Implementations of the subject matter and the functional operations described in this specification can be implemented in digital electronic circuitry, or in computer software, firmware, or hardware, including the structures disclosed in this specification and their structural equivalents, or in combinations of one or more of them. Implementations of the subject matter described in this specification can be implemented as one or more computer program products, i.e., one or more modules of computer program instructions tangibly stored on a non-transitory computer readable storage device for execution by, or to control the operation of, data processing apparatus. In addition, the one or more computer program products can be tangibly encoded in a propagated signal, which is an artificially generated signal, e.g., a machine-generated electrical, optical, or electromagnetic signal, that is generated to encode information for transmission to suitable receiver apparatus for execution by a computer. The computer readable storage device can be a machine-readable storage device, a machine-readable storage substrate, a memory device, or a combination of one or more of them.","The terms \u201cprocessor\u201d and \u201cdata processing apparatus\u201d encompass all apparatus, devices, and machines for processing data, including by way of example a programmable processor, a computer, or multiple processors or computers. The apparatus can include, in addition to hardware, code that creates an execution environment for the computer program in question, e.g., code that constitutes processor firmware, a protocol stack, a database management system, an operating system, a cross-platform runtime environment, or a combination of one or more of them. In addition, the apparatus can employ various different computing model infrastructures, such as web services, distributed computing and grid computing infrastructures.","A computer program (also known as a program, software, software application, script, or code) can be written in any form of programming language, including compiled or interpreted languages, declarative or procedural languages, and it can be deployed in any form, including as a standalone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program does not necessarily correspond to a file in a file system. A program can be stored in a portion of a file that holds other programs or data (e.g., one or more scripts stored in a markup language document), in a single file dedicated to the program in question, or in multiple coordinated files (e.g., files that store one or more modules, sub programs, or portions of code). A computer program can be deployed to be executed on one computer or on multiple computers that are located at one site or distributed across multiple sites and interconnected by a communication network.","The processes and logic flows described in this specification can be performed by one or more programmable processors executing one or more computer programs to perform functions by operating on input data and generating output. The processes and logic flows can also be performed by, and apparatus can also be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random access memory or both. The essential elements of a computer are a processor for performing instructions and one or more memory devices for storing instructions and data. Generally, a computer will also include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. However, a computer need not have such devices. Moreover, a computer can be embedded in another device, e.g., a mobile telephone, a personal digital assistant (PDA), a mobile audio or video player, a game console, a Global Positioning System (GPS) receiver, or a portable storage device (e.g., a universal serial bus (USB) flash drive), to name just a few. Devices suitable for storing computer program instructions and data include all forms of nonvolatile memory, media and memory devices, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, special purpose logic circuitry.","To provide for interaction with a user, implementations of the subject matter described in this specification can be implemented on a computer having a display device, e.g., a CRT (cathode ray tube) or LCD (liquid crystal display) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.","Implementations of the subject matter described in this specification can be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation of the subject matter described is this specification, or any combination of one or more such back end, middleware, or front end components. The components of the system can be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (\u201cLAN\u201d) and a wide area network (\u201cWAN\u201d), an inter-network (e.g., the Internet), and peer-to-peer networks (e.g., ad hoc peer-to-peer networks).","The computing system can include clients and servers. A client and server are generally remote from each other and typically interact through a communication network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","While this specification contains many implementation details, these should not be construed as limitations on the scope of any implementation or of what may be claimed, but rather as descriptions of features specific to particular implementations of the subject matter. Certain features that are described in this specification in the context of separate embodiments can also be implemented in combination in a single embodiment. Conversely, various features that are described in the context of a single embodiment can also be implemented in multiple embodiments separately or in any suitable subcombination. Moreover, although features may be described above as acting in certain combinations and even initially claimed as such, one or more features from a claimed combination can in some cases be excised from the combination, and the claimed combination may be directed to a subcombination or variation of a subcombination.","Similarly, while operations are depicted in the drawings in a particular order, this should not be understood as requiring that such operations be performed in the particular order shown or in sequential order, or that all illustrated operations be performed, to achieve desirable results. In certain circumstances, multitasking and parallel processing may be advantageous. Moreover, the separation of various system components in the implementations described above should not be understood as requiring such separation in all implementations, and it should be understood that the described program components and systems can generally be integrated together in a single software product or packaged into multiple software products.","In other words, although this disclosure has been described in terms of certain embodiments and generally associated methods, alterations and permutations of these embodiments and methods will be apparent to those skilled in the art. Accordingly, the above description of example embodiments does not define or constrain this disclosure. Other changes, substitutions, and alterations are also possible without departing from the spirit and scope of this disclosure."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7C"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 7D"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7E"}]},"DETDESC":[{},{}]}
