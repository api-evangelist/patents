---
title: Component model for batch computing in a distributed object environment
abstract: A batch component model is provided within a distributed object environment. The batch component is designed to capture the iterative logic of a batch program as it reads from one or more input streams, invokes operations on other business component functions, and generates output to one or more output streams. Deployment descriptors express declarative policies for the component that will influence how the component is managed including the streams it uses, business components it depends on, how processing costs are accounted, and the resource demands the job will put on the system. Input streams and output streams are encapsulated in objects that hide the actual source of input and output data so that the component can be redeployed in different execution environments to different physical data sources without requiring the program to be changed. A batch container enforces the deployment policies declared for the batch component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08024733&OS=08024733&RS=08024733
owner: International Business Machines Corporation
number: 08024733
owner_city: Armonk
owner_country: US
publication_date: 20040513
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["1. Technical Field","The present invention relates to data processing systems and, in particular, to batch processing in a distributed object environment. Still more particularly, the present invention provides a component model for batch computing in a distributed object environment.","2. Description of Related Art","Distributed object component technology has evolved to provide a solid foundation for modern business application design in online transaction processing systems. These component technologies include, for example, the use of the JAVA programming language, the JAVA 2 Enterprise Edition (J2EE) programming model, and component technologies, such as Java Server Pages (JSPs), Servlets, and Portlets for online presentation logic. Component technologies also includes, for example, the use of Enterprise JAVA Bean (EJB) SessionBeans and EntityBeans for transactional business logic and data management.","These component models are expressly designed to enable a strong separation of concerns between business application logic and the underlying information systems technology on which those application components are hosted. This separation enables application developers to focus on domain knowledge, adding value to their business, and to avoid the intricacies of distributed information systems technology. The EJB component models are designed to support transactional processing of business functions, leveraging the ACID (Atomicity, Consistency, Isolation, and Durability) properties of distributed two-phase commit protocols to ensure a very high degree of information integrity. Further, these component models enable declarative approaches to enforcing security, the relationships between objects, internationalization, serviceability, and persistence, essentially virtualizing the relationship of the business application component to its underlying information system.","The primary limitation of object component technologies, such as those defined by J2EE, is that they are designed for online transaction processing. Business transactions are typically initiated by an end user in real time, requesting that a function be performed by the business application, usually resulting in an update to business data that gets transactionally committed before returning a result to the user. Component models and container management are designed to operate on one request at a time. Any multi-processing is achieved through multi-threading and workload clustering, but in a way that retains the illusion of sequential processing. Transaction, security, and persistence processing are structured around the idea that each request is initiated distinctly for a unique user and for a unique end purpose.","However, there is a large demand for bulk (batch) processing. Besides being a traditional approach to data processing\u2014in fact, the incumbent of modern electronic computing\u2014bulk processing also represents a significant portion of how enterprises continue to conduct their business. Bank checks are processed in bulk in clearing centers every night. Interest on savings and loan accounts is computed in bulk every week. Billing statements are printed in bulk every month. Corporate payments are collected up and posted every week. Paychecks are cut and distributed every couple of weeks. Customers often want to be able to execute these transactions in batch programs, processing many hundreds, thousands, or even millions of transactions in a single job. Moreover, many customers want to be able to re-use the exact same business logic and programming artifacts in both their online transaction processing and in their batch programs. For example, an account withdrawal function should do the same thing whether it is being performed for a bank customer standing at an automatic teller machine or for a check that was posted through a clearing house in the middle of the night.","Batch computing has been a long-time staple of mainframe computing in languages, such as COBOL and PL\/I, and as standalone programs or combined in subsystems, such as CICS and IMS. However, batch computing has never been combined with distributed object component technologies. Therefore, one must perform batch processing by stringing together a large number of single transactions, which is inefficient, or by performing one large transaction, which will likely affect online processing.","The present invention recognizes the disadvantages of the prior art and introduces a batch component model that adopts the same design principles of other J2EE components, but applies them uniquely to batch processing. The batch component is designed to capture the iterative logic of a batch program as it reads from one or more input streams, invokes operations on other business component functions, and generates output to one or more output streams. Deployment descriptors may be associated with the component. Deployment descriptors express declarative policies for the component that will influence how the component is managed including the streams it uses, business components it depends on, how processing costs are accounted for, the resource demands the job will put on the system, and the like. Input streams and output streams are encapsulated in objects that hide the actual source of input and output data so that the component can be redeployed in different execution environments to different physical data sources without requiring the program be changed. A contractual relationship is formed between the batch component and a container that enforces the deployment policies declared for the component, against a set of service qualities offered by the container, including enforcing security, internationalization, and serviceability policies, optimizing the execution path of the batch job, and managing the workload of the batch component against other workloads being served in the execution environment at the same time. Control is passed between the component and its container so that the container binds the component's input and output streams and other dependent business components, optimizes the checkpoint interval, and recovers and restarts the batch job after a failure. The contractual relationship between the batch component and the container is wrappered with a batch adapter to isolate the batch component from different potential container implementations. The adapter may be instantiated to hold the execution progress state of each run of the batch job. In certain cases it is possible for the container to partition the input stream and run multiple (sub-) instances of the batch job in parallel, each operating on its own partition of the input stream to gain even further throughput advantages for the batch workload.","The present invention provides a method, apparatus and computer program product for application design based on diagram specialization. The data processing device may be a stand-alone computing device or may be a distributed data processing system in which multiple computing devices are utilized to perform various aspects of the present invention. Therefore, the following  are provided as exemplary diagrams of data processing environments in which the present invention may be implemented. It should be appreciated that  are only exemplary and are not intended to assert or imply any limitation with regard to the environments in which the present invention may be implemented. Many modifications to the depicted environments may be made without departing from the spirit and scope of the present invention.","With reference now to the figures,  depicts a pictorial representation of a network of data processing systems in which the present invention may be implemented. Network data processing system  is a network of computers in which the present invention may be implemented. Network data processing system  contains a network , which is the medium used to provide communications links between various devices and computers connected together within network data processing system . Network  may include connections, such as wire, wireless communication links, or fiber optic cables.","In the depicted example, servers ,  are connected to network  along with storage unit . In addition, clients , , and  are connected to network . These clients , , and  may be, for example, personal computers or network computers. In the depicted example, servers ,  provide data, such as boot files, operating system images, and applications to clients -. Clients , , and  are clients to servers , . Network data processing system  may include additional servers, clients, and other devices not shown.","In the depicted example, network data processing system  is the Internet with network  representing a worldwide collection of networks and gateways that use the Transmission Control Protocol\/Internet Protocol (TCP\/IP) suite of protocols to communicate with one another. At the heart of the Internet is a backbone of high-speed data communication lines between major nodes or host computers, consisting of thousands of commercial, government, educational and other computer systems that route data and messages. Of course, network data processing system  also may be implemented as a number of different types of networks, such as for example, an intranet, a local area network (LAN), or a wide area network (WAN).  is intended as an example, and not as an architectural limitation for the present invention.","Referring to , a block diagram of a data processing system that may be implemented as a server, such as server  in , is depicted in accordance with a preferred embodiment of the present invention. Data processing system  may be a symmetric multiprocessor (SMP) system including a plurality of processors  and  connected to system bus . Alternatively, a single processor system may be employed. Also connected to system bus  is memory controller\/cache , which provides an interface to local memory . I\/O bus bridge  is connected to system bus  and provides an interface to I\/O bus . Memory controller\/cache  and I\/O bus bridge  may be integrated as depicted.","Peripheral component interconnect (PCI) bus bridge  connected to I\/O bus  provides an interface to PCI local bus . A number of modems may be connected to PCI local bus . Typical PCI bus implementations will support four PCI expansion slots or add-in connectors. Communications links to clients - in  may be provided through modem  and network adapter  connected to PCI local bus  through add-in connectors.","Additional PCI bus bridges  and  provide interfaces for additional PCI local buses  and , from which additional modems or network adapters may be supported. In this manner, data processing system  allows connections to multiple network computers. A memory-mapped graphics adapter  and hard disk  may also be connected to I\/O bus  as depicted, either directly or indirectly.","Those of ordinary skill in the art will appreciate that the hardware depicted in  may vary. For example, other peripheral devices, such as optical disk drives and the like, also may be used in addition to or in place of the hardware depicted. The depicted example is not meant to imply architectural limitations with respect to the present invention.","The data processing system depicted in  may be, for example, an IBM eServer pSeries system, a product of International Business Machines Corporation in Armonk, N.Y., running the Advanced Interactive Executive (AIX) operating system or LINUX operating system.","With reference now to , a block diagram of a data processing system is shown in which the present invention may be implemented. Data processing system  is an example of a computer, such as client  in , in which code or instructions implementing the processes of the present invention may be located. In the depicted example, data processing system  employs a hub architecture including a north bridge and memory controller hub (MCH)  and a south bridge and input\/output (I\/O) controller hub (ICH) . Processor , main memory , and graphics processor  are connected to MCH . Graphics processor  may be connected to the MCH through an accelerated graphics port (AGP), for example.","In the depicted example, local area network (LAN) adapter , audio adapter , keyboard and mouse adapter , modem , read only memory (ROM) , hard disk drive (HDD) , CD-ROM driver , universal serial bus (USB) ports and other communications ports , and PCI\/PCIe devices  may be connected to ICH . PCI\/PCIe devices may include, for example, Ethernet adapters, add-in cards, PC cards for notebook computers, etc. PCI uses a cardbus controller, while PCIe does not. ROM  may be, for example, a flash binary input\/output system (BIOS). Hard disk drive  and CD-ROM drive  may use, for example, an integrated drive electronics (IDE) or serial advanced technology attachment (SATA) interface. A super I\/O (SIO) device  may be connected to ICH .","An operating system runs on processor  and is used to coordinate and provide control of various components within data processing system  in . The operating system may be a commercially available operating system such as Windows XP, which is available from Microsoft Corporation. An object oriented programming system such as Java may run in conjunction with the operating system and provides calls to the operating system from Java programs or applications executing on data processing system . \u201cJava\u201d is a trademark of Sun Microsystems, Inc. Instructions for the operating system, the object-oriented programming system, and applications or programs are located on storage devices, such as hard disk drive , and may be loaded into main memory  for execution by processor . The processes of the present invention are performed by processor  using computer implemented instructions, which may be located in a memory such as, for example, main memory , memory , or in one or more peripheral devices  and .","Those of ordinary skill in the art will appreciate that the hardware in  may vary depending on the implementation. Other internal hardware or peripheral devices, such as flash memory, equivalent non-volatile memory, or optical disk drives and the like, may be used in addition to or in place of the hardware depicted in . Also, the processes of the present invention may be applied to a multiprocessor data processing system.","For example, data processing system  may be a personal digital assistant (PDA), which is configured with flash memory to provide non-volatile memory for storing operating system files and\/or user-generated data. The depicted example in  and above-described examples are not meant to imply architectural limitations. For example, data processing system  also may be a tablet computer, laptop computer, or telephone device in addition to taking the form of a PDA.","Returning to , Network data processing system  may provide a distributed object environment. For example, server  may provide terminal services and other clients, server  may provide web services clients, and storage  may store core business functions and persistent business objects. Distributed objects are software modules that are designed to work together, but may reside in multiple computer systems throughout the network. A program in one machine sends a message to an object in a remote machine to perform some processing and the results are sent back to the calling machine. Distributed objects over the Web are known as \u201cWeb services.\u201d \u201cTerminal services\u201d enable an application to be run simultaneously by multiple users at different clients. Terminal services turn a server into a centralized, timeshared computer. All the data processing (business logic) is performed in the server, and the clients display only the user interface and screen changes.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 4","b":["420","402","404","406","408","410"]},"A \u201cworkflow\u201d is a script, or a series of steps to be executed to perform a procedure. A workflow engine (not shown) invokes the tasks or activities that have been scripted into the workflow. These steps typically involve performing transactions using business functions .","Data  represents persistence of the essential state of the business logic. Persistent data, such as database tables and the like, are stored in data .","Clients - may access core business functions  through, for example, Remote Method Invocation over Internet Inter-ORB Protocol (RMI\/IIOP), Web Services Description Language (WSDL), Simple Object Access Protocol (SOAP), JAVA Messaging Service (JMS), or local access. RMI\/IIOP allows Java access to non-Java processes via Common Object Request Broker Architecture (CORBA). WSDL is a protocol for a Web service to describe its capabilities. SOAP is a message-based protocol based on extensible Markup Language (XML) for accessing services on the Web. JMS is an application programming interface (API) from Sun for connecting JAVA programs to messaging middleware. JMS is part of Sun's J2EE platform.","The primary limitation of object component technologies, as described above with respect to , is that they are designed for online transaction processing. Yet, there is a large demand for batch processing. However, batch computing has never been combined with distributed object component technologies. A convergence between batch computing and distributed object component technologies can yield the combined strength of container based component management, developer productivity, and economies of scale.","The idea of batch computing in a distributed component system introduces several problems, including:\n\n",{"@attributes":{"id":"p-0044","num":"0052"},"figref":"FIG. 5","b":["506","508","502","504","508"]},"Container technology is designed to operate on deployment descriptors (declarative policies) to enforce the policies they express. Containers have been extended to optimize the management of those components to reach optimal throughput in a fully loaded system. This results in application designs that are more flexible, durable, and portable. Componentization enables a higher degree of re-use and sharing of application logic and data, thus improving developer productivity and business process integration. In addition, containers manage components to enforce the contractual obligations of that component model for the business logic they contain.","The BatchBean is attributed with deployment descriptors that provide input to how a BatchBean is managed by its container. Deployment descriptors are supplied as declarative policies for the component by the component assembler and\/or deployer. Among the deployment descriptors include descriptors that identify which business function components, such as business function  in , the BatchBean uses. The deployment descriptors may be symbolic references that can be coded into the BatchBean implementation, and then bound to the actual components it will use at deployment time. The BatchBean deployment descriptors also refer to the input and output data streams that the BatchBean will be associated with at runtime. These deployment descriptors also name the batch program, conditions the checkpoint interval for the batch job, and enumerates other resource dependencies that should be allocated before beginning the batch job. These descriptors are used by the container that will host the BatchBean when it instantiates a batch job.","The input and output streams ,  presented to the BatchBean component model are abstractions of the actual underlying data technology from which those streams receive their data. Input stream , for example, may be a wrapper to a magnetic tape, a message queue, a text file, a relational database table, or any other stream implementation, and thus different underlying data technologies and sources may be bound at deployment time without affecting the implementation of the BatchBean.","Turning now to , a block diagram illustrating a batch component model is shown in accordance with an exemplary embodiment of the present invention. Batch component, or BatchBean,  is managed by batch container . The batch component  is attributed with deployment descriptors that provide input to how the batch component is managed by its container. The deployment descriptors also refer to the input streams  and output streams  that the batch component will be associated with at runtime.","In many cases, an input stream for a batch job may contain many thousands or millions of input records, each record representing an input to a business transaction. Container  is responsible for checkpointing the progress of the batch job periodically to ensure that if the job should fail the batch job will not have to be restarted from the beginning, but rather can be restarted at its last checkpoint after recovering from the failure. This includes persisting in checkpoint cursor storage  any cursors that mark the progress of the batch job through its input and output streams.","The basic protocol is that container  opens a global transaction context at the beginning of a checkpoint interval (the period between checkpoints), lets the batch program iterate over some number of records in its input stream, and then commits the global transaction at the end of the checkpoint interval\u2014committing any business data that was updated during the checkpoint interval along with checkpoint cursors.","If the global transaction cannot be committed, then all of the work that was performed within the checkpoint interval is rolled back. The job is effectively rolled back to the prior checkpoint.","By putting the responsibility of checkpointing on the container, the checkpoint interval can be varied based on other conditions in the execution environment. Increasing the size of the checkpoint interval will tend to maximize the number of business transactions that can be processed in a given period of time. However, doing so tends to leave resources allocated to the batch job for a longer period of time, which blocks other concurrent resources that need to share those same resources, and increases the number of records that need to be re-processed in the case of a failure. On the other hand, decreasing the size of the checkpoint interval decreases the length of contention on shared resources, reduces the number of records that need to be re-processed in the case of failure, but also tends to increase the amount of overhead spent in processing global transaction commitments.","Checkpoint intervals may be measured in terms of the number of records processed in the interval or the amount of time spent in the interval. The container may increase the interval when resource contention from other workloads is low or decrease the interval when contention is high or when there is an elevated potential for the job to fail and have to be restarted.",{"@attributes":{"id":"p-0054","num":"0062"},"figref":"FIG. 7","b":["720","722","720"]},"Batch client  is attributed with deployment descriptors that provide input to how the batch component is managed by its container. The deployment descriptors also refer to the input streams and output streams that the batch component will be associated with at runtime. The container in batch client  is responsible checkpointing the progress of the batch job periodically to ensure that if the job should fail, the batch job will not have to be restarted from the beginning, but rather can be restarted at its last checkpoint after recovering from the failure. This includes persisting in a checkpoint cursor storage any cursors that mark the progress of the batch job through its input and output streams.","Batch client  accesses the same core business functions  as the other clients in the distributed object environment. Data  represents persistence of the essential state of the business logic. Resources, such as database tables and the like, are stored in data . This is germane to potential optimization benefits that can come from knowledge of the checkpoint interval in the container.","A major additional advantage that stems from putting the responsibility for setting the checkpoint interval on the container is that it can then propagate context information  and  about the size of the checkpoint interval and other information about the dependencies declared for the batch job to downstream containers within an execution context. This context information ,  can then be used by downstream containers to pre-allocate resources or verify that availability of dependent resources that will be used during the checkpoint interval. For example, a downstream EntityBean container  can pre-fetch the database rows that will be used in the interval and thus reduce incremental I\/O overhead. Or the container may set aside space in object pools, thread pools, connection pools, etc. that will be needed during the interval. Doing so both reduces overhead, making the processing during the checkpoint interval more efficient, but also helps ensure resources that will be needed during the interval will not be depleted before the interval completes, avoiding unnecessary checkpoint failures and thus unnecessary rework.","In more advanced systems, context information can be correlated against applicable application profiles that condition the enforcement of different deployment policies  for components used in the batch job. For example, a downstream component may be deployed with container management policies that are unique to the case that the component is being used within a batch program as opposed to some other OLTP client.",{"@attributes":{"id":"p-0059","num":"0067"},"figref":"FIG. 8","b":["820","810","820"]},"Since the BatchBean in batch client  is a component, its operations can be called by other clients to begin the batch task. One such client may be a scheduling program\u2014a facility for initiating batch jobs at a certain time of day or in response to certain information arriving at the enterprise, such as a dataset containing bank checks that were received form a member bank, for example. The scheduler may initiate a sequence of batch jobs to make up job flow .",{"@attributes":{"id":"p-0061","num":"0069"},"figref":"FIG. 9","b":["912","914","916","902","904","912","916","914","912","916","914","912","916","912","916","912","916"]},"Furthermore, the output stream produced by one batch job may serve as an input stream to another batch job. In this manner, the job flow may be structured as a data flow. Moreover, some batch jobs may never terminate; rather, they just continue to process from their input streams that, in turn, may be fed from other batch jobs, and so forth. Other batch jobs may be scheduled to regularly process a portion of their input streams. For example, a batch job may be scheduled to start every ten minutes and process a thousand input records, just chipping away at the input at a very deterministic rate and generating very predictable demands on the information system.","Each batch container is able to restart a batch job, either as a result of a failure that occurred in a previous run of the batch job or as a result of deliberately starting and stopping the batch job. Consequently, the container may be able to tell the batch component where to begin work\u2014where within the input stream the BatchBean should start reading again. Likewise, the container must be able to instruct the BatchBean on where to stop processing\u2014either as a result of a portion of the batch job timing out or as a result of an administrator deliberately stopping or suspending the batch job. This same mechanism can also be used to schedule multiple instances of the batch job running\u2014each starting from a different position within the input stream and continuing to a different stopping point. In this way, a large batch job can be partitioned and executed in parallel\u2014perhaps in different containers or on different computers\u2014as a way of spreading the workload and enabling concurrent processing.","Batch partitioning may be performed by either directing each job partition to share the same input and output streams or by partitioning the input streams and distributing those to each of the batch job partitions and likewise re-assembling the disparate output streams that each partition produces.","The scheduler can distribute batch jobs and partitions to run on different computers in the network. The scheduler can make scheduling (time and location) decisions based on the actual utilization and capacity of different computers in the network, based on where input and output resources are located, and where execution demands are least likely to be impacted by the batch job (or vice versa). A key function of the scheduler is to collaborate with the batch container to ensure the needed input and output resources are available (or allocated) to the batch job before it is started\u2014in doing so, it is ensuring that the batch job can be run with maximum efficiency.","Finally, it is the responsibility of the batch container to maintain knowledge of what batch jobs are running and which are suspended or waiting to be scheduled or dispatched. It should be possible for an administrator to query the container for this information to get an idea of how much of each batch has been completed or how close it is to completing all of its work.",{"@attributes":{"id":"p-0067","num":"0075"},"figref":"FIG. 10","b":["1002","1004"]},"A client may deploy different instances of the same batch component by instantiating the batch component with different instances of a batch container and providing different deployment descriptors. The deployment descriptors identify which business function components the batch component uses, the input data streams, and the output data streams. The deployment descriptors also name the batch program, condition the checkpoint interval for the batch job, and enumerate other resource dependencies that should be allocated before beginning the batch job. The batch container uses these deployment descriptors to manage the batch component.","Next, the batch container examines the workload and deployment descriptors (block ) and the batch container computes a size of a checkpoint interval (block ). The checkpoint interval may be determined based on other conditions in the execution environment. Checkpoint intervals may be measured in terms of the number of records processed in the interval or the amount of time spent in the interval. The container may increase the interval when resource contention from other workloads in the distributed object environment is low. The container may decrease the interval when contention is high or when there is an elevated potential for the job to fail and have to be restarted.","A determination is made as to whether resource capacity is available for the batch job (block ). If resource capacity is not available, the batch container suspends the batch job (block ) and the process returns to block . The batch component remains suspended until the necessary resource capacity is available for the batch job in block .","If the necessary resource capacity is available in block , the batch container allocates resources for the batch job (block ) and the batch container locks the resources (block ). Then, the batch container starts the batch component (block ). A determination is made as to whether the end of the checkpoint interval is reached (block ). If the end of the checkpoint interval is not reached, the process returns to block  and the batch component continues processing until the end of the checkpoint interval is reached.","If the end of the checkpoint interval is reached in block , the batch container updates and commits checkpoint cursors that mark the progress of the batch job through its input and output streams (block ). Thereafter, the batch container commits the results of the work performed during the checkpoint interval (block ) and the batch container releases the locks on the resources (block ).","A determination is then made as to whether the batch job is finished (block ). If the batch job is finished, the process ends. However, if the batch job is not finished in block , the process returns to block  where the batch container examines the workload and deployment descriptors for the next checkpoint interval.",{"@attributes":{"id":"p-0074","num":"0082"},"figref":"FIG. 11","b":["1102","1104"]},"Next, the process examines workload and deployment descriptors (block ) and computes a size of a checkpoint interval (block ). The checkpoint interval may be determined based on other conditions in the execution environment. Checkpoint intervals may be measured in terms of the number of records processed in the interval or the amount of time spent in the interval.","A determination is made as to whether resource capacity is available for the batch job (block ). If resource capacity is not available, the process suspends the batch job (block ) and the process returns to block . The batch component remains suspended until the necessary resource capacity is available for the batch job in block .","If the necessary resource capacity is available in block , the process allocates resources for the batch job (block ) and locks the resources (block ). Then, the process starts the batch component (block ). A determination is made as to whether the end of the checkpoint interval is reached (block ). If the end of the checkpoint interval is not reached, the process returns to block  and the batch component continues processing until the end of the checkpoint interval is reached.","If the end of the checkpoint interval is reached in block , the process updates and commits checkpoint cursors that mark the progress of the batch job through its input and output streams (block ). Thereafter, the process commits the results of the work performed during the checkpoint interval (block ) and releases the locks on the resources (block ).","A determination is then made as to whether the batch job is finished (block ). If the batch job is finished, the process ends. However, if the batch job is not finished in block , the process returns to block  to examine the workload and deployment descriptors for the next checkpoint interval.","Thus, the present invention solves the disadvantages of the prior art by providing a component model for batch computing in a distributed object environment. The batch component is managed by a batch container that may dynamically set a checkpoint interval based on deployment descriptors associated with the batch component and other workloads being served in the execution environment at the same time. Thus, the batch container enforces the policies in the deployment descriptors of the batch component while ensuring continuous service of concurrent online transaction processing workloads. Checkpoint conditions are isolated so that the checkpoint interval can be varied form one run to the next or even within a single run based on actual workload conditions of the hosting environment.","The batch component model also captures the same separation of concerns between business logic and information system infrastructure that are the principle merits of component-based programming. Furthermore, input streams and output streams are abstractions of the actual underlying data technology from which those streams receive their data. The batch component of the present invention is also able to share business logic and data components with online transaction processing.","The container can also be queried by an administrator to identify which jobs are running, suspended, scheduled, or waiting to be dispatched. The container also allows an administrator to perform operations on the batch job to start the program, interrupt the program, recover from failure, or to restart the program.","Furthermore, batch components may be related so that one batch job can be scheduled after the completion of another batch job. Batch jobs may also be interconnected so that output of one batch job may become input to another batch job.","It is important to note that while the present invention has been described in the context of a fully functioning data processing system, those of ordinary skill in the art will appreciate that the processes of the present invention are capable of being distributed in the form of a computer readable medium of instructions and a variety of forms and that the present invention applies equally regardless of the particular type of signal bearing media actually used to carry out the distribution. Examples of computer readable media include recordable-type media, such as a floppy disk, a hard disk drive, a RAM, CD-ROMs, DVD-ROMs, and transmission-type media, such as digital and analog communications links, wired or wireless communications links using transmission forms, such as, for example, radio frequency and light wave transmissions. The computer readable media may take the form of coded formats that are decoded for actual use in a particular data processing system.","The description of the present invention has been presented for purposes of illustration and description, and is not intended to be exhaustive or limited to the invention in the form disclosed. Many modifications and variations will be apparent to those of ordinary skill in the art. The embodiment was chosen and described in order to best explain the principles of the invention, the practical application, and to enable others of ordinary skill in the art to understand the invention for various embodiments with various modifications as are suited to the particular use contemplated."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The novel features believed characteristic of the invention are set forth in the appended claims. The invention itself, however, as well as a preferred mode of use, further objectives and advantages thereof, will best be understood by reference to the following detailed description of an illustrative embodiment when read in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
