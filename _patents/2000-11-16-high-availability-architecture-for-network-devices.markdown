---
title: High availability architecture for network devices
abstract: A method and apparatus allows for continued operation of one or more applications running at a network device with reduced delay despite crashes or failures at that device. The network device includes two or more supervisor cards for running the applications and a plurality of line cards. According to the invention, one supervisor card is designated the active supervisor card and one supervisor card is designated the standby supervisor card. As changes in state and other operating conditions take place on the active supervisor events are generating for passing at least some of this information to the standby supervisor where it is stored. Following a crash or failure of the active supervisor card, the standby becomes the newly active supervisor card. The standby supervisor performs a consistency check with the line cards and resets those that fail the check. The standby supervisor also determines which data records and state information stored at the standby supervisor are valid, and begins running the applications loaded onto the device. Those data records and state information determined by the standby supervisor to be valid are utilized by the applications in continuing their operation, while invalid data records and state information are discarded.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07061858&OS=07061858&RS=07061858
owner: Cisco Technology, Inc.
number: 07061858
owner_city: San Jose
owner_country: US
publication_date: 20001116
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF AN ILLUSTRATIVE EMBODIMENT"],"p":["The present application is a continuation-in-part of commonly assigned U.S. patent application Ser. No. 09\/644,377, now issued as U.S. Pat. No. 6,898,189, which was filed on Aug. 23, 2000, by Marco Di Benedetto, Ramana Mellacheruvu and Umesh Mahajan for a Restartable Spanning Tree for High Availability Network Systems and is hereby incorporated by reference.","1. Field of the Invention","The present invention relates generally to computer networks, and more specifically, to a method and apparatus for quickly resuming the operation of selected applications and processes despite crashes and failures.","2. Background Information","A computer network typically comprises a plurality of interconnected entities. An entity may consist of any device, such as a computer or end station, that \u201csources\u201d (i.e., transmits) or \u201csinks\u201d (i.e., receives) data frames. A common type of computer network is a local area network (\u201cLAN\u201d) which typically refers to a privately owned network within a single building or campus. LANs typically employ a data communication protocol (LAN standard), such as Ethernet, FDDI or token ring, that defines the functions performed by the data link and physical layers of a communications architecture (i.e., a protocol stack). In many instances, several LANs may be interconnected by point-to-point links, microwave transceivers, satellite hook-ups, etc. to form a wide area network (\u201cWAN\u201d) or intranet that may span an entire country or continent.","One or more intermediate network devices are often used to couple LANs together and allow the corresponding entities to exchange information. For example, a bridge may be used to provide a \u201cbridging\u201d function between two or more LANs. Alternatively, a switch may be utilized to provide a \u201cswitching\u201d function for transferring information between a plurality of LANs or end stations. Bridges and switches may operate at various levels of the communication protocol stack. For example, a switch may operate at layer 2 which, in the Open Systems Interconnection (OSI) Reference Model, is called the data link layer and includes the Logical Link Control (LLC) and Media Access Control (MAC) sub-layers. Data frames at the data link layer typically include a header containing the MAC address of the entity sourcing the message, referred to as the source address, and the MAC address of the entity to whom the message is being sent, referred to as the destination address. To perform the switching function, layer 2 switches examine the MAC destination address of each data frame received on a source port. The frame is then switched onto the destination port(s) associated with that MAC destination address.","Other network devices, commonly referred to as routers, may operate at higher communication layers, such as layer 3 of the OSI Reference Model, which in TCP\/IP networks corresponds to the Internet Protocol (IP) layer. Data frames at the IP layer also include a header which contains an IP source address and an IP destination address. Routers or layer 3 switches may re-assemble or convert received data frames from one LAN standard (e.g., Ethernet) to another (e.g. token ring). Thus, layer 3 devices are often used to interconnect dissimilar subnetworks.","Bridges, switches and routers, like computers, typically have one or more processing elements and memory elements interconnected by a bus. They also include one or more line cards each defining a plurality of ports that couple the respective devices to each other, to the LANs and\/or to end stations of the computer network. Ports that are used to couple two network devices together are generally referred to as a trunk ports, whereas ports used to couple a network device to a LAN or an end station(s) are generally referred to as access ports. The switching and bridging functions include receiving data from a sending entity at a source port and transferring that data to at least one destination port for forwarding to the receiving entity.","Switches and bridges typically learn which destination port to use in order to reach a particular entity by noting on which source port the last message originating from that entity was received. This information is then stored by the bridge in a block of memory referred to as a filtering database. Thereafter, when a message addressed to a given entity is received on a source port, the bridge looks up the entity in its filtering database and identifies the appropriate destination port to reach that entity. If no destination port is identified in the filtering database, the bridge floods the message out all ports, except the port on which the message was received. Messages addressed to broadcast or multicast addresses are also flooded.","To perform their bridging, switching, and\/or routing functions, network devices run a plurality of applications and\/or protocols. In particular, a network device may run a protocol, such as the Dynamic Trunk Protocol (DTP), that causes its trunk ports to automatically negotiate with the trunks ports of the second network device to which it is coupled and decide upon a message encapsulation or tagging format in order to support Virtual Local Area Networks (VLANs). For example, the trunk ports may decide to encapsulate messages pursuant to the InterSwitch Link (ISL) protocol from Cisco Systems, Inc. of San Jose, Calif. or the 802.1Q standard from the Institute of Electrical and Electronics Engineers (IEEE).","Network devices may also run the Port Aggregation Protocol (PAgP) from Cisco Systems, Inc. to identify and aggregate redundant trunk and access ports, i.e., two or more trunks that couple the same two network devices or two or more access ports that coupled a device to the same LAN or end station, so as to permit load balancing, among other advantages. In particular, PAgP, which relies on packets exchanged between neighboring devices or with itself, groups redundant ports or links into a single, logical channel.","Many network devices also run a protocol or algorithm to detect and eliminate circuitous paths or loops within the corresponding computer network. In particular, most computer networks are either partially or fully meshed. That is, they include redundant communications paths so that a failure of any given link or device does not isolate any portion of the network. The existence of redundant links, however, may cause the formation of circuitous paths or \u201cloops\u201d within the network. Loops are highly undesirable because data frames may traverse the loops indefinitely. Furthermore, because switches and bridges replicate (i.e., flood) frames whose destination port is unknown or which are directed to broadcast or multicast addresses, the existence of loops may cause a proliferation of data frames that effectively overwhelms the network.","To avoid the formation of loops, most bridges and switches execute a spanning tree algorithm which allows them to calculate an active network topology that is loop-free (i.e., a tree) and yet connects every pair of LANs within the network (i.e., the tree is spanning). The Institute of Electrical and Electronics Engineers (IEEE) has promulgated a standard (the 802.1D standard) that defines a spanning tree protocol to be executed by 802.1D compatible devices. In general, by executing the IEEE spanning tree protocol, bridges elect a single bridge within the bridged network to be the \u201croot\u201d bridge, and each bridge selects one port (its \u201croot port\u201d) which gives the lowest cost path to the root. In addition, for each LAN coupled to more than one bridge, only one (the \u201cdesignated bridge\u201d) is elected to forward frames to and from the respective LAN. The root ports and designated bridge ports are selected for inclusion in the active topology and are placed in a forwarding state so that data frames may be forwarded to and from these ports and thus onto the corresponding paths or links of the network. Ports not included within the active topology are placed in a blocking state. When a port is in the blocking state, data frames will not be forwarded to or received from the port. To obtain the information necessary to run the spanning tree protocol, network devices exchange special messages called configuration bridge protocol data unit (BPDU) messages.","To facilitate the management of VLANs, a network device may run the VLAN Trunk Protocol (VTP) from Cisco Systems, Inc. VTP is a Layer 2 messaging protocol that maintains VLAN configuration consistency by managing the addition, deletion, and renaming of VLANs across the network. With VTP, a network administrator can make VLAN configuration changes at a single network device and have those changes propagated to most if not all of the network devices in the corresponding computer network or domain.","U.S. Pat. No. 6,049,834 to Khabardar, et al describes a Layer 3 Unicast Shortcut Protocol that may be run by a network device. This protocol allows routers to download shortcut decisions to switches so that they can make certain layer 3 routing decisions.","These applications and protocols typically execute on a supervisor card disposed within the network device and\/or on one or more line cards or modules disposed within the network device. To carry out their various functions, these applications or protocols transition among a plurality of states and save configuration and state information in one or more data structures. If the supervisor card crashes or fails, the network device is generally rendered inoperative and must be re-started or replaced. This may result in significant disruption to the network including a potential loss of connectivity for one or more entities.","To provide redundancy, some network devices include a second supervisor card. As described in from Cisco Systems, Inc., the Catalyst 5500 and 6000 series of network devices from Cisco Systems, Inc. include two supervisor cards. Each of these cards, moreover, includes a network management processor (NMP) and memory resources, among other components, for running these applications and protocols. One of the supervisor cards is designated the active card while the other is designated the standby card. If a crash or failure occurs on the active supervisor card, the standby card takes over and begins running the applications and protocols. Each application and protocol, however, must be started from its initialization state on the back-up supervisor card. That is, each application and protocol begins as if the network device were just powered-up.","For example, the PAgP protocol begins transmitting packets to see whether the network device has any redundant trunk or access ports that can be aggregated into a single, logical channel. This occurs even though the PAgP protocol, as it ran on the failed supervisor card, may have previously identified several redundant links or ports and aggregated them into corresponding channels. The STP protocol similarly re-starts its computations for each port of the network device. That is, the STP protocol running on the back-up card transitions all ports to the blocking or listening states and begins transmitting BPDU messages assuming it is the root.","This process of re-starting all of the applications and protocols from an initialization state following a failure or crash at the active supervisor card can delay the forwarding of messages by the network device for a significant amount of time. In particular, it may take on the order of 30 seconds or more for the device to begin forwarding messages again. Such delays can seriously affect performance of the network. Indeed, such delays can be catastrophic for audio, video and other types of network traffic that cannot accommodate delays in transmission.","Furthermore, short duration failures or crashes of a supervisor card is not an infrequent problem. Failures or crashes can occur due to power fluctuations, glitches in the running of one or more applications or protocols, hardware faults, etc. Accordingly, significant time is often lost re-starting applications and protocols following a failure or crash of the active supervisor card, even though no change in network topology has occurred and the device, including its ports, may ultimately be returned to their original states.","Briefly, the invention relates to a method and apparatus for continuing the operation of one or more applications, protocols or processes running at a network device with reduced delay despite crashes or failures at that device. The network device includes a plurality of line cards having ports for receiving and forwarding network messages, and two or more supervisor cards for processing at least some of those messages. According to the invention, one supervisor card is designated the active supervisor card and one supervisor card is designated the standby supervisor card. Applications loaded onto the device are run by the active supervisor card and\/or the line cards. Disposed on the network device are a series of cooperating facilities for sharing certain application related information, such as data records and state information, with the standby supervisor card which stores that information.","Following a crash or failure of the active supervisor card, the standby becomes the newly active supervisor card, and begins running the applications, protocols and processes loaded onto the device. The standby supervisor also determines which data records and state information stored at the standby supervisor are valid. In particular, the standby determines which events are complete and which remain unfinished. The standby supervisor also queries the line cards to determine which of their state and other information is consistent with the corresponding information stored at the standby supervisor. Data records and state information that are determined by the standby supervisor card to be valid are utilized by the applications in resuming their operation, while invalid data records and state information are discarded. The applications resume operation on the standby supervisor utilizing the state and data record information that was determined to be valid, thereby avoiding significant disruption.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1","b":["100","100","102","112","114","116","102","112","118","108","100","102","112","114","116","120","126","130","126","120","126","128","120","126","126","1","2","3","120","126"]},"It should be understood that the bridged network  of  is meant for illustrative purposes only and that the present invention will operate with other network designs having possibly far more complex topologies.",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2","b":["126","126","202","204","0","1","206","208","2","3","202","204","206","208","210","206","208","0","2","203","205","207","209","205","203","206","208","209","212","206","208","202","204","203","207","209","212"]},"In order to render forwarding decisions that can be implemented by the switch , each supervisor card ,  preferably includes an encoded address recognition logic (EARL) circuit  coupled to its UDLINK . The EARL circuit  executes all forwarding decisions between the ports  of the line cards  and  and the supervisor cards  and . To that end, each EARL circuit  contains a forwarding engine (FE)  and at least one forwarding table (FWD TBL)  configured to produce a unique destination port index value. The LTL memories  implement \u201clocal\u201d forwarding decisions, i.e., forward decisions among the ports  of the same line card or supervisor card.","High speed message bus  is preferably a switching matrix employed to control the transfer of data among the various cards , ,  and  plugged into the switch . The UDLINK  of each card basically interfaces between the local bus  at the respective card and the message bus . Inputs to the various LTL memories  may be received over the respective local buses , which are driven by the corresponding UDLINKs . Switch  also includes a common bus  that similarly interconnects the line cards  and  and the supervisor cards  and  to support additional message handling.","Each supervisor card  and  further includes a network management processor (NMP)  and  that may be configured to run or participate in the running of a plurality of applications, protocols or processes implemented at and\/or loaded onto switch . Each supervisor  and  also includes both a run-time memory  and , such as a random access memory (RAM), and a non-volatile memory  and , such as a non-volatile RAM (NVRAM). The NMPs  and  are in communicating relationship with the corresponding memories  and  and  and , in order to store and retrieve information therefrom. Each NMP  and  is also coupled to high-speed bus , e.g., via the UDLINKs , and common bus  so that information may be exchanged between and among the NMPs  and  and the line cards  and .","As indicated above, the NMPs  and  and the microprocessors  can run a plurality of applications, protocols and processes to facilitate the performance of switch . More specifically, the NMPs  and  may be configured to run the spanning tree protocol (STP), the VLAN Trunk Protocol (VTP), the Unicast Shortcut Protocol, a multicast shortcut protocol, the Port Aggregation Protocol (PAgP) and the Dynamic Trunk Protocol (DTP), among others. The microprocessors  at line cards  and  either alone or in cooperation with the NMPs  and  may be configured to run other applications, protocols and processes which may be in the form of firmware.","Suitable intermediate network device platforms for use with the present invention include but are not limited to the commercially available Catalyst 5000 and 6000 series of switches from Cisco Systems, Inc. of San Jose, Calif.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 3","b":["126","302","304","202","204","202","204","306","308","206","208","310","312","314","316","314","316","318","320","322","324","306","308","310","312","220","202","204","206","208","126"]},"Each high availability entity  and  includes a plurality of facilities that allow applications, protocols and processes running on switch  to continue operation despite crashes or failures. In the illustrative embodiment, an event-based communication architecture is used to pass information from one supervisor to the other. An event is basically a message containing information about a change, such as a change in state, that took place somewhere on the switch . In accordance with the invention, there are three basic types of events:","\u201cprotocol events\u201d, which are produced by an application, protocol or process running at switch  in response to a change in its operating state or condition;","\u201csystem events\u201d, which are caused in response to some un-commanded network change, such as a port or link going from a down condition to an up condition or vice versa; and","\u201cexternal events\u201d, which are caused in response to some intentional network change, such as a network administrator executing a command at a Command Line Interface (CLI) terminal or screen or automatically by the well-known Simple Network Management Protocol (SNMP).","To implement this event-based architecture, each high availability entity  and  includes a high availability manager  and , a synchronization (sync) manager  and , an event manager  and , an event database  and  and a sequence database  and . Each high availability entity  and , moreover, is coupled to the respective communication engine  and . The synch managers  and  include a synchronization queue (SYNC_Q)  and . As described below, the SYNC_Qs  and  are used to sequentially buffer messages that are to be transmitted between the supervisors  and .","The high availability managers  and , the sync managers  and  and the event managers  and  may each comprise programmed or programmable program instructions or processing elements, such as software programs, modules or libraries, pertaining to the methods described herein that are executable by the respective NMPs or by other processors, processing elements or integrated circuits. These program instructions may be stored at one or more memories, such as memories , ,  and\/or , or at other computer readable media in order to store and\/or transmit the program instructions. The high availability managers  and , the sync managers  and  and the event managers  and  may also be implemented in hardware through a plurality of registers and combinational logic configured to produce sequential logic circuits and cooperating state machines. Those skilled in the art will also recognize that various combinations of hardware and software components may also be utilized to implement the present invention.",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIGS. 4","b":["7","10","12","126","226","246","248","126"]},"When a supervisor, e.g., supervisor , is initialized or starts running, it first determines whether there are any other supervisors in the switch , as indicated at block  (). If so, the two (or more) supervisors  and  elect or designate one of them to be the \u201cactive supervisor\u201d, as indicated at block . The supervisors  and  may employ any suitable criteria for use in electing one of them to be the active supervisor, such as electing the supervisor card that is inserted into the lowest (or highest) slot number in the switch's chassis. Each supervisor  and , moreover, may include some mechanism, such as an elector circuit (not shown), to perform the designation. Suppose, for example, that supervisor  is elected to be the active supervisor. All or at least one of the other supervisor cards at switch , i.e., supervisor , are then designated \u201cstandby supervisors\u201d, as indicated at block . Upon being designated the active supervisor, the high availability entity  at the active supervisor  preferably synchronizes its default configuration information to the standby supervisor(s), as indicated at block . For example, with regard to STP configuration information, the active supervisor  sends a copy of the spanning tree parameter values from its non-volatile memory  to standby supervisor . The standby supervisor  utilizes this information to update the contents of its non-volatile memory , thereby making them consistent with the information at the active supervisor .","Next, the applications, processes and protocols loaded onto the active supervisor , which may hereafter simply be referred to as applications, are initialized and run, as indicated at block . More specifically, applications ,  and  may be initialized and run on the active supervisor card . Exemplary applications or protocols represented by blocks ,  and  may include STP, VTP and the Unicast Shortcut Protocol, respectively. Other exemplary applications or protocols include DTP and PAgP. DTP is described in copending, commonly owned U.S. patent application Ser. No. 09\/141,231, filed Aug. 27, 1998, and is hereby incorporated by reference in its entirety. PAgP is described in commonly owned U.S. patent application Ser. No. 08\/902,638, filed Jun. 30, 1997, now U.S. Pat. No. 5,959,968, and is hereby incorporated by reference in its entirety.","The applications loaded onto the standby supervisor  are not initialized or run, as indicated at block . Instead, the applications at the standby supervisor  are kept in a dormant or sleeping mode.","One or more applications, processes or protocols may also be run on the line cards  and  by the respective line card managers  and . These line card-level applications may access the LC databases  and  in order to store and retrieve information and\/or data used by the line card-level applications.","Those skilled in the art will recognize that additional and\/or other applications, processes or protocols may be running on switch  and that they may or may not take advantage of the high availability objects of the present invention.","Those applications, e.g. applications ,  and , at the active supervisor  that wish to take advantage of the high availability functions provided by switch  then perform several steps. Specifically, each such application ,  and  defines a logical synchronization database ,  and , as indicated at block . Within its logical synchronization database ,  and , the application then defines one or more synchronization records, which may generally be referred to by reference numbers ,  and , as indicated at block . Synchronization records ,  and  contain the data or information that the application wishes to have synchronized to its counterpart application on the standby supervisor . Specifically, the application developer identifies that data or information which is to be used by the counterpart application on the standby supervisor  in order to continue operation of the application following a crash or failure of the active supervisor . The logical synchronization databases ,  and  will typically model the state of the respective applications ,  and .","The synchronization databases ,  and  are \u201clogical\u201d in that they are not a duplicate copy of the information maintained by the application, but preferably a designation that certain of the application's information, as stored in a portion of run-time memory allocated to the application, represents its logical synchronization database. This conserves the switch's memory resources. In the preferred embodiment, logical synchronization databases ,  and  contain only a subset of the entire set of data or information associated with the respective applications so as to conserve processing and communications resources at the switch .","For example, although the STP defines state variables for the identity of the root bridge, the identity of designated bridge(s), the identity of designated ports and the spanning tree port state of each port, among other things, it preferably only defines a sync record for the spanning tree port state for each port  of switch . As a result, the identity of the root bridge and the designated bridge(s), among other things, are not synchronized to the standby supervisor . PAgP preferably defines synchronization records for the PAgP state of each port , among other information. DTP preferably defines synchronization records for the operational status and operational type of trunk ports and for the negotiation status of trunk ports, among other information.","As described below, although the applications are not running on the standby supervisor  (i.e., they remain in a sleeping mode), synchronization databases , ,  and  having sync records , ,  and , similar to their counterparts on the active supervisor , are established and maintained on the standby  as well.","Next, each application ,  and  defines or creates one or more event types that the application will use to synchronize data to the standby supervisor , as indicated at block . The application also specifies the attributes for each defined event type. For each event type that is defined, the application also specifies whether a sequence number should be generated for instances of that event type, as described below. As a general rule, if an instance of a given event type will result in some action being taken at one or more of the line cards  and , then the application preferably requests that a sequence number be generated for instances of this event type.","The STP application , for example, may define a PORT_CHANGE_STATE event type for use in notifying the standby supervisor  that a particular port on a particular line card has changed its spanning tree port state. The PORT_CHANGE_STATE event type may include as its attributes the line card and port number identifying the port whose state is being changed, the VLAN designation associated with the change, if relevant, and the new port state. It may also request a sequence number. The VTP application  may define a MOVE_PORT_TO_VLAN event type whose attributes may include the line card and port number of a port whose VLAN designation is being changed. Additional attributes may include the old VLAN designation and the new VLAN designation. Another application, such as a link\/module up\/down application or process, may define an ADD_DELETE_PORT event type for use in notifying the standby  whenever a port is added to or deleted from the switch . Attributes for this event type may include the line card and port number of the port, the VLAN designation of the port and a flag signifying whether the port is being added or deleted. The PAgP and DTP applications may each define NEGOTIATION events for use in notifying the standby  when a port begins negotiating with a neighboring device. One of them may also define an ADD_TO_STP event for use when a given port(s) is ready to be considered by the STP application .","The applications ,  and  running at the active supervisor  may also register with the event manager  in order to listen to or be notified of the occurrence of specific instances of event types, as indicated at block . An application, for example, may wish to be notified of the events that it produces and\/or one or more events that are produced by other applications running at the active supervisor . The STP application , for example, may wish to know whenever a port is added to or deleted from the switch  or whenever a port changes its VLAN association. Accordingly, the STP application  registers with the event manager  so as to be notified of the occurrence of any ADD_DELETE_PORT and MOVE_PORT_TO_VLAN events. As the applications ,  and  define event types and\/or register as listeners for existing event types, the event manager  may establish an event queue (not shown) for each application ,  and  and may assign each queue a unique identifier, i.e., an event queue identifier (EQID), as indicated at block . Alternatively, the EQIDs may be statically defined.","In order to register as a listener for an event type, applications ,  and  preferably use the system or task calls defined by an Application Programming Interface (API) layer that is implemented by the event manager  on the active supervisor . The available API system calls may include the following:\n\n","The arguments of the eventRegister( ) API call include the event type and the listening application's EQID. As each event type is defined and applications register as listeners of the various event types, the event manager  at the active supervisor  builds and fills in an event registration table at its event database , as indicated at block  ().",{"@attributes":{"id":"p-0061","num":"0064"},"figref":"FIG. 5","b":["500","500","500","502","352","353","354","202","1","2","3","500","504","502","506","502","506","506","334","506","334","0","4","7","1","2","3","7","8","504","506","500","334","426"],"i":["a\u2013f","a\u2013f "]},"Each application that defines an event type or registers to listen for a particular event type must also define or provide to the high availability entity  a function, which may be termed an \u201cevent_recovery_func( )\u201d, that may be called should the active supervisor  fail before an instance of that event type is completed by the respective producer or listener application. Possible event_recovery_func( )s include \u201creset\u201d or \u201credo\u201d operations, but preferably not \u201cundo\u201d operations. In the illustrative embodiment, the event_recovery_func( )s and EQID for each application are statically defined at each supervisor  and .","If an application wishes to stop receiving instances of a specific event type, it preferably issues the eventDeregister( ) API call to the event manager . The arguments of this API call include event type and listener's EQID. In response, the event manager  clears the corresponding cell or record of the respective sub-column associated with the deregistering application from the event registration table  for that event type.","The active supervisor  may also notify the standby supervisor  of eventRegister( ) and eventDeregister( ) APIs, as indicated at block  (). More specifically, in response to receiving an eventRegister( ) API, the event manager  on the active supervisor  generates a REGISTER_NOTIFY message that contains the event type for which registration is being requested, an identifier of the application registering for the event type and the application's EQID. The REGISTER_NOTIFY message is then passed by the event manager  to the synch manager  which places it in the SYNC_Q . Similarly, in response to an eventDeregister( ) API, the event manager  creates a DEREGISTER_NOTIFY message, which is placed in the SYNC_Q . As messages reach or near the head of the SYNC_Q , they are preferably encapsulated within a packet or frame and transmitted to the standby supervisor  via communication engine  and bus .",{"@attributes":{"id":"p-0065","num":"0068"},"figref":"FIG. 6","b":["600","220","220","600","602","600","604","600","604","600","604","606","606","608","350","608","606","600","608","350","608","350","606","608","606"],"i":["a\u2013d","a\u2013d ","a\u2013d ","a","a\u2013d "]},"SCP frame  is received at the synch manager  of the standby supervisor  and may be placed at least temporarily in its SYNC_Q . The high availability entity  at the standby supervisor  uses the contents of REGISTER_NOTIFY and\/or DEREGISTER_NOTIFY messages from received SCP frames  to update its event database with the applications registered for particular events. Should the standby supervisor  become the active supervisor, as described below, it will use this information to monitor and track events.","After registering for event types of interest, defining corresponding event_recovery_func( )s, and configuring their logical synchronization databases ,  and , the applications ,  and  at the active supervisor  begin performing their respective functions, as indicated at block . As part of their operation, applications ,  and  may modify or change one or more of the state variables or other conditional information maintained by them. As indicated above, such changes are considered to be protocol events which are acted upon by the high availability entities  and  at supervisors  and .","Processing of Protocol Events",{"@attributes":{"id":"p-0069","num":"0072"},"figref":["FIG. 7","FIG. 7A"],"b":["202","352","202","702","352","334","704","334","706","334","334","708"]},"To generate a sequence number, the event manager  preferably accesses the sequence database  and retrieves the next available sequence number. The sequence database  may be implemented as counter that can be operated, e.g., incremented or decremented, by the event manager  in order to obtain a new sequence number. The event manager  then performs a look-up of event registration table  to determine which other applications, if any, have registered as listeners for events of this type, as indicated at block . Suppose, for example, that the event type is E and that it was produced by application A, e.g., the STP application . In this case, the event manager  determines that application A, e.g., the VTP application , has registered for events of type E. Accordingly, the event manager  also places a copy of the event instance, including the eventID, the sequence number, if any, and the data into the EQID for application A, as also indicated at block . The event manager  next returns a copy of the event instance, including the eventID, the sequence number, if any, and the specified data to the producing application, as indicated at block .","It should be understood that the producing application could also have requested that a copy of the event be placed in its EQID. The producing application may also omit its EQID from the newEvent( ) API call.","Next, the event manager  creates an entry for the event in its pending events table that is preferably maintained in the event database , as indicated at block . As described herein, the pending events table is used to keep track of which event instances have yet to be completed by all of the interested applications.",{"@attributes":{"id":"p-0073","num":"0076"},"figref":"FIG. 8","b":["800","800","802","804","802","804","802","806","810","806","810","812","1","45","1","23","4","11","806","810","814","202","0","804","816","820","816","820","822","824"],"i":["a\u2013g ","a\u2013g "]},"When a new event instance is created, the event manager  preferably creates a corresponding bit map, e.g., bit maps  and , within the first and second table elements  and . In the eventID cell of these two bit maps  and , the event manager  loads the eventID assigned to this event. The event manager  then sets, e.g., asserts, those application cells and for the application(s) that will be processing the event and are thus expected to notify the event manager  when their processing of the event is complete. Specifically, the event manager  asserts, e.g., sets to \u201c1\u201d, the application cells, e.g., cells , , and , that correspond to the producing application and to the listening application(s), if any, and de-asserts, e.g., sets to \u201c0\u201d, all other application cells for the given event instance. The event manager  may refer to the information in its event registration table  in order to assert\/de-assert the application cells and of the respective bit maps  and .","As described below, as individual applications notify the event manager  that they have completed their processing of an event, the event manager de-asserts the application cell for that application from the respective bit map of the second table element . Thus, by comparing, e.g., applying one or more Boolean operations to, the bit maps from the first and second table elements  and  that correspond to the same event instance (as indicated by the eventIDs), the event manager  can determine which applications have yet to complete their processing of the event instance.","Those skilled in the art will understand that other arrangements can be used to store the information of table .","In addition to returning the event instance to the producing application, placing copies of the event into the EQIDs of the listening applications and updating its pending events table , the event manager  notifies the standby supervisor of the occurrence of the event, as indicated at block . In particular, the event manager  generates an EVENT_BEGIN message. The EVENT_BEGIN message contains the event type, the bit map generated for the first table element  for the event (which includes the event's eventID and designates the producing and listing applications, if any), the sequence number, if any, and the data specified by the producing application. The event manager  passes the EVENT_BEGIN message to the sync manager , which, in turn, places it in the SYNC_Q . When the EVENT_BEGIN message reaches (or nears) the head of the SYNC_Q , it is encapsulated within an SCP frame  and transmitted to the standby supervisor  via communication engine  and bus  in a similar manner as described above. At the standby supervisor , the EVENT_BEGIN message is received by the sync manager . The event manager  at the standby supervisor  stores the sequence number, if any, from the EVENT_BEGIN message in its sequence database , and copies the bit map into the first and second table elements  and  of its pending events table , as indicated at block .","Returning to the active supervisor , upon receiving the event instance that was returned to it by the event manager , the producing application, i.e., application  or A, processes the event, as indicated at block . That is, the application takes the appropriate, i.e.; programmed, action in response to the event. Suppose this action includes commanding a line card, e.g., line card , to take some action, such as changing some state or condition associated with one or more of its ports, e.g., port P. Suppose this action further includes modifying the contents of one or more of the application's sync records  so as to store this new state or condition. If so, the application  preferably generates an SCP command message for transmission to the line card . The SCP command message preferably identifies the affected port and the new state or condition to which the port should be transitioned. The command message further includes the sequence number that was generated by the event manager  and returned to the application  with the copy of the event instance. The application  passes the SCP command message to communication engine , which sends it to line card  via bus . The SCP command message from the application  is preferably not placed in or routed through the SYNC_Q .","The SCP command message is received by the line card's communication engine , which provides it to the line card manager . Manager  takes the corresponding action, e.g., changing the state or condition of port P. The line card manager  also stores the sequence number from the command message at its sequence database , as indicated at block  (). The line card manager  may or may not return an acknowledgment message to the application  at the active supervisor .","In accordance with the preferred embodiment of the present invention, the line card managers  and  only store at their respective sequence databases  and  the single, highest sequence number they have received. To the extent the line card manager  was storing a previous sequence number at the time it received the SCP command message containing the new sequence number, the previous, e.g., lower, sequence number is discarded and only the sequence number that was just received is saved by the line card manager . If a received sequence number happens to be lower than the currently stored sequence number, the line card manager  carries out the action of the SCP message, but retains the higher sequence number. In other words, the line card manager  and  at each line card  and  only stores the highest sequence number that it has received.","Since it is modifying or changing, e.g., writing to, the contents of one or more of its sync records , the application  also causes the standby supervisor  to be informed of the new value(s) for each modified synch record , as indicated at block . In particular, the application  creates a SYNC_RECORD_MESSAGE for transmission to the standby supervisor .",{"@attributes":{"id":"p-0082","num":"0085"},"figref":"FIG. 9","b":["900","900","902","904","906","908","910","362","204","902","352","904","352","356","352","906","910","910","352","904","352","910","204"]},"Once it has created the SYNC_RECORD_MESSAGE, the application  preferably causes it to be sent to the standby supervisor . In particular, the application  calls a transmit function, which may be referred to as the \u201cha_tx_sync( ) function\u201d. The ha_tx_sync( ) function takes the SYNC_RECORD_MESSAGE  and places it in the SYNC_Q  at the active supervisor . When the message  reaches or nears the head of the SYNC_Q , it is encapsulated in an SCP frame  and transmitted to the standby supervisor  in a similar manner as described above.","The SCP frame  is received at standby's communication  and is passed to the high availability entity , based on the message's Destination Address (DA) and\/or Destination Service Access Point (DSAP). The sync manager  preferably recovers the SYNC_RECORD_MESSAGE  from the SCP message . The sync manager  then uses the entity ID and the record ID from fields  and  of the sync record  to index a database and derive a put function, which may also be the record_sync_func( ) described above.","Specifically, the sync manager  may be statically configured with the particular record_sync_func( )s corresponding to each possible entity ID and record ID pair. On the standby , execution of the record_sync_func( ), causes the data in the data portion  of the sync record  to be recovered. It also causes the recovered data to be stored at the specified sync record  at the logical synchronization database  for the application , as indicated at block . In particular, the record_sync_func( ) uses the values from the entity and record ID fields  and  to locate the correct synchronization database  and synchronization record . The record_sync_func( ) then writes the unpacked data of field  to that record.","Upon completing all of its programmed action(s), e.g., issuing the SCP set command message to line card , updating its own sync record  and transmitting the new sync record to the standby supervisor , the application  preferably issues an eventComplete( ) API call to the event manager , as indicated at block . The arguments of the eventComplete( ) API call include the event's eventID and an identifier of the application issuing the eventComplete( ) API call, e.g., its EQID. In response to the eventComplete( ) API call, the event manager  modifies its pending events table  to reflect that application  has completed its processing of the subject event, as indicated at block . In particular, the event manager  accesses the particular bit map, e.g., bit map , from second table element  that corresponds to the event instance specified by the eventID of the eventComplete( ) API call. The event manager  then de-asserts the application cell, e.g., cell , that corresponds to the EQID from the eventComplete( ) API call so as reflect that the event manager  is no longer waiting for application A to complete this event.","The event manager  also notifies the standby supervisor  that application  has completed its processing of this event, as indicated by block . In particular, the event manager  creates an EVENT_COMPLETE message for use in notifying the standby supervisor . The EVENT_COMPLETE message includes the bit map, i.e., bit map , from second table element  that it has modified. The EVENT_COMPLETE message is provided to the sync manager  which places it in the SYNC_Q  for transmission to the standby supervisor . The EVENT_COMPLETE message is received at the standby's communication engine  which passes the message to the high availability entity . The event manager  then updates its pending events table  to reflect that application A has completed its processing of the event, as indicated at block . In particular, the event manager  uses the eventID to identify the corresponding bit map, i.e., bit map , from the standby's second table element  and replaces that bit map with the modified bit map that was received in the EVENT_COMPLETE message from the active supervisor , i.e., the bit map  having application cell de-asserted.","Other applications that received a copy of the event instance in their EQIDs similarly perform their programmed processing of the event. These applications may similarly update one or more of their sync records in response to the event and, if so, issue sync record messages to the standby supervisor . These applications may also issue one or more events in response to the first event. As a result, events may become nested within each other. As each of these other applications complete their processing of the first event, they similarly issue an eventComplete( ) API call to the event manager , which de-asserts the respective application cells from bit map , as indicated at block . The event manager  then sends an EVENT_COMPLETE message with a copy of the modified bit map  to the standby supervisor , as indicated at block , and the standby supervisor  clears the respective application from its pending events table, as indicated at block  ().","When the producing application and all listening applications of a particular event have issued eventComplete( ) API calls, the event manager  preferably closes the corresponding event, as indicated at block . In particular, the event manager  removes the bit map that was established for this event from both the first and second table elements  and  of its pending events table . The event manager  at the standby supervisor  similarly closes events that have been processed by the producing and all listening applications, as indicated at block .","Processing of System Events",{"@attributes":{"id":"p-0091","num":"0094"},"figref":"FIG. 10","b":["3","208","3","316","600","202","1002","310","202","220","334","1004"]},"In response, the event manager  preferably creates an instance of this event and returns it along with a new sequence number, which it obtains from the sequence database , to the link\/module up\/down application, as indicated at block . It also places the event in the EQIDs for any applications that registered as listeners to this event type, as also indicated by block . The event manager  also updates its pending events table , as indicated at block , by creating a new bit map in each of the first and second table elements  and . The event manager  also generates an EVENT_BEGIN message containing the sequence number and the new bit map, among other information, and sends this message to the standby supervisor  via the SYNC_Q , as indicated at block . The standby supervisor  updates its pending events table, as also indicated at block .","The link\/module up\/down application preferably generates an SCP acknowledgement message to line card  containing the sequence number generated by the event manager , as indicated at block . The acknowledgement is sent to the line card  via communication engine  and bus . The acknowledgement preferably does not get placed in the SYNC_Q . When the acknowledgment is received at line card , the line card manager  updates its sequence database  with the new sequence number, as indicated at . The line card manager  preferably does not consider the link to be in an up condition until the acknowledgement from the link\/module is up\/down application on the supervisor  is received. To the extent a sync record of the link\/module up\/down application is modified, the application generates a SYNC_RECORD_MESSAGE with the new sync record and sends it to the standby supervisor  via the SYNC_Q .","When the link\/module up\/down application completes its processing of the event, it issues an eventComplete( ) API call to the event manager , as indicated at block . The event manager  modifies its pending events table  by updating the corresponding event finished bit map established for this event, generates an EVENT_COMPLETE message containing the new bit map and sends the EVENT_COMPLETE message to the standby supervisor  via the SYNC_Q , as indicated at block . The event manager  at the standby supervisor , in turn, updates its pending events table, as indicated at block .","To the extent other applications registered as listeners for this type of event, they process the event and issue eventComplete( ) API calls to the event manager . The event manager  updates the corresponding bit map in its pending events table  accordingly and sends EVENT_COMPLETE messages to the standby supervisor  containing the update.","Processing of External Events",{"@attributes":{"id":"p-0097","num":"0100"},"figref":["FIG. 11","FIG. 11A"],"b":["126","126","1102","354","206","202","334","1104","334","800","1106","334"]},"The event manager  returns a copy of the event, including the new sequence number, to the CLI task and places a copy of the event in the EQID for application , as indicated at block . The event manager  also issues an EVENT_BEGIN message that includes the new sequence number to the standby supervisor , as indicated at block . The standby supervisor  adds the new bit map from the EVENT_BEGIN message to its pending events table  and stores the new sequence number, as indicated at block . The application  meanwhile, if required as part of its processing of the event, issues a SCP set command, which includes the sequence number, to line card  directing it to take the corresponding action, as indicated at block . Line card  executes the corresponding action and stores the new sequence number at its sequence database , as indicated at block . The application  may then modify one or more of its sync records  to reflect the new condition, as indicated at block . The new sync record is then transmitted to the standby supervisor  in a similar manner as described above, as indicated at block .","Upon completing their processing of the event, the CLI task and application  each issue an eventComplete( ) call to the event manager , as indicated at block  (). The event manager  clears the CLI task and application  from its pending events table , as indicated at block , and sends EVENT_COMPLETE messages to the standby supervisor , as indicated at block . The standby supervisor clears the CLI task and application  from its pending events table, as indicated at block . The active and the standby supervisors  and  then close the event, as indicated at block .","As shown, the synchronization of information from the active to the standby supervisors  and  in response to protocol, system and external events preferably takes place asynchronously so as to minimize their effects on the run-time performance of the switch . Furthermore, the existence of a single SYNC_Q  at the active supervisor  ensures consistent ordering between the active and the standby supervisors  and . That is, the order in which changes take place on the active supervisor  is the same as the order in which those changes take place on the standby supervisor .","Switchover from Active to Standby Supervisors","If a failure occurs at the active supervisor , the standby supervisor  preferably continues the switching and other operations of the switch  with little or no disruption to the bridged computer network .  is a flow diagram of the preferred steps taken by switch  during a switchover of supervisor cards. First, the active supervisor  crashes or fails, and that crash or failure is detected by the standby supervisor(s), e.g., supervisor , as indicated at block . It should be understood that the supervisors  and  may each include failure detection modules or circuits for this purpose. If there are multiple standby supervisors, one of them is elected to be the newly active supervisor, as indicated at block .","The standby supervisor(s) , in addition to processing events, as described above, also keeps track of which line cards or modules of switch  are running, i.e., which line cards are on-line. Following the crash or failure of the active supervisor , the high availability manager  at the standby  notifies each line card  and  that it is the newly active supervisor and that the line cards  and  should, from this point forward, send messages to supervisor , as indicated at block . The newly active supervisor  also conducts a \u201cconsistency check\u201d on each line card  and . In particular, supervisor  queries each line card  and  for their sequence numbers, as indicated at block . To perform these tasks, the newly active supervisor  may send a SWITCH_SEQ SCP command message to each of the line cards  and , which contains the address of supervisor card . Each line card  and  responds by sending its current sequence number to the newly active supervisor card .","The high availability manager  then compares the retrieved sequence numbers to the sequence number stored at its sequence database . More specifically, the high availability manager  determines whether any of the sequence numbers from the line cards  and  is greater than its sequence number, as indicated at decision block . Suppose, for example, that the last sequence number provided to the standby supervisor  before the active supervisor  crashed was sequence number \u201c21\u201d. If the sequence number stored at each of the line cards  and  is less than or equal to this sequence number (i.e., \u201c21\u201d), then the high availability manager  \u201cknows\u201d that all of the state or condition information stored at each line card  and  is consistent with the state or condition information stored in the sync records , ,  and  of the synchronization databases , ,  and  at the newly active supervisor .","If, however, a line card, such as line card , returns a sequence number (e.g., \u201c22\u201d) that is greater than the sequence number at sequence database  of the newly active supervisor , then the high availability manager  concludes that at least one change was implemented by line card , but was never received by the newly active supervisor . Since the newly active supervisor  cannot \u201crecover\u201d this change, it preferably responds by directing the respective line card (i.e., line card ) to reset all of its state or condition information, as indicated by Yes arrow  leading to block .","Following the line card \u201cconsistency check\u201d and the resetting of those line cards, if any, that failed the consistency check, the high availability manager  at the newly active supervisor  next proceeds to determine whether any events are still \u201copen\u201d, as indicated at block . In particular, the high availability manager  examines the pending events table  at its event database . As described above, when producing and listening applications complete their processing of event instances, they issue eventComplete( ) API calls, which result in those applications being cleared from the pending events table  for the respective event at both supervisor cards  and .","After a crash or failure of the active supervisor, an event may be open at the newly active supervisor  for several reasons. For example, the application at the previously active supervisor  may not have completed its processing of the subject event prior to the supervisor  crashing or failing. Alternatively, the application may have completed its processing of the subject event but not yet issued an eventComplete( ) API call or, if the eventComplete( ) call was issued, the previously active supervisor  may not yet have issued a corresponding EVENT_COMPLETE message to the then standby . In either case, the newly active supervisor  considers the subject event to be an open event. By applying one or more Boolean operations to the two bit maps created for each event, the high availability manager  can quickly determine which applications, if any, did not complete their processing of each event. If there are one or more applications which have yet to be cleared for any event, as reflected in the pending events table  at the newly active supervisor , then the high availability manager  preferably takes some recovery action.","More specifically, as described above, for each event type that an application defines or registers as a listener, the application also defines an event_recovery_func( ). For each open event that was identified at step , the high availability manager  executes or calls for execution by the application the event_recovery_func( ) specified by the application that had yet to complete the event prior to the crash or failure of the previously active supervisor , as indicated at block . The event_recovery_func( ) preferably restores the logical synchronization database for the respective application to a consistent state. For the Spanning Tree Protocol (STP), for example, the event_recovery_func( ) may be a redo operation. Specifically, if the STP application has not completed a PORT_CHANGE_STATE event at the time the active supervisor  crashes or fails, the new spanning tree port state from the open event is saved at the standby supervisor , and an SCP set command is sent to the line card for the respective port in order to set the port's state to the new spanning tree port state. Even if the active supervisor  had sent such an SCP set command before crashing or failing, re-sending it is harmless. For DTP and PAgP, the event_recovery_func( )s may be reset operations. Thus, if a DTP or PAgP NEGOTIATION event is open following a crash or failure of the active supervisor , the respective port(s) or line card(s) are preferably reset.","The newly active supervisor , as part of its recovery functions following the crash or failure of the active supervisor , may also build one or more switchover databases. The switchover database may indicate which line cards, if any, failed the consistency check and thus must be re-stared. It may also list all of the open events and specify the corresponding event_recovery_func( )s that must be executed.","Upon completing the consistency check and responding to any open events, the newly active supervisor  starts or wakes up the applications loaded onto supervisor , as indicated at block  (). Rather than starting from an initialization state, however, these applications start running based on the contents of their corresponding synchronization databases at the newly active supervisor , as indicated at block . That is, the applications begin running based on the state or other condition information that was synchronized to the newly active supervisor  before it became the active supervisor and determined to be valid. Accordingly, the applications do not waste time starting over from initialization states. Switch  can thus resume forwarding messages with little disruption despite the crash or failure of the previously active supervisor .","As part of the switchover process, the high availability manager  at the newly active supervisor  preferably creates a table or other data structure that has a record or cell for each port  at switch . As each application performs its recovery functions, e.g., the event_recovery_func( ), it may determine that one or more ports  should be brought down and reinitialized. If so, the application preferably identifies or marks that port in the data structure created by the high availability manager , unless that port has already been marked by some other application. When the applications have all completed their recovery functions, the high availability manager  checks this table or data structure and brings down and reinitializes all of the designated ports. For example, one application, e.g., DTP, may conclude that no action need be taken in response to the active supervisor crashing or failing, while a second application, e.g., PAgP, may determine that a port or an entire line card must be restarted. The applications, e.g., DTP, may also check this data structure so as to learn whether any ports or line cards are to be restarted.","Hot-Swapping of Supervisor Cards\/Global Synchronization","The present invention is also able to support the hot swapping of supervisor cards. The term hot swapping refers to the replacement of components, in this case supervisor cards, without having to shut-down and restart the affected equipment, in this case the switch. Suppose, for example, after failing, that supervisor card  is removed, and later on a new supervisor card, which will also be referred to by designation number  for simplicity, is installed into switch . Each application that utilizes the high availability facilities of the present invention, in addition to defining an event_recovery_func( ) among others, also defines a global_sync_func( ) which is used to synchronize all of the application's sync records to the standby supervisor. Furthermore, the high availability managers also maintain a global_sync_done flag for each sync record. Initially, the global_sync_done flag for every sync record is deasserted or set to false.","When the high availability manager  at the currently active supervisor  determines that a new supervisor  has been inserted, e.g., \u201chot\u201d inserted, it begins calling the global_sync_func( ) defined by each application so as to synchronize the synch records for each application to the current standby supervisor . Execution of the global_sync_func( ) for a given application may result in the application calling a series of ha_tx_sync( ) functions. Each of the ha_tx_sync( ) functions may take a particular sync record, generate a corresponding SYNC_RECORD_MESSAGE  containing that sync record and place the SYNC_RECORD_MESSAGE  in the SYNC_Q .","From the SYNC_Q  the SYNC_RECORD_MESSAGE  is sent to the current standby supervisor  where it is unpacked. That is, the SYNC_RECORD_MESSAGE causes the corresponding sync record at the current standby supervisor  to be updated. After the application has synchronized a given sync record to the current standby supervisor , it may call a get function and a set function in order to assert or set to true the global_sync_done flag for the given sync record. This process is repeated by each application at the current active supervisor . Once a given sync record has been synchronized to the standby supervisor  and the corresponding flag has been set to true, the application can, in response to one or more protocol events, call the ha_tx_sync( ) function in order to update that record. Until the global_sync_done flag is set to true for a given sync record, the application is preferably precluded from issuing any ha_tx_sync( ) functions (other than in connection with a global sync operation) for that sync record.","It should be understood that multiple sync records may be merged or grouped into a composite record. All of the sync records of this composite record may then be synchronized to the current standby supervisor  by calling a single instance of the ha_tx_sync( ) function on the composite record.","It should be further understood that the high availability entities  and  and\/or the sequence databases  and  preferably implement some type of wrap-around function or process when the sequence number wraps around from its highest value to its lowest value. Suitable wrap-around solutions for use with the present invention are well-known to those skilled in the art.","Although the invention has been described in connection with applications operating at layers 2 and 3 of the Open Systems Interconnection (OSI) Reference Model, it should be understood that it may be used with applications, protocols or processes operating at other layers. In addition, the high availability facilities of the present invention could be used by two separate intermediate network devices or entities in order to share or synchronize information between them.","The foregoing description has been directed to specific embodiments of this invention. It will be apparent, however, that other variations and modifications may be made to the described embodiments, with the attainment of some or all of their advantages. For example, other communication architectures or paradigms, besides event-based architectures, such as primitives, commit protocols, etc., may be employed by the active and standby supervisor cards to exchange information relating to the spanning tree protocol. Therefore, it is an object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The invention description below refers to the accompanying drawings, of which:",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIGS. 4","b":["7","10","12"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 5 and 8"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIGS. 6 and 9"}]},"DETDESC":[{},{}]}
