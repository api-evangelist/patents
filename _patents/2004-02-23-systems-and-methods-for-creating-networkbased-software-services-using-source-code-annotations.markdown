---
title: Systems and methods for creating network-based software services using source code annotations
abstract: A developer can express the logic offered by a Web service, or other network accessible service, using a standard programming language augmented with declarative annotations specifying preferences for exposing that logic as a Web service. At compile time, an enhanced compiler can analyze the annotated source file and automatically generate the mechanisms required to expose its functionality as a Web service or network accessible service.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07707564&OS=07707564&RS=07707564
owner: BEA Systems, Inc.
number: 07707564
owner_city: San Jose
owner_country: US
publication_date: 20040223
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CLAIM OF PRIORITY","COPYRIGHT NOTICE","FIELD OF THE INVENTION","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application claims priority from the following application, which is hereby incorporated by reference in its entirety:","U.S. Provisional Application No. 60\/449,958, entitled \u201cSystems and Methods for Creating Network-Based Software Services Using Source Code Annotations\u201d by Kyle Marvin, et al., filed Feb. 26, 2003.","A portion of the disclosure of this patent document contains material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document of the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","The present invention relates to the creation of network-accessible services, such as Web services.","There is a rapidly expanding industry emerging around Web services, a term loosely defined as the ability to share software as a service using network protocols. Web services and other network accessible software services require significant time. As the Web service infrastructure evolves, it is becoming increasingly complicated, requiring more time, skill, knowledge and ultimately money to create Web services. Consequently, the generation and deployment of Web services is increasingly tedious and unnecessarily complicated for the average developer. Currently, in addition to developing the software logic offered via the Web service, developers are also required to address a number of tedious and complex issues involving Web service generation and deployment. Examples of such issues include but are not limited to, security, reliable messaging and message pre\/post processors (a.k.a. interceptors).","It is not uncommon for Web services to require several forms of security simultaneously. The creation and deployment of secure Web services and other software services made available over networks is a complex and time consuming process for both software developers and system managers.","Reliable messaging is often required for Web services, but yet is not inherent in the protocols typically used. Reliable messaging is implemented on both the client and the server and will generally support a callback path, used in the event of a failure. Thus, developers require considerable specialized knowledge and time to develop, test, and deploy reliable messaging schemes.","In many practical Web services implementations and system integrations, it is necessary to manipulate both incoming and outgoing network messages with message pre\/post processors. These manipulations can include transformation of message headers and contents, logging, auditing, message redirection, and protocol conversions.","The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. It should be noted that references to \u201can\u201d or \u201cone\u201d embodiment in this disclosure are not necessarily to the same embodiment, and such references mean at least one.","Systems and methods in accordance with the present invention can provide a flexible and extensible platform that simplifies the task of developing Web services, or other network accessible services, by allowing Web service developers to focus on developing the logic of the Web service rather than implementation and deployment particulars. In some embodiments of the present invention, the developer expresses the logic offered by the Web service using a standard programming language augmented with declarative annotations specifying preferences for exposing that logic as a Web service. At compile time, an enhanced compiler can analyze the annotated source file and automatically generate the mechanisms required to expose its functionality as a Web service or network accessible service. Because the annotations are declarative, they may be easily visualized, created, and modified using a graphical user interface, further simplifying the developer's task. Thus, such an approach decreases the time, knowledge, skill and ultimately cost required to develop the complex support required to proved services in these environments.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 1","FIG. 1"],"b":["102","110","115","120","112","125","100","100"]},"Web server  represents one or more computing devices equipped with enhanced Web services  of the present invention to provide conversational and asynchronous Web services to remote clients, such as user client  as well as enterprise servers  and , which are communicatively coupled to networking fabric . Enhanced Web services  can include an annotated source code , an enhanced compiler , and various deployed service components . As will be discussed in further detail below, when annotated source code  is compiled by enhanced compiler , the compiler generates one or more object files, software components and deployment descriptors to facilitate the automated deployment of Web service components . In the illustrated embodiment, developer client  represents a computing device equipped with integrated development environment (IDE)  to facilitate graphical interface-based design and development of enhanced Web services  by a developer. In place of, or in addition to being communicatively coupled to Web server  through networking fabric , developer client  can be coupled directly (e.g. via a local area network) to Web server  as shown. Furthermore, rather than being installed on an external client device such as developer client , IDE  may instead be collocated with enhanced Web services  on Web server  without departing from the spirit and scope of the invention.","Enterprise servers  and  represent publicly accessible servers belonging to one or more organizations that have published Web service components  and  with associated Web service description files  and , respectively. In the illustrated embodiment, Web service description files  and  represent XML-based Web service description language (WSDL) files that advertise the capabilities of Web service components  and  to devices coupled to networking fabric  including user client  and Web server .","User client  represents a general-purpose computer system such as, but not limited to a desktop computer, laptop computer, palmtop computer, network appliance, a personal digital assistant (PDA), and so forth, equipped with Web browser . In the illustrated embodiment, user client  accesses (e.g. via networking fabric ) Web page(s)  hosted by eCommerce server . Web pages  may include content , such as merchandise descriptions, reviews and pricing information, as well as one or more Web functions . When executed, Web functions  may send requests to Web server  causing one or more service components  to be executed, which in turn may send one or more requests to enterprise servers  and  causing one or more remote components  and\/or  to further be executed.","For example, assume Web page(s)  displays merchandise that is offered for sale by a given online merchant via eCommerce Web server . Web function(s)  may request various functions of a shopping cart service provided by Web server  including an \u201cadd an item to cart\u201d function, a \u201cremove an item from cart\u201d function, and a \u201ccheckout\u201d function. By selecting a button graphically displayed on Web page(s)  for example, a user may cause one or more requests for shopping cart functions to be generated. This in turn may cause one or more of service components  to be remotely executed on Web server  via e.g. the well-known Simple Object Access Protocol (SOAP). In the illustrated example, the initiation of a checkout function by user client  may cause Web server  to communicate with enterprise servers  and\/or  to obtain one or more credit authorizations for use by the online merchant in completing the user's purchase transaction. In one embodiment, Web server  communicates with enterprise server  and\/or  based upon their public interfaces advertised by WSDL files  and\/or . Once enterprise servers  and\/or  provide Web server  with the solicited credit information, server components  can perform a variety of actions depending upon the particular Web logic deployed.","In the above example, enhanced Web services  processed a single shopping cart transaction pertaining to a single user client. More often, however, Web services are required to process numerous simultaneous transactions while maintaining state associated with each transaction. In the shopping cart Web service for example, each user client will use a separate shopping basket, each containing a separate list of items. Each user client will request a new shopping cart, add items to the shopping cart, remove items from the shopping cart, and finally check out or cancel the operation. Thus, the Web service needs to keep track of all the shopping lists and ensure that each incoming client request (e.g. new, add, remove & check-out) is applied to the correct list. Furthermore, each credit authorization request needs to be correlated with the correct user so as to avoid mistaken authorizations. Therefore, it should be apparent that as the number of users and associated transactions increase, the need to efficiently manage conversations (i.e. correlate multiple requests and responses) and the associated state becomes increasingly important. Accordingly, the present invention automatically generates code to manage state associated with multiple, simultaneous conversations. Similarly, because external Web services (i.e. such as those offered by enterprise servers  and ) are not always designed to respond to the initiating Web service immediately, the present invention further provides the automatic generation of code for managing one or more asynchronous transactions where for example, responses may be temporally separated from the initiating request and arrive on a separate connection.","In one embodiment, enhanced compiler  compiles programming language source code that has been augmented with declarative annotations specifying preferences for exposing programming logic as a Web service. At compile time, enhanced compiler  analyzes the annotated source file and automatically generates the mechanisms necessary to expose its functionality as a stateful and\/or asynchronous Web service based at least in part upon the annotations.","At run time, enhanced Web services  of the present invention receives messages from remote clients requesting that one or more Web service methods be invoked. Enhanced Web services  parses each message to identify the method being called and dispatches the request to one or more of service components  depending upon whether the requested method comprises a stateless or stateful request for example.","In some embodiments in accordance with the present invention, IDE  facilitates graphical interface-based Web service design and development. Using IDE  for example, a developer is able to graphically associate remote clients, external services, Web methods, and so forth, with the Web service logic being designed. Additionally, using IDE  a developer is able to identify which methods (if any) should be buffered, which methods should be asynchronous, which methods should be stateful, and which methods are to cause a non-isomorphic mapping between incoming message elements and native language objects for example. Furthermore, once a method has been added to the Web service (e.g. via graphical manipulation by the developer), IDE  provides the developer with the ability to further define and\/or modify the method by specifying one or more parameters and\/or attributes. For example, if a developer drags a method indicator to graphically connect the current Web service to the client, a dialog may be displayed to enable the developer to declare a method name, member variable names, variable types, expected return types and so forth. Similarly, if a developer graphically associates an external service with the Web service under development, the developer may be provided the opportunity to import a description file for the Web service, such as WSDL file  or .","In one embodiment, IDE  automatically annotates the Web service source code with declarative meta-data based upon graphical and\/or textual input provided by the developer through one or more interfaces of IDE . In one embodiment, enhanced compiler  utilizes the meta-data annotations during compilation of the source code to facilitate generation of stateful and asynchronous Web services. For example, if a developer graphically identifies a method as being buffered (e.g. by dragging an icon representing a buffer onto or near the associated graphical representation of a method), IDE  annotates the associated method within the source code with meta-data to indicate to enhanced compiler  that the method is to be buffered. During compilation, enhanced compiler  recognizes the method as being buffered based at least in part upon the meta-data annotations, builds one or more class files (and potentially additional support files) and deploys them to server  to buffer incoming requests for that method accordingly.","In one embodiment, a developer using IDE  is able to toggle between various screen views including a graphical design view, and a source view. In accordance with one embodiment of the invention, using the source view a developer can manually enter meta-data annotations directly within the source code to identify those portions of the source code that are to be exposed as Web services.","As the developer interacts with IDE  to specify a Web service, IDE  contemporaneously creates directories on Web server , into which various files, including the Web service source code file and imported Web service description files, are stored. In one embodiment, IDE  attaches a \u201c*.jws\u201d extension to the Web service source code filename, which is then stored in a publicly accessible project directory on Web server . In one embodiment, Web server  is configured to redirect client requests for this file to a servlet for processing instead of returning the contents of the file to the client. IDE  may communicate with Web server  to create such files and directories via networking fabric  using one or more network protocols such as the file transfer protocol (FTP).","As previously mentioned, source code files can be augmented by adding (whether automatically by IDE  or manually by the developer) meta-data annotations to the source code files to describe which portions of the source files are to be exposed as Web services and to control implementation details, such as wire protocol preferences. In one embodiment, meta-data annotations are placed within a comment field immediately preceding the statement or declaration the annotation will operate on. In one embodiment of the invention, meta-data annotations include one or more symbols and\/or keywords defined by an extended syntax known to the compiler. In the illustrated embodiment, a keyword preceded by a \u2018@\u2019 symbol indicates to enhanced compiler , which is equipped to recognize such a symbol\/keyword combination or derivation thereof based upon the extended syntax, that the associated source code is to be exposed as part of the Web service.","In one embodiment, compiler  has been enhanced to recognize numerous such meta-data annotations. In one embodiment, enhanced compiler  recognizes meta-data annotations that indicate whether an associated method is stateful, and if so, whether the method applies to the start of a conversation (i.e. a \u201cstart\u201d method) between a specific client and Web server , a continuation of a conversation (i.e. a \u201ccontinue\u201d method), or the completion of a conversation (i.e. a \u201cfinish\u201d method). In one embodiment, stateful annotations cause enhanced compiler  to generate one or more persistent components to maintain conversational state relating to the associated method. In one embodiment, enhanced compiler  automatically generates one or more Enterprise Java beans (such as an entity bean) as well as associated deployment descriptors to store and manage such conversational state. In one embodiment, each time a start method is invoked at run-time, a new instance of a conversation is created, and a unique identifier is associated with that conversational instance by a persistent component to facilitate management of multiple simultaneous conversations. In one embodiment, a client requesting a conversational start method generates a unique identifier that is used for each subsequent transaction between that client and the Web service until a finish method is called. In one embodiment, the identifier is passed between the client and Web service by way of a SOAP based message header.","In addition to conversational annotations, in one embodiment enhanced compiler  also recognizes meta-data annotations indicating whether an associated method should be buffered to reliably handle a large number of simultaneous requests at peak usage times. In one embodiment, compilation of source code containing buffered annotations causes enhanced compiler  to instantiate one or more queues to temporarily store one or more associated requests such that they may be processed in order of arrival when server  has resources free to process them. In one embodiment, enhanced compiler  utilizes one or more Enterprise JavaBeans\u2122 (such as a message driven bean) to dispatch queued requests.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 2","FIG. 2"],"b":["206","210","201","205","206","209","201","204","210","209","204","106","106"]},"Although in the illustrated embodiment, each conversational annotation is preceded by an @OPERATION annotation, other embodiments may not require such a construct. For example, the @OPERATION annotation may be inferred from the @CONVERSATION annotation or other characteristics of the source code (e.g., modifiers such as public, private and static). Moreover, the various meta-data annotations described herein represent a subset of meta-data annotations that enhanced compiler  is equipped to recognize. Accordingly, the present invention should not be read as being limited to only those meta-data annotations described. Furthermore, it should be noted that any convenient meta-data annotation syntax could be utilized so long as the compiler is equipped to recognize such an extended syntax. In addition, it should be noted that the meta-data need not be communicated to the compiler using source file annotations, but could instead be communicated using e.g. a separate file. For example, the enhanced compiler could be programmed to read meta-data from a specially formatted XML file with the same name as the source file, but with a different file extension without departing from the spirit of the invention.","It is not always desirable or possible for Web services to return a response to a particular request immediately. Some Web services, called asynchronous Web services, are designed to return one or more responses temporally separate from the associated original requests. In one embodiment, developers may declare asynchronous responses to clients inside an inner interface called Callback. For example,",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"public static interface Callback {"]},{"entry":[{},"\u2003\u2003\/* @Operation"]},{"entry":[{},"\u2003\u2003\u2009* @Conversation Finish *\/"]},{"entry":[{},"\u2003\u2003void returnResult(String s) ;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["Callback client;\n\nWhen enhanced compiler  encounters the Callback interface and associated member variable declaration, it automatically generates code to create a client proxy object that implements the declared Callback interface for returning asynchronous responses and assigns it to the declared member variable. For example, the Web service developer could generate the asynchronous response declared above using the following line of code:\n","client.returnResult(\u201cIt worked!\u201d);"]}}}},"The client proxy object, including the callback address and a conversation identifier, is stored as part of the conversational state of each Web service instance to associate each callback with the appropriate client instance.","Annotated source code can further define bindings that specify how the client interface is bound to physical wire formats and protocols. In one embodiment, each service interface can have multiple service bindings for different protocols. In one embodiment, supported service bindings include (but are not limited to) SOAP over HTTP, SOAP over SMTP, generic HTTP Post of XML, transport of XML over other protocols such as FTP and mail, transport of XML over Java Messaging Service (JMS) or Microsoft Message Queuing Services (MSMQ), connection to proprietary protocols and so forth. In one embodiment, information about service interfaces and protocol bindings can be exported via WSDL files.","In one embodiment, the method invoked by Web server  can be inferred from the data sent over the wire protocol and other meta-data as is illustrated by . For example, in , the signature of the \u2018greeting\u2019 method has two parameters, labeled firstname and lastname. Incoming SOAP messages containing an appropriately qualified <greeting> element in the message body and having child elements <firstname> and <lastname> as shown in  should cause this method to be invoked at run time. Enhanced Web Services  will parse the request illustrated in , find the destination object based on the URL\/app\/mypackage\/CreditReport.jws, create String objects based on the <firstname> and <lastname> elements, and pass them as parameters to the \u201cgreeting\u201d method based on the <greeting> element. Similarly, Enhanced Web Services  will use the return value of the greeting method to generate an HTTP SOAP response such as that illustrated by .","As was previously mentioned, in one embodiment, the annotated meta-data of the present invention facilitates access to external services (such as service components  and ) by enhanced Web services . In one embodiment, enhanced compiler  detects one or more annotated member variable declarations representing external services, finds the associated service definition files, automatically generates and assigns proxy objects designed for interacting with the external services, and automatically generates and associates code to handle asynchronous responses from those services. In one embodiment, enhanced compiler  scans a provided classpath for one or more service definition files (e.g., WSDL files) matching the classnames of the annotated member variables and automatically generates proxy objects based on the service description. This enables the Web service developer to interact with the external Web service as if it was a local Java object. For example, the declaration",{"@attributes":{"id":"p-0050","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/* @Service *\/"]},{"entry":[{},"public Bank mybank;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":"float balance=mybank.getBalance( );\n\nIn this case, the mybank proxy object generated by enhanced compiler  would send a request to the remote Bank service using the address, protocol and format information in the Bank.wsdl file found on the classpath. At run time, the code generated by enhanced compiler  will automatically instantiate one proxy object for each of the \u201c@Service\u201d annotations found within the source code as shown above.\n"}}}},"A service description file associated with an external service may indicate it has stateful conversation methods. In this case, each proxy object generated for interacting with those services will include code to generate and store a unique identifier for the associated conversational instance of the external service. The proxy object will use this unique identifier when generating the conversational message headers stipulated by the external service (see \u201cConversational Message Headers\u201d below).","Each proxy object, including a unique identifier if present, can be stored as part of the state of the service in development. This effectively associates each instance of the service in development with the appropriate instances of external services.","External services do not always return a response immediately. Accordingly, enhanced compiler  automatically generates software for receiving asynchronous responses, associating the responses with the appropriate conversational state, and processing the responses with user defined code.","In accordance with the teachings of the present invention, an asynchronous Web service declares its asynchronous responses as \u201cout methods\u201d in it's associated service description (e.g., WSDL) file. Out methods can be viewed as remote callbacks, i.e., remote functions the asynchronous Web service invokes to return the result associated with an earlier request back to the caller. Software generated by the enhanced compiler of the present invention will pass these asynchronous responses to specially named member functions as may be defined by the developer. In one embodiment, these member function names are formed by appending the name of the asynchronous out method to the name of its local proxy object. For example, to handle a creditCheckResponse( ) out method of the Bank service defined above, the developer would generate a function of the following form:\n\n","In one embodiment, the conversational aspect of the present invention is facilitated through the use of message headers that help maintain conversational state throughout the lifetime of the conversation. In one embodiment of the invention, one or more of a conversation ID header, a default callback location header, and an echoed conversation ID are utilized to maintain conversational state. For example,  illustrates a conversation ID header and a callback location header within a SOAP message from the client to the server. The echoed conversation ID is utilized in responses from the server to the client.","In one embodiment, the conversation ID represents a unique string that is generated by the originator of the first message of the conversation. The conversation ID may include any structure so long as it is globally unique. In one embodiment, the client generates a globally unique identifier (GUID), which is then encapsulated in a SOAP header, however, Uniform Resource Locators (URLs), timestamps, and other unique objects can be used to generate a unique identifier in lieu of the GUID. In one embodiment, the client embeds its own instance identifier as part of the conversation ID so asynchronous callbacks from the server that include the conversation ID can be used to route the callback to the appropriate client instance. In addition, if the first message of the conversation returns a synchronous response, the server can generate the GUID and return it to the client as part of the response. When \u201ccontinue\u201d or \u201cfinish\u201d methods are sent as part of a conversation (either from the client to the server or from the server to the client), the same conversation ID that was established in the start message is echoed verbatim. In one embodiment, the callback location represents an arbitrary URL indicating where the client involved in the conversation is listening for callbacks from the Web service. In one embodiment, the callback location header can appear in association with any start, continue or finish method.",{"@attributes":{"id":"p-0057","num":"0060"},"figref":"FIG. 5","b":["104","502","506","509","502","502"]},"Once compiler  receives annotated source code files , parser  reads and parses programming statements contained within the source code. In one embodiment, compiler  is enhanced to recognize annotations based on an extended syntax for specifying functionality of the source file to be deployed as a Web service. Accordingly, as parser  parses the annotated source code, it identifies the presence and composition of embedded annotations based on this extended syntax. In one embodiment of the present invention, compiler  infers by way of the source code annotations the interface of the Web service that is to be exposed to remote clients, the interface of services that will be called by the runtime to be created by compiler , as well as internal storage requirements and persistence behavior of the Web service.","During the parsing of annotated source code , parser  identifies the object types used in the code and attempts to locate definitions corresponding to each type. For example, if a variable \u201cb\u201d of type \u201cBank\u201d is declared, parser  determines whether an object or library file defining the \u201cBank\u201d type already exists within a given set of directories (e.g., as created by IDE  on Web server ). If an object or library file does not exist, parser  determines whether a source file exists that could be run through compiler  to generate an object file. Similarly, if neither an object file, library file, nor a source file exists, parser  determines whether a Web service description (e.g., WSDL) file exists that could be used by compiler  to generate an object file implementing a proxy object for interacting with the associated Web service. In accordance with one embodiment of the invention, if an object file is determined not to exist, parser  walks through an ordered list of file types so as to identify a file that could be used in generating the requisite object file.","In one embodiment, compiler  generates one or more object files defining publicly accessible service components  that may be executed by one or more remote clients. In addition, compiler  generates meta-data  based on annotated source code  and associates it with object codes  and service components . In one embodiment, meta-data  includes descriptions of the annotations, methods, member variables, external services and callback interfaces associated with the service. Once compiler  has compiled annotated source code  into executable code, the code is then provided to an execution engine (not shown) that controls the execution of the code (by e.g. a processor), and performs conventional execution runtime services, such as memory allocation request and release, error\/exception handling, and so forth. For the illustrated embodiment, compiler  includes an application programming interface (API) (not shown), through which programming statements contained within annotated source code  may be programmatically submitted for compilation by a variety of application-specific processes. For example, in accordance with one embodiment of the present invention, Web server  makes calls to enhanced Web services  upon receiving SOAP encapsulated XML method invocations via networking fabric .",{"@attributes":{"id":"p-0061","num":"0064"},"figref":"FIG. 6","b":["506","506","502","601","505","506","602","604","506","608","609","610","611","506","612","506","614","616","506","506"]},"Compilation of the annotated source code by enhanced compiler  causes one or more object files, software components, and deployment descriptors to be generated so as to facilitate the automated deployment of the Web services.  illustrates a conceptual Web service component resulting from the compilation of one or more annotated source code files in accordance with one embodiment of the invention.","The Web service component of  includes a servlet container and an Enterprise JavaBean (EJB) container. The servlet and EJB containers are communicatively coupled together for the dispatch of Web service requests. In the illustrated embodiment, the servlet container listens for requests received on a designated communication port, and uses deployment descriptors (DESC) to identify which servlet should respond to the request. In one embodiment, all requests for files with a \u201c.jws\u201d extension are routed to the listener servlet. In one embodiment, the listener servlet uses the URL of the request to determine which Web service should receive the request and identify the location of associated meta-data (META)  (e.g., stored in the class file) previously generated by enhanced compiler .","In one embodiment of the invention, when the enhanced compiler compiles the annotated source code files, it builds and deploys one or more EJBs depending upon the constitution of the code. At a minimum, the enhanced compiler builds and deploys at least one dispatch component () to service messages forwarded from the servlet container. If the enhanced compiler identifies that the Web service has at least one buffered method, the enhanced compiler generates a queue structure () in addition to deploying a message driven bean to service the queue. Similarly, if the particular Web service contains stateless methods the enhanced compiler deploys a stateless session bean to handle requests for those methods. In addition, if the Web service contains stateful methods, the enhanced compiler will deploy an entity bean to manage conversational state associated with each service instance. Dispatch components  and  use meta-data (META)  generated by enhanced compiler  to determine whether the requested method is stateful or stateless and deploy it to a stateful or stateless component as appropriate. If the requested method is stateful, dispatch components  and  further use meta-data (META)  to determine whether the method is a start method, continue method or finish method, and creates a new stateful instance or looks up a previously created instance as appropriate (see discussion of  below).",{"@attributes":{"id":"p-0065","num":"0068"},"figref":["FIG. 8","FIG. 7"],"b":["104","100","112","802","803","804","510","506","806","702","706","510","808"]},{"@attributes":{"id":"p-0066","num":"0069"},"figref":["FIG. 9","FIG. 7"],"b":["901","902","702","904","902","706","704","903","906","908","910"]},"The dispatcher then continues to determine whether the message represents a start method () a continue method () or a finish method (). If the method represents a start method (), a new instance of an entity bean containing the Web service logic and conversational state is generated (), and then associated with the identifier (). The dispatcher uses the associated meta-data to determine if annotated source code  defined a Callback interface and declared a variable of type Callback. If so, a client proxy object for interacting asynchronously with the client is created based on the Callback interface and is assigned to the declared variable. Further, the dispatcher determines whether annotated source code  declared one or more variables for interacting with external services. If so, the dispatcher creates proxy objects for interacting with these remote services based on the interfaces defined by the associated service definition (e.g., WSDL) files, and assigns them to the declared variables. Further, the dispatcher configures the Web service to accept all asynchronous callbacks declared in each of the associated service definition (e.g., WSDL) files and route the callbacks to Web service methods named by appending the declared variable name to the callback method name (e.g., mybank_creditCheckResponse(String result)). The dispatcher stores all proxy objects (whether created for interacting with the client or other external services) as part of the conversation state of the entity bean. The message is then routed to the new entity bean instance for further processing by the Web logic.","If the method represents a continue method () or finish method (), the bean instance associated with that identifier is found (, ), and the message is routed to that bean for further processing by the Web logic (,). With the finish method however, the bean instance is destroyed once the processing has completed ().","In one embodiment of the invention, once the message has been routed to a bean (whether stateful or stateless), a SOAP handler removes the encapsulated XML message from the SOAP body, determines which method of the Web service logic to invoke based on the root element of the XML message, maps XML child elements onto newly created programming language objects to be used as arguments to the method, and invokes the Web service method passing the newly created objects as parameters. If the invoked Web service method returns a value synchronously, the bean will map the value onto a corresponding XML element, package it in a message and return it to the client using the same protocol details used in the request (e.g., SOAP over HTTP).","Once invoked, any Web service method can use the proxy objects created for generating calls to the client or external services. The proxy objects will map objects passed as parameters into corresponding XML elements and use them and the remote method name to generate and send a message to the remote service or client. In the case of external services, the message is generated and sent using the protocol specifics (e.g., SOAP over HTTP) specified by the associated service description file. In the case of the client, the message is generated and sent using the protocol specifics used by the client in the initial start method. In one embodiment, synchronous responses from the client or remote services are parsed to extract the result and map it onto a representative object, which is returned to the Web service code as the return value of the proxy object method invocation.","Asynchronous responses and requests from external services are dispatched to the appropriate entity bean by the listener servlet and dispatch beans just like requests sent by the client. These responses are routed to the appropriate method of the Web service logic identified by a special naming convention. Specifically, they are routed to methods named by appending the name of the external service out method to the declared service proxy variable name (e.g., mybank_creditCheckResponse(String result)).",{"@attributes":{"id":"p-0072","num":"0075"},"figref":"FIG. 10","b":["1000","1002","1004","1000","1006","1008","1010","1012","1004","1006","1006","1010","1002","1012"]},"Embodiments in accordance with the present invention can use source code annotations to decrease the time, knowledge, skill and ultimately cost required to develop security capabilities into Web services. In some embodiments, developers and system managers can utilize the enhanced compiler to automatically create, deploy, and manage multiple types of security using the source code annotations without requiring knowledge of the specifics of any of these security types. The security can be applied to request messages, callbacks or response messages, or requests and callbacks originating with intermediate services in a chain. The security capabilities supported by the invention are applicable to stateful or stateless services, and both synchronous and asynchronous services. Types of security that can be specified by developers using the invention can include:\n\n","Some embodiments can enable components to \u201crun-as\u201d a static principal, meaning all calls from that component to external services will appear to be from a the static principal (e.g., a single person or system) independent of who actually invoked the action that caused the external call. In some cases, this can be a direct mapping on to the static configuration of run-as defined in the J2EE specification.","Some embodiments enable components to \u201crun-as\u201d the authenticated subject that started a conversation (i.e., instantiated the component). In some cases, role-based constraints can still be applied and will be based on the effective Subject.","Some embodiments enable (possibly via configuration) calls to external services to have external callbacks run-as the Authenticated Subject that started the conversation (i.e., instantiated the component). This is similar to run-as start user, but applied to callbacks. This feature may be used to address the scenario where a conceptually synchronous call is implemented as an external asynchronous request, and the author does not want the external caller's identity (Principal) associated with actions taken within the event handler. Note that in some embodiments, external software components may always run in the context of their container, so run-as may only be applicable to external callbacks to the external service proxy instance. In these cases, since we don't have specific request\/response correlation, the options are to:\n\n","Some embodiments may provide an API to make the authenticated user available. This is useful when the \u201ccalling\u201d Principal was set via \u201crun-as\u201d.","Some embodiments support declarative security on Callbacks and may also support the ability to bind the Principal that starts a conversation to callback invocation.","Some embodiments may use an approach to role definition that closely parallels that used by J2EE. Roles added to methods are extending privileges downward (adding broader privileges).","Some embodiments may provide a number of additional capabilities including:\n\n","In some embodiments, an annotation such as:\n\n","In some embodiments the roles-allowed tag is optional and can be applied at a class level or at a @operation method level. Any roles that are applied at the class level may be applied to all operations (i.e. a class level role-required may exist on each @operation). For example, this is semantically equivalent to using the element <method-name>*<\/method-name> within an EJB <method-permission>.","During dispatch, the runtime messaging environment may reject any request where:\n\n","In some embodiments, an annotation such as:\n\n","In some embodiments, the annotation @common:security roles-referenced=\u201c<role-name> [ . . . <role-name>]\u201d declares the space separated list of role names that are used as parameters to isCallerInRole(String roleName). This annotation serves two purposes:\n\n","In some embodiments this annotation is optional and is only allowed at the class level for various service and proxy definitions. These roles may not imply permission to invoke the operation and should not be considered during dispatch. They may only represent the names of the roles referenced from within the operation.","To simplify administration, some embodiments assume that all roles defined through roles-allowed and callback-roles-allowed may be used within the code. This can imply that only roles reference in code but not part of the declared role must be added via the roles-referenced tag.","In some embodiments, during code-generation, the roles included in roles-allowed and roles-referenced need to be included in the ejb-jar.xml deployment descriptor.","In some embodiments, the annotation @common:security run-as=\u201cstaticRoleName|<start-user>\u201d provides the means to specify a component to run as a particular user. This annotation is optional and may only allowed at the class level. In an example, this annotation has the same semantics as the EJB run-as mechanism, (i.e. it does not effect the caller's identity, it establishes the identity that the component will use when it makes calls). During code-generation, the role name included in run-as may be included in the ejb-jar.xml deployment descriptor.","The table below givens an example of one possible set of annotations that can be used in some embodiments.",{"@attributes":{"id":"p-0091","num":"0112"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Annotations in Some Embodiments"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"On","On",{}]},{"entry":[{},"On","Operation","Callback"]},{"entry":["Tag (1)","Class","Method","Method","Affects DD"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Roles-allowed","Y","Y","N","Y (2)"]},{"entry":["callback-roles-allowed","Y","N","Y","Y (2)"]},{"entry":["Roles-referenced","Y","N","N","Y"]},{"entry":["run-as","Y","N","N","Y"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":"Notes:"},{"entry":"(1) These tags are very rarely needed on an external service proxy declaration"},{"entry":"(2) All roles included in roles-allowed may be added to the deployment descriptor. This means that only roles referenced but not declared need to be added via the roles-referenced tag."}]}}]}},"br":{},"figref":["FIG. 11","FIG. 12"]},"In some embodiments, the @common:roles-allowed tag can be used on the @operation methods of, for example, proxy object definition files. Control execution may respect the run-as configured in the hosting component. In these cases, the @common:role-allowed will be evaluated with respect to the run-as principal.","In some embodiments, proxy objects may not be implemented as EJBs, in which case an administration path separate from the standard J2EE approach may be required to administratively modify the security applied to a control.","In some embodiments, the proxy objects may not be implemented as EJBs, in which case a mapping mechanism separate from the one commonly used in J2EE may need to be used to map roles when including externally provided control jars in an application.","In an example, if Web Services Security is a message-based model it can be layered on top of existing J2EE security. From an integration perspective, the key consideration is authentication since message level encryption and signature are not currently relevant to the J2EE runtime.","In some embodiments, when an incoming SOAP message includes WSSE based authentication that subject should be bound to the request rather than any transport provided subject. An exception to this is cases where the service is configured to bind the subject that starts a conversation to subsequent requests.","In some embodiments, there may be cases where a roles-allowed test is not met. Some examples of error responses in these cases include:\n\n","The following sections show examples of the use of source code annotation to create security services in the form of source code in the Java language. These examples are meant only for purpose of illustration and are not intended to communicate limitations on the functionality or embodiments of the invention. The names of the following section are based on exemplary file names that could be used to identify each segment of source code.","Certain embodiments can use source code annotations to decrease the time, knowledge, skill and ultimately cost required to develop reliable messaging capabilities for Web services. This provides the capabilities for a client and a service to communicate using guaranteed message delivery. In some embodiments, the enhanced compiler automatically creates the required reliable messaging software for selected Web services using the specifications provided by the annotations. A callback path is provided to notify the transmitting entity of delivery failure or time out. The messages traveling from the client are delivered to the service's message queue. Messages traveling from the server are delivered to the client. Developers have the option to set a number of parameters, which can include, the number of retries attempted, the time interval between retries, and the time to live for a message. The reliable messaging capabilities supported by the invention are applicable to both synchronous and asynchronous services.","Some embodiments will use SOAP headers in the underlying implementation. These cases can use a SOAP\/HTTP protocol binding, possibly using the capabilities of the runtime messaging infrastructure.","In some embodiments a void return signature may be used for methods transmitting messages in the runtime-messaging environment. Some examples of situations where a void return signature may be advantageous include:\n\n","Some embodiments of the invention will consider a message as having been successfully delivered when it is placed in the queue or queues for the one or more target services. This means that \u201cacknowledgment\u201d indicates that the message was delivered to the Service's queue, not the Service itself. A number of possible scenarios could result in the message never being delivered to the destination Service. Some embodiments may use J2EE platforms, in which case the server side integration can use the facilities of JMS.","Some embodiments will include extensions to the design of the queue delivery model, which can include:\n\n","Some embodiments may provide the capability to put messages submitted to the queue or directly to the service a predetermined order within the reliable messaging infrastructure. In some cases this capability may be desired to reduce the requirement to retransmit a sequence of messages if they do not arrive a required order.","Using the reliable messaging facilities, client software can be assured of message delivery to one or more queues or directly to one or more services. Some embodiments will provide delivery, which is transparent from the point of view of the client, to the remote service queue. Thus, the client software does not need to be modified to use the reliable messaging infrastructure. In some embodiments, the client can receive an invocation error if the message cannot be en-queued by the local message handling service. This can be made to appear to the client like any other resource error. In some embodiments, the client will receive an error event if the message cannot be delivered to the remote service queue.","The remote messaging system can provide client software with a number of benefits, which can include:\n\n","Using reliable messaging facilities, server software can provide assured message delivery to one or more queues or directly to one or more services. Several key capabilities of for servers have already been discussed.","Some embodiments may provide \u201cBlocking on Delivery\u201d capabilities. In this case, the reliable messaging system can block the invocation pending delivery confirmation from the remote server or queue. Note that this still does not ensure receipt by the destination Service. It's not clear how this could be easily accomplished as part of a transactional operation.","Some embodiments of the invention additional error notification capabilities. In these cases, reliable messaging system can deliver failure notification up to the point the message is delivered to the remote service implementation.","Some embodiments can provide \u201cDelivery Receipt Notification\u201d capabilities. In these cases, the reliable messaging system provides delivery receipts if there are corresponding paths build on the server side.","Some embodiments can provide the caller's control ID as part of the context delivered to the local service. This capability allows the reliable messaging system to provide callbacks the \u201csending\u201d components.","Some embodiments of the invention can have a constraint on the number of outstanding send operations. In some cases, a sender may only have a single outstanding send, possibly making the programming model is simpler since the caller knows what context the error is related to. In cases where multiple outstanding operations are allowed, an API can be provided, similar to ones typically used for exception handling, which provides the context back to the caller. In some cases, the number of messages allowed to be outstanding can be configurable.","In cases where the reliable messaging system ensures delivery to a queue, the receiving service may not be aware that the message was delivered reliably. The server side message handling service will en-queue the message to a queue, possibly after verifying that is it not a duplicate. Some embodiments will implement this functionality using the capabilities provided by JMS.",{"@attributes":{"id":"p-0114","num":"0148"},"figref":"FIG. 13","ul":{"@attributes":{"id":"ul0030","list-style":"none"},"li":{"@attributes":{"id":"ul0030-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0031","list-style":"none"},"li":["The local JWS @operation method.","The remote message service handling and delivery to the service queue.","The remote JWS @operation method."]}}}},"Some embodiments will use platform capabilities to established a Map based API that can be used to pass the necessary information from the run time environment to the reliable messaging. This Map needs to be populated with information that the runtime messaging knows (via annotations) about reliability requirements for each @operation or callback.","In some embodiments, the ServiceControl will pass the following information to the reliable messaging system, the entire outbound SOAP message as an XML Stream and parameters in the SAAJ Format\n\n","In some embodiments, the reliable messaging system will add the appropriate SOAP Headers and en-queue the request locally.","In some embodiments this case, the reliable messaging system can notify the caller that a delivery failure occurred. ebXML Defines an Error Reporting and Handling model that may be used as a framework for communicating failures, including:\n\n","In some embodiments, when the runtime massaging infrastructure HTTP Server receives an inbound message it can forward the incoming stream to the reliable messaging system library if the message is being delivered \u201creliably\u201d. In some cases the runtime messaging infrastructure can either look in the SOAP header or have to look far enough into the body to know which operation is being called, then look up that operation's metadata.",{"@attributes":{"id":"p-0120","num":"0173"},"figref":"FIG. 14","ul":{"@attributes":{"id":"ul0036","list-style":"none"},"li":{"@attributes":{"id":"ul0036-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0037","list-style":"none"},"li":["The URI of the Service, which can be a Map of Properties to set on the JMS Message.","The reliability parameters for the targeted operation","The conversation ID","The JMS Queue Connection information for the target Service (JNDI Connection Factory, JNDI Queue, etc)."]}}}},"In some embodiments, the reliable messaging system needs to return the response message (as an XML Stream) to the runtime messaging infrastructure HTTP Server. Only the reliable messaging system knows what headers are necessary to communicate with the sending reliable messaging system.","In some embodiments, if an error occurs during the invocation of the reliable messaging system library, runtime-messaging infrastructure can return a HTTP  processing error. The reliable messaging system will perform any appropriate retry logic.","If reliable messaging system is provided an XML stream that it can't handle, then it may throw an appropriate exception. The runtime messaging infrastructure may translate that exception to a SOAP fault and return it in the HTTP response. Some embodiments may include Fault Mapping capabilities.","Some embodiments allow attributes to the reliable messaging annotations (i.e. the @wlw:reliable tag) which, depending on the details of the embodiment:\n\n",{"@attributes":{"id":"p-0125","num":"0184"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Attributes to the Annotation Tag in An Embodiment"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["@wlw:reliable",{},{},"In"]},{"entry":["attributes","Type\/Defaults","Description","WSDL"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Retries","integer count","Number of times the client","Y"]},{"entry":[{},"(No default)","should attempt to re-deliver an"]},{"entry":[{},{},"unacknowledged message."]},{"entry":[{},{},"[Mutually exclusive to retry-"]},{"entry":[{},{},"interval and persist duration]"]},{"entry":["Retry-interval","integer seconds","Minimum time the client","Y"]},{"entry":[{},"(No default)","should wait before the client"]},{"entry":[{},{},"attempts to re-deliver an"]},{"entry":[{},{},"unacknowledged message."]},{"entry":["message-time-","integer seconds","Indicates the duration in","Y"]},{"entry":["to-live","(No default)","seconds for which the sever"]},{"entry":[{},{},"will persist reliably delivered"]},{"entry":[{},{},"messages."]},{"entry":[{},{},"Used by the client to"]},{"entry":[{},{},"determine if a message has"]},{"entry":[{},{},"expired."]},{"entry":["in-order","(true","Indicates that the messages","Y"]},{"entry":[{},"[default]|false)","must be delivered in the order"]},{"entry":[{},{},"sent."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"The following sections show test criteria, which may be applied to some embodiments.\n\n","Embodiments can use source code annotations to decrease the time, knowledge, skill, and ultimately cost required to develop message interception and transformation capabilities for Web services. Interceptors can provide the means for developers to apply their own pre and post processing methods to Web service messages. The use of interceptors allows developers to add functionality that doesn't exist in default message processing supplied by transactional platforms, Web servers and other standard software infrastructure. These manipulations can include transformation of message headers and contents, logging, auditing, message redirection, and protocol conversions. Embodiments allow a developer to utilize the enhanced compiler to automatically generate a software component using source code annotations to implement an interceptor, having the required message interception and transformation capability. The interceptor capabilities supported by the invention can be applicable to stateful or stateless services, and both synchronous and asynchronous services. The capabilities of embodiments can include:\n\n","The interceptors created by developers using the invention can have many properties including:\n\n","Some embodiments can make use of the JAX-RPC API, which defines a handler model that has the same basic features useful in creating interceptors. Since the JAX-RPC model is well understood by experienced developers, may make the interceptor API consistent (at a semantic level) with JAX-RPC API where similar features are required.","Some embodiments can use a streaming XML parser and API. For some of these embodiments the API are structured around a pull rather then push model for parsing. These embodiments may use the push model parser to improve the performance, especially for streaming implementations. In some cases the Java XMLInputStream API can be used. In some of these cases the XMLInputStream can be used to construct a DOM if needed.  shows an interceptor API, which may be used in implementing some embodiments of the invention.","Once the complier has created the interceptor it is deployed into the runtime environment. Once in the runtime environment the interceptor becomes operational.","Each interceptor in the runtime environment will follow some particular lifecycle. Some embodiments may pattern the interceptor lifecycle model after the lifecycle model defined for JAX-RPC Handlers. In some cases the JAX-RPC handler API is used directly. This model can give the lifecycle and the environment specific characteristics including:\n\n","Each interceptor in the runtime environment will have a particular state at any point in time. Some possible state management model properties may include:\n\n","As has been mentioned previously, interceptors can be chained in an arbitrary manner. Some embodiments employ the JAX-RPC Handler model to provide a mechanism for chaining handlers together forming a message processing \u201cpipeline\u201d. In some cases the model will follow the JAX-RPC convention, which specifies that the default order of handler invocation is the order in which the handlers are registered. Some embodiments using this type of model can also provides for specialized chaining based on several convenient conventions including:\n\n","Some embodiments may include the runtime environment capabilities to use a specific category to log the initialization, entry, and exit of interceptor chains. Some of these embodiments may provide consistent levels defining summary and detailed logging information. The logs created may be used to audit transactions in the system, behavior of the system or performance of the system.","Some embodiments use a run time environment with the capabilities to supply interceptors with the required data from one or more WSDL directories or other service directories. This information can be used configure the interceptor if required.","Some embodiments may use information in the message payload to bind security credentials to the current request (perhaps using existing APIs) for messages processed by an interceptor.","In some embodiments developers can use the capabilities of the IDE to indicate that they want to include or exclude interceptors as a debug breakpoint. This is particularly useful for interceptors that are provided through a library.","In some embodiments the IDE will include a project model that can be expanded to build and include interceptors as part of building a Web Service. In some embodiments the IDE can treat the interceptors as a library. This may be particularly useful in cases where the interceptors can be added to existing Web services.","One embodiment may be implemented using a conventional general purpose or a specialized digital computer or microprocessor(s) programmed according to the teachings of the present disclosure, as will be apparent to those skilled in the computer art. Appropriate software coding can readily be prepared by skilled programmers based on the teachings of the present disclosure, as will be apparent to those skilled in the software art. The invention may also be implemented by the preparation of integrated circuits or by interconnecting an appropriate network of conventional component circuits, as will be readily apparent to those skilled in the art.","One embodiment includes a computer program product which is a storage medium (media) having instructions stored thereon\/in which can be used to program a computer to perform any of the features presented herein. The storage medium can include, but is not limited to, any type of disk including floppy disks, optical discs, DVD, CD-ROMs, micro drive, and magneto-optical disks, ROMs, RAMs, EPROMs, EEPROMs, DRAMs, VRAMs, flash memory devices, magnetic or optical cards, nanosystems (including molecular memory ICs), or any type of media or device suitable for storing instructions and\/or data.","Stored on any one of the computer readable medium (media), the present invention includes software for controlling both the hardware of the general purpose\/specialized computer or microprocessor, and for enabling the computer or microprocessor to interact with a human user or other mechanism utilizing the results of the present invention. Such software may include, but is not limited to, device drivers, operating systems, execution environments\/containers, and applications.","The foregoing description of the preferred embodiments of the present invention has been provided for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations will be apparent to the practitioner skilled in the art. Particularly, while the concept \u201ccomponent\u201d is used in the embodiments of the systems and methods described above, it will be evident that such concept can be interchangeably used with equivalent concepts such as, service, container, event, control, class, object, bean, and other suitable concepts. Embodiments were chosen and described in order to best describe the principles of the invention and its practical application, thereby enabling others skilled in the art to understand the invention, the various embodiments and with various modifications that are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 3A-C"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":["FIG. 8","FIG. 7"]},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 9","FIG. 7"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
