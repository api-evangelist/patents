---
title: System and method for linguistic collation
abstract: A system and method is provided for handling the collation of linguistic symbols of different languages that may have various types of compressions (e.g., from 2-to-1 to 8-to-1). A symbol table of the symbols identified as Unicode code points is generated, with each symbol tagged with a highest compression type of that symbol by sorting the compression tables of the various languages. During a sorting operation with respect to a given string, the tag of a symbol in the string is checked to identify the highest compression type of compressions beginning with that symbol, and the compression tables for the language with compression types equal or lower than the highest compression type of the symbol are searched using a binary search method to find a matching compression for the symbols in the string. A common search module is used to perform binary searches through compression tables of different compression types.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07941311&OS=07941311&RS=07941311
owner: Microsoft Corporation
number: 07941311
owner_city: Redmond
owner_country: US
publication_date: 20031022
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This invention relates generally to the handling of different written languages in the context of computer data processing, and more particularly to the operation of linguistically collating linguistic elements used in various languages.","One of the greatest challenges in the globalization of computer technologies is to properly handle the numerous written languages used in different parts of the world. The languages may differ greatly in the linguistic symbols they use and in their grammatical structures, and to support most, if not all, languages in various forms of computer data processing can be a daunting task. One critical step taken to facilitate the support of the different languages by computers is to provide a standardized coding system to uniquely identify every symbol in all the languages with a unique number. This coding system, called the Unicode, has been widely adopted by leaders of the computer industry, and is supported in many operating systems, modern browsers, and many other products.","A fundamental operation on textual strings consisting of symbols of a given language is collation, which may be defined as sorting the strings according to an ordering of the symbols that is culturally correct to users of that particular language. Anytime a user orders linguistic data or searches for linguistic data in a logical fashion within the structure of the given language, collation is used. Collation is a rather complex matter and requires an in-depth understanding of the language. For example, in English, a speaker expects a word starting with the letter \u201cQ\u201d to sort after all words beginning with the letter \u201cP\u201d and before all words starting with the letter \u201cR\u201d. As another example, in the Chinese language used in Taiwan, the Chinese block characters are often sorted according to their pronunciations based on the \u201cbopomofo\u201d phonetic system as well as the numbers of strokes in the characters. The proper sorting of the symbols also has to take into account variations on the symbols. Common examples of such variations include the casing (upper or lower) of the symbols and modifiers (diacritics, Indic matras, vowel marks) applied to the symbols.","The operation of collation is further complicated by the existence in many languages of special groupings of linguistic symbols that have to be treated as \u201csort elements\u201d for purpose of linguistically correct sorting. For instance, in Hungarian, \u201cDZS\u201d is a unique combination that is sorted before \u201cE\u201d and after \u201cDZ.\u201d Such a special grouping of symbols as a sorting element is conventionally referred to as \u201ccompressions\u201d (not to be confused with the usage of \u201ccompression\u201d in the context of data size reduction). They are also sometimes referred to as linguistic \u201ccharacters.\u201d Within a given language, there may be several types of compressions (i.e., different numbers of symbols in the compressions). The highest type of compressions varies from language to language, and compressions as high as 8-to-1 are used in Bengali and Tibetan. The existence of compressions makes linguistic sorting more complicated, because for a given input string the sorting program has to determine whether some of the symbols in the string form a compression in order to properly sort the string. In other words, the sorting program has to recognize the language-dependent sort elements in the string. To further complicate the matter, some languages have large numbers of compressions. For instance, Tibetan and Chinese have about 10,000 and 30,000 compressions, respectively, that represent supplemental characters. Since the compressions have to be checked in a sorting operation to identify the sort elements in a textual string, the existence of a large number of compressions can make the sorting operation very time consuming.","The need to properly handle compressions becomes increasingly important as developers of computer software programs try to add support for many new languages that are more complex than those languages already supported. One significant difficulty encountered by the developers is that the existing framework for collation is unable to accommodate the much more complex compressions or the large numbers of compressions used in the new languages. For instance, operating systems traditionally support languages with compression levels no greater than 3-to-1, and the number of compressions in a give language is typically quite small, at most a few tens. The new languages to be supported, however, use compressions with higher compression levels up to 8-to-1, and some of them have tens of thousands of compressions. The existing framework for providing the collation functionality, being developed to handle much lower levels of compressions and much smaller number of compressions, cannot cope with the new compressions presented by the new languages. Moreover, attempts to extend the existing architecture would likely result in un-maintainable code that is complex and difficult to debug. Accordingly, there is a need for a new architecture for providing collation functionality that can effectively support the new languages.","In view of the foregoing, the present invention provides a new architecture for handling the collation of linguistic characters for different languages. In accordance with the invention, one or more compression tables, each corresponding to a compression type, is provided for a given language that has compressions as sorting elements. The system includes a symbol table that contains a list of code points for symbols of the supported languages, and has a sort weight for the symbol identified by each of the code point. The compression tables are sorted in the build process to tag each code point in the symbol table to indicate the highest compression type (e.g., 3-to-1) of compressions beginning with the symbol identified by that code point. During a sorting operation with respect to an input string of symbols in a given language, when the sorting program encounters a first symbol in a combination of symbols in the string, it checks the tag of the code point in the symbol table for that symbol to identify the highest compression type for that symbol, and searches through the compression tables for the particular language in descending order of compression types starting at the highest compression type of the symbol as indicated by the tag. Each of the compression table is searched using a binary search method to significantly enhance the speed of the search, and a common macro module is called to perform the binary search through each of the compression tables.","Turning to the drawings, wherein like reference numerals refer to like elements, the invention is illustrated as being implemented in a suitable computing environment. Although not required, the invention will be described in the general context of computer-executable instructions, such as program modules, being executed by a personal computer. Generally, program modules include routines, programs, objects, components, data structures, etc., that perform particular tasks or implement particular abstract data types. Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multi-processor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers, and the like. The invention may be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","The following description begins with a description of a general-purpose computing device that may implement the system and method for collation of linguistic strings in accordance with the invention. The architecture of an embodiment of the invention, including software modules and data structures, for handling compressions (i.e., special grouping of linguistic symbols that form sort elements) in a sorting operation will be described in greater detail with reference to . Turning now to , a general purpose computing device is shown in the form of a conventional personal computer , including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within the personal computer , such as during start-up, is stored in ROM . The personal computer  further includes a hard disk drive  for reading from and writing to a hard disk , a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM or other optical media.","The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical disk drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of computer readable instructions, data structures, program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk , a removable magnetic disk , and a removable optical disk , it will be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories, and read only memories may also be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk , magnetic disk , optical disk , ROM  or RAM , including an operating system , one or more applications programs , other program modules , and program data . A user may enter commands and information into the personal computer  through input devices such as a keyboard  and a pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or a universal serial bus (USB) or a network interface card. A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, personal computers typically include other peripheral output devices, not shown, such as speakers and printers.","The personal computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the personal computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the personal computer  typically includes a modem  or other means for establishing communications over the WAN . The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","In the description that follows, the invention will be described with reference to acts and symbolic representations of operations that are performed by one or more computers, unless indicated otherwise. As such, it will be understood that such acts and operations, which are at times referred to as being computer-executed, include the manipulation by the processing unit of the computer of electrical signals representing data in a structured form. This manipulation transforms the data or maintains it at locations in the memory system of the computer, which reconfigures or otherwise alters the operation of the computer in a manner well understood by those skilled in the art. The data structures where data is maintained are physical locations of the memory that have particular properties defined by the format of the data. However, while the invention is being described in the foregoing context, it is not meant to be limiting as those of skill in the art will appreciate that various of the acts and operations described hereinafter may also be implemented in hardware.","Referring now to , the present invention is directed to a new architecture  for handling \u201ccompressions\u201d that occur in various languages to facilitate collation (i.e., linguistically correct sorting) operations that sort textual strings in a culturally correct manner. In a preferred embodiment, the collation functionality is provided by an operating system of the computer as one of the many functions supported by the operating system. To that end, the operating system provides two application programming interface (API) functions, CompareString and LCMapString, that can be called by user or kernel mode applications  to carry out sorting operations. The CompareString API function  accepts two character strings as input and compares them to determine which one is sorted before the other, based on the locale information specified as part of the input. The declaration for CompareString is as follows:",{"@attributes":{"id":"p-0022","num":"0021"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int CompareString("]},{"entry":[{},"\u2003LCID Locale,"]},{"entry":[{},"\u2003DWORD dwCmpFlags,"]},{"entry":[{},"\u2003DWORD lpString1,"]},{"entry":[{},"\u2003DWORD cchCount1,"]},{"entry":[{},"\u2003DWORD lpString2,"]},{"entry":[{},"\u2003DWORD cchCount2"]},{"entry":[{},");"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The LCMapString API function  with the LCMAP_SORTKEY flag, on the other hand, accepts a single character string  as the input and returns a sort key  for the input string. The declaration for LCMapString is as follows:",{"@attributes":{"id":"p-0024","num":"0023"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int LCMapString("]},{"entry":[{},"\u2003LCID Locale,\u2003\u2003\/\/ locale identifier"]},{"entry":[{},"\u2003DWORD dwMapFlags, \/\/ mapping transformation type"]},{"entry":[{},"\u2003LPCTSTR lpSrcStr, \/\/ source string"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003int cchSrc,","\/\/ number of characters in source string"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003LPTSTR lpDestStr, \/\/ destination buffer"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003int cchDest","\/\/ size of destination buffer"]},{"entry":[{},");"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"As mentioned above, the collation architecture of the invention facilitates the handling of compressions used in the various languages to be supported by a computer system. The term \u201ccompression\u201d as used herein means a special grouping of linguistic symbols that is to be treated as one unit for linguistic sorting purposes. In other words, a \u201ccompression\u201d is a \u201csort element.\u201d As an example, the combination of \u201cdzs\u201d in Hungarian is a compression or sort element that is expected by a Hungarian speaker to be sorted between the letters \u201cd\u201d and \u201ce.\u201d A compression may consist of two or more symbols, and the \u201ccompression type\u201d (or synonymously \u201ccompression level\u201d) of a given compression means the number of symbols in a given compression. For instance, the compression type of the compression \u201cdzs\u201d is 3-to-1. The number of compressions and the types of compressions vary greatly from language to language. For example, compressions with compression types as high as 8-to-1 are used in Bengali and Tibetan, while some other languages, such as English, do not have compressions.","In a preferred embodiment, the collation architecture is built upon a coding system according to the Unicode standard. In other words, each individual linguistic symbol is identified by a unique number assigned by the Unicode standard. The coding number assigned to a symbol is often referred to as a \u201ccode point.\u201d For example, the code point for Latin Small Letter A (i.e., \u201ca\u201d) is 0x0041. As described above, a compression is a combination of two or more symbols. Each compression is identified by the code points of the symbols that form the compression. For example, the letter \u201c\u00e2\u201d is represented by two code points 0x0041 (Latin Small Letter A) and 0x0302 (Combining Circumflex Accent), and a user would not consider \u201c\u00e2\u201d as two letters. Another way to form a compression is to combine stand-alone symbols. For example, \u201cch\u201d (represented by code points 0x0063 0x0068) in traditional Spanish is treated as a unique sort element to be placed after the letter \u201ch,\u201d and the compression \u201cdzs\u201d (represented by code points 0x0064 0x007a 0x0073) in Hungarian is a sort element between \u201cd\u201d and \u201ce.\u201d","Since the sorting order of symbols is language dependent, the particular language being considered has to be identified for a sorting operation. In a preferred embodiment, each locale that uses a particular version of language is given a locale identifier (LCID) that uniquely identifies the language of that locale. Examples of LCIDs are 0x00000409 for US-English and 0x0000041e for Thai-Thailand.","For purposes of linguistic sorting operations performed by a computer, a core concept is the creation of sort weights. Each sort element (or \u201ccharacter\u201d) in particular language, which may be a symbol or a compression, is given a sort weight. By assigning weights based on the desired ordering of characters, it is possible to easily mask differences (e.g., case or diacritics) that are not important for a particular query, and to quickly do the comparison to identify the order of the characters (e.g., using a database that uses the weights as index values). In one implementation, a sort weight for a symbol or compression is a 32-bit value made up of four 8-bit values. The first 8-bit (or byte) value specifies the \u201cscript member\u201d (SM) of the sort element (e.g., Latin, Cyrillic, Gurmukhi, etc.). The second 8-bit value specifies the \u201calphabetic weight,\u201d which is the primary weight used to distinguish one sort element from another (e.g., \u201cA\u201d vs. \u201cB\u201d). The third 8-bit value is the \u201cdiacritic weight,\u201d which is often used for non-spacing diacritics. This byte is used as a secondary weight difference (e.g., \u201cA\u201d vs. \u201c\u0100\u201d), and can be ignored in a sorting operation via a flag to the APIs. The fourth 8-bit value is the \u201ccase weight,\u201d which is often used for differences in cases. This byte serves as the tertiary weight difference (e.g., \u201cA\u201d vs. \u201ca\u201d), and can be ignored via a flag to the APIs.","As illustrated in , to store the weight information for the various sort elements, multiple tables are used. These data structures are maintained by linguists who work to make sure that the data are linguistically appropriate for all languages supported by the computer software. In the illustrated embodiment, the architecture  has a default symbol table  for storing the default sort weights for all linguistic symbols included in the Unicode standard (with code points from 0x0000 to 0xFFFF), which each entry representing one single symbol (i.e., not a compression) and containing a 32-bit value that specifies the default sort weights for that symbol. By way of example, an excerpt of data from the default table  is shown in . As described above, the sort weight for each symbol in the table is dividing into four 8-bit values (SM, AW, DW, and CW), which are shown in  as separate columns. From this small sample, it can be seen how one could deterministically sort the full list of code points based on their sort weights, and how one could use the code to treat the composite (combined) form of a letter (e.g., A+Diaeresis) with the precomposed form (A Diaresis), as the DW value of the latter is a simple combination of the combined DW values of the former. It is also easy to see how uppercase letters sort after the corresponding lowercase letters, and how different scripts (e.g., Latin vs. Greek) have different SM values.","Returning to , for some locales, the sort weights in the default table for a given symbol may be incorrect. For instance, in Lithuanian, the letter \u201cy\u201d is supposed to be sorted as a unique character after the letter \u201ci\u201d, while in English \u201cy\u201d is sorted after \u201ci\u201d, and the default sort weights for these two letters reflect the latter sorting order. To keep track of the deviations from the default sorting orders given in the default symbol table, a plurality of exception tables  are provided. Each exception table is for a particular language and lists the changes that need to be made to the default table for symbols used in that language. Each entry in the exception table includes the code point for a symbol and its sort weights for that particular language. As an example,  shows a sample excerpt of data in an exception table  for Danish. In the table, the LCID of 0x00000406 uniquely identifies the language that requires the exceptions as Danish, and the data columns are in the same format as those in the default table shown in .","Again referring to , as described above, many languages use compressions that are to be treated as sort elements. Each compression is formed of multiple symbols, and the \u201ctype\u201d of a compression is the number of symbols in that compression. In a preferred embodiment, there is one compression table for each type of compressions used in each language that has compressions. For example,  shows sample compression tables for the Hungarian language. Hungarian uses 2-to-1 and 3-to-1 compressions. Accordingly, there is a 2-to-1 compression table  and a 3-to-1 compression table . The LCID (0x0000040e) identifies that the compression tables are for the Hungarian language, and there are 24 entries in the 2-to-1 table  and 3 entries in the 3-to-1 table . As shown in the tables, the Hungarian language includes the compression \u201cdzs\u201d as well as the compression \u201cdz.\u201d This example highlights the reason that during a sorting operation the larger compressions have to be checked against the string to be sorted before the smaller ones. For instance, if the string \u201ckodzsy\u201d is to be sorted (either against another string or for producing a sort key), the sort program has to recognize that the \u201cdzs\u201d combination in the string, rather than \u201cdz\u201d, is to be treated as a sort element, and this is achieved by searching the 3-to-1 compression table first to finding a match therein. In languages currently supported by a preferred embodiment, compression types up to 8-to-1 are used (e.g., in Bengali and Tibetan). Thus, the compression tables for a language with 8-to-1 compressions may include tables for compression types of 2-to-1, 3-to-1, and so on, all way up to 8-to-1.","As described above, compressions of various types are found in different languages. As the number of new languages supported by computer programs increases, both the compression types and the number of new compressions have increased tremendously, and the existing framework for collation prior to the present invention was not capable of handling those new compressions. For instance, the prior framework dealt with compressions of types only up to 3-to-1. The newly supported languages, however, have compression types as high as 8-to-1, and the prior framework was unable to cope with the increased number of compression types. Specifically, the prior framework used the top three bits in the CW portion of the sort weight of a symbol in the default table as three flags to indicate whether that symbol is not used in any compression or is used in 2-to-1, 3-to-1, or both 2-to-1 and 3-1 compressions. With the new compressions, using such flags to identify whether a symbol is or is not in all the types of compressions up to 8-to-1 would use up too many bits of the CW value. Another problem with the compression tagging mechanism in the prior framework is that the tagging in the default table was done by the linguist by manually setting each of the flag bits for a given symbol, and that process had been a major source of errors in the past.","The present invention provides a new architecture for collation of character strings that effectively addresses the need to handle the much higher compression types and significantly larger numbers of compressions in languages not supported in the prior framework for collation. In accordance with a feature of the invention, a new way of tagging the symbols in the default table is used to support the increased compression types. Instead of attempting to indicate all types of compressions that begin with that symbol, the compression tag indicates only the highest compression type with that symbol. In one implementation, the top three bits of the CW value of the symbol are still used for tagging, but in contrast to the old tagging system, the three bits now form a number instead of three separate flag bits, and the number indicates the highest compression type for the symbol. For example, a tag value of 7 indicates that there is at least one 8-to-1 compression that begins with that symbol, and there may or many not be compressions of a lower type that begin with the symbol.","Moreover, in accordance with the invention, the task of tagging the symbols is performed automatically in the build process. During the build process, the compression tables  for all the supported languages are sorted to identify for each symbol the highest type of compressions that begin with that symbol, and the sort weights for the code point in the default table is tagged to indicate that highest type of compression. The compression masks used in one embodiment in this tagging operation are defined as follows:",{"@attributes":{"id":"p-0035","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Bit values 5\/6\/7 of CW displayed on the right"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/\u2002\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Bit 7 6 5"]},{"entry":[{},"#define COMPRESS_8_MASK 0xe0 \/\/ 1 1 1"]},{"entry":[{},"#define COMPRESS_7_MASK 0xc0 \/\/ 1 1 0"]},{"entry":[{},"#define COMPRESS_6_MASK 0xa0 \/\/ 1 0 1"]},{"entry":[{},"#define COMPRESS_5_MASK 0x80 \/\/ 1 0 0"]},{"entry":[{},"#define COMPRESS_4_MASK 0x60 \/\/ 0 1 1"]},{"entry":[{},"#define COMPRESS_3_MASK 0x40 \/\/ 0 1 0"]},{"entry":[{},"#define COMPRESS_2_MASK 0x20 \/\/ 0 0 1"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"110"},"As another aspect of the invention, the time spent on searching the compression tables  during a sort operation to find a match is significantly reduced by using a binary search method. In the prior collation framework, the search was carried out by sequentially enumerating the entries of the compression table. Such a sequential search is very time-consuming and can be unacceptably slow when there are many compressions in a compression table. For instance, there are about 10,000 and 30,000 supplemental characters in Tibetan and Chinese, respectively, and a sequential enumeration through such large lists of compressions may require tens of thousands of comparisons to find a match, and the large amount time required to go through the compressions would significantly affect the performance of the collation program.","In accordance with the invention, fast searching of a compression table is achieved by employing a binary search algorithm. With the binary search, even a large list can be searched through by doing a small number of comparisons. Taking Chinese as an example, only 15 comparisons (2^15=32,768) have to be carried out to see if a matching compression exists in the about 30,000 supplemental characters, while the conventional collation algorithm would have to enumerate those supplemental characters one by one until a match is found. To facilitate the binary search operation, the entries in each compression table are sorted during the build process according to the combined Unicode values of the compressions, and the binary search method is based on the combined Unicode values. By way of example, in the compression tables for Hungarian as shown in , the compression \u201cly\u201d is represented by the code point combination of \u201c0x006c 0x0079\u201d, while the compression \u201cny\u201d is represented by the code point combination of \u201c0x006e 0x0079\u201d. As a result, \u201cny\u201d is listed in the 2-to-1 compression table after \u201ccy\u201d. During the search operation, when a compression table is to be searched, the highest and lowest code points of the entries in the table are retrieved, and the binary search technique is applied to quickly determine whether a match with a combination of symbols in the input string is found in the compressions in the table.","In accordance with another aspect of the invention, the code of the software program for handling the various compression levels in a sorting operation is significantly simplified by utilizing a sorting module that is called to compare all of the different types of compressions without requiring multiple code paths. In the prior collation framework, a sorting operation involved a complex set of steps to walk through the string to be sorted and detect the compressions in an atomic or discrete manner, and there were thousands of lines in source code for handling the compressions. Such an ad hoc approach to handling different types of compressions is not only prone to errors but also unsuitable for handling the much higher levels of compressions in many newly supported languages. As described in greater detail below, the use of a common sorting module for all the different compression types significantly simplifies the code for collation operations and makes the code easily expandable for handling even higher compression levels.","In one implementation, the sorting module is in the form of a macro module. To illustrate the degree of simplification of the software code achieved, the source code of the macro  () for the LCMapString API is provided below. This macro  is called fore each type of compressions. The macro for the CompareString API is similar. As can be seen in the source code, the macro also checks the existence of double compressions.",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"},{"entry":"\/\/ SORTKEY_COMPRESSION_HANDLER"},{"entry":"\/\/"},{"entry":"\/\/ Handles all of the compression types from 8to1 down to 2to1, including"},{"entry":"\/\/ double compressions. Defined as a macro so that it can be used generically"},{"entry":"\/\/ with all of the different compression types."},{"entry":"\/\/"},{"entry":"\/\/ DEFINED AS A MACRO."},{"entry":"\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/"},{"entry":"#define SORTKEY_COMPRESSION_HANDLER("}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type,","\/* Type of compression","*\/","\\"]},{"entry":[{},"pComp,","\/* ptr to compression list","*\/","\\"]},{"entry":[{},"Candidates,","\/* Count of possible comp. chars","*\/","\\"]},{"entry":[{},"pWeight,","\/* ptr to weight of character","*\/","\\"]},{"entry":[{},"CaseMask,","\/* mask for case weight","*\/","\\"]},{"entry":[{},"pPosUW,","\/* ptr to position in pUW buffer","*\/","\\"]},{"entry":[{},"pPosDW,","\/* ptr to position in pDW buffer","*\/","\\"]},{"entry":[{},"pPosCW,","\/* ptr to position in pCW buffer","*\/","\\"]},{"entry":[{},"cchSrc,","\/* # of characters in source string","*\/","\\"]},{"entry":[{},"PosCtr,","\/* position counter in string","*\/","\\"]},{"entry":[{},"pPos,","\/* ptr to position in string","*\/","\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IfDblCompress, \/*","*\/","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"left,","\/*","*\/","\\"]},{"entry":[{},"right,","\/*","*\/","\\"]},{"entry":[{},"median,","\/*","*\/","\\"]},{"entry":[{},"iComp)","\/*","*\/","\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["{","\\"]},{"entry":["\u2003if (((pHashN->pCompHdr->Num[(Type \u2212 2)]) > 0) &&","\\"]},{"entry":["\u2003\u2003((PosCtr + (Type \u2212 1)) <= cchSrc))","\\"]},{"entry":["\u2003{","\\"]},{"entry":["\u2003\u2003if(0 == Candidates)","\\"]},{"entry":["\u2003\u2003{","\\"]},{"entry":["\u2003\u2003\u2003Candidates = NlsCountOfWCharsWithinRange(pPos,","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003Type,","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003pHashN->pCompHdr->MinUCP,","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003pHashN->pCompHdr->MaxUCP);","\\"]},{"entry":["\u2003\u2003}","\\"]},{"entry":[{},"\\"]},{"entry":["\u2003\u2003if(Candidates >= Type)","\\"]},{"entry":["\u2003\u2003{","\\"]},{"entry":["\u2003\u2003\u2003IfDblCompress = FALSE;","\\"]},{"entry":["\u2003\u2003\u2003left = 0;","\\"]},{"entry":["\u2003\u2003\u2003right = (pHashN->pCompHdr->Num[(Type \u2212 2)]) \u2212 1;","\\"]},{"entry":[{},"\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\/* If it is a double compression locale, check for the possibility of","*\/","\\"]},{"entry":["\u2003\u2003\u2003\/* double compressions now.","*\/","\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003if((pHashN->IfDblCompression) &&","\\"]},{"entry":["\u2003\u2003\u2003\u2003((PosCtr + (Type)) <= cchSrc) &&","\\"]},{"entry":["\u2003\u2003\u2003\u2003((GET_DWORD_WEIGHT(pHashN, *pPos) & CMP_MASKOFF_CW) ==","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003(GET_DWORD_WEIGHT(pHashN, *(pPos + 1)) & CMP_MASKOFF_CW)))","\\"]},{"entry":["\u2003\u2003\u2003{","\\"]},{"entry":["\u2003\u2003\u2003\u2003IfDblCompress = TRUE;","\\"]},{"entry":["\u2003\u2003\u2003}","\\"]},{"entry":[{},"\\"]},{"entry":["\u2003\u2003\u2003while (left <= right)","\\"]},{"entry":["\u2003\u2003\u2003{","\\"]},{"entry":["\u2003\u2003\u2003\u2003median = (left + right) \/ 2;","\\"]},{"entry":[{},"\\"]},{"entry":["\u2003\u2003\u2003\u2003if(IfDblCompress)","\\"]},{"entry":["\u2003\u2003\u2003\u2003{","\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"238pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\u2003\u2003\/*","*\/","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\/* EXPLANATION OF HOW DOUBLE COMPRESSIONS WORK","*\/","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\/*","*\/","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\/* A double-compression means that if \u2018dsz\u2019 is a compression then","*\/","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\/* \u2018ddsz\u2019 is equivalent to \u2018dszdsz\u2019. The IfDblCompress check above","*\/","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\/* has indicated that the weights of pPos[0] and pPos[1] are","*\/","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\/* equal, so now if pPos[1] to pPos[Type + 1] is a compression","*\/","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\/* then we will have found a double compression.","*\/","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\/*","*\/","\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\u2003\u2003iComp = NlsCompareRgWChar(((pPos + 1)), &(pComp[median].CP1), Type);","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003if(0 == iComp)","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003{","\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"224pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/* Found it! Lets store the weights.","*\/","\\"]},{"entry":[{},{},"\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/* Note that for the sake of this double compression we will","*\/","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/* store the weight twice.","*\/","\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003pWeight = &(pComp[median].Weights);","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003*(pPosUW + 1) = *pPosUW = GET_UNICODE(pWeight);","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003*(pPosDW + 1) = *pPosDW = GET_DIACRITIC(pWeight);","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003*(pPosCW + 1) = *pPosCW = GET_CASE_FULL_COMP_MASK(pWeight) &","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CaseMask;","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003pPosUW += 2;","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003pPosDW += 2;","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003pPosCW += 2;","\\"]},{"entry":[{},"\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"238pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/* Add one less than the compression type to source, plus one","*\/","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/* since one will be added by \u201cfor\u201d structure and the double","*\/","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/* compression added one to the number of chars we looked at.","*\/","\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003pPos += (Type);","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003PosCtr += (Type);","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003}","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003}","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003else","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003{","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003iComp = NlsCompareRgWChar(pPos, &(pComp[median].CP1), Type);","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003if(0 == iComp)","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003{","\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/* Found it! Lets store the weights and increment.","*\/","\\"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003pWeight = &(pComp[median].Weights);","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003*pPosUW = GET_UNICODE(pWeight);","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003*pPosDW = GET_DIACRITIC(pWeight);","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003*pPosCW = GET_CASE_FULL_COMP_MASK(pWeight) & CaseMask;","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003pPosUW++;","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003pPosDW++;","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003pPosCW++;","\\"]},{"entry":[{},"\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/* Add one less than the compression type to source,","*\/","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/* since one will be added by \u201cfor\u201d structure.","*\/","\\"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"294pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"7pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003pPos += (Type \u2212 1);","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003PosCtr += (Type \u2212 1);","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003\u2003\u2003break;","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003}","\\"]},{"entry":["\u2003\u2003\u2003\u2003}","\\"]},{"entry":[{},"\\"]},{"entry":["\u2003\u2003\u2003if (iComp < 0)","\\"]},{"entry":["\u2003\u2003\u2003\u2003{","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003right = median \u2212 1;","\\"]},{"entry":["\u2003\u2003\u2003\u2003}","\\"]},{"entry":["\u2003\u2003\u2003\u2003else","\\"]},{"entry":["\u2003\u2003\u2003\u2003{","\\"]},{"entry":["\u2003\u2003\u2003\u2003\u2003left = median + 1;","\\"]},{"entry":["\u2003\u2003\u2003\u2003}","\\"]},{"entry":["\u2003\u2003\u2003}","\\"]},{"entry":[{},"\\"]},{"entry":["\u2003\u2003\u2003if (0 == iComp)","\\"]},{"entry":["\u2003\u2003\u2003{","\\"]},{"entry":["\u2003\u2003\u2003\u2003break;","\\"]},{"entry":["\u2003\u2003\u2003}","\\"]},{"entry":["\u2003\u2003}","\\"]},{"entry":["\u2003}","\\"]},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"This simple macro has replaced thousands of lines in the source code for the prior collation framework for searching through compression tables. With the macro described above, a simple switch module such as the one provided below can be used to perform a search through all the compression tables.",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"switch (GET_COMPRESSION(pWeight))"},{"entry":"{"},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ Jump to the appropriate compression type to"},{"entry":"\u2003\u2003\/\/ check. When a compression is found, the macro"},{"entry":"\u2003\u2003\/\/ will break out of the switch block; otherwise,"},{"entry":"\u2003\u2003\/\/ fall through and check the next compression."},{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003case (COMPRESS_8_MASK):"},{"entry":"\u2003\u2003\u2003SORTKEY_COMPRESSION_HANDLER(8, pHashN->pCompress8,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CompressionCandidateChars, pWeight,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CaseMask, pPosUW, pPosDW, pPosCW,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003cchSrc, PosCtr, pPos, IfDblCompress, left,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003right, median, iComp);"},{"entry":"\u2003\u2003case (COMPRESS_7_MASK):"},{"entry":"\u2003\u2003\u2003SORTKEY_COMPRESSION_HANDLER(7, pHashN->pCompress7,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CompressionCandidateChars, pWeight,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003CaseMask, pPosUW, pPosDW, pPosCW,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003cchSrc, PosCtr, pPos, IfDblCompress, left,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003right, median, iComp);"},{"entry":"\u2003\u2003. . ."},{"entry":"\u2003\u2003. . ."},{"entry":"\u2003\u2003. . ."},{"entry":"\u2003\u2003default:"},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\/\/ No possible compression for character, so store"},{"entry":"\u2003\u2003\u2003\/\/ the various weights for the character."},{"entry":"\u2003\u2003\u2003\/\/"},{"entry":"\u2003\u2003\u2003\u2003*pPosUW = GET_UNICODE_SM(pWeight, SM);"},{"entry":"\u2003\u2003\u2003\u2003*pPosDW = GET_DIACRITIC(pWeight);"},{"entry":"\u2003\u2003\u2003\u2003*pPosCW = GET_CASE_FULL_COMP_MASK(pWeight) & CaseMask;"},{"entry":"\u2003\u2003\u2003\u2003pPosUW++;"},{"entry":"\u2003\u2003\u2003\u2003pPosDW++;"},{"entry":"\u2003\u2003\u2003\u2003pPosCW++;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 6","b":["200","202","204","210","204","206","206","208","210","210","216","202","216","220"]},"In view of the many possible embodiments to which the principles of this invention may be applied, it should be recognized that the embodiments described herein with respect to the drawing figures are meant to be illustrative only and should not be taken as limiting the scope of the invention. Therefore, the invention as described herein contemplates all such embodiments as may come within the scope of the following claims and equivalents thereof."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 4","FIG. 2"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":["FIG. 6","FIG. 2"]}]},"DETDESC":[{},{}]}
