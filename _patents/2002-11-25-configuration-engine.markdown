---
title: Configuration engine
abstract: In a distributed computing, object oriented, component based framework, some components may be capable of running some tasks, incapable of running others and capable of running still others, but obtaining only sub-optimal results. Components may already be assigned tasks, and have insufficient capacity remaining to execute additional tasks. A configuration manager seeks to rectify this. The configuration manager gathers information stored in a configuration template associated with each of the components, interrogates the components about their current status and compares the results to a dynamic plan developed by a tasking engine. The configuration engine then assigns tasks to processor managers based on the results obtained by the configuration manager.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07765521&OS=07765521&RS=07765521
owner: 
number: 07765521
owner_city: 
owner_country: 
publication_date: 20021125
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","COPYRIGHT NOTICE","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT","EXAMPLE OF WINDOWS NT WORKSTATION BASE CONFIGURATION"],"p":["This application claims the benefit of U.S. Provisional Applications No. 60\/407,555, filed Aug. 29, 2002, and No. 60\/406,853, filed Aug. 29, 2002. In addition, this application is a continuation-in-part of U.S. application Ser. No. 10\/290,939, filed Nov. 8, 2002, now abandoned. Each of these applications is herein incorporated in its entirety by reference.","A portion of the disclosure of this patent document contains material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent file or records, but otherwise reserves all copyright rights whatsoever.","1. Technical Field of the Invention","The present invention relates to software architecture. More particularly to software architecture incorporating configuration engines for the management of multiple processing nodes.","2. Background","The rapid evolution of technology has posed significant problems, as well as benefits. Some technologies never achieve their full potential while others evolve rapidly, leaving earlier versions obsolete shortly after they have been installed. Technologies may need to be frequently substituted or otherwise adapted to compensate for different needs. Software particularly must be made amenable to substitution and adaptation and can be a means of allowing integration of new hardware or allowing existing hardware to fulfill new functions.","Large-scale software development has evolved rapidly from its inception. Through the 1980s large-scale software was developed in modular systems of subsystems. Even today these are the most common systems in use. These systems are largely hardware dependent, problems or errors could be detected down to the level of the subsystem. These systems were based on point solutions where the problem\/solution is functionally decomposed into subsystems. Potential reuse of the software for other applications must be anticipated during development and integrated into the software design. Extensions of the software are difficult and can only be achieved when such extensions were anticipated and designed into the system architecture itself.","In the 1990s, some improvement came with the advent of Object Oriented Systems (OOS). Object Oriented Systems were still deficient in a number of respects. OOS are still hardware dependent, they are designed for specific hardware configurations and modules are not productized. Off the shelf components could not be easily integrated in to a software system since each piece of software was developed for a particular hardware platform using different languages. No standard interface was available. These systems were based, like their predecessors, on point solutions. The point solutions for OOS are derived using Object Oriented Analysis. Extension of the system using existing components was difficult as a result of the multiplicity of languages used.","In recent years, research and development has centered on layered or component based systems. In such a system a thin common layer or component base class is used in the development of all software modules. Each of the major capabilities of the system is represented by at least one module or component. These modules or components are thus \u201cwrapped\u201d in the thin common layer. Independent components are developed, tested, and packaged independently of each other, and while operating have no knowledge of their environment, since all input\/output is constrained to interface ports connected from the outside. Run time discoverable parameter ports control specific behavior.","Component technology has in recent years become an area of increasing interest given the above challenges. Component technologies such as, CORBA, Common Object Request Broker Architecture (developed in 1997), allow for increased flexibility when implementing business processes. By combining components many different software products can be created from existing modules. This increases the speed and efficiency of software development thereby better meeting client and internal demands and decreasing costs associated with development.","The goal now is to make software components that allow reuse by performing a particular function and providing an appropriate interface with a larger system. Each component should be autonomous regarding its particular functionality. This autonomy would allow changes to be made with individual components without disturbing the configuration of the entire system. Relating the various quasi-autonomous components to each other results in a high degree of complexity in communication and synchronization code.","A system of reusable and flexible components would be especially useful for developers of large and complex software packages, such as military contractors. In the past, software was designed specifically for a contract. When a new contract was bid for, the contractor started from scratch. As discussed above, differences in language and architecture prevented different functionalities from being reused from earlier contracts. Since the software was newly developed there remained a relatively high risk of failure in the software or its interfaces, therefore the new software required testing and packaging, adding to the cost of the contract. The application of a flexible framework of reusable and interchangeable components would enable a client to leverage earlier development investments and minimize risk of failure in the development process. Contractors would be able to provide clients with more accurate and lower bids and possibly prototypes or catalogues of products easily configured to the clients needs.","A similar, though different, architecture is SCA-Software communication architecture. This architecture is used in such applications as SDR (Software Defined Radio). SCA has specific interface description language (IDL) interfaces defined for software radios. Any new desired capabilities must fit in to pre defined IDL. SCA provides an interface framework; as such, it is not hardware independent. While peer-upper layer interfaces are well defined in SCA, lower layer interfaces are largely ignored. Another disadvantage of SCA for more general application is its total reliance on CORBA layered communications. Such problems present themselves in CPU overhead and quality of service. Messages can be delivered out of order and processed by different threads when belonging to the same data streams. Thus the SCA architecture is unsuitable for the distributed computing application.","Rocray et al. in a published US Application Pub. No. US 2002\/0065958 A1 disclose a multiprocessor system that comprises a plurality of processor modules, including a software management processor, a non-volatile storage memory configuration (NVS), and a plurality of software components stored on the NVS configured for use in the processor modules. The application further discloses a software generic control information file used by the software management processor to relate the compatibility of software and to determine which of the software components to distribute to a processor module that requires software stored on the NVS.","In published PCT application, WO 02\/057886 A2, Talk2 Technologies discloses methods, systems, and computer program products for dynamically accessing software components in an environment that may include a plurality of processing nodes. In the '886 reference, each node includes one or more software objects, such as one or more software component objects (virtual processors), a controller object, a database object, a trace object, an agent object, etc. Requests for the functionality implemented by a particular software component are load balanced across the available instances. If no software components are available, a request may be submitted to a scheduler. A software component also may be reserved for future processing. Relationships between software components are defined by platform independent logic that is accessible through a database object and processed by a controller object. An agent object tracks which software components are available at the one or more nodes for which the agent is responsible.","In order for such a component system to properly function a central infrastructure must provide a forum for this communication and synchronization for components and control the allocation of the tasks to the various components based on the capabilities and availabilities of those components, thereby preventing conflicts and redundancies.","Clearly what is needed to create a flexible framework of reusable and interchangeable components, developed and working independently, coordinated by controls that can be manipulated without substantial reengineering or programming in runtime.","The invention is devised in the light of the problems of the prior art described herein. Accordingly it is a general object of the present invention to provide a novel and useful technique that can solve the problems described herein.","One embodiment of the present invention provides a system for management of a distributed computing system including a tasking manager, whereby a plan is formulated describing a task to be carried out by the distributed computing system and detailing resources required for execution of the task a framework manager, communicating with the tasking manager and comprising at least one configuration manager, including a library within which are disposed at least one configuration template a means for ascertaining the current configuration of the distributed computing system a component assignment unit communicating with said tasking manager, the library, and the means for ascertaining the current configuration; and an output whereby the configuration manager directs the allocation of tasks to available system resources.","In such a system for management of a distributed computing system the configuration template may detail a tested configuration compliant with the distributed computing system and the component assignment unit may be configured to: compare said required resources with said each configuration template in said library to select usable configuration templates; compare said usable configuration templates with said means for ascertaining the current configuration; determine if system resources required by said usable templates are available; and select, based on comparisons of said usable templates with said current configuration, an optimal resource allocation for execution of said task.","According to one embodiment, system resources may include software processing units and hardware components. Such system resources may be adapted to RE (Radio Frequency) applications such as tuners, channelizers, transmission security components, delay\/multi-band radios, modems, communication security components, and decoders.","A further embodiment of the present invention provides a configuration manager for the assignment of task elements to processing units in a component based distributed system, including a library wherein are disposed at least one configuration template; a means for ascertaining currently available system resources of the distributed computing system; a component assignment unit communicating with a tasking manager, the library, and the means for ascertaining currently available system resources; and means for communicating assignments of the task elements to the processing units.","In this embodiment, the component assignment unit may be configured to: compare said required resources with said each configuration template in said library to select usable configuration templates; compare the usable configuration templates with the means for ascertaining the current configuration; determine if system resources required by the usable templates are available; and select, based on comparisons of the usable templates with the current configuration, an optimal resource allocation for execution of the task.","According to one embodiment, system resources may include software processing units or hardware components. Such system resources may be adapted to RF applications, such as tuners, channelizers, transmission security components, delay\/multi-band radios, modems, communication security components, and decoders.","Another embodiment of the present invention provides a method for the configuration of components in a component based distributed system including the steps of: obtaining a plan schematic; obtaining at least one configuration template from a configuration template library; matching the configuration template with system requirements defined by the plan schematic; generating a preliminary result from the step of comparing the system requirements with the configuration template; obtaining a current configuration of components in the component based distributed system describing currently available system resources; matching the current configuration with the preliminary result; generating a final result of the step of matching the current configuration and the preliminary result; and communicating the result to distributed processing centers.","According to one embodiment, configuration templates include tested configurations for the component based distributed system. The preliminary result may include a plurality of useable templates while the final result is an optimal configuration for the components given said current configuration of the system.","According to one embodiment of the present invention, the method is executed within a framework manager. A tasking engine may formulate the plan.","According to one embodiment of the invention, matching the current configuration with the preliminary result is undertaken so as to obtain a template with an optimal correlation between the requirements of the template and resources available to the system.","According to one embodiment of the present invention, components may include software processing units or hardware components. Such components may be adapted to RF applications","Still other objects and advantages of the present invention will become readily apparent to those skilled in this art from the following detailed description, wherein we have shown and described only a preferred embodiment of the invention, simply by way of illustration of the best mode contemplated by us on carrying out our invention. As will be realized, the invention is capable of other and different embodiments, and its several details are capable of modifications in various obvious respects, all without departing from the invention.","The deployment of components to solve a processing problem may be performed in two steps. The first describes what the elements are and the logical connection between them. The second step involves placing the components on processing elements such that the performance of all the components is guaranteed. This two-step technique allocates components to processing elements using a set of known working configurations that are described in a database. The algorithm queries each processing element for the template database and a set of rules that optimize the processor utilization and minimize the disruption to existing components.","One embodiment of the present invention is a component manager or engine integrated into a SIMPLE, script based, task engine. A user can input a plan of what components are necessary for a particular procedure via an application programming interface (API). Parameters for this can be set and controlled without changes being made to code. Such a script-based system requires little effort from the user to coordinate even complex tasks.","Referring to , this figure illustrates the operation of a configuration manager operating according to one embodiment of the present invention. The configuration manager or engine uses configuration templates to describe the possible combinations of processors capable of performing a particular function. These templates are stored in a database and are recalled by the configuration engine. The configuration engine maintains a current configuration of the system. The current configuration consists of a list of: the processors, of components running on each processor, current memory and CPU utilization of the processor, current interconnects between processors, and current loading of the processor.","This configuration is compiled dynamically at run time just before a new configuration is made. The configuration manager or engine is then able to compare the configuration template, the current configuration, and requirements of the task or schematic, inputted by the user and comprising: the list of components, the connections between each of the components and the component parameter values and other configuration information.","The configuration manager or engine then assigns the task to the processor best suited to its requirements and without conflicts and maintains a database of what components are loaded on which processors and monitors the processor loading (Memory, CPU and Input\/Output bandwidth utilizations).","The configuration manager when assigning tasks to processors applies a component assignment algorithm designed to efficiently deploy components on as few processors as possible. Secondarily, the algorithm seeks to avoid disruption to currently executing plans or tasks. The algorithm avoids loading components until the optimal allocation is obtained. If the loading process fails, no assignments are actually made.","One embodiment of the present invention is best understood in the context of a Signal Intelligence\/Information Warfare (SIGINT\/IW) System, a component is an object-oriented set of reusable and new software, and if required compatible hardware, that performs a specific system task.","The present invention allows for the development and integration of custom object-oriented components that satisfy the assigned task(s) and are scaleable, modular, extensible, platform independent, open, robust, and efficient.","The general approach in this software development is to use object-oriented technology to model and build software, using the Unified Modeling Language (UML). This development technology utilizes the UML semantics and graphical notation to express the software design.","In one embodiment, the Rational Rose application is the primary UML tool used to specify, visualize, construct and document the elements and artifacts of a component consistent with the preferred embodiment of the present invention. Rational Rose is used to implement UML to create a blueprint or model for object-oriented system and software application construction.","An embodiment follows a set of standards to generate the object oriented design and software for the framework and components.","Once the component software model is reviewed, updated and stabilized the detailed lower level classes and internal sequences are coded to complete the component Visual C++ source code. The component source code is then compiled and tested.","Through the use of Object oriented technology, the component developer creates the application by extending the component base classes. Most methods of these classes have desired default behaviors, and need not be extended for simple applications. Component development can proceed in an iterative approach, with each iteration extending more and more of the classes and overwriting more and more of the base class methods, increasing the component maturity until the ultimate desired behavior and performance is attained.","A component, according to the present invention, interfaces and exists with a framework having been optimized for throughput, and will continue to have advances in performance with successive releases. The small penalty in run-time performance is greatly offset by the reduction in non-recurring engineering.","Architecture Overview","One embodiment of the present invention is an Information Dominance Systems product family for new SIGINT\/IW Systems. The embodiment has a component-framework architecture that consists of a framework of expandable sets of reusable software components with compatible commercial, off the shelf (COTS) hardware. A framework makes components work together, provides a common run-time infrastructure for components, and provides a common set of base classes for component developers. One embodiment is an object-oriented system and software development approach for an evolving scaleable family of products. One embodiment is Operating System and platform independent in that the architecture is designed to run on PC WindowsNT, Sun Solaris, and embedded platforms such as VxWorks and MC\/OS.","The preferred system provides a Product Store service, a repository for SIGINT products, accessible as either objects or as database entries. The system developer may extend the Product Store as required.","The component-framework architecture of the preferred embodiment provides common standard interfaces to the components. This facilitates testing at the component level. An embodiment of the present invention provides programmable component test capability. This capability consists of TestSource, a programmable signal and event source component, TestSink, a controllable signal and event logging and display component, and the MAUI (Maintenance And User Interface), which provides a graphical user interface into the component interfaces of individual components, processors, plans, and systems.","The architecture of the preferred embodiment of the present invention is component framework architecture. Components \u201cDo the work\u201d of the application. A component encapsulates the signal and data processing inside common (extensible) interface. Frameworks make components work together. The framework provides a common upgradeable run-time infrastructure for components and provides a common set of base classes for component developers.","Framework Manager","Based on the mission, priority, and component requirements a dynamic plan is constructed, by a tasking engine, to accomplish the individual component task(s). The tasking engine issues instructions to a framework manager. The framework manager manages the deployment of components to remote processors through a processor manager. The framework manager contains, in the preferred embodiment, a configuration manger. Some components may be capable of running some tasks, incapable of running others and capable of running still others yet with sub-optimal results. Components may already be assigned tasks, and have insufficient capacity remaining to execute additional tasks. The configuration manager seeks to rectify this. The configuration engine gathers information stored in a configuration template associated with each of the components, interrogates the processors about their current status and compares the results to the dynamic plan developed by a tasking engine. The configuration engine then assigns tasks to processor managers based on the results obtained. Thus an optimum allocation of resources is achieved even before a task is assigned to a processor or component. The framework manager then no longer is in direct control of the task, leaving the management thereof to the processor manager.","Processor Manager","The processor manager is application independent. A processor manager is associated with one or more specific components. It takes commands from the framework manager and manages the operation of components local to the processor.","Component(s)","Each component manages its local transforms and its associated I\/Os. Component interaction is fully decoupled from other components. Any component interaction is managed by the Framework Manager and an associated Processor Manager. Some components such as Channelize, Detect, Copy, and Recognize are application independent.","Framework","The framework manages the deployment of components to processors in the system. The framework handles the management of interconnection of components. The deployment and interconnection of components may be done individually, or through the submission of a plan, containing this information.","Task applications provide translation of system operator or user required services to plans, component deployments, and component parameter settings. This includes copy (providing a software radio), search (a SIGINT signal acquisition and recognition system), and others. These task applications are extensible by system developers.","Components","Components are essentially small subsystems, with common interface characteristics and expected (control) behavior. By using Object-Oriented technology, these common interfaces and behaviors can be provided to the developer and enforced through inheritance. The component encapsulates the signal and data processing inside a common interface. The framework provides deployment, communications, and health monitoring services to the components.","The interfaces and expected (control) behaviors of components constant with the present invention are provided for the developer. The developer can focus his\/her effort on the signal and data processing requirements of the component, and benefit by reusing the deployment, communications, and engineering services of the component base classes.","The component interface is designed not to be extended. The component base classes are extended \u201cinside\u201d the component. \u201cSpecific Interface\u201d provides an interface extension mechanism for special cases.","A component implements a single function or small sub-system capability, for example, detection, base-band tuning, signal recognition, etc.","A component accepts input and produces output, generally in the form of signals (e.g. stream of complex floating point samples) or events (detection \u201calarms\u201d).","A component developer is generally unaware of the existence or behavior of other components. This frees the developer to solve the signal or data processing problem assigned, minimizing the development of interfaces and system level interactions. Interfaces and system level interactions consume most of the software and system development activity, while providing no perceived value to the customer.","A component is controlled using run-time discoverable parameter sets. These parameter sets are associated with both the component controller and the output ports. Applications external to the component may obtain the current parameter values and definitions, and may change the parameters of the component. The component is notified of changes and may behave as the developer programs it to.","A component is developed independent of the target processor platform. The component developer need not understand the details of the operating system or machine architecture to create functioning, high performance components. The details of the operating system and target platform are insulated, as the developer uses an Operating System API for the services required. The developer typically uses a user-friendly development environment such as MicroSoft Visual C++ for initial code and debugging, and then rebuilds the component for the target.","Component Base Class Services","The Component Base Class provides the required services and interfaces for the component developer. These include:\n\n","In an embodiment setting up the development environment is pre-requisite to component development and consists of the configuration of individual WindowsNT workstations connected to the developer's company LAN.","Microsoft Windows NT 4.0 with Service Pack 4 (or later)","Intel Pentium III 600 MHz Processor (512 cache)","Minimum configuration must include:\n\n",{"@attributes":{"id":"p-0075","num":"0117"},"figref":"FIG. 1","b":["100","102","104","104","102"]},"The configuration manager  queries each process manager looking for components that have already been loaded. It constructs a database  for each processor containing a list of those components already loaded. This database  contains the current configuration of the system.","The configuration template then loads the template database or library . The template library is compared with the plan, and those templates that provide viable configurations are collected. These viable templates are then compared with the current configuration. The configuration manger  is configured to minimize the resources dedicated to a particular component. Thus the optimal assignment is one that minimizes the number of processors devoted to a particular component.","The configuration manager  assigns components first to empty processors, then to partially full processors. The configuration manager then updates the template library , including the new configuration as a template.","If the component is successfully loaded onto its assigned processor, the processor manager sends a success message back to the configuration manger . If it fails to load, the configuration manger is alerted to the error.","Referring now to , which is a block diagram of the tasking\/configuration process constructed according to one embodiment of the present invention. The plan , formulated by a tasking engine  is deployed on a fabric of processor units . This is realized through the framework manager  acting through the processor manager(s) . The processors then execute the plan , thereby creating the product .",{"@attributes":{"id":"p-0081","num":"0123"},"figref":"FIG. 3","b":["202","204","206","208","210","212","206","214"]},{"@attributes":{"id":"p-0082","num":"0124"},"figref":"FIG. 4","b":["110","100","104","104","304","306"]},{"@attributes":{"id":"p-0083","num":"0125"},"figref":"FIG. 5","b":["110","404","106","108"]},{"@attributes":{"id":"p-0084","num":"0126"},"figref":"FIG. 6","b":["102","106","602"]},"One embodiment of the present invention system for management of a distributed computing system including a tasking manager, whereby a plan is formulated describing a task to be carried out by the distributed computing system and detailing resources required for execution of the task a framework manager, communicating with the tasking manager and comprising at least one configuration manager, including a library within which are disposed at least one configuration template a means for ascertaining the current configuration of the distributed computing system a component assignment unit communicating with said tasking manager, the library, and the means for ascertaining the current configuration; and an output whereby the configuration manager directs the allocation of tasks to available system resources.","In such a system for management of a distributed computing system the configuration template may detail a tested configuration compliant with the distributed computing system and the component assignment unit may be configured to: compare said required resources with said each configuration template in said library to select usable configuration templates; compare said usable configuration templates with said means for ascertaining the current configuration; determine if system resources required by said usable templates are available; and select, based on comparisons of said usable templates with said current configuration, an optimal resource allocation for execution of said task.","According to one embodiment, system resources may include software processing units and hardware components. Such system resources may be adapted to RF applications such as tuners, channelizers, transmission security components, delay\/multi-band radios, modems, communication security components, and decoders.","One embodiment of the present invention is a configuration manager for the assignment of task elements to processing units in a component based distributed system, including a library wherein are disposed at least one configuration template; a means for ascertaining currently available system resources of the distributed computing system; a component assignment unit communicating with a tasking manager, the library, and the means for ascertaining currently available system resources; and means for communicating assignments of the task elements to the processing units.","In this embodiment, the component assignment unit may be configured to: compare said required resources with said each configuration template in said library to select usable configuration templates; compare the usable configuration templates with the means for ascertaining the current configuration; determine if system resources required by the usable templates are available; and select, based on comparisons of the usable templates with the current configuration, an optimal resource allocation for execution of the task.","According to one embodiment, system resources may include software processing units or hardware components. Such system resources may be adapted to RF applications, such as tuners, channelizers, transmission security components, delay\/multi-band radios, modems, communication security components, and decoders.","One embodiment of the present invention is a method for the configuration of components in a component based distributed system including the steps of: obtaining a plan schematic; obtaining at least one configuration template from a configuration template library; matching the configuration template with system requirements defined by the plan schematic; generating a preliminary result from the step of comparing the system requirements with the configuration template; obtaining a current configuration of components in the component based distributed system describing currently available system resources; matching the current configuration with the preliminary result; generating a final result of the step of matching the current configuration and the preliminary result; and communicating the result to distributed processing centers.","According to one embodiment, configuration templates include tested configurations for the component based distributed system. The preliminary result may include a plurality of useable templates while the final result is an optimal configuration for the components given said current configuration of the system.","According to one embodiment of the present invention, the method is executed within a framework manager. A tasking engine may formulate the plan.","According to one embodiment of the invention, matching the current configuration with the preliminary result is undertaken so as to obtain a template with an optimal correlation between the requirements of the template and resources available to the system.","According to one embodiment of the present invention, components may include software processing units or hardware components. Such components may be adapted to RF applications.","Included herein as Appendix A, are portions of source code that describe one embodiment of the invention. Those skilled in the art readily appreciate that the functionality expressed therein is not limited by the literal expression of the code and that there are numerous equivalent manners to present the functions. The comments and source code depict a single embodiment of the present invention.","Numerous characteristics and advantages have been set forth in the foregoing description, together with details of structures and functions of a configuration engine, and the novel features thereof are pointed out in appended claims. The disclosure, however, is illustrative only, and changes may be made in arrangement and details, within the principle of the invention, to the full extent indicated by the broad general meaning of the terms in which the appended claims are expressed.","The objects and advantages of the invention may be further realized and attained by means of the instrumentalities and combinations particularly pointed out in the appended claims. Accordingly, the drawing and description are to be regarded as illustrative in nature, and not as restrictive."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention will be readily understood by the following detailed description in conjunction with the accompanying drawings and exhibits, wherein like reference numerals designate like structural elements, and in which:",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
