---
title: Generating a where-used objects list for updating data
abstract: Methods and systems are described that involve creating a where-used objects list that contains a set of provider's objects to be adjusted or tested in a customized program after an upgrade of a program, import of projects, patches, and so on. A set of contracts is created that corresponds to the set of provider's objects used in the customer system. Each contract contains information about the provider's object it is created for and assigned to. This information is used by a lifecycle tool to detect if a provider's object has been changed by comparing the contract information of the provider's object with a new imported version of the same provider's object. The provider's object is modified according to the detected change and the assigned contract is recreated to represent the latest data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09658845&OS=09658845&RS=09658845
owner: SAP SE
number: 09658845
owner_city: Walldorf
owner_country: DE
publication_date: 20091218
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["Embodiments of the invention generally relate to the software arts, and, more specifically, to methods and systems for generating a where-used objects list that contains software objects to be considered for changes and testing after an upgrade (e.g., of a system and import of service patches).","Standard enterprise applications cannot cover all possible customer environments, industries, practices, and requirements. Some application platforms, such as SAP NetWeaver provided by SAP AG from Walldorf Germany offer a platform for building and deploying customer or scenario specific applications that is based on a standard offering. Usually, the customer applications are copied or they reuse parts from the common business applications provided by a given software provider. Therefore, when a provider's application has been changed due to bug fixing or embedding of new functionality, the customer application has to be changed as well. Often times, the changed standard provider's application is obtained via a software patch or service package of a product. The patch may be delivered in a number of different ways including being made available as a download from the Internet site of the company offering the given product. Usually, the patch does not contain the new version of the software in its entirety, just the changes that need to be made. The customer applications affected by these changes have to be adjusted and updated. Ascertaining which parts of the standard application have been changed and which are applicable to which application is a complex task. It is not desirable to test every customer application. The provider's application is a program (or a software product in general) that contains a number of modules and features that perform given functionality. The provider's application is offered to all customers. When a customer buys the provider's product and develops additional features or modules inside the product (or modifies existing ones) and customizes it by his or her needs and requirements, the product becomes a customized product; customer applications are such customized products.","Some software lifecycle solutions provide a list of objects that have to be adjusted or tested after an upgrade or import of patches. These solutions usually scan the actual system and compare the usage of a given object against another not yet upgraded system or against a database. Copied programs are detected by comparing source code lines. If the amount of equal lines is higher than a given threshold, the heuristic assumes it is copied.","Methods and systems are described that involve generating a where-used objects list for updating data. In one embodiment, the method includes receiving a new version of a provider's object, wherein the provider's object is used in a customized program. A contract is associated with the provider's object. Further, data from the contract of the provider's object is compared with the new version of the provider's object and a change of the provider's object in the new version of the provider's object is detected. Finally, a where-used objects list is provided with changed provider's objects.","In one embodiment, the system includes a repository unit that stores a set of provider's objects used by a provider's program and a set of custom objects used by a customized program. The system also includes a development platform that enables one or more of copying the provider's program into the customized program and a direct usage of a provider's object from the set of provider's objects into the customized program. Further, the system includes a where-used objects unit that stores a set of contracts, wherein a contract from the set stores information about the provider's object. Finally, an import tool compares the contract of the provider's object with a new version of the provider's object and detects a modification in the new version of the provider's object.","These and other benefits and features of embodiments of the invention will be apparent upon consideration of the following detailed description of preferred embodiments thereof, presented in connection with the following drawings.","Embodiments of techniques for generating a where-used objects list for updating data are described herein. In the following description, numerous specific details are set forth to provide a thorough understanding of embodiments of the invention. One skilled in the relevant art will recognize, however, that the invention can be practiced without one or more of the specific details, or with other methods, components, materials, etc. In other instances, well-known structures, materials, or operations are not shown or described in detail to avoid obscuring aspects of the invention.","Reference throughout this specification to \u201cone embodiment\u201d, \u201cthis embodiment\u201d and similar phrases, means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of these phrases in various places throughout this specification are not necessarily all referring to the same embodiment. Furthermore, the particular features, structures, or characteristics may be combined in any suitable manner in one or more embodiments.","During a lifecycle operation (e.g., upgrade, transport) of a software product, a development object (such as a program) may be copied from one software component into another software component. The copied development object may be modified later. A software component is a set of software objects that is independently delivered (e.g. an application, functional modules, etc.). In an embodiment, an object is created during the copy operation called a \u201ccontract object\u201d or simply \u201ccontract\u201d. The contract may contain information such as object name, the name of the copied object, and the source code of the object. Using the contract information, a delivery tool may find all copies of development objects, where the source code has been changed. The copying operation may be performed to update, upgrade or change a deployed version of the object. The contract represents a snapshot of the development object before the copy operation is performed. The contract may be referred to as a container that includes the information needed to detect whether the development object has been changed before the copy operation. The information may include, but is not limited to, metadata, a copy of the source code object, parameters, attributes, and so on. The contracts may be stored in a new development unit such as a where-used objects unit. Where-used lists based on the where-used objects unit show where an object is used in the system, if at all. Inside a development landscape, the contract is transported together with the development object. This allows detecting modifications of the development objects even in a system where the development object was not developed.","The contracts may be assigned to the referred (used) or copied standard (i.e., provider's) objects. In an embodiment, whenever a standard object is upgraded or transported into a system that contains a contract for this standard object, this contract is checked for changes directly as part of the normal lifecycle tools' procedures. Checking a contract means comparing the contract against the newly imported object and the usage by a non-standard object (e.g., a customer object). The result of the comparison may be presented to the user of the non-standard object. The changes of a given standard object could be: irrelevant (does not affect the program's execution), compatible (the changed object is compatible with the customized program and the customized program will run properly), or incompatible (the change is crucial and the customized program will not run properly if the change is not adopted). The incompatible changes need to be adjusted to ensure that the customized program will be executed properly; the compatible changes may be adjusted as well depending on customer's needs. For example, a compatible change could be a modification in the documentation to a given portion of a source code of a program. The customer may want to include this information in his or her program as well and thus to adopt the change. However, this change will not affect the execution of the program in either case, since it is a compatible change.","In an exemplary embodiment, a customized program invokes a method of a given class for accessing and manipulating the data stored in an object. The contract assigned to the method contains the signature of the method and further important attributes of the method such as if the method is declared as static (meaning that it acts at the class level rather than at the instance level) or declared as instance method (the method is exclusively associated with an object). The signature of a method usually includes, but is not limited to, the method's name, the number, types and order of its parameters. After checking the contract, a user may detect the following irrelevant, compatible and incompatible changes. The irrelevant changes may include: 1) the method is not changed; 2) the method is changed from private to protected, package, or public; 3) the method is changed from not final to final; etc. The compatible changes may include: 1) the content of the method is changed; 2) a new optional parameter is added; 3) the documentation is changed; 4) a new exception that inherits an already specified exception is declared; etc. The incompatible changes may include: 1) the method is deleted or renamed; 2) a new not optional parameter is added; 3) the method is changed from public to private, protected, or package and cannot be invoked anymore; 4) a new exception that does not inherit an existing exception is added; 5) an existing parameter is deleted; etc.","In another embodiment, a customized program accesses a database table, wherein the database table is a standard object. The contract assigned to the database table contains access information such as list of fields, attributes, parameters, and so on. After an upgrade of the database that includes the database table, the customized program attempts to access the database table. The contract is checked for changes. As a result the following irrelevant, compatible, and incompatible changes may occur. An irrelevant change may be if the database table contains changed attributes such as owner, changed date, etc. The compatible changes may include: 1) the documentation is changed; 2) fields that are not requested or used is the database access are changed, added, or deleted; etc. The incompatible changes may include: 1) fields that are requested or used in the database access are changed, added, or deleted; 2) the key fields of the table are changed; etc.","In another embodiment, a standard program is copied into or used in a customized program. The contract assigned to the standard program contains the entire program at the time it was copied and all signatures and attributes for any object used by the standard program. After an upgrade of the standard program, the customized program has to be adapted to the new changes (if any). The contract is checked for changes. As a result, the following irrelevant, compatible, and incompatible changes may occur. The irrelevant changes may include: 1) the attributes (e.g., owner, accessibility, etc.) of the standard program are changed; 2) the source code was reformatted without changing a statement (e.g., using a tool to unify the source code such as Pretty Printer); etc. The compatible changes may include: 1) the documentation is changed; 2) new comment lines are added; etc. An incompatible change may be that a statement of the standard program is changed, deleted, or added.","In an embodiment, an import tool is provided that supports a software developer adopting the objects that were changed as a result of reviewing the contracts. The import tool may display the differences of the objects in a three-view editor: a first user interface (UI) element (e.g., window) of the editor to display the old standard object; a second UI to display the new standard object; and a third UI to display the copied or used object. Further, the import tool may provide automatic functionality to adjust the changed standard objects used by the customized program including, but not limited to: rename of a method call when the standard method was renamed; adding of parameters that were newly added in the standard program; adding, changing, or deleting of the source code that was added, changed, or deleted in the standard program; and so on. In addition, a test list may be provided to automatically start executing tests after the customized program is adopted.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["100","110","110","115","120","130","140","145","150"]},"The where-used objects unit  is linked with the customized program , the standard program , and a number of standard objects used by the standard program  (for example, table  and method  of class ). The where-used objects unit  contains the contracts assigned to the standard program  and the used objects. In an embodiment, the where-used object unit  may include: a contract program  that contains information about standard program  such as the relevant source code; a contract method  that contains information about method  such as the names and types of all used parameters of method  in class ; contract table  that contains information about table  such as the names and types of all used fields of table ; etc. These contracts contain all relations to the standard objects  (e.g., table  and method  of class ) that when some of the used objects of standard objects  are changed, may cause the customized program  to run incorrectly. The stored data of the contracts in the where-used objects unit  may be compressed to save resources (e.g., disk space) by using text compressing algorithms, by removing some irrelevant information such as comments, documentation, etc., and other downsizing techniques.","In an embodiment, method  of class  was changed by the provider of the standard program . For example, a parameter in the method definition is removed. The standard program  is adjusted and adapted to the new method accordingly by the software provider. The class  and the standard program  may be delivered to a customer via an upgrade, a patch, a support packages, or a similar module. A delivery procedure (e.g., upgrade or service package import) may be performed at the customer's system by a corresponding tool, such as an import tool (e.g., upgrade tool). During the delivery procedure, the import tool compares line by line the new data with the data stored in the contracts. Thus, the import tool may detect that a parameter in method  of class  was removed (since the contract of method  contains the copied source code of the method itself). At the end of the delivery procedure, the import tool may provide a list of customer objects (as part of customer objects ) that may be affected by changes and may need to be adjusted. In an embodiment, this list shows objects from the where-used objects unit  that includes the contracts. Since method  was changed and the customized program  uses this method , the customized program  may have to be changed. The import tool may point the user to the customized program  that uses method  to be modified. In an embodiment, the import tool may allow the user to navigate from the tool to the standard object used in the customized program  to adopt the changes (e.g., via a clickable link). Modifying the customer program  to include the changes results in recreating the contracts that correspond to the modified standard objects, stored in the where-used objects unit . Thus, the contracts will include the last version of the stored information. The same algorithm as for creating the where-used objects unit  during the initial copy operation of the program can be used for the recreation.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 2","FIG. 1","FIG. 1"],"b":["130","140","130","140","200","130","140","140","170","180","180","160","170","170","180","160","130","140","170","210","140","150","150","154","156","170","180","160"]},"In an embodiment, table  is changed (e.g., a field was removed) by a program such as standard program  at the program's provider side. Class  that uses table  is adjusted with the change by the provider of the standard program  (in ). Class  and table  may be delivered to the customer via standard delivery procedures including, but not limited to, program upgrade, import of a patch, import of a service pack, and so on. Since customized program  uses method , whose parameters are stored in table , any change in the table  may result in a syntax error. Thus, customized program  may have to be adjusted as well. During the delivery procedure, the import tool compares the new data with the data stored in the contracts. Thus, the import tool can detect that a field in table  was removed (since the contract of table  contains the fields of the table itself). At the end of the delivery procedure, the import tool may provide a list of customer objects (as part of customer objects ) that are affected by changes and may need to be adjusted. In an embodiment, this list shows objects from the where-used objects unit  that includes the contracts. In an embodiment, the import tool may allow the user to navigate from the tool to the customized program  to adopt the changes. Changing the customized program  to include the changes results in recreating the contracts of the modified standard objects in the where-used objects unit . The same algorithm as for creating the where-used objects unit  during saving or compiling of the customized program can be used for the recreation.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3","b":["300","140","130","310","130","140","130","320"]},"In another embodiment, the customer may want to use just some particular parts of the standard program, such as a method, a database table, etc. Accordingly, at block , usage of a set of standard objects when developing a customized program is identified (e.g., imported via a development platform). While saving (or compiling) the customized program with the newly used set of standard objects, a contract is generated for each of the used objects in the set, at block . The contracts contain information about the used objects. For example, if a method is used in the customized program, the generated contract contains, for example, the names and types of parameters of the methods used. At block , all generated contracts (discarding the generation scenario) are stored in a where-used objects unit. Some point later, a new version of the standard program may be available from the program's provider. This new version may contain objects that are used by the customized program and have been modified by the provider. At block , the new version of the program is obtained by the customer. The new version may be delivered by a support package, a patch, and so on. The customer may use an import tool or other solution to apply the new version of the standard program. During the update procedure, a check for changes may be performed by the import tool. At block , the data from the new version is compared with the stored data from the contracts. For example, if a given method is used by the customized program and there is a contract for this method in the where-used objects unit, the version of the method that is provided with the new version of the standard program is compared with the contract of the method. Since the contract contains all necessary information about the method (such as parameters, attributes, etc.), a difference between the two versions can be established, if there is any.","At block , if there are any modified objects of the standard program that are used by the customized program, these objects are detected by the import tool in response to the comparison with the contracts. At block , a list of the used modified objects is generated and provided to the user. The changes in the standard objects could be compatible, incompatible, or irrelevant. Depending on the type of the change, the user may decide which change to adopt in the customized program. In an embodiment, the update procedure may provide a direct navigation (e.g., a link) to the customized program where the objects are used. At block , the customized program may be adjusted according to the modified objects. At block , the contracts are recreated and the where-used objects unit is regenerated as result of the modifications. The customized program is updated and the contracts contain the latest information. Using contracts for the standard objects used by a customized program decreases the effort of applying new versions of a standard program. The contracts enable fast and easy comparison between the new data and the old data whenever standard objects are used or copied.","Some embodiments of the invention may include the above-described methods being written as one or more software components. These components, and the functionality associated with each, may be used by client, server, distributed, or peer computer systems. These components may be written in a computer language corresponding to one or more programming languages such as, functional, declarative, procedural, object-oriented, lower level languages and the like. They may be linked to other components via various application programming interfaces and then compiled into one complete application for a server or a client. Alternatively, the components maybe implemented in server and client applications. Further, these components may be linked together via various distributed programming protocols. Some example embodiments of the invention may include remote procedure calls being used to implement one or more of these components across a distributed programming environment. For example, a logic level may reside on a first computer system that is remotely located from a second computer system containing an interface level (e.g., a graphical user interface). These first and second computer systems can be configured in a server-client, peer-to-peer, or some other configuration. The clients can vary in complexity from mobile and handheld devices, to thin clients and on to thick clients or even other servers.","The above-illustrated software components are tangibly stored on a computer readable medium as instructions. The term \u201ccomputer readable medium\u201d should be taken to include a single medium or multiple media that stores one or more sets of instructions. The term \u201ccomputer readable medium\u201d should be taken to include any physical article that is capable of undergoing a set of physical changes to physically store, encode, or otherwise carry a set of instructions for execution by a computer system which causes the computer system to perform any of the methods or process steps described, represented, or illustrated herein. Examples of computer-readable media include, but are not limited to: magnetic media, such as hard disks, floppy disks, and magnetic tape; optical media such as CD-ROMs, DVDs and holographic devices; magneto-optical media; and hardware devices that are specially configured to store and execute, such as application-specific integrated circuits (\u201cASICs\u201d), programmable logic devices (\u201cPLDs\u201d) and ROM and RAM devices. Examples of computer readable instructions include machine code, such as produced by a compiler, and files containing higher-level code that are executed by a computer using an interpreter. For example, an embodiment of the invention may be implemented using Java, C++, or other object-oriented programming language and development tools. Another embodiment of the invention may be implemented in hard-wired circuitry in place of, or in combination with machine readable software instructions.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4","b":["400","400","405","455","400","440","455","410","415","410","415","405","415","400","425","430","400","425","430","400","435","400","450","450","400","445","400","420","460","460","460","450","460"]},"A data source is an information resource. Data sources include sources of data that enable data storage and retrieval. Data sources may include databases, such as, relational, transactional, hierarchical, multi-dimensional (e.g., OLAP), object oriented databases, and the like. Further data sources include tabular data (e.g., spreadsheets, delimited text files), data tagged with a markup language (e.g., XML data), transactional data, unstructured data (e.g., text files, screen scrapings), hierarchical data (e.g., data in a file system, XML data), files, a plurality of reports, and any other data source accessible through an established protocol, such as, Open DataBase Connectivity (ODBC), produced by an underlying software system (e.g., ERP system), and the like. Data sources may also include a data source where the data is not tangibly stored or otherwise ephemeral such as data streams, broadcast data, and the like. These data sources can include associated data foundations, semantic layers, management systems, security systems and so on.","The above descriptions and illustrations of embodiments of the invention, including what is described in the Abstract, is not intended to be exhaustive or to limit the invention to the precise forms disclosed. While specific embodiments of, and examples for, the invention are described herein for illustrative purposes, various equivalent modifications are possible within the scope of the invention, as those skilled in the relevant art will recognize. These modifications can be made to the invention in light of the above detailed description. Rather, the scope of the invention is to be determined by the following claims, which are to be interpreted in accordance with established doctrines of claim construction."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The claims set forth the embodiments of the invention with particularity. The invention is illustrated by way of example and not by way of limitation in the figures of the accompanying drawings in which like references indicate similar elements. The embodiments of the invention, together with its advantages, may be best understood from the following detailed description taken in conjunction with the accompanying drawings.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4","b":"400"}]},"DETDESC":[{},{}]}
