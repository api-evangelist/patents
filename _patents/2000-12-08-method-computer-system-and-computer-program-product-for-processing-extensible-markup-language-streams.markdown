---
title: Method, computer system and computer program product for processing extensible markup language streams
abstract: The invention is directed to a method performed by a computer system to process an extensible markup language input stream using discrete software components mapped to tags contained in the input stream, comprising: parsing the input stream; as a tag is parsed, invoking the software component mapped to it. The invention is also directed to a computer system, comprising: a processing unit and storage for processing programs; bindings representing a mapping between tags and discrete software components; a software engine comprising: a reader component that reads an extensible markup language input stream containing at least one tag; a parser component that parses the input stream; an execution component that, as a tag is parsed, invokes the software component mapped to the tag. The invention is also directed to a corresponding computer program product.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06925631&OS=06925631&RS=06925631
owner: Hewlett-Packard Development Company, L.P.
number: 06925631
owner_city: Houston
owner_country: US
publication_date: 20001208
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention relates generally to the processing of tokenized data streams, and more particularly to a method, a computer system and a computer program product for processing extensible markup language streams.","A markup language represents a hierarchical structure for a document by identifying markup on \u201ctags\u201d. For example, the HyperText Markup Language (HTML) focuses on expressing the presentation of a document (i.e. its formatting and displaying), for example sections, subsections, sidebars and images by attaching corresponding tags to individual words, paragraphs etc. Markup languages allow documents to be exchanged among applications. For example, HTML documents are widely used in the request-response protocol of what is called the World Wide Web (i.e. the Internet with the HyperText Transfer Protocol (HTTP) protocol suite). Normally, when a HTTP server in the Web receives a HTTP request, it sends a HTTP response with an embedded HTML document to the HTTP client (\u201cbrowser\u201d) from which the request originates. The browser processes the HTML document and, thus, displays it on a graphical user interface according to the presentation information contained in the document.","HTML has proven quite limiting because it focuses on the presentation of documents rather than representing their internal structure, and has a fixed set of tags. Extensible markup languages can solve this problem of limited flexibility of HTML. Under the auspices of a consortium that creates de facto standards for the Web, the World Wide Web Consortium (W3C) a new markup language called XML was defined in 1996 (see: Extensible Markup Language (XML) 1.0 W3C Recommendation Feb. 10, 1998\u201d, http:\/\/www.w3.org\/TR\/REC-xml). With XML, a user can define his own set of tags. The definition of these tags can be contained in a Document Type Definition, or DTD. One of the validity constraints specified in the XML 1.0 Recommendation is that all tags of a document are defined in the DTD which is referenced in an XML document.","In the beginning, XML was thought of mainly as the language for metacontent. Metacontent is information about a document's contents, such as its title, author, revision history, keywords, and so on. Metacontent can be used, for example, for searching, information filtering and document management. Another interesting application relates to databases. If data is delivered as an document that preserves the original information, such as column names and data types, as is the case with XML, it can be used for other purposes than just displaying on the screen, for example, to do some computation. A further application area of XML is messaging, i.e. the exchange of messages between organizations (B2B messaging) or between applications systems within an organization. These applications are, for example, described in H. Maruyama et al.: XML and Java, 1999, pages 13 to 30.","It has also been proposed that the information contained in an XML document is used as processing instructions for certain procedures. For instance, Maruyama et al. gives an example of how XML can be used to interface with a database:","A SQL (Standard Query Language) query is embedded in an XML document. When, the XML document is parsed by an XML processor, a DOM (Document Object Model) representation of the XML document is generated in the memory of the processing computer system. DOM is an application programming interface (API) for XML documents (see J. Robie (Ed.): What is the Document Object Model?, REC-DOM-Level-1-1981001, http:\/\/www.w3.org\/TR\/REC-DOM-Level-1\/introduction.html and M. Champion et al. (Eds.): Document Object Model (Core) Level 1, REC-DOM-Level-1-19981001, http:\/\/www.w3.org\/TR\/REC-DOM-Level-1\/level-one-core. html). When using DOM, the tag structure of an XML document is converted in a tree-like memory structure, called a \u201cDOM tree\u201d. After the parsing of the XML document has been completed and the corresponding DOM tree is generated in the memory, the DOM tree is processed by visiting all nodes of the tree. When the node with the SQL query is visited, it is executed, i.e. the database is accessed (H. Maruyama et al., pages 97-141, 185-228).","Another similar example of how XML documents are processed is the JavaServer Pages Technology by Sun Microsystems, Inc. (see E. Pelegr\u00ed-Llopart et al.: JavaServer Pages Specification, version 1.1, Nov. 30, 1999). (JavaServer Pages is a trademark of Sun Microsystems, Inc.). The JavaServer Pages (JSP) technology enables the authoring of Web pages that create dynamic content. A JSP page is a text-based document that describes how to process a request to create a response. JSP pages are compiled to what is called servlets and respond to HTTP requests. An input received from HTTP POST or QUERY arguments can be in the form of an XML document. Such an input is first parsed by an XML parser, and a corresponding DOM tree is generated in memory. Then, JavaBeans components, Enterprise JavaBeans components, or custom actions can be invoked (see Pelegr\u00ed-Llopart et al., page 31). This corresponds in principle to the method for interfacing databases proposed by Maruyama et al.","A method performed by a computer system to process an extensible markup language input stream uses discrete software components mapped to tags contained in the input stream. The method comprises parsing the input stream, and, as a tag is parsed, invoking the software component mapped to it.","According to another aspect, a computer system comprises a processing unit and storage for processing programs, bindings representing a mapping between tags and discrete software components, and a software engine. The software engine comprises a reader component that reads an extensible markup language input stream containing at least one tag, a parser component that parses the input stream, and an execution component that, as a tag is parsed, invokes the software component mapped to the tag.","According to still another aspect, a computer program product includes program code for execution on a computer system. The program code is capable of processing an extensible markup language input stream using discrete software components mapped to tags contained in the input stream. The program code directs the computer system to parse the input stream; as a tag is parsed, invoke the software component mapped to it.","Other features are inherent in the disclosed method, computer system and computer program product or will become apparent to those skilled in the art from the following detailed description of embodiments and its accompanying drawings.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1"},"A \u201cmarkup language\u201d describes a class of data objects which are at least partly made up of characters, some of which form character data, and some of which form markup. Markup takes, for example, the form of start-tags, end-tags, empty-element tags, entity references, character references, comments, CDATA sections, delimiters and document type declarations. Logical structures of the document are defined by what are called tags. A tag is commonly constituted of a start-tag and an end-tag, or by an empty-element tag. Whereas in HTML the set of available tags is limited (it can only be extended by a standardization body, as the World Wide Web Consortium), the term \u201cextensible\u201d refers to a markup language's ability to have new markup tags freely defined by users, customized to particular purposes. The definition of these tags can be contained in a DTD. The DTD can be published and thereby be made available to anyone wanting to use documents with these customized tags. The extensible markup language used in the preferred embodiments is XML. However, other extensible markup languages, like SGML, the Standard Generalized Markup Language (ISO 8879) can also be used.","The term \u201cstream\u201d covers documents and messages and parts of them, as well as a (quasi-)infinite series of data or messages, for example in work flow or multimedia applications.","\u201cParsing\u201d is the process of reading an input stream and dissecting it into elements that can be analyzed. Unlike the methods discussed in the background section in which first the entire document is parsed and transformed into a DOM tree in memory, and only then, in a second pass over the DOM tree, the actual processing of the representation of the document information (e.g. database interfacing) is performed, in the disclosed embodiments the process of parsing and document processing is one-pass. That is, the invocation of software components mapped to the tags is performed during the parsing process. This means that \u201cbehavior\u201d induced by invoking the software components is already generated during the input stream is parsed (for the first) time, and not only after it has been parsed. The preferred parser (an event-driven Application Programming Interface (API)) is the \u201csimple API for XML\u201d (SAX) parser. SAX has been developed by David Megginson et al. Although not sanctioned by any standards body, SAX is widely used because of its simplicity. It can be downloaded from http:\/\/www.megginson.com\/SAX\/.","In some of the preferred embodiments the input stream is parsed and processed only once. However in other embodiments, one and the same input stream can be parsed and processed more than once (e.g. twice). For example, if the bindings in the second pass of combined parsing and processing are different from the first pass, the results of the first combined parsing and processing will differ from those of the second parsing and processing.","It is not necessary that all tags contained in the input stream are mapped to a discrete software component. Rather, if a tag which is not mapped is parsed, no software component or a software component that does nothing is invoked. For the tags which are mapped, in the disclosed embodiments, the mapping is a single-valued function. In other words, each mapped tag is mapped to only one (rather than to two or more) software component, but it may be that two or more tags are mapped to the same software component. However, in the most preferred embodiments there is a one-to-one mapping between all mapped tags and software components. In other words, to each mapped tag corresponds exactly one software component.","In the preferred embodiments, the discrete software components are classes of an object-oriented programming language, like Java (Java is a trademark of Sun Microsystems, Inc.). They can likewise be procedures or functions of a procedural programming language.","In the applications mentioned in the background section, a DOM tree which corresponds to the entire XML input document is built before the actual processing of the document is performed. This is because behavior (as, for instance, a database access is only generated by a second pass over the generated DOM tree. In contrast to such a recursive processing, in the preferred embodiments the behavior is generated during the input stream is parsed, which requires only a single pass. Of course, it is not excluded that a hierarchical memory structure, like a DOM, tree is also built during the parsing. This is, in fact, done in the preferred embodiments. One of the reasons for building a DOM tree is that a tag generally has a start-tag and an end-tag which may have many sub-tags (children). In a XML document, the children are bracketed between the start-tag and the end-tag. As behavior may be invoked when the start-tag or the end-tag or both are parsed and, may depend on the children of a tag, it is advantageous to keep track of all start-tags and their children, at least until they are closed by their corresponding end-tag. To this end, preferably a hierarchical tree structure (i.e. a DOM tree) in built during the parsing.","As explained above, a tag of the extensible markup language input stream is generally formed by a pair of a start tag and an end tag, which have optionally one or more children. In the preferred embodiments, the discrete software components comprise a method, which is invoked as the start-tag of a tag, is parsed (called \u201cinit method\u201d) and a further method, which is invoked as the end-tag of a tag, is parsed, i.e. after all children of the tag (possibly zero) have been parsed (called \u201crun method\u201d). For example, the init method may be a conditional call, as a data validity check. When the run method is invoked, the program has already an awareness of all children of the tag since they have already been parsed by this time.","Generally, the syntax of a programming language is fixed. In the disclosed embodiments, however, the mapping between the tags and the discrete software objects can be easily changed before, after or even during the parsing process. Consequently, the \u201cbehavior\u201d that is induced by a certain tag is not fixed, but can be changed depending on the context in which the input stream is parsed, or any other internal or external conditions. The bindings may even be changed depending on events that occurred in the same input stream. A markup language which flexibly binds behavior to tags can be considered as a \u201cdynamic programming language\u201d.","For complex applications, like workflow applications, the disclosed XML processing method can be queued. If one considers a reader component, a parser component and an execution component (and, optionally, further components not listed here) as one XBF engine, then two or more of such XBF engines can then work in series. One XBF engine generates an extensible markup language output stream which is used as an input stream for another XBF engine. The generation of the output stream by the first XBF engine can be a result of the invoking of one or more of the software components which are mapped to tags of the input stream and are capable of transforming XML input into a (normally different) XML output. Alternatively, the output stream can be generated in a \u201csecond pass\u201d using the hierarchical memory structure which corresponds to the XML input stream, since in the present context it is not necessary that all the \u201cbehavior\u201d is already induced during the parsing of the input stream. Rather, it is also possible that a part of the behavior, for example the transformation of the input stream into the output stream, is only performed in a second pass.","There are a number of important applications for the disclosed embodiments of the method, computer system and computer program product. In a first application, the computer system is a server in a network, and the extensible markup language input stream is processed by the server. It can, for example, be comprised in a request received over the network from a client. As a tag of the input stream is parsed, the software component mapped to it is invoked, for example, a software component for accessing a database. Information retrieved from the database may then be built into a document page (e.g. a HTML document page) to form a response to the client's request. Another possible source for XML input is a database, since data can advantageously be stored in databases in the form of XML documents or document fragments. Such an XML database output forms an input for the disclosed embodiments, and as a tag is parsed, a software component mapped to it is invoked. Again, this could be used to generate a response to a client's request (which could be a conventional HTML request).","Another application is the use of XML as a query language. To this end, the invoked software components comprise at least one software component for interfacing with a database. In contrast to the proposal of MARUYAMA et al. mentioned at the outset, the database-interfacing software components are invoked during the parsing process, as the corresponding tags of the input stream are parsed.","Another application of the disclosed embodiments is messaging, in particular the dispatch of bulk e-mail or facsimile. To this end, the invoked software components comprise at least one software component for sending electronic mail and\/or for sending facsimiles.","A still further application is remote computing. In a disclosed embodiment, the computer system comprises a local computer and a remote computer, which communicate which each other. Commands given to the local computer are executed on the remote computer. However, the results of the execution are output on the local computer so that the commands appear to be executed locally. The communication between the local and the remote computers comprises the transmission of tokenized data streams, as XML streams. The disclosed method for processing XML input is performed on the local computer or on the remote computer or on both. Processing on the remote computer comprises executing the commands received from the local computer. Processing on the local computer comprises outputting the results received from the remote computer, e.g. on a Graphical User Interface.","The disclosed embodiments of the computer program product comprise the disclosed program code which, for example, is stored on a computer-readable data carrier or is in the form of signals transmitted over a computer network. The program code comprises the following classes: a class which parses the input stream (named TagletEngine), a class which implements a parser interface (named TagletDocumentFactory), a class which creates a document (named TagletDocument), a class which creates \u201cTaglets\u201d (named TagletFactory), a class which provides behavior for the Taglets (named Taglet).",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 2","FIG. 1","FIG. 2"]},"Then, when the \u201cproduct\u201d and \u201cquantity\u201d tags are parsed, the init and run methods of the classes \u201cProduct\u201d and \u201cQuantity\u201d are invoked, since these two tags are again empty element-tags. The attributes of the \u201cproduct\u201d and \u201cquantity\u201d tags (\u201ccode\u201d, \u201cunits\u201d and \u201cvalue\u201d) can be used in the corresponding invoked classes. Then, when the end-tags of \u201citems\u201d and \u201corder\u201d are passed, the run method of the classes \u201cItem\u201d and \u201cOrder\u201d are invoked. This way of processing an XML document is in contrast to the prior art described in the background section, in which the only result of parsing an XML input document would be the generation of a DOM tree. In this prior art, a behavior could only be generated upon a \u201csecond pass\u201d, which goes over the nodes of the DOM tree generated during the first parse.","However, also in the disclosed embodiments a DOM tree is built during the parsing process. The main purpose of that is to achieve that the program has \u201cawareness\u201d of all children of a tag when the tag's end-tag is parsed and the corresponding run method is invoked.  illustrates a DOM tree which resembles the structure of the XML document fragment of  DOM representation is a hierarchical, tree-like structure generated, for example, in the memory of the disclosed computer system. (Details of the Document Object Model (DOM) can be taken from Robie and Champion et al.) The order tag of  is represented by a root node named order. It has two child nodes named customer and item, which represent the corresponding tags of FIG. . The customer node has an attribute (id=\u201c123-456\u201d), whereas the item note has two child nodes, product and quantity, which represent the corresponding tags of FIG. . The products and quantity nodes have the attributes \u201ccode=\u201c123\u201d as well as units=\u201cea\u201d and value=\u201c3\u201d, respectively",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 4","b":["10","11","12","10","10","13","14","13","15","13","16","14","17","18","12","19","4"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 5"},"The XBF program is written in JAVA. A simple example of a XBF main program, test. java, is shown below in listing 1.","Class Test","Listing 1: Test.java: XBF main program","import xbf.core.Taglet;","import xbf.core.TagletEngine;","import java.io.InputStreamReader;","import java.io.OutputStreamWriter;","import java.io.Reader;","import java.io.StringReader;","import java.io.StringWriter;","import java.io.Writer;","import java.util.Dictionary;","import java.util.Hashtable;","class Test","{","\/* Do nothing constructor *\/","public Test( )","{\n\n","}","public static void main(String[ ] args)\n\n","{\n\n","}","}","The main purpose of an XBF main program is to read in the XML input stream and the bindings and to invoke a class TagletEngine. However, to make the present example simple, the XML input stream is not read in, but is defined in-line in the XBF main program:\n\n","In line [11], the XML input stream is made up of a foo tag (formed by a start-tag and an end-tag). The foo tag has one child, which is an empty-element tag hello.","Next, the bindings which represent the mapping between tags and discrete software components to be invoked, are entered into the program (a binding is, for example, a tuple of a tag name and an \u201cobject\u201d, for instance a name of a Java class). Generally, the bindings are entered by accessing a file or a database. In order to make the present example simple, only one binding is entered, again by an in-line definition:\n\n","In line [18], an object TestTaglet is mapped to the hello tag. No object is mapped to the foo tag.","Then, the program creates an instance engine of class TagletEngine:\n\n","After the XML input and the bindings have been passed to engine,\n\n","In , the main program is indicated by an arrow \u201ca\u201d which symbolizes that the class TagletEngine is invoked and the XML input stream is passed to it. The class TagletEngine and its relevant classes are illustrated by box  in FIG. . Listing  shows the core of the class TagletEngine, mainly the runEngine method.","Class TagletEngine","Listing : TagletEngine.java: Parses the inputstream","package xbf.core;","import java.io.InputStreamReader;","import java.io.OutputStreamWriter;","import java.io.Reader;","import java.io.Writer;","import java.util.Dictionary;","import java.util.Hashtable;","import com.sun.xml.tree.ElementNode;","import com.sun.xml.tree.XmlDocumentBuilder;","import com.sun.xml.tree.XmlDocument;","import org.xml.sax.DocumentHandler;","import org.xml.sax.InputSource;\n\n","public class TagletEngine","{","public void runEngine( )\n\n","}","}","The SAX parser, an event-driven API, is used for the parsing process. The application registers an event handler to a parser object that implements the org.sax.Parser interface. The event handler interface DocumentHandler is called whenever an element is found in the input stream.","First, the Parser interface is imported:\n\n","Next, an instance of a SAX driver is created:\n\n","Next, an instance of class TagletDocumentFactory is registered as a DocumentHandler:\n\n","Then, the input stream is parsed:\n\n","Upon parsing the input stream, a DOM representation of it is created. As an XML tag is found, an object (e.g. a JAVA class), as defined by the corresponding binding, is bound to the DOM tree for the specific tag. A tag with behavior (e.g. a JAVA class) bound to it is called a \u201ctaglet\u201d. As will be explained in more detail below, a init ( ) method is invoked on the taglet. After all of the taglet's children (possibly zero) have been added to the DOM representation, the taglet's run ( ) method is invoked.","After the input XML document has been entirely parsed, the DOM representation is written out again as an XML document:\n\n","The class TagletDocumentFactory is illustrated in  by box  and its core is listed below. Its creation is symbolized by an arrow . and completely in the appendix. The class TagletDocumentFactory implements the DocumentHandler interface and defines the methods which are associated to the different element types that appear during the parsing process, like the start or end of the document or the appearance of an start-tag or an end-tag.","Class TagletDocumentFactory","Listing 3: TagletDocumentFactory.java: Implements the parser interface","package xbf.core;","import java.util.Hashtable;","import java.util.Stack;","import org.w3c.dom.Node;","import org.xml.sax.AttributeList;","import org.xml.sax.DocumentHandler;","import org.xml.sax.Locator;\n\n","{\n\n","{\n\n","}\n\n","{\n\n","}\n\n","{\n\n","}\n\n","{\n\n","}","}","First, by the keyword implements, the interface DocumentHandler is applied to the class TagletDocumentFactory:\n\n","When the parser finds the start of a document, the method startDocument ( ) is invoked (line [11]). In this method, an instance document of class TagletDocument is created:\n\n","When the parser finds a start-tag or an empty-element tag, the method startElement is invoked (line [27]). First, a new taglet is created:\n\n","Then, in lines [33] to [53] the new taglet is built into a DOM tree structure InheritanceStack. To this end, first a distinction is made as to whether the new taglet already has a parent taglet or is the document root:\n\n","If the parent taglet already exists, it is fetched (without removing it) from the InheritanceStack by the peek method of the Java collection class stack:\n\n","Then the new taglet is appended to the parent taglet:\n\n","Otherwise, the new taglet is appended to the document root:\n\n","Then, the new taglet is pushed onto the InheritanceStack so that it becomes the parent for a next taglet (by method push of class Stack):\n\n","Finally, the new taglet is \u201cinitialized\u201d, which means that the method init ( ) is invoked for newTaglet of class Taglet:\n\n","When the parser finds an end-tag or an empty-element tag, the method endElement is invoked (line [61]). Children may appear between a start-tag and an end-tag so that the method startElement will be called a corresponding number of times for new taglets (child taglets) before the method endElement will be called for the taglet in consideration.","First, the taglet is fetched and removed from the InheritanceStack by the pop method of class Stack:\n\n","Then, the run method of class Taglet is invoked on the taglet which is closed by the end-element tag found by the parser:\n\n","The run method, which is the counterpart to the init method is invoked: the former is invoked when the taglet is closed, the latter when the taglet is opened. Both methods bind \u201cbehavior\u201d to a tag as it is parsed, as will be explained in more detail below.","When the parser finds the end of a document, the method endDocument is invoked (line [74]). This method does nothing.","The class TagletFactory is illustrated in  by box  and its core is listed below. Its creation is symbolized by arrow . Its method createTaglet (which is, for example, invoked in line [33] of TagletDocumentFactory listed above) generates taglets from tag names.","Class tagletFactory","Listing 4: TagletFactory.java: Creates taglets","import java.util.Dictionary;","import java.util.Enumeration;","import java.util.Hashtable;","import org.xml.sax.AttributeList;","import com.sun.xml.tree.ElementFactory;","public class TagletFactory\n\n","{\n\n","}","\/\/ if the object is a Class","if (boundObject instanceof Class)","{\/\/ return an instance of the Class\n\n","}","\/\/ else if the object is a Taglet","else if (boundObject instanceof Taglet)","{\/\/ return deep clone of bound taglet\n\n","}","else","{\/\/ otherwise, use an plain Taglet\n\n","}","\/\/ set tag name\n\n","return retVal;","}\n\n","(String tagName, AttributeList attributes)","{\n\n","}","\/* Promote a class name.","The passed class name is promoted to a Class. *\/\n\n","{\n\n","}","}","The method createTaglet (line [11]) creates a new taglet from the binding boundObject stored in the taglet bindings dictionary:\n\n","Objects in the initial taglet bindings dictionary may be one of three types: String, class or a taglet. Strings will be interpreted as class names and promoted to classes on first use (see the Promote method starting in line [71]):\n\n","If the tag name is bound to a class an instance of that class is returned:\n\n","If the tag name is bound to a taglet a deep clone of that taglet is returned:\n\n","Otherwise, a plain taglet is used:\n\n","Finally, the name of the taglet is set to the tag name:\n\n","The method createTaglet is overloaded: Whereas createTaglet of line [11] has one argument of the type String, the method createTaglet of line [52] has two arguments of types String and AttributeList. The method createTaglet with two arguments invokes the method createTaglet with one argument (line [56]) and sets the argument of the type AttributeList on the new taglet:\n\n","The Class TagletDocument, which is invoked when the parser finds the start of a document in class TagletDocumentFactory in line [16], is illustrated in  by box . The creation of an empty taglet document (a DOM document) is symbolized by an arrow .","The class Taglet, the methods of which are invoked as a taglet is parsed (for example in lines [56] and [69] of class TagletDocumentFactory) is illustrated in  by box  and is listed below. The creation of one taglet for each XML tag in the input stream is symbolized by arrow .","Class Taglet","Listing 5: Taglet.java: Provides behavior (init and run methods) for taglets","package xbf.core;","import com.sun.xml.tree.ElementNode;","public class Taglet\n\n","{","public Taglet( )","{\n\n","}","public TagletDocument getTagletDocument( )","{\n\n","}","\/** Initialize the taglet (tag open).\n\n","{","}","\/** Run the taglet (tag closed).\n\n","{","}","void setName(String tagName)","{\n\n","}","}","The arrow  in  symbolizes that taglets are added to the taglet document. As each taglet is added to the taglet document, the taglet's init ( ) method is called. After all the taglet's children have been added to the taglet document, the taglet's run ( ) method is called. As the taglet document is written to the output stream (as XML), the taglet's toString( ) method is called.","The class Taglet has the methods init (line [17]) and run (line [21]) which, however, do nothing. In fact, the class Taglet is intended to be extended by the specific classes which are bound to the tags by the bindings.","In the present example, the class TestTaglet is bound to the tag name hello (see listing 1, line [18]).","As a simple example of such a specific class extending the class Taglet, the class TestTaglet is shown below in listing 6:","Class TestTaglet","Listing 6: TestTaglet.java: Extends Taglet","import xbf.core.Taglet;\n\n","{","public TestTaglet( ) {\n\n","}\n\n","{\n\n","}\n\n","{\n\n","}","}","The class TestTaglet extends the class Taglet (line [3]). In this simple example, the init method (line [8]) outputs only the string TestTaglet.init (line [10]). The run method (line [13]) outputs only the string TestTaglet.run (line [15]).","Finally, arrow  in  symbolizes that the taglet document is written to the output stream .","The several steps performed by the program described in connection with  are summarized and illustrated by the flow diagram of FIG. . First, an XML document to be processed and bindings which bind \u201cbehavior\u201d (e.g. Java classes) to tag names are input into the program in Steps  and . In the above example of the main program test.java, the input document is <foo><hello\/><\/foo>. There is only one binding which binds the class TestTaglet to the hello tag. There is no binding for the foo tag. In step , the parsing process is started. Parsing is an event-driven process. The events are items (or elements) in the input document. Generally, an input document contains more than one item. Step  and the following steps are carried out for each item and, thus, form a loop. If the loop is entered, in Step  the first item in the input document is parsed, otherwise the next item is parsed. In Step  it is checked whether the parsed item is the start of the input document. If the answer is affirmative, in Step  an empty DOM document is created in the memory of the computer system  which carries out the method. Then, the flow returns to Step  where the next item in the input stream is parsed.","If the answer in Step  is negative, it is checked in Step  whether the parsed item is a start-tag. If the answer is affirmative, in Step  a new taglet is created, i.e. behavior (a Java class) is bound to the tag. In Step , the taglet is appended in the DOM document to the previous taglet (or, if there is no previous taglet, it forms the document root) and pushed, so that it becomes the parent for a next taglet which will be appended when the program flow loops over Step  the next time. In Step  the taglet is \u201cinitialized\u201d, which means that the init method of that class, which is bound to the present tag is invoked. This generates that kind of \u201cbehavior\u201d which is defined in the invoked init method. Then, the flow returns to Step  which parses the next item in the input document. If the current tag has at least one child, the next item parsed in Step  will again be a start-tag, which will again be processed through Steps  to , and so forth. After all the taglet's children (possibly zero) and sub-children etc. have been appended to the DOM representation and initialized by a corresponding number of cycles through Steps -, an end-tag will be detected in Step  and . Then, in Step  the corresponding taglet is fetched and removed from the DOM tree. In Step , the method \u201cruns\u201d the taglet, which means that the run method of that class which is bound to the tag closed by the end-tag is invoked. This generates that kind of \u201cbehavior\u201d which is defined in the invoked run method. Then, the flow returns to Step  where the next item in the input stream is parsed. The sequence of Steps  to  will be run through for each end-tag, i.e. for a number of times which corresponds to the number of initialization cycles through Steps  to . Apart from start and end of the document and start-tags and end-tags there may appear other events, like white space events, processing instruction node events, etc. This other events are found when the start-tag and end-tags check in Steps  and  are negative and the \u201cother item\u201d check in Step  is positive. They are processed in Step  from where the flow returns to Step . An empty-element tag is handled as a start-tag and a subsequent end-tag. Tags may have attributes which can be used as input variables for the init and run methods. Also data contained in the XML input document can be used as input for the init and run methods and be processed by them. The handling of attributes and data is evident for the skilled person.","If the end of the document is be detected in Step , the XML document stored in the memory (the DOM tree) is output in Step . In other embodiments (not shown), the output step  is omitted.","When the above XML document defined in Test.java of listing 1 is processed, first the start-tag of the foo tag is detected in Step . In Step  a foo taglet is created. Since no binding is defined for the tag name foo, the foo taglet is plain, i.e. the init and run methods bound to it do nothing. After the foo taglet has been added to the DOM tree in Step  and initialized in Step  (i.e. an \u201cempty\u201d init method is invoked), the cycle is finished and the next item in the input stream is parsed in Step . This next item is the hello tag, a child of the foo tag. The hello tag is an empty-element tag and is therefore considered as a start-tag followed by an end-tag. In Step , a hello taglet is created which means that the class TestTaglet is bound to the hello tag. In Step , the hello taglet is appended to the DOM tree and pushed. In Step , the hello taglet is initialized, which means that the init method of the class TestTaglet is invoked. As a result, the following string is output on the output device of the computer system (for example the screen):","TestTaglet.init( )","Then, since the empty-element tag hello is considered as a start-tag and a subsequent end-tag, in Step  the hello taglet is fetched and removed from the DOM tree. In Step  the method \u201cruns\u201d the hello taglet, which means that it invokes the run method of the class TestTaglet. As a result, the following string is written to the output device:","TestTaglet.run( )","Then, the next cycle starts in which, in Step , the end-tag of the foo tag is detected. In Step , the foo taglet is fetched and removed from the DOM tree. In Step  the run method of the foo tag is invoked, which, however, does nothing. Finally, as a result of Step , the stored DOM tree is output on the output-device:","<foo>\n\n","<\/foo>","It is clear from the above that the \u201cbehavior\u201d is generated immediately during the parsing of the input document. If, for example, in the exemplary input document a further tag followed the hello tag the behavior of the hello tag (namely the printout of the strings TestTaglet.init( ) and TestTaglet.run( )) would be generated before the parsing of the other taglet commences. It is even possible that the bindings are changed during the parsing process, for example by the init or run method of a previous taglet (in such embodiments, Step  lies within the loop, as it is indicated by a dashed Line in FIG. ).","In the following, several useful applications of the embodiments of  are described.  illustrates examples in which the above-described embodiments are used for transforming an XML input stream into a different output stream. A XML input document  is received, for example, together with a HTTP request over the Internet or it is an output from a database. The XBF engine  processes the XML input document  as described in the context of , using bindings  which define the mapping between tags in the XML input document  and classes (e.g. JAVA classes), which give \u201cbehavior\u201d to the tags. In one the examples depicted in , the \u201cbehavior\u201d is the translation of the XML input document  into a HTML output document . This translation process may be a one-to-one translation, only translating the XML representation into a HTML representation, without changing the information content of the input document . For example, the XBF engine  can be part of a web server which, upon a user's request, retrieves data from a database in the form of a XML document, processes this XML document (input document ) and outputs the HTML document  as a response to the user's request, which will be send over the Web and displayed on the user's browser. Another example depicted in  is the transformation of the XML input document  into an e-commerce language document . The e-commerce language may be, for example, a special language as used by e-commerce or enterprise resource planning (ERP) applications, like BroadVision, ColdFusion, SAP. According to still another embodiment depicted in , the XML input document  is transformed into an XML output document . The XML output document  is not the output stream  shown in  or the XML document output in Step  of  since these outputs are a \u201cmirror\u201d of the XML input document. Rather, in the embodiment example, illustrated in  the \u201cbehavior\u201d defined by the bindings  is a modification of the XML input document. For example, the XBF engine  processes an input document  retrieved from a database into a XML output document which represents only part of the input information (i.e. the processing performs a filtering), but represents additional, for example display-related, information so that the output document  can be displayed on a browser, like a HTML document.",{"@attributes":{"id":"p-0218","num":"0369"},"figref":["FIG. 8","FIG. 8"],"b":["65","64","60","61","12","60","61","62","63","64","65","62","64","65","62","63","62","63","13","12","12","62","63","64","65","63","62","60","61"]},"Whereas  show examples for transforming an XML input into a different output or to transform one interface into another,  illustrates how XML in connection with the method described in connection with  is used as an application modeling language. XML tags and software objects (e.g. JAVA classes ) which are bound by bindings  to the XML tags trigger processes, for example, access databases or CORBA servers , produce printouts or dispatch facsimiles or e-mails . When the XBF engine  processes the input XML document  and parses a tag, the JAVA class  bound to it as the tag is parsed. As a result, the invoked JAVA class accesses the databases or CORBA servers , or produces printouts or dispatches e-mails . In addition, a transformation process as described in  can be performed, for example, a HTML or XML output document may be generated (not shown in FIG. ).",{"@attributes":{"id":"p-0220","num":"0371"},"figref":"FIG. 10","b":["14","13","13","80","13","13","13"]},"Alternatively, in a system of chained XBF engines, the \u201cbehavior\u201d generated by a first engine may comprise a transformation of the XML input stream into a different XML output stream. Then, the second engine processes the transformed XML stream as its input stream. The differences in the input streams of the first and second engines generally cause a different behavior generated by them even if the bindings used by the second engine are identical with those used by the first engine. In addition, the bindings of the two engines can be different. The output of a first engine can also be branched so that it forms the input for two \u201csecond\u201d engines. If the branching is not conditional, the two branches following the first engine work in parallel. If the branching is conditional (i.e. if it depends on whether a certain condition is fulfilled during the processing performed by the first engine) only one of the branches following the first engine is activated depending on the conditional result. The same effect can be achieved without branching if the bindings of the second (and further) engines are chosen dynamically depending on whether the condition has been fulfilled or not during the processing in the first engine.","In the embodiment of , an order is received in the form of an input XML document  by the Web server . The input document  is processed by a first XBF engine , which checks whether user data contained in the order are valid. This check is done by corresponding software objects (JAVA classes), which are bound to user data related tag names and are invoked as such tags are found during the parsing of the input XML document . (In order to keep  simple, the bindings and software objects used by the XBF engine and other XBF engines described below are not shown). The XBF engine consults a database  and compares whether the input user data are identical with valid user data stored in the database . Then, a conditional branching is performed: If the input user data are valid, the further process runs through a first branch , otherwise through a second branch  by selectively outputting the XML input stream  to the first XBF engine is of branch  or to the (only) XBF engine of branch . The first XBF engine of branch  decides whether the ordered item is in stock or not. In order to take this decision, the database  which stores also stock-related data is consulted. The XBF engine generates two XML output documents, one includes a list of that part of the ordered items which are on stock and the other one includes a list of that part of the ordered items which are not on stock. The first mentioned output document forms the input for a subsequent XBF engine which generates a picking list and initiates the corresponding picking process (this process and other processes in  are generally depicted by boxes ). The other output document of XBF engine forms the input for XBF engine which requests a back order of the corresponding items. The XML outputs of both XBF engines and are input to XBF engine which initiates the payment (i.e. by debiting the customer's credit card) and the dispatch of the ordered items. The next XBF engine prepares an XML output document. For example, this output document is a confirmation for the customer that his order has been processed. The other branch  for invalid user data has only one XBF engine which also prepares an XML output document. This XML output contains information for the customers that his customer data are invalid. Finally, both branches  and  are fed together into the last XBF engine which transforms the respective XML output document into an HTML output document and initiates that it is sent over the Web to the customer.",{"@attributes":{"id":"p-0223","num":"0374"},"figref":["FIG. 11","FIG. 11"],"b":["90","91","90","91","90","91","13","1","13","2","90","91","13","90","1","2","91"]},"Such a document is generated internally by the local computer , for example when a user puts in commands to the local computer, for instance to retrieve data from a database. The document is then input to the local XBF engine ., which processes only the local tag in the way described in connection with . The \u201ccontent \u201d bracketed by the remote tag (\u201ccontent \u201d) is, however, not executed locally. Rather, it is sent via SMTP to the remote computer  and is there processed by the remote XBF engine . in the way described in connection with . The result of the processing at the remote computer  (for example data retrieved from a remote database) is then sent to the local computer  and is output there, as if it were processed on the local computer . Therefore, the remote processing is transparent for the user; in other words, he does not become aware of the remote processing. Preferably, the result of the remote processing is also send via SMTP from the remote computer  to the local computer  in the form of an XML document. This response document generally contains only tags and data which represent what is to be output on the local computer's graphical user interface. Preferably, the input document received from the remote computer  is also processed by the local XBF engine .. The remote processing embodiment of  is advantageous when the processing or storage capabilities of the local computer  are limited, which is generally the case with mobile computers and the like.","Thus, a general purpose of the disclosed embodiments is to provide an improved method, computer system and computer program product for processing extensible markup language data streams.","All publications and existing systems mentioned in this specification are herein incorporated by reference.","Although certain methods, systems and products constructed in accordance with the teachings of the invention have been described herein, the scope of coverage of this patent is not limited thereto. On the contrary, this patent covers all embodiments of the teachings of the invention fairly falling within the scope of the appended claims either literally or under the doctrine of equivalents."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":["In the accompanying drawings:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
