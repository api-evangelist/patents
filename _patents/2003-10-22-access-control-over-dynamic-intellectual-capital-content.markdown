---
title: Access control over dynamic intellectual capital content
abstract: Methods, systems, and articles of manufacture consistent with the present invention provide for access control over dynamic intellectual capital content. A subscriber subscribes to a datatype, the datatype having a predetermined runtime property that restricts use of the datatype. The datatype is associated with a data referenced in the datatype and maintained separate from the datatype. The datatype is received responsive to the subscription. A determination is made whether the runtime properties are valid. If the runtime properties are valid, a determination is made whether a user of the subscriber has permission to access the data referenced in the datatype. If the user has permission to access the data, the user is provided access to the data.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07428756&OS=07428756&RS=07428756
owner: Sun Microsystems, Inc.
number: 07428756
owner_city: Palo Alto
owner_country: US
publication_date: 20031022
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application claims the benefit of the filing date and priority to the following patent application, which is incorporated herein by reference to the extent permitted by law:","U.S. Provisional Application Ser. No. 60\/469,767, entitled \u201cMETHODS AND SYSTEMS FOR INTELLECTUAL CAPITAL SHARING AND CONTROL\u201d, filed May 12, 2003.","Additionally, this application is related to the following U.S. patent applications, which are filed concurrently with this application, and which are incorporated herein by reference to the extent permitted by law:","Ser. No. 10\/691,075, entitled \u201cINTELLECTUAL CAPITAL SHARING\u201d;","Ser. No. 10\/691,098, entitled \u201cINTEGRATING INTELLECTUAL CAPITAL THROUGH ABSTRACTION\u201d;","Ser. No. 10\/690,869, entitled \u201cEVOLUTIONARY DEVELOPMENT OF INTELLECTUAL CAPITAL IN AN INTELLECTUAL CAPITAL MANAGEMENT SYSTEM\u201d;","Ser. No. 10\/691,097, entitled \u201cBUSINESS INTELLIGENCE USING INTELLECTUAL CAPITAL\u201d;","Ser. No. 10\/690,865, entitled \u201cINTEGRATING INTELLECTUAL CAPITAL INTO AN INTELLECTUAL CAPITAL MANAGEMENT SYSTEM\u201d;","Ser. No. 10\/691,039, entitled \u201cMETHODS AND SYSTEMS FOR PUBLISHING AND SUBSCRIBING TO INTELLECTUAL CAPITAL\u201d;","Ser. No. 10\/690,867, entitled \u201cA LOOSELY COUPLED INTELLECTUAL CAPITAL PROCESSING ENGINE\u201d;","Ser. No. 10\/691,279, entitled \u201cASYNCHRONOUS INTELLECTUAL CAPITAL QUERY SYSTEM\u201d;","Ser. No. 10\/690,870, entitled \u201cASSEMBLY OF BUSINESS PROCESS USING INTELLECTUAL CAPITAL PROCESSING\u201d;","Ser. No. 10\/690,870, entitled \u201cREGISTRATION AND CONTROL OF INTELLECTUAL CAPITAL\u201d; and","Ser. No. 10\/691,280, entitled \u201cENABLING ACTIVE INTELLECTUAL CAPITAL PROCESSING TO ENABLE DATA NEUTRALITY.\u201d","The present invention relates to servicing computer-based systems, and in particular, to a distributed message-oriented system to capture, share and manage structured and unstructured knowledge about serviced computer-based systems.","Corporations have made a significant shift toward increased globalization in the recent past. This is driven by many factors, from the need to be closer to global customers to workforce cost management. Communications technology has broken down many of the traditional barriers. As the corporations spread across the globe, they implement computer-based systems in each of their new locations. These systems typically require support by services organizations, which must accommodate for the growth of the corporations.","In the computer support services industry, knowledge is conventionally maintained by individual experts that are distributed globally in the service field. The geographically diverse experts use multiple information systems and a variety of analysis tools, making knowledge sharing very difficult.","The lifeblood of a services industry is the knowledge that it maintains. Support is offered on products based on the knowledge of the services engineers and the knowledge bases that support those services engineers. Knowledge is used to build training classes that are offered globally to customers to increase their effectiveness at operating their systems. Further, best practice architectures are built based on the knowledge and experience of architects and are offered as solutions to businesses.","The services industry has conventionally been a people intensive industry. As one would expect, the number of people required to service a technology is traditionally directly related to the complexity and market penetration of that technology. As technology complexity and product deployment has increased, as has the number of people employed by services organizations. In some industry examples, services organizations have outgrown the size of product development groups in the same technology corporation. Research into these cases reveals highly labor-intensive process-driven businesses with little direct implementation of technology to support the process.","Collecting and automating knowledge, such as by using decision trees, is not a new technology. In the 1980s, research was put into this by the expert system community. The focus of the research was on how the experts could be encouraged to divulge their knowledge into a computer system, and more importantly on how the knowledge could be refreshed and maintained. Experts, such as services engineers, are generally business critical and have not typically had the time to impart their knowledge. Even if they were allowed to do so, it was difficult to justify the ongoing knowledge refresh that the support system required. Additionally, under those conditions, the experts did not typically engage with the knowledge capture process.","The effect of automating knowledge of a subject matter expert had a direct and clear value to a business. This led to the growth of a cottage industry of software tools makers in the services industry. The vast majority of those tools were created in the spare time of the services engineers (the expert) with the subject matter expertise, and their requirements were usually founded in personal experience of repeated problems or customer concerns. This process grew and evolved through the 1990s as the services industry's tools space became globalized.","Much of the above issues apply to structured knowledge, but unstructured knowledge faces similar problems. Unstructured knowledge is conventionally gathered globally as documents into repositories. The large centralized repositories typically have little knowledgeable connections between their various documents and there is typically no concept of aging for the data. Efforts have been focused on creating meta data standards for documentation, which has improved some of the knowledge, however there is currently no single meta data standard for much of the knowledge.","Knowledge management is a technology that has held promise for many years now, often seen as a method of productivity increase based on the ability to capture knowledge for multi-purpose reuse. The services industry has segmented the knowledge management technology into structured and unstructured management systems. Structured knowledge systems focus on the application of well formatted data to problems or opportunities, while unstructured management systems focus on applications and creation of meta data systems and building or associating ontologies with them. Conventional knowledge management technologies, however, still suffer from the above-described problems.","Methods, systems, and articles of manufacture consistent with the present invention provide for the distributed data-centric capture, sharing and managing of intellectual capital. For purposes of this disclosure, \u201cintellectual capital\u201d refers to a subset of knowledge that is useful and valuable to a services organization for servicing computer-based systems. The terms intellectual capital, knowledge, and data are used interchangeably for purposes of this disclosure. A distributed system enables the sharing of structured and unstructured knowledge using a publish and subscribe pattern. An evolving ontology of knowledge types is maintained within the system and the storage of the knowledge that flows through the system is implicit and maintained according to a defined time of relevance for each knowledge type.","The knowledge is published and subscribed to over the Internet. Therefore, a services engineer who is at a customer site anywhere in the world can publish newly acquired knowledge provided that they have Internet access. The system associates the data with a datatype that has a format that is readable by other users of the system, then shares the datatype with relevant subscribers on the system. Upon receiving the datatype, the subscribers can also access the data, which is maintained separately from the datatype. Thus, newly acquired knowledge is almost instantaneously and asynchronously received by other services engineers, who may be confronted with an issue that requires the newly acquired knowledge.","In accordance with methods consistent with the present invention, a method in a data processing system having a program is provided. The method comprises the steps of: a subscriber subscribing to a datatype, the datatype having a predetermined runtime property that restricts use of the datatype, the datatype being associated with a data referenced in the datatype and maintained separate from the datatype; receiving the datatype responsive to the subscription; determining whether the runtime properties are valid; if the runtime properties are valid, determining whether a user of the subscriber has permission to access the data referenced in the datatype; and if the user has permission to access the data, providing the user access to the data.","In accordance with articles of manufacture consistent with the present invention, a computer-readable medium containing instructions that cause a program in a data processing medium to perform a method is provided. The method comprises the steps of: a subscriber subscribing to a datatype, the datatype having a predetermined runtime property that restricts use of the datatype, the datatype being associated with a data referenced in the datatype and maintained separate from the datatype; receiving the datatype responsive to the subscription; determining whether the runtime properties are valid; if the runtime properties are valid, determining whether a user of the subscriber has permission to access the data referenced in the datatype; and if the user has permission to access the data, providing the user access to the data.","In accordance with systems consistent with the present invention, a data processing system is provided. The data processing system comprises: a memory having a program that subscribes a subscriber to a datatype, the datatype having a predetermined runtime property that restricts use of the datatype, the datatype being associated with a data referenced in the datatype and maintained separate from the datatype, receiving the datatype responsive to the subscription, determines whether the runtime properties are valid, determines whether a user of the subscriber has permission to access the data referenced in the datatype if the runtime properties are valid, and provides the user access to the data if the user has permission to access the data; and a processing unit that runs the program.","In accordance with systems consistent with the present invention, a data processing system is provide. The data processing system comprises: means for subscribing a subscriber to a datatype, the datatype having a predetermined runtime property that restricts use of the datatype, the datatype being associated with a data referenced in the datatype and maintained separate from the datatype; means for receiving the datatype responsive to the subscription; means for determining whether the runtime properties are valid; means for determining whether a user of the subscriber has permission to access the data referenced in the datatype if the runtime properties are valid; and means for providing the user access to the data if the user has permission to access the data.","Other systems, methods, features, and advantages of the invention will become apparent to one with skill in the art upon examination of the following figures and detailed description. It is intended that all such additional systems, methods, features, and advantages be included within this description, be within the scope of the invention, and be protected by the accompanying drawings.","Reference will now be made in detail to an implementation consistent with the present invention as illustrated in the accompanying drawings. Wherever possible, the same reference numbers will be used throughout the drawings and the following description to refer to the same or like parts.","Methods, systems, and articles of manufacture consistent with the present invention provide for the distributed data-centric capture, sharing and managing of intellectual capital. A distributed services system (\u201cthe system\u201d) enables the sharing of structured and unstructured knowledge using a publish and subscribe pattern. An evolving ontology of knowledge datatypes is registered and maintained within the system and the storage of the knowledge that flows through the system is implicit and maintained according to a defined time of relevance for each knowledge type. The knowledge is asynchronously published and subscribed to over a network, such as the Internet, and also allows synchronous controlled access to requested knowledge.","As will be described in more detail below, the system treats both structured and unstructured knowledge as artifacts. The knowledge data is associated with meta data that is in a format that can be recognized by any functional block of the system. Thus, the knowledge data itself does not have to be in a globally recognizable format. A description of each meta data is registered within its knowledge ontology. Relationships between the meta data are explicitly set within the ontology to provide deterministic joining of the knowledge instances. Over time, more information can be driven into the meta data, so that knowledge processors know less and less about the original format of the knowledge.","The system can evolve its ontology to adopt new knowledge or remove no longer applicable knowledge. It provides a method for evolving knowledge and data from a less structured model to a highly structured model, while insulating tools and knowledge processors from the same change timeline. The system also tracks the use of the datatypes and tools under its control, providing business intelligence focused on which tools are important and what knowledge is key to the success of the business. This provides an indicator for focused evolution of the toolset toward the core business requirements. The datatype lifecycle is managed within the system using a time of relevance concept. A time is associated with each datatype that describes for how long this datatype is considered relevant, from its time of creation\/collection. A storage system uses this time relevance when tools\/knowledge processors query for information or request multiple subscriptions for datatypes. A garbage collection function uses this to remove aged data within the storage devices.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 1","b":["100","100","110","112","224","110","234","236","238","110","236","116","118","120","140","114"]},"Additional devices can also be connected to the network as part of the system. In the depicted example, a legacy storage system , which has a legacy data storage device , is connected to the network. The system can access intellectual capital and data stored on the legacy storage system. Intellectual capital data is also stored on a file server  connected to the network. File server  includes a file manager program  and a file storage . Each of these components of the system will be described in more detail below.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 2","b":["110","110","202","204","206","208","210"]},"Memory  comprises a number of functional modules that administer, register, store, and distribute the intellectual capital and data, including: a registration block , bus manager , a storage controller , a common services block , a transformer block , a presenter block , an external data input manager , a message broker cluster , a virtual database , a registry , a message queue relational database management system (RDBMS) , a properties RDBMS , and a client module . As will be described in more detail below, there may be multiple instances of some of these modules on the system, such as multiple client modules and storage controllers. Some of these functional modules will be described briefly immediately below and then each will be described in more detail further down in the description. One of skill in the art will appreciate that each functional modules can itself be a stand-alone program and can reside in memory on a data processing other than the services system. The functional modules may comprise or may be included in one or more code sections containing instructions for performing their respective operations. While the functional modules are described as being implemented as software, the present implementation may be implemented as a combination of hardware and software or hardware alone. Also, one having skill in the art will appreciate that the functional modules may comprise or may be included in a data processing device, which may be a client or a server, communicating with services system .","The system maintains data with associated datatypes, which are classes. A datatype contains metadata about the data and the body of the data itself. The metadata describes the data and is implemented in the properties of a message envelope that is used to transmit the datatype through the messaging system. The message can either contain the body of the data or a reference, such as a pointer, to the data. Therefore, clients of the system, such as processing engines, do not have to understand the body of the data itself, they at a minimum need to understand the metadata. Accordingly, clients are able to share and process datatypes even if the body of the data is in an unfamiliar format, such as legacy data. Over time, the body of the data can be manipulated into a standard format or moved into the metadata, leaving a null body. Thus, the data can evolve into a standard format that is recognizable by clients of the system.","The system abstracts the data, as described above, and registers the datatype and any clients that consumer\/produce data. Once the registration is complete, the data can be tracked from initial entry into the system, including who uses the data, what additional data is generated from it, and what data is used to solve customer problems. Given this information, the metrics of the business can be accurately measured.","Registration block  controls a Lightweight Directory Access Protocol (LDAP) registry  that stores known datatypes, datatype keys, clients, and users within the system. The datatypes have information associated with them, such as how they should be stored, what storage controller they should be sent to, the priority of the data to the system, the version of the datatype, and envelope data that is added in to incoming data instances. The registry is updated and maintained by an administrator, who acts through an interface of the web server .","Bus manager  controls the publishing and subscribing of messages. Bus manager  can be any publish\/subscribe messaging program suitable for use with methods and systems consistent with the present invention. In the illustrative example, bus manager  is built around a multi-broker implementation of the Sun\u00ae ONE Messaging Queue (S1MQ) implementation of the Java\u00ae Messaging System (JMS). Part of the act of registering a new datatype with the registry is to create a new topic for that datatype within the system. The system carries references (pass by reference) to data that is stored by the storage controllers. Thus, messages passed through the system do not carry the data itself, but instead have a meta data that is in a neutral format that is readable by subscribers. Accordingly, the data itself does not have to be converted to a universally readable format, unless that is desired.","Storage controller  can be implemented as one or more legacy storage controllers, core storage controllers, and temporary storage controllers . Legacy storage controller  provides a transparent interaction with existing repositories. Existing repositories are registered with the legacy storage controller to describe what datatypes are supported and how they can be saved. Core storage controller  and temporary storage controller  are similar in that they store datatypes that are newly registered with the system. The core storage controller manages the storing, retrieving and querying of documents that contain intellectual capital and data that are stored in a virtualized database . The temporary storage controller maintains the storage of data that has been flagged in the datatype registry as temporary. This can apply, for example, to external data that is to be parsed by the transformer block, or interim transformer data that may be persisted for transactional recovery purposes.","Common services block  provides for incorporating functionality that is common to consumers\/producers of data and intellectual capital within the system. For example, the common services block manages the lifecycle of data and intellectual capital.","Transformer block , presenter block  and external data input manager  are registered as clients on the system. These clients are loosely coupled processing engines that asynchronously receive data, processes it, and possibly publish it. Transformer block  takes data to which it has subscribed, applies a transformation onto the data into one or more output datatypes, and publishes the datatype. Presenter block  queries data from storage and present it to a user. External data input manager  formats incoming external data into a format that the system can understand and publish it onto the system. This involves associating the incoming data with a known datatype and applying an envelope to the particular instance of the data. There can be a plurality of transformer block and presenter block instances, each configured to process one or more datatypes.","Each of the above-described functional blocks will be described in more detail below.","Although aspects of methods, systems, and articles of manufacture consistent with the present invention are depicted as being stored in memory, one having skill in the art will appreciate that these aspects may be stored on or read from other computer-readable media, such as secondary storage devices, like hard disks, floppy disks, and CD-ROM; a carrier wave received from a network such as the Internet; or other forms of ROM or RAM either currently known or later developed. Further, although specific components of the data processing system  have been described, one skilled in the art will appreciate that a data processing system suitable for use with methods, systems, and articles of manufacture consistent with the present invention may contain additional or different components.","One having skill in the art will appreciate that the services system  can itself also be implemented as a client-server data processing system. In that case, the functional modules can be stored on the services system as a client, while some or all of the steps of the processing of the functional blocks described below can be carried out on a remote server, which is accessed by the server over the network. The remote server can comprise components similar to those described above with respect to the server, such as a CPU, an I\/O, a memory, a secondary storage, and a display device.","Customer systems ,  and  comprise similar components to those of the services system, such as a CPU, a memory, an I\/O device, a display device, and a secondary storage. Each customer system comprises a browser program  in memory for interfacing to the system.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 3","b":["240","302","304","306","308","310","114","312","314"]},"Clients of the system (e.g., transformer blocks) are also registered. Each registered client is provided a unique textual tag at registration time as well as describing the datatypes the client will subscribe to and potentially publish. The registration block outputs a password that is embedded into the client functional component and provided during its initial connect phase. One having skill in the art will appreciate that other identifiers can be used besides passwords, such as SSL certificates.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 4","ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["User management . This functional block manages the access rights to the registration administration website. It allows users to be added, deleted, and updated on the system.","Datatype management . This functional block manages the creation, modification, and deletion of datatypes. It also provides a user with a view into any illegal datatype accesses that may have happened.","Datatype key management . This functional block provides a method for declaring keys that are associated with datatypes. The datatype keys provide a declarative method for storing relationships between datatypes that will support runtime linking of data.","Client management . This functional block manages the creation, modification, and deletion of clients and generates passwords for new clients being registered with the system. It also provides a user with a view into any illegal client accesses that have been rejected by the system.","Dependency mapping . This functional block provides relationships between registered datatypes, datatype keys, and clients that use the datatypes. Dependency mapping can assist a user to understand the effects of client data interface modifications or deletions."]}}}},"The registration manager also manages certain control attributes of the system. The following are managed, with the lists  stored, for example, in the secondary storage:\n\n","The registration manager does not provide enforcement logic based on runtime queries by the clients. For example, a transformer client that wishes to publish an invalid datatype is not denied by the registration manager. Instead, the control is maintained by the client module, which interprets information that is returned from the registration manager. The client module interfaces with the registration manager through an object abstraction of the LDAP schema provided by the registration manager.","There are four exemplary types of users of the system:","1. Users who want to introduce new or modify existing external datatypes with the system.","2. Users who want to register new or modify existing clients with the system.","3. Users who want to register new datatype keys with the system.","4. Administrators of the registry.","In addition, the client module provides the following functionality, which requires communication with the registration manager:\n\n","To register a client, the datatypes that the client uses (i.e., subscribes to or publishes) are first registered with the system through the datatype registration. To register a datatype, the datatype keys that the datatype requires are initially defined.",{"@attributes":{"id":"p-0090","num":"0105"},"figref":"FIG. 5","b":"502"},"Then, the registration manager receives a user input to perform datatype key administration (step ). The registration manager determines whether the user wants to register a new datatype key (step ). Datatype keys are singleton keys that are defined within the system to join different datatypes at runtime using a same definition. For example, \u201chostid\u201d could be defined as a datatype key within the system and the runtime properties of a particular datatype would use this key within its definition. In the process of defining a datatype, the datatype keys are registered within the system prior to the registration of the datatype that requires that key. Therefore, the datatype keys provide seamless datatype instance joins within the system. The client module also uses the datatype keys during its join operations.","For example, in a case a services engineer is installing a new customer system, the engineer obtains, through a subscription, a datatype associated with a data comprising a list of known good installation configurations. The datatype's metadata keys join related datatypes that provide additional knowledge, such as information on why the installation configurations are considered good. These related datatypes are also received through the subscription. Accordingly, the metadata of active data and passive data can be linked, for example so that a subscriber can analyze both types of data.","Table 1 below shows illustrative values associated with a datatype key name.",{"@attributes":{"id":"p-0094","num":"0109"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Datatype key id","An identification that is used within the"]},{"entry":[{},{},"datatype definitions to refer to the key"]},{"entry":[{},"Datatype key name","A name that identifies the key"]},{"entry":[{},"Datatype key type","The type of the datatype (e.g., string,"]},{"entry":[{},{},"integer, date)"]},{"entry":[{},"Datatype key value","A runtime instance filed value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"Illustrative examples of datatype keys are keys that identify host ID, host name, originating time, operating system version, and architecture.","If the registration manager determines in step  that the user wants to register a new datatype key, then the registration manager prompts the user to enter the information for the new datatype key (step ). In the illustrative example, the registration manager receives information for the datatype key id, the datatype key name, and the datatype key type.","If the registration manager determines in step  that the user does not want to register a new datatype key, but instead wants to modify an existing datatype key (step ), then the registration manager presents to the user a list of predefined datatype keys (step ). The user selects the desired datatype key and provides the modified information for the datatype key.","Then, the registration manager checks that the new or modified datatype key is valid (step ). To do this, the registration manager determines whether the datatype key information is complete and the datatype key name is unique. The registration manager then commits the datatype key to the registry (step ).",{"@attributes":{"id":"p-0099","num":"0114"},"figref":"FIG. 6"},"1. Registration time properties. These name\/value field are filled in at the time of datatype registration. They include class fields, which describe fields which are common to the datatypes, and instance fields, which are a variable length of name\/value fields specific to the datatype being registered.","2. Runtime properties. These properties are name\/value fields that are set at runtime and specific to the data contained within the datatype instance. They also include class fields and instance fields. The difference between the runtime properties and the registration time properties is that the name of the name-value pair is set at registration time, while the value is set at runtime by a system client.","In , first the registration manager receives a user input to log onto the registration administration website (step ). If the user is not successfully authenticated, then the user is denied access. Otherwise, the user is permitted access to the website. Then, the registration manager receives a user input to perform datatype administration (step ).","The registration manager then determines whether the user wants to register a new datatype (step ). If the user want to register a new datatype as determined in step , then the registration manager prompts the user to enter the registration time properties for the new datatype (step ). Table 2 below shows sample registration time properties that are entered in the illustrative example. As can be appreciated, some of the illustrative registration time properties are optional and different properties can be used.",{"@attributes":{"id":"p-0104","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Property","Property",{},{}]},{"entry":["Name","Description","Type","Generated By"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Datatype","ID that is used to","Integer","Registration"]},{"entry":["ID","reference datatypes","(unique)","manager"]},{"entry":[{},"to clients"]},{"entry":["Name","Unique name supplied","String","User"]},{"entry":[{},"by user who registers"]},{"entry":[{},"the datatype. The"]},{"entry":[{},"datatype name and"]},{"entry":[{},"the version provide"]},{"entry":[{},"a combined unique"]},{"entry":[{},"key. This is"]},{"entry":[{},"different than the"]},{"entry":[{},"datatype key, which"]},{"entry":[{},"relates to the"]},{"entry":[{},"instance, this is"]},{"entry":[{},"to recognize the"]},{"entry":[{},"datatype itself."]},{"entry":["Version","The version of the","Integer","User"]},{"entry":[{},"datatype. There may"]},{"entry":[{},"be multiple version"]},{"entry":[{},"of the datatype on"]},{"entry":[{},"the system."]},{"entry":["Description","Textual description","String","User"]},{"entry":[{},"of"]},{"entry":[{},"the datatype"]},{"entry":["Creation","Date and time of","Date","Registration"]},{"entry":["time","datatype creation",{},"manager"]},{"entry":["Created by","User that created","User","Registration"]},{"entry":[{},"the datatype","administration","manager"]},{"entry":["Last","Date and time","Date","Registration"]},{"entry":["modified","of datatype last",{},"manager"]},{"entry":[{},"modification"]},{"entry":["Last","User that last","User","Registration"]},{"entry":["modified","modified the","administration","manager"]},{"entry":["by","datatype"]},{"entry":["Average","Estimated average","Integer","User"]},{"entry":["size","size of the data-"]},{"entry":[{},"type. This is used"]},{"entry":[{},"by the storage"]},{"entry":[{},"controllers to"]},{"entry":[{},"optimize storage"]},{"entry":[{},"capacity."]},{"entry":["Maximum","Estimated maximum","Integer","User"]},{"entry":["size","size of the"]},{"entry":[{},"datatype."]},{"entry":["Priority","A subjective measure","Integer","User"]},{"entry":[{},"of the relative","(e.g., 1"]},{"entry":[{},"priority of this","highest"]},{"entry":[{},"datatype to the","priority,"]},{"entry":[{},"system\/business.","5 lowest"]},{"entry":[{},{},"priority)"]},{"entry":["Storage","A measure of the","Integer","User"]},{"entry":["access","storage access","(e.g., 1"]},{"entry":["model","model for this","highest"]},{"entry":[{},"datatype. A high","priority,"]},{"entry":[{},"priority indicates","5 lowest"]},{"entry":[{},"that the datatype","priority)"]},{"entry":[{},"would be queried"]},{"entry":[{},"often, or require"]},{"entry":[{},"rapid retrieval."]},{"entry":[{},"A low priority"]},{"entry":[{},"indicates an access"]},{"entry":[{},"model that is"]},{"entry":[{},"retrieved and"]},{"entry":[{},"not queried."]},{"entry":["Storage","A string that","String","Registration"]},{"entry":["properties","references the",{},"manager"]},{"entry":["RDBMS","properties RDBMS"]},{"entry":[{},"selected for the"]},{"entry":[{},"datatype. This is"]},{"entry":[{},"inserted by the"]},{"entry":[{},"registration"]},{"entry":[{},"manager using a"]},{"entry":[{},"resource allocator."]},{"entry":["Storage file","A string that","String","Registration"]},{"entry":["server","references the",{},"manager"]},{"entry":[{},"fileserver selected"]},{"entry":[{},"for the datatype"]},{"entry":[{},"This is inserted by"]},{"entry":[{},"the registration"]},{"entry":[{},"manager using the"]},{"entry":[{},"resource allocator"]},{"entry":["Storage","Identifies the","Boolean","User"]},{"entry":["controller","legacy storage"]},{"entry":["type","controller or core"]},{"entry":[{},"storage controller."]},{"entry":["Storage","Temporary or","Boolean","User"]},{"entry":["type","persistent. A"]},{"entry":[{},"datatype marked"]},{"entry":[{},"as temporary has"]},{"entry":[{},"each instance"]},{"entry":[{},"deleted from the"]},{"entry":[{},"database once the"]},{"entry":[{},"instance has been"]},{"entry":[{},"delivered each of"]},{"entry":[{},"its subscribers."]},{"entry":[{},"A datatype marked"]},{"entry":[{},"as persistent is"]},{"entry":[{},"not automatically"]},{"entry":[{},"deleted."]},{"entry":["Message","The message topic","String","Registration"]},{"entry":["topic","associated with",{},"manager"]},{"entry":[{},"this datatype."]},{"entry":[{},"The message topic"]},{"entry":[{},"is created when"]},{"entry":[{},"the datatype is"]},{"entry":[{},"first created by"]},{"entry":[{},"the registration"]},{"entry":[{},"manager."]},{"entry":["JMS server","The message server","String","Registration"]},{"entry":[{},"is selected by the",{},"manager"]},{"entry":[{},"system based on"]},{"entry":[{},"internal policy"]},{"entry":[{},"controlled by the"]},{"entry":[{},"resource allocator."]},{"entry":["Time","This is a subjective","Integer","User"]},{"entry":["relevance","time measurement"]},{"entry":[{},"measured, for"]},{"entry":[{},"example, in minutes"]},{"entry":[{},"that indicates an"]},{"entry":[{},"expected relevance"]},{"entry":[{},"or lifetime of an"]},{"entry":[{},"instance of the"]},{"entry":[{},"datatype. For"]},{"entry":[{},"example, if the"]},{"entry":[{},"time relevance is"]},{"entry":[{},"set to 1440 (24"]},{"entry":[{},"hours) and the"]},{"entry":[{},"data was 48 hours"]},{"entry":[{},"old, this instance"]},{"entry":[{},"of the datatype"]},{"entry":[{},"would be considered"]},{"entry":[{},"to be invalid by"]},{"entry":[{},"the transformers"]},{"entry":[{},"who are interested"]},{"entry":[{},"in the time"]},{"entry":[{},"relevance."]},{"entry":["Status","This is a system","Integer","Registration"]},{"entry":[{},"controlled variable",{},"manager"]},{"entry":[{},"that is set to either"]},{"entry":[{},"VALID or INVALID."]},{"entry":[{},"A datatype is"]},{"entry":[{},"set to INVALID"]},{"entry":[{},"when its publishing"]},{"entry":[{},"client is set to"]},{"entry":[{},"INVALID. Any client"]},{"entry":[{},"that subscribes to"]},{"entry":[{},"an INVALID datatype"]},{"entry":[{},"is then set to"]},{"entry":[{},"INVALID. This is"]},{"entry":[{},"managed to ensure"]},{"entry":[{},"that the system"]},{"entry":[{},"integrity is main-"]},{"entry":[{},"tained."]},{"entry":["Body","A user may","String","Registration"]},{"entry":["description","alternatively",{},"manager"]},{"entry":[{},"place a link to a"]},{"entry":[{},"description that"]},{"entry":[{},"describes the body"]},{"entry":[{},"message."]},{"entry":["Intrinsic","The value of an","Integer","User"]},{"entry":["value","instance of this"]},{"entry":[{},"datatype to the"]},{"entry":[{},"business."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"As noted above, the datatypes also comprise runtime properties that are filled in at runtime. Table 3 below shows sample runtime properties that are entered for the illustrative example. As can be appreciated, the illustrative runtime properties can be different than those in the illustrative example.",{"@attributes":{"id":"p-0106","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 3"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Property",{}]},{"entry":[{},"Name","Property Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"key(s)","The key(s) for the instance of the datatype,"]},{"entry":[{},{},"such as hostid. This is selected from a list"]},{"entry":[{},{},"of available keys within the system."]},{"entry":[{},"Generated","The time, for example in GMT, that the data"]},{"entry":[{},"timestamp","was generated by a system client."]},{"entry":[{},"Created by","The system client that created the instance."]},{"entry":[{},{},"This is, for example, the reference ID."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The registration manager fills in the information provided by the user and also fills in the information provided by the registration manager as shown in Table 2. To enter the storage properties RDBMS field, the registration manager maintains a list of properties RDBMSs and chooses a properties RDBMS based on, for example, predetermined criteria, such as the closest properties RDBMS to the storage controller.","The resource manager chooses the storage file server, for example, based on load balancing among the file servers. Similarly, the JMS server is chosen based on a load balancing scheme. The message topic matches the datatype on a 1:1 basis.","If the registration manager determines in step  that the user does not want to register a new datatype, but instead wants to modify an existing datatype (step ), then the registration manager presents to the user a list of datatypes from the registry (step ). The user selects the desired datatype to modify and provides the modified information for the datatype.","Then, the registration manager checks whether the new or modified datatype is valid (step ). To do this, the registration manager determines whether the datatype information is complete and the datatype name is unique. The registration manager then commits the datatype to the registry (step ). To do so, the registration manager issues a request, such as an SQL request, to the properties RDBMS associated with the datatype to create or modify a table for the datatype in the properties database. Also, the registration manager issues a request, such as an S1MQ request, to the bus manager to create or modify the message topic associated with the datatype. And the registration manager issues a request to the file server manager to register the datatype.","If the registration manager determines that the user wants to delete a datatype (step ), then the registration manager deletes the datatype from the registry (step ). To do so, the registration manager issues a request, such as an SQL request, to the properties RDBMS associated with the datatype to delete a table for the datatype in the properties database. Also, the registration manager issues a request, such as an S1MQ request, to the bus manager to delete the message topic associated with the datatype. And the registration manager issues a request to the file server manager to deregister the datatype. Alternatively, the registration manager can keep the datatype in the registry, but mark the datatype as invalid by setting the datatype status field to INVALID.",{"@attributes":{"id":"p-0112","num":"0127"},"figref":"FIG. 7"},"The client's definition comprises a series of name\/value properties, which include mandatory properties and optional properties. Mandatory properties are fields that are filled in for registering clients. Optional properties are specific to the client and are used by the clients as a persistent store of operating parameters. Table 4 below shows mandatory properties that are entered in the illustrative example. As can be appreciated, some of the illustrative properties are optional and different properties can be used.",{"@attributes":{"id":"p-0114","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Property Name","Property Description","Type","Generated By"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Client ID","ID that is used to","Integer","Registration"]},{"entry":[{},"reference clients to","(unique)","manager"]},{"entry":[{},"datatypes"]},{"entry":["Name","Unique name","String","User"]},{"entry":[{},"supplied to the user"]},{"entry":[{},"who is registering"]},{"entry":[{},"the client. The"]},{"entry":[{},"Client Name and"]},{"entry":[{},"the Version provide"]},{"entry":[{},"a combined unique"]},{"entry":[{},"key. This name is"]},{"entry":[{},"used by the client"]},{"entry":[{},"module to perform"]},{"entry":[{},"a JMS client authen-"]},{"entry":[{},"tication."]},{"entry":["Client type","The user can choose","System","User"]},{"entry":[{},"from three main","controlled"]},{"entry":[{},"classifications of","choice"]},{"entry":[{},"client: transformer,"]},{"entry":[{},"presenter, and"]},{"entry":[{},"external data input"]},{"entry":[{},"manager. This selec-"]},{"entry":[{},"tion affects what"]},{"entry":[{},"operations the"]},{"entry":[{},"client can perform."]},{"entry":[{},"An external data"]},{"entry":[{},"input manager pub-"]},{"entry":[{},"lish data. A trans-"]},{"entry":[{},"former can publish,"]},{"entry":[{},"query and subscribe"]},{"entry":[{},"to data. A presenter"]},{"entry":[{},"can query and sub-"]},{"entry":[{},"scribe to data."]},{"entry":["Password","Stores the","String","Registration"]},{"entry":[{},"generated password",{},"manager"]},{"entry":[{},"for the client."]},{"entry":["Description","A textual descrip-","String","User"]},{"entry":[{},"tion of what the"]},{"entry":[{},"client does."]},{"entry":["Creation","Date and time of","Date","Registration"]},{"entry":["time","client creation.",{},"manager"]},{"entry":["Created by","User that created","User","Registration"]},{"entry":[{},"the client.","administration","manager"]},{"entry":[{},{},"implementation"]},{"entry":[{},{},"specific"]},{"entry":["Last","Date and time of","Date","Registration"]},{"entry":["modified","client last modifi-",{},"manager"]},{"entry":[{},"cation."]},{"entry":["Last","User that last","User","Registration"]},{"entry":["modified by","modified the client","administration","manager"]},{"entry":[{},{},"implementation"]},{"entry":[{},{},"specific"]},{"entry":["Status","This is a system","Integer","Registration"]},{"entry":[{},"controlled variable",{},"manager"]},{"entry":[{},"that is set to either"]},{"entry":[{},"VALID or INVALID."]},{"entry":[{},"A client becomes"]},{"entry":[{},"INVALID if any of"]},{"entry":[{},"the datatypes to"]},{"entry":[{},"which it subscribes"]},{"entry":[{},"are marked as in-"]},{"entry":[{},"valid. When this"]},{"entry":[{},"occurs, the re-"]},{"entry":[{},"gistration manager"]},{"entry":[{},"marks theclient as"]},{"entry":[{},"INVALID. According-"]},{"entry":[{},"ly, the integrity"]},{"entry":[{},"of the system is"]},{"entry":[{},"maintained when"]},{"entry":[{},"datatypes or"]},{"entry":[{},"clients are deleted."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"Table 5 below shows extended properties that are entered in the illustrative example. As can be appreciated, some of the illustrative properties are optional and different properties can be used.",{"@attributes":{"id":"p-0116","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Property","Property",{},{}]},{"entry":["Name","Description","Type","Generated By"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Datatypes","The datatypes this","Integer list","User"]},{"entry":["published","client publishes,","(reference to"]},{"entry":[{},"if the client","the datatype"]},{"entry":[{},"publishes datatypes.","IDs)"]},{"entry":["Datatypes","The datatypes this","Integer list","User"]},{"entry":["subscribed to","client subscribes","(reference to"]},{"entry":[{},"to, if the client","the datatype"]},{"entry":[{},"subscribes to","IDs)"]},{"entry":[{},"datatypes."]},{"entry":["Datatypes","A list of datatypes","Integer list","User"]},{"entry":["queried","the client queries,","(reference to"]},{"entry":[{},"if the client queries","the datatype"]},{"entry":[{},"for datatypes.","IDs)"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"In , the registration manager first receives a user input to log onto the registration administration website (step ). If the user is not successfully authenticated, then the user is denied access. Otherwise, the user is permitted access to the website. Then, the registration manager receives a user input to perform client administration (step ).","Then, the registration manager determines whether the user wants to register a new client (step ). If the user want to register a new client as determined in step , then the registration manager prompts the user to enter the mandatory and extended properties for the new client (step ). Illustrative mandatory and extended properties are identified above in Tables 4 and 5. As indicated above, the user enters subscribed to datatypes in the extended properties. These subscribed to datatypes include a primary subscription datatype and zero or more secondary subscription datatypes.","After the registration manager receives the client information from the user, the registration manager generates the registration manager generated fields, as shown in Table 4, including a password for the client (step ).","If the registration manager determines in step  that the user does not want to register a new client, but instead wants to modify an existing client (step ), then the registration manager presents to the user a list of clients from the registry (step ). The user selects the desired client to modify and provides the modified information for the client. In the illustrative example, the user cannot modify the client's primary subscription, but can modify its secondary subscriptions, publishing datatypes, and other information. To modify a client's primary subscription, a new client is registered with the system.","The registration manager then checks whether the new or modified client is valid (step ). To do this, the registration manager determines whether the client information is complete and the client name is unique. The registration manager then commits the client to the registry (step ).","If the registration manager determines that the user wants to delete a client (step ), then the registration manager deletes the client from the registry (step ). Alternatively, the registration manager can keep the client in the registry, but mark the client as invalid by setting the client status field to INVALID.","To assist a user or administrator with understanding the effects of modifications or deletions in a client data interface, the registration manager provides dependency mapping functionality. Dependency mapping maintains and displays relationships between registered datatypes, datatype keys, and clients that use the datatypes. The registration manager can present the following illustrative information to an administrator or user:\n\n","To display the dependency mapping information, the registration manager retrieves the relevant information from the registry.","After a datatype has been registered on the system by the registration manager, it can be published and subscribed to within a message. As noted above, the bus manager manages the publishing and subscription of messages.  depicts an illustrative functional block diagram of client interactions that occur for passing messages. In the illustrative example, a message broker cluster  comprises two message brokers  and . More message brokers can be added into a message broker cluster to provide vertical scalability on specific topics\/datatypes and additional clusters can be added to scale horizontally.","Persistent message queues are managed in the message queue RDBMS repository  using, for example, a Java Data Base Connectivity (JDBC) interface available through the message broker. The message queue repository is, for example, an Oracle repository, managed by a message queue RDBMS manager . Each message broker cluster has a message queue administration function that provides command line interaction and LDAP\/JDNI configuration through its directory services repository.","Clients, such as the transformers A and B shown in , can publish data for registered datatypes. Data that is published is in the form of a JMS publication to a specified topic maintained by a specific broker running in a broker cluster. The published data is maintained in a message queue in the message queue database until each of its subscribing clients acknowledge reception of the data, at which point it is deleted from the queue. Client subscriptions are durable. That is, the client uses its unique and persistent client ID to register its interest with a message broker that supports the target datatype (i.e., topic). This durable subscription is maintained in the message queue repository until it is deleted. As described above, the registration manager can request the creation, deletion, and updating of topics through a request, such as a JDNI request. Publish and subscribe messaging systems are known in the art and will not be described in further detail herein.","To accommodate for intellectual capital applications that enable improved business intelligence to the services organization and its customers, the applications are built upon system clients, such as transformers and presenters. The transformers and presenters act on data that is made available through the messaging system.  depicts a functional block diagram illustrating the relationships between intellectual capital applications and other functional blocks of the system. The interfaces between the blocks in  show relationships rather than programmatical interfaces.","As shown in , storage is seen as transparent to the intellectual capital applications. The system handles the storage of the datatypes that run through it, while the intellectual capital applications are not concerned with how the data is stored. Instead, the intellectual capital applications are concerned that the data is stored and can be retrieved\/queried. This relies on the data being well described, which is a function of the external data input modules . They take raw data and associate it with a known datatype that has been registered with the system. As shown in , data input may not be a feature of an intellectual capital application. Applications can be built on existing registered datatypes. Accordingly, this architecture segments functionally the data input components and depicts that they are separate from applications, even if the applications require new data.","Usage and tracking reporting provides a facility to track the usage of data and the activity of tools that use the data on the message bus. This enables profiles to be built on the data and the tools that are used by the services organization. Therefore, data-driven decisions can be made for future developments, and enhancements can be based on value to the business. Tracked usage information includes, for example, when a datatype or client is accessed, published and subscribed to, who publishes and subscribes to the datatype, and processing results of the clients, including what datatypes were used to arrive at the processing results.","A functional block diagram of the client module and associated clients is shown in . Although three types of clients are shown with a single client module, this is to illustrate that each of those client types can be associated with the client module. A different instance of the client module, however, is instantiated for each client. The client module has a client module Application Programming Interface (API) , which provides access to a developer to data and intellectual capital available on the system. The API is, for example, a Java\u00ae API.","The client module functional architecture shown in  illustrates the client module's outbound (to the client) functions. Each of these interactions is described below. Error handling within the client module is managed through a retry before informing client of the error.",{"@attributes":{"id":"p-0133","num":"0153"},"figref":"FIG. 11","b":"1102"},"Then, the client module downloads the client data interface (CDI) information from the registry (step ). After downloading the CDI information in step , the client module authenticates and initializes connection of the client to the messaging system, but does not enable subscription reception at this time (step ). The client name and password are used to provide a unique JMS subscription name to the messaging system. This ensures that future connections will pick up durable subscriptions that may be pending. The client module then retrieves the client's database connection information based on the CDI information (step ). This information includes, for example, database addresses, users and passwords.","The client module then authenticates and initializes connection of the client to the storage controllers that are required according to the CDI information (step ). Based on the CDI, the client module initializes connection to the legacy storage controller (step ), the core storage controller (step ), or the temporary storage controller (step ). Then, the client module delivers a reference to the CDI to the client for validation purposes (step ).","After a client is initialized, it can interact with other functional components of the system through message publication and subscription, using the client module as an interface. The client module manages the active connections between the client module and the system. In the illustrative embodiment, these connections take the form of JMS and JDNI connections. Connections are managed by the client module using an exception catching mechanism. Connection orientated exceptions are caught by the client module, which then triggers a standoff retry algorithm that attempts to reconnect to a problematic service.","Table 6 below shows illustrative settings for connection retry:",{"@attributes":{"id":"p-0138","num":"0158"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Illustrative settings for connection retry"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["JMS","Attempt","Retry","Retry","Retry"]},{"entry":["Publish\/","reconnect","after 60","after 120","after 240"]},{"entry":["Subscribe","immediately","seconds","seconds","seconds"]},{"entry":["JMS P2P","Attempt","Retry","Retry","Retry"]},{"entry":[{},"reconnect","after 30","after 60","after 120"]},{"entry":[{},"immediately","seconds","seconds","seconds"]},{"entry":["JDNI","Attempt","Retry","Retry","Retry"]},{"entry":[{},"reconnect","after 240","after 360","after 480"]},{"entry":[{},"immediately","seconds","seconds","seconds"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"These variables are exposed as properties and can be set by each client instance to reflect the client's requirements. The variables can also have minimum settings to prevent retry overload by the client.","Upon failure of the last reconnect, the client module throws an internal exception and disconnects connections and initiates closedown. Part of this closedown is to trigger a registered close connection callback in the client. A process of re-initiation or error logging is performed by the client that is communicating through the client module.","The client module also registers with the registration manager, for example through JDNI, to detect changes that may have been made to the active CDI of its client by the registration manager. To do so, the client module performs a callback with the registration manager to watch for modifications to the client and related datatypes in the registry. Then, the client module compares the CDI values with cached values that exist in the client module. If a change is detected and the version of the client has not changed, the client module closes down the active connections and triggers a client closedown connection callback, informing the client that an update to the CDI has occurred. Further, if the client module detects a change in the client's status to INVALID, the client module notifies the client of the error through a closedown connection callback and suspends processing and closes down connections. As described above, a client's status is set to INVALID by the registration manager when a related datatype is deleted or when the client is requested to be deleted. When an error occurs, it is up to the client to implement its predetermined policy responsive to this exception.","The client module also manages the subscriptions of its client. As will be described in more detail below, when data is received through subscription, the reception of data can trigger a client's processing engine. Thus, subscriptions enable the asynchronous reception of data that can trigger processing. Queries, however, provide a synchronous processing model. Queries are embedded in the client and are part of an information collection or ratification phase of the client. The client module supports both subscriptions and queries. When planning a client implementation, a developer should consider which data subscribed to and what data is queried. For example, if a data is subject to change, it may be desirable to subscribe to the data.","Subscriptions use local transactions, therefore, a client will finish processing incoming subscriptions before the message broker is informed that it can remove that client's lock on the message. To commit the transaction, the client issues a command to the client module. Additionally, the initialize subscription command is executed after all subscriptions are complete.","A client can subscribe to a single datatype or to multiple datatypes. The datatypes to which the client subscribes are defined in the client's registry entry.","As will be described below, data is transmitted through the system as a meta data envelope that references the data itself, which is maintained in storage. Envelope meta data is expressed to the messaging system in the form of message properties. An advantage of this is that the messaging system supports subscription by filters. Thus, a subscription command can be setup to subscribe to a datatype based on specific meta data values.","An illustrative example of a subscribe function is as follows:",{"@attributes":{"id":"p-0147","num":"0167"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"subscribe(datatype where datatype.metadataitem1 ="]},{"entry":[{},"xyz and datatype.metadataitem2"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"= abc ..... )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The subscribe command, does not issue the subscribe request, instead it fills in the profile with the client module. The actual subscriptions are performed when the subscribe initialization is executed by the client module. The client module validates the language semantics of the subscribe command by using the CDI to syntax validate the metadata fields.","The fact that the client module uses filtering on subscriptions is abstracted from the developer of the client. The developer of the client sets up search criteria as described above, which criteria can be used by both filtering and query. Therefore, the client developer is not required to discern the difference between a query being fulfilled by a filtered subscription and a query to the database.",{"@attributes":{"id":"p-0150","num":"0170"},"figref":"FIG. 12","b":["1202","1204","1206","1208","1210"]},"Once the client is able to subscribe to datatype, published datatype instances are received by the client module, verified, and passed on to the client.  depicts a flow diagram illustrating the exemplary steps performed by the client module for receiving datatype instances. The message server publishes a datatype instance, which is asynchronously received by the client module responsive to the client having identified the datatypes to which it subscribes (step ). Then, the client module checks the datatype instance to determine whether it meets the subscription criteria (step ). If it is determined that the datatype is verified (step ), then the client module delivers the datatype instance to the client (step ).","When a client subscribes to multiple datatypes, it is probable that the datatypes are relevant to each other because the client will require each of the datatypes for some processing. The system implements an implicit relevance of time by identifying a time relevance period within each datatype in the registry. That is, each of the instances of the datatypes that are provided by the client module to the client to fulfill the client data interface are within the time relevance period defined within the individual datatypes, unless specifically overridden in the subscription.","When implementing the above-identified restriction in the asynchronous system, it is possible that the system cannot guarantee the arrival time of any one datatype instance within its relevant time period. For example, the datatype may be delayed in its delivery to a subscribing client. In another example, a client that subscribes to two data types, may receive an instance of data type 1 at 12 a.m., and it may not receive an instance of data type 2 with the corresponding primary key until three days later. The instance of data type 2 may not be relevant to the instance of data type 1 at this time, accordingly instead the client would have operated satisfactorily by retrieving an instance of data type 2 from the registry that arrived thirty minutes beforehand.","When a client requests multiple subscriptions to different data types, the client module executes a method similar to when subscribing to one datatype, however the client module accommodates for the multiple subscriptions. When registering to subscribe to multiple datatype instances, the client additionally provides a subscription relevance definition and an error handler when matching relevant data cannot be found. The subscription relevance definition identifies the relationship between the different datatypes. As discussed above, time is implicit unless it is overridden in this definition. An example of a subscription-relevance definition is that the primary key contents of the datatype instances match. This relevance takes the form of a data join on the relevant subscriptions. Data joins are described in more detail below with reference to queries.","The client also provides an error handler when matching relevant data cannot be found. In the case where the client module cannot fulfill the request to find relevant matches for the subscribed data, it sends an error to the client with the relevant found data types, and identifies the missing data types. What the client does with this information is implementation specific to the client.","Multiple subscription requests requires additional syntax, compared to a single datatype subscription requests. The following is an example of a subscription to two datatypes:",{"@attributes":{"id":"p-0157","num":"0177"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"subscribe(datatype1 and datatype2 where"]},{"entry":[{},"join(datatype.metadataitem1 ="]},{"entry":[{},"datatype2.metadataitem1) and datatype1.metadataitem3 ="]},{"entry":[{},"xyz and datatype2.metadataitem2 ="]},{"entry":[{},"abc ..... )"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The above example shows an illustrative example of how multiple subscriptions can be implemented. Multiple subscriptions may use the join-specific command to match specific data instances. The illustrative join statement is listed within the statement to make it easier for the client module to unpack and parse the search criteria since it will be the client module that manages the join statement.","This illustrative subscription is implemented in a multi-phase manner.  is a flow diagram illustrating the exemplary steps performed by the client manager to fulfill the multiple subscription request. As shown, subscription filtering and data query are used to fulfill the request. In the illustrative example, the use of the join command in the syntax protects the facts from the command line parser that would be constructing filters for subscription.","After the client is set up to subscribe to multiple datatypes, published datatype instances are received by the client module, verified, and passed on to the client as described below with reference to .  depicts a flow diagram illustrating the exemplary steps performed by the client module for receiving datatype instances for multiple subscriptions. The message server publishes a datatype instance, which is asynchronously received by the client module responsive to the client having identified that datatype as one to which it subscribes (step ). Then, the client module checks the datatype instance to determine whether it meets the client's subscription criteria (step ). If it is determined that the datatype is verified in step , then the client module checks the client's subscription relevance information (step ). As described above, when the client wants to subscribe to multiple datatypes, the client provides the client manager with subscription relevance information.","If the client module determines that there are other datatypes that are relevant to the received datatype instance (step ), then the client module queries the client's designated storage controller for instances of the remaining relevant datatypes, using time relevance and the client's specified rules (step ). The remaining datatype instances that match the query criteria are then received from storage (step ). After the relevant datatypes are received in step  or if it was determined in step  that additional relevant datatypes are not required, then the client manager delivers the received datatype instance and other relevant datatype instances to the client (step ).","A client can also de-subscribe to a datatype, for example, by changing the client's designated datatype subscriptions in the registry. This may be done, for example, by an administrator or an intelligent client responsive to a change in the client's client data interface through a registration update.","After a client has successfully completed its processing of its subscription datatype instances, it notifies the client module. This tells the client module to notify the message server that the client has successfully processed the message. Accordingly, if a client fails during the middle of processing received data, the message broker will still indicate that the message was not delivered to the client. Therefore, the next time the client is started up, it will be able to re-receive the message and restart processing.","As noted above, the client can synchronously receive data by querying for data. This may be done, for example, to access historical data or additional information to help fulfill the client's processing requirements. The client module's data query capabilities are similar to its subscription capabilities, a difference being that subscriptions can initiate the execution path of a client where a data query is part of an already running execution path.","A client can query data types that are defined within its client data interface as queryable. The client module data query issues a command to the storage controller that is specified in the client's datatype definition. There can be implemented restrictions on what can be queried using the data query, as in the following illustrative restrictions:\n\n","The queries also use declared relationships and information that is controlled, thus providing query results that are accurate and predictable in their performance. The client module manages a transaction around the query to ensure that the collection of the data to fulfill the query is atomic. To do so, the client module may have to join on data that is from multiple storage controllers.","The query language can be any query language suitable for use with methods and systems consistent with the present invention. Query languages are known in the art and will not be described in more detail herein. In the illustrative embodiment, the query language is based on a version of Standard Query Language (SQL). The query language can manipulate and relevant data. This query language is used in the query and subscribe commands from the client; which uses elements of the query command in the subscribe command.","The query language operates on the metadata of the object, and preferably not the body of the object. Some sample query language statements include select statements, joining datatypes, and comparison operators. The select statement forms the basis of the data query. An illustrative example of a select statement is shown below, which example is SQL compliant:\n\nselect from datatype1 where metadata1=xyz and metadata2>6\n","Joining data types is another function of data query. In the following illustrative example, the join request is explicitly listed because the implementation of the datastore may be distributed. That is, one datatype may be stored on a different datastore to another.",{"@attributes":{"id":"p-0170","num":"0193"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"select from datatype1, datatype2 where"]},{"entry":[{},"join(datatype1.metadata3 ="]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"datatype2.metadata1) and datatype1.metadata1 > 6"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The query language can also support comparison operators, such as the following, which can apply for example to integer, string and date types:",{"@attributes":{"id":"p-0172","num":"0195"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"> Greater than"]},{"entry":[{},"< Less than"]},{"entry":[{},"= Equals"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The system provides for both an asynchronous and synchronous interface for data queries. The query interface to the storage controller is synchronous, but the client may not want to block processing while waiting on results. This depends on the architecture and function of the client.","A client can publish zero or more data types. Publishing a data type has a 1:1 correspondence with storage for the system. The publish requests executed by a client are similar to the publish request (e.g., JMS publish requests) that the client module issues to the message server. When publishing, the client module validates the content of the outgoing datatype instance against the datatype definitions that are cached in the client module upon client initialization. If they match, the client module publishes the envelope and the envelope and body are stored in the persistent store.","A publish command can publishes a single instance of a single data type. Therefore, a client makes a separate publish request for each data type instance that it wishes to publish to the message system. The body of the data is supplied through a file or network URL in the publish request. It is up to the client to determine how the data is stored prior to publishing, but the data is to be accessible for successful publication. If a client attempts to publish a piece of data that is a duplicate of data that has been already stored, the registry rejects the store, as the properties RDBMS that stores the meta data will fail to store it based on a multi-field unique key that spans the primary and secondary keys of the datatype envelope table. This unique key is described in the datatype at registration time, as discussed above.",{"@attributes":{"id":"p-0176","num":"0199"},"figref":"FIG. 16","b":["1602","1604","1606","1608"]},"If the save of the data fails, the storage controller sends the client an error code and the data is not published to the bus. Accordingly, duplicate data is neither stored, nor published. After the client publishes a message, the client module can then poll each subscriber to determine whether the subscribers receives the message. If the data is not received by the subscribers, indicating a failed publish, the data that was saved may be removed in the case of a failed publish.","The client can issue a close connection command to the client module, wherein the client module closes all of its JMS and JDNI connections and exits. Further, the client module can perform a client module close connection, wherein the client module calls a registered callback method within the client to initiate shutdown. This can occur, for example, when a fatal reconnect or datatype definition resynchronization has occurred. The client registers the callback with the client module and then the client exits.","The system has access to existing data and knowledge on which to base its logic and processing. As the system evolves, it integrates existing repositories and tools while converting them to native system storage if deemed necessary. The storage controller interacts with the client module to provide properties information from the properties database  and body data stored on the file server . There can be a plurality of properties databases and file servers. The storage controller  can be configured to include one or more of the legacy storage controller, the core storage controller, and the temporary storage controller. The legacy storage controller provides a base for querying knowledge and data that already exists. The core storage controller manages persistent data and provides a storage abstraction layer for storage of managed datatypes within the system. Persistent data is kept and archived according to a policy defined in the system. The temporary storage controller manages temporary data, which is data that is cleaned up according to a policy defined in the system. For example, the data can be persisted until each relevant client has processed it, at which point it is deleted. The storage controller manages both the properties and the body of the data.","The storage controller interacts with the client module and can interact with the client module in the manners shown in . As shown in , the storage controller can be in the same virtual memory as the client module, wherein interfacing between the storage controller and the client is via, for example, method call. Alternatively, as shown in , the client module and the storage controller can communicate over the network using, for example, the Hypertext Transfer Prototcol (HTTP). In the illustrative example, the storage controller uses JTA (java transactions), as the data that is required by clients of the storage controller can be sourced from two locations. In this case, transactions are wrapped around both database accesses. HTTP is a trademark of Massachusetts Institute of Technology, European Research Consortium for Informatics and Mathematics, and Keio University.","The storage controller can operate in three operating modes: local mode, remote mode, and legacy mode.  depicts a functional block diagram of the storage controller operating in local mode. And  depicts a functional block diagram of the storage controller operating in remote mode. Depending on whether the storage controller  is operating in local mode or remote mode, various functional components are illustrated. The storage controller interface  exposes an storage controller API to the client module. The local mode plug-in  interfaces with the JDBC interface  and HTTP interface  and manages the storage and delivery of data. The remote mode plug-in  encodes and decodes the requests from the storage controller interface into document form for HTTP transmission and reception. The remote server  is similar to the local mode plug-in in that it interfaces with the JDBC interface  and HTTP interface , and it encodes and decodes eXtensible Markup Language documents. The JDBC interface  manages the interface with the properties database . The HTTP interfaces ,  and  interface between the storage controller  and the file server , and between the storage controller  and the remote server . Each of these functional components will be described in more detail below.","In the local mode as shown in , the storage controller interface operates in the same process space as the logic that interacts with the databases. The advantage to this, is that the storage controller (and the client module implicitly) can take advantage of the features of JDBC such as connection pooling and transactional control to significantly increase performance. In the remote mode as shown in , a client-server relationship is created. The storage controller interface acts as an HTTP client communicating with the remote server, which is servlet based. The remote server contains similar JDBC and file server logic as the local mode plug-in. In the legacy mode, a legacy storage controller plug-in  is loaded that permits access to the legacy storage controller .","The mode in which the storage controller operates is defined at instantiation time. A client module could have multiple storage controllers loaded dependant on the needs of its CDI. For example, a CDI is loaded into the client module that involves the following data types:",{"@attributes":{"id":"p-0184","num":"0207"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Datatype 1:","RDBMS: db1","FileServer: FS1","Storage Type: Persistent"]},{"entry":["Datatype 2:","RDBMS: db2","FileServer: FS1","Storage Type: Persistent"]},{"entry":["Datatype 3:","RDBMS: db1","FileServer: FS1","Storage Type: Temporary"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Datatype 4:","LegacyStorageController: LSC1"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this illustrative example, the client module has a storage controller with a local mode plug-in for datatypes 1-3 and a legacy storage controller plug-in for datatype 4.","The storage controller is instantiated with an access model setting. This model matches READ\/WRITE, READ, WRITE based on the needs of the client module. An example of a storage controller instantiation is shown below:",{"@attributes":{"id":"p-0187","num":"0210"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"StorageController("]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"accessmodel (READ\/WRITE | READ | WRITE)"]},{"entry":[{},"server_list"]},{"entry":[{},")"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The access model can be derived from the CDI by the client module, based on what is subscribed (read), published (write) and queried (read). The relevant file servers depends on the CDI of the client and the mode of operation. A server list contains of a list of file servers where a server is, such as shown in the following illustrative example:","String servername","String rdbmsaddress","int number_of connections\u2014This is used in local mode to initiate more than one JDBC connection to a server","If the mode is local, the client module supplies to the storage controller a list of properties RDBMSs specified by the data types in its CDI. If the access model is set to read\/write or read, the storage controller selects the RDBMS with the fastest response time and allocates it as its primary properties RDBMS. Read functions that the storage controller undertakes will operate through this primary properties RDBMS. This provides predictable performance regardless of physical location on the network.","If the mode is remote, the client module supplies a list of file servers, which list is obtained from the registry. The storage controller then calculates which is the closest remote server based on network performance and uses this as its primary connection. If the mode is legacy, the client module supplies the legacy server address, obtainable from the registry. The server list is stored within the instantiated class for later use.",{"@attributes":{"id":"p-0191","num":"0214"},"figref":"FIG. 20","b":["2002","2004","2006","2008"]},"The storage controller interface exposes an API to the client module that does not have specific implementation objects within it. Therefore, the implementation of a RDBMS\/file database is abstracted from the client module such that the storage mechanisms could be changed if desired. The storage controller interface provides the following illustrative API methods, which are described in more detail below: initialize sessions, close sessions, get data, data query, and data store.","Initialization of the session is performed by the client module within the constructor of the appropriate storage controller, and varies according to the storage controller mode. In the local mode, the storage controller opens a JDBC connection to the primary properties RDBMS and to other properties RDBMSs identified in the server list. If the connection to the primary RDBMS fails, then another RDBMS is chosen and allocated as the working RDBMS. The local mode model makes use of connection pooling. These sessions are reused by the implicit connection pooling provided by JDBC 2.0. In the remote mode, the storage controller verifies the remote servers are responding to HTTP requests. And in the legacy mode, the storage controller verifies the legacy server is responding to HTTTP requests. Error conditions are handled through exceptions which are exposed by the initialize sessions command.","The close sessions command is used once the client module is exiting processing. It will attempt to close connections to all servers cleanly based on the list specified in the server list.","The get data command is used to retrieve message bodies from the file server given a URL list. The method works in two modes. In the first mode, the caller specifies a file directory in which to store the message bodies and receives a list of URLs that point to the message bodies in the specified directory. In the second mode, the message bodies are returned as documents allocated in virtual memory.","The data query command provides the ability for the caller to request the file body, the properties or both as a result of the query. The client module exposes these options to the client and uses some of these optional retrieval methods itself to fulfill join requests. As in the get data command, two types of message body retrieval are provided, file storage and in memory retrieval. The data query command uses the primary server address to issue queries against if the system is working in local mode. In remote or legacy mode, it uses the server specified at instantiation time. Joining data types is treated in two ways. If the data types are managed by the same storage controller, then joins can be expressed in the SQL string passed through the data query command by the client module. If a join is required across storage controllers, then the client module iterates the join request.","The data store command can save information to the repositories. Storage is done in two phases and transacted using JTA. The data store command is called for each instance of a datatype that needs to be stored. The properties of the datatype are interrogated for RDBMS server name and other storage hints associated with the data type. The actions depend on the mode in which the storage controller is operating. In local mode, the properties are stored to the RDBMS, upon successful storage, the body is sent to the file server along with the appropriate storage hints, specified at registration. In remote mode, an eXtensible Markup Language (XML) document is constructed and sent to the remote server. XML is a trademark of Massachusetts Institute of Technology.","In the command descriptions above, there is described that the message body can be delivered in memory or as a file. When the message body is delivered in memory, the message body is instantiated in memory and a reference to the object is passed through the system. When the message body is delivered as a file, the message body is stored as a file in a file system local to the storage controller interface. A reference is passed to the file as part of the method signature.","The local mode module effectively acts as a container to the JDBC interface the properties database and the HTTP interface to the file server. It also manages a local file system  where message bodies can be temporarily stored in a declared working space. The local mode module provides transactional control for data store requests to ensure that both the properties and body are stored or any faults that are detected cause rollback. A command parser of the local mode module interprets method calls from the storage controller interface and converts them into JDBC requests required for property manipulation and\/or file server requests to retrieve the message bodies from the file server. The command parser manages the execution path and ensures that the JDBC requests are managed and executed appropriately. JDBC exceptions are returned as is to the storage controller interface, which in turn forwards them on to the client. To facilitate JDBC command construction, each data type name directly maps onto the table name in the properties name and each field in the table maps onto the meta data name described during restriction. The HTTP interface performs a post or a get dependant on the direction of the data request. If required, the HTTP interface uses an internal file manager on the command switch. If the user has requested that the information is available in a file or wishes it to be stored in a directory space, the local mode module file manager supports this by managing space available in the specified directory. The HTTP interface can also support multiple file servers.","As described above, the remote mode module interfaces with storage controller interface. It converts the method calls of the storage controller interface into XML constructs and sends a point to point message using HTTP to the remote server. The XML message content is project private between the remote mode module and the remote server. The remote mode module also provides a file manager module that can store and retrieve files if the storage controller methods are operating in that mode:","When the storage is operating in remote mode, a remote server is used as described above. The remote server supports storage controllers running in remote mode. The remote server decodes the command construct sent by the remote module, executes the appropriate JDBC\/file server requests and sends a resultant message back to the client in the response component of the HTTP request. An XML command parser of the remote server decodes the incoming instruction from the remote module and passes the request onto the JDBC Manager\/HTTP interface for fulfillment. An XML data construct module of the remote server constructs the result of the action and stores it in the response component of the HTTP document. The remote server also provides a file manager module that provides an interim storage management for any files that are in transit up to the remote module or down to the file server for storage.","The properties database contains the runtime properties of a data type. The tables are created in the properties RDBMS by the registration manager at creation and any modifications are managed by the registration manager. In the illustrative example, the properties database is implemented with an SQL schema supported, for example, by Oracle 9i. The items marked as keys at registration are indexed and a combined unique index is created on the keys marked as unique.","The properties database also has some stored procedures logged on the datatype tables. These stored procedures measure access patterns on the data including, for example, the number of instances that are written to a datatype, and the number of times a datatype is accessed for read. To do so, the stored procedures effectively manage sub-tables which have long integer values that increment upon each access. This data can be used for usage tracking. Each datatype table has a corresponding table, such as the following illustrative example:",{"@attributes":{"id":"p-0204","num":"0227"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Tablename: nameofdatatype_version_stats"]},{"entry":[{},"fieldname: number of instances"]},{"entry":[{},"fieldname: number of times accessed"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The file server is tasked with the storage and management of the message bodies. These are treated, for example, as files and the file server manages the distribution of the files for storage and retrieval. The result of a store is a URL, which identifies a stored file. This URL can be used, for example, by a client module to retrieve a stored file. The fileserver is based on a servlet engine and uses a policy input to dictate where and how the files are stored. Each file server maintains a registry of allowable data type bodies it will store. The fileserver also uses the hints provided by the storage meta data of the datatype to understand how to manage the access patterns of the data instance.","Although the system is capable of obtaining new data for processing, the system also supports existing data (i.e., legacy data). As is known, various data can each have different formats. Over time, standards and data processing systems change and new data formats are introduced, resulting in a variety of data formats. Thus, data that is acquired at an earlier date may have a different format than data acquired later. It is further possible that the earlier-acquired data, or legacy data, is stored on a legacy database. The legacy storage controller enables the system to interact with data held in databases and knowledge repositories outside of the direct control of the system.","The legacy storage controller is a process which provides a data mapping from existing data stored in repositories into something the system understands. This mapping, creates properties and bodies from relational or textual data and provides a datatype which can be registered with the registration manager. The system can thus evolve, integrating existing repositories and tools while converting them to native system storage if desired. The legacy storage controller provides a base for querying knowledge and data that already exists. A high level functional view of the legacy data controller is shown in .","As shown in , the legacy storage controller supports at least two different forms of data: document based repositories and RDBMS based repositories. For document based repository, the legacy storage controller data mapping contains a list of text query\/text parse commands used to extract the defined data properties and build\/reference the appropriate data body. For RDBMS based repositories, the legacy storage controller data mapping contains a list of query commands, such as SQL commands, used to extract the defined data properties and bodies of the data.","The legacy storage controller provides for querying existing data in the same way a system client would query newly acquired data. Therefore, the system can access data that exists in legacy databases in the same manner as newly-acquired data, without having to publish the body of the legacy data through the system. The data may, however, maintain some historical relevance to some of the system clients. While it is possible to query the legacy data using the legacy storage controller, it is possible that the system can be implemented such that legacy data cannot be written.",{"@attributes":{"id":"p-0210","num":"0233"},"figref":"FIG. 22","b":["134","2208","2206","2204"]},"When the client module initializes the legacy storage controller, it makes a connection to the datatype mapper using, for example, HTTP. The datatype mapper loads-up the appropriate datatype mappings according to the legacy datatype requests made by the client module and the client.","The datatype mapper manages connections to the legacy databases and provides a translation of the incoming query to the legacy format and then a translation of the results from the legacy format to the system format.  depicts a block diagram of the functional components of the datatype mapper. The datatype mapper maintains connections to the source SQL and file databases for optimized queries. Upon startup, the datatype mapper contacts the registration manager and requests information about each of the legacy storage servers. This information includes the address and authentication information required to access the data. These connections are managed by a file database connection management module  and an SQL connection management module , respectively.","A client connection management module  manages the query requests coming from the legacy storage controller embedded in the client module. This connection management passes the query requests onto a query translator , which uses the datatype mapping  for the queried datatype to translate it into the appropriate native query. The query translator then passes control over to a results translator , which translates the results of the query into the registered datatype format and passes the returned array back to the client connection management module for sending to the client. Translating to a datatype format is known in the art and will not be described in further detail herein.","The datatype mapping loader module  loads datatype mappings from datatype mapping storage , for example, from the secondary storage of the legacy system.","The connection management modules uses, for example, HTTP for communications between the legacy storage controller in the client and the datatype mapper. The results of the query are transmitted in one of two ways based on the query command instantiated on the legacy storage controller. Datatype bodies can either be returned in memory or into a local disk cache on the same system as the legacy storage controller.","The datatype mapping editor  is an editor that allows datatype mappings to be created. It will also create the datatype in the registration management system. Datatype mappings are, for example, XML files that comprise the following sample entries:\n\n","These three components provide logic with which the data can be modeled.",{"@attributes":{"id":"p-0218","num":"0244"},"figref":"FIG. 24","b":"2402"},"The property names  that are inserted in the generated registered datatype provide a match into the correct query . For example, a property name could be one of the following:",{"@attributes":{"id":"p-0220","num":"0246"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"sql.query3.element1"]},{"entry":[{},"file.query6.element1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"This allows a query to be constructed as follows:","select from table1 where table1.field3==\u201cfile.query3.element1\u201d . . .","The construction of the datatype body is managed in two ways. First, the queries are designed to extract the data components of the body. The results of these queries are then organized within the body as components, as shown in the following illustrative example:",{"@attributes":{"id":"p-0224","num":"0250"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<bodycomponent>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Query>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/bodycomponent>"]},{"entry":[{},"<bodycomponent>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Query>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/bodycomponent>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Therefore, legacy queries are mapped to SQL queries. Further, the system can work with textual databases. In that case, queries may, for example, take the form of perl search logic or interfacing into a custom text search engine.","In addition to bringing in legacy data into the system through the legacy storage controller, the system can also acquire other external data into the system through the external data input manager. The external data input manager is an input gateway for external data to the system. It wraps and formats an incoming datatype in such a way that the data can be published and used in the system. Each datatype that is external has its own external data input manager. The system is defined in this manner because of the individual data instance specific variables and the tight coupling the external data input manager will have with the specific data type. A functional block diagram of external data input managers  and  receiving external data instances 2506 and  and publishing to the messaging bus  is shown in . As shown, the external data input managers  and  communicate with the bus via client managers  and .","The external data input manager is a client of the system and is therefore registered in the registry by the registration manager. The external data input manager's operations comprise data retrieval of external data, preparing the data to be placed in an envelope, and creating and publishing meta data associated with the data.",{"@attributes":{"id":"p-0228","num":"0254"},"figref":"FIG. 26","b":"2602"},"Then, the external data input manager unpacks the received external data (step ). To do so, the external data input manager initiates a connection to the messaging bus via the client module to receive the client data interface from the registry. The client data interface contains information on the datatypes to be published to the messaging bus, along with information that tells the external data input manager what key and meta data information needs to be extracted from the unpacked data. The client data interface also contains information on whether the datatype should be published with the actual data in the message body (data is in memory) or if it should be published with a reference (data is in a file). Once the external data input manager has gather the information as to what is required for keys and meta data, and what datatypes to publish, it then unpacks the received data.","The external data input manager then extracts the file name information (step ) and metadata-type information that may be required to put in the envelope, such as primary instance keys and the date (step ). After extracting the information, the external data input manager creates a meta data for the data (step ), and requests the client module to publish each datatype from the client data interface to the messaging bus, utilizing the extracted information to fill in the values for the keys and metadata (step ).","Data input managers like other clients can be highly distributed, and are controlled through a registration scheme. This stops multiple external data input managers of the same type being registered or run within the system.","Once data is in the system, it can be processed by processing engines, such as transformer and presenter clients. Transformers subscribe to data, perform a processing on the data, and publish a data output. Similarly, presenters subscribe to datatypes, and then prepare an output for presentation, for example to a web viewer. Since datatypes are received asynchronously by transformers and presenters, complex intellectual capital processing can be performed on an as needed manner. Unlike conventional techniques, the clients are not limited by static or synchronous links. The system publishes the datatype to expose the data to whatever client may subscribe to the datatype. Therefore, many different types of clients can subscribe to the datatype, mutate the data in some manner, and publish the results. As the data itself does not have to be recognizable to a client, a client that subscribes to a datatype can, for example, concurrently process two instances of the same data that have different formats. If it is desired, the data in a first of the two formats can eventually be converted to the other of the two formats. Thus, processing is not inhibited by the data's format. The clients can still process datatypes for unrecognizable data formats, and eventually phase out those unrecognizable formats.","This provides for complex chaining of passive intellectual capital that is influenced by active intellectual capital. Accordingly, problems with customer systems can be mapped to the intellectual capital quickly and dynamically. Further, new clients can be added to the system without the need for versioning the whole system. Therefore, dynamic solution paths through the system can be reused.","When developed by a developer, transformers and presenters can be configured to fulfill a variety of processing tasks. The registration of clients is described above with reference to the registration manager. In addition to the information described above that is used for registration, the developer also implements processing functionality into the client. The processing functionality can be, for example, an algorithm, calculation, look-up function, or logic.","In an illustrative example, client processing engines can be used to asynchronously detect changes in data about a business or arriving from a customer system and fire business rules and processing to reflect those changes. For example, the system can inform a customer of a potential problem when the customer changes its software configuration on a customer system. Today, software stacks are so complicated that a change in configuration may not typically cause an immediate problem. Services organizations understand the correct configurations of software may not typically have access to knowledge of the change. A transformer on the system can asynchronously receive an information from the customer system whenever a software change is made to the customer system, analyze the configuration against known potential problems, and then publish a notice to the customer of a potential problem. The analysis can be made, for example, by comparing the received data to other data that relates to known problems. Also, if such a problem is discovered on the one customer's system, other customer systems, which have related client processing engines that subscribe to the datatype identifying the problem, will also be informed of the problem. Therefore, the services organization can use the system to asynchronously inform customers of potential problems before they happen.","In an illustrative example of a transformer implementation, a sample transformer parses a system log file received from a customer. The transformer, which is named Syslog Parser, parses raw syslog data coming from an external data input manager and publishes individual lines of syslog data. These syslog lines contain accessible properties that will allow transformers and presenters downstream to filter which syslog lines they are interested in and turn information into knowledge about a particular system.","In the example, syslog information is received in a raw syslog file format. Individual siloed tools are typically implemented to parse and organize this syslog data into a format useful to a specific application. Accordingly, a plurality of many applications typically perform similar or duplicate parsing. The Syslog Parser takes the burden of parsing raw syslog data off the individual application developer. Each line of syslog data received about a system and properties, which are described below) associated with that line of data are published back to the system, where it is openly accessible to downstream transformers and presenters.","Input to the Syslog Parser comprises the hostid of the system the syslog data came from, and a flat text file in standard syslog format. The syslog lines that are published comprise a set of properties that make a particular syslog line uniquely identifiable. Also, they comprise publicly queryable properties to allow a downstream application to determine whether a syslog line is interesting data.","Therefore, the Syslog Parser takes raw syslog data from customer systems one step closer to being transformed into usable Intellectual Capital. It enables new applications to be written that require customer syslog information to produce knowledge. For example, a second transformer can subscribe to the Syslog Parser output information, eliminate information that may have been in a previous syslog, and then publish the new syslog information. In turn, a third transformer can subscribe to the output of the second transformer and process what are identified as interesting events and publish them. Then, a fourth transformer, which is an availability calculator, subscribes to the output of the third transformer and processes it. In turn, the published results can be subscribed to by further clients, such as presenters that present the results to a user.","The Syslog Parser can therefore be considered in three components: Subscribed Data Type (i.e., MessagesFile), Published Data Type (i.e., MessageLine), and Processing.","The illustrative MessagesFile datatype definition is as shown in Table 7 below.",{"@attributes":{"id":"p-0242","num":"0268"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 7"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Name of Property","Value"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Name","MessagesFile"]},{"entry":[{},"Description","A datatype containing one or more"]},{"entry":[{},{},"lines of syslog data in native syslog"]},{"entry":[{},{},"format"]},{"entry":[{},"Average Size","TBD against a sampling of standard"]},{"entry":[{},{},"syslog data"]},{"entry":[{},"Maximum Size","TBD against a sampling of standard"]},{"entry":[{},{},"syslog data"]},{"entry":[{},"Priority","Initially set to \u201c3\u201d (average)"]},{"entry":[{},"Storage Access","Initially set to \u201c3\u201d (average)"]},{"entry":[{},"Model"]},{"entry":[{},"Storage Controller","N\/A (storage type is Temporary)"]},{"entry":[{},"Type"]},{"entry":[{},"Storage Type","Temporary"]},{"entry":[{},"Time Relevance","Initially set to 43,200 minutes"]},{"entry":[{},{},"(30 days)"]},{"entry":[{},"Intrinsic Value","Initially set to \u201c3\u201d (average)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The MessagesFile datatype keys definition is shown below in Table 8.",{"@attributes":{"id":"p-0244","num":"0270"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 8"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]},{"entry":[{},"Datatype",{},{},"Unique","Value"]},{"entry":[{},"Key Name","Description","Type","Combiner","Source"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"hostid","hostid of the","String","Yes","external"]},{"entry":[{},{},"system the",{},{},"device"]},{"entry":[{},{},"message file"]},{"entry":[{},{},"came from"]},{"entry":[{},"timestamp","timestamp of","Date","Yes","external"]},{"entry":[{},{},"the file the",{},{},"device"]},{"entry":[{},{},"messages file"]},{"entry":[{},{},"came from"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]}}}}},"The MessageFile runtime properties definition is shown below in Table 9.",{"@attributes":{"id":"p-0246","num":"0272"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 9"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"Runtime",{},{},"Value"]},{"entry":[{},"Property Name","Description","Type","Source"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"message body","URL to retrieve the","String","System"]},{"entry":[{},"URL","message body from the",{},"Bus"]},{"entry":[{},{},"storage controller"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}}}},"The MessageLine datatype definition is shown below in Table 10.",{"@attributes":{"id":"p-0248","num":"0274"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Name of Property","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Name","MessageLine"]},{"entry":["Description","A Data Type describing a single line of"]},{"entry":[{},"syslog data"]},{"entry":["Average Size","<1 KB (0 or 1 depending on how the storage"]},{"entry":[{},"controller uses this value)"]},{"entry":["Maximum Size","2 KB (TBD against a sampling of standard"]},{"entry":[{},"syslog data)"]},{"entry":["Priority","Initially set to \u201c3\u201d (average)"]},{"entry":["Storage Access","Initially set to \u201c3\u201d (average)"]},{"entry":"Model"},{"entry":["Storage Controller","N\/A (storage type is Temporary)"]},{"entry":"Type"},{"entry":["Storage Type","Temporary"]},{"entry":["Time Relevance","Initially set to 43,200 minutes (30 days)"]},{"entry":["Intrinsic Value","Initially set to \u201c3\u201d (average)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The MessageLine datatype keys definition is shown below in Table 11.",{"@attributes":{"id":"p-0250","num":"0276"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Data Type",{},{},"Unique","Value"]},{"entry":["Key Name","Description","Type","Combiner","Source"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["MessageLine_ID","Uniquely","Long","Yes","Generated"]},{"entry":[{},"identifies a",{},{},"by Syslog"]},{"entry":[{},"line of syslog",{},{},"Parser"]},{"entry":[{},"data"]},{"entry":["hostid","hostid of the","String","No","hostid key"]},{"entry":[{},"system that",{},{},"of messages"]},{"entry":[{},"the message",{},{},"file data"]},{"entry":[{},"came from",{},{},"type"]},{"entry":["timestamp","time the","Date","No","the syslog"]},{"entry":[{},"syslog message",{},{},"line"]},{"entry":[{},"was generated"]},{"entry":[{},"(GMT)"]},{"entry":["sourceProcess","process that","String","No","the syslog"]},{"entry":[{},"generated",{},{},"line"]},{"entry":[{},"the message"]},{"entry":[{},"as noted in"]},{"entry":[{},"the messages"]},{"entry":[{},"file"]},{"entry":["syslogLevel","the logging","String","No","the syslog"]},{"entry":[{},"level that",{},{},"line (empty"]},{"entry":[{},"logged this",{},{},"String if"]},{"entry":[{},"message",{},{},"not present)"]},{"entry":["message","the text of","String","No","the syslog"]},{"entry":[{},"the message",{},{},"line"]},{"entry":["previous","MessageLine_ID","Long","No","Generated"]},{"entry":[{},"of the previous",{},{},"by Syslog"]},{"entry":[{},"syslog message",{},{},"Parser"]},{"entry":["next","MessageLine_ID","Long","No","Generated"]},{"entry":[{},"of the next",{},{},"by Syslog"]},{"entry":[{},"syslog message",{},{},"Parser"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}}}},"The MessageLine runtime properties definition is shown below in Table 12.",{"@attributes":{"id":"p-0252","num":"0278"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Runtime",{},{},{}]},{"entry":"Property"},{"entry":["Name","Description","Type","Value Source"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["hostname","the hostname given in this","String","the syslog line"]},{"entry":[{},"message"]},{"entry":["pid","the pid of the process that","Integer","the syslog line"]},{"entry":[{},"generated this message",{},"(-1 if not present)"]},{"entry":["syslogID","the syslog generated ID of","Long","the syslog line"]},{"entry":[{},"this message",{},"(-1 if not present)"]},{"entry":["repeated","Number of times this message","Integer","the next line of"]},{"entry":[{},"was immediately repeated",{},"the messages file"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"During processing, the Syslog Parser receives the message files from the external data input manager via subscription. It opens the body of the message and reads through the messages line by line. A line is formatted into a MessagesLine data type if:\n\n","Matching the hostname on the message line with the system hostname filters messages generated by other systems at the customer site and routed to this system. The criteria for publishing is configured by the user setting up the client prior to starting up the Syslog Parser. It consists of a series of regular expressions that are matched against the datatype keys or runtime properties of MessagesLine to allow the SyslogLine to be published.","Publishing the MessageLine instances that are generated is delayed until the entire messages file received has been processed. This way Syslog Parser can insert the \u201clinks\u201d between MessagesLine instances for the \u201cprevious\u201d and \u201cnext\u201d MessagesLine.","Therefore, methods, systems, and articles of manufacture consistent with the present invention provide for the distributed data-centric capture, sharing and managing of intellectual capital. Unlike conventional systems that synchronously provide data from static \u201cstovepipe\u201d data stores, the system presented herein enables the asynchronous sharing of structured and unstructured knowledge using a publish and subscribe pattern. Loosely coupled intellectual capital processing engines subscribe to the datatypes, execute processing based on the data, and publish processing results as datatypes. These processing results can be used to dynamically and asynchronously solve customer problems.","The foregoing description of an implementation of the invention has been presented for purposes of illustration and description. It is not exhaustive and does not limit the invention to the precise form disclosed. Modifications and variations are possible in light of the above teachings or may be acquired from practicing the invention. For example, the described implementation includes software but the present implementation may be implemented as a combination of hardware and software or hardware alone. The invention may be implemented with both object-oriented and non-object-oriented programming systems. The scope of the invention is defined by the claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate an implementation of the invention and, together with the description, serve to explain the advantages and principles of the invention. In the drawings,",{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIGS. 17A and 17B"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 26"}]},"DETDESC":[{},{}]}
