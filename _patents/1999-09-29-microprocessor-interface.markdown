---
title: Microprocessor interface
abstract: A microprocessor interface having: (i) a data rebuffering section to couple data from a one of a plurality of data ports to a data port of the microprocessor selectively in accordance with a control signal; and (ii) a main memory interface for coupling to a main memory for the microprocessor, such main memory interface being coupled to the data rebuffering section for providing control signals to the main memory section for enabling data transfer between the main memory and the microprocessor through the data rebuffering section. The main memory is a selected one of a plurality of memory types each type having a different data transfer protocol and the main memory interface is configured in accordance with the selected one of the plurality of memory types to provide a proper memory protocol to data being transferred between the microprocessor and the main memory through the main memory interface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06915394&OS=06915394&RS=06915394
owner: EMC Corporation
number: 06915394
owner_city: Hopkinton
owner_country: US
publication_date: 19990929
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENTS","Data Storage System","Director","Central Processing Unit ","Error Detector","Interrupt Request Controller ","Fault Detector"],"p":["This invention relates generally to data storage systems, and more particularly to data storage systems having redundancy arrangements to protect against total system failure in the event of a failure in a component or subassembly of the storage system.","As is known in the art, large mainframe computer systems require large capacity data storage systems. These large main frame computer systems generally include data processors which perform many operations on data introduced to the computer system through peripherals including the data storage system. The results of these operations are output to peripherals, including the storage system.","One type of data storage system is a magnetic disk storage system. Here a bank of disk drives and the main frame computer system are coupled together through an interface. The interface includes CPU, or \u201cfront end\u201d, controllers (or directors) and \u201cback end\u201d disk controllers (or directors). The interface operates the controllers (or directors) in such a way that they are transparent to the computer. That is, data is stored in, and retrieved from, the bank of disk drives in such a way that the mainframe computer system merely thinks it is operating with one mainframe memory. One such system is described in U.S. Pat. No. 5,206,939, entitled \u201cSystem and Method for Disk Mapping and Data Retrieval\u201d, inventors Moshe Yanai, Natan Vishlitzky, Bruno Alterescu and Daniel Castel, issued Apr. 27, 1993, and assigned to the same assignee as the present invention.","As described in such U.S. patent, the interface may also include, in addition to the CPU controllers (or directors) and disk controllers (or directors), addressable cache memories. The cache memory is a semiconductor memory and is provided to rapidly store data from the main frame computer system before storage in the disk drives, and, on the other hand, store data from the disk drives prior to being sent to the main frame computer. The cache memory being a semiconductor memory, as distinguished from a magnetic memory as in the case of the disk drives, is much faster than the disk drives in reading and writing data.","The CPU controllers, disk controllers and cache memory are interconnected through a backplane printed circuit board. More particularly, disk controllers are mounted on disk controller printed circuit boards. CPU controllers are mounted on CPU controller printed circuit boards. And, cache memories are mounted on cache memory printed circuit boards. The disk controller, CPU controller and cache memory printed circuit boards plug into the backplane printed circuit board. In order to provide data integrity in case of a failure in a controller, the backplane printed circuit board has a pair of buses. One set the disk controllers is connected to one bus and another set of the disk controllers is connected to the other bus. Likewise, one set the CPU controllers is connected to one bus and another set of the CPU controllers is connected to the other bus. The cache memories are connected to both buses. Each one of the buses provides data, address and control information.","In accordance with the invention, a microprocessor interface is provided. The interface includes a semiconductor integrated circuit having formed therein: (i) a data rebuffering section adapted to couple data from a one of a plurality of data ports to a data port of the microprocessor selectively in accordance with a control signal; and (ii) a main memory interface adapted for coupling to a main memory for the microprocessor, such main memory interface being coupled to the data rebuffering section for providing control signals to the main memory section for enabling data transfer between the main memory and the microprocessor through the data rebuffering section.","In one embodiment of the invention, the main memory is a selected one of a plurality of memory types each type having a different data transfer protocol and the main memory interface is configured in accordance with the selected one of the plurality of memory types to provide a proper memory protocol to data being transferred between the microprocessor and the main memory through the main memory interface.","In one embodiment, one main memory type is an SDRAM or a RDRAM.","In accordance with another feature of the invention, the microprocessor interface includes a second integrated circuit adapted for controlling the first-mention integrated circuit, such second integrated circuit having thereon a controller adapted for coupling to the main memory interface. The controller is adapted to produce a main memory access control signal. The main memory has a two portions of addressable locations, one portion being addressed by the main memory interface in response to a preselected range of memory location addresses provided by the microprocessor and the other portion being addressed by the main memory interface in response to the memory access control signal provided by the controller.","In one embodiment the data rebuffering section includes a selector responsive to the control signal for coupling data between a selected one of the data ports and the data port of the microprocessor.","In accordance with one feature of the invention, the data rebuffering section includes selector responsive to the control signal for coupling the data port of the microprocessor to either: a selected one of the data ports; or, the main memory, selectively in accordance with the control signal.","In accordance with another feature of the invention, the data rebuffering section includes a data distribution unit having a plurality of ports each one of the ports being coupled to a corresponding one of: (i) the selector; (ii) a random access memory; (iii) an interrupt request controller; (iv) the microprocessor data port; and (v) the main memory interface.","In accordance with another feature of a microprocessor interface is provided. The interface includes: (i) a memory controller for producing addresses for the main memory, such memory controller having a decoder responsive to the produced addressed to determine whether the produced address is within the first set or the second set of addresses; and (ii) a main memory interface adapted for coupling to a main memory for the microprocessor, such main memory interface being adapted for coupling to the microprocessor and being coupled to the data rebuffering section for providing control signals to the main memory section for enabling data transfer between the main memory and the microprocessor through the data rebuffering section. A controller is responsive to the decoder, for enabling the second section in the memory when the decoder determines the produced address is in the second set of addresses. The first section is enabled for addressing by the produced address when the decoder determines the produced address is in the first set of addresses.","In one embodiment, the system includes a mask to transform the address to an address in the second section of the memory.","Referring now to , a data storage system  is shown wherein a host computer  is coupled to a bank  of disk drives through a system interface . The system interface  includes a cache memory . A plurality of directors -is provided for controlling data transfer between the host computer  and the bank  of disk drives as such data passes through the cache memory . A pair of high address busses TH, BH is electrically connected to the high address memory section H of cache memory  as described in U.S. patent application Ser. No. 09\/223,115 entitled \u201cData Storage System\u201d, inventors D. Castel et al, now U.S. Pat. No. 6,289,401 filed Dec. 30, 1998, assigned to the same assignee as the present invention, the entire subject matter thereof being incorporated into this application by reference. A pair of low address busses TL, BL is electrically connected to the low address memory section L of cache memory . The cache memory  has a plurality of storage location addresses. Here, the storage locations having the higher addresses are in the high address memory sections H and the storage locations having the lower addresses are in the low address memory sections L. It should be noted that each one of the directors -is electrically connected to one of the pair of high address busses TH, BH and one of the pair of low address busses TL, BL. Thus, each one of the directors -is able to address all locations in the entire cache memory  (i.e., to both the high address memory sections H and the low address memory sections L) and is therefore able to store data in and retrieve data from any storage location in the entire cache memory .","More particularly, a rear-end portion of the directors, here directors -, is electrically connected to the bank  of disk drives and a front-end portion of the directors, here directors -, is electrically connected to the host computer .","In operation, when the host computer  wishes to store data, the host computer  issues a write request to one of the front-end directors -to perform a write command. One of the front-end directors -replies to the request and asks the host computer  for the data. After the request has passed to the requesting one of the front-end directors -, the director determines the size of the data and reserves space in the cache memory  to store the request. The front-end director then produces control signals on either a high address memory bus (TH or BH) or a low address memory bus (TL, BL) connected to such front-end director depending on the location in the cache memory  allocated to store the data and enables the transfer to the cache memory . The host computer  then transfers the data to the front-end director. The front-end director then advises the host computer  that the transfer is complete. The front-end director looks up in a Table, not shown, stored in the cache memory  to determine which one of the rear-end directors -is to handle this request. The Table maps the host computer  address into an address in the bank  of disk drives. The front-end director then puts a notification in a \u201cmail box\u201d (not shown and stored in the cache memory ) for the rear-end director which is to handle the request, the amount of the data and the disk address for the data. Other rear-end directors poll the cache memory  when they are idle to check their \u201cmail boxes\u201d. If the polled \u201cmail box\u201d indicates a transfer is to be made, the rear-end director processes the request, addresses the disk drive in the bank, reads the data from the cache memory and writes it into the addresses of a disk drive in the bank . When data is to be read from the disk drive to the host computer  the system operates in a reciprocal manner.","Referring now to , an exemplary one of the directors, here director , is shown. The director has an X CPU section  and a Y CPU section  which share shared resources  such as flash memories, etc. The flash memory stores the BIOS, or boot-up routine, for the CPU sections , . The X and Y CPU sections ,  are identical in construction, the X CPU section  being shown in more detail in FIG. . Here, the X CPU section  shown is a rear end director and thus is coupled to the disk drives  (FIG. ), it being understood that had such section been in a front end director such X CPU section  would have been connected to the host computer . The X CPU section  is also coupled to the cache memory  (FIG. ), as indicated.","Referring in more detail to the X CPU section , it is noted that such section  includes a Direct Memory Access (DMA) section  which is an interface between the cache memory  (FIG. ), the bank of disk drives  and the central processing unit  of the X CPU section . The central processing unit  includes a microprocessor , here a Power PC microprocessor, a main memory , a CPU decoder  (e.g., a programmable logic device), and a microprocessor interface , here an Application Specific Integrated circuit (ASIC). The microprocessor interface  will be described in more detail in connection with FIG. . Suffice it to say here, however, that the microprocessor interface  is a comprehensive Power PC microprocessor support integrated circuit chip having several discrete functional sections, including a main memory interface  having a set of registers , a data rebuffering section , an interrupt request (IRQ) controller , and an embedded Static Random Access Memory (SRAM) . Here, the main memory  is an SDRAM, however, as will be described, other types of memories may be used such as a RAMBUS DRAM (RDRAM).","Here, the main memory interface  is adapted to manage one or two banks of main memory  SDRAMs, providing up to 128 MB of memory I\/O space using 64-megabit RAM densities. The data is Error Correction Code (ECC)-protected and single-bit errors can be corrected as they are detected. The main memory SDRAM interface  fully supports byte, half-word and word reads and writes through built in Read-Modify-Write cycles.","The interrupt request (IRQ) controller  provides flexible interrupt management. Here, the interrupt request controller  supports up to 28 external interrupts and 4 fatal interrupts as well as internal interrupts. These interrupts can be assigned to any interrupt level by programming level and mask registers which will be described in more detail in connection with FIG. . In addition, the interrupt request controller provides facilities to assist in Motorola 68060-style interrupt generation as will also be described in more detail in connection with FIG. .","The data rebuffering section  of the microprocessor interface  provides dual-bus address and data rebuffering. Fully flexible and controlled by the external CPU decoder , the address and data paths are rebuffered to enable connection to local and shared resources . The options of registering data, assembly\/disassembly function, and parity generation are controlled by the logic in the external CPU decoder .","The microprocessor interface  also provides facilities to capture address and data ranges, and to provide interrupts upon capture. This capability is useful for debugging operations to trap rouge address or data cycles.","Referring now also to , the central processing unit  () of the director  includes, as noted above, a microprocessor ; a main memory ; a CPU decoder ; and a microprocessor interface , here an ASIC. The data rebuffering section  of the microprocessor interface  is adapted to couple data from a one of a plurality of data ports, here data port A, data port B, and data from the embedded SRAM  and interrupt request controller , to a data port of the microprocessor  selectively in accordance with a control signal supplied by the CPU decoder . The main memory interface  is adapted for providing control signals to the main memory  section for enabling data transfer between the main memory  and the microprocessor  through the data rebuffering section .","As noted above, the main memory  is a selected one of a plurality of memory types, such as an SDRAM or an RDRAM. Each memory type has a different data transfer protocol. The main memory interface  is configured in accordance with the selected one of the plurality of memory types to provide a proper memory protocol to data being transferred between the microprocessor  and the main memory  through the main memory interface . As noted above, one main memory type is an SDRAM and another main memory type is a RDRAM, it being understood that other types may also be used.","Referring now also to , the main memory interface  is shown in more detail to include a main memory API controller  and a microprocessor memory interface control\/EDAC section . The data to and from the main memory  passes through the EDAC portion  of section , such EDAC portion being described in more detail in connection with FIG. . The main memory API controller  is responsible for translating upper-level read, write, and refresh requests into the appropriate low-level control signals for the type of main memory  being used. That is, the data to and from the main memory  is through the main memory API controller  in response to control signals supplied by the microprocessor memory interface control\/EDAC section . The control signals are generic, that is they are independent of the type of main memory  being used. The main memory API control  is hard-wired a priori to translate the generic control signals into the proper protocol for the particular type of main memory , i.e., SDRAM or RDRAM, etc. If for example, the original application for the CPU controller  is with an SDRAM, and at some future time the application will use an RDRAM, the only portion of the microprocessor interface  which must be reconfigured is the main memory API controller ; the design of the microprocessor memory interface control\/EDAC section  may remain unchanged.","Referring also to , the microprocessor memory interface  has three sections; the EDAC section , a memory interface control section  and an address\/data register and control section . The microprocessor memory interface  manages the interface between the microprocessor  and the main memory API controller . It performs the required address decoding, burst address counter, Opcode generation, refresh generation, and main memory API controller \/microprocessor  synchronization.","The address\/data register and control section  contains the necessary input and output registers to properly align the microprocessor  data stream with the main memory  data stream after it has passed through the EDAC section .","The EDAC section  is described in more detail below in connection with FIG. .","Various control and data lines and busses are shown in FIG. :",{"@attributes":{"id":"p-0045","num":"0044"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CPU_DatlOp<71.0>"]},{"entry":[{},"DBBnp"]},{"entry":[{},"CPU_Adrp<35.0>"]},{"entry":[{},"TSnp"]},{"entry":[{},"ABBnp"]},{"entry":[{},"TT1p"]},{"entry":[{},"TT3p"]},{"entry":[{},"TBSTnp"]},{"entry":[{},"TSIZp<2.0>"]},{"entry":[{},"AACKnp"]},{"entry":[{},"TAnp"]},{"entry":[{},"which are defined in the Motorola MPC 750"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"microprocessor Manual;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Clock"]},{"entry":[{},"Reset and"]},{"entry":[{},"Pulse"]},{"entry":[{},"which are system inputs;"]},{"entry":[{},"the following EDAC signals:"]},{"entry":[{},"SBE\u2014single bit error indication"]},{"entry":[{},"MBE\u2014multiple bit error indication"]},{"entry":[{},"PErr\u2014parity error indication"]},{"entry":[{},"Syndrome\u2014XOR reduced syndrome bits"]},{"entry":[{},"Err_Cnt\u2014error count (number of EDAC errors"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"detected during a data transfer)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Config_Data\u2014indicates where the EDAC is either an error detect or error correct mode and whether the EDAC is in even or odd parity;","the following are defined by Rambus Application",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"WD"]},{"entry":[{},"RD"]},{"entry":[{},"Wdone"]},{"entry":[{},"Rrdy"]},{"entry":[{},"Busy"]},{"entry":[{},"Last"]},{"entry":[{},"Ai"]},{"entry":[{},"Ao"]},{"entry":[{},"Mo"]},{"entry":[{},"Op"]},{"entry":[{},"Start"]},{"entry":[{},"and the following which are conventional SDRAM"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"interface signals:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"DQ<71.0>"]},{"entry":[{},"Adr<13.0>"]},{"entry":[{},"CSn"]},{"entry":[{},"RASn"]},{"entry":[{},"CASn"]},{"entry":[{},"WEn"]},{"entry":[{},"DQM"]},{"entry":[{},"CKE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Referring again to , the data rebuffering section  is responsive to a control signal from the CPU decoder , for coupling data between a selected one of the data ports, i.e., port A, port B, or the embedded SRAM or the interrupt request controller , and the data port of the microprocessor . More particularly, the data rebuffering section  has a port A transceiver (XCVR), a port B XCVR , an XCVR core , and a CPU XCVR , arranged as indicated in FIG. . The XCVR core  is a selector which, in response to a control signal from the CPU decoder , couples data\/address between port  of the CPU XCVR  and either: the port A XCVR ; or, the port B XCVR ; the embedded SRAM , or the interrupt request controller  selectively in accordance with a control signal fed to the XCVR core  from the CPU decoder . (As noted from , here the port A XCVR is connected at port A to the cache memory  () through the DMA  and the port B XCVR  is coupled at port B to the shared resources .","The CPU XCVR is a data distribution unit having a plurality of ports each one of the ports being coupled to a corresponding one of: (i) the XCVR (selector) ; (ii) the Synchronous DRAM ; (iii) the interrupt request controller ; (iv) the microprocessor  data port; and (v) the main memory interface .","More particularly, the XCVR core  and CPU XCVR  are shown in , B, and C. The data rebuffering section  mechanism that supports microprocessor write operations is shown in FIG. A. The here 72 bit data from the microprocessor  data transfer bus transfers to the microprocessor interface  at the CPU_DataIOp interface. The microprocessor interface  has two registers , , one for the upper data word and one for the lower data word, respectively. The CPU_DatWUClkEnp and DatWLClkEnp are used to enable data registering into the upper and lower word lanes on the rising edge of a clock, not shown, respectively. Parity is stored along with the corresponding word's data. CPU_DatSyncSelp, when clear, causes the input registers ,  to be by-passed providing an asynchronous data path to Port A and Port B. CPU_ULSelp determines whether the upper or lower register  or  word is passed to port A or port B. This is necessary as the microprocessor , here Power PC, data interface  is 72 bits while here the Port A and Port B interfaces are 36 bits wide.","Port A and Port B are identical in operation. Thus PortA\/PortB_DatWClkEnp clocks data PortA_DatIOp\/PortB_DataIOp into the output port data registers ,  respectively on the rising edge of the Clock. PortA\/PortB_DatSyncSelp, when clear, provides an output register bypass mechanism for asynchronous output data. PortA\/PortB_DatIOOEnp enable the output drivers ,  for the ports A and B.","A separate data path (SDIO) is used for the main memory interface . The main memory interface  has a dedicated set of input registers ,  in the CPU XCVR  which are enabled (EN) when DBBnp from the CPU decoder  is asserted.","The data rebuffering section  mechanism that supports the microprocessor  read operation is shown in FIG. B. For read operations, data transfers to the microprocessor interface  at the PortA\/PortB_DatIOp interfaces. PortA\/PortB_DatRClkEnp are used to enable data registering on the rising edge of the Clock, respectively. PortA\/PortB_DatSyncSelp, when clear, causes the input registers ,  to be bypassed providing an asynchronous data path. Such an arrangement allows design flexibility (e.g., tradeoff between performance and latency).","CPU_DatPortSelp determines the data source for the CPU output registers , . The Table below list the possible data sources:",{"@attributes":{"id":"p-0056","num":"0055"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["CPU_DatPortSelp Value","Data Source"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["000","Data currently stored in the microprocessor"]},{"entry":[{},"output registers"]},{"entry":["001","Data currently stores in the Port A output"]},{"entry":[{},"registers"]},{"entry":["010","Data Currently stored in the Port B output"]},{"entry":[{},"registers"]},{"entry":["011","All 1s with good parity"]},{"entry":["100","Internal configuration and status registers. The"]},{"entry":[{},"register data is presented on the lower word"]},{"entry":[{},"and the upper word is padded with all 0s and"]},{"entry":[{},"good parity."]},{"entry":["101","Data from Port A."]},{"entry":["110","Data from Port B."]},{"entry":["111","Data from the EDAC 70"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"CPU_DatRUClkEnp and CPU-DatRLClkEnp clocks data into the upper and lower word lanes (e.g., registers , ) on the rising edge of the Clock. The external CPU decoder  () must control these signals appropriately to present the portA\/PortB data on the correct word line based on the least-significant address decodes. CPU_DatSyncSelp, when clear, causes the CPU output registers ,  in the data path to be bypassed providing asynchronous output to the Power PC microprocessor .","A separate data path SDIO is used for the main memory interface. The output from the main memory controller  is fed to a top-level output multiplexer . Any time the microprocessor interface  decodes an address in its internal main memory space, the data presented to the microprocessor is from the main memory controller. Otherwise, the data presented to the microprocessor is from the microprocessor  output structure.","CPU_DatIOOEnp controls the CPU output buffers and is valid only during non-main memory transactions. During main memory control, the microprocessor interface  controls these output drivers  to present data to the microprocessor  at the correct time.","Referring now to , the addressing rebuffering mechanism that supports the microprocessor address path is shown. Address rebuffering in the microprocessor interface  is unidirectional and is source at the CPU_Adrp port. CPU_AdrSyncSelp determines on a global basis whether the address path is synchronous-pipelined or asynchronous (default). During asynchronous operation, the external CPU decoder  () must ensure that the address has enough time to propagate through the microprocessor interface  to Port A\/PortB before asserting Ext_AACKnp.","During synchronous operations, TSnp clocks the current address into the CPU Address input register . When the external CPU decoder  () asserts Ext_AACKnp, the address previously registered into the CPU Address input register  is transferred to the Port A and Port B Address Output registers , . PortA\/PortB_AdrIOOEnp selectively enable their respective port address output drivers , .","The internal main memory controller  has a dedicated set of address registers . When TSnp asserts, the address on CPU_Adrp is clocked into one of the main memory address registers  for use by the main memory controller.","As noted briefly above, the main memory  has a plurality of data storage sections, one section having a first set of addresses and a second section having a second set of addresses. It should be understood that there may be more than one second section (i.e., the second section may be made up of a plurality of regions, or sections). The microprocessor interface  produces addresses for the main memory . The main memory controller  has a decoder  responsive to the produced addressed to determine whether the produced address is within the first set or the second set of addresses. The main memory interface  is adapted for coupling to the main memory . The main memory  is adapted for coupling to the microprocessor  and to the data rebuffering section . The main memory interface  provides control signals for enabling data transfer between the main memory  and the microprocessor  through the data rebuffering section . The main memory interface  is responsive to the decoder  and enables the second section in the memory  when the decoder  determines the produced address is in the second set of addresses and the first section is enabled for addressing by the produced address when the main memory interface  determines the produced address is in the first set of addresses.","More particularly, and referring to , four external SDRAM chip selects CS-CS provide access to the SDRAM . Access to the SDRAM via the chip select is decoded by the external CPU decoder  (FIG. ). The decoded address must fall outside the memory space allocated to the microprocessor interface , here addresses h to FF FFFFh. A configuration register defines an address mask which is applied to the Power PC microprocessor  address to qualify a segment size, i.e., the size of the SDRAM associated with each chip select. Each chip select also has a segment address register, (i.e., DRAM CSx segment address) with which it is associated. This segment address register provides an OR-field which is added to the microprocessor address after the address segment size mask is applied. This allows the four chip selected SDRAM spaces to be located independently throughout the SDRAM space.","Assuming, for example, a full memory configuration of 128 MB and that this configuration demonstrates four segments of 64K apiece located at the top 256 K of SDRAM memory space. Assume that the CPU decoder decodes a chip select memory access at address h. As will be described in connection with , the input address provided by the microprocessor , here h and stored in register  will be mapped to a new output address, here FC h) shown in region  shown in FIG. D.","More particularly, the microprocessor address segment mask of FF h is applied to this address yielding a resulting address of h. Next, the appropriate DRAM chip select segment address is OR'd in. Assuming chip select CS was used, FC h is OR'd with the interim result to produce FFC h as the chip select memory address. The uppermost 5 bits are truncated from the address as they are beyond the 128 MB of addressable memory. The final memory address becomes FC h for the chip select of the SDRAM access.","More particularly, and referring to , it is first noted that first addresses in the main memory  (i.e., the section  having the first 128 MBytes minus 256k of memory) is dedicated for addressing only by the microprocessor interface . The upper 256 Kbytes have been segmented into four segments -of 64k each. Each one of these four segments -is selected by a corresponding one of four chip selects CS-CS, as indicated. Here, the address (here, for example, h) is shown provided by the microprocessor  is stored in register  (FIG. C). The segment size is stored in one of the registers, here register ) in set of registers  () in the main memory interface , here, in this example, FF h). For each bit in register  is gated with a corresponding bit in register  in gates  with the gated output (i.e., interim result) being shown in region , here h. The desired chip select segment enabling the various storage sections for the main memory  is stored in register  in set of registers . Here, in this example the register  stores FC h, as indicated. Each one of these bits is OR gated with a corresponding one of the bits produced at the output of gates  to provide the result shown in region , here the chip select SDRAM mapped addresses FFC h, as indicated. After truncating bits  through , as indicated by the bracket , such truncated result is fed as the address to the main memory , as indicated. It is noted that addresses FC  through FF FFFF are in the above described second section of the main memory  here having four region -, each with 64K addresses. Here, regions -are selected by chip selects CS-CS, respectively. Thus, it is noted that the input address provided by the microprocessor  and stored in register  has been mapped to a new output address shown in region .","Referring now to , the error detection and correction section (EDAC)  is shown in more detail. The EDAC  is coupled between the main memory API (Application Programming Interface) controller  and the CPU XCVR  through a data bi-directional I\/O bus (MDIO) and the system data bi-directional I\/O bus (SDIO), as shown in FIG. . Considering first data flow from the SDIO to the MDIO, a source of data, here the data read from the CPU XCVR  (FIG. ), is applied to the SDIO. The data has a plurality of bytes, here eight bytes (i.e., 64 bits), each one of the bytes having a parity bit. A parity checker  is responsive to the parity bits on SDIO and the eight bytes of data on SDIO for detecting a parity error in the data eight bytes of data produced by the data source on SDIO. Any parity error is reported to the CPU decoder  (FIG. ).","A pair of check bit generators are provided. Each one of the parity bit generators ,  is fed the plurality of bytes, here eight bytes, of the data on SDIO. Each one of the parity bit generators ,  is a redundancy code generator, here a modified Hamming code check bit generator, which generates a plurality of check bits from the plurality of bytes fed thereto. A logic, here an XOR gate , is fed by the check bits produced by the pair of check bit generators ,  for determining whether the pair of check bit generators ,  produce different check bits for the same bytes fed thereto. A logic, here an XOR gate arrangement  is fed by the check bits produced by one of the pair of check bit generators, here generator , for producing a single, combined parity bit from the generated check bits. One such XOR gate arrangement  is shown in  to include a plurality of, here six XOR gates  arranged as shown being fed by eight bits B-Bto produce a combined parity bit on line .","The eight parity bits on SDIO are fed to a logic , here an XOR gate arrangement similar to the arrangement  shown in , for producing a combined parity bit CHK_PAR from the plurality of parity bits. A logic , here an XOR gate, is provided to determine whether the combined parity bit produced by the logic  and the combined parity bit produced by the logic  have the same logic state. Absent any error or fault, the parity bit CHK_PAR and the combined parity bit produced by the XOR arrangement  will be the same. The output of the XOR gate  and XOR gate  are fed to an OR gate  which produces a check bit error signal for an OR gate  if a fault has been detected by either a mismatch in the parity bits fed to the XOR gate  or the XOR gate .","Considering now the flow of data from the MDIO to the SDIO, a data source, here the data read from the main memory  and placed on the MDIO bus, has a plurality of, here eight bytes and a plurality of, here eight check bits associated with such bytes. The eight check bits are stored with the data and had been generated from a redundancy generating code, here a modified Hamming code. A pair of check bit generators ,  are provided. Each one of the check bit generators ,  is responsive to the plurality of, here eight bytes of the data on the MDIO bus for generating here eight check bits. The check bit generators ,  are redundancy code generators, here modified Hamming code generators. A logic , here an XORing arrangement such as that described in connection with  is provided for producing a combined parity bit from the generated check bits. The combined parity bit is fed to an input of XOR gate .","A pair of error detector\/correctors ,  is provided. Each one of the detectors\/correctors ,  is responsive to: the eight bytes of data on the SDIO; the generated check bits of a corresponding one of the pair of check bit generators , ; and, the eight check bits associated with the bytes of data on the SDIO. Each one of the pair of error detector\/correctors ,  includes a pair of syndrome generator , , respectively, and a pair of data_correctors , , respectively. Each one of the pair of error detector\/correctors ,  is adapted to detect an error in the bytes fed thereto and adapted to correct such data in event of a detected error in accordance with conventional modified Hamming code error correction and detection techniques (i.e., a single bit error is detectable and correctable and a multiple bit error is detectable).","A parity bit generator  is provided for producing a plurality of, here eight, parity bits from data produced by one the pair of error detector\/correctors , , here the data_corrector  of generator . A logic , here an XOR arrangement similar to that described above in connection with , is provided for producing a combined parity bit, GEN_PAR, representative of the eight parity bits produced by the parity bit generator . The eight parity bits produced by the parity bit generator  are fed to the SDIO.","A logic, here the XOR gate , is provided to determine whether the combined parity bit produced by the logic  and the combined parity check bit from the logic  have the same logic state. A logic , here an XOR gate is provided for determining whether the data produced by the data_correctors ,  of the pair or error detector\/correctors ,  is the same. If they are different an syndrome error is produced. This syndrome error together with the output of the XOR  and the CB error are fed to an OR gate  to produce a chip error signal for the interrupt request controller  (FIG. ).","Referring now to , the interrupt request controller  is shown in more detail. The interrupt request controller  manages interrupt inputs and programmable interrupt inputs or general purpose outputs. Here  dedicated inputs feed the interrupt request controller  directly and four fatal interrupts (Fatal_IntIop < . . . >) are OR-reduced to a single entry by a fatal mask  in the interrupt request controller . It is noted that these four fatal requests may be programmed as general purpose outputs.","The interrupt request controller  includes an interrupt inverter section  () fed by the ORrd output from the fatal mask  and the here  other interrupt request (IRQs); a watchdog IRQ produced by watchdog timer  which is fed refresh pulses, select signals and data from the XCORE selector , a Match IRQ produced by Match  which is fed addresses, data and select signals from the XCORE selector , a microprocessor interface IRQ produced by the microprocessor interface  (FIG. ), and  Intp < . . . > IRQs produced by inputs external pins of the microprocessor interface . Each one of the 32 IRQs are fed to an interrupt invert register  in the interrupt invert section , and exemplary one thereof being shown in FIG. . The interrupt request IRQ is fed to one input of an XOR gate , the other input being fed by the output of a register . If the particular IRQ sense (i.e., either positive-true or negative-true) is to be inverted, a logic 1 is stored in the register . On the other hand, if the IRQ , is not to be inverted, a logic 0 is stored in the register .","In any event, the  outputs from the interrupt invert  are fed to an interrupt type register section . More particularly, each bit is fed to an interrupt type register , an exemplary one thereof being shown in FIG. . The interrupt type register  determines whether the interrupt IRQ should be an edge (leading or trailing edge) or remain as a level. More particularly, the register  includes a multiplexer . The multiplexer  has one port, port A, fed by the interrupt request IRQ and the other input, port B, fed by an edge logic . The edge logic  includes an OR gate . One input to the OR gate is fed by the interrupt request IRQ through an AND gate  and register , as indicated, and the other input to the OR gate  is fed by a clear signal through AND gate , as indicated. The output of the OR gate is fed to a register . The output of register  is fed to the B input of multiplexer . A register  is provided to produce the port select signal for the multiplexer . If a logic 1 is stored in the register , the A port is coupled to the output of the multiplexer  thereby selected a level as in interrupt request type. On the other hand, if a logic 1 is stored in the register  the output of the edge logic  is coupled to the output of the multiplexer .","More particularly, in response to a clock pulse, register  stores the level of the interrupt fed thereto. The stored level is fed to the inverted input of AND gate . Thus, AND gate  compares the level of the present interrupt with the level of the previous interrupt (i.e., the level of the interrupt on the previous clock). If they differ, a logic 1 is asserted and becomes stored in register . The stored logic 1 in register  is then fed back to the non-inverting input of AND gate . The output of AND gate , in the absence of a clear signal from the microprocessor interface  () passes through OR gate  where it remains until the presence of a clear signal. Thus the clear opens the feedback path. Thus, in response to an edge (i.e., leading or trailing edge) of the interrupt signal, such edge is converted into a level which appears at the output of register  (i.e., at the B input of selector .","The interrupt requests produced by the interrupt type register section  is fed to a current interrupt register . The contents of the current interrupt register may be observed for testing or, in operation, for polling, for example. These contents are also fed to a source mask  wherein any one of the 32 bits may be masked as desired.","Additional registers assign each interrupt source to a particular level interrupt. A mask register allows individual interrupts to be masked. In addition, the interrupt request controller contains logic for emulating the Motorola 68k family interrupt logic. This logic includes registers which contain current IPL level and status and provide the necessary hardware to simply implement an emulated 68k interrupt scheme.","More particularly, the Int through Int mask registers in section  select which interrupt bits from the source mask register  participate on a given level. Each Intx mask is OR-reduced in OR gate section  to arrive at the primary IRQnp< . . .  outputs. These outputs may be used where desired to change the flow in execution of a program, for example. Similarly, the Int68k7 through Int68k1 mask registers in section  select which interrupt bits participate on Motorola 68k-style level. Each level is OR-reduced in section  and then fed to the IPL level\/mask register . This register can individually mask any interrupt level. An IRQ68knp interrupt is then generated based on the level information stored in the IPL level\/mask register  and the current IPL register .","The microprocessor , here Power PC, microcode may use the IPL\/mask and current IPL registers ,  to emulate the built-in capabilities of the Motorola 68k family of microprocessors. The current register contains the highest-level interrupt currently pending. By reading this register  and then reprogramming the IPL level\/mask register , the microprocessor interface  can emulate the IPL level masking capabilities found in the 68k family of microprocessors. A simple driver routine need only be written to manipulate these registers upon receiving an interrupt so the ISR can branch to the traditional 68k-style interrupt vectors.","Thus, section  is a programmable mask section for coupling unmasked ones of the interrupt signals to a plurality of outputs selectively in accordance with a predetermined priority criteria.","Referring now to , a circuit  is shown for detecting a hard fault (i.e., a ground fault or a connection to a fixed, unchanging voltage) on a bi-directional data line . The circuit  includes an input\/output terminal  connected to one end of the bi-directional line ; a data receiver  having an input coupled to a second end of the bi-directional line  for receiving data on the terminal ; an data driver  having an output coupled to second end of the bi-directional line  for producing data on the terminal ; an XOR gate  having a pair of inputs, one being coupled to an input of the data driver  and the other being coupled to an output of the data receiver , for determining whether data produced by the data driver is received by the data receiver.","For example, assume a ground is shorted to the line . When the data driver  is enabled by an enable signal EN and is to produce, in response to the logic signal fed to the input of the data driver , a high logic voltage on the line bus, the ground will produce a low logic signal at the output of the XOR gate . Thus, the XOR gate output will indicate that the input to the data driver  is different from the output produced by the data receiver , thereby producing a logic 1 and therefore indicating a fault.","It should be understood that if the hard fault on the line  is a high voltage which is fixed and remains constant over a number of normal data cycles, when the data driver  is enabled by an enable signal EN and is to produce, in response to the logic signal fed to the input of the data driver , a low logic voltage on the line bus, the high voltage fault will produce a high logic signal at the output of the XOR gate . Thus, the XOR gate output will indicate that the input to the data driver  is different from the output produced by the data receiver , thereby producing a logic 1 and therefore indicating a fault.","Other embodiments are within the spirit and scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWING","p":["These and other features of the invention will become more readily apparent from the following detailed description when read together with the accompanying drawings, in which:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIGS. 3A through 3C","FIG. 3","FIG. 3A","FIG. 3B","FIG. 3C"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 3D","FIG. 2"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 5A","FIG. 5"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 7","FIG. 6"]},{"@attributes":{"id":"p-0027","num":"0026"},"figref":["FIG. 8","FIG. 6"]},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
