---
title: Page function architectural framework
abstract: An architectural software framework is provided for creating Web-style application software incorporating protocols and means for expansion and interfacing with other Web-style programs, as well as a reusable basic programming structure, consisting of abstract and concrete data types, that assist in building Web-style applications. The architectural software framework includes a page function and frame. Each Web-style application includes one or more page functions which communicate via the frame.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07404004&OS=07404004&RS=07404004
owner: Microsoft Corporation
number: 07404004
owner_city: Redmond
owner_country: US
publication_date: 20031118
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["This application is a continuation-in-part of U.S. patent application Ser. No. 10\/083,023, filed on Feb. 26, 2002 now U.S. Pat No. 6,973,624.","The present invention relates generally to an architectural software framework for creating Web-style applications, and more particularly, to the design of Web-style application software incorporating protocols and means for expansion and interfacing with other Web style programs, as well as a reusable basic programming structure consisting of abstract and concrete data types that assist in building Web-style applications.","A user interface is a portion of a program with which a user interacts. Types of user interfaces, or UIs (in the idioms of computer engineering), include command-line interfaces, menu-driven interfaces, and graphical user interfaces. A windowing environment, which uses a graphical user interface, is an operating system or shell that presents the user with specially delineated areas of the screen called windows, which may be resized and moved around on the display of a computer. Macintosh OS\u00ae and Microsoft Windows\u00ae are both examples of windowing environments. Graphical user interfaces are one of the means by which a user interacts with an application, which is a program designed to assist in the performance of a specific task, such as word processing, accounting, or inventory management. Graphical user interfaces allow a user's action in one window to cause an application to open another window. In such a case, the original window, which caused the new window to be opened, appears behind the new window. Many applications allow an unlimited number of such windows to be open at the same time. However, a user can generally interact only with the top-most window. As a result, the top-most window is said to be the active window. All other windows are said to be inactive windows.","Windows can be classified as modeless or modal. If an active window is modeless, a user is able to make any inactive window active by using a pointing device to click on any portion of an inactive window that is visible to a user. If, however, an active window is modal, a user cannot activate other windows until the active window is closed. For example, a user may have to complete a task in the active window, which is modal, such as filling in some fields and pressing an OK button to close the active window before other windows can be activated.","An active window that is modal may open another window, which will become active and modal, on top of it, and so on. Only the top-most active window that is modal is active. All other windows, whether they are modal or modeless, are inactive and cannot be activated until the active modal window is closed. Applications use modal windows as detours away from some primary task to perform an auxiliary task. Once a user closes a modal window, the operating system reactivates the original window that the user employed to activate the modal window. Returning a user to the original window effectively completes the detour, thereby allowing a user to continue with his original task.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1","b":["100","100","102","102","104","104","100","100","106","108","110","106","110","112","114","100","115","100","100","116","100","100"]},"Wizards and similar programs work fine for the purpose for which they were designed. However, because of various constraints, wizard-type programs are typically not used in user interfaces for interacting with various applications. The main problem with the wizard-type programs is their modal nature. When a wizard presents a question to a user, the user must contemporaneously have sufficient information to answer the question or must cancel the entire process. Because of the modal nature of wizard-type programs, a user cannot reactivate the application that has invoked the wizard or other applications to gather information with which to answer a question presented by the wizard. In various usability studies, users have complained that they feel forced down a particular, and unknowingly lengthy, path by a wizard. In certain wizards, the Next button  is unclickable until a user has answered the presented question, thereby preventing the user from skipping a question that the user has insufficient information to answer. Another problem is the lengthy linear sequence of screens of wizards. A user may have sufficient information to answer many screens of questions only to find out near the end of the wizard screens that a question cannot be answered, thereby forcing the user to quit the wizard prior to completion. A further problem is that wizards must follow a rigid dialog template without deviation. Besides the fixed screen dimensions within which the wizard is presented to the user, navigational facilities within the wizard are limited to the Back button , the Next button , or the cancel button . Given these constraints, a wizard is more appropriately used in the context of a help utility rather than as a user interface for complex applications.","The linear rigidity employed by wizards to force a user to interact in a specific manner in order to accomplish a desired task is overcome by Web-style applications, such as Microsoft\u00ae Money 2000. An example of a Web-style application  is shown in . A Web-style application is not a Web site, but it shares many properties in common with Web sites. The user interface of the Web-style application  shown in  consists of a plurality of full-screen pages , , and  shown in a shared frame  with tools for navigation, such as a Back button , a Forward button , and a Home button . The user interface of the Web-style application  may also include a title bar and a close box like the wizard , but are not shown here for brevity purposes. The shared frame  includes a navigation bar  that contains the name of the page being displayed in the shared frame , as well as the navigation controls, i.e., the Back button , the Forward button , and the Home button .","The first page of the Web-style application  is a Home page , which includes a list of tasks that a user can select to be performed. The tasks are invoked by clicking on a hyperlink, such as a pay a bill hyperlink , a balance an account hyperlink , or a track a stock portfolio hyperlink . When one of these hyperlinks - is activated, a \u201cprocess,\u201d which consists of a page or series of pages that are employed to perform the selected task, is invoked.","In the example shown in , a process  is invoked when the user selects the pay a bill hyperlink . The invoked process  includes two pages , . A number of exemplary payable bills are presented on the first page , namely, a Cablevision bill , an AT&T bill , and a City Power bill . Each of these bills - is presented as a hyperlink. Clicking on one of these hyperlinks causes the bill associated with the hyperlink to be paid, as noted in the title bar . The first page , additionally, allows a user to view bills that are one month away by clicking on a hyperlink . When hyperlink  is clicked on, the second page  is shown. The second page lists an exemplary bill from MSN. This bill is associated with a further hyperlink . Clicking on the further hyperlink  causes the bill from MSN to be paid (as noted in the title bar ). When a user is finished with the bill paying task, the user may click on another hyperlink  titled, for example, \u201cI am done paying bills.\u201d When this hyperlink is clicked, the Web-style application  automatically represents the Home page , i.e., the page from which the user initially launched the bill paying process .","This behavior of always returning a user to the page that launched the invoked process is not achieved through a hard-coded hyperlink on the final screen of the process, such as the last page  of the process . This is because the destination of the final hyperlink may vary and a hard-coded hyperlink cannot anticipate the precise launching page from which a process is invoked. Instead, the Web-style application  implements the behavior of always returning a user to the page that invoked a process in a different way. More specifically, the Web-style application  maintains a stack of launching pages that are independent of the normal navigation offered by the Back button  and the Forward button . When a user launches a process, the launching page is pushed onto the stack. When a user clicks the done hyperlink on the final screen of the process, the Web-style application  pops the most recent launching page off the stack and returns the user to that page.","Unlike the linear rigidity associated with the wizard  illustrated in  and discussed above, at any point during the operation of the Web-style application , a user may navigate backward or forward from any page, even the pages included in an invoked process, such as the process . When a user does navigate away from a page in a process, the page that launched the invoked process remains active on the stack. Thus, the user can still complete the process by backing up to the page where he left it and will always be returned to the launching page because of the stack. This process allows a user to make a detour or back up, and then go on with a process. Thus, the non-linear structure of Web-style applications overcomes many of the limitations of wizard-type applications.","The dynamism of the user interface of a Web-style application that allows a user exploration is ensured by the steadfastness of the stack in that the stack always returns the user to the launching page from which a process is invoked. While a significant advance, the constant interposition of launching pages can hinder Web-style application from forming super-processes that comprise the functionalities of two or more processes. This hindrance is illustrated in , which shows a Web-style application  at a macroscopic level, i.e., without a shared frame and page details. A Home page  includes a hyperlink that, when clicked, brings a user to a Launching page . The Launching page  contains one or more hyperlinks, including a hyperlink to invoke a first process . When the first process  is invoked, the Launching page  is placed on a stack, and the first page, page A , of the process  is displayed. As discussed before, a user may navigate away from the pages of the process , or the user may navigate through the first process  by working with the pages of the process, namely, page A , page B , and the final page, page C , to complete the task associated with the process. The Launching page  is popped from the stack and represented to a user when a hyperlink on first page C  of the first process  is selected to indicate the completion of the task associated with the process .","If the user desires to perform a second task associated with a second process , the user must click another hyperlink contained on the Launching page . Clicking this hyperlink causes the first page of the process , page X , to be displayed. From page X , the user can progress to the next page Y  and then to the final page, page Z , to complete the second task. Similar to the invocation of the first process , the Launching page  is again pushed onto the stack prior to the presentation of the pages of the second process . At the conclusion of the second task, the Launching page  once again is popped from the stack and represented to the user.","In the past it has not been possible for a designer of the user interface of the Web-style application  shown in  to combine the functionality of a first process  with the functionality of a Web-style application, such as a second process , while keeping each of the process pages - separate so that each page can be used in other contexts. The undesired interposition of the Launching page  in the Web-style application  prevented a seamless user interface experience between the presentation of the pages of the first process  and the presentation of the pages of the second process . The only way to provide the functionalities of both of the processes ,  is to combine the pages of each of the two processes ,  in another process.","Besides the problem of assembling two or more processes without interference by the interposition of the launching pages, the processes of previously developed Web-style applications are designed with no thought that these processes may be reused to form new functionalities in other applications. This problem is better illustrated in , which shows a partial navigational flow  taken from a Web-style application of the type shown in . The partial navigational flow  includes the Launching page  from which the first process  is invoked. The first page of the first process  is page A  and the remaining pages are page B  and page C . When exiting from the process , the Launching page  is popped from the stack and represented to the user.","As shown, each of the pages - is tightly coupled to a database  where data is shared. To use the database , each of the pages - must intimately know all the data that can be written to or read by the other pages. Otherwise, one page could mistakenly access and change data in the wrong place in the database  resulting in the corruption to the rest of the pages and possibly detrimental repercussions to the Web-style application . Unfortunately, this requirement results in the data in the database  being vulnerably exposed by necessity to all of the pages -. The lines A-J are included to show the data access paths of the pages -.","To summarize, in the past, Web style applications were developed separately from one another. It was not envisioned that the processes employed by Web-style applications might be used outside the context of Web-style applications for which they were designed. This resulted in Web-style application processes being tightly coupled to a data source, such as the database , which is specific to a particular application domain. As a result, prior Web-style applications are Web-like only in that the pages and the pages in the processes are linked together in a complex, non-sequential web of associations in which the user may browse in a single application. However, a process in one Web-style application cannot access a process in another Web-style application unless the data of one application is completely exposed to the other application. This presents a serious security problem. Additionally, this is similar to the proscription in computer science of the use of global variables to store states across functions because global variables limit reuse and make understanding code difficult.","The problem of tight coupling is further illustrated in , which illustrates a first process  of the type associated with the Web-style application  shown in  and a further process  associated with another Web-style application. As discussed before, the pages of the first process  (page A , page B , and page C ) are tightly coupled to a first database . The pages of the further process , which includes page U , page V , and page W , are tightly coupled to another database . The lines C-G are included to show the data access paths of the pages of the first process , and the lines A-F are included to show the data access paths by the pages of the further process . Given the tight coupling between the first process  and the first database , and the tight coupling of the further process  and the second database , it is difficult to combine the functionality of the first process  and the functionality of the further process . To do so would require a user interface designer to be intimately familiar with the relationship between the first process  and the first database , and the further process  and the second database . Not only would this be a time-consuming undertaking, but it may also hinder the efficiency of designing and improving Web-style applications.","As noted above, exposure of the data of a process poses a security risk. For example, suppose that the first process  and its database  are designed by Corporation A, and the further process  and its database  are designed by Corporation B. Suppose further that it would be synergistic for the functionality of the first process  to invoke the functionality of the further process . The only way to do so at present is for Corporation A to completely expose the data associated with the first process  stored in its database  to Corporation B, and for the Corporation B to completely expose the data associated with the further process  stored in its database  to Corporation A. Such exposure creates a security risk for Web-style applications designed by both Corporations A and B.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 3D","FIG. 3D","FIG. 3D"],"b":["306","326","350","352","354","356","360","358","358","350","360","348","348","306","350","306","326","350","360","306","350","306","350","306","350"]},"Thus, there is a need for an architectural software framework for designing Web-style applications that incorporates protocols and means for expansion and interfacing with other Web-style programs, as well as a reusable basic programming structure that assists in building secured Web-style applications, while avoiding the foregoing and other problems associated with existing Web-style applications.","In accordance with this invention, Web-style applications produced from an architectural software framework that includes one or more page functions are provided. Page functions are not the same as the pages of Web-style applications of the type described in the Background of the Invention. Each page function includes: a set of page function attributes, including strongly typed input parameters and return values, a set of page function services, and user interface page elements. Page function attributes can be exposed or hidden. Hidden attributes are private to the internal working of the page function; they are not known nor can they be accessible by other page functions. Exposed attributes are available to other page functions. Exposed attributes can be used to put information into or to take information out of a page function so that each page function may perform its intended task. Hiding details of a page function that are not necessary to know in order to invoke the functionality of the page function addresses the tight coupling and security problems of prior Web-style applications.","In accordance with other aspects of the present invention, a computer-readable medium storing data types as page functions for display on a computer system is presented. Each page function comprises a set of exposed attributes, a set of page function services, and user interface elements. The set of exposed attributes includes two subsets: a first subset defining types of information receivable by the page function and a second subset defining types of information returnable by the page function. The exposed attributes that define types of information returnable by the page function are strongly typed. The set of page services includes an activate service and a complete service. Both services are invocable to execute a decision selected from a group consisting of a decision to finish, a decision to show user interface elements, and a decision to create a new page function.","In accordance with further aspects of the present invention, a programming system having a computer-readable medium storing an architectural software framework is presented. The architectural software framework comprises a first data type defined as a page function and a second data type defined as a frame. The page function data type includes a set of exposed attributes, a set of page function services, and user interface elements. The set of exposed attributes includes two subsets: a first subset defining types of information receivable by the page function and a second subset defining types of information returnable by the page function. The exposed attributes that define types of information returnable by the page function are strongly typed. The set of page services includes an activate service and a complete service. Both services are invocable to execute a decision selected from a group consisting of a decision to finish, a decision to show user interface elements, and a decision to create a new page function. The user interface elements may be selectively displayed on the display. The frame data type includes a set of frame services, including a navigate service and a finish service, and a frame data structure. The navigate service navigates to a second page function and the finish service communicates to the frame that the page function is complete. The frame data structure stores information that identifies each page function to which the frame has navigated and shows the originator relationships among page functions.","In accordance with yet further aspects of the present invention, a computing environment for displaying user interfaces on an output device in a Web-style manner is presented. The computing environment includes an output device, an input device, and a program interface module. The program interface module exposes an interface that, when invoked, creates a page function and selectively displays user interface elements of the page function on the output device. The page function comprises a set of exposed attributes, a set of page function services, and user interface elements displayable on the output device. The set of exposed attributes includes two subsets: a first subset defining types of information receivable by the page function and a second subset defining types of information returnable by the page function. The exposed attributes that define types of information returnable by the page function are strongly typed. The set of page services includes an activate service and a complete service. Both services are invocable to execute a decision selected from a group consisting of a decision to finish, a decision to show user interface elements, and a decision to create a new page function. The user interface elements may be selectively displayed on the display.","According to yet further aspects of the present invention, a computer-readable medium having computer-executable instructions that when executed on a computer system implement an application programming interface module exposing a programming interface. When invoked, the programming interface creates a page function and selectively displays user interface elements of the page function on an output device.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 4","b":["400","400","400"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well-known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention is described in the general context of computer-executable instructions, such as program modules being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types.","The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media, including memory storage devices.","With reference to , a system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures, including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example and not limitation, such bus architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus, also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information, such as computer readable instructions, data structures, program modules, or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory, or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tapes, magnetic disk storage or other magnetic storage devices, or any other computer storage media. Communication media typically embodies computer readable instructions, data structures, program modules, or other data in a modulated data signal, such as a carrier wave or other transport mechanism that includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example and not limitation, communication media includes wired media, such as a wired network or direct-wired connection, and wireless media, such as acoustic, RF infrared, and other wireless media. A combination of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory, such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS) containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible and\/or presently being operated on by processing unit . By way of example and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates the hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk , such as a CD-ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital videotapes, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface, such as interface , and the magnetic disk write  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in  provide storage of computer readable instructions, data structures, program modules, and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices, such as a keyboard  and pointing device , commonly referred to as a mouse, trackball, or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port, or universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices, such as speakers  and printer , which may be connected through an input\/output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device, or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such network environments are commonplace in offices, enterprise-wide computer networks, intranets, and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the input\/output peripheral interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are for illustrative purposes only and other means of establishing a communications link between the computers may be used.","As illustrated in , the invention provides an architectural software framework  designed to overcome and\/or reduce the problems discussed in the Background of the Invention. The architectural software framework  creates Web-style applications. Two of the major pieces of the framework, namely a frame  and a page function , are illustrated in  and described below.","Each Web-style application includes one or more page functions, only one of which is illustrated in . The illustrated page function  includes a user interface page  that contains user interface elements, such as one or more hyperlinks for interacting with a user. While the pages of prior Web-style applications have a Web-like user interface, they lack the software component formed by the page function . The user interface page  may be bound to the page function  by a binding . The binding  allows the page function  to be associated with the user interface page  or not associated therewith. One suitable technique for creating a binding includes setting a pointer variable in the page function  that points to the user-interface page . Other binding techniques may also be employed. The ability of the page function  to be selectively associated with a user interface page  allows the page function  to be invisible to a user and act as an intermediary to seamlessly join together the functionalities of page functions.","To invoke the page function  to perform a certain task, a protocol provided by the architectural software framework  is followed. A line  represents the invocation of the page function . The invocation of the page function  generally requires that one or more parameters be supplied to the page function  in order for it to perform a designated task. Once the page function  is finished with the task, the page function  returns one or more values associated with the performed task. This is represented by a line . This protocol for invoking the page function  and returning the result of the performed task allows the page function  to be combined with other page functions to create functionality different from the one offered by the page function . Additionally, this protocol allows the page function  to interface with other page functions. According to aspects of the present invention, the page function  returns it's one or more return values according to a predetermined definition of the page function. Those skilled in the art will recognize that returning values according to a predetermined definition is frequently referred to as strong typing of the page function .","Programming faults, incorrect run-time results, system crashes, and the like often occur when the caller of a page function  erroneously expects a return result in a particular format, such as an integer, but instead receives the result in a different format, such as a character string. When this occurs, it is truly anyone's guess what will be the actual result. Whatever the result, it would be very unlikely to be the correct, or desired, result. Thus, one of the advantages realized by strong typing, or strongly typing a page function , is that errors resulting from erroneously expecting a return value in a particular format are caught at compilation time, i.e., while the developer is writing the source code. By requiring strong typing for page functions, a compiler will detect an erroneous return format assumption, or in other words, the error is found during compilation. Accordingly, the page function's programmer is advised of the erroneous assumption during the compilation phase, and can correct the error before the page function  is release for actual use.","Page functions are strongly typed according to explicit definition of a particular page function. Strong typing may include both the input parameters to a function, as well as the return values. As mentioned above, the input parameters provided to a page function, as well as the return results may be strongly typed.  are block diagrams illustrating exemplary code samples for creating instances of page functions according to strongly typed definitions.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 11A","b":"1100"},"As shown in , the class definition for a generic PageFunction  includes a \u201cplaceholder\u201d . Those skilled in the art will recognize that when creating an instance of a page function using the Generic PageFunction definition , the place holder  will be replaced by another known type. The PageFunction definition  includes, among other things, an event handler variable Return . This event handler variable is declared in such a way such that the actual type is dependent upon the substitution of the placeholder . An additional Generic class ReturnArgs  also includes the placeholder . The ReturnArgs class  represents the values that will be returned. By substituting the placeholder  with a concrete type, an instance of the page function will have return values that are strongly typed according to the substitution. The code that follows the two definitions is illustrative of the substitution and strong typing.","Line  shows how a page function that includes return values of type \u201cstring\u201d is created. The placeholder  described above is replaced by an actual type \u201cstring\u201d  when creating an instance of the page function and stored in the variable stringPF . A call to the constructor similarly replaces the placeholder  with the same concrete type string . This line illustrates the strong typing involved, as the assignment does not require a casting operation for a particular type. The compiler is aware of the types, according to the substitutions, and does not require a type casting.","Line  further illustrates the strong typing which takes place. The variable stringPF , being a page function, includes a variable \u201cReturn\u201d , as per the definition of the class. Because the Return variable  has already be defined with a particular concrete type, i.e., string, no type casting is needed when an event handler is created by properly substituting its placeholder with the correct type, string . Further, on line , the output of ra.Result  need not be type cast because of the strong typing that has taken place in creating the ReturnArgs  class.","As illustrated by lines  and , to create an instance of a page function object, a program invokes the constructor of the object class, PageFunction. Further, according to one embodiment of the present invention, page functions are able to return values to callers using a delegate, or handler routine. Line  illustrates the assignment of a handler routine to the stringPF.Return variable , specifically, \u201cReturnEventHander<string>(OnStringPageFunctionReturned)\u201d.","While Generics, or templates, are advantageously used to combine multiple types of values into one definition, specific definitions of a class for each desired concrete type may also be used.  illustrates examples of an explicitly defined, strongly typed class of functions for creating concrete typed object instances. In particular, segment  illustrates a definition for a page function class returning a string value, segment  illustrates a definition for a page function class returning an integer value, and segment  illustrates a definition for a generic \u201cobject\u201d class returning an object. While  illustrates certain examples of strongly typed classes for creating concrete objects of specific types, these are for illustration purposes only, and should not be construed as limiting upon the present invention. Those skilled in the art will recognize that there are other atomic types, which may be provided, as well as an innumerable number of user created types, including user created structures.","While the above described examples are put forth in a particular pseudo-code format, it should be understood that they are illustrative only, and should not be construed as limiting upon the present invention. Strong typing may be performed in many ways, and creating class definitions that accept strongly typed input parameters and return strongly typed return values is just one such manner.","With reference again to , the frame  includes a user interface .","The user interface  of the frame  includes a title bar , a set of navigational buttons of which only a Back button  is shown, and a region  where the user interface page  of the page function  is displayed. (The shared frame  of the Web-style application  shown in  lacks the software component of the architectural software framework  identified as the frame .) The frame  contains logic and a data structure that facilitates the protocol employed to invoke the page function  as well as the protocol employed to facilitate the returned values as a result of the performance of a task by the page function . The facilitate ability allows the frame  to mediate the communication between any page functions. As long as a page function can communicate with the frame , a page function should be able to communicate with other page functions via the frame.","The page function  is a self-contained unit of software. To use or invoke the software, a programmer (or hereafter, \u201cuser\u201d) only needs to follow the protocol. This protocol would then include the strong typing of both input values or parameters to the page function , as well as the return values. The user does not have to know the internal working and data arrangement of the page function . This notion of a self-contained unit of software is further enhanced by strongly typing both the input parameters, as well as the return results. In this way, the page function  overcomes the tight coupling problem described above, and becomes a reusable basic programming structure that can be used within a single program, or distributed to other programs. The frame , as a mediator between a first page function and another page function, provides another level of decoupling. The first page function need not know the intimate detail of the other page function in order to use the services provided by the other page function. The first page function need only know how to invoke the other page function, i.e., the strongly typed input parameters, and what will be returned, i.e., the strongly typed return values. The frame  guarantees that a desired page function will be invoked if the invoking page function follows the established protocol provided by the architectural software framework .","While the above described components illustrate the page function  as being a separate component from the user interface page , according to an alternative embodiment, the user interface aspects of the user interface page are combined into the page function.  is a block diagram illustrating an alternative embodiment of the pieces of an architectural software framework  to design Web-style applications, and particularly, a frame, a user interface of the frame, and page function combined with user interface elements. Similar to the configuration described above in regard to , this embodiment includes a user interface  of the frame , as well as an enhanced page function  that, instead of including a reference to a user interface page, includes the user interface page elements in the page function. All other aspects, including communication between the frame  and the page function  occur as described above in regard to .","The protocol of communicating between the various elements of the software architecture referenced above will be better understood by reference to , which illustrates the use of the protocol with a Web-style application . The Web-style application  includes a starting piece of code , such as a main routine (e.g., main( )) that can be enabled to activate a set of page functions, which comprise a parent page function  or a child page function . The user interfaces of the page functions, as well as the frame, are not shown in  in order to better focus on the flow of the protocol. When the Web-style application  is launched, the starting process  requests a frame  to navigate to the parent page function . This action is represented by a first invocation line . The frame , in response, activates the parent page function . This action is represented by a second invocation line .","Upon activation, the parent page function  makes one of three choices: to finish, to display its user interface page, or to create a new page function. Suppose that the parent page function  has been designed to automatically choose to create a new page function without displaying its user interface page. The parent page function  then creates the child page function . The parent page function  then requests the frame  to navigate to the child page function . This action is represented by a third invocation line . In response, the frame  activates the child page function . This action is represented by a fourth invocation line .","Upon activation, the child page function  makes one of three choices similar to the choices presented to the parent page function , namely, to finish, to display its user interface page, or to create a new page function. The child page function  performs its task and decides to finish. This decision to finish need not be made every time a page function has performed its designated task. For example, the child page function  may display its user interface page instead so as to receive input from a user, but to better illustrate the flow of the protocol, the child page function  decides to finish after its task is performed. The child page function  notifies the frame  that it is finished. This action is represented by a fifth invocation line . Then the frame  notifies the parent page function  that the child page function  has completed its task. This action is represented by a sixth invocation line .","Having confirmation that the task of the child page function  is finished, the parent page function  is once again presented with three choices: to finish, to display its user interface page, or to create a new page function. The parent page function  decides that its task is also finished and proceeds to notify the frame . This action is represented by a seventh invocation line . Finally, the frame  informs the Web-style application  that all tasks have been performed by the page functions. This action is represented by an eighth invocation line . Then, the Web-style application  exits.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":["FIG. 5B","FIG. 5B","FIG. 9","FIG. 5B"],"b":["515","518","516","524","524","532","518","524","526","524","518","524","526","528","524","1530","524","518","534","518","520","516","522","515","516","524","516","524","515"]},{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 5C","b":["514","514","538","514","514","500","514","514","514","514"]},{"@attributes":{"id":"p-0093","num":"0092"},"figref":"FIG. 6A","b":["502","500","502","503","502","504","502","503","502","504","502","502","502"]},"As shown in , the page function  includes a set of page function attributes , which are properties or data fields in which data is stored and accessed in the performance of a task. The page function  also includes a decision engine  that defines the behavior of the page function . Additionally, the page function  includes a set of page function services . The set of page function services  is used to invoke the page function  and notify the page function  when another page function (not shown) has performed a desired task.  illustrate the set of page function attributes , the decision engine , and the set of page function services  in greater detail.","As shown in , the set of page function attributes  includes one or more parameters , one or more return values , and an identifier . The one or more parameters  are exposed so that information may be provided externally to the page function  for it to perform a certain task. These parameters  are generic in the sense that any type parameter may be specified as needed for the page function  to perform its designated task. When the page function  is invoked, these parameters  should be filled out with information of the correct data type. Strongly typing the page function , and in particular the parameters , ensures that the parameters are filled out with information of the correct type. This ensures that the invoked page function at least operates on values of the correct type.","As described above and discussed more fully below, the page function  may invoke another page function to perform another task. When that task is finished, the result of the task performed by the other page function is returned to the page function  via one or more returned values . As shown in , the returned values  are also a part of the set of page function attributes . Like the parameters , the return values  are publicly exposed. Additionally, the return values  are also strongly typed. Thus, correct data typing is enforced at compilation time, thereby reducing the possibilities of errors occurring in regard to the return values during execution.","The page function  also has a hidden or private set of page function attributes (not shown). The hidden attributes need not be known externally for the page function  to perform its task. The use of exposed and hidden attributes overcomes the tight coupling problem described above. The strongly typed parameters  and the strongly typed return values  require minimal coupling. Minimal coupling is required because the page function  has to communicate with the outside world for it to perform its task. The parameters  allow the page function  to receive information, and the return values  allow the page function  to receive results from other page functions.","The set of the page function attributes  also includes an identifier  that uniquely distinguishes the page function  from other page functions. More specifically, if the page function  were a class in the sense of object-oriented methodology, each instance of the page function  can have an identifier value stored in the identifier  that is different from an identifier value of another instance of the page function . This identifier  is used in the architectural software framework  to track page functions as well as to identify relationships between page functions, as illustrated in  and described more fully below. In one embodiment, these relationships are established at runtime according to what page functions are called as an application executes.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":["FIG. 6C","FIG. 3A"],"b":["604","614","616","618","502","614","604","614","506","506","614","610","502"]},"As previously described, the page function  may be bound to a user interface page  via a binding . In a conventional manner, the user interface page  receives input events from the user, and the user interface page communicates the input events to the page function  via any suitable means, such as an event queue. As also previously described, the page function  may not have an associated user interface, and in such a case, no binding  exists, or the binding  is bound to nothing. Even if the page function  is bound to the user interface page , the presentation of the user interface page  can be controlled by the decision to show a user interface page  of the decision engine . This control allows the page function  to hide its user interface page  if desired. Hiding a user interface page permits the seamless joining to other page functions, which is not possible in the prior art as discussed above with reference to .","The page function  may invoke another page function by executing the decision to create a new page function . When a new page function is created, the page function  may furnish parameters to the newly created page function, or the furnishing of parameters can be delayed until the frame  navigates to the newly created page function (discussed below).","The decision engine  defines the core behavior of the page function . The decision engine  allows invoked page functions to naturally return to the originator page function. The decision engine also allows the user interface of the page function  to be selectively displayed. Thus, the decision engine  guarantees a core behavior that allows for the expansion of page functions into many different applications, while allowing the page functions in different applications to interface with each other.","The set of page function services  is illustrated in  and described next. An activate service  is used to activate the page function . More specifically, the page function  is invoked by furnishing one or more parameters to the page function  according to the strongly typed definition of the page function , and invoking the activate service . Although the parameters may be provided along with the invocation of the activate service , this is not required because these parameters  are exposed. Because the parameters  are exposed, the parameters can be directly accessed. Because the parameters can be directly accessed, the parameters do not have to be supplied when the activate service  is invoked. For example, when an invoking function (not shown) invokes the page function , the invoking function may supply the parameters  along with the invocation of the activate service . Or, the invoking function may directly access each parameter of the set of parameters  and insert the appropriate information into the parameter.","A complete service , when it is invoked, notifies the page function  that a task performed by another page function (not shown) is finished. When the complete service  is invoked, the identifier of a page function called or invoked to perform the required task is furnished. One or more return values  associated with the performed task are also furnished when the complete service  is invoked. Receipt of the complete service  lets the page function  know that one of its invoked page functions is finished, and that the navigational flow has returned to the page function .","Both the activate service  and the complete service  execute one of the three decisions associated with the decision engine  and discussed above with reference to . The three decisions allow the page function : to quit (decision to finish ); to present and receive information from the user by displaying the user interface page  (decision to show a user interface page ); or to invoke another page function (decision  to create a new page function). The latter decision may be made because, for example, the page function  lacks the functionality that is possessed by the other page function. In any event, one of the three decisions is made when the page function  is activated and when returning from the performance of a task by an invoked page function.",{"@attributes":{"id":"p-0106","num":"0105"},"figref":["FIG. 6E","FIG. 6E"],"b":["502","500","600","500","502","502","600","626","502","626","502","628","626","628","628","500","640","626","602","502","630","626","632","604","502","626","634","634","620","622","606","502","620","622"]},{"@attributes":{"id":"p-0107","num":"0106"},"figref":"FIG. 6E","b":["626","638","502","502","640","638","628","626","623","626","638","638","638","640","640","638","644","638","626","626","638"]},"As with other page functions, page function Two  includes a set of page function Two attributes , a decision engine , and a set of page function Two services . Like page function One , the set of page function Two attributes  include the parameters required for page function Two  to perform and the ability to return values from other page functions invoked by page function Two . The three core decisions of the decision engine  of page function Two  are inherited from the decision engine  of the generic page function . The set of page function Two services  includes at a minimum both the activate services  and the complete service  of the page function .",{"@attributes":{"id":"p-0109","num":"0108"},"figref":["FIG. 7A","FIG. 7A"],"b":["700","704","712","702","706","704","708","710","704","712","710","714","712","702","704","712","704","712"]},"The second collection of page functions  also includes two additional page functions, identified as page N  and page O . When the user exits from page O , which is the last page function of the second collection of page functions , the user is automatically navigated to the Home page , which launched the first collection of page functions .","The Web-style application  shown in , which uses one or more page functions, should be contrasted with the Web-style application , shown in , which uses Web-like pages. As shown, the first collection of page functions  is integrated to the second collection of page functions  without an interposing launching page. This difference increases the flexibility of the architectural framework  because it allows different functionalities of page functions to be combined together. This allows page functions to expand beyond the separate designs.",{"@attributes":{"id":"p-0112","num":"0111"},"figref":["FIG. 7B","FIG. 7A"],"b":["704","712","703","702","702","704","702","703","701","701","701","707","707","706","706","707","707","701"]},"Following a sequence of creation and navigation similar to the process discussed above with respect to page function J , page function One  sequentially creates and navigates to two further additional page functions, identified as page function K  and page function L . When the user has accomplished the task associated with the user interface page , associated with page function L, page function L  navigates the process back to page function One . Page function One  returns process control to the Home page function . During processing of the first collection of page functions , only the associated user interface pages - are displayed to the user. Because the page function One  does not have an associated user interface page, page function One, it is invisible to the user.","After processing, control returns to the Home page function , the Home page function  executes a decision to create another page function, identified as page function Two , and to activate page function Two. This occurs without displaying the Home interface page . This results in the first collection of page functions  being seamlessly integrated with the second collection of page functions  without a user interface page  being interposed in between the first and second collections of page functions.","Similar to the first collection of page functions , page function Two  creates a first page function identified as page function M , which displays its related user interface page . When the task associated with page function M  is finished, page function Two  creates another page function, identified as page function N , which displays its related user interface page . When the task associated with page function N  is accomplished, page function Two  creates a further page function, designated page function O , which displays its related user interface page . For purposes of this description, page function  is the last page function. Process control returns to the Home page function  when the task associated with page function O  is finished. When this occurs, the user interface page of the Home page function , i.e., the Home interface page , is again displayed to the user as shown in  and discussed above.",{"@attributes":{"id":"p-0116","num":"0115"},"figref":["FIG. 7C","FIG. 7A","FIG. 7B","FIG. 7B"],"b":["704","712","703","702","704","703","701","701","701","707","706","707","709","707","701","709","707","709","709","708","709","711","701","711","711","709","711","710","711","709","707","701","703","704"]},"The Home page function  next proceeds to create and navigate to page function Two . Again, this occurs without displaying the user interface page  associated with the Home page function. As with , the page function Two  first invokes page function M . As a result, the user interface page  associated with page function M  is displayed. When the task associated with page function M  is finished, rather than returning to page function Two, page function M  invokes page function N . As a result, the user interface page  associated with page function N  is displayed. When the task associated with page function N  is finished via the interaction of the user with the user interface page , the process returns to page function M  and, then, to page function Two . Next, page function Two  invokes page function O . As a result, the user interface page  associated with page function O  is displayed. When the task associated with page function O  is finished, the process returns to page function Two  and, then, to the Home page function . This return results in the user interface page  associated with the Home page function  being again displayed.","The integration between the first collection of page functions  and the second collection of page functions  resulting from the process illustrated in  is the same as the integration resulting from the process illustrated in . Identical results are possible because the Home page function  has the ability to withhold the presentation of its associated user interface page . Thus, the navigation from the last page of the first collection of page functions  to the first page of the second collection of page functions  appears to be seamless.  illustrate the different ways in which page functions may be linked together using this invention. In  example, the user interface pages of both the first collection of page functions  and the second collection of page functions  are limited such that the user interface pages always return to either page function One  or page function Two . In  example, page function One  is linked only to page function J . Page function J  is linked to page function K  and the page function K  is linked to page function L . Additionally, page function Two  linked to page function M  and to the page function O . Page function N  is linked to page function M . These exemplary different linking combinations indicate the variety of ways one page function can be linked to another page function.","In , page functions J , K , and L  do not need to know the parameters\/return values for each other because page function One  calls all three. In , page function J  does need to know the parameters\/return values for page function K  because page function J  calls page function K . Furthermore, in , page function J  will need to handle the situation where page function K  completes (it will have to account for completion of page function K in choosing one of its three decisions). In , page function J  does not need to know anything about page function K.","The architectural software framework  allows Web-style applications having means for expansion and interfacing with other Web-style programs to be readily designed. The architectural software framework  also provides a reusable basic structure, for creating Web-style applications comprised of one or more linked together page functions. As discussed next with reference to , because Web-style applications formed in accordance with this invention are more Web-like than the prior art, they can be linked to regular Web pages.",{"@attributes":{"id":"p-0121","num":"0120"},"figref":"FIG. 7D","b":["702","704","724","726","728","500","728","730","500","500"]},{"@attributes":{"id":"p-0122","num":"0121"},"figref":["FIG. 7E","FIGS. 7D-7E"],"b":["730","500","500","500"]},"As noted above and illustrated in , the architectural software framework  includes both the page function  and the frame . The foregoing discussion of  and A-D has focused on page functions and the navigation flow between page functions without discussing the frame . As will be better understood from the following description, the frame  mediates navigation from one page function to another page function.","As shown in , the frame  employs a set of frame services  and a frame data structure  for mediating between page functions. Page functions that seek to invoke another page function use the set of frame services  to notify the frame . The frame  uses the frame data structure to keep track of which page function has invoked another page function.",{"@attributes":{"id":"p-0125","num":"0124"},"figref":"FIG. 8B","b":["806","506","806","810","810","810","810","506","506","506"]},"The set of frame services  also includes a finish service . The finish service  is invoked by the child page function when a child page function has accomplished the task requested by a parent page function. The finish service is used to notify the frame  when the child page function has completed its task. When the frame receives a notification that the task of a child page function is finished, the frame  employs the complete service of the parent page function to notify the parent page function of the completion. The finish service , like the navigate service , provides an orderly protocol that advises the frame  when the child page function has ended because the requested task has been performed.",{"@attributes":{"id":"p-0127","num":"0126"},"figref":"FIG. 8C","b":["808","506","808","814","816","818","820","822","824","826","828","506","818","816"]},"The tree  provides the frame  with knowledge about the relationship between page functions. The tree  is not the history of links followed using the navigational tools, such as the Back button , of the user interface  of the frame . Instead, the tree  captures each invocation of the navigate service  of the set of frame services .",{"@attributes":{"id":"p-0129","num":"0128"},"figref":["FIG. 8D","FIG. 8D"],"b":["814","832","834","832","834","816","814","832","810","834","506","832"]},"The frame data structure  also includes a set of data structure services , which is shown in detail in . The set of data structure services includes at least a create node service , a create relationship service  and a remove service . The create node service  is invoked whenever the navigate service  is invoked. The proper invocation of the create node service  includes a parameter that contains the identity of the invoked child page function. This identity of the child function is stored in the identifier  of a node created by the create node service , and thus each node specifically identifies a child page function to which the frame  has navigated. For example, when the parent page function associated with node A  navigates to the child page function for which a node has not been created yet in the tree , the create node service  is invoked to create, for example, node B , to represent the child page function to which the frame  has navigated. At the same time, the create relationship service  is invoked to link node A  to node B . As a result, the frame  knows the parent-child (invocative) relationship between these two nodes.","The remove service  includes a parameter that identifies a parent page function. The remove service  allows a set of nodes within the tree  to be removed from the tree  for security purposes or other purposes. For example, it can be difficult or undesirable to allow a user to run through certain page functions to which the user has already visited or navigated. The canonical example here is a user who has just finished buying something on the Web. If at this point he backs up and presses the \u201cOrder Now\u201d button again, it is not clear whether he meant to change or replace his existing order, or make a second purchase. The clearest thing to do might be to prevent a user from getting into such a situation by removing page functions associated with the buying process by removing the nodes representing these page functions in the tree  when the order is successfully placed. As another example, suppose a page function is associated with a network adapter that has just removed. It does not make sense for a node that represents this page function to remain in the tree , and this node should be removed. As a further example, suppose nodes C , D , E , F  comprise a collection of page functions in a portion of a Web-style application that requests a user to input a credit card number in order to purchase a plane ticket. For security purposes, once a purchase has been made, these nodes should be removed. This is accomplished by invoking the remove service  and providing the identity of the parent page function associated with node C .",{"@attributes":{"id":"p-0132","num":"0131"},"figref":["FIGS. 10A-10F","FIG. 9"],"b":["1000","1000","1002","1000","1004","900","906","906","906","900","1006","900","904","906","900","906","904","1008"]},"In response to the request to navigate, at block , the frame  creates a first node to represent the parent  in the frame data structure. Because the identifier of the parent  was provided, the frame  causes the first node in the frame data structure to contain the identifier of the parent . See block . Next, the process  proceeds to a block  where the frame  activates the parent  by invoking the activate service of the parent . Here, the process  proceeds to a process continuation terminal (\u201cterminal A\u201d). From terminal A (), the process  enters a block  where, along with a request to activate the parent , the frame  provides one or more parameters, which are provided by the Web-style application , to the parent. Next, at a decision block , the parent  decides whether it has completed its task. If the answer is YES, the process  proceeds to another continuation terminal (\u201cterminal B\u201d).","From terminal B (), the process  proceeds to a block  where the parent  notifies the frame  that the task of the parent is finished. Along with the notification, the parent  sends its identifier to the frame . See block . Frame notification is accomplished by the parent  invoking the finish service of the frame . Next, a test is made (decision block ) to determine if the parent  has requested that the node representing the parent  in the frame data structure and all of the parent's children nodes be removed. If the decision is YES, the process flow proceeds to a block  where the frame  removes the node representing the parent  and all of the parent's children nodes from the frame data structure. If the decision is NO, or after the parent and its children have been removed from the frame data structure, a block  is entered. At the block , the frame sends an exit signal to the Web-style application  indicating that all the tasks have been performed and the Web-style application  may exit from the operating system. In response to the exit signal, the Web-style application  quits (block ), and the process  ends.","Returning to , if the answer at decision block  is NO, another decision block  is entered. At decision block , the parent  decides whether to show the user interface page associated with the parent . If the decision is YES, at block  the user interface page of the parent  is displayed in the user interface of the frame . At this point in the process, the user interface page of the parent  waits for the user to provide input. A decision block  along with its NO branch captures this waiting process. When the user interacts with the user interface page of the parent , the answer to decision block  is NO and the process loops back to decision block . When the user interacts with the user interface page of the parent , the answer to decision block  becomes YES and the process  proceeds to a block . At block , the parent  processes the user's action, which was captured by the user interface page of the parent . When processing of the user's action is completed, the process  cycles back to decision block .","If the answer to decision block  is NO, the process proceeds to a decision block  where the parent  decides whether to create a new page function. If the answer to decision block  is NO, there has been an error. This results in the process proceeding to a block  and the operating system handling the error.","The process proceeds to another continuation terminal (\u201cterminal C\u201d) if the answer to decision block  is YES. The flow of the process  from terminal C is in . From terminal C, at a block , the parent  creates a child page function  (hereinafter \u201cchild \u201d). The creation of the child  includes the creation of an identifier that uniquely identifies the child . After the child  has been created, the parent  requests the frame  to navigate to the child. See block . One suitable technique for making this request is the invocation of the navigate service of the frame . Along with the request to navigate, the parent  provides the identifier of the parent , and the identifier of the child  as shown at block .","The process  next proceeds to a block  where the frame  creates a second node to represent the child  in the frame data structure. Additionally, the frame places the identifier of the child  in the second node as shown at block . Further, the frame creates an originator relationship or a link between the first node, which represents the parent , and the second node, which represents the child . See block . From there, the process  proceeds to another continuation terminal (\u201cterminal D\u201d).","From terminal D (), at a block , the frame  activates the child  by invoking the activate service of the child . Along with the activation of the child , the frame  provides one or more parameters, which are determined and provided by the parent , to the child . See block . One way of passing these parameters is to furnish these parameters as part of the function signature of the activate service, and an alternate way is to directly access the exposed parameters of the child  and place information into these exposed parameters. Next, at decision block , a test is made to determine if the child  has finished its task. If the answer is YES, the process  proceeds to a further continuation terminal (\u201cterminal E\u201d), which is also illustrated in .","At a block  (), the child  notifies the frame that the task of the child is finished by invoking a finish service of the frame . At the same time, the child  sends its identifier to the frame . See block . From there, the process  flows to a decision block . At decision block , the child may decide if the child and its children's nodes should be removed from the frame data structure. If the decision is YES, the frame  removes the node representing the child , and the child's children's nodes from the frame data structure. See block . If the answer is NO or after the child and the child's children's nodes have been removed from the frame data structure, the frame  notifies the parent  that the child  has completed the task. See block . One suitable notification technique is to invoke a complete service of the parent . If the child has one or more returned results from the performance of the task, those results are returned at the time the frame notifies the parent  via the invocation of the complete service. One technique for the child to return these returned results is for the parent to pass to the child a call-back function at the time the child is activated. The callback function contains parameters in which the child may place the returned results. To send the results back to the parent, the child simply invokes the callback function. Other techniques are also suitable. In addition, at the same time, the child identifier is provided to the parent  by the frame . These activities occur at a block . From here, the process  proceeds to another continuation terminal (\u201cterminal G\u201d), which brings the process  back to decision block  ().","Returning to , if the answer to decision block  is NO, at block  a test is made to determine if the user interface page of the child  is to be shown. If the answer to decision block  is YES, the child  displays its user interface page in the user interface of the frame . See block . From here, the process  waits (decision block ) for a user to interact with the user interface page of the child . If no interaction occurs, the process  continues to loop around decision block . When the user interacts with the user interface page of the child , the child  processes the interaction (block ), and the process loops back to decision block .","If the answer to decision block  is NO, the child  decides whether it desires to create a new page function. See decision block . If the answer is NO, there has been an error. As a result, the process proceeds to block  and the operating system handles the error. Otherwise, the process proceeds to a further continuation terminal (\u201cterminal F\u201d). The process of creating a new page function has already been described with reference to .","The architectural framework for enabling page functions to be displayed in a Web-like manner, the architectural framework is typically part of an application program interface (API) available on a computer. Frequently, API's are available as part of an operating system, such as Microsoft Corporation's Windows family of operating systems. However, API's may also be provided as part of another application or service installed on a computer.",{"@attributes":{"id":"p-0144","num":"0143"},"figref":"FIG. 12","b":["1200","1202","1200"]},"The exemplary computing environment  further includes a page function API  which applications and\/or program modules must call in order to create a page function, as described above. The page function API  includes at least one interface  for the applications\/program modules to invoke in order to create an instance of the page function.","While the preferred embodiment of the invention has been illustrated and described, it will be appreciated that various changes can be made therein without departing from the spirit and scope of the invention as defined by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing aspects and many of the attendant advantages of this invention will become more readily appreciated as the same become better understood by reference to the following detailed description, when taken in conjunction with the accompanying drawings, wherein:",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 3D"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 5C"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 5D"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 6D"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 6E"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 7B","FIG. 7A"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 7C"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 7D"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 7E"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 8C"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 8D"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 8E"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIGS. 10A-10F"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIGS. 11A-11B"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
