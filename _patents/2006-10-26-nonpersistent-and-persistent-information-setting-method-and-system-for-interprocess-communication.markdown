---
title: Non-persistent and persistent information setting method and system for inter-process communication
abstract: System, method, architecture, network device, and computer programs and computer program products for inter-process communications. Message structure, procedure for generating the message structure, applications of the message structure and messaging method for obtaining status, statistics, and other information and for performing an information or parameter set operation across one or more process boundaries, and to other device and system architectures and methods for utilizing the messages and messaging methodology.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08250587&OS=08250587&RS=08250587
owner: Trapeze Networks, Inc.
number: 08250587
owner_city: Pleasanton
owner_country: US
publication_date: 20061026
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION"],"p":["This patent application claims the benefit of priority under 35 USC \u00a7119 to U.S. Provisional Application Ser. No. 60\/732,038 filed Oct. 27, 2005 and entitled MOBILITY SYSTEM; which application is hereby incorporated by reference in its entirety.","This application is also related to U.S. Utility patent application Ser. No. 11\/588,849 filed 26Oct. 2006 and entitled Mobility System and Method for Messaging and Inter-Process Communication; and U.S. Utility patent application Ser. No. 11\/588,878 filed 26 Oct. 2006 and entitled Information and Status and Statistics Messaging Method and System for Inter-Process Communication; each of which applications are hereby incorporated by reference.","This invention relates generally to systems, methods, architectures, and computer programs and computer program products for interprocess communications, and more particularly to a message structure, a procedure for generating the message structure, applications of the message structure and messaging method for obtaining status, statistics, and other information and for performing an information or parameter set operation across one or more process boundaries, and to other device and system architectures and methods for utilizing the messages and messaging methodology.","Conventionally, authoring a single or small set of executable software or other program code for what may be considered as bundling of multiple functions or operations into the single process code has had the advantage that communication between the multiple functions or operations is simplified. Communications between any two functions within the single executable program code has also been relatively simple in that communications between any two or more of the multiple functions may readily be achieved by passing or sharing memory contents or ranges within the single executable software or other program code.","Unfortunately, executing the single (or small set of) executable software or program code has had the disadvantage that it may contribute to instability because of functions that may sometimes tend to interfere with each other in unexpected ways during their execution in the real world, as well as possible susceptibility to security flaws, memory overflow, and other problems. It may also complicate the task for developers to work together without having detailed knowledge of other developers efforts.","Therefore, it has been recognized that in at least some instances, there are advantages to separating different functions or operations, even when related or when requiring coordination between the related functions, to separate the functions into different processes that have defined process boundaries and are executed independently and advantageously substantially autonomously from one another. Typically, however, since the processes are at least somewhat related or interdependent, some degree of communication between the different processes, usually referred to as Inter-Process Communications or IPC, is required to facilitate operation of the system as a whole.","Software and system designers have utilized various interprocess communications architectures and methods in the past to permit communications between different processes within in a system. Unfortunately, these architectures, methods, procedures, and interprocess communications techniques have had limitations so that they have not necessarily been universally applicable to the diverse range of system architectures, device characteristics, or functional and operational needs. They may also have had complicated interfaces that required relatively high levels of programming skills that added to the cost and time involved in implementing them and were more difficult to test and debug.","For example, some conventional interprocess communication or messaging techniques are protocol or transport layer dependent, or are client-server relationship specific in some way, or are merely remote program calls, or other situation where there is again an asymmetry, dependency, special treatment or characteristic, or bias toward one of the message sender or receiver. Furthermore, these conventional interprocess communication techniques, architectures and methods may not usually be able to efficiently and reliably provide the type of interprocess communication that are required for particular situations or applications.","One of conventional communication, that may be thought of as a pseudo interprocess communication technique was the Sun Microsystems remote program call (RPC) technique. Another was the Open Network Computing (ONC) remote program call technique. Each of these techniques involved specifying one or more interfaces to a library so that there was a client on one side of a network and a server on the other side of the network, and to the client it would essentially appear that the client was making a direct functional call to a library on the server even though was or might be a network between the client and the server based library. These RPC models may be considered to be asymmetric and very much client-server models which means at the very least that each side has either a special server characteristic, a special client characteristic, or some other side specific characteristic. These side specific characteristics are frequently undesirable in many applications.","Many of these conventional interprocess communication or pseudo interprocess communication models, methods, and techniques were also synchronous in that there was a need for the sender process to receive a response back from the intended recipient or receiver process before the sender process could continue. Since the response in many networking situations could take at least large fractions of a second, such synchronous operational requirements led to inefficiencies, unnecessary overhead, and reduced performance.","Conventional interprocess communication schemes and techniques and even the messages themselves were also frequently difficult to implement and typically required highly skilled computer programmers with an ability to program code in relatively low-level and non-intuitive languages such as the C, C++, and similar programming languages.","Conventional processes also frequently fell primarily or even exclusively into one of two models: a thread execution based model or a finite state machine based execution model.","Therefore, there remains a need for an interprocess communication method, model, and architecture in which the interprocess messaging is more symmetric and peer-to-peer or message producer-consumer like in approach without a bias as to which process, device, or system is the producer and which process, device, or system is the consumer of any particular messaging event. Even where there may actually be a server and a client, such labels from the standpoint of the messaging event are or should be relatively unimportant.","There also remains a need for a message structure that provides the desired message information and content and that is compatible with the messaging model and method.","There further remains a need for a message that is relatively easy to specify and that may advantageously be written in a relatively high-level language, such as for example in the XML language or other higher level language.","There also remains a need for a interprocess message communication methodology and message structure that permits the sharing of information across process boundaries whether the process boundaries exist between processes in a single hardware device or between separate hardware devices that are either collocated in a facility that may use one particular message transport layer, or coupled or connected over a communications link between geographically remote hardware devices or systems possibly using a different transport layer but the same message structure.","There also remains a need for an interprocess communication scheme and message structure that permits authoring and generating messages and communicating messages between different processes that is simple and efficient.","There also remains a need for an interprocess communication scheme and message structure that is suitable for wired, wireless, and hybrid wired and wireless network communication infrastructures, including infrastructures involving one or more of network servers, routers, switches, access points, and clients.","There also remains a need for an interprocess communication scheme and message structure that permits efficient operation with low overhead in both thread-based execution schemes and finite state machine based execution schemes, particularly as they may apply to different devices and systems in a network infrastructure and network packet processing environment.","There also remains a need for an interprocess communication scheme and message structure that permits the acquisition by one process of the status and statistical information known within or available from another process.","There also remains a need for an interprocess communication scheme and message structure that permits persistent and\/or non-persistent setting of information or data using a message sent from a first process and received by a different process.","This invention provides systems, methods, architectures, and computer programs and computer program products for inter-process communications, and more particularly to a message structure, a procedure for generating the message structure, applications of the message structure and messaging method for obtaining status, statistics, and other information and for performing an information or parameter set operation across one or more process boundaries, and to other device and system architectures and methods for utilizing the messages and messaging methodology.","In one aspect, the invention provides a method for setting an information across an interprocess boundary from a from an information producer process to an information consumer process using an information setting message, where the producer and consumer processes are separated by at least one process boundary, the method comprising: generating an information set request in the producer process; communicating a message including the information set request from the producer process to the consumer process; receiving the information request by the consumer process; and processing the request and setting the information in the consumer process.","In another aspect, the invention provides a computer readable medium encoded with a computer program for directing a computer to set an information in an information consumer process, where the consumer process is separated by at least one process boundary from an information producer process, the computer program including a module that includes executable instructions for: generating an information set request in the producer process; communicating a message including the information set request from the producer process to the consumer process; receiving the information request by the consumer process; and processing the request and setting the information in the consumer process.","In another aspect, the invention provides a system for setting an information from an information producer process to an information consumer process, where the producer and consumer processes are separated by at least one process boundary, the computer system comprising: means for generating an information set request in the producer process; means for communicating a message including the information set request from the producer process to the consumer process; means for receiving the information request by the consumer process; and means for processing the request and setting the information in the consumer process.","In another aspect, the invention provides a method for defining information to be set in an external process in a computing machine or device, the method comprising: defining a message using a high-level language; automatically generating a plurality of application programming interfaces (APIs) including implementation code and any interfaces; using the APIs to transfer information, data, or state from one process to another process across a process boundary.","In another aspect, the invention provides a method for designing an information setting message comprising: (1) defining an information setting (NPS) message in a high-level descriptive language; (2) running the high-level descriptive language through an NPS message transformation or modification tool adapted to the high-level descriptive language to generate per-NPS message Application Program Interfaces (APIs); and (3) using these APIs to set the NPS information from one process to another process.","In yet another aspect, the invention provides for implementation of at least some of the various methods to be implemented as computer programs where the computer programs may include a computer readable medium encoded with a computer program for directing a computer, or a processor, or other logic circuit or logic means to act in a particular manner.","In the figures, similar reference numerals may denote similar components.","Introduction","A communication and messaging system, method, computer program and computer program product are described for communicating or messaging between two or more processes. This inter-process communication or messaging scheme may be applied between any two processes whether within a single physical device, between processes executing in different devices, in peer-to-peer situations or in client-server or server-client situations, and in any other situation where there is a need or desirability to communicate, message, send instructions, make requests, pass parameters, get status or other information, set parameters, data, or other information, or in any other way perform one-way, two-way, or multi-way information exchanges between computer programs or processes.","Aspects of the invention provide for sending general messages between processes, that may or may not result in an optional response from the receiving process. Other aspects of the invention provide for sending a message from a first process to a second process that will result in the return or retrieval of an information item or data from the second process, whether that returned information item or items be status from the second process, statistical information that the second process has access to, or any other information. In another aspect, the invention provides for sending a message from a first process for non-persistently setting (or persistently setting with an additional store or save operations) some information item, data, status, flag, condition, or any other parameter, value, or state in a second process. The non-persistently set information item can then be made persistent by having the second process persistently store, keep, save, utilize, or by any other means retain the information sent from the first process to the second process.","In general terms, elements of the general messaging system and method are also used for the system and method for returning or receiving information from a second process, and elements of both of these systems and methods are used for setting information in a second process by the first process. Extensions and enhancements are added at each level to achieve the desired operation. The generalized interprocess messaging, the interprocess information retrieval, and the interprocess information setting are described below.","Exemplary Automated Interprocess Communication Message Structure and Method","Techniques described herein enable developers to create interprocess communication messages without having to implement marshalling and unmarshalling functions or worry about many other aspects of interprocess communications, and to provide an intuitive means of specifying and using those messages. An example of a system developed according to this technique provides automated Inter-Process Communication (IPC) (such as for example, various processes in a LAN) to allow developers to work only on an XML layer; this allows messages to be specified using only XML. The messages may be organized into catalogs of specific functions. Advantageously, a developer can register a function against a message so that a single dispatch can be called to handle both. This is particularly valuable in a system that includes multiple processes with the need to communicate with each other. In a non-limiting embodiment, marshaled messages are hardware architecture agnostic and message transport is independent of the messages.","In one non-limiting embodiment, an exemplary system configuration with which the inventive messaging architecture, method, procedures, and computer program and computer program product may be utilized may include a network device, such as for example a network switch, is coupled for communication with a network management system. In one embodiment the network management system may include the Ringmaster\u2122 server management software (manufactured by Trapeze Incorporated of Pleasanton, Calif.). The network management system may further include mobility systems software. Though not required for practicing the invention, a network management system, such as the Ringmaster\u2122 server network management system, provides a client server application that enables organizations to perform pre- and post-deployment planning, configuration, and monitoring and management, of the a network infrastructure. The two or more processes which may for example take place between two processes executing in a device, such as for example in a network wireless switch or other device or system. For example, if the device is a switch, then a first process that is involved with a web http process may need to talk to a second process involved with device configuration so that the process involved with the device configuration can enable or disable the http process for communication or to get status, statistics, or other information, or even to set some parameter or condition. These are merely non-limiting examples of interprocess communications that may benefit from the inventive features.","Aspects and features of this invention have been described in co-pending U.S. Provisional Patent Application No. 60\/732,038 filed 27 Oct. 2005, entitled MOBILITY SYSTEM, including in the specification, drawings, and computer program code and pseudo-code that is included in one or more of the appendices of that application, and which application is hereby incorporated by reference in its entirety.","In a non-limiting implementation, rather than developing a new language to obtain desired functionality, XML was used to facilitate use of the system without extensive retraining of developers in the new language. Underlying processes may advantageously be handled automatically for developers, who only needed to work in an XML (or other higher language) layer. Interfaces are advantageously generated using XML (or other higher language or more intuitive code, or other declaratory computer programming language), as well. In this particular embodiment, communication between processes is accomplished by passing messages through UNIX domain sockets. However, the communication could be by any other practical means, such as over Internet sockets. Of course, the communication could be by less practical means as well, such as facsimile. Other implementations, using, for example, other languages, are anticipated and should be apparent to those of skill in the art upon a careful reading of this specification.","Various methods procedures and techniques are described in terms of two or a plurality of processes. It will be appreciated that the invention and its various embodiments include the method steps that occur between and among the different processes as well as the steps that take place in each of the processes separately as the process interacts with another process. Therefore in the embodiments described herein, although the method, technique, computer program code, or the like may be described in terms of two processes, the invention will be understood to include the steps taking place in each process separately, and vice versa.","Exemplary Embodiment of a Mobility System",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 1","FIG. 1"],"b":["100","100","102","104","106","108","110","102"]},"Exemplary Message Specification Using XML Document Type Definition (DTD)","In one non-limiting aspect, the inventive message structure and messaging method provides an automated interprocess communication (IPC) that permits various processes to communicate with each other while the developers of the system and device architecture and computer program code do not have to work or program at any other layer than an XML (or other declaratory computer programming language) program language layer. The developers define messages using a message structure and the inventive structure, method, and programming technique handles everything else automatically to generate the information files and executable program code to implement the desired interprocess communication or messaging.","In one non-limiting embodiment, the invention provides one or more message definition files and each of these message definition files may, where each message catalog may include zero to many messages, typically one or more messages, be referred to as a message catalog. In one embodiment, there is one message catalog in one file, but the message catalogs need not be files and a file is merely one non-limiting physical manifestation of how a message catalog may be defined or implemented. Advantageously, the message definition files provide a description of the message elements are written or defined in terms of the XML programming language (or other declaratory computer programming language). Table I (below) provides an example of a message catalog that may include one or more messages.","The inventive structure and method differ from conventional structures and methods in at least the following ways. First, in at least one non-limiting embodiment it has its own message definition language and language structure from other known IPC and remote program call (RPC) interprocess communication structures and methods. Second, in at least one non-limiting embodiment, the invention utilizes XML to generate the interprocess communication interfaces. Other languages may be utilized for this generation. Third, in at least one non-limiting embodiment, marshalling code is automatically generated in a \u201cC\u201d language file. The marshalling code puts or encodes the desired message from the easier to program and more intuitive higher-level XML language into a defined message structure, and since it put into a well defined message structure by the marshalling code, the same message when received by an intended recipient, may readily be decoded and put into a known defined structure by unmarshalling code at the recipient or receiving end. Each C-file for other implementation file advantageously includes one or a number of computer programs. These computer programs may be considered to be functions, procedures, or routines for each message and used to implement or communicate for each message.","Exemplary embodiments provide a C-file or other implementation file that provides message marshalling, a kind of well defined structured creation of a message. Message marshalling (and message unmarshalling) are described herein elsewhere.","Registration routines for each message are created by the message translation tool such as by a message compiler. A message may be created and a function is registered that is linked with or associated with that message. Advantageously, the inventive message structure and messaging method are automated as much as possible with the goal that not only are the structures created, but it is also desirable to provide the automation so that the developer can take a function and register the function against the message so that the developer may then, when a message is received, call a single message dispatch function with the message.","In a non-limiting embodiment, the structure of the messages is advantageously well-defined. Having a message that is well-defined assists in the message automation and the marshalling and unmarshalling of the message. Table 1 depicts an exemplary structure of the message catalog using the XML language and using a Document Type Definition (DTD or dtd) structural definition of a document using XML. Table 2 illustrates an instance of a catalog defined using DTD. Other message definition forms may be used so that the invention is not limited to DTD defined messages or to the XML language.","In one non-limiting embodiment of the invention, messages are defined using a simple XML document type definition (dtd) as indicated in the XML language which is further described relative to Table I below.","The exemplary message definition in Table 1 provides a document type definition (dtd) for a message catalog. It may be noted that the lower case abbreviation \u201cdtd\u201d and the upper case abbreviation \u201cDTD\u201d for Document Type Definition are equivalent and used interchangeably in this document, though the lower case \u201cdtd\u201d is more typically used in the exemplary code and pseudo code. The DTD defines the proper or legal building blocks of an XML document and defines the document structure with a list of legal elements. Here in Step , !ELEMENT CATALOG defines the element \u201cCATALOG\u201d as having zero or more elements called MESSAGE. It may be appreciated in light of the description provided here that a catalog may be considered (at a high level) to be like a document, and just as a document may be comprised of a single file or data set or a plurality of files or data sets, so too may a catalog be a single file or data set or a plurality of files or data sets.","The XML attribute list declaration (ATTLIST) is used to declare XML element attributes. The ATTLIST declaration defines the element which may in general have four parts, the attribute, the name of the attribute, the type of the attribute, and the default attribute value.","In step , !ATTLIST CATALOG catalog name NMTOKEN #REQUIRED declares that the element CATALOG has an attribute name \u201ccatalogname\u201d and that the attribute \u201ccatalogname\u201d has an attribute type NMTOKEN meaning that the value must be a valid XML name, and that the attribute value must be included in the element (#REQUIRED).","In step , !ELEMENT MESSAGE defines the element \u201cMESSAGE\u201d as having one element \u201cPARAMETER*\u201d. In step , !ATTLIST MESSAGE callname ID #REQUIRED declares that the element MESSAGE has an attribute name \u201ccallname\u201d and that the attribute \u201ccallname\u201d has an attribute type ID meaning that the value is an unique ID, and that the attribute value must be included in the element (#REQUIRED).",{"@attributes":{"id":"p-0067","num":"0066"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of a Message Defined Using a Document Type Definition (DTD)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Step 100","<!--dtd for message \u201caaa\u201d -->"]},{"entry":["Step 101","<!ELEMENT CATALOG (MESSAGE*)>"]},{"entry":["Step 102","<!ATTLIST CATALOG"]},{"entry":[{},"\u2003\u2003\u2003\u2003catalogname NMTOKEN #REQUIRED >"]},{"entry":["Step 103","<!ELEMENT MESSAGE (PARAMETER*)>"]},{"entry":["Step 104","<!ATTLIST MESSAGE"]},{"entry":[{},"\u2003\u2003\u2003\u2003callname ID #REQUIRED>"]},{"entry":["Step 105","<!ELEMENT PARAMETER (SUBPARAM*)>"]},{"entry":["Step 106","<!ATTLIST PARAMETER"]},{"entry":[{},"\u2003\u2003id CDATA #REQUIRED"]},{"entry":[{},"\u2003\u2003type (INT|STR|INTARRAY|STRARRAY|OPAQUE|"]},{"entry":[{},"SEQUENCE)"]},{"entry":[{},"#REQUIRED >"]},{"entry":["Step 107","<!ELEMENT SUBPARAM EMPTY>"]},{"entry":["Step 108","<!ATTLIST SUBPARAM"]},{"entry":[{},"\u2003\u2003\u2003\u2003type (INT|STR|OPAQUE) #REQUIRED >"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In step , !ELEMENT PARAMETER defines the element PARAMETER as having one element \u201cSUBPARAM\u201d.","In step , !ATTLIST PARAMETER id CDATA #REQUIRED type (INT|STR|INTARRAY|STRARRAY|OPAQUE|SEQUENCE) #REQUIRED, declares that the element PARAMETER has an attribute name, where CDATA indicates that the value is character data, (INT|STR|INTARRAY|STRARRAY|OPAQUE|SEQUENCE) indicates enumerated values of INT, STR, INTARRAY, STRARRAY, OPAQUE, SEQUENCE and that the value must be included in the element (#REQUIRED).","In step , !ELEMENT SUBPARAM EMPTY defines the element SUBPARAM as having no additional elements (e.g., is empty).","In step , !ATTLIST SUBPARAM type (INT|STR|OPAQUE) #REQUIRED declares that the element SUBPARM has an attribute type and no name or ID.","By way of summary, this set of steps says that catalogs may include messages, messages may include parameters, and parameters may include sub parameters.","It will be appreciated that the marshalling procedure may advantageously utilize a well defined format that does not introduce ambiguity into the marshaled code structure so that unmarshalling or extraction of the message or message catalog content may be performed in an efficient and unambiguous manner. Advantageously the marshalling and unmarshalling are performed in a manner and according to rules that permit the marshaled and unmarshalled messages (and\/or compiled and\/or decompiled versions thereof) to be understood in a hardware, operating system (OS), and\/or applications program, interface, or computing or processing environment agnostic manner. In at least non-limiting embodiments of the invention, the particular message definition, marshaled, and\/or unmarshalled message format or formats is not important so long as there are understandable rules that are used to put the message information into the form (marshal) and then later extract it (unmarshal). In one non-limiting embodiment, a marshaled message may be unmarshalled in different formats for different processes if desired or required. There is no one standard that needs to be implemented, whatever standard or implementation adopted, just needs to be repeatable. The particular embodiment of the format and rules described herein do provide some particular advantages to the particular network environment inter-process communications.","It will be appreciated in light of the description provided herein, that embodiments of the invention provide a way of describing a message as consisting of a number of parameters wherein each parameter may be described as to the data or information it represents. The inventive message structure and messaging method are able to collect one or a plurality of messages into a catalog of messages (message catalog).","Exemplary Method and Procedure for Marshalling a Message","An exemplary process for marshalling information generally and for marshalling a message in particular is now described.","Marshalling information or data refers generally to a procedure for collecting, constructing, organizing, formatting, or otherwise bringing together information or data in any form and putting it into a well defined standard form or organization. Data or information may include but is not limited to numbers, symbols, characters, code, messages or message components, statistics, status, indicators, binary or ASCII representations, or any other data or information without limitation. A particular marshalling procedure that is applied to a non-limiting embodiment of the invention that optionally but advantageously uses a network operating system (NOS) context, to generate the messaging code and provide the message generation, transmission, and message receipt infrastructure. This messaging methodology may be applied to messaging amongst and between a plurality of processes in a network environment that need to, or are advantaged by, communication with each other either directly or indirectly.","The structures of the messages are advantageously defined or well defined and based on rules or policies that provide not only for the construction or marshalling of the message or messages but also provide for the unmarshalling or extraction of the message content or information in a different receiving process that is advantageously but optionally any one or a combination of operating system agnostic or independent (or does not care), hardware, software, language, environment and\/or in other ways agnostic or independent, so that the structures of the messages, and the marshalling and unmarshalling will work properly and predictably in any environment, and in particular will work where the sending computing or messaging environment is different from the receiving computing or messaging environment.","In one non-limiting embodiment, the interprocess communication in the form of messaging uses UNIX domain sockets to pass messages. In another non-limiting embodiment, the interprocess communication messaging uses Internet sockets to pass messages. In yet another non-limiting embodiment, the interprocess communication messaging uses a shared memory, a file or files, or any other means to pass messages.","In one embodiment of the invention, a simple and relatively high-level programming language (such as XML) is used to define messages and message catalogs, and a message converter tool (optionally including a message marshalling tool) is then used to convert the messages and message catalogs into marshaled computer code. Advantageously the converted or marshaled computer code may be in a derivative or different computer language, such as in a language that is more closely adapted to the computing or information processing environment that will execute or otherwise use the marshaled computer code. In one non-limiting embodiment, the different or derivative language may be the C, C++, or other language without limitation. For example, though having some possible disadvantages, even programming languages such as Fortran, Cobol, Pascal, new languages yet to be developed as well as enhancements and extensions to known languages may be used.","Because the rules and structure of the converted or marshaled message computer code are well defined, a different or complementary second conversion or unmarshalling tool may advantageously be used to unmarshall the message (or perform a second conversion) so that the receiver of the message may readily understand and\/or extract the content of the received message even though the receiver process may exist in a different hardware, operating system, application program, or other environment.","In the exemplary embodiments described herein, the marshalling and subsequent unmarshalling of messages and\/or message catalogs generate one or more message catalogs based on specifications or definitions in the XML language, such as XML version 1.0 however, the invention is not limited to any particular XML or other language version. In particular it will be appreciated that later versions of XML may be utilized in conjunction with the invention as well as later languages that may be used in the computer and programming arts, particularly as they apply to network devices and systems. In other non-limiting embodiments of the invention, the marshalling and subsequent unmarshalling of messages and\/or message catalogs generate message catalogs based on specifications or definitions in some other language, which other language is advantageously higher-level and therefore a simpler, easier to program, and\/or more intuitive (language). The marshalling language and unmarshalling language may the same or may be different languages. The unmarshalling may result in the initial message form or may result in a different message form or structure so that the marshalling and unmarshalling need not be symmetrical.","A message transformation tool, such as a message compiler, automatically creates the marshalling and unmarshalling tools so that a computer code or program developer may work in the relatively high-level or more intuitive programming language (such as XML) and does not need to know how to explicitly and in detail create either the marshaled code (or unmarshalled code) or the converted or compiled version of the marshaled or unmarshalled code (such as for example the header file and the C-file code described herein elsewhere).","In one non-limiting embodiment, a first file, referred to as an interface or header file, describes the contents of a second file (such as the C-file), and the second or implementation file (such as the C-file) implements the marshalling of the message and the transport of the message to the other process. However, it will be appreciated that the invention itself is transport independent and that any transport process or mechanism may be used.","Exemplary Processes, Messages, and Message Catalogs","In at least one non-limiting embodiment of the invention, multiple or a plurality of message catalogs may be related. By way of example, but not limitation, a first process (\u201cProcess A\u201d) may support message catalogs 1, 2, and 3; and a second process (e.g., \u201cProcess B\u201d) may support message catalogs 1, 5, and 6. Each message catalog may therefore support either non-overlapping (e.g., disjoint) processes, partially overlapping or common processes, or completely overlapping processes, without limitation. These are some examples of relationships between message catalogs.","A message catalog is defined by a message catalog definition. In one non-limiting embodiment the message catalog definition has a form exemplified by the XML message catalog definition shown in Table 2.",{"@attributes":{"id":"p-0086","num":"0085"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Message Catalog Definition"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Step 110","<?xml version=\u201c1.0\u201d ?>"]},{"entry":["Step 111","<!DOCTYPE CATALOG PUBLIC \u201c-\/\/TRPZ\/DTD Messages"]},{"entry":[{},"definition 1.0\/\/EN\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u201cmessages.dtd\u201d>"]},{"entry":["Step 112","\u2003<CATALOG catalogname=\u201ctestcatalog\u201d>"]},{"entry":["Step 113","\u2003<MESSAGE callname=\u201ctestone\u201d>"]},{"entry":["Step 114","\u2003\u2003\u2003<PARAMETER id=\u201c1\u201d type=\u201cINT\u201d\/>"]},{"entry":["Step 115","\u2003\u2003\u2003<PARAMETER id=\u201c2\u201d type=\u201cSTR\u201d\/>"]},{"entry":["Step 116","\u2003\u2003\u2003<PARAMETER id=\u201c3\u201d type=\u201cINT\u201d\/>"]},{"entry":["Step 117","\u2003<\/MESSAGE>"]},{"entry":["Step 118","\u2003<\/CATALOG>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In this exemplary message catalog definition, Step , identifies the XML version as being version=\u201c1.0\u201d. This statement, the XML declaration should always be included as the first line in the document, and defines the XML version of the document. In this case the document conforms to the 1.0 specification of XML.","In Step , a document type declaration (!DOCTYPE) is used to wrap the included DTD in the XML source file and says the only valid document type here is a CATALOG and having a catalog name. For purposes of this example the catalog name is testcatalog but it can be any name. Here, the root element CATALOG PUBLIC is the \u201c-\/\/TRPZ\/DTD Messages definition 1.0\/\/EN messaged document type definition \u201cmessages.dtd\u201d (See also Table 1)","Next (Step ), the <CATALOG catalogname=\u201ctestcatalog\u201d> refers back to the description in Table 1 (Steps  and ) for the catalog with catalog name testcatalog.","Then (Step ), <MESSAGE callname=\u201ctestone\u201d>, specifies three parameters for the message testone: a first parameter having id=1 and type integer (<PARAMETER id=\u201c1\u201d type=\u201cINT\u201d\/>), a second parameter having id=2 and having type string (<PARAMETER id=\u201c2\u201d type=\u201cSTR\u201d\/>), and a third parameter having id=3 and a type integer (<PARAMETER id=\u201c3\u201d type=\u201cINT\u201d\/>), and ends with <\/MESSAGE> <\/CATALOG>.","This message catalog is then processed through the message transformation tool or message converter , such as for example through a message compiler, to generate an implementation file or data structure (such as for example a C-language file or data structure) and an interface file or data structure (such as for example a C-language header file). Typically the language of the implementation file and of the interface file will be the same, but they need not be, and in some embodiments there will only be an implementation file without an interface or header file. In these situations, the interface information may usually be provided within the implementation file itself, or by other means. It will be appreciated in light of the description provided herein, that the inventive system and method may be implemented in a variety of languages, and even for example when the implementation file is a C-language file, the invention includes all of the versions, variation, enhancements and extensions to the C-language, such as for example but without limitation to the C, C++, Java, Fortran, Pascal, Cobol, and any other language.","It will be noted that the term file may refer to a file or any other data structure whether in the form of a traditional file or other data structure. In one non-limiting embodiment, the message and message catalog are written or defined in the XML language and the compiler is an XML compiler that generates a compiled output into the target output program language, such as the C-language.","Exemplary Message Transformation Tools, Converters and Compilers","In the example of , the message transformation tool or message converter  (such as for example a message compiler) transforms or converts each message into an interface file  (where required) and an implementation file . In a non-limiting embodiment, the message converter may be a message compiler that compiles or transforms the code into the two files. By way of example but not limitation, the interface file  may be a C-language header file and the implementation file  may be a C-program language file. In an alternative embodiment, the message converter  may be an interpreter and, by way of example but not limitation, the resulting code could be included in a single (e.g., Java) file rather than in both an interface file  and an implementation file .","Table 3 and Table 4 depict examples of a header file (a type of interface descriptor file) and a C-language executable file (a kind of message implementation file), respectively, that might be generated according to one alternative embodiment.","An exemplary compiler output of the C-language implementation file and the C-language language header file are illustrated in Table 5 and Table 6.  also illustrates relationships between the interface file the implementation file and other elements of the system.","With reference to Table 3, in one non-limiting embodiment, the catalog interface procedure comprises the steps of: creating a function to handle each response (Step ), registering the function in the message catalog (Step ), calling or otherwise utilizing the marshal code to create a message (Step ), sending the encoded message to a message recipient (such as to a server or to a different recipient directly or indirectly through a server) (Step ), receiving and reading a response from the recipient or server (either directly or as an intermediary from a different ultimate recipient and responder) (Step ), and calling the generic or overall unmarshalling routine (e.g., unmarshall_testcatalog) to process the incoming message (Step ). The unmarshalling call may optionally include an argument (such as a last argument in an argument list) to be passed to the function defined in step  and may be used to maintain state. In the exemplary code in Table 3, the last argument \u201cNULL\u201d is used for this state maintaining purpose.","In the step of sending the encoded message (Step ) above, the transport layer used is not important, it can be a file, or any other transport mechanism or layer.","Although XML program language is preferred and described herein, it may be appreciated that other programming languages may be used instead or in combination. For example, the invention may be implemented using any formal computer program language that allows one to define a structure, usually any declarative language.","In one embodiment, two files are utilized. Advantageously, one file provides a header (or interface description for the second file) and the second file provides the implementation details. The header file is referred to as an interface file because it describes the interface(s) that is or are available for passing messages.","The header or interface file is provided to other programs to use and identifies what is in the second implementation or C-file. The term C-file is used because in one preferred embodiment, the implementation file is a C-language program code file. The implementation or C-file may be a single file or may be separated into a plurality of files. For example, though no particular advantage may be provided, the second or C-file may be cut or separated into a plurality of files, such as for example into as many separate files as there are C-functions. Since the file is automatically generated, it does not matter how large the implementation or C-file is. In the context of embodiments of the invention, there is no need or particular advantage to separate the contents of the implementation or C-file. Furthermore, though not required, anyone process or device using one component of the implementation or C-file probably wants to or readily may use all or selected ones of the components of the single implementation or C-file, so that there is probably no advantage to using more than a single header file.","For ease of description, it will be understood that the use of the term C-file implies any implementation file having the properties described herein, and not merely to a C-language program file. In similar manner, reference to a header or h-file refers to any interface file having the properties described herein.","In one non-limiting embodiment, one implementation or C-file and one interface or header-file are provide per message catalog. This may typically be true when each message catalog includes a single message. That is, compilation of each XML file ultimately generates one C-file and one header-file. Alternatively, one may put more than one XML file into a catalog, so that the multiple-XML containing catalog may be compiled into a one C-file and one header file. The use of multiple files may typically be advantageous when the catalog is particularly large; however, in prototype implementations, no practical limits for single file implementations have been identified.","In general, a catalog can have an unlimited number of messages, and therefore an unlimited number of XML message descriptions. However, as one of the objects of the present invention is to provide an easier code development procedure where a code developer need only concern her-self\/him-self with the single coding or programming task at hand, it is advantageous to have each XML file compile into one C-file and one corresponding h- or header-file.","The invention is not however limited to implementation languages that require or are compatible with header files. For example, some languages, such as PERL, may be used for the implementation file and yet do not require or even benefit from a header file. It is a dynamic or interpretive language and does not need a header file. Even for a C-language (or any other language) implementation, the invention may be implemented without an interface or header file so long as one specifies the appropriate rules and policies for interpretation of the implementation file. Alternatively or in addition, the information that would have been placed in the header or interface file may be included in the implementation file itself so that when that implementation file is accessed or opened, the information will be available to interpret and use the implementation file. In one non-limiting embodiment that utilizes XML program language for the operations for a client program use of the message catalog and interface, the code or pseudo code shown in Table 3 serves as an example.",{"@attributes":{"id":"p-0105","num":"0104"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"273pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Program Pseudo Code for Client Program Use of the Catalog Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["121","Create a function to","static int"]},{"entry":[{},"handle each response","testonefunc(int p1, char * p2, int p3, void * arg)"]},{"entry":[{},{},"{"]},{"entry":[{},{},"\u2003fprintf(stdout, \u201cCalled with %d, %s, %d\\n\u201d, p1, p2, p3);"]},{"entry":[{},{},"\u2003return 1;"]},{"entry":[{},{},"}"]},{"entry":["122","Register the function in","register_mfunc_testcatalog(\u201ctestone\u201d, testonefunc);"]},{"entry":[{},"the catalog",{}]},{"entry":["123","Call the marshall code to","marshall_message_testone(buffer, 2048, 55, \u201ctest\u201d, 28);"]},{"entry":[{},"create an encoded",{}]},{"entry":[{},"message",{}]},{"entry":["124","Send the encoded","Send message (transport independent)"]},{"entry":[{},"message to the server",{}]},{"entry":["125","Read a response from the","Read message (transport independent)"]},{"entry":[{},"server",{}]},{"entry":["126","Call the unmarshall","unmarshall_testcatalog(buffer, 2048, NULL);"]},{"entry":[{},"routine to process the",{}]},{"entry":[{},"incoming message"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Function prototypes are advantageous when trying to compile or code against. Table 4 sets forth exemplary rules or policies for creating function prototypes. The prototypes are included in the header files.","The following rules in Table 4 may be used in one embodiment to create function prototypes. An exemplary sample header file, such as may be generated by compiling the message catalog illustrated in Table 5, and an exemplary implementation file (here an implementation file in the C-language) illustrated in Table 6.",{"@attributes":{"id":"p-0108","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Rule Set for Creating a Function Prototype for the"},{"entry":"Interface File"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Rule 1","marshall_message_%s using the message name"]},{"entry":[{},"Rule 2","unmarshall_message_%s using the message name"]},{"entry":[{},"Rule 3","unmarshall_%s using the catalog name"]},{"entry":[{},"Rule 4","register_mfunc_%s using the catalog name"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The rules set forth a procedure or logic within the message transformation tool or message compiler  for generating information for the interface or header file or other data structure. These rules are described by way of an exemplary transformation between definitions in Table 2 as inputs and resulting code in Table 5. Two of the rules in Table 4 apply to messages (Rule 1 and Rule 2) and two of the rules apply to catalogs (Rule 3 and Rule 4) one each for marshalling and unmarshalling. In the case of marshalling the message catalog, the result is called register message function (e.g., register_mfunc_testcatalog) rather than marshall_testcatalog.","Rule 1 applies to marshalling and specifies that the message should be marshaled or constructed using the message name. Step  of Table 5 is an example of the result of applying Rule 1 from Table 4 to generate the particular message component \u201ctestone\u201d of the header file. Table 4 is inside of the message compiler\u2014logic inside of the message compiler, and for every message inside the message catalog, these rules get applied, and that application yields or generates the output in the interface or header file of Table 5.","Applying the first two rules to message named \u201ctestone\u201d results in marshall_message_testone (see step  in Table 5) and unmarshall_message_testone (see step  in Table 5), and applying the second two rules to the catalog named \u201ctestcatalog\u201d which results in register_mfunc_testcatalog (see step  in Table 5) and unmarshall_testcatalog (see step  in Table 5). More particularly, Step  of Table 5 (e.g., marshall_message_testone) is the result of applying Rule 1 to Step  of Table 2 (e.g., <MESSAGE callname=\u201ctestone\u201d>); Step  of Table 5 is the result of applying Rule 2 of Table 4 to Step  of Table 2; Step  of Table 5 is the result of applying Rule 3 of Table 4 to Step  of Table 2; and Step  of Table 5 is the result of applying Rule 4 of Table 4 to Step  of Table 2. It may be appreciated that other or alternative rules, or transformation tool, or compiler logic may be used to implement the desired message transformation, conversion, or compilation, and that the rule execution embodied in the examples are for purposes of illustration and not a limitation of the invention.",{"@attributes":{"id":"p-0112","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Sample Automatically Generated Interface or Header File or"},{"entry":"Data Structure"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/*"]},{"entry":["Step 201","\u2009* testmessages.h - automatically generated file."]},{"entry":[{},"\u2009*\/"]},{"entry":["Step 202","#ifndef TESTMESSAGES_HDR"]},{"entry":["Step 203","#define TESTMESSAGES_HDR"]},{"entry":["Step 204","typedef int (*intfunc)( );"]},{"entry":["Step 205","extern int register_mfunc_testcatalog(char * name, intfunc"]},{"entry":[{},"func);"]},{"entry":["Step 206","extern int marshall_message_testone ("]},{"entry":[{},"\u2003\u2003char * buffer,"]},{"entry":[{},"\u2003\u2003int bufsize,"]},{"entry":[{},"\u2003\u2003int parameter_1,"]},{"entry":[{},"\u2003\u2003char * parameter_2,"]},{"entry":[{},"\u2003\u2003int parameter_3);"]},{"entry":["Step 212","extern int unmarshall_message_testone ("]},{"entry":[{},"\u2003\u2003char * buffer,"]},{"entry":[{},"\u2003\u2003int bufsize,"]},{"entry":[{},"\u2003\u2003int * parameter_1,"]},{"entry":[{},"\u2003\u2003char ** parameter_2,"]},{"entry":[{},"\u2003\u2003int * parameter_3);"]},{"entry":["Step 218","extern int unmarshall_testcatalog(char * buf, int size, void *"]},{"entry":[{},"arg);"]},{"entry":["Step 219","#endif \/* TESTMESSAGES_HDR *\/"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"It will be apparent by comparing the content of the XML-based message definition file in Table 2, and the automatically created interface file (e.g., h-file or header file), and implementation (e.g., content-file or C-file) that there are related or associated entries in each file. Advantageously, a developer creates a message catalog and then includes the header file, and this becomes part of the library. The developer generates the definition and understands the rules which are very clear as to how the function prototypes are structured and generated, a developer may then generate code and the code may use or reference the function prototypes, and need not know or care at all about how the messaging happens.","Recall that the program code developer merely needs to define the message \u201ctestone\u201d as belonging to the message catalog \u201ctestcatalog\u201d and having parameters 1, 2, and 3 with parameter types integer (INT), string (STR), and integer (INT) respectively (See Table 2). The inventive structure and method then automatically and without programmer intervention through the compiler or other message transformation tool generates the interface (e.g., the h- or header file) and the implementation (e.g., C-file). Exemplary interface file and implementation files are illustrated in Table 5 and Table 6 respectively.","It will be apparent from the description provide herein that the program developers task is vastly simplified by being able to define the message in an XML file (or other high-level definition format) and have the inventive method generate the interface and implementation files. Once these interface and implementation files have been generated, a program (such as a client program) may utilize the catalog interface to send a message and receive and handle a response.",{"@attributes":{"id":"p-0116","num":"0115"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Sample Implementation File or Data Structure"},{"entry":"(Here a Sample C-File)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/*"]},{"entry":["Step 302","\u2009* testmessages.c - automatically generated file."]},{"entry":[{},"\u2009*\/"]},{"entry":["Step 303","#include \u201cutil\/message.h\u201d"]},{"entry":["Step 304","#include \u201ctestmessages.h\u201d"]},{"entry":["Step 305","int"]},{"entry":["Step 306","marshall_message_testone ("]},{"entry":[{},"\u2003\u2003char * buffer,"]},{"entry":[{},"\u2003\u2003int bufsize,"]},{"entry":[{},"\u2003\u2003int parameter_1,"]},{"entry":[{},"\u2003\u2003char * parameter_2,"]},{"entry":[{},"\u2003\u2003int parameter_3)"]},{"entry":[{},"{"]},{"entry":["Step 307","\u2003int result = 0;"]},{"entry":["Step 308","\u2003void * message = create_message(\u201ctestone\u201d);"]},{"entry":["Step 309","\u2003add_message_arg(message,"]},{"entry":[{},"\u2003\u2003create_message_arg(1, Int_arg_e,(void*)"]},{"entry":[{},"\u2003\u2003parameter_1));"]},{"entry":["Step 310","\u2003add_message_arg(message,"]},{"entry":[{},"\u2003\u2003create_message_arg(2, Str_arg_e,(void*)"]},{"entry":[{},"\u2003\u2003parameter_2));"]},{"entry":["Step 311","\u2003add_message_arg(message,"]},{"entry":[{},"\u2003\u2003create_message_arg(3, Int_arg_e,(void*)"]},{"entry":[{},"\u2003\u2003parameter_3));"]},{"entry":["Step 312","\u2003result = encode_message(message, buffer, bufsize);"]},{"entry":["Step 313","\u2003delete_message(message);"]},{"entry":["Step 314","\u2003return result;"]},{"entry":[{},"}"]},{"entry":["Step 315","Int"]},{"entry":["Step 316","unmarshall_message_testone ("]},{"entry":[{},"\u2003\u2003char * buffer,"]},{"entry":[{},"\u2003\u2003int bufsize,"]},{"entry":[{},"\u2003\u2003int * parameter_1,"]},{"entry":[{},"\u2003\u2003char ** parameter_2,"]},{"entry":[{},"\u2003\u2003int * parameter_3)"]},{"entry":[{},"{"]},{"entry":["Step 317","\u2003int result = 0;"]},{"entry":["Step 318","\u2003void * message = decode_message(buffer, bufsize);"]},{"entry":["Step 319","\u2003unsigned int value;"]},{"entry":["Step 320","\u2003*parameter_1 = get_message_arg_int(message, 1, 0);"]},{"entry":["Step 321","\u2003*parameter_2 = get_message_arg_str(message, 2, 0);"]},{"entry":["Step 322","\u2003*parameter_3 = get_message_arg_int(message, 3, 0);"]},{"entry":["Step 323","\u2003delete_message(message);"]},{"entry":["Step 324","\u2003return result;"]},{"entry":["Step 325","}"]},{"entry":["Step 326","#ifndef NULL"]},{"entry":["Step 327","#define NULL 0"]},{"entry":["Step 328","#endif"]},{"entry":["Step 329",{}]},{"entry":["Step 330","typedef struct _fmap_s {"]},{"entry":[{},"\u2003char * mname;"]},{"entry":[{},"\u2003intfunc mfunc;"]},{"entry":[{},"} _fmap_t;"]},{"entry":["Step 331","static _fmap_t SG_fmap[2] = {"]},{"entry":["Step 332","\u2003{\u201ctestone\u201d, NULL},"]},{"entry":["Step 333","\u2003{NULL, NULL}"]},{"entry":["Step 334","};"]},{"entry":["Step 335","Int"]},{"entry":["Step 336","register_mfunc_testcatalog (char * name, intfunc func)"]},{"entry":[{},"{"]},{"entry":["Step 337","\u2003int idx = 0;"]},{"entry":["Step 338","\u2003for (; SG_fmap[idx].mname != NULL; idx++) {"]},{"entry":[{},"\u2003\u2003if (strcmp(SG_fmap[idx].mname, name) == 0) {"]},{"entry":[{},"\u2003\u2003\u2003SG_fmap[idx].mfunc = func;"]},{"entry":[{},"\u2003\u2003\u2003return 1;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003return 0;"]},{"entry":[{},"}"]},{"entry":["Step 339","static intfunc _lookup_mfunc (char * name)"]},{"entry":["Step 340","{"]},{"entry":["Step 341","\u2003int idx = 0;"]},{"entry":["Step 342","\u2003for (; SG_fmap[idx].mname != NULL; idx++) {"]},{"entry":[{},"\u2003\u2003if (strcmp(SG_fmap[idx].mname, name) == 0) {"]},{"entry":[{},"\u2003\u2003\u2003return SG_fmap[idx].mfunc;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":["Step 343","\u2003return NULL;"]},{"entry":[{},"}"]},{"entry":["Step 344","Int"]},{"entry":["Step 345","unmarshall_testcatalog (char * buf, int size, void * arg)"]},{"entry":[{},"{"]},{"entry":["Step 346","\u2003int result = 0;"]},{"entry":["Step 347","\u2003void * msg = decode_message(buf, size);"]},{"entry":["Step 348","\u2003char * mname = get_message_type(msg);"]},{"entry":["Step 349","\u2003int idx;"]},{"entry":["Step 350","\u2003for (idx = 0; idx < 1; idx++) {"]},{"entry":[{},"\u2003\u2003if (strcmp(mname, \u201ctestone\u201d) == 0) {"]},{"entry":[{},"\u2003\u2003\u2003int p1 = get_message_arg_int(msg, 1, 0);"]},{"entry":[{},"\u2003\u2003\u2003char * p2 = get_message_arg_str(msg, 2, 0);"]},{"entry":[{},"\u2003\u2003\u2003int p3 = get_message_arg_int(msg, 3, 0);"]},{"entry":[{},"\u2003\u2003\u2003intfunc func = _lookup_mfunc(mname);"]},{"entry":[{},"\u2003\u2003\u2003result = (func)(p1,p2,p3,arg);"]},{"entry":[{},"\u2003\u2003\u2003break;"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":["Step 351","\u2003delete_message(msg);"]},{"entry":["Step 352","\u2003return result;"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Returning now to the mobility system example of , it will be apparent that the interface file  and the implementation file  are stored in the library . After storage, the library  includes message-specific routines. The routines may include, by way of example but not limitation, message marshalling, message unmarshalling, and registration routines for each message. In a non-limiting embodiment, these routines are not shared among messages. However, in alternative embodiments, some of the functions or routines could be shared. For example, the routines could include a dispatch routine that is shared among more than one message.","In the example of , the interface file  is included, either directly or indirectly, in the operational systems code . Operational systems code  may for example be a computer program in one of the processes making use of the library. The compiled interface file  and implementation files are included in the MSS , along with the operational systems code . The MSS  may be based upon, by way of example but not limitation, Trapeze Networks' Mobility Switch Software\u2122.","Embodiment of Method for Utilizing a Mobility System","Attention is now directed to a description of an embodiment of a method for utilizing a mobility system relative to the flowchart diagram of  depicts a flowchart  of an exemplary embodiment of a method for utilizing a system having interprocess communications, such as mobility system. In the example of , the flowchart  starts at module  where a function to handle a response is created.","By way of example but not limitation, the function to handle a response could be similar to the sample function depicted in Table 7. This exemplary function to handle a response performs a minimal function handling task.","In the example of , the flowchart  continues at module  where the function is registered in a catalog. By way of example but not limitation, the function may be registered with a call to registration code: \u201cregister_mfunc_testcatalog(\u201ctestone\u201d, testonefunc);\u201d. See, e.g., the code \u201cregister_mfunc_testcatalog (char * name, intfunc func)\u201d in Table 4 where in this example, char*name is \u201ctestone\u201d and intfunc func is \u201ctestonefunc\u201d. The registration code may include registering a callback function.",{"@attributes":{"id":"p-0122","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Sample Handler Function"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"static int"]},{"entry":[{},"testonefunc(int p1, char * p2, int p3, void * arg)"]},{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003fprintf(stdout, \u201cCalled with %d, %s, %d\\n\u201d, p1, p2, p3);"]},{"entry":[{},"\u2003\u2003return 1;"]},{"entry":[{},"}"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In the example of , the flowchart  continues at module  where a message is generated or created. By way of example but not limitation, the message may be generated or created with a call to marshalling code to create the message: \u201cmarshall_message_testone(buffer, 2048, 55, \u201ctest\u201d, 28);\u201d. See for example, the C code for \u201cmarshall_message_testone (char * buffer, int bufsize, int parameter1, char * parameter2, int parameter3)\u201d in Table 4. Where the function may be registered at a first location or process, such as a first process (e.g., Process A), the message may be created at a second location or process, such as a at a second process (e.g., Process B). The marshalling code may include creating a message, encoding the message, deleting the message, and returning a result. Advantageously, the marshalling code does not require symmetry between the one process and another process.","When these inter-process communication or interaction aspects of the invention are applied in a network environment where there may be one of more servers or clients, these different processes may apply to server-server communications, client-server communications, and\/or to client-client communications. It will also be appreciated that since the inventive system, method, and techniques do not really have a client-server, server-client, client-client, or server-server specificity, that the label of client and server are somewhat misapplied. However, it may be appreciated that the invention may be applied to clients, server, and to interactions between clients and servers. The term producer and consumer may be more appropriate and it will be appreciated that a process may at the same time be both a producer for one interaction or communication and a consumer for a different interaction or communication.","In the example of , the flowchart  continues at module  where the encoded message is sent. In one non-limiting embodiment, the encoded message is sent from the first process to a second process, and then a response from the second process is received and read by the first process. When making an analogy to threads, sending the message may be considered part of the same thread as the marshalling (step ). In either case, in a non-limiting embodiment the thread does not continue, waiting for a reply from a server. Rather, the message is sent and the thread ends. In a non-limiting embodiment, the message is received at, for example, the server where the message was registered (step or module ). The server may execute a dispatch routine, possibly including marshalling a response, and send the response back to the client.","In the example of , the flowchart  continues at module  where a response is received. In a non-limiting embodiment, the response is received at the first process. The first process may start a new thread.  illustrates one example of the processes and threads as described in the example of .","In the example of , the flowchart  ends at module  where the incoming message sent by the one process and received by the other process is processed by for example a dispatch function. By way of example, but not limitation, the message may be processed with a call to an unmarshalling routine, such as by a call to unmarshalling code: \u201cunmarshall_testcatalog(buffer, 2048, NULL);\u201d. See for example, the exemplary C-language code for \u201cunmarshall_testcatalog (char * buf, int size, void * arg)\u201d in Table 4. Processing the received response is performed in order to perform useful work with the message, such as to perform the instruction or satisfy a request made in the message. The last argument or information of the unmarshalling code (i.e., NULL) is, in the exemplary implementation, an optional state argument or information that may be passed to the function defined in Table 5, and can be used to maintain state in one of the processes or to obtain or exchange state or status information between processes.","The method of the flowchart  and other methods are depicted as serially arranged modules. However, modules of the methods may be reordered, or arranged for parallel execution as appropriate.","In light of the description provided herein it will be apparent that the invention provides a generalized inter-process message structure, messaging method and procedure, and substantially automated method for generating messages from high-level languages that unburden developers.","Having described various embodiments of the inventive system, method, device, and computer program for generalized messaging attention is now directed to a highlighting of several non-limiting embodiments of the invention having particular combinations of features. Some of these features may then be extended to provide information gathering capabilities and information setting capabilities across process boundaries as are described elsewhere herein.","In one (1) embodiment, the invention provides a method for automatically generating an implementation data structure for an inter-process message to achieve a communication between a first process and a second process, the method comprising: adopting a message input specification for specifying a message input language and a message input format; adopting at least one rule for converting any input message complying with the message input specification into at least one executable message structure in a message implementation language different from the message input language; receiving a particular input message complying with the message input specification; and automatically generating a particular executable message implementation data structure corresponding to the particular input message from the particular input specification.","In another embodiment (2), the method of (1) provides that the automatically generating includes processing the received input message through a message converter to generate the executable message implementation data structure.","In another embodiment (3), the method of (1) provides that the message converter comprises a message compiler and the executable message implementation data structure comprises a executable implementation file and an interface file.","In another embodiment (4), the method of (1) provides that the input message includes XML language elements, the message compiler comprises an XML-language to C-language compiler, and the executable implementation language file comprises a C-language file.","In another embodiment (5), the method of (1) provides that the message input language comprises a high-level programming language file and the implementation data structure includes a low-level executable program code file; and the low-level executable program code file is generated from the high-level programming language specification of the message without programmer coding.","In another embodiment (6), the method of (1) provides that the message input language comprises an XML programming language and the input message is defined in a document type definition file.","In another embodiment (7), the method of (1) provides that the implementation data structure comprises at least one executable program code file.","In another embodiment (8), the method of (1) provides that the executable program code comprises executable program code in a C-programming language.","In another embodiment (9), the method of (1) provides that the executable program code comprises executable program code in a C-programming language and includes a plurality of C-language program components selected from the set of program components consisting of functions, routines, subroutines, procedures, libraries, and combinations thereof.","In another embodiment (10), the method of (1) provides that n the implementation data structure further comprises an interface data structure.","In another embodiment (11), the method of (1) provides that the interface data structure comprises a header file.","In another embodiment (12), the method of (1) provides that the adopting a message input specification for specifying a message input language and a message input format, further comprises: defining the message input specification for specifying a message input language and a message input format.","In another embodiment (13), the method of (1) provides that the adopting at least one rule for converting any input message complying with the message input specification into at least one executable message structure in a message implementation language different from the message input language, further comprises: defining the at least one rule for converting any input message complying with the message input specification into at least one executable message structure in a message implementation language different from the message input language.","In another embodiment (14), the method of (1) provides that the method further comprising preparing the particular input message complying with the message input specification; and the automatically generating a particular executable message implementation data structure is performed without human intervention.","In another embodiment (15), the method of (1) provides that the high-level message specification and rules completely enable automated generation of an executable message and any interface that may be required.","In another embodiment (16), the method of (1) provides that at least one rule for converting any input message includes at least one rule for marshalling message elements into a complete message.","In another embodiment (17), the method of (1) provides that the marshalled message is hardware agnostic.","In another embodiment (18), the method of (1) provides that at least one rule for converting any input message includes at least one rule for generating a message catalog.","In another embodiment (19), the method of (18) provides that a message catalog contains messages, messages contain parameters, parameters may optionally include sub-parameters, parameters have a parameter identifier (ID), and each parameter has a parameter type selected from among a set of defined parameter types.","In another embodiment (20), the method of (1) provides that the message input specification for specifying a message input language and a message input format comprises a formal specification that defines how to specify the message in terms of a high-level XML language so that executable code to implement the specified message may automatically be generated without human coding or intervention.","In another embodiment (21), the method of (1) provides that the message is an interprocess message.","In another embodiment (22), the invention provides a computer readable medium encoded with a computer program for directing a computer to generate a particular executable message implementation data structure corresponding to the particular input message from a particular input message, the computer program including a module that includes executable instructions for: accessing at least one rule for converting an input message complying with a known message input specification into at least one executable message structure in a message implementation language different from the message input language; receiving a particular input message complying with the message input specification; and automatically generating a particular executable message implementation data structure corresponding to the particular input message from the particular input specification.","In another embodiment (23), the invention provides an inter-process message definition structure comprising: a formal message input specification wherein an interprocess message is defined in terms of a document type definition (DTD) file; at least one message catalog element including a catalog name; at least one parameter for at least one message catalog element; and an optional sub parameter for at least one parameter.","In another embodiment (24), the invention provides an inter-process message catalog data structure comprising: an XML version element; a message catalog name element; a message catalog call name element; and at least one message parameter identifier element and at least one message parameter type element.","In another embodiment (25), the invention provides a method for communicating a message between a first process and a second process, the method comprising: generating (marshalling) an encoded inter-process message data set, the inter-process message data set including an encoded message interface file and an encoded message implementation file; sending the encoded message from the sending first process to the destination second process, the sending first process not being required to wait for a response from the destination second process; receiving a response from the destination; processing the received response; and optionally extracting a state information.","In another embodiment (26), the method of (25) provides that the generation of the message includes marshalling of message elements into a message to be sent.","In another embodiment (27), the method of (25) provides that the processing of the received response includes unmarshalling the received response.","In another embodiment (28), the method of (25) provides that there is no client-server dependency relationship between the first process and the second process or between the second process and the first process.","In another embodiment (29), the method of (25) provides that the messaging between the first process and the second process is a peer-to-peer symmetric messaging.","In another embodiment (30), the method of (25) provides that the message may be sent from the first process to the second process and\/or from the second process to the first process and is not a remote procedure call.","In another embodiment (31), the method of (25) provides that there is no dependency on the processing behavior or timing on either the sending first process side or the receiving destination second process side.","In another embodiment (32), the method of (25) provides that the message does not have a dependency on a processing behavior on either the sending first process side or on the destination receiving second process side.","In another embodiment (33), the method of (1) provides that for each message sent by a sender process, a response back to the sender process from the destination receiving process is optional and non-receipt of a response does not degrade operation in the first sending process.","In another embodiment (34), the method of (1) provides that in messaging, a message is sent, a acknowledgement of delivery may be returned, and a response may or may not be returned.","In another embodiment (35), the invention provides a method for sending an interprocess communication from a sending process to an external second process, the method comprising: generating an encoded inter-process message data set, the inter-process message data set including an encoded message interface file and an encoded message implementation file, the generation of the message includes marshalling of message elements into a message to be sent; and sending the encoded message from the sending first process to the destination second process, the sending first process not being required to wait for a response from the destination second process.","In another embodiment (36), the invention provides a network device adapted for coupling to a network including a plurality of other network devices by a communications link, the network device comprising: a processor and random access memory coupled to the processor, the processor for executing computer program code instructions; a persistent non-volatile memory for storing configuration information and the computer program code instructions; a communications port for sending and receiving messages with other ones of the other network devices; and means for sending and receiving messages.","Exemplary System for Messaging, Gathering Status and Statistics, and\/or Non-Persistent or Persistent Setting of Information Across Process Boundaries","The above described message structure and messaging method and procedures may be used as an underlying layer to message between processes generally, this messaging may optionally but advantageously also be utilized to communicate (send and\/or receive) status, statistics, and other information or data between processes, as well as to set or reset status, data, information, conditions, or memory in at least a non-persistent fashion.","Although the methods and procedures described herein are not limited to any particular system or hardware configuration, optionally but advantageously, the mobility system  (See for example ) may be used to retrieve statistics, status, and\/or other information across process boundaries, by for example using an automated object definition scheme as described above. This scheme may advantageously be XML-based or non-XML-based. This allows statistical (STATistical), status (STATus), and\/or other information (generally referred to herein as STAT) to be specified in terms of objects using XML or other object oriented or definitional languages. Application Program Interfaces (APIs) and implementation files may be generated in, by way of example but not by way of limitation, the C programming language. In a non-limiting embodiment, the system is independent of hardware, operating system, and interprocess transport layer or scheme.","It is desirable to simplify STAT or per-STAT information massaging or acquisition program code as much as possible from the developer, hiding or at least relieving the developer from any need to understand the complexity in any STAT infrastructure. This simplification or higher level abstraction may generally result in faster and less expensive code development and more robust code.",{"@attributes":{"id":"p-0170","num":"0169"},"figref":["FIG. 4","FIG. 4"],"b":["400","400","402","400","404","400","406"]},{"@attributes":{"id":"p-0171","num":"0170"},"figref":"FIG. 5","b":["500","502","504","502","504","502","502","504"]},"It may be appreciated that many multitasking systems do not have a systematic way in which to obtain, send, retrieve, or otherwise exchange or transfer statistical, status, or other information or data between processes. This being the case, each software or code developer tends to define his\/her own way in which to retrieve and\/or send this information. It is desirable to provide a scheme in which to not only define this information in a generic way, but also to automatically generate interfaces, such as for example Application Programming Interfaces (APIs) and implementation code and any ancillary interface information which developers can use to easily obtain, send, transfer and\/or retrieve such information or data. Among its advantages, such an approach saves development time and increases code and process stability.","This approach also advantageously allows statistical and status information to be specified in terms of objects using a higher-level and more intuitive language such as the exemplary XML language. APIs may for example be generated in the C programming language or other implementation languages. Furthermore, the approach is advantageously independent of hardware, operating system, and interprocess transport schemes.","An embodiment of the overall design of the architecture, structure, method, and procedure for collecting or retrieving statistics and status (STAT) and other information in a multi-process environment is now described. In particular, the invention provides a means and mechanism for STAT information to be passed across process boundaries. This description includes a high-level description of the transport mechanism used to transfer STAT information between processes as well as detailed descriptions of software Application Program Interfaces (APIs) that may be used by developers.","The invention provides a mechanism for communicating the STAT information across process boundaries so that the STAT information that may be resident in the first process may be obtained and utilized in the second process or vice versa.","It will be appreciated in light of the description provided herein that the APIs are provided by way of example, and not by way of limitations and that different and other APIs may be developed and used in accordance with the invention. The description includes the software architecture and the APIs provided to or for applications. The applications may for example include but are not limited to applications on network switches operating under a network based system.","With reference to , a high-level view of the information retrieval or STAT model may include two components, an information producer (such as a status or statistical \u201cSTAT\u201d information producer) and an information consumer (such as a status or statistical \u201cSTAT\u201d information consumer). The STAT consumer would typically reside inside the a first process (e.g., Process \u201cA\u201d), such as for example in a device configuration (CFG) process, while the producer may typically reside in a second process (e.g., Process \u201cB\u201d) which may for example be in one non-limiting embodiment, a network process that is somehow associated with the exemplary device process. In one non-limiting embodiment of the invention wherein the two processes are processes within a network switch, the configuration process is the process responsible for configuring settings or parameter of the switch and the network process is responsible for providing one or more parameters or status information items.","It may be appreciated however, that the producer and consumer could simultaneously exist or reside in other places as well (for example, the first process could be a STAT consumer and another external process could be a producer of STAT information). Furthermore, the invention is not limited to any particular environment, such as a network environment, or to any particular process or processes within a particular network device, such as a network switch device.","In the exemplary embodiment of , the information consumer in a first process is a STAT consumer in an exemplary configuration process generates a status or statistical information (e.g., STAT) request, and sends the request to a second process which in this example is a network process, wherein it may be received by the STAT producer, optionally via a dispatcher. The second or STAT producer process then takes up the request, and generates a response that it sends back to the first STAT consumer in the first or configuration process, optionally via a dispatcher. In one embodiment, a STAT dispatcher receives a STAT message, decodes the message based on the received message type, and then provides and optionally executes the appropriate callback function.","In one non-limiting embodiment, the design process involves three basic steps: (1) Define STAT \u201cmessages\u201d in a high level descriptive or programming language, such as in the XML language, (2) Run the high-level descriptive language through an appropriate compiler, such as XML language through an XML compiler, to generate per-STAT message Application Program Interfaces (APIs), and (3) Use these APIs to fetch or otherwise obtain the STAT information needed by one process from another process.","Exemplary STAT Message Formats","Exemplary STAT Message formats are now described. In one non-limiting embodiment, the STAT messages may be considered as a special class of the generic network-type inter-process messages as described herein before. In one embodiment, STAT messages may contain a STAT header, keys, and one or more records; however, some of these may be absent or null. In embodiments that utilize an implementation or header file, the header or implementation may be required in the request and in the response to that request, but the other elements are optional including for example the keys which may be absent or null. ) shows an exemplary structure of a STAT request and ) shows an exemplary structure of a STAT response.","An exemplary embodiment of a STAT header (or interface description) for the STAT request (e.g., STAT_REQUEST) and STAT response (e.g., STAT RESPONSE) are illustrated in . It may include a plurality of fields or appropriate size, such as six 4-byte fields in one none-limiting embodiment. The length field indicates the total size or number of elements (e.g. number of octets) in the message, not including the STAT header. The sequence number (seqnum) field indicates an ever-increasing message sequence number. Other or different numbering schemes may alternatively be used. The number of records (num_rec) field indicates the total number of records included in the message, but does not include keys. The flags field uses a zero bit (bit ) to indicate exact or next (bit =exact_next), where if bit =0 then a Get-Exact operation is indicated and if bit =1, a Get-Next operation is indicated; and a one bit (bit ) to indicate first or not first (bit =first) where if bit =1 a first operation is indicated and if bit =0, a not-first operation is indicated. The result field indicates a returned result from operation, and is typically only used in response message. The last record (lastrec) field indicates an Offset to the last record in the message, and is counted as the number of bytes from the start of the message body, where in at least one non-limiting embodiment, the message body starts immediately after the message header.","The record and keys use the generic inventive message format described relative to the general messaging described herein before relative to marshalling and shown in . The structure in  also shows the format of a general message type, even when that general message is not requesting or communicating status or statistics. Some fields (such as for example the \u201ckey\u201d field may be null field however for a generalized message. The STAT type messages may generally provide and utilize the \u201ckey\u201d element as set forth in the DTD for the STAT message type in Table 9. The key element includes reference information on the process on the other side for the STAT message to return, and the returned response stat message includes a similar key or reference information for use by the receiver of the response. When a general message does not need to reference or have information returned, the key is not needed. The record and key may include a variable length message type (e.g., msg_type) field that indicates a len\/string defining the type of generic message; a four-byte number of parameters (num_par) field identifying the number of parameters in the record\/key; and a parameters (param) field, that indicates the parameters encoded with parameter identifier (ID), parameter type, parameter length (len), and parameter value. A return status code is or may optionally but advantageously be sent in the STAT response message as part of a STAT operation.","Exemplary STAT Message Definitions","In one non-limiting embodiment, messages are advantageously defined in XML; however, other languages may be used to define or specify messages. A message incorporating a new STAT element is defined as follows in Table 9, showing an exemplary DTD for a STAT message. The STAT message element provides an extension over and above the general message type described herein before, in that for at least on non-limiting embodiment, the STAT message element comprises a feature that provides a capability for returning an information item (such as for example some value, statistical information or plurality of information items, or some status or set of status, or a combination of these) from another process so that the statistical, status, or other information may be requested from across a process boundary without many of the negative impacts that may be incurred using conventional inter-process messaging or information gathering techniques. As described above, the message structure and format includes a \u201ckey\u201d element that permits reference from the STAT message sender requesting the information, and another key that is included with the message back from the other responding process so that the process receiving the response has a reference to match it back with either the requested information or with the requesting process. Comparison between the general \u201cMESSAGE\u201d and the \u201cSTAT-MESSAGE\u201d are apparent from a comparison of the exemplary DTD descriptions in Table 1 and Table 9.","The STAT type message is a more complex and complicated message type than the generalized message, at least in part because of the need have information returned from the destination process back to the originally requesting origination process. Some of these additional application program interfaces (APIs) and code are described in greater detail herein below. One of the optional features that may advantageously be included with the STAT type message is an indicator, parameter, flag, field, pointer, or the like having at least two possible states that indicates whether the message should be executed as a synchronous communication or message, or as an asynchronous communication or message.","Several parameter types are identified and these parameter types will be understood to be exemplary and non-limiting as workers in the art will appreciate in light of the description provided herein that other and different types of parameters may be added.","STAT-MESSAGE generates the interfaces for statistics, which automatically create both the request and the response prototypes, and provides either one of the synchronous and asynchronous prototypes. Later in this description and in the related applications is described a NPS-MESSAGE type will be described which generates the interfaces for persistent or non-persistent set of information or state type operations, and which automatically creates both request and response prototypes, with no user data returned in the response. The set operation is non-persistent in the target process and may be made persistent in the target process by directing the receiving process to save or store the state that is communicated by the NPS message.",{"@attributes":{"id":"p-0188","num":"0187"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary DTD for STAT Message (STAT-MESSAGE)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"<!-- dtd for STAT message -->"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["<!ELEMENT","CATALOG (STAT-MESSAGE*)>"]},{"entry":["<!ATTLIST","CATALOG"]},{"entry":[{},"catalogname NMTOKEN #REQUIRED>"]},{"entry":["<!ELEMENT","STAT-MESSAGE (STAT-PARAMETER*)>"]},{"entry":["<!ATTLIST","STAT-MESSAGE"]},{"entry":[{},"callname ID #REQUIRED>"]},{"entry":["<!ELEMENT","STAT-PARAMETER EMPTY>"]},{"entry":["<!ATTLIST","STAT-PARAMETER"]},{"entry":[{},"id \u2003\u2002CDATA #REQUIRED"]},{"entry":[{},"name \u2009CDATA #REQUIRED"]},{"entry":[{},"type \u2009(INT32|UINT32|INT64|UINT64|OPAQUE|STR|"]},{"entry":[{},"SEQ) \u2003\u2003#REQUIRED"]},{"entry":[{},"key \u2002\u2009(YES|NO) \u201cNO\u201d"]},{"entry":[{},"cfg-link CDATA"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Parameter type SEQUENCE is a special and optional parameter type that is used to define a list of elements within a message. These list elements may also or alternatively be defined to be messages. This allows embedding one or more levels of messages within a message. This functionality may generally be useful for more complex data structures where one or more levels of lists or other data structures are attached to a main structure. General STAT APIs used to support sequences are described herein elsewhere.","A sample STAT catalog and message would look something like the example in Table 10. The \u201cname\u201d identifies the attribute via a user-defined string. The \u201ctype\u201d identifies the type of the attribute (integer, string, etc). The \u201ckey\u201d indicates whether the attribute is to be sent in the request message. Typically, the parameters which uniquely identify the record define the key. However, it is also possible to add other parameters to the key which may be used as filters in the request.","It may be appreciated that a message catalog my include general messages, information passing, status, and\/or statistics (STAT) type messages, as well as persistent or non-persistent set (NPS) messages in the same catalog. Alternatively different catalogs may be used for different message types.",{"@attributes":{"id":"p-0192","num":"0191"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary STAT Catalog and Message"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<CATALOG catalogname=\u201caaa\u201d>"]},{"entry":[{},"\u2003\u2003<!-- Admin user session information"]},{"entry":[{},"\u2003\u2003\u2003-->"]},{"entry":[{},"\u2003\u2003<STAT-MESSAGE callname=\u201caaa_admin_session\u201d>"]},{"entry":[{},"\u2003\u2003\u2003<!-- TTY used -->"]},{"entry":[{},"\u2003\u2003\u2003<STAT-PARAMETER name=\u201ctty\u201d type=\u201cINT32\u201d"]},{"entry":[{},"\u2003\u2003\u2003key=\u201cyes\u201d\/>"]},{"entry":[{},"\u2003\u2003\u2003<!-- Name of the user -->"]},{"entry":[{},"\u2003\u2003\u2003<STAT-PARAMETER name=\u201cusername\u201d type=\u201cSTR\u201d \/>"]},{"entry":[{},"\u2003\u2003\u2003<!-- session time -->"]},{"entry":[{},"\u2003\u2003\u2003<STAT-PARAMETER name=\u201ctime\u201d type=\u201cINT32\u201d \/>"]},{"entry":[{},"\u2003\u2003<\/STAT-MESSAGE>"]},{"entry":[{},"\u2003\u2003<!-- Define additional messages here"]},{"entry":[{},"\u2003\u2003\u2003-->"]},{"entry":[{},"<\/CATALOG>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Computer program software code for the implantation and interface files (where required) is generated after the STAT messages have been fully defined in the defining language (such as in the XML language), by running through a compiler (for example, through an XML compiler when the defining language is XML) which produces an output code in the target output language, such as C code. An interface file, such as the header or h-file may also be generated as for the general message file described herein before above. It will be apparent to those workers in the art in light of the description provided herein that although aspects of the invention are described relative to XML as the high-level defining language, and to a C-language file as the compiler output language, the invention is not limited to these particular exemplary languages. By way of example, and as described relative to general messages, but not limitation, the defining language may be XML or any other language; and the compiled output language may be C, C++, or any other language, and that the defining language may generally be used with an appropriate compiler to generate any of the possible output codes.","While it will be appreciated that any languages may be used, the inventive system, method, technique, and computer programs and computer program product for general messages, information or STAT messages, and for interprocess persistent or non-persistent set messages, advantages do arise from using XML as a high level intuitive language and outputting to C, C++ or one of the related languages, which are commonly used for contemporary programming features. This choice of languages may therefore also be considered a novel and non-obvious aspect of at least some embodiments of the invention.","There are several functions that may advantageously be automatically generated for each STAT message defined. These functions comprise the Application program Interface (API) which developers may then use when implementing STAT gathering or retrieval.  shows by way of example, some of the functions that are automatically generated by the compiler, and what the STAT message transformation or conversion tool (in some embodiments the STAT message compiler). Some functions are internal functions such as marshall message, unmarshall message, unmarshall, register marshall function, and dispatcher functions (for example, in some exemplary embodiments these functions may include marshall_message_<msg>, unmarshall_message_<msg>, unmarshall_<msg>, register_mfunc_<cat>, and dispatcher_<msg>) that may be used by the message producer and consumer, and the rest of the functions are used by the STAT message consumer (for example, stat_get_<msg>, stat_nextrec_<msg>, and stat_nextkey_<msg>) and the STAT message producer (e.g., stat_register_<msg>, stat_alloc_<msg>, stat_dealloc_<msg>, and stat_insert_<msg>).","As illustrated in , some of the auto generated APIs are per-message APIs and some are per-catalog auto generated APIs, identified in the Internal functions block by the per-message indicator \u201c<msg>\u201d suffix and the per-catalog indicatior \u201c<cat>\u201d suffix respectively. A set of APIs (internal, consumer, and producer) are automatically generated for each message and for each catalog. The different classes of APIs and members of the classes are described in greater detail below.","In terms of transport mechanism, STAT information will be requested by a STAT consumer and returned by a STAT producer. The STAT consumer sends a STAT request message and the STAT Producer returns a STAT response message. These messages will be organized or marshaled using the marshalling scheme described herein before. The invention is transport mechanism independent and any know or to be developed transport mechanism may be utilized.","Exemplary STAT Application Program Interfaces (APIs)","In at least one non-limiting embodiment of the invention, the STAT model includes application program interfaces. General APIs are used by all STAT-provider and STAT-consumer callback functions and may be common across all message types. They are not typically generated on a per-message or per-catalog basis as are the per-message and per-catalog message specific APIs described below.",{"@attributes":{"id":"p-0199","num":"0198"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"General API: stat_init_producer( )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Syntax:"},{"entry":"int stat_init_producer (char *sess_name);"},{"entry":"Parameter(s):"},{"entry":"Sess_name -- Name of the STAT Producer session"},{"entry":"Returns:"},{"entry":"Returns a session ID to be used in stat_get_<msg>."},{"entry":"Operation:"},{"entry":"API stat_init_producer( ) initializes the STAT Producer, enabling it to"},{"entry":"accept new sessions from one or more STAT Consumers."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0200","num":"0199"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"General API: stat_init_consumer( )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"int stat_init_consumer (char *sess_name);"},{"entry":"Parameter(s):"},{"entry":"Sess_name -- Name of the STAT Consumer session"},{"entry":"Returns:"},{"entry":"Returns a session ID to be used in stat_get_<msg>."},{"entry":"Operation:"},{"entry":"API stat_init_consumer( )establishes a session with the STAT Producer"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0201","num":"0200"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"General API: stat_alloc"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Syntax:"},{"entry":"stat_hdl_t * stat_alloc (void);"},{"entry":"Parameter(s):"},{"entry":"(none)"},{"entry":"Returns:"},{"entry":"Returns a pointer to a STAT handle to be used in other STAT APIs."},{"entry":"Operation:"},{"entry":"API stat_alloc( ) allocates a descriptor, or handle, to hold state"},{"entry":"information"},{"entry":"for the STAT session. Must be called by STAT Consumer before calling"},{"entry":"stat_get_<msg>."},{"entry":"Must call stat_dealloc( ) after done with handle."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0202","num":"0201"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"General API: stat_dealloc"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Syntax:"]},{"entry":[{},"void stat_dealloc (stat_hdl_t *stat_hdl);"]},{"entry":[{},"Parameter(s):"]},{"entry":[{},"Stat_hdl -- STAT handle"]},{"entry":[{},"Returns:"]},{"entry":[{},"Returns a session ID to be used in stat_get_<msg>."]},{"entry":[{},"Operation:"]},{"entry":[{},"Frees a STAT handle allocated by stat_alloc( )."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0203","num":"0202"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 15"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"General API: stat_done"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Syntax:"},{"entry":"void stat_done (stat_hdl_t *stat_hdl);"},{"entry":"Parameter(s):"},{"entry":"stat_hdl -- STAT handle"},{"entry":"Returns:"},{"entry":"Returns a session ID to be used in stat_get_<msg>."},{"entry":"Operation:"},{"entry":"Used by STAT Producer to return the STAT response message."},{"entry":"Should be called when all records have been sent in the response."},{"entry":"This accommodates an asynchronous case where the STAT Producer"},{"entry":"cannot respond to a request in a reasonable amount of time, or does"},{"entry":"not want to hold up a network operating system or other network process"},{"entry":"waiting to collect data. Once all data has been collected,"},{"entry":"stat_done( ) is called. This must be called in all cases."},{"entry":"The stat_hdl is deallocated in stat_done( )."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0204","num":"0203"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 16"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"General API: stat_seq_count"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Syntax:"]},{"entry":[{},"unsigned int stat_seq_count (stat_hdl_t *seq);"]},{"entry":[{},"Parameter(s):"]},{"entry":[{},"seq -- STAT sequence handle"]},{"entry":[{},"Returns:"]},{"entry":[{},"Returns the number of records in the sequence."]},{"entry":[{},"Operation:"]},{"entry":[{},"Returns the number of records in the sequence."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0205","num":"0204"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 17"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"General API: stat_set_errstr"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Syntax:"},{"entry":"unsigned int stat_seq_count (stat_hdl_t *seq);"},{"entry":"Parameter(s):"},{"entry":"seq - STAT sequence handle"},{"entry":"Returns:"},{"entry":"Returns a formatted error string from the STAT Producer to the STAT"},{"entry":"Consumer."},{"entry":"Must be called before stat_done( )."},{"entry":"Operation:"},{"entry":"Returns a formatted error string from the STAT Producer to the STAT"},{"entry":"Consumer."},{"entry":"Must be called before stat_done( )."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0206","num":"0205"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 18"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"General API: stat_get_errstr"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"char *stat_get_errstr(stat_hdl_t *stat_hdl);"},{"entry":"Parameter(s):"},{"entry":"stat_hdl -- STAT handle"},{"entry":"Returns:"},{"entry":"Any error string returned from the STAT Producer. NULL if no error"},{"entry":"string present"},{"entry":"Operation:"},{"entry":"Used by the STAT Consumer to retrieve any error string returned from the"},{"entry":"STAT Producer. NULL if no error string present."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0207","num":"0206"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 19"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"General API: stat_timeout_set"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Syntax:"]},{"entry":[{},"int stat_timeout_set(stat_hdl_t *stat_hdl, int timeout);"]},{"entry":[{},"Parameter(s):"]},{"entry":[{},"stat_hdl -- STAT handle"]},{"entry":[{},"timeout -- timeout value in seconds"]},{"entry":[{},"Returns:"]},{"entry":[{},"Returns 0 upon success, otherwise error."]},{"entry":[{},"Operation:"]},{"entry":[{},"Used by the STAT Consumer to change the timeout value of the"]},{"entry":[{},"stat_get_<msg> call. Returns 0 upon success, otherwise error."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Several auto-generated APIs for the STAT messaging are now described. Autogenerated APIs are typically generated on a per STAT-MESSAGE basis. For example, there is an entire set or plurality of APIs generated that are specific to the given STAT-MESSAGE. This differs from the generalized APIs, which are global and shared across all message types. For each of the below described Autogenerated APIs, the message \u201c<msg>\u201d is the message name defined in the XML message definitions. A stat_<msg> structure is generated for the returned records in the format in Table 20. This stat_<msg> structure is provided for the application programmer to conveniently fill in message parameters in the STAT callback function.","Table 21 through Table 28 provide exemplary descriptions of several autogenerated STAT APIs as well as an exemplary Handler.","The autogenerated API stat_nextrec_<msg> in Table 21 is used by the STAT Consumer to retrieve the next record in a STAT response. The stat handle keeps track of the next record in the response message.","The autogenerated API stat next key stat_nextkey_<msg> in Table 22 is used by the STAT consumer to retrieve the key to be used for the next get request.","The autogenerated API stat_get_<msg> in Table 23 is used to send a STAT request message from STAT Consumer to STAT Producer. In the synchronous case, this function blocks and waits for a STAT response message from the STAT Producer.","The autogenerated API stat_register_<msg> in Table 24 is used by the STAT Producer to register a Producer Handler function for a given message. Whenever a STAT request is received for this message type, this handler is called.","The autogenerated API stat_alloc_<msg> in Table 25 allocates memory for the record of the given message type.","The autogenerated API stat_dealloc_<msg> in Table 26 frees memory for the record of the given message type.","The autogenerated API stat_insert_<msg> in Table 27 is used by the STAT Producer to insert a record into a STAT Response message.","An exemplary Producer Handler in Table 28 is not an autogenerated API, but the registered callback function that is used to process a given type of STAT message.",{"@attributes":{"id":"p-0218","num":"0217"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 20"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of stat_<msg> Structure Generated for Returned Records"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct stat_<msg>_s {"]},{"entry":[{},"\u2003\u2003. . ."]},{"entry":[{},"\u2003\u2003. . . parameters . . ."]},{"entry":[{},"\u2003\u2003. . ."]},{"entry":[{},"} stat_<msg>_t;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0219","num":"0218"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 21"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Autogenerated API: stat_nextrec_<msg>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Syntax:"},{"entry":"int stat_nextrec_<msg> (stat_hdl_t *stat_hdl, stat_<msg>_t *rec);"},{"entry":"Parameter(s):"},{"entry":"stat_hdl -- STAT handle used internally. This handle must be first"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002allocated using stat_alloc( );"},{"entry":"rec\u2003-- Next returned record. Parameters are defined in the XML"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002message"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2002definition file. Record must be allocated by caller."},{"entry":"Returns:"},{"entry":"Returns 0 for success, 1 if no more records, \u22121 for error."},{"entry":"Operation:"},{"entry":"This API is used by the STAT Consumer to retrieve the next record in a"},{"entry":"STAT response. The stat_hdl keeps track of the next record in"},{"entry":"the response message."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0220","num":"0219"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 22"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Autogenerated API: stat_nextkey_<msg>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Syntax:"},{"entry":"int stat_nextkey_<msg> (stat_hdl_t *stat_hdl, ...r_keys...);"},{"entry":"Parameter(s):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["stat_hdl","-- STAT handle used internally. This handle must be first"]},{"entry":[{},"\u2003\u2003allocated using stat_alloc( );"]},{"entry":["r_keys","-- Returned key parameters of the key of the"]},{"entry":[{},"\u2003\u2003last record in the STAT response."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Returns:"},{"entry":"Returns 0 for success, \u22121 for error."},{"entry":"Operation:"},{"entry":"This API is used by the STAT Consumer to retrieve the key to be used for"},{"entry":"the next get request in a get-bulk operation. Only needed if calling"},{"entry":"stat_get_<msg> more than once. If the calling code keeps track of"},{"entry":"the key to the last record in the last response, then it may not be"},{"entry":"necessary to call this API."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0221","num":"0220"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 23"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Autogenerated API: stat_get_<msg>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Syntax:"},{"entry":"typedef int (*stat_cfunc_t) (stat_hdl_t *stat_hdl, uint num_rec,"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"uint flags, int result);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"int stat_get_<msg> (stat_hdl_t *stat_hdl, int sess_id, uint get_cnt,"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"uint flags, stat_cfunc_t func, void *cookie, ...keys...);"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Parameter(s):"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["stat_hdl","-- STAT handle used internally. This handle must be first"]},{"entry":[{},"allocated using stat_alloc( );"]},{"entry":["sess_id","-- Session ID. Returned from stat_init_consumer( )."]},{"entry":["get_cnt","-- Specifies the number of records to get."]},{"entry":["flags","-- Flags bitfield, must OR flags if more than one used"]},{"entry":[{},"STAT_GETNEXT: Get the next entry after the one specified"]},{"entry":[{},"by the keys. Not setting this bit implies a"]},{"entry":[{},"Get-Exact operation. This bit is not used"]},{"entry":[{},"internally by the STAT code, and is only intended"]},{"entry":[{},"for the Stat Producer handler."]},{"entry":[{},"STAT_GETFIRST: Indicates that this is the first request of a"]},{"entry":[{},"series of requests. This is only needed when"]},{"entry":[{},"STAT_GETNEXT is set. It can be used to"]},{"entry":[{},"specify the first request in cases where there"]},{"entry":[{},"is no logical value of the keys that can signify"]},{"entry":[{},"the first request. This bit is not used"]},{"entry":[{},"internally by the STAT code, and is only intended"]},{"entry":[{},"for the Stat Producer handler."]},{"entry":[{},"STAT_ASYNC: Return immediately from function without "]},{"entry":[{},"waiting For response. Call function specified in func."]},{"entry":[{},"This bit is used internally and is not intended for"]},{"entry":[{},"use by the Stat Producer handler."]},{"entry":["func","-- Optional callback function used when STAT_ASYNC is set."]},{"entry":[{},"This function is called after the response message is received."]},{"entry":["cookie","-- Optional argument to pass into callback function"]},{"entry":["keys","-- Message-specific keys as marked in the message definition"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Returns:"},{"entry":"Returns 0 for success, \u22121 for error."},{"entry":"Operation:"},{"entry":"This API is used to send a STAT request message from STAT Consumer"},{"entry":"to STAT Producer. In the synchronous case (default), this function blocks "},{"entry":"and waits for a STAT response message from the STAT Producer. The"},{"entry":"keys specify the exact record or group of records to retrieve. The"},{"entry":"received records are retrieved using stat_nextrec_<msg>."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0222","num":"0221"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 24"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Autogenerated API: stat_register_<msg>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Syntax:"},{"entry":"int stat_register_<msg> (stat_func_<msg>_t func);"},{"entry":"Parameter(s):"},{"entry":"func -- Handler function"},{"entry":"Returns:"},{"entry":"Returns 0 for success, \u22121 for error."},{"entry":"Operation:"},{"entry":"This API is used by the STAT Producer to register a handler function for a"},{"entry":"given message. Whenever a STAT request is received for this message"},{"entry":"type, this handler is called. The Producer handler is described below."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0223","num":"0222"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 25"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Autogenerated API: stat_alloc_<msg>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Syntax:"},{"entry":"stat_<msg>_t * stat_alloc_<msg> (void);"},{"entry":"Parameter(s):"},{"entry":"(none)"},{"entry":"Returns:"},{"entry":"Returns a pointer to a record for this message type."},{"entry":"Operation:"},{"entry":"This API allocates memory for the record of the given message type. All"},{"entry":"fields are initialized. This should be used to allocate records which are"},{"entry":"inserted into stat_insert_<msg>. Note that only one stat_alloc_<msg>"},{"entry":"should be needed per provider callback invocation. This should only be"},{"entry":"used by the provider."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0224","num":"0223"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 26"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Autogenerated API: stat_dealloc_<msg>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Syntax:"]},{"entry":[{},"void stat_dealloc_<msg> (stat_<msg>_t *rec);"]},{"entry":[{},"Parameter(s):"]},{"entry":[{},"rec -- Pointer to the record to deallocate."]},{"entry":[{},"Returns:"]},{"entry":[{},"(none)"]},{"entry":[{},"Operation:"]},{"entry":[{},"This API deallocates a record which was allocated with"]},{"entry":[{},"stat_alloc_<msg>."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0225","num":"0224"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 27"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Autogenerated API: stat_insert_<msg>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Syntax:"},{"entry":"int stat_insert_<msg> (stat_hdl_t *stat_hdl, stat_<msg>_t *rec);"},{"entry":"Parameter(s):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["stat_hdl","-- STAT handle used internally. Received via callback"]},{"entry":[{},"function."]},{"entry":["rec","-- Record to send back to STAT Consumer. Allocated by"]},{"entry":[{},"caller."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Returns:"},{"entry":"Returns 0 for success or \u22121 for error."},{"entry":"Operation:"},{"entry":"This API is used by the STAT Producer to insert a record into a STAT"},{"entry":"Response. This function can be called multiple times to insert multiple"},{"entry":"records. This should be called from within the handler function registered"},{"entry":"above. Note that the record is reinitialized after it is inserted into the"},{"entry":"response. Therefore, the caller should not reference any old pointers in"},{"entry":"the record after an insert."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0226","num":"0225"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 28"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Producer Handler"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Syntax:"},{"entry":"typedef int (*stat_func_<msg>t) (stat_hdl_t *stat_hdl, uint get_cnt, uint"},{"entry":"flags, ... ...keys...);"},{"entry":"Parameter(s):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["stat_hdl","-- STAT handle used to pass to APIs called from the handler."]},{"entry":["get_cnt","-- Number of records requested."]},{"entry":["flags","-- flags field defined in stat_get_<msg>. Note that the following"]},{"entry":[{},"\u2003\u2002macros can be used to check the bits in the flags field:"]},{"entry":[{},"\u2003\u2002STAT_IS_GETNEXT \u2014True if STAT_GETNEXT flag is set."]},{"entry":[{},"\u2003\u2002STAT_IS_GETFIRST \u2014True if STAT_GETFIRST flag is set."]},{"entry":["keys","-- Key parameters sent in stat_get_<msg>."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Returns:"},{"entry":"OK for success. Error otherwise."},{"entry":"Operation:"},{"entry":"The Producer Handler is the registered callback function that"},{"entry":"is used to process the given type of stat message."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Appendix A sets forth some examples associated with statistics, status, and other information (STAT) messaging. The first example is of the STAT Get-Exact operation in which at most one record is retrieved from the STAT Producer. The second example shows a STAT Get-Next operation in which zero or more records are retrieved.","Exemplary Embodiment of System and Method for Persistent and Non-Persistent Setting of Information Across Process Boundaries","Limitations of conventional message structures and messaging schemes have already been described relative to interprocess messaging and messaging that retrieves status, statistics, and other information across process boundaries.","In analogous manner, many conventional multi-process multitasking systems do not have a systematic way in which to define and set information, including persistently or non-persistently set information, between processes. As such, each developer conventionally tends to define his\/her own way in which to set this information across and between processes. It is therefore desirable to provide a scheme in which to not only define this information in a more general or generic way, but also to automatically generate Application Programming Interfaces (APIs) including implementation code and any interfaces which developers can use to easily transfer and set information or data between and across process boundaries. As with other of the embodiments of the invention, these features save development time and increases code stability.","Therefore, advantageously, a system or device such as but not limited to the mobility system  (See ) may also be used to set information across process boundaries using an automated object definition scheme. One non-limiting embodiment of this scheme may be XML-based. This allows persistent or non-persistent information to be specified in terms of objects using XML. APIs may be generated in, by way of example but not by way of limitation, the C-programming language. In a non-limiting embodiment, the system is independent of hardware, operating system, and interprocess transport schemes. The use of XML allows information (to be persistently or non-persistent stored or used) to be specified in terms of objects using XML, and APIs are generated in the C-language or other lower level programming language. These exemplary implementations are independent of hardware, operating system, and interprocess transport schemes.","An embodiment of the overall design of the architecture, structure, method, and procedure for a new scheme to perform a Non-Persistent Set (NPS) of information in a multi-process environment is now described. This scheme may also be used to persistently set information across process boundaries by adding an additional store or save in the target process so that he non-persistently set information becomes persistently set. In particular, the invention provides a means and mechanism for the setting (persistently or non-persistently) of information across process boundaries. This description includes an exemplary high-level description of the transport mechanism used to transfer NPS information between processes as well as detailed software APIs to be used by developers.","In one embodiment, much of the computer program code involved in setting NPS information will reside in an external process. The invention provides a mechanism for passing or communicating the information or state to be set across process boundaries so that the information or state to be set resident in one first process may be obtained and utilized in another second process external to the first process.","It will be appreciated in light of the description provided herein that the APIs are provided by way of example, and not by way of limitations and that different and other APIs may be developed and used in accordance with the invention. The description includes the software architecture and the APIs provided to or for applications. The applications may for example include but are not limited to applications on the MX series of network switches operating under a network based system. Systems and switches such as these are made by Trapeze Networks of Pleasanton, Calif.","With reference to , a high-level view of a messaging model applied to the Non-Persistent Set operation may include two components, a NPS producer and a NPS consumer. An additional save or storage of the information at the NPS consumer may persistently save the non-persistently set information at the information consumer making that consumer a persistently set (PS) consumer.","The NPS message producer would typically reside inside one process, for example in a network device configuration first process while the NPS message consumer may reside in a different second process, such as for example in a second device or network process. Note that the consumer and producer processes may be viewed as being swapped or exchanged for the NPS model as compared to the STAT model processes. In the STAT model, a first process is requesting information from a second process, and in the NPS model a first process is sending an information or command or a set of information or command(s) to another process. Stated differently relative to our earlier example, in at least one embodiment of the STAT model, the STAT information consumer is in the configuration process and the STAT information producer is in the network process; while in the NPS model, the NPS consumer is in the network process and the NPS producer is in the configuration process. These configuration and network processes are merely convenient examples as it will be understood that the two different processes for which the inter-process messaging is occurring can be any processes.","It may be noted, however, that the producer and consumer could simultaneously exist or reside in other places as well (for example, the network process could be a NPS producer and another external process could be a consumer of NPS information). Furthermore, the invention is not limited to any particular environment, such as a network environment, or to any particular process or processes within a particular network device, such as a network switch device.","In the exemplary embodiment of , the NPS producer in the configuration (CFG) process generates a NPS request, and sends the request to the network process, and may be received by the NPS consumer (via an optional dispatcher). The NPS consumer then takes up the request, and generates a response that it sends back to the NPS producer in the configuration process, optionally via a dispatcher.","In one non-limiting embodiment, the NPS design process involves three basic steps: (1) define NPS \u201cmessages\u201d in a high level descriptive or programming language, such as in the XML language; (2) run the high-level descriptive language through an appropriate message transformation or modification tool such as an NPS message compiler (such as XML language high-level descriptive language through an XML compiler), to generate per-NPS message Application Program Interfaces (APIs); and (3) use these APIs to set the NPS information in one process from another process.","Exemplary NPS Message Formats","The Non-Persistent Set (NPS) messages are a special class of the generic inventive message described above and use substantially the same message format as the STAT information messages described herein elsewhere with reference to , , and  and are not repeated here. These NPS message formats are shown in , , and . In fact, in at least one embodiment, the NPS message format is the same as the STAT message format. Although the NPS message format may be the same as the STAT format, the information contained in the message may differ.","One difference in the NPS implementation as compared to the STAT implementation is that all NPS message parameters (NPS-PARAMETERs) may (inherently) be defined as key parameters and are therefore sent as keys in the NPS request message. Furthermore, there are no (or at least need not be any) records returned in the NPS response (as compared to the STAT response) message, only an optionally but advantageously returned status code. The status code may for example merely provide an indication that the message was received or completed successfully or some other indication of success, or failure, or error. There can be zero, one, or a plurality of NPS parameters (NPS-PARAMETERs). As with the STAT-message, a return status code is or may optionally but advantageously be sent in an NPS response message as part of a NPS operation.","Exemplary NPS Message Definitions","A exemplary new NPS message element is defined as in Table 29, showing an exemplary DTD for an NPS message. The NPS message element differs from a STAT message in that different APIs are generated and the results are different. Some of these differences are apparent from the different DTD description of an NPS-Message, while other differences will be apparent from the different APIs and code generated when processed through the NPS message transformation or conversion tool, such as for example an NPS message compiler.",{"@attributes":{"id":"p-0242","num":"0241"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 29"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary DTD for NPS Message"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<!-dtd for NPS message -->"},{"entry":"<!ELEMENT CATALOG (NPS-MESSAGE*)>"},{"entry":"<!ATTLIST CATALOG"},{"entry":"\u2003\u2003catalogname NMTOKEN #REQUIRED>"},{"entry":"<!ELEMENT NPS-MESSAGE (NPS-PARAMETER*)>"},{"entry":"<!ATTLIST NPS-MESSAGE"},{"entry":"\u2003\u2003callname ID #REQUIRED>"},{"entry":"<!ELEMENT NPS-PARAMETER EMPTY>"},{"entry":"<!ATTLIST NPS-PARAMETER"},{"entry":"\u2003\u2003id CDATA #REQUIRED"},{"entry":"\u2003\u2003name CDATA #REQUIRED"},{"entry":"\u2003\u2003type (INT32|UINT32|INT64|UINT64|OPAQUE|STR) #REQUIRED"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"An NPS message (NPS-MESSAGE) generates the interfaces for persistent or non-persistent set operations, and automatically creates both request and response prototypes, with no user data returned in the response.","A non-limiting embodiment of an exemplary sample catalog and message may have the form illustrated in Table 30. The \u201cname\u201d identifies the attribute via a user-defined string. The \u201ctype\u201d identifies the type of the attribute (integer, string, etc). Several parameter types are identified, and these types will be understood to be exemplary and non-limiting as workers in the art will appreciate in light of the description provided herein that other and different types of parameters may be added.",{"@attributes":{"id":"p-0245","num":"0244"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 30"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary structure for NPS Catalog and Message"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<CATALOG catalogname=\u201cmemorycatalog\u201d>"]},{"entry":[{},"\u2003<NPS-MESSAGE callname=\u201cmemleak_set\u201d>"]},{"entry":[{},"\u2003\u2003<NPS-PARAMETER id=\u201c1\u201d name=\u201cenable\u201d type=\u201cUINT32\u201d\/>"]},{"entry":[{},"\u2003<\/NPS-MESSAGE>"]},{"entry":[{},"<\/CATALOG>"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Code for execution is generated after the NPS message has been fully defined in the defining language (such as in a DTD file using the XML language), by running through a transformation tool or converter such as a compiler (for example, through an XML compiler when the defining language is XML) which produces an output code in the target output language, such as C language code. It will be apparent to those workers in the art in light of the description provided herein that although aspects of the invention are described relative to XML as the high-level defining language, and to C as the compiler output language, the invention is not limited to these particular languages. As for the general message or information message, any programming language may be used and the transformed or compiled output interface and implementations files may be used, though definition in the XML language and implementation in the C-language may be preferred.","There are several functions that may automatically generated for each NPS message defined. These functions comprise the Application program Interface (API) which developers may then use when implementing NPS setting.  shows by way of example, some of the functions that may automatically be generated by the compiler. Some functions are internal functions (e.g., a marshal message \u201cmarshall_message_<msg>\u201d function, an unmarshall message \u201cunmarshall_message_<msg>\u201d function, an unmarshall \u201cunmarshall_<msg>\u201d function, a register catalog \u201cregister_mfunc_<cat>\u201d function, and optional dispatcher \u201cdispatcher_<msg>\u201d function) which are typically only used by the NPS engine and the rest of the functions are used by the NPS message consumer (e.g., NPS register \u201cnps_register_<msg>\u201d) and the NPS message producer (e.g., nps_set_<msg>).","In terms of transport mechanism, NPS information will be requested by a NPS producer process and returned by a NPS consumer process. The NPS producer sends a request message and the NPS consumer optionally returns a response message. These messages will be marshaled using the marshalling scheme described herein before. The invention is transport mechanism independent.",{"@attributes":{"id":"p-0249","num":"0248"},"figref":"FIG. 12"},"Exemplary NPS Application Program Interfaces (APIs)","There are some general NPS APIs as well as NPS APIs which are automatically generated.","In at least one non-limiting embodiment of the invention, the NPS messaging model includes application program interfaces. General APIs are used by all NPS producer and NPS consumer callback functions when present and are common across all message types. They are not typically generated on a per-message or per-catalog basis as are the per-message and per-catalog message specific APIs described below.","The NPS general API: NPS set \u201cnps_set_<msg>( )\u201d in Table 34 is used to send an NPS request message from NPS Producer to NPS Consumer.","The NPS general API: NPS register \u201cnps_register_<msg>( )\u201d in Table 35 is used by the NPS Consumer to register a Consumer Handler function for a given message.","The NPS general API: NPS delete error string \u201cnps_delete_errstr( )\u201d in Table 33 is used by the NPS Consumer to delete an error string that was returned from NPS set \u201cnps_set_<msg>\u201d.",{"@attributes":{"id":"p-0255","num":"0254"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 31"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NPS General API: nps_done"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Syntax:"]},{"entry":[{},"void nps_done (nps_hdl_t *nps_hdl);"]},{"entry":[{},"Parameter(s):"]},{"entry":[{},"nps_hdl -- NPS handle"]},{"entry":[{},"Returns:"]},{"entry":[{},"(none)"]},{"entry":[{},"Operation:"]},{"entry":[{},"Used by NPS Consumer to return the NPS response message."]},{"entry":[{},"Should be called when all processing is complete."]},{"entry":[{},"This accommodates an asynchronous case where the NPS Consumer"]},{"entry":[{},"cannot respond to a request in a reasonable amount of time,"]},{"entry":[{},"or does not want to hold up NOS waiting to process data. Once"]},{"entry":[{},"all data has been processed, nps_done( ) is called. This"]},{"entry":[{},"must be called in ALL cases. nps_hdl is"]},{"entry":[{},"deallocated in nps_done( )."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0256","num":"0255"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 32"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"General API: nps_set_errstr"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Syntax:"]},{"entry":[{},"void nps_set_errstr(nps_hdl_t *nps_hdl, char *fmt,...);"]},{"entry":[{},"Parameter(s):"]},{"entry":[{},"nps_hdl - - NPS handle"]},{"entry":[{},"Returns:"]},{"entry":[{},"Returns a formatted error string from the NPS Consumer to the NPS"]},{"entry":[{},"Producer."]},{"entry":[{},"Must be called before nps_done( )."]},{"entry":[{},"Operation:"]},{"entry":[{},"Returns a formatted error string from the NPS Consumer to the NPS"]},{"entry":[{},"Producer."]},{"entry":[{},"Must be called before nps_done( )."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0257","num":"0256"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 33"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"General API: nps_delete_errstr"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Syntax:"]},{"entry":[{},"char *nps_delete_errstr(char *errstr);"]},{"entry":[{},"Parameter(s):"]},{"entry":[{},"errstr - - Error string to free"]},{"entry":[{},"Returns:"]},{"entry":[{},"Null"]},{"entry":[{},"Operation:"]},{"entry":[{},"Used by the NPS Consumer to delete an error string that was returned"]},{"entry":[{},"from nps_set_<msg>."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Several Autogenerated APIs for the NPS messaging are now described. For each of the below described Autogenerated APIs, <msg> is the message name defined in the XML message definitions. A nps_<msg> structure is generated for the returned records in the format in Table 34. This nps_<msg> structure is provided for the application programmer to conveniently acquire message parameters in the NPS callback function.","Tables 35 through 37 provide exemplary descriptions of several autogenerated STAT APIs.","The NPS general API: nps_set_<msg>( ) in Table 34 is used to send an NPS request message from NPS Producer to NPS Consumer.","The NPS general API: nps_register_<msg>( ) in Table 35 is used by the NPS Consumer to register a Consumer Handler function for a given message.","The NPS Consumer Handler (and not an API) in Table 36 is the registered callback function that is used to process a given type of NPS message.",{"@attributes":{"id":"p-0263","num":"0262"},"tables":{"@attributes":{"id":"TABLE-US-00033","num":"00033"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 34"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of nps_<msg> Structure Generated for Returned Records"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct nps_<msg>_s {"]},{"entry":[{},"\u2003..."]},{"entry":[{},"\u2003... parameters ..."]},{"entry":[{},"\u2003..."]},{"entry":[{},"} nps_<msg>_t;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0264","num":"0263"},"tables":{"@attributes":{"id":"TABLE-US-00034","num":"00034"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 35"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Autogenerated NPS API: nps_set_<msg>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Syntax:"},{"entry":"int nps_set_<msg> (int sess_id, char **errstr, ...parameters...);"},{"entry":"Parameter(s):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["sess_id","- - Session ID. Returned from stat_init_consumer( )."]},{"entry":["errstr","- - Optional pointer to returned error string. If errstr is given"]},{"entry":[{},"\u2003as non-NULL, a pointer to an error string will be returned if"]},{"entry":[{},"\u2003an error exists. NULL will be returned if no error string"]},{"entry":[{},"\u2003exists. If the caller does not want to use this feature, then"]},{"entry":[{},"\u2003errstr should be set to NULL on input. errstr should be"]},{"entry":[{},"\u2003deleted (freed) using nps_delete_errstr( )."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Returns:"},{"entry":"Returns 0 for success, \u22121 for error."},{"entry":"Operation:"},{"entry":"This API is used to send a NPS request message from NPS Producer to"},{"entry":"NPS Consumer. This function blocks and waits for an NPS response"},{"entry":"message from the NPS Consumer. The parameters specify all data to set."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0265","num":"0264"},"tables":{"@attributes":{"id":"TABLE-US-00035","num":"00035"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 36"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Autogenerated NPS API: nps_register_<msg>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Syntax:"]},{"entry":[{},"int nps_register_<msg> (nps_func_<msg>_t func);"]},{"entry":[{},"Parameter(s):"]},{"entry":[{},"func - - Handler function"]},{"entry":[{},"Returns:"]},{"entry":[{},"Returns 0 for success, \u22121 for error."]},{"entry":[{},"Operation:"]},{"entry":[{},"This API is used by the NPS Consumer to register a handler"]},{"entry":[{},"function for a given message. Whenever an NPS request is"]},{"entry":[{},"received for this message type, this NPS consumer handler is called."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0266","num":"0265"},"tables":{"@attributes":{"id":"TABLE-US-00036","num":"00036"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 37"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Autogenerated NPS API: NPS Consumer Handler"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Syntax:"},{"entry":"typedef int (*nps_func_<msg>t)(nps_hdl_t *nps_hdl, ...parameters...);"},{"entry":"Parameter(s):"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["nps_hdl","- - NPS handle used to pass to APIs called from the handler."]},{"entry":["parameters","- - Parameters sent in nps_set_<msg>."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Returns:"},{"entry":"OK for success. Error otherwise."},{"entry":"Operation:"},{"entry":"The NPS Consumer Handler is the registered callback function that"},{"entry":"is used to process a given type of NPS message."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"Appendix B sets forth some examples associated with information setting messages, such as persistent or non-persistent setting (NPS) messaging. The example is of the NPS Set Memory Leak example operation.","Additional Description","As used herein, the term \u201cembodiment\u201d means an embodiment that serves to illustrate by way of example but not limitation.","It will be appreciated to those skilled in the art that the preceding examples and preferred embodiments are exemplary and not limiting to the scope of the present invention. It is intended that all permutations, enhancements, equivalents, and improvements thereto that are apparent to those skilled in the art upon a reading of the specification and a study of the drawings are included within the true spirit and scope of the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the invention are illustrated in the figures. However, the embodiments and figures are illustrative rather than limiting; they provide examples of the invention.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2","b":"200"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 3","b":"300"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
