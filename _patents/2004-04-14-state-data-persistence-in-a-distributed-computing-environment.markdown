---
title: State data persistence in a distributed computing environment
abstract: Various embodiments of a system and method for persisting application state data are disclosed. The system may include a server cluster networked to a persistent data store such as a database resident on a backend system. Each server of the cluster may include a server container providing services for one or more applications along with a persistence mechanism. The persistence mechanism may be able to detect changes to the state of an application and persist only the portion of the application state that changed to the remote, persistent data store. In some embodiments, the persistence mechanism may be a Java Data Object (JDO) persistence manager which provides object persistence and transaction support while masking the peculiarities of resource managers for particular databases.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07716274&OS=07716274&RS=07716274
owner: Oracle America, Inc.
number: 07716274
owner_city: Santa Clara
owner_country: US
publication_date: 20040414
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["1. Field of the Invention","This invention relates to computer systems, and more particularly to the persistence of application state in a distributed container environment.","2. Description of the Related Art","Distributed applications are often implemented as part of commercial and non-commercial business solutions for an enterprise. For example, a company may leverage the use of an enterprise application that includes various databases distributed across multiple computers. Applications of this type, which support E-commerce, typically support hundreds or thousands of sessions simultaneously during periods of peak utilization. For scalability and fault tolerance, the servers running such applications may be clustered.","In some application server cluster implementations state and\/or session information for an application running on a server may only be stored locally to that server and therefore, may not be available to any other members of the cluster. Load balancing, in such a clustered system, may amount to nothing more than the round-robin assignment of new sessions to cluster members. Once a particular session is assigned to a given server, all requests associated with that session must be forwarded to assigned server who has sole access to the state data for that session. If the sessions assigned to one server of the cluster generate significantly more requests than the sessions assigned to another member of the cluster, then the actual workload of the two nodes may be disparate and the goal of load balancing within the cluster may not be achieved.","Storing application state data only locally to a given server within a cluster may also have implications in the area of failure recovery. If a server in a cluster fails, state information for the applications running in that server may be lost. Another server in the cluster may be able to take the place of the failed server within the cluster configuration, but may not be able to resume processing the applications from the point where the server failure occurred. For example, client sessions handled by the failed server may have to be restarted from an initial point. If one or more users have spent non-negligible time\/effort in promoting their sessions to the state at which the server failed, the need to restart these sessions from scratch may be highly unsatisfactory. One solution to this problem may be to persist application state information to a persistent store that can be accessed by multiple cluster members","Typically, application state persistence is achieved through serialization. Serialization allows an object graph to be serialized into a stream, which can be associated with a file. An instance is serialized by passing it as a parameter to the writeObject method of ObjectOutputStream. The entire graph of objects reachable from the instance in then serialized into the stream. The object graph is later reconstructed by de-serializing the data from an ObjectInputStream.","Serialization lacks features that may be desirable for distributed application systems. For example, there is no support for transactions. Without concurrency control, there is nothing to prevent multiple application component instances from serializing to the same file, thus corrupting state data. Serialization also lacks the ability to perform queries against the data. The granularity of access is an entire object graph, making it impossible to access a single instance or subset of the serialized data. Serialization includes no mechanism to determine when persistence updates should be performed. It therefore falls to the application developer to code the invocation points for serialization. Typically, this is done upon each request and results in large and for the most part unnecessary transfers of data among cluster members. Serialization and the corresponding storing of data can be very time consuming operations.","Also, a single serialization typically, cannot store all the data needed by an application. Applications must manage multiple serializations, either in the same file or in multiple files. Serialization lacks support for identity and the coordinated management of the instances in storage and memory. Therefore, developers must take extreme care to avoid storing and loading redundant instances. If different parts of a large application read the same serialization more than once, multiple copies of this instance will reside in memory. Redundant copies would make the coordination of separate updates extremely difficult. These issues collectively produce a high level of complexity, which often results in a lack of maintainability and can constrain scalability, which is crucial to most enterprise applications.","Various embodiments of a system and method for persisting application state data are disclosed. The system may include a server cluster networked to a persistent data store such as a database resident on a backend system. Each server of the cluster may include a server container providing services for one or more applications along with a Java Data Object (JDO) persistence manager. The JDO persistence manager may be able to detect changes to the state of an application and persist only the portion of the application state that changed to the remote, persistent data store in response to the change. In some embodiments, the JDO persistence manager may provide object persistence and transaction support while masking the peculiarities of resource managers for particular databases.","Application state data may be used to track the current process and\/or environmental state of an application. For example, the application state data to be persisted may include session state data. A session may be a series of requests to an application component, originating from the same user at the same browser. Sessions may allow applications running in a container to keep track of individual users. For example, an application component might use sessions to provide \u201cshopping carts\u201d to online shoppers. Suppose the application component is designed to record the items each shopper indicates he or she wants to purchase from a Web site. It is important that the application component be able to associate incoming requests with particular shoppers. Otherwise, the application component might mistakenly add Shopper#'s choices to the cart of Shopper#.","In some embodiments, the servers included in a cluster may be web servers, which provide web pages to clients. The clients may communicate with the web servers using hypertext transfer protocol (HTTP). Each server may include a Java Server Pages (JSP) servlet for providing the web pages to the clients and may require the persistence of HTTP session data. In other embodiments, the servers included in a cluster may be application servers. An application server may run one or more applications, which perform a variety of functions based on user requests. The applications and their components may take the form of Java Beans and application state data may include one or more session beans or other state objects.","In some embodiments, the persistence mechanism may include a JDO-style write barrier to detect changes in the state of an application. A JDO enhancer may operate on state object classes along with information provided in a metadata file to determine which objects need to be persisted. The enhancer may generate an accessor\/mutator method for each persisted object. Anywhere a load\/modify\/store operation on an object is found, it may be replaced with calls to the corresponding accessor or mutator methods. Accessor methods may cause the JDO runtime to get the latest version of the object from the persistent store, while mutator methods may change the values of associated variables and perform other functions to insure that the updated values are properly reflected in the persistent database. In another embodiment, one or more accessor methods may be combined within a single method. The persistence mechanism may initiate a transaction with a database on a backend system where the state data of application is being persisted. The result of this transaction may be that only the value of the changed state element is altered in the backend data store.","A server cluster in which session data is persisted to a remote, persistent backend data store may be made fault tolerant. When the failure of a cluster node is detected, one or more functional nodes may be selected to take over the application processing that was being done by the failed node. The selected surrogate nodes may access the failed node's application state data (e.g. session data) from the remote persistent data store and resume processing the failed node's applications.","While the invention is described herein by way of example for several embodiments and illustrative drawings, those skilled in the art will recognize that the invention is not limited to the embodiments or drawings described. It should be understood, that the drawings and detailed description thereto are not intended to limit the invention to the particular form disclosed, but on the contrary, the intention is to cover all modifications, equivalents and alternatives falling within the spirit and scope of the present invention as defined by the appended claims. The headings used herein are for organizational purposes only and are not meant to be used to limit the scope of the description or the claims. As used throughout this application, the word \u201cmay\u201d is used in a permissive sense (i.e., meaning having the potential to), rather than the mandatory sense (i.e., meaning must). Similarly, the words \u201cinclude\u201d, \u201cincluding\u201d, and \u201cincludes\u201d mean including, but not limited to.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["171","175","178"]},"Client tier  may include a number of different clients A through N (e.g., device, system, user interface) communicating to application components (e.g., servlets, server pages, beans) in the middle tier  via the Internet\/Intranet . The middle tier  may include a number of different Web servers A through N and\/or application servers A through N. In some embodiments, an application server  may include functionality typically provided by a Web server . For example, functionality provided by a Web server  may be included in an application server  eliminating the need for the Web server . The backend tier  may include a number of different computer systems A through N including data resources such as database .","Application components may communicate using different types of protocols and technologies such as Hyper Text Transfer Protocol Secure sockets (HTTPS), Java\u2122 Database Connectivity (JDBC), Java Naming and Directory Interface (JNDI), eXtensible Markup Language (XML) and\/or Simple Object Access Protocol (SOAP). The application components within a tier typically communicate with remote application components in an adjacent tier. For example, multiple users with access to an application component configured to operate in a client tier  (e.g., application client accessible via a Web browser) may initiate requests (e.g., application program call) to each remote application component configured to operate in a middle tier . Each application component in the middle tier  may, in turn, initiate requests to the backend tier  on behalf of the application component in the client tier . For example, an application component in the middle tier  (e.g., bean) may receive a remote request from a Web browser operating in the client tier  and in response access an application component (e.g., database object) operating in the backend tier . The application component in the backend tier  may then provide a response to the application component in middle tier  which may complete the remote request.","Some of the application components operating within the middle tier  may be configured to run within a component container  provided with an application server A. Some standard services (e.g., security, transaction management, state management, multi-threading) may be built into a platform and provided automatically to the application components via the container  and\/or application server A. State management may include the persisting of application state data.","Application server functionality may be organized around the concept of containers , which provide groupings of related functions. Containers may typically be layered on top of the Java 2 Standard Edition (J2SE) platform, which may include a Java Virtual Machine (JVM) and the corresponding suite of APIs. For instance, the two application server-based containers may be the Web container and the Enterprise JavaBeans (EJB) container. Web containers may be used to support Web-based user interface components, such as Servlets and Java Server Pages (JSP). EJB containers may be used to support business components, which include Session Beans, Entity Beans, and Message-driven Beans. Session Beans may provide access to independent business components in two flavors: Stateful Session Beans, used when state information is required between service calls, and Stateless Session Beans, used when individual service calls are independent of each other and may not require state information to be preserved.","In addition to the core container application programming interfaces (APIs), application servers may provide additional support to APIs such as naming and directory services (JNDI), database connectivity (JDBC), messaging (JMS), XML processing (JAXP), transactions (JTS), and connectivity to legacy systems (JCA). Most application servers may also provide the ability to transparently cluster multiple containers in order to enable fault tolerance and multi-node scalability. In order to provide runtime support for this comprehensive set of functionality, application servers may need to implement a number of key services, including state management, life-cycle management, thread pooling, transactions, security, fault tolerance, load balancing, and persistence.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 2","b":["200","270","240","230","280","230"]},"Persistence functionality may be provided to an application component by a persistence mechanism  that may be provided as a service of the application server . The persistence mechanism may provide for persisting individually specified fields of the application state . The persistence mechanism  may also persist only those of the specified fields of the application state  whose values have changed since the last persistence transaction. The persistence mechanism  may detect the mutation of any of the specified fields of the application state . In one embodiment, the persistence mechanism  may make use of Java Data Object (JDO) servers provided by the application server. In one embodiment, application state objects may be enhanced for persistence with a JDO-style write barrier as described in detail below. In other embodiments, persistence mechanisms other than based on JDO may be used.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3"},"When application state data is accessed, as shown at , a determination may be made as to whether the access causes a change in the application state data, as shown at decision block . For example, a read operation may not alter the state data, whereas a write or load-modify-store operation may. At block , only that portion of the application state data that is changed by the access may be persisted to the backend store of the distributed system. For example, if the access writes to one element of the application state data object the persistence mechanism may initiate a network transmission to a database on the backend system where the application state data is being persisted to update the value of only that single element that was changed in the database, instead of persisting the entire state object to the database. As mentioned above, in one embodiment the persistence mechanism may implement this method by employing a JDO-style write barrier.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4","b":["460","400","450","452","454","420","452","452","430","440","432","432","430"]},"As another example, assignment statement  may attempt to write a constant value into VAR. Since the value of VAR is to be overwritten, it may not be necessary to obtain the most current value for VAR in this case. The enhanced code may call mutator  to write the update value of VAR to persistent database . As a final example, statement  may attempt to increment the value of VAR. In this case it may be necessary to both obtain the current value of VAR and update the value of VAR in the persistent database. Therefore, both accessor  and mutator  may be invoked in this instance.",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 5","b":["500","510"]},"Likewise, anywhere a load\/modify\/store operation on an object is found the enhancer may replaced such and operation with calls to the corresponding accessor or mutator methods, as shown in block . Accessor methods may cause the JDO runtime, for example, to get the latest version of the object from the persistent store, while mutator methods may change the values of associated variables and perform other functions to insure that the updated values are properly reflected in the persistent database. At  the enhancer may use information included in the metadata file to produce a database schema that describes how all class objects are to be persisted in the database.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 6","b":["600","630","630","1","2"]},"An application component may distinguish users by their unique session IDs. The session ID may arrive with each request. If the user's browser is cookie-enabled, the session ID may be stored as a cookie. As an alternative, the session ID may be conveyed to the application component by uniform resource locator (URL) rewriting, in which the session ID is appended to the URL of the application component or Java Server Pages (JSP) file from which the user is making requests. For requests over HTTPS or Secure Sockets Layer (SSL), another alternative is to use SSL information to identify the session.","In a distributed application, the component running in the middle tier (application server) may require a great deal of computational resource due to the generation of a large number of requests from the client tier components. To meet these needs, the middle tier component may be replicated several times with each instance running in its own application server within a clustered environment. In a clustered environment, the same application may exist on each of the servers with each server handling a group of sessions. A load balancer  may distribute the total workload among members of the cluster. A clustered environment may require an affinity mechanism associated with the load balancer  such that all requests for a particular session are directed to the same application server instance in the cluster. A cluster employing such an affinity mechanism may be said to have \u201csticky\u201d sessions in the since that requests associated with a particular session will \u201cstick\u201d (be forwarded) to a single server.","Making a client session sticky to a single server may turn the server into a performance bottleneck. If the server undergoes an excessive load, and thus responds slowly, the user experience may degrade. In addition, it is entirely possible that a majority of abnormally active users may coincidentally be routed to a single server, overburdening that server more than its counterparts. A solution to this type problem may be to persist the sessions' state data in a commonly accessible data store. In such a case, the load balancer  may receive session requests from clients over network  and distribute them to the application servers  based solely on workload. For example, load balancer  may receive a request associated with session D and forward it to application server B because it has the lightest workload. Application server B may not have any session state data for session D or the state data that it does have may not be current. If the previous request associated with session D were processed by a different cluster node, then the current state data for that session may reside only in that node and in the persistent data store . In either case it may be necessary for application server B to access the current state of session  from persistent data store . Therefore it may be extremely important for each node to synchronize state data for each session they are processing to persistent data store  coincident with any change to the data.","Persisting session state data to a highly available data store accessible to multiple members of an application server cluster may allow for a graceful fail-over of sessions from a failed node to one or more of the other nodes of the cluster.  illustrates the components of such a clustered system including a JDO persistence mechanism, according to one embodiment. JDO persistence mechanism  may monitor sessions  under an application  for state changes using techniques described previously with respect to the JDO-style write barrier. In response to a change of state of any session , the JDO persistence mechanism  may persist only the session state changes to the copy of the session state  stored in the data store  on backend system . This stored copy of the session state data may be accessible to all nodes  of the cluster .","In the case of the hardware failure of a cluster node A, it may be possible for requests from that server's sessions to be rerouted to another server or servers in the cluster  in which the same application component installed. The new server N may be able to access session data B, F, and G from the commonly accessible persistent data store . If the JVM fails during the writing of session state data associated with session F to the session database , the update to the database may not get committed. In this case the commonly accessible persistent store  may roll back the session data to a point prior to the initiation of the persist transaction. The surrogate application A running on application server N may access the rolled-back session state F from the persistent store  and recover the session with minimal impact to the user. If the server fails between persistence transactions, the transition of the session from the failed unit to the surrogate may only be noticeable to the user as a delay in processing of one phase of a transaction, without the loss of any data.","Persisting application state data to a persistent data store remote from the server on which the application executes may allow for the recovery of the application in the event of server failure.  is a flowchart of a method for recovering sessions from a node failure in an application server cluster, according to one embodiment. At block , the cluster may detect the failure of one of its constituent nodes. There are many possible methods that may be implemented for detecting node failures within a cluster. In one embodiment, a Domain Administration Server may monitor the health of all application server instances. This may be done in a variety of ways such as having each instance generate a message (heartbeat) to the Domain Administration Server with a given periodicity. Detection of a failed application server instance may be denoted by the absence of its heartbeat. In another embodiment, the Domain Administration Server may poll each application server instance periodically to determine its health. Failure to respond to the poll may indicate a failure of the polled instance. Once a failure is detected, the Domain Administration Server may select one of the other cluster instances to recover the downed server's sessions, as indicated in block .","In another embodiment, the method for detecting a non-restarting server may not involve a Domain Administration Server. The application server instances may be responsible for monitoring one another. When they detect a loss of cluster membership that does not restart within a given time interval, another instance may be determined by a simple selection algorithm (e.g. the server instance whose ID is greater than and closest to that of the downed server) to recover the downed server's sessions, as indicated in block .","Regardless of the specifics of the failure detection mechanism or the fail-over node(s) selection process, the surrogate application server instance may initiate a transaction with the highly available storage to obtain the current state data for the sessions being processed by the failed node, as shown in block . The load balancer may begin forwarding requests associated with sessions that were running on the failed node to the surrogate node(s), and the surrogate node(s) may begin processing the session requests based on the session state data obtained from the last updates of the failed node in the persistent data store, as illustrated in block .",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 9","b":["1000","1007","1005","1000","1000","1010","1020","1025","1015","1015"]},"The computer system  preferably includes a memory medium on which computer programs according to various embodiments may be stored. The term \u201cmemory medium may include an installation medium, e.g., a CD-ROM, or floppy disk; a computer system memory such as DRAM, SRAM, EDO DRAM, SDRAM, DDR SDRAM, Rambus RAM, etc., or a non-volatile memory such as a magnetic media, e.g., a hard drive , or optical storage. The memory medium may include other types of memory as well, or combinations thereof. In addition, the memory medium may be located in a first computer in which the programs are executed, or may be located in a second different computer, which connects to the first computer over a network. In the latter instance, the second computer provides the program instructions to the first computer for execution.","Also, the computer system  may take various forms, including a personal computer system, mainframe computer system, workstation, network appliance, Internet appliance, personal digital assistant (PDA), television system or other device. In general, the term \u201ccomputer system\u201d can be broadly defined to encompass any device having a processor, which executes instructions from a memory medium. The memory medium preferably stores a software program or programs for event-triggered transaction processing as described herein. The software program(s) may be implemented in any of various ways, including procedure-based techniques, component-based techniques, and\/or object-oriented techniques, among others. For example, the software program may be implemented using ActiveX controls, C++ objects, JavaBeans, Microsoft Foundation Classes (MFC), or other technologies or methodologies, as desired.","Memory  may store program instructions accessed by the CPU . For example, instructions and data implementing an application server  may be stored in memory . Application server  may include one or more applications, data sources, data source proxies, transaction managers, and\/or a data source ID manager.","Computer system  may further include other software and hardware components, such as an input\/output (I\/O) interface , that may be coupled to various other components and memory . The CPU  may acquire instructions and\/or data through the I\/O interface . Through the I\/O interface , the CPU  may also be coupled to one or more I\/O components. As illustrated, I\/O components may include a hard disk drive , a network adapter , a display adapter  and\/or a removable storage adapter . Some components  to  may be coupled to the I\/O interface . In addition, the computer system  may include one or more of a particular type of component. The computer system  may include one or more components coupled to the system through a component other than the I\/O interface . Some computer systems may include additional and\/or other such as application software (e.g., stored in memory ), other CPUs, video monitors or other displays, track balls, mice, keyboards, printers, plotters, scanners, or other types of I\/O devices for use with computer system .","Various embodiments may further include receiving, sending or storing instructions and\/or data implemented in accordance with the foregoing description upon a carrier medium. Generally speaking, a carrier medium may include storage media or memory media such as magnetic or optical media, e.g., disk or CD-ROM, volatile or non-volatile media such as RAM (e.g. SDRAM, DDR SDRAM, RDRAM, SRAM, etc.), ROM, etc. as well as transmission media or signals such as electrical, electromagnetic, or digital signals, conveyed via a communication medium such as network and\/or a wireless link.","The various methods as illustrated in the figures and described herein represent exemplary embodiments of methods. The methods may be implemented in software, hardware, or a combination thereof. The order of method may be changed, and various elements may be added, reordered, combined, omitted, modified, etc.","Various modifications and changes may be made as would be obvious to a person skilled in the art having the benefit of this disclosure. It is intended that the invention embrace all such modifications and changes and, accordingly, the above description to be regarded in an illustrative rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
