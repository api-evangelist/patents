---
title: Hardware acceleration system for logic simulation using shift register as local cache
abstract: A logic simulation processor stores in a shift register intermediate values generated during the logic simulation. The simulation processor includes multiple processor units and an interconnect system that communicatively couples the processor units to each other. Each of the processor units includes a processor element configurable to simulate at least a logic gate, and a shift register associated with the processor element. The shift register includes multiple entries to store the intermediate values, and is coupled to receive the output of the processor element. Each of the processor units further includes one or more multiplexers for selecting one of the entries of the shift register as outputs to be coupled to the interconnect system. Each of the processor units may further include a local memory for storing data from, and loading the data to, the simulation processor.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07444276&OS=07444276&RS=07444276
owner: Liga Systems, Inc.
number: 07444276
owner_city: Sunnyvale
owner_country: US
publication_date: 20050928
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENTS"],"p":["1. Field of the Invention","The present invention relates generally to VLIW (Very Long Instruction Word) processors, including for example simulation processors that may be used in hardware acceleration systems for logic simulation. More specifically, the present invention relates to the use of shift registers as the local cache in such processors.","2. Description of the Related Art","Simulation of a logic design typically requires high processing speed and a large number of operations due to the large number of gates and operations and the high speed of operation typically present in the logic design for modern semiconductor chips. One approach for logic simulation is software-based logic simulation (i.e., software simulators) where the logic is simulated by computer software executing on general purpose hardware. Unfortunately, software simulators typically are very slow. Another approach for logic simulation is hardware-based logic simulation (i.e., hardware emulators) where the logic of the semiconductor chip is mapped on a dedicated basis to hardware circuits in the emulator, and the hardware circuits then perform the simulation. Unfortunately, hardware emulators typically require high cost because the number of hardware circuits in the emulator increases according to the size of the simulated logic design.","Still another approach for logic simulation is hardware-accelerated simulation. Hardware-accelerated simulation typically utilizes a specialized hardware simulation system that includes processor elements configurable to emulate or simulate the logic designs. A compiler is typically provided to convert the logic design (e.g., in the form of a netlist or RTL (Register Transfer Language) to a program containing instructions which are loaded to the processor elements to simulate the logic design. Hardware-accelerated simulation does not have to scale proportionally to the size of the logic design, because various techniques may be utilized to break up the logic design into smaller portions and then load these portions of the logic design to the simulation processor. As a result, hardware-accelerated simulators typically are significantly less expensive than hardware emulators. In addition, hardware-accelerated simulators typically are faster than software simulators due to the hardware acceleration produced by the simulation processor.","However, hardware-accelerated simulators generally require that instructions be loaded onto the simulation processor for execution and the data path for loading these instructions can be a performance bottleneck. For example, a simulation processor might include a large number of processor elements, each of which includes an addressable register as a local cache to store intermediate values generated during the logic simulation. The register requires an input address signal to determine the location of the particular memory cell at which the intermediate value is to be stored. This input address signal typically is included as part of the instruction sent to the processor element, which can significantly increase the instruction length and exacerbate the instruction bandwidth bottleneck.","For example, in order to select one memory cell out of a local cache register that has 2memory cells (i.e., the \u201cdepth\u201d of the register is 2, e.g., the \u201cdepth\u201d is 256 for N=8), an input address signal of at least N bits is required. If these bits are included as part of the instruction, then the instruction length will be increased by at least N bits for each processor unit. Assuming that this architecture is available on a per-processor unit basis (non-shared local cache), if the simulation processor contains n processor elements, then a total n\u00d7N bits is added to the overall size of the instruction word (e.g., for n=128 and N=8, this amounts to an additional 1024 bits). On the hardware side, additional circuitry will be needed to allow the register to be addressable. This adds to the cost, size and complexity of the simulation processor.","Therefore, there is a need for a simulation processor using a different type of local cache memory requiring fewer bits in the instructions that are used by the simulation processor. There is also a need for a simulation processor obviating or at least reducing the need for additional circuitry, such as input multiplexers to support the addressability of registers of the simulation processor.","The present invention provides a simulation processor for performing logic simulation of logic gates, where intermediate values generated by the simulation processor during the logic simulation are stored in shift registers. The simulation process includes a plurality of processor units and an interconnect system (e.g., a crossbar) that communicatively couples the processor units to each other. As compared to an addressable register, the use of a shift register as local cache reduces the instruction length and also simplifies the hardware design of the simulation processor.","Each of the processor units includes a processor element configurable to simulate at least one of the logic gates, and a shift register associated with the processor element and including a plurality of entries to store intermediate values during operation of the processor element. The shift register is coupled to receive an output of the processor element. Each of the processor units may optionally include any number of multiplexers selecting entries of the shift register in response to selection signals. The selected entries may then be routed to various locations, for example to the inputs of other processor units via the interconnect system. Each of the processor units may optionally include a local memory associated with the shift register for storing data from the shift register and loading the data to the shift register, in some sense acting as overflow memory for the shift register.","In various embodiments of the present invention, each of the processor units further comprises one or more of the following: a first multiplexer selecting either the output of the processor element or a last entry of the shift register in response to a first selection signal as input to the shift register, a second multiplexer selecting one of the entries of the shift register in response to a second selection signal, a third multiplexer selecting another one of the entries of the shift register in response to a third selection signal, a fourth multiplexer selecting either the output of the processor element or an output of the local memory in response to a fourth selection signal, a fifth multiplexer selecting either an output of the second multiplexer or the last entry of the shift register in response to a fifth selection signal, and a sixth multiplexer selecting either an output of the third multiplexer or an output of the fourth multiplexer in response to the fifth selection signal.","In a second embodiment of the present invention, each of the processor units further comprises a first multiplexer selecting either a mid-entry of the shift register or a last entry of the shift register in response to a first selection signal, and a second multiplexer selecting either an output of the processor element or an output of the first multiplexer, in response to a second selection signal, as an input to the shift register. The processor unit can further include a local memory associated with the shift register for storing data from the processor element and loading the data to the processor element, a third multiplexer selecting one of the entries of the shift register in response to a third selection signal, a fourth multiplexer selecting another one of the entries of the shift register in response to a fourth selection signal having one more bit than the third selection signal, a fifth multiplexer selecting either the output of the processor element or an output of the local memory in response to a fifth selection signal, a sixth multiplexer selecting either an output of the third multiplexer or the output of the first multiplexer in response to the first selection signal, and a seventh multiplexer selecting either an output of the fourth multiplexer or an output of the fifth multiplexer in response to the first selection signal.","The simulation processor of the present invention has the advantage that it may reduce the instruction length, because the shift register does not require any input address signals. Also, input multiplexers are not necessarily required to select cells of the shift register. The simulation process of the present invention has the additional advantage that the shift register is interconnected with the local memory in such a way that a store mode and a load mode for the processor element are non-blocking with respect to an evaluation mode. That is, the store mode and the load mode may be performed simultaneously with the evaluation mode.","Other aspects of the invention include systems corresponding to the devices described above, applications for these devices and systems, and methods corresponding to all of the foregoing. Another aspect of the invention includes VLIW processors that use shift registers as local cache but for purposes other than logic simulation of semiconductor chips.","The figures depict embodiments of the present invention for purposes of illustration only. One skilled in the art will readily recognize from the following discussion that alternative embodiments of the structures and methods illustrated herein may be employed without departing from the principles of the invention described herein.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1","b":["130","108","116","110","114","112","116","110","100","130","121","122","100","102","104","142","144"]},"The system shown in  operates as follows. The compiler  receives a description  of a user chip or logic design, for example, an RTL (Register Transfer Language) description or a netlist description of the logic design. The description  typically represents the logic design as a directed graph, where nodes of the graph correspond to hardware blocks in the design. The compiler  compiles the description  of the logic design into a program , which maps the logic design  against the processor elements  to simulate the logic design . The program  may also include the test environment (testbench) to simulate the logic design  in addition to representing the chip design  itself. For further descriptions of example compilers , see United States Patent Application Publication No. US 2003\/0105617 A1, \u201cHardware acceleration system for logic simulation,\u201d published on Jun. 5, 2003, which is incorporated herein by reference. See especially paragraphs 191-252 and the corresponding figures. The instructions in program  are stored in main memory .","The simulation processor  includes a plurality of processor elements  for simulating the logic gates of the logic design  and a local memory  for storing instructions and data for the processor elements . In one embodiment, the HW simulator  is implemented on a generic PCI-board using an FPGA (Field-Programmable Gate Array) with PCI (Peripheral Component Interconnect) and DMA (Direct Memory Access) controllers, so that the HW simulator  naturally plugs into any general computing system . The simulation processor  forms a portion of the HW simulator . Thus, the simulation processor  has direct access to the main memory  of the host computer , with its operation being controlled by the host computer  via the API . The host computer  can direct DMA transfers between the main memory  and the memories ,  on the HW simulator , although the DMA between the main memory  and the memory  may be optional.","The host computer  takes simulation vectors (not shown) specified by the user and the program  generated by the compiler  as inputs, and generates board-level instructions  for the simulation processor . The simulation vector (not shown) includes values of the inputs to the netlist  that is simulated. The board-level instructions  are transferred by DMA from the main memory  to the memory  of the HW simulator . The memory  also stores results  of the simulation for transfer to the main memory . The memory  stores user memory data, and can alternatively (optionally) store the simulation vectors (not shown) or the results . The memory interfaces ,  provide interfaces for the processor elements  to access the memories , , respectively. The processor elements  execute the instructions  and, at some point, return simulation results  to the computer  also by DMA. Intermediate results may remain on-board for use by subsequent instructions. Executing all instructions  simulates the entire netlist  for one simulation vector. A more detailed discussion of the operation of a hardware-accelerated simulation system such as that shown in  can be found in United States Patent Application Publication No. US 2003\/0105617 A1 published on Jun. 5, 2003, which is incorporated herein by reference in its entirety.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 2","b":["100","100","103","1","2","101","103","103"]},"As will be shown in more detail with reference to , each of the processor units  includes a processor element (PE), a shift register, and a corresponding part of the local memory  as its memory. Therefore, each processor unit  can be configured to simulate at least one logic gate of the logic design  and store intermediate or final simulation values during the simulation.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 3","FIG. 3"],"b":["103","100","103","302","308","326","304","306","310","312","314","316","320","324","318","322","103","118","382","382","0","1","0","1","0","1","0","1","101","103","101","302","103","100"]},"The PE  is a configurable ALU (Arithmetic Logic Unit) that can be configured to simulate any logic gate with two or fewer inputs (e.g., NOT, AND, NAND, OR, NOR, XOR, constant 1, constant 0, etc.). The type of logic gate that the PE  simulates depends upon Boolean Func, which programs the PE  to simulate a particular type of logic gate. The number of bits in Boolean Func is determined in part by the number of different types of unique logic gates that the PE  is to simulate. For example, if each of the inputs is 2-state logic (i.e., a single bit, either 0 or 1) and the output is also 2-state, then the corresponding truth table is a 2\u00d72 truth table (2 possible values for each input), yielding 2\u00d72=4 possible entries in the truth table. Each entry in the truth table can take one of two possible values (2 possible values for each output). Thus, there are a total of 2^4=16 possible truth tables that can be implemented. If every truth table is implemented, the truth tables are all unique, and Boolean Func is coded in a straightforward manner, then Boolean Func would require 4 bits to specify which truth table (i.e., which logic function) is being implemented. Correspondingly, the number Boolean Func would equal 4 bits in this example. Note that it is also possible to have Boolean Func of only 5 bits for 4-state logic with modifications to the circuitry.","The multiplexer  selects input data from one of the 2n bus lines of the crossbar  in response to a selection signal P that has P bits, and the multiplexer  selects input data from one of the 2n bus lines of the crossbar  in response to a selection signal P that has P bits. The PE  receives the input data selected by the multiplexers ,  as operands, and performs the simulation according to the configured logic function as indicated by the Boolean Func signal.","In the example of , each of the multiplexers ,  for every processor unit  can select any of the 2n bus lines. The crossbar  is fully non-blocking and exhaustively connective. This is not required in all implementations. For example, some of the processor units  may be designed to have more limited connectivity, with possible connection to only some and not all of the other processor units , or to only some and not all of the output lines from other processor units . Different input lines to the same processor unit may also have different connectivity. For example, multiplexer  might be designed to have full connectivity to any of the 2n bus lines, but multiplexer  might be designed to have more limited connectivity. In addition, the selections signals P and P are represented here as distinct signals, one for selecting the input to multiplexer  and one for selecting the input to multiplexer . This also is not required. The information for selecting inputs may be combined into a single field (call it P) or even combined with other fields. For example, this may allow more efficient coding of the instruction, thus reducing the instruction length.","The shift register  has a depth of y (has y memory cells), and stores intermediate values generated while the PEs  in the simulation processor  simulate a large number of gates of the logic design  in multiple cycles. Using a shift register  rather than a general register has the advantage that no input address signal is needed to select a particular memory cell of the shift register .  shows a single shift register  of depth y, but alternate embodiments can use more than one shift register. In one approach, a single shift register  is reproduced, for example to allow more memory access on the output side. The duplicate shift registers may have different depths. For example, only the top half of the shift register may be reproduced if there is much more activity in the top half (which stores fresher data) than in the bottom half (which stores staler data).","In the embodiment shown in , a multiplexer  selects either the output - of the PE  or the last entry - of the shift register  in response to bit en of the signal EN, and the first entry of the shift register  receives the output  of the multiplexer . Selection of output  allows the output of the PE  to be transferred to the shift register . Selection of last entry  allows the last entry  of the shift register  to be recirculated to the top of the shift register , rather than dropping off the end of the shift register  and being lost. In this way, the shift register  is refreshed. The multiplexer  is optional and the shift register  can receive input data directly from the PE  in other embodiments. In addition, although in  the first entry of the shift register  is coupled to receive the output - of the PE  through the multiplexer , the circuit of  may be modified such that any one of the entries of the shift register  can receive the output - of the PE  directly or through the multiplexer . There can also be more than one entry point to shift register  and\/or to additional shift registers.","On the output side of the shift register , the multiplexer  selects one of they memory cells of the shift register  in response to a selection signal XB that has XBbits as one output  of the shift register . Similarly, the multiplexer  selects one of they memory cells of the shift register  in response to a selection signal XB that has XBbits as another output  of the shift register . Depending on the state of multiplexers  and , the selected outputs can be routed to the crossbar  for consumption by the data inputs of processor units . This particular example shows two shift register outputs  and , each of which can select from anywhere in the shift register. Alternate embodiments can use different numbers of outputs, different accesses to the shift register (as will be discussed in ) and different routings. For example, it is not required that every output from the shift register  be routable to the crossbar . Some outputs may be strictly routed internally within the processor unit . For another example, although the embodiment of  uses one shift register  and the output of the shift register  is accessed by two multiplexers , , it is also possible to have two separate shift registers and have each of two separate multiplexers access the output of one of the two separate multiplexers. In such case, the contents of the data stored in the two shift registers would be replicated to be identical. Also, the signals for controlling the two separate multiplexers may have different lengths.","The memory  has an input port DI and an output port DO for storing data to permit the shift register  to be spilled over due to its limited size. In other words, the data in the shift register  may be loaded from and\/or stored into the memory . The number of intermediate signal values that may be stored is limited by the total size of the memory . Since memories  are relative inexpensive and fast, this scheme provides a scalable, fast and inexpensive solution for logic simulation. The memory  is addressed by an address signal  made up of XB, XB and Xtra Mem. Note that signals XB and XB were also used as selection signals for multiplexers  and , respectively. Thus, these bits have different meanings depending on the remainder of the instruction. These bits are shown twice in , once as part of the overall instruction  and once  to indicate that they are used to address the memory .","The input port DI is coupled to receive the output -- of the PE . Note that an intermediate value calculated by the PE  that is transferred to the shift register  will drop off the end of the shift register  after y shifts (assuming that it is not recirculated). Thus, a viable alternative for intermediate values that will be used eventually but not before y shifts have occurred, is to transfer the value from PE  directly to the memory , bypassing the shift register  entirely (although the value could be simultaneously made available to the crossbar  via path ----). In a separate data path, values that are transferred to shift register  can be subsequently moved to memory  by outputting them from the shift register  to crossbar  (via data path -- or --) and then re-entering them through a PE  to the memory . Values that are dropping off the end of shift register  can be moved to memory  by a similar path --.","The output port DO is coupled to the multiplexer . The multiplexer  selects either the output -- of the PE  or the output  of the memory  as its output  in response to the complement (\u02dcen) of bit en of the signal EN. In this example, signal EN contains two bits: en and en. The multiplexer  selects either the output  of the multiplexer  or the output  of the multiplexer  in response to another bit en of the signal EN. The multiplexer  selects either the output  of the multiplexer  or the final entry ,  of the shift register  in response to another bit en of the signal EN. The flip-flops ,  buffer the outputs ,  of the multiplexers , , respectively, for output to the crossbar .","Referring to the instruction  shown in , the fields can be generally divided as follows. P and P determine the inputs from the crossbar to the PE . EN is primarily a two-bit opcode that will be discussed in further detail below. Boolean Func determines the logic gate to be implemented by the PE . XB, XBand Xtra Mem either determine the outputs of the processor unit to the crossbar , or determine the memory address  for memory . Note that Xtra Mem is not a required bit, and Xtra Mem=0 is also a valid condition.","In one embodiment, four different operation modes (Evaluation, No-Operation, Store, and Load) can be triggered in the processor unit  according to the bits en and en of the signal EN, as shown below in Table 1:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Op Codes for field EN"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Mode","en1","en0"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Evaluation","0","0"]},{"entry":[{},"No-Op","0","1"]},{"entry":[{},"Load","1","0"]},{"entry":[{},"Store","1","1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"figref":"FIGS. 3A-3D"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 3A","FIG. 3A"],"b":["1","0","100","302","0","310","371","373","302","1","316","354","312","320","360","314","0","1","312","314","326"]},"Therefore, during the evaluation mode, the PE  simulates a logic gate based on the input operands output by the multiplexers  and , stores the intermediate value in the shift register , which is eventually output to the crossbar  for use by other processor units . At the same time, multiplexers  and  can select entries from the shift register  for use as inputs to processor units on the next cycle.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 3B","FIG. 3A"],"b":["1","0","100","302","308","0","310","363","364","308","1","0","1","312","314","326"]},"During the no-operation mode, the PE  does not simulate any gate, while the shift register  is refreshed so that the last entry of the shift register  is recirculated to the first entry of the shift register . At the same time, data can be read out from the shift register  via paths -- and --.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 3C","b":["1","0","100","326","1","320","368","324","0","324","366","326","0","310","371","373","302","1","316","363","370","308","326","377","0","1","366"]},"Note that during this mode, data can be loaded from the memory  to the crossbar  for use by processor units and, at the same time, the PE  can perform an evaluation of a logic function and store the result in the shift register . In many alternate approaches, evaluation by the PE and load from memory cannot be performed simultaneously, as is the case here. In this example, loading data from local memory  does not block operation of the PE .",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 3D","b":["1","0","100","326","326","377","371","372","374","302","371","372","374","302","326","1","320","368","324","0","324","371","372","376","302","1","316","363","370","308","0","310","363","364","308"]},"The store mode is also non-blocking of the operation of the PE . The PE  can evaluation a logic function and the resulting value can be immediately stored to local memory . It can also be made available to the crossbar  via path ----. The last entry in the shift register  can also be recirculated and also made available to the crossbar via path -.","One advantage of the architecture shown in  is that the load and store modes do not block operation of the PE . That is, the load mode might be more appropriately referred to as a load-and-evaluation mode, and the store mode might be more appropriately referred to as a store-and-evaluation mode. This is important for logic simulation. Logic simulation requires the simulation of a certain number of gates. Hence, the more quickly evaluations can be performed, the faster the logic simulation can be completed. Supporting load\/store and evaluation in a single cycle is a significant speedup compared to approaches in which load\/store requires one cycle and evaluation requires a separate cycle.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 4","b":["103","103","302","308","326","304","306","310","312","314","316","320","324","386","318","322","103","383","0","1","0","1","1","0","101","103","101","302","103","100"]},"The processor unit shown in  is the same as the one shown in , with one significant difference. In , multiplexer  could select any of the y entries in shift register , as could multiplexer . In , while multiplexer \u2032 can select any of they entries in shift register , multiplexer \u2032 can only select from the top half of the shift register. Multiplexer \u2032 can address only y\/2 entries.","In more detail, the multiplexer  selects either the mid-entry (y\/2)  or the last entry (y)  of the shift register  in response to bit en, although the multiplexer  can be modified to select any two entries of the shift register  in other embodiments. The output  of multiplexer  plays a role similar to signal  in . Thus, multiplexer  selects either the output - of the PE  or the output - of multiplexer  in response to bit en, and the first entry of the shift register  receives the output  of the multiplexer . Additionally, the multiplexer \u2032 selects one of the memory cells (0 through y\/2) of the shift register  in response to a selection signal XB\u2032, and the multiplexer \u2032 selects one of they memory cells of the shift register  in response to a selection signal XB\u2032. The memory  is addressed by an address signal  that includes the bits XB\u2032, XB\u2032.","This approach shown in  may result in better utilization of the fields XB\u2032, XB\u2032. For example, referring first to , assume that y is a power of 2 and XB0=XB1=log (base 2) y. Further assume that Xtra Mem has 1 bit, so Xtra Mem=1 and there are 2^(2 XB0+1) possible addresses for the local memory. Now consider a design for  which uses the same size local memory but a shift register with depth 2y instead of y. Use prime to indicate the quantities for . Then, XB0\u2032=XBbecause multiplexer \u2032 only addresses half of the shift register so the same number of bits are needed as in  to address the entire shift register. However, XB1\u2032=XB1+1 since multiplexer \u2032 addresses twice as many shift register entries. Accordingly, the Xtra Mem field is not needed in . Instead of using fields XB, XB and Xtra Mem of , fields XB\u2032 and XB\u2032 can be used in . Thus,  results in an instruction that has the same length as  (i.e., no additional bits are needed), a local memory of the same size but a shift register with twice the depth. This is achieved by utilizing the bits in the Xtra Mem field for shift register addressing in addition to local memory addressing. In , these bits were used only for local memory addressing and were wasted during shift register addressing.","The multiplexer  selects either the mid-entry  or the last entry  during various modes. In the example of , the multiplexer  is configured so that the shift register  is refreshed by recirculating the mid-entry  to the top of the shift register  in the no-operation mode (en=0 and en=1) via path ---, the last entry  is output to the crossbar  during the load mode (en=1 and en=0) via path ---, and the last entry  is both recirculated to the top of the shift register  and output to the crossbar  during the store mode (en=1 and en=1).","The present invention has the advantage that the simulation processor may use fewer bits in the instructions for the simulation processor, because the shift register does not require input address signals. Additional input multiplexers are not needed to address the shift register, thereby simplifying and reducing the number of components in the circuitry of the simulation processor. The present invention has the additional advantage that the shift register  is interconnected with the local memory  in such a way that the store mode and load mode are non-blocking, i.e., the store mode and the load mode may be performed simultaneously with the evaluation mode of the simulation processor.","Although the present invention has been described above with respect to several embodiments, various modifications can be made within the scope of the present invention. For example, the shift register  may be used with the PE  in many different configurations, and changes in the surrounding circuitry of the shift register  and PE  are still within the scope of the present invention. Additionally, although the present invention is described in the context of PEs that are the same, alternate embodiments can use different types of PEs and different numbers of PEs. The PEs also are not required to have the same connectivity or the same size or configuration of shift register. PEs may also share resources. For example, more than one PE may write to the same shift register and\/or local memory. For example, two PEs may share a single local memory. The reverse is also true, a single PE may write to more than one shift register and\/or local memory.","As another example, the instructions ,  shown in  show distinct fields for P, P, etc. and the overall operation of the instruction set was described in the context of four primary operational modes. This was done for clarity of illustration. In various embodiments, more sophisticated coding of the instruction set may result in instructions with overlapping fields or fields that do not have a clean one-to-one correspondence with physical structures or operational modes. One example is given in the use of fields XB, XB and Xtra Mem. These fields take different meanings depending on the rest of the instruction. In addition, symmetries or duality in operation may also be used to reduce the instruction length.","In another aspect, the simulation processor  of the present invention can be realized in ASIC (Application-Specific Integrated Circuit) or FPGA (Field-Programmable Gate Array) or other types of integrated circuits. It also need not be implemented on a separate circuit board or plugged into the host computer . There may be no separate host computer . For example, referring to , CPU  and simulation processor  may be more closely integrated, or perhaps even implemented as a single integrated computing device.","Although the present invention is described in the context of logic simulation for semiconductor chips, the VLIW processor architecture presented here can also be used for other applications. For example, the processor architecture can be extended from single bit logic simulation to fixed width computing (e.g., integer programming), to floating point computing. The same architecture can be applied to other types of applications, such as finite element modeling, DNA sequencing, three-dimensional rendering, database computation, MRI (magnetic resonance imaging), etc. Applications that have inherent parallelism are good candidates for this processor architecture. Accordingly, the disclosure of the present invention is intended to be illustrative, but not limiting, of the scope of the invention, which is set forth in the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The teachings of the present invention can be readily understood by considering the following detailed description in conjunction with the accompanying drawings. Like reference numerals are used for like elements in the accompanying drawings.",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 3A","FIG. 3"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 3B","FIG. 3"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 3C","FIG. 3"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 3D","FIG. 3"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
