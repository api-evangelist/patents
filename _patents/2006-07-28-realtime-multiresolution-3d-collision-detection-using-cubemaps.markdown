---
title: Real-time multi-resolution 3D collision detection using cube-maps
abstract: Apparatus, systems and methods for real-time, multi-resolution 3D collision detection using cube maps are disclosed. For example, a method is disclosed including receiving a first polygon, receiving a second polygon and then using a texture map stored in memory to detect collisions between the first and second polygons. Other implementations are also disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07928993&OS=07928993&RS=07928993
owner: Intel Corporation
number: 07928993
owner_city: Santa Clara
owner_country: US
publication_date: 20060728
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["Collision detection in three-dimensional (3D) graphics is the process of determining whether two objects, typically rigid bodies comprising linked polygons such as triangles, are in contact with each other. Usually this is done by having a processor implement an algorithm to calculate whether a triangle of one object conflicts spatially with a triangle of another object. Although there are a variety of approaches to this problem all standard solutions use the processor to execute calculations including testing for object-to-object collisions using a spatial data structure such as an octree and then undertaking a series of geometric calculations to assess polygon-to-polygon collisions for those objects whose bounding volumes are shown to be intersection candidates.","When implemented in a processor such as a central processing unit (CPU) these traditional approaches to collision detection can occupy significant computing resources that, particularly in a 3D gaming context, may be better spent in undertaking CPU-specific tasks such as physics calculations or implementing artificial intelligence routines. Moreover, by implementing collision detection in the CPU rather than a dedicated graphics processor such as a graphical processing unit (GPU) the traditional approaches fail to take advantage of the hardware primitives supported by modern graphics texture sampling hardware.","The following description refers to the accompanying drawings. Among the various drawings the same reference numbers may be used to identify the same or similar elements. While the following description provides a thorough understanding of the various aspects of the claimed invention by setting forth specific details such as particular structures, architectures, interfaces, techniques, etc., such details are provided for purposes of explanation and should not be viewed as limiting. Moreover, those of skill in the art will, in light of the present disclosure, appreciate that various aspects of the invention claimed may be practiced in other examples or implementations that depart from these specific details. At certain junctures in the following disclosure descriptions of well known devices, circuits, and methods have been omitted to avoid clouding the description of the present invention with unnecessary detail.",{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 1","FIG. 1","FIG. 1","FIG. 1"],"b":["100","100","102","104","106","108","102","104","104","102","106"]},"Collision detection algorithm  may comprise a detection routine including any combination of software, and\/or firmware that may be used to detect collisions between objects. Towards that end, algorithm  may provide texture sampler  with one or more lookup indices. Alternatively, algorithm  may provide shader  with one or more lookup indices and shader  may convey those indices to texture sampler . Sampler  may then use those indices to access distance data stored at corresponding texture addresses of a texture map held or stored in texture memory  as will be explained in greater detail below. Those skilled in the art will recognize that algorithm  may comprise a collision detection kernel spawned by a 3D graphics application (not shown) executing on a computing system that supports engine . Alternatively, algorithm  may comprise a collision detection kernel spawned by pixel shader . Those skilled in the art will further recognize that the terms objects, geometries, polygons, bodies and polyhedrons may be used interchangeably.","Texture sampler  may be any texture sampling logic comprising any combination of hardware, software, and\/or firmware that is capable of accessing texture data in memory  in response to one or more lookup indices provided by algorithm . In accordance with implementations of the invention, the texture data stored in memory  and accessed by sampler  may include a texture map, such as a cube map, comprising an array of pixels (or \u201ctexels\u201d) storing distance values as will be explained in greater detail below. Sampler  may then use the indices provided by algorithm  to determine associated texture addresses to be used to access the corresponding distance values stored and\/or held in memory . Sampler  may then use those distance values to generate interpolated distance values and may provide those interpolated distance values to algorithm  as will be described in greater detail below. Alternatively, sampler  may provide those distance values to shader  and shader  may generate interpolated distance values and provide those interpolated distance values to algorithm .","Texture memory  may comprise any memory device or mechanism suitable for storing and\/or holding one or more texture maps, such as one or more cube maps, specifying texel data such as distance values. While memory  may comprise any volatile or non-volatile memory technology such as Random Access Memory (RAM) memory or Flash memory, the invention is in no way limited by the type of memory employed for use as memory .",{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 2","FIG. 1"],"b":["200","200","100"]},"Process  may begin with the receipt of a first polygon [act ] and the receipt of a second polygon [act ]. In accordance with some implementations, acts  and  may, for example, involve collision detection algorithm  receiving the vertex coordinates of first and second triangles where those coordinates are defined, for example, with respect to a model coordinate system that may be implemented by a 3D graphics application (now shown). Such a 3D graphics application may spawn algorithm  and may supply algorithm  with geometric primitives, such as triangles.","Those skilled in the art may recognize that, as part of an overall collision detection process, algorithm  may have, prior to acts  and , already subjected 3D graphical objects to a trivial reject phase using a spatial data structure such as an octree or a kd-tree. In doing so, algorithm  may have determined that two objects, one including the first polygon of act  and another including the second polygon of act , have passed this trivial reject phase and thus are candidates for further collision detection testing. Details about the various methods of undertaking the trivial reject phase of a collision detection process are beyond the scope of the claimed invention and are well known in the art.","Process  may also include the generation of a texture map storing distance values [act ]. In accordance with some implementations of the invention act  may be undertaken by application software in a preprocessing phase occurring prior to any other steps in process . In other implementations of the invention act  may be undertaken by application software in run time concurrent with other acts of process . Regardless, the invention is not limited by when act  is undertaken.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 3","FIG. 1"],"b":["300","206","200","300","100"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4","b":["400","300","400","402","402","404","409","404","409","404","409","404","409","404","409","404","409","402","404","409"]},"As those skilled in the art will recognize, coordinates for each pixel of 2D maps - may be indexed by a 3D direction vector  originating at an origin  of cube map . In some implementations of the invention origin  may correspond to the centroid of an object such as a polygon as will be explained in further detail below. The invention is not, however, limited to how origin  is defined and thus, for example, origin  may comprise the circumcenter of an object. Those skilled in the art will further recognize that a set of unique direction vectors may be defined such that each vector of the set of vectors passes through a corresponding pixel of one of 2D maps -. For example, vector  passes through a pixel  of map , where map  corresponds to a +X face of cube map  and where pixel  may correspond to a specific (u,v) texture coordinate pair of map . Thus, vector  may be defined by origin  and the texture coordinate pair corresponding to pixel .","In accordance with some implementations of the invention, origin  may be the centroid of an object or the circumcenter of an object. However, the invention is not limited in this regard and, thus, origin  may comprise any point lying inside an object. Moreover, while the texture primitive employed in processes  and  may comprise a cube map primitive the invention is not limited in this regard and, thus, for example, processes  and  may be undertaken using other 3D texture primitives such as texture primitives employing more than six 2D faces or, for example, paraboloid or spherical texture primitives.","Process  may begin with the determination of an origin of the first polygon [act ] where that polygon is the same polygon as that received in act  of process . Those skilled in the art will recognize the well known technique of determining a bounding sphere of a polygon as one way to determine an origin of a polygon in accordance with act . For the sake of discussion,  illustrates a scheme  for determining a bounding sphere in accordance with some implementations of act . While, for the purposes of illustration,  illustrates bounding sphere  and an associated polygon  in 2D, implementations of act  may be undertaken on a 3D polygon resulting in a 3D bounding sphere.","Those skilled in the art will recognize that bounding sphere  represents a hypothetical sphere that encompasses polygon  such that the scalar radius  of sphere  defines a maximum distance from the center  of the sphere to any point of polygon . When so defined, the center  of sphere  represents the centroid of polygon . Thus, as a result of act  an origin such as a centroid of the first polygon may be determined. As noted above, however, the invention is not limited to how the origin of an object is determined or defined. Thus, in accordance with the invention, any arbitrary means could be used to determine the origin of a 3D object to be processed by process .","Process  may continue with the receipt of a cube map primitive [act ] where that primitive comprises six 2D arrays of texture pixels. As discussed above, cube maps are a well known type of 3D graphics primitive. Process  may then continue with the determination of distance values from the origin of the first polygon to intersection points with faces of the first polygon along directions originating at the origin and passing through pixels of the cube map [act ].",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 6","FIG. 6","FIG. 6","FIG. 6","FIG. 6"],"b":["600","306","602","604","602","604","306","606","1","7","608","604","306","612","612","614","602","606","616","7","618","602","620","614","7","306","612","604"]},"While  shows a cross-section of a cube map  where each face of map  may comprise an eight-by-eight array of pixels so that cube map  may include a total of 144 pixels, the invention is not limited to a particular resolution of cube map employed in processes  and . Thus, for example, act  may be undertaken with different resolution cube maps for each polygon processed in process . For example, the cube map received in act  may comprise six 2D sixteen-by-sixteen pixel arrays so that the cube map employed in processes  and  may include a total of 1,536 pixels. Alternatively, the cube map received in act  may comprise six 2D four-by-four pixel arrays so that the cube map employed in processes  and  may include a total of 96 pixels. Moreover, those skilled in the art will recognize that act  may be undertaken by determining distance values along only a subset of directions (e.g., only a subset of directions ) with the remaining distance values determined by linear interpolation between pairs of the distance values determined in act .","Process  may continue with the storing of the distance values as pixel values of the cube map [act ]. In accordance with some implementations of the invention, act  may involve storing each distance value determined in act  as the pixel value of the pixel lying along the direction associated with that distance value. For example, if act  includes determining distance value  associated with direction , then act  may involve storing distance value  as the pixel value of pixel P lying along direction . In some implementations of the invention those distance values determined in act  and stored in act  may comprise floating point values although the invention is not limited to the distance values having a particular data format.","Moreover, while the detailed description provided herein refers to convex polygons, such as polygon  or polygon , the invention is not limited in this regard and concave polygons may be employed in processes \/. Those skilled in the art will recognize that a convex polygon may be defined as an object wherein any whole straight line segment joining any two points of the object is contained wholly within the object while a concave polygon may be defined as an object wherein a whole straight line segment joining two points of the object may be found in which that line segment is not completely contained in the object.","To employ concave polygons in processes \/ a bounding volume corresponding to a convex hull of a concave polygon may be determined where that convex hull bounding volume has a scalar radius corresponding to the greatest distance value between an origin of the object and any point of the object. Such a convex hull bounding volume may then be employed in act . Alternatively, convex decomposition techniques may be used to subdivide a concave geometry into smaller convex geometries. The processes \/ may then be employed to detect collisions between those convex sub-geometries. Both convex hull bounding volume and convex decomposition techniques are well known in the art and will not be discussed in greater detail herein.","Referring again to process , in some implementations of the invention an application, such as a 3D graphics application, may undertake all acts of process  in a preprocessing stage (i.e., before process  is undertaken) and supply the resulting texture map to algorithm  in act . Alternatively, in other implementations of the invention, algorithm  may undertake process  in a dynamic manner in response to each collision detection event occurring during 3D rendering implemented by engine . Further, for each polygon received in act  an associated cube map storing distance values for that polygon may have been created in process  (i.e., generated in act ) and used in further acts of process  as will be explained in greater detail below. In accordance with some implementations of the invention, process  may result in a cube map being held or stored in memory  where that cube map stores distance values for a particular polygon.","Process  may continue with determining a first distance value from an origin of the first polygon to a vertex of the second polygon [act ] where the first distance lies along a direction vector extending from the origin of the first polygon to a vertex of the second polygon.  illustrates a scheme  for determining a first distance value in accordance with some implementations of act .",{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 7","FIG. 7"],"b":["702","704","208","705","706","702","708","704","710","706","708","208","712","706","714","704","715","706","714","702","704","208","208","102","202","204"]},"Process  may then continue with the determination, along a direction vector, of a second distance from the origin of the first polygon to a face of the first polygon by performing one or more lookups to a texture map [act ]. In some implementations of the invention, referring again to , act  may involve determining, for example, a second distance  from origin  to a face  of polygon  along direction vector . In this example, determining second distance  may involve looking up the distance values (i.e., determined in ) that are stored at pixels  and  (i.e., in act ) of the texture map generated in act  and then linearly interpolating between those distance values to obtain second distance  in act .","Similarly, for example, act  may involve determining a second distance  from origin  to face  of polygon  along direction vector . Then, in this example, determining second distance  may involve looking up the distance values that are stored at pixels  and  of the texture map generated in act  and then linearly interpolating between those distance values to obtain second distance  in act . In some implementations of the invention, act  may involve algorithm  providing texture sampler  with lookup indices associated with the pixels (e.g., pixels  and  or pixels  and ). Sampler  may then use those indices to generate corresponding memory addresses for accessing the distance values for the corresponding pixels of the cube map stored in memory . Sampler  may then linearly interpolate between those distance values and provide a resulting interpolated distance value to algorithm . Alternatively, Sampler  may provide the distance values to algorithm  and algorithm  may linearly interpolate between those values to determine the second distance in act .","While each of direction vectors  and  are shown in  as passing through or specifying a texture coordinate pair lying, respectively, between pixels  and  and pixels  and , the invention is not limited to the 2D representation shown in . Thus, for example, either of direction vectors  and  may pass through or specify a texture coordinate pair lying between two pixel rows or columns of a face of a cube map. Thus, act  may involve using four lookup indices to access the distance values stored at the four pixels that bound that texture coordinate pair and then bi-linearly interpolating between those four distance values to obtain the second distance value. The invention is not, however, limited to linear interpolation (bi-linear, tri-linear or otherwise). Thus, for example, act  may be undertaken using nearest point sampling of the distance values obtained from the texture map.","In other implementations of the invention, act  may involve algorithm  providing pixel shader  with lookup indices associated with the pixels (e.g., pixels  and  or pixels  and ) and shader  may convey those indices to texture sampler . Sampler  may then use those indices to generate corresponding memory addresses for accessing the distance values for the corresponding pixels of the cube map stored in memory  and provide those distance values to shader . Shader  may then linearly interpolate between those distance values and provide a resulting interpolated distance value to algorithm . Alternatively, Shader  may provide the distance values to algorithm  and algorithm  may linearly interpolate between those values to determine the second distance in act .","Process  may then continue with comparing the first distance value to the second distance value [act ] and, if the second distance is greater than or equal to the first distance, detecting a collision [act ] between the first and second polygons. Referring again to , act  may, for example, involve comparing the first distance  to the second distance  along direction vector . In this case first distance  is greater than second distance  and no collision will be detected. However, act  may, for another example, involve comparing the first distance  to the second distance  along direction vector . In this case second distance  is greater than first distance  and thus a collision may be detected in act . In some implementations of the invention algorithm  may undertake the comparison of act  and determine, in act  that a collision has occurred if the second distance is greater than or equal to the first distance.","While acts  and  as described above refer, respectively, to determining first and second distances, and while act  refers to comparing these two distances to each other, in other implementations of the invention process  may include the acts of determining the square of those distances and then comparing those squared distance values to each other in act . Thus, in these implementations, act  may comprise determining if the square of the second distance is greater than or equal to the square of the first distance. The invention is, however, not limited to comparing the distances or the square of the distances in act . Thus for example, process  may include the acts of determining the square root of those distances and then comparing those square root distance values to each other in act .","The acts shown in  need not be implemented in the order shown; nor do all of the acts necessarily need to be performed. Also, those acts that are not dependent on other acts may be performed in parallel with the other acts. For example, acts  and  may be undertaken in parallel. Alternatively, acts  and  may be combined into a single action. In other words, the receipt of first and second polygons may take place in a single action. In addition, as noted above, act , the generation of a cube map in accordance with some implementations of the invention, may take place prior to all other acts of process  or, alternatively, act  may take place after or in parallel with acts  or . Further, at least some of the acts in this figure may be implemented as instructions, or groups of instructions, implemented in a machine-readable medium.","In some implementations of the invention, algorithm  as employed in processes  and\/or  may comprise the following pseudo code:",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003Collision_Detection_Using_Cubemaps(...)"]},{"entry":[{},"\u2003bool Collision = false;"]},{"entry":[{},"\u2003Foreach vertex Vof polygon P{"]},{"entry":[{},"\u2003\u2003DirectionVector = V\u2212 C;"]},{"entry":[{},"\u2003\u2003d1 = texCube (DirectionVector);"]},{"entry":[{},"\u2003\u2003d2 = distance (C, V);"]},{"entry":[{},"\u2003\u2003\u2003if (d1 >= d2) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003Collision = true;"]},{"entry":[{},"\u2003\u2003\u2003\u2003break; \/\/ Collision"]},{"entry":[{},"\u2003\u2003}"]},{"entry":[{},"\u2003}"]},{"entry":[{},"\u2003If (Collision) {"]},{"entry":[{},"\u2003\u2003\/\/ Model the response of collision"]},{"entry":[{},"\u2003} else {"]},{"entry":[{},"\u2003\u2003\/\/ No collision, move on to evaluate the collision"]},{"entry":[{},"\u2003detection for next pair of geometries"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In other implementations of the invention, algorithm  as employed in processes  and\/or  may be spawned by or be associated with pixel shader  of engine  and may comprise the following high level shading language (HLSL) pixel shader code:",{"@attributes":{"id":"p-0044","num":"0043"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"PS_OUTPUT CollisionDetectionPS( VS_OUTPUT In,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003uniform bool bTexture )"},{"entry":"{"},{"entry":"\u2003PS_OUTPUT Output;"},{"entry":"\u2003\u2002int Index = 0;"},{"entry":"\u2003\u2002float sum = 0.0;"},{"entry":"\u2003\u2002float fActualDist,fCubeMapDist;"},{"entry":"\u2003\u2002float4 temp = (0,0,0,1);"},{"entry":"\u2003\u2002float4 WorldPos,WorldCentroid,dir;"},{"entry":"\u2003\u2002bool collision = false;"},{"entry":"\u2003\u2002float2 tex;"},{"entry":"\u2003\u2002\/\/bool results[115];"},{"entry":"\u2003\u2002int trouble = 0;"},{"entry":"\u2003\u2002Output.RGBColor.r = Output.RGBColor.g = Output.RGBColor.b ="},{"entry":"Output.RGBColor.a = 0.0;"},{"entry":"\u2003\u2002\/\/ These are texture (u,v) coordinates used to index at"},{"entry":"\u2003\u2002center of pixels, and access \/\/ the position data of"},{"entry":"\u2003\u2002objects."},{"entry":"\u2003\u2002float disp = 0.5\/g_iNumVertices[1];"},{"entry":"\u2003\u2002tex.y = 0.5"},{"entry":"\u2003\u2002\/\/ World position of Centroid of object 0"},{"entry":"\u2003\u2002WorldCentroid = mul(g_vCentroids[0],g_mWorldMat0);"},{"entry":"\u2003\u2002\/\/ Shoot rays thru' all the vertices of Object 1"},{"entry":"\u2003\u2002for( Index = 0; Index < g_iNumVertices[1]; Index++ ) {"},{"entry":"\u2003\u2003\u2003tex.x = Index\/g_iNumVertices[1] + disp;"},{"entry":"\u2003\u2003\u2003\/\/ Get the position of vertex of object 1 that is"},{"entry":"stored in a texture."},{"entry":"\u2003\u2003\u2003WorldPos = tex2D(g_samPositions1,tex);"},{"entry":"\u2003\u2003\u2003\/\/ Tranform to world space."},{"entry":"\u2003\u2003\u2003WorldPos = mul(WorldPos,g_mWorldMat1);"},{"entry":"\u2003\u2003\u2003dir = WorldPos \u2212 WorldCentroid;"},{"entry":"\u2003\u2003\u2003fActualDist = sqrt(dir.x*dir.x + dir.y*dir.y +"},{"entry":"dir.z*dir.z);"},{"entry":"\u2003\u2003\u2003\/\/ Transform the direction back to the space where"},{"entry":"cube-map was generated by"},{"entry":"\u2003\u2003\u2003\/\/ multiplying by inverse of world matrix for object 0."},{"entry":"\u2003\u2003\u2003dir = mul(dir,g_mWorldMat0Inv);"},{"entry":"\u2003\u2003\u2003dir = normalize(dir);"},{"entry":"\u2003\u2003\u2003temp = texCUBE(g_samCubeMapDistance0,dir);"},{"entry":"\u2003\u2003\u2003fCubeMapDist = temp.x;"},{"entry":"\u2003\u2003\u2003if (fCubeMapDist > fActualDist) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003collision = true;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2002}"},{"entry":"\u2003\u2002\/\/ Do the same calculations as above but switching the"},{"entry":"objects. So now cycle thru' object 0's vertices."},{"entry":"\u2003\u2002disp = 0.5\/g_iNumVertices[0];"},{"entry":"\u2003\u2002WorldCentroid = mul(g_vCentroids[1],g_mWorldMat1);"},{"entry":"\u2003\u2002for( Index = 0; Index < g_iNumVertices[0]; Index++ ) {"},{"entry":"\u2003\u2003\u2003tex.x = Index\/14.0 + disp;"},{"entry":"\u2003\u2003\u2003WorldPos = tex2D(g_samPositions0,tex);"},{"entry":"\u2003\u2003\u2003WorldPos = mul(WorldPos,g_mWorldMat0);"},{"entry":"\u2003\u2003\u2003dir = WorldPos \u2212 WorldCentroid;"},{"entry":"\u2003\u2003\u2003fActualDist = sqrt(dir.x*dir.x + dir.y*dir.y +"},{"entry":"dir.z*dir.z);"},{"entry":"\u2003\u2003\u2003dir = mul(dir,g_mWorldMat1Inv);"},{"entry":"\u2003\u2003\u2003dir = normalize(dir);"},{"entry":"\u2003\u2003\u2003temp = texCUBE(g_samCubeMapDistance1,dir);"},{"entry":"\u2003\u2003\u2003fCubeMapDist = temp.x;"},{"entry":"\u2003\u2003\u2003if (fCubeMapDist > fActualDist) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003collision = true;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2002}"},{"entry":"\u2003\u2002if (collision == true) {"},{"entry":"\u2003\u2003\u2003Output.RGBColor.r = Output.RGBColor.g ="},{"entry":"Output.RGBColor.b = 1.0;"},{"entry":"\u2003\u2003\u2003Output.RGBColor.a = 1.0;"},{"entry":"\u2003\u2002}"},{"entry":"\u2003\u2002return Output;"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 8","b":["800","500","802","803","804","806","808","810","814","816","800","815","814","800"]},"System  may assume a variety of physical implementations. For example, system  may be implemented in a personal computer (PC), a networked PC, a server computing system, a handheld computing platform (e.g., a personal digital assistant (PDA)), a gaming system (portable or otherwise), a 3D capable cellular telephone handset, etc. Moreover, while all components of system  may be implemented within a single device, such as a system-on-a-chip (SOC) integrated circuit (IC), components of system  may also be distributed across multiple ICs or devices. For example, host processor  along with components  and  may be implemented as multiple ICs contained within a single PC while graphics processor  and components  and  may be implemented in a separate device such as a television or other display coupled to host processor  and components  and  through communications pathway .","Host processor  may comprise a special purpose or a general purpose processor including any control and\/or processing logic, hardware, software and\/or firmware, capable of providing graphics processor  with 3D graphics data and\/or instructions. Processor  may perform a variety of 3D graphics calculations such as 3D coordinate transformations, etc. the results of which may be provided to graphics processor  over bus  and\/or that may be stored in memories  and\/or  for eventual use by processor . In some implementations of the invention host processor  may be a Central Processing Unit (CPU).","In one implementation, host processor  may be capable of performing any of a number of tasks that support or enable real-time, multi-resolution 3D collision detection using cube maps. Support tasks may include, for example, although the invention is not limited in this regard, providing 3D graphics data to graphics processor , placing one or more texture maps, such as cube maps, in memory , downloading microcode (via antenna  and interfaces ) to processor , initializing and\/or configuring registers within processor , interrupt servicing, and providing a bus interface for uploading and\/or downloading 3D graphics data. In alternate implementations, some or all of these functions may be performed by graphics processor . While  shows host processor  and graphics processor  as distinct components, the invention is not limited in this regard and those of skill in the art will recognize that processors  and  possibly in addition to other components of system  may be implemented within a single IC.","In accordance with some implementations of the invention, each of cores  may perform, in parallel, processes \/ for separate pairs of polygons using separate implementations of collision detection algorithm . Alternatively, such parallel processing schemes may be implemented by graphics processor .","Graphics processor  may comprise any processing logic, hardware, software, and\/or firmware, capable of processing graphics data. In one implementation, graphics processor  may implement a 3D graphics architecture capable of processing graphics data in accordance with one or more standardized rendering application programming interfaces (APIs) such as OpenGL 2.0\u2122 (\u201cThe OpenGL Graphics System: A Specification\u201d (Version 2.0; Oct. 22, 2004)) and DirectX 9.0\u2122 (Version 9.0c; Aug. 8, 2004) to name a few examples, although the invention is not limited in this regard. Graphics processor  may process 3D graphics data provided by host processor , held or stored in memories  and\/or , and\/or provided by sources external to system  and obtained over bus  from interfaces .","Graphics processor  may receive 3D graphics data in the form of 3D scene data and process that data to provide image data in a format suitable for conversion by display processor  into display-specific data. In addition, graphics processor  may implement a variety of 3D graphics processing components and\/or stages (not shown) such as a rasterizer stage in addition to one or more texture samplers similar to texture sampler . Texture samplers implemented by graphics processor  may fetch or access texture data stored or held in the form of cube maps in either or both of memories  and . Further, in accordance with some implementations of the invention, graphics processor  may implement two or more texture samplers capable of using distance values stored in one or more cube maps to undertake collision detection for multiple pairs of polygons in a parallel fashion.","Bus or communications pathway(s)  may comprise any mechanism for conveying information (e.g., graphics data, instructions, etc.) between or amongst any of the elements of system . For example, although the invention is not limited in this regard, communications pathway(s)  may comprise a multipurpose bus capable of conveying, for example, instructions (e.g., macrocode) between processor  and processor . Alternatively, pathway(s)  may comprise a wireless communications pathway.","Display processor  may comprise any processing logic, hardware, software, and\/or firmware, capable of converting rasterized image data supplied by graphics processor  into a format suitable for driving a display (i.e., display-specific data). For example, while the invention is not limited in this regard, processor  may provide image data to processor  in a specific color data format, for example in a compressed red-green-blue (RGB) format, and processor  may process such RGB data by generating, for example, corresponding LCD drive data levels etc. Although  shows processors  and  as distinct components, the invention is not limited in this regard, and those of skill in the art will recognize that, for example, some if not all of the functions of display processor  may be performed by graphics processor  and\/or host processor .","Thus, by taking advantage of hardware primitives such as cube maps a collision detection algorithm in accordance with the invention may execute entirely on a graphics processor such as processor  with, possibly, the exception of the preprocessing of process  which may be implemented once for each polygon and done ahead of process . Further, a collision detection algorithm in accordance with the invention can leverage a high level octree structure to minimize object-object detections and may rely on cube maps for those object-object interactions that are identified as candidates by the octree data structure. Thus, by moving the collision detection algorithm to a graphics processor (e.g., processor ) the CPU (e.g., host processor ) may be freed up to undertake other tasks. Although a collision detection algorithm in accordance with the invention may execute on a CPU as well. Moreover, using hardware primitives such as cube maps to detect collisions may result in a significant reduction of the arithmetic operations per collision (possibly as much as a three-fold reduction) and is amenable to a many processing core implementation (e.g., using cores ) due to the capability of performing completely independent collision detection tests.","While the foregoing description of one or more instantiations consistent with the claimed invention provides illustration and description of the invention it is not intended to be exhaustive or to limit the scope of the invention to the particular implementations disclosed. Clearly, modifications and variations are possible in light of the above teachings or may be acquired from practice of various implementations of the invention. For example, while  and the accompanying text may show and describe a single texture sampler  coupled to a single texture memory , those skilled in the art will recognize that data processors in accordance with the invention may include rendering engines that employ multiple texture samplers, each operating in accordance with the invention, coupled to one or more texture memories. Clearly, many other implementations may be employed to provide for real-time, multi-resolution 3D collision detection using cube maps in accordance with the invention.","No device, element, act, data type, instruction etc. set forth in the description of the present application should be construed as critical or essential to the invention unless explicitly described as such. Also, as used herein, the article \u201ca\u201d is intended to include one or more items. Moreover, when terms or phrases such as \u201ccoupled\u201d or \u201cresponsive\u201d or \u201cin communication with\u201d are used herein or in the claims that follow, these terms are meant to be interpreted broadly. For example, the phrase \u201ccoupled to\u201d may refer to being communicatively, electrically and\/or operatively coupled as appropriate for the context in which the phrase is used. Variations and modifications may be made to the above-described implementation(s) of the claimed invention without departing substantially from the spirit and principles of the invention. All such modifications and variations are intended to be included herein within the scope of this disclosure and protected by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, incorporated in and constituting a part of this specification, illustrate one or more implementations consistent with the principles of the invention and, together with the description of the invention, explain such implementations. The drawings are not necessarily to scale, the emphasis instead being placed upon illustrating the principles of the invention. In the drawings,",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIGS. 4-7","FIGS. 2 and 3"]},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
