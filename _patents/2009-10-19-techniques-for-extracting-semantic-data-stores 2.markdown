---
title: Techniques for extracting semantic data stores
abstract: Techniques for enforcing policies. A set of data is stored in one or more data stores. A plurality of semantic concepts for an ontology are defined and a map is constructed from the set of data to the concepts. The map is executed in order to transform data from the set of data to a second set of data. The second set of data is stored according to the ontology. The second set of data is reasoned in order to determine compliance with one or more policies.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09569725&OS=09569725&RS=09569725
owner: Oracle International Corporation
number: 09569725
owner_city: Redwood Shores
owner_country: US
publication_date: 20091019
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application incorporates by reference for all purposes co-pending U.S. patent application Ser. No. 12\/576,176 filed on Oct. 8, 2009, entitled \u201cTechniques for Processing Ontologies.\u201d","Many business applications, such as Enterprise Resource Planning (ERP) applications, generate and manage large amounts of business transaction data which are stored in many different formats (e.g. RDBMs, LDAP directories, flat files, etc.), and which use a plethora of different schema or data models.","In addition, governance, risk, and compliance (GRC) concerns often lead businesses to have internal business policies intended to address a wide range of issues such as security, privacy, trade secrets, criminal activity of employees or others with access to the business, and many others. These business policies address various aspects of a business, such as purchasing, selling, marketing, and internal administration. Because of the large number of activities occurring during the course of running a business, which may have various entities located in a variety of geographical locations, it is often impractical to manually monitor all activities in which improper behavior or mistakes may occur. Thus, GRC concerns often require that dynamic, legislative, and trend-driven policies be enforced against business transaction data which may span multiple business applications and, therefore, potentially a set of disparate, yet related, data sources.","Moreover, users of business applications typically prefer to interact with applications that assist in policy enforcement using relevant business semantics as opposed to application-specific or storage-specific semantics.","On approach to monitoring and controlling a business' computer systems involves storing business data in one or more ontologies. With the advent of semantic technologies, the importance of ontologies and semantic query languages has grown manifold. An ontology is a formal representation of knowledge, specifically a formal representation of a set of concepts within a domain and relationships between the concepts. Ontologies are used in several different areas including business analytics, enterprise systems, artificial intelligence and the like, and have and the potential to be used in several other fields and applications.","An ontology is typically encoded using an ontology language. Several ontology languages are available. The OWL Web Ontology Language has become the industry standard for representing web ontologies. OWL can be used to explicitly represent the meaning of terms in vocabularies and the relationships between the terms. OWL thus provides facilities for expressing meaning and semantics that goes far beyond the capabilities of languages such as XML. OWL is being developed by the Web Ontology Working Group as part of the W3C Semantic Web Activity.","An ontology may be persisted in memory such as in a database or other data store. There are several standard ways of querying and manipulating the data in an ontology using query languages such as RDQL (Resource Description Format Query Language), OWL-QL, SPARQL (SPARQL Protocol and RDF Query Language), and others. Among the ontology query languages, SPARQL is considered by many to be the de facto industry standard.","In the context of a business, data from one or more data stores may be periodically compiled in an ontology, such as in a batch process occurring at times when there is less use of the business' computer systems, such as at night when most employees are not present. Once compiled in an ontology, an ontology reasoner can be used to make logical inferences from the ontology. Generally, an ontology reasoner is a module implemented in hardware or software executed by a processor, configured to infer logical consequences from a set of facts or axioms stored in an ontology. This process is often referred to as \u201creasoning.\u201d Data from an ontology may be converted into a form convenient for processing by the reasoner, such as in a manner described in co-pending U.S. patent application Ser. No. 12\/576,176, entitled \u201cTechniques for Processing Ontologies,\u201d filed on Oct. 8, 2009, and which is incorporated herein by reference for all purposes. Ontology reasoners are also known as reasoning engines, rules engines, or simply reasoners. Examples include RETE-based rules engines such as JESS, a rules engine for the Java platform, and probabilistic description logic reasoners such as Pronto, available from Clark & Parsia LLC, located at 926 N St. NW Rear, Studio #1, Washington, DC 20001. Ontology reasoners typically incorporate algorithms that, if possible, avoid analyzing complete data sets, and instead analyze only relevant data.","Traditional approaches to business policy enforcement have several shortcomings. For instance, typically business applications create and store very large amounts of data to satisfy various needs of the business. The physical and logical data stores for these applications are typically designed by and organized for use by technical users, not for business users. For instance, types and degree of normalization in Relational Database Management Systems (RDBMSs) are tuned for functionality and performance as opposed to ease of semantic understanding by business users. Thus, the applications operate and store data using terminology that is often meaningless to business analysts. Performing policy analysis using transactional data may involve, for instance, using Structured Query Language (SQL), which is verbose and overly complex for typical business users and whose complexity grows as the complexity of the analysis grows. In addition, with RDBMSs, certain types of queries, such as those containing sliding time-windows, are difficult to accommodate. Complicating matters, each business application may store data differently, often for convenience for each application.","As another example, many business applications hold mission critical data and, therefore, do not expose transactional data, but use datamarts for external analysis to avoid performance loss. This and other data are constantly updated by business systems, making snap-shot techniques difficult to perform and potentially inconsistent in the resulting analysis.","Embodiments of the present invention include techniques for enforcing policies. In accordance with an embodiment, a method for enforcing policies includes storing a first set of data in at least one first data store, defining a plurality of semantic concepts of an ontology, constructing a map from the first set of data to the semantic concepts, executing the map to form a second set of data according to the ontology, and reasoning the ontology to determine compliance with one or more policies.","The at least one first data store may comprise a plurality of data stores and the method may include reformatting at least a portion of the first set of data. For example, the at least one first data store may include a relational database that has at least one table and the method may include denormalizing the at least one table. In addition, executing the map may include filtering the first set of data in order to restrain the size of the second set of data. The method may, for example, include defining a set of ETL transformations from the first set of data to the second set of data. A trigger may be defined and the map may be executed when the conditions for the trigger are fulfilled. Executing the map may include transforming the second set of data into another format, such as format optimized for use by a reasoning engine.","In accordance with another embodiment, at least one computer readable medium, having stored collectively thereon instructions for causing at least one processor to perform a method of enforcing policies is disclosed. The instructions include instructions for storing a first set of data in at least one first data store, for defining a plurality of semantic concepts for an ontology, for constructing a map from said data to said semantic concepts, for executing said map to transform said first set of data into a second set of data, for storing said second set of data in a second data store according to said ontology, and for reasoning said second set of data to determine compliance with one or more policies.","The at least one first data store may comprise a plurality of data stores and the instructions for executing the map may include instructions for reformatting at least a portion of said first set of data. For example, the at lest one first data store may include a relational database that includes at least one table and the instructions may include instructions for denormalizing the at least one table. Further, the instructions for executing may include instructions for filtering the first set of data in order to restrain the size of the second set of data. The instructions for constructing the map may include instructions for defining ETL transformations from the first set of data to the second set of data. The instructions may also include instructions for reformatting the second set of data into another format. Also, instructions for defining conditions for a trigger and executing the map every time the conditions for the trigger are fulfilled may be included.","In accordance with yet another embodiment, a system for enforcing policies is included. The system includes at least one first data store, a processor, a second data store communicatively coupled to the processor, and a rules engine. The first data store is operable to store a first set of data. The processor is operable to extract a second set of data from said first set of data according to a map between said first set of data and set of semantic concepts of an ontology. The second data store is communicatively coupled to the processor and is operable to receive the second set of data according to the ontology. The rules engine is communicatively coupled to the second data store and is operable to reason said second set of data to determine compliance with one or more policies.","In an embodiment, the at least one first data store comprises a plurality of data stores and the processor is operable to reformat at least a portion of the first set of data. For example, the at least one first data store may include a relational database that includes at least one table and the processor may be operable to denormalize the at least one table. The processor may be operable to filter said first set of data and the map may include a set of ETL transformations from the first set of data to the second set of data and may be operable to transform the second set of data into another format.","In the following description, for the purposes of explanation, specific details are set forth in order to provide a thorough understanding of embodiments of the invention. However, it will be apparent that the invention may be practiced without these specific details.","The following description describes an embodiment of the present invention in the business policy domain, and specifically with extracting data to implement business policies. However, the scope of the present invention is not restricted to business policies, but may be applied to other domains or applications. For example, any domain or application where a set of rules or criteria is used to analyze data may make use of the present invention. Examples of domains in which embodiments of the present invention may be used include segregation of duties, separation of powers, transaction monitoring, fraud or other crime detection, semantic web applications, and generally applications dealing with large sets of data.","In general, embodiments of the present invention provide techniques for extracting data. In an embodiment, semantic concepts of an ontology are defined and a map is defined from the data stores to the semantic concepts. Using the map, data is extracted from one or more data stores and loaded into a semantic data store that stores the data according to the ontology. Data may be denormalized during the process of extraction in order optimize the semantic data store for the purposes of policy enforcement. The map may be used to extract data according to one or more triggers in order to ensure that the data in the semantic data store, to the extent possible, reflects the current state of the data from which it was extracted.","Turning now to the drawings,  is a simplified block diagram of a computer system  that may be used to practice an embodiment of the present invention. Computer system  may serve as a user workstation or server, such as those described in connection with  below. As shown in , computer system  includes a processor  that communicates with a number of peripheral subsystems via a bus subsystem . These peripheral subsystems may include a storage subsystem , comprising a memory subsystem  and a file storage subsystem , user interface input devices , user interface output devices , and a network interface subsystem .","Bus subsystem  provides a mechanism for letting the various components and subsystems of computer system  communicate with each other as intended. Although bus subsystem  is shown schematically as a single bus, alternative embodiments of the bus subsystem may utilize multiple busses.","Network interface subsystem  provides an interface to other computer systems, networks, and portals. Network interface subsystem  serves as an interface for receiving data from and transmitting data to other systems from computer system .","User interface input devices  may include a keyboard, pointing devices such as a mouse, trackball, touchpad, or graphics tablet, a scanner, a barcode scanner, a touch screen incorporated into the display, audio input devices such as voice recognition systems, microphones, and other types of input devices. In general, use of the term \u201cinput device\u201d is intended to include all possible types of devices and mechanisms for inputting information to computer system . A user may use an input device in order to execute commands in connection with implementation of specific embodiments of the present invention, such as to implement, define policies, and\/or configure various components of an enterprise system, such as that described below in connection with .","User interface output devices  may include a display subsystem, a printer, a fax machine, or non-visual displays such as audio output devices, etc. The display subsystem may be a cathode ray tube (CRT), a flat-panel device such as a liquid crystal display (LCD), or a projection device. In general, use of the term \u201coutput device\u201d is intended to include all possible types of devices and mechanisms for outputting information from computer system . Results of implementing policies, defining policies, and configuring various components of a computer system may be output to the user via an output device.","Storage subsystem  provides a computer-readable medium for storing the basic programming and data constructs that provide the functionality of the present invention. Software (programs, code modules, instructions) that when executed by a processor provide the functionality of the present invention may be stored in storage subsystem . These software modules or instructions may be executed by processor(s) . Storage subsystem  may also provide a repository for storing data used in accordance with the present invention, for example, the data stored in the diagnostic data repository. For example, storage subsystem  provides a storage medium for persisting one or more ontologies. Storage subsystem  may comprise memory subsystem  and file\/disk storage subsystem .","Memory subsystem  may include a number of memories including a main random access memory (RAM)  for storage of instructions and data during program execution and a read only memory (ROM)  in which fixed instructions are stored. File storage subsystem  provides persistent (non-volatile) storage for program and data files, and may include a hard disk drive, a floppy disk drive along with associated removable media, a Compact Disk Read Only Memory (CD-ROM) drive, an optical drive, removable media cartridges, and other like storage media.","Computer system  can be of various types including a personal computer, a portable computer, a workstation, a network computer, a mainframe, a kiosk, personal digital assistant (PDA), cellular telephone, a server, or any other data processing system. Due to the ever-changing nature of computers and networks, the description of computer system  depicted in  is intended only as a specific example for purposes of illustrating the preferred embodiment of the computer system. Many other configurations having more or fewer components than the system depicted in  are possible.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 2","FIG. 2"],"b":"200"},"In accordance with an embodiment, the enterprise computer system  includes a first location  and a second location  communicatively connected by a network , such as the Internet or any suitable communications network or combination of networks. In an embodiment, the first location  and second location  correspond to separate physical locations of a business, such as offices in two separate cities, states, or countries. While  shows two locations, it should be understood that a business may have only a single location and may include more than two locations. As shown in the drawing, the enterprise computer system  may include one or more user workstations , a development server , and a developer workstation . The user workstation , development server , and\/or development workstation  may be physically present at any of the locations, or at separate locations. In an embodiment, the user workstation  and development server  are communicatively connected to the network  so as to access various components of the enterprise computer system. For example, the user workstation  may include a browser used for viewing content provided from the Internet and\/or from other systems within the business. Further, the developer workstation  may be connected to the network  through the development server  and may be adapted to enable certain employees within the organization to configure, install, modify, and perform other actions in connection with the business' computing systems. As an example, a developer within the organization may utilize the developer workstation in order to define policies, execute one or more applications that extract data and store the extracted data in one or more semantic data stores, and that reason the data according to the policies in accordance with various embodiments of the invention. The developer workstation  may include one or more rules engines, as may any of the components shown in . Instructions for controlling the applications and the defined policies may be sent over the network  to an appropriate computing device executing the one or more applications.","As noted above, the first location  may include various computer systems used in operating the business. For example, as depicted in , the first location  includes a web server  configured to receive requests from various users, such as from a user of the user workstation , and to respond to the requests over the network . While  shows the web server as a hardware component, as with any of the servers described herein, the web server may also be a software module operating on a computer system. Responses from the web server  may be provided from the web server  itself or through the web server  but from a variety of sources in communication with the web server , such as from components of an internal computer system of the first location  or from other web servers located at other, possibly third-party, locations.","In an embodiment, the web server  is communicably coupled to an application server , which is a hardware component or software module configured to run one or more applications, such as one or more policy engines and other applications for managing organizational data. As is known, a user of the user workstation  may send a request to the web server  that specifies a specific action to be taken in connection with an internal business application implemented on the application server . The web server  then relays the request to the application server  which takes the specified action and returns the result of that action to the web server , which in turn relays the result to the user workstation . In accordance with an embodiment, the web server , or other component, may modify the content returned to the user workstation  in accordance with one or more policies applicable to a user of the user workstation .","As shown in the example of , the application server  interacts with data stored in a first data store  and a second data store , each of which may store data relevant to the business' operation, such as in one or more relational or other databases. While the disclosed example shows the first location  having two data stores, it should be understood that the first location  may have less than two data stores or more than two data stores. Information in the data stores can include a wide variety of data, such as data relating to business transactions, invoices, human resources data, user account data, receipts, bank account data, accounting data, payroll data, and generally, any data relevant to the operation of a particular business. Information from the data stores , , and other sources, may be extracted from the data stores and stored in a semantic data store in accordance with an embodiment of the present invention.","In an embodiment, the second location includes its own web server , application server , first data store , and second data store  which may be configured to function similarly to the identically named components above.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 3","b":["300","302","304","304","302","302"]},"In the example of , four different data sources of a business are shown, although a business or other entity may use more than four data sources or less than four. Also, the four different data sources may be physically realized in separate data stores, which may be in separate geographical locations, or two or more data sources may be incorporated into a single data store. As shown in the example demonstrated in , a business may include a first relational database  which is modeled by a first relational schema . As it applies to data storage, a schema is a structure configured to organize the data of one or more data sources. For example, in a relational database, a schema that models the relational database defines the tables of the database, the fields of each table, and the relationships between the fields and tables.","In the provided example, the business may also include a second relational database  which is modeled by a second relational schema . There can be various reasons for having more than one source of business data, for example for storing data for different aspects of a businesses' activities, such as sales and human resources. Businesses may also store data in different forms depending on the particular application. For example, in  a light weight directory access protocol (LDAP) directory  is modeled by a LDAP schema . Likewise, a flat file database  may be modeled by a flat file schema . Thus, in the example shown in , a business may include data from a variety of sources in a variety of formats.","As can be seen in the figure, data from each of the data sources is mapped to the semantic data store . In an embodiment, mapping data from a data source to the semantic data store  is described in more detail below, but generally includes extracting data from the source and loading it (or a portion of it) into the semantic data store, which may or may not involve reformatting data from one form to a form suitable for the semantic data store . In addition, mapping data from a data source to the semantic data store  may involve mapping all data from the data source or using a filter to only map some data from the data source. For instance, the data source may include data that is not pertinent to the purposes for which the business ontology  is used and, as a result, only pertinent data would be mapped to the semantic data store. A filter may be used to control which data is mapped to the semantic data store. For example, the data mappings above can be used in connection with Oracle Data Integration (ODI) Tools available from Oracle International Corporation in order to perform ETL processes that constrain and filter data from the various data stores and merge the data into a common format in the semantic data store . As described below, once maps are constructed, the maps can be used in automated processes that extract data from one data store and appropriately load the data into the semantic data store . Extraction and loading of data can occur, for example, at predetermined intervals such as once a day, or at predetermined triggers, such as when data is changed.","As shown in the example, data from the first relational database  is stored in the semantic data store  as well as data from the second relational database , the LDAP Directory , and the flat file database . In an embodiment, schemas of various data stores are mapped to the business ontology such that semantic concepts embodied in the data stores are stored in the business ontology . For example, the first relational database  may include a plurality of tables, each table having one or more columns. The first relational schema  may relate tables together in a useful manner, for example, relating customers to invoices such that a customer is related to an invoice for goods or services purchased by the customer. Thus, relationships defined by the relational schema  are mapped to the business ontology  such that semantic concepts defined by the relational schema  are preserved in the business ontology .",{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 4","FIG. 3","FIG. 4"],"b":["400","402","400","400","404","406","408","410","406","408","410","408","406"]},"Also, in an embodiment, each relation  is a binary relationship between two classes. For example, a relation orgHasEmployees may be a relationship between a member of an organization class and an employee class. This relationship, for example, may specify employees that are part of an organization. Relations  may be further classified in terms of their domains (the class or classes from which they relate) and ranges (the class or classes to which they relate). Also, in an embodiment, some relations  have super relations. For instance orgHasEmployees may be a super relation of an orgHasManagers relation because, for example, all managers may be employees.","As shown in the diagram, the ontological meta model  also includes storage for ontological data types , which may be, for example, strings, integers, floats, dates, Boolean, or other types of data. In an embodiment, datatypes are the ranges (value sets) of the attributes and consist of sets of similar data forms. In the embodiment presented in the drawings, ontological type data is stored separately from instance data, which is stored in a hyper-denormalized relationed form. As used herein, semantic data that is in hyper-denormalized relationed form is stored such that every attribute is stored in its own table. This form provides an advantage in that instance data is easily and quickly accessible, which in turn allows for a highly distributed approach to solve problems of inferencing, persistence, and other issues. In other words, the architecture in the disclosed embodiment provides the power and flexibility of ontological storage with the performance of modern relational database management system. However, one with skill in the art will appreciate that variations are possible and that, in other contexts, different architecture may be appropriate. For example, one with skill in the art would recognize that type and instance data may be stored in the same storage system and that instance data need not be hyper-denormalized, but that different degrees of denormalization of data may be used, and different kinds of instance data may be combined in one or more containers.","As shown in the drawing, in an embodiment, between the classes are relations  between the classes  and there may be relations  among the relations . Also, each class  is an aggregation of attributes, in accordance with an embodiment.","As noted above, the relational meta-model  is mapped to the ontological meta-model, as described more fully below. In an embodiment, of relational meta-model includes relational concepts  which are super classes of tables , columns  and keys . Also, as is known, each table  is an aggregation of columns. As can be seen, various mappings are provided between various elements of the ontological meta-model  in relational meta-model . For instance, in an embodiment, one or more columns of a table are mapped to an attribute of the ontological meta-model . Likewise, tables  are mapped to classes  of the ontological meta-model . As keys  define relationships between tables  in the relational meta-model, keys of the relational meta-model  are mapped to relations of the ontological meta-model  in a manner preserving the relationships between the tables . In an embodiment, relational data types  are mapped to a ontological data types .","In an embodiment, the relational meta-model may be implemented using a relational database management system (RDBMS) and the meta-data in the relational meta-model is, therefore, readily available. The mapping shown in , in an embodiment, may also be achieved by utilizing Application Programming Interfaces (APIs) exposed by the systems implementing the relational meta-model , such as Java Database Connectivity (JDBC) meta-data, Open Database Connectivity (ODBC) meta-data, and the like.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 5","FIG. 3"],"b":["500","502","504","506","506","506","506"]},"In an embodiment, the semantic data store translates policies (queries) expressed in terms of the sales ontology  into queries expressed in terms of the semantic store schema, and executing the translated queries on the data store. The actual execution of the query may be delegated to a reasoner. Thus, in an embodiment, a query expressed in terms of classes and relations will be translated by the semantic data store  in terms of tables and keys. For example, in an embodiment, the ontological query:","ONT: SELECT X.firstName, X.lastName","will get translated into the semantic data source query:","SELECT firstName, lastName FROM Partition_1, Partition_2, . . . , Partition_N.","In addition, appropriate relations may be substituted with foreign-key\/primary-key pairings when the query is translated into the relational form.","As discussed above, the ontological meta-model is comprises of classes , relations  and attributes . The sales ontology  comprises specific instances of the members of the ontology meta-model . For example, as shown, the sales ontology  includes several classes including a person class , a buyer class  an employee class , an invoice class  and invoice item class . As seen by it's name, the person class  corresponds to people such as employees, buyers and other people. Accordingly, the buyer class  and employee class  are sub-classes of the person class . Also clear from its name, the invoice class  may be associated with invoices and the invoice item class  may be comprised of various invoice items such as various products sold by a business employing the disclosed ontology. In an embodiment, the employee class , invoice class , and invoice item class  have corresponding tables in the semantic data store . Other classes of the sales ontology  may also have corresponding tables in the semantic data store .","As shown, the sales ontology  includes various relations from the relations , such as a buyerOf relation  and a sellerOf relation  and a hasItems relation . The names of the various relations also may be related to their semantic meaning. For instance, as can be seen in the figure, a buyer of the buyer class  may be related to an invoice of the invoice class  by the relation buyerOf because the buyer may have purchased the particular items of the invoice. Likewise, an invoice of the invoice class  is related to invoice items of the invoice item class  by the relation hasItems  because the invoice items were included on the invoice. Also, the sellerOf relation  relates an employee of the employee class  to an invoice of the invoice class  when the employee was the person who sold the items listed on the invoice. In an embodiment, relations  are represented in the semantic data store  by the pairing of the primary key of the tables of the semantic data store , as discussed below.","Further, various items of the sales ontology  may include various members of the attribute class . As an example, person  may include a first name  and a last name , which as indicated in the drawing, may be stored as strings. Likewise, a buyer  may have a buyerID unique to the buyer as may an employee  have an employeeID  unique to the employee. Continuing this example, the invoice  may include an invoiceID  unique to the invoice  and a date , for example, on which the invoice  was created. As a final example, an invoice item of the invoiceItem class  may include an amount corresponding to the price at which the associated item was sold to the buyer .","As discussed above, various items of the sales ontology are stored in a semantic data store . In an embodiment, the semantic data store  may closely resemble a data store of another data model such as a relational database model. Thus, in an embodiment, the semantic data store  includes a plurality of tables where each table corresponds to a class of the ontology meta-model . It should be understood, however, that the example semantic data store  shown in the drawings may be in an intermediate format used to facilitate transformation of the data. Data from the semantic data store  may be further transformed, for example, into a format suitable for use with a particular reasoner operable to reason the data.","Thus, as shown in the illustrative example of , the semantic data store  includes an employee table , an invoice table  and an invoice item table . Each of the tables of the semantic data store  may include a key comprising an attribute unique to the entities represented by the table. For instance, the employee table  may include a column having each employee ID . Other attributes may also be stored in tables such as the last name and first name attributes of employees in the employee table . Likewise, the invoice table  may include a column corresponding to an invoice ID primary key, employee ID foreign key and buyer ID foreign key such that in this manner, for example, an ID of an invoice may be located in the invoice table  and the employee associated with the invoice and buyer to which items on the invoice are sold may be identified.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIGS. 6A and 6B","FIGS. 6A and 6B","FIG. 6","FIG. 2"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":["FIG. 6A","FIG. 6A","FIG. 6A"],"b":"600"},"Turning to the method as shown in the drawings, as depicted in , at a business data building step , business data is collected and stored. As discussed above, building business data may include using a variety of applications which store data in various formats, perhaps in various geographical locations. Business data building may be a process that proceeds over a period of time. For example, if a new employee joins an organization, a row in an employee table of a relational database may be added to correspond to the new employee. As another example, as new invoices are created, data related to the invoices are added to an appropriate data store.","At semantic definition step , semantic concepts are defined. For instance, if a business is interested in looking at an analyzing data relating to sales, semantic concepts such as employee, invoice item, buyer, seller etc., may be defined. Common semantic concepts may be pre-defined while less common concepts may be manually defined by users of a system employing an embodiment of the present invention.","At a map construction step , a data model map from the business data to the semantic concepts in a business ontology is defined. Because businesses may have a plurality of data stores storing data in various formats, constructing such a mapping may require specific knowledge of the specific data stores. However, predefined mappings may be included for data stores and data schemas which are commonly used, such as data stores that are included in database packages that are already configured for use by businesses that do not require a high level of customization.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 6B","b":["600","600","600","600","600","600"]},"Turning to the specific steps of the method B, at a mapping execution step , the mapping from the business data to the semantic concepts is executed in order to build a semantic data store. As discussed above, constructing a map may include use of Oracle Data Integration (ODI) Tools available from Oracle Corporation in order to execute the mapping by performing ETL processes that constrain and filter data from the various data stores and merge the data into a common format in a semantic data store according to one or more maps created from the various data stores to the semantic data store. Also, as noted above, in an embodiment, building a semantic data store includes formation of and\/or modification of one or more hyper-denormalized tables used to store the semantic data.","In an embodiment, as discussed above, as part of the mapping execution step , the user of one or more filters may be employed in order to limit the amount of information from business data sources that is loaded into the semantic data store. In an embodiment, every class of the ontology for the semantic data store has an active metadata property which has Boolean values. A filter may utilize the active metadata property in order to avoid performing ETL operations involving a class, relation, or attribute having an active metadata property that is set to \u201cfalse.\u201d Filters may be employed using additional and\/or alternative methods as well. For instance, the set of queries that will be allowed on a data store may be fixed and all concepts not involved with the queries may be set to be inactive (for instance, by setting the active metadata properties for the concepts to \u201cfalse\u201d). In this manner, an ETL process would only retrieve concepts mentioned in the queries and\/or their sub-queries.","In terms of loading (priming) the semantic data store, as part of the mapping execution step  the business ontology (such as the sales ontology described above) and data model mappings may be bootstrapped initially which, in an embodiment, involves interrogation of the meta-data store of the data source (such as a RDBMS). For example, in the case of RDBMS source data, bootstrapping may be initiated through a one-time process that generates the business ontology and mappings from the RDBMS schema(s).","In certain instances, such as with source data from RDBMSs, Web Ontology Language (OWL) concepts are generated from corresponding relational concepts using a set of transformation rules in order to define the mappings from the source data to the semantic data store. For example, binary tables from a RDBMS may be transformed to relations in an ontology as may primary\/foreign-key pairings. Other tables may be transformed to classes while columns of tables may be transformed to attributes.","In addition, because tables in a semantic data store have a similar structure to tables in many business data sources, it is often straightforward to dynamically create transformations to be executed by an ETL process in order to prime the semantic data store by moving data from the data sources to the data store. For example, this can be performed using ODI by Oracle Corporation for ETL from business data sources to a semantic data store. Generally, at system startup, when the semantic data store is empty, the records from the data sources (such as tables of an RDBMS) may be extracted, necessary data transformations may be made and then the data may be loaded into the semantic data store.","In addition, the business ontology and data model mappings may be manually edited and\/or annotated to give domain-appropriate names to the business domain concepts and to capture any semantics that count's be captured automatically during bootstrapping. As an example, if the business ontology were intended to support an accounts payable business domain, the concepts of Invoice, Receipt, and Vendor might be defined. Further, if multiple overlapping data schemas are involved, the manual editing\/annotation may involve merging of the concepts in the ontology. As an example, if bootstrapping resulted in a Buyer class and a Purchaser class because of different naming conventions in different data sources, these classes may be joined in the ontology to a single class.","As discussed above, as source data changes over time, the data in the semantic data store is updated at various times, such as periodically, by performing the mapping execution step  in order to update the semantic data store to reflect the changed data. Thus, the business ontology and data model mappings are used to define ETL transformations that may be scheduled to run automatically, such as at predefined periods of time, whenever there is a change in source data, and\/or at other triggers. The ETL transformations move data from the data sources to the Semantic Data Store according to the data model mappings.","For example, with source data from RDBMSs, when the semantic data store is empty, it is a straightforward process to extract records from the data sources to the semantic data store by extracting data from the data source tables, make necessary data transformations, and then load the data into the semantic data stores. After startup, when there are already data in the semantic data store, records flowing into the semantic data store may need to be merged with existing data in the semantic data store. This may be done, for instance, by using a primary key in the incoming source record to locate the equivalent target record and either adding the record to the appropriate table in the semantic data store or merging the record into the appropriate table of the semantic data store. If the semantic data store table for the incoming record has an identifiable primary key tied to multiple data values, then the incoming record may be added to a table rather than merged.","At a reasoning step , data from the semantic data store is reasoned in order to determine compliance with one or more policies. Reasoning the data from the semantic data store may be accomplished in a variety of ways. For instance, data from the semantic data store may be reasoned according to techniques described in co-pending U.S. patent application Ser. No. 12\/576,176, entitled \u201cTechniques for Processing Ontologies,\u201d mentioned above. Generally, any method of reasoning the data of the semantic data store may be used. As examples, any suitable transitive and\/or pattern-based reasoner may be used depending on the specific policies for which compliance is monitored.","Although specific embodiments of the invention have been described, various modifications, alterations, alternative constructions, and equivalents are also encompassed within the scope of the invention. Embodiments of the present invention are not restricted to operation within certain specific data processing environments, but are free to operate within a plurality of data processing environments. Additionally, although embodiments of the present invention have been described using a particular series of transactions and steps, it should be apparent to those skilled in the art that the scope of the present invention is not limited to the described series of transactions and steps.","Further, while embodiments of the present invention have been described using a particular combination of hardware and software, it should be recognized that other combinations of hardware and software are also within the scope of the present invention. Embodiments of the present invention may be implemented only in hardware, or only in software, or using combinations thereof.","The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. It will, however, be evident that additions, subtractions, deletions, and other modifications and changes may be made thereunto without departing from the broader spirit and scope as set forth in the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIGS. 6A and 6B"}]},"DETDESC":[{},{}]}
