---
title: Managing allocation of temporary and permanent files in a database system
abstract: A database system includes a plurality of access modules and corresponding persistent storage devices each having a pool of storage elements that can be allocated to store permanent files and temporary files. Each access module is associated with a non-persistent file management context and each storage device contains a persistent file management context. The persistent file management context indicates allocation of permanent files, while the non-persistent file management context indicates the allocation of both permanent and temporary files.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07904419&OS=07904419&RS=07904419
owner: Teradata US, Inc.
number: 07904419
owner_city: Dayton
owner_country: US
publication_date: 20001208
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The invention relates to managing allocation of temporary and permanent files in a database system.","Database systems are used to collect and store various types of information that are later extracted for viewing or manipulation. Various different types of database systems exist, including relational database systems, object relational database systems, and others. Relational database systems store data in relational tables. When a query, such as a Structured Query Language (SQL) query is received, a subset of the data is extracted from one or more relational tables.","Many typical database systems divide data into different storage regions, such as system storage, permanent storage, and temporary storage. System storage contains data associated with the operation and configuration of the database system. Permanent storage typically is used to store user data. The storage is \u201cpermanent\u201d in the sense that stored data remains in storage until deleted or modified by a request to delete or update the data. Temporary storage is typically used to store intermediate or final results of a query. The data in temporary storage is usually discarded after the query has completed so that the temporary storage can be used by other database operations.","The behavior of the database control logic differs when accessing data in the permanent and temporary storage regions. When accessing the permanent storage region, the database control logic usually acquires transaction locks to prevent one operation from interfering with another operation, logs data changes, and maintains context information to enable recovery of data if a system crash occurs. However, such tasks are usually not performed when accessing data in the temporary storage region.","To allow different treatment of the different storage regions, the database control logic may have to be separated for the different types of files. This allows the database control logic responsible for the temporary storage region to avoid some of the management overhead associated with the permanent storage region. However, the separation of the database control logic for temporary and permanent files creates other inefficiencies. For example, the storage space allocated for temporary storage may not be available for permanent storage, and vice versa.","In general, a method for use in a database system having a persistent storage device and a non-persistent memory comprises storing a first file management context in the persistent storage device, and storing a second file management context in the non-persistent memory. Both the first and second file management contexts are updated to allocate a permanent file, and the second file management context is updated without updating the first file management context to allocate a temporary file.","Other or alternative features will become apparent from the following description, from the drawings, and from the claims.","In the following description, numerous details are set forth to provide an understanding of the present invention. However, it will be understood by those skilled in the art that the present invention may be practiced without these details and that numerous variations or modifications from the described embodiments may be possible.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1","b":["10","12","14","14","12","10","10"]},"In the illustrated embodiment, the database system  includes multiple nodes A and B (two or more). In an alternative embodiment, the database system  can also be a single-node system. The nodes A and B are coupled by an interconnect network , which is in turn connected to an interface system . The interface system  includes a query coordinator  to receive queries from the client , to parse the received requests, and to generate access requests to one or more data servers A, B in corresponding nodes A, B. Each node A, B includes respective one or more control units A, B that are coupled to a respective memory A, B, which can be main memory, a cache, or some other form of storage.","Each data server A, B controls access to a respective storage unit A, B. The data servers A, B can also be referred to as \u201caccess modules\u201d for the storage units A, B. In one embodiment, the database system  is a relational database management system or an object relational database management system. User data A, B are contained in relational tables in respective storage units A, B. The storage units A, B also contain respective system tables A, B for storing system operational and configuration information. In addition, the storage units A, B contain temporary files A, B that are used to store intermediate or final results of database operations.","The user data  is stored in a permanent storage region of the storage unit , while the temporary files  are stored in a temporary storage region of the storage unit . The user data  are stored in \u201cpermanent\u201d files. Such files are considered \u201cpermanent\u201d in the sense that they are not lost in the event of system crashes, resets, or power cycles. However, permanent files can be changed or deleted by user requests during normal operation of the database system . A \u201cfile\u201d refers to any apportionment of data in the database system\u2014for example, a file can refer to a row or column of a relational table or to some other apportionment.","In accordance with some embodiments of the invention, the permanent storage region and temporary storage region are part of the same pool of storage resources in each storage unit. For example, the pool of storage resources includes blocks or pages (generally referred to as \u201cstorage elements\u201d) in the storage unit .","By employing file management contexts in accordance with some embodiments, a block or a group of blocks can be selectively allocated to either permanent or temporary storage. Two groups of file management contexts are maintained: a first group  (referred to as \u201cpersistent file management context\u201d) is stored in the storage unit ; and a second group  (referred to as \u201cnon-persistent file management context\u201d) is stored in the memory  of each node . The storage unit  in one embodiment is a persistent storage unit. A persistent storage unit maintains stored data even if power is removed from the database system or the database system is reset. However, the second group  is stored in a non-persistent storage unit, such as the memory  in the node . Examples of the memory  include dynamic random access memories (DRAMs), static random access memories (SRAMs), and the like.","In one embodiment, the file management context in either persistent or non-persistent storage includes two maps: a first map to allocate storage identifiers for uniquely identifying each file created in the database system, and a second map to allocate allocation units, which are blocks or pages of storage in the storage units A, B. Each map contains flags that can be set to indicate allocation of a storage identifier or allocation unit. The flags can be released to indicate when a storage identifier or allocation unit has been released.","A file management context control routine or module  in each data server  is capable of accessing the file management context  through an application programming interface (API) , which defines a collection of API calls. In one example embodiment, the API  defines the following methods that are invocable by the file management context control routine : a method SET_STORAGE_ID( ) to allocate a temporary or permanent storage identifier; a method RELEASE_STORAGE_ID( ) to release a temporary or permanent storage identifier; a method SET_ALLOCATION_UNIT( ) to allocate blocks of storage; and a method RELEASE_ALLOCATION_UNIT( ) to release blocks of storage.","To access the storage units A, B, the data servers A, B issue requests to respective file systems A, B. The file systems A, B then generate commands to the storage units A, B to access data in the storage units A, B.","The database system  according to the arrangement of  is provided as an example only. In other embodiments, other arrangements of the database system can be utilized. For example, another database system is the Teradata database system from NCR Corporation. The Teradata database system includes a parsing engine that interprets SQL statements and controls the dispatch of requests to virtual access module processors (VAMPs) in one or more nodes. The VAMPs control extraction or manipulation of data stored in respective storage units.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2","b":["10","38","30","26","52"]},"The persistent file management context  includes a STORAGE_ID map  (to allocate storage identifiers to permanent files) and an ALLOCATION_UNIT map  to allocate blocks or pages to permanent files). Each map  or  includes an array of flags that can be set to a \u201c1\u201d or \u201c0\u201d state. A \u201c1\u201d or active state indicates that a storage ID or an allocation unit has been allocated to a permanent file.","The non-persistent file management context  also includes a STORAGE_ID map  and an ALLOCATION_UNIT map . Whereas the maps  and  in persistent storage are used to allocate storage IDs or allocation units to permanent files, the maps  and  are used to allocate storage IDs or allocation unit to both permanent and temporary files. The persistent maps  and  are subsets of respective non-persistent maps  and . Each of the STORAGE_ID and ALLOCATION_UNIT maps  and  includes flags that can be set to a \u201c1\u201d or \u201c0\u201d state, with some of the flags corresponding to permanent files and others corresponding to temporary files.","Even though the same pool of storage elements are used to store both temporary and permanent files, the control logic in the data server  performs different management functions depending on whether a flag that is set in the STORAGE_ID or ALLOCATION_UNIT maps correspond to a temporary file or permanent file. For a permanent file, the control logic in the data server  performs transaction locking, logging of data changes made to the maps, and performs tasks to provide data consistency across restart boundaries. Allocation of a permanent file is indicated when the persistent STORAGE_ID map  or ALLOCATION_UNIT map  is updated. However, when a temporary file is allocated, and the non-persistent maps  and  are updated without updating the persistent maps  and , the control logic in the data server  does not perform transaction locking, logging of data changes made to the maps, and performing tasks to provide data consistency across restart boundaries.","Storage capacity is made more efficient by combining the pool of storage elements to store both temporary and permanent files. At the same time management overhead is reduced by performing certain tasks only if permanent files are allocated.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4","b":["106","110","108","112","250","252","272","1","254","256","274","2","276","262","264","266","1","2"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 3","b":["22","26","38","23","16","202","106","30","204","52","16","52","110","23","206","108","208","52","16","112"]},"In response to requests received from the query coordinator , the data server  issues calls to the file management context control routine  to perform storage allocation. Each storage management call contains a flag that identifies the class of storage desired: temporary or permanent. As shown in , when the file management context control routine  receives (at ) a storage management call, it determines (at ) if the flag in the storage management call indicates a temporary file or a permanent file. If the flag indicates a temporary file, then the file management context routine  searches (at ) the in-memory or non-persistent STORAGE_ID map  to find a free storage identifier. The routine  then sets (at ) the corresponding bit in the non-persistent STORAGE_ID map to an active state. This is accomplished by calling the SET_STORAGE_ID( ) method in the API  (). Next, the routine  searches (at ) the non-persistent ALLOCATION_UNIT map  to find a free block or a group of free blocks. The corresponding bit(s) in the non-persistent ALLOCATION_UNIT map  are then set (at ) to the active state by calling the SET_ALLOCATION_UNIT( ) method. Plural bits are set if the allocation unit contains plural storage blocks.","For temporary files, only the non-persistent maps  and  are updated; the persistent  and  remain unchanged. When a temporary file is deleted, the API methods RELEASE_STORAGE_ID( ) and RELEASE_ALLOCATION_UNIT( ) are called to release flags (set the flags to the inactive state) in the maps  and .","However, if the flag in the storage management call indicates a permanent file (as detected at ), then the file management context control routine  searches (at ) the non-persistent STORAGE_ID map  for a free storage identifier. The corresponding bit in the non-persistent STORAGE_ID map  is then set (at ) to an active state. In addition, the file management context control routine  also sets (at ) a corresponding bit in the persistent STORAGE_ID map  to an active state. Setting flags in the STORAGE_ID maps  and  are accomplished with respective calls of the SET_STORAGE_ID( )method.","Next, the routine  searches (at ) the non-persistent ALLOCATION_UNIT map  for a free block or a group of free blocks. The routine  then sets (at ) the corresponding bit(s) in the non-persistent ALLOCATION_UNIT map  to an active state. The corresponding bit in the persistent ALLOCATION_UNIT map  is also set (at ) in the persistent ALLOCATION_UNIT map to the active state. Setting flags in the ALLOCATION_UNIT maps are accomplished by calling the SET_ALLOCATION_UNIT( ) method.","In the operation discussed above, when the control logic in each data server  detects that the persistent maps  and  are updated (indicating that a permanent file is being allocated), the control logic performs transaction locking, data change logging, and other tasks to provide data consistency across restart boundaries. Such tasks are not performed when a temporary file is allocated.","The persistent maps  and  can be considered to be \u201cshadows\u201d of the non-persistent maps  and . In the event of a system crash or reset, the persistent maps  and  are maintained in the persistent storage units A, B so that permanent files are not lost as a result of the system crash or reset. However, the non-persistent maps  and  are lost, which effectively erases any allocated temporary files.","The various software routines or modules discussed above are executable on corresponding one or more control units in the database system . Each of the control units includes a microprocessor, a microcontroller, a processor card (including one or more microprocessors or microcontrollers), or other control or computing devices. As used here, a \u201ccontroller\u201d refers to hardware, software, or a combination of both. A \u201ccontroller\u201d can refer to a single component or to plural components (whether software or hardware).","The storage units or devices referred to herein include one or more machine-readable storage media for storing data and instructions. The storage media include different forms of memory including semiconductor memory devices such as dynamic or static random access memories (DRAMs or SRAMs), erasable and programmable read-only memories (EPROMs), electrically erasable and programmable read-only memories (EEPROMs) and flash memories; magnetic disks such as fixed, floppy and removable disks; other magnetic media including tape; and optical media such as compact disks (CDs) or digital video disks (DVDs). Instructions that make up the various software routines or modules are stored in respective storage units. The instructions when executed by a respective control unit cause the corresponding system to perform programmed acts.","The instructions of the software routines or modules are loaded or transported to each system in one of many different ways. For example, code segments including instructions stored on floppy disks, CD or DVD media, a hard disk, or transported through a network interface card, modem, or other interface device are loaded into the system and executed as corresponding software routines or modules. In the loading or transport process, data signals that are embodied in carrier waves (transmitted over telephone lines, network lines, wireless links, cables, and the like) communicate the code segments, including instructions, to the system. Such carrier waves are in the form of electrical, optical, acoustical, electromagnetic, or other types of signals.","While the invention has been disclosed with respect to a limited number of embodiments, those skilled in the art will appreciate numerous modifications and variations therefrom. It is intended that the appended claims cover such modifications and variations as fall within the true spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
