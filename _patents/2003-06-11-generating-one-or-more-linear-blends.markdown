---
title: Generating one or more linear blends
abstract: A method () generates one or more linear blends. Initially, the method has a list of already received one or more fill-paths defining a current linear blend, and a newly received fill-path, where the fill-paths each comprise a single colored parallelogram (eg. ). The method adds () the new fill-path to the list to become the last fill-path in the list, if the difference () in color between the new fill-path and the last fill-path in the list is no greater, in each color channel, than a predetermined threshold value multiplied by the difference in color between the last and second-last fill-paths in the list. The predetermined threshold value is preset to such a value so that the new fill-path will not be added to the list if the new fill-path does not visually form part of the current linear blend. The method repeats this step for each new fill-path received until the aforementioned condition is not satisfied. Then, the method generates () one or more linear blends from the first fill-path in the list to the last fill-path in the list.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07304648&OS=07304648&RS=07304648
owner: Canon Kabushiki Kaisha
number: 07304648
owner_city: Tokyo
owner_country: JP
publication_date: 20030611
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION INCLUDING BEST MODE","INDUSTRIAL APPLICABILITY"],"p":["The present invention relates to electronic image generation and control and, in particular, relates to generating one or more linear blends.","Traditionally, software applications such as word processors, create page-based documents where each page contains graphic objects such as text, lines, fill regions and image data. When representing the document data on a display device or a printing device, such software applications typically send commands defined in terms of the graphics interface services of a native operating system within which the software application operates. The graphics interface services of the native operating system are typically known as the graphics device interface (GDI) layer. The GDI layer is generally an application programming interface (API) providing a rich set of graphics features to all applications. Typically, a graphics rendering system renders the graphics objects received from the GDI layer, generating pixels, which are then sent to the output device. Rendering is the process by which the graphics objects received from the GDI layer are converted to pixels by the graphics rendering system, which are then sent to the output device for storage, display, or printing.","Turning to  there is shown a traditional relationship between a prior art software application , a graphics device interface layer , a graphics rendering system , and an output device . The application  passes each page of a document as a series of commands defined in terms of the graphic interfaces services which describe the graphic objects of the page. The GDI layer  mediates between the application program  and the output device , such that the GDI layer  enables the graphics rendering system  to support a much smaller set of functionality, such as drawing rectangular blocks of image data, and filling simple regions with flat color. The GDI layer  also provides graphics objects to the graphics rendering system  in a format that the GDI layer  determines that the rendering system  would process most efficiently, and at a resolution of the output device . The graphics rendering system  then renders the graphics objects received from the GDI layer , generating pixels, which are then sent to the output device .","In some known graphic rendering systems, rendering is a two-stage process. In these rendering systems, graphics objects are first converted into an intermediate language before the rendering process begins. In one such system, the first stage of the process converts each graphic object received from the GDI layer into some intermediate edge-based object graphics format, such that all edges are sorted in ascending y, then ascending x, these corresponding respectively to the scan lines and pixel locations on such scan lines in a rasterized display. The output from this stage is typically a display list of edges and their associated fill priority (z-order), along with other information such as if this edge is a clipping edge or a filling edge. This is sometimes called a job. The job contains all the information needed by the second stage to render the page. The second stage of the process involves a rendering module parsing the job and generating the pixels for the output device for each scanline down the page.","In some GDI layers, a graphics object filled with a smooth blend of color is represented by the GDI layer as a series of adjacent single-colored parallelograms, each differing in color by some small offset from the previous, and which is clipped over the area of the graphics object. The parallelograms may proceed left to right, top to bottom or diagonally across the page.","Some applications refer to this type of fill as a gradient fill (Microsoft Word) or a fountain fill (Corel Draw). For sake of clarity, this type of fill is referred for the purposes of this description as a gradient fill. An example of a graphic object  filled with a diagonal gradient fill as produced by a typical prior art application is shown in . The method of filling an object with a gradient fill is dependent on the application. However, in its simplest form, such a method typically consists of specifying a start color and an end color at each end of a bounding box of the graphic object being filled. , B, C illustrate how a diagonal gradient fill is typically passed by the application to the GDI layer to the graphics rendering system.","Some graphics rendering systems typically support a simple form of the gradient fill effect called a linear ramp or a linear blend. This can be represented by a starting reference point on the page, with an associated starting color, accompanied by a constant gradient change per color channel per pixel, on a line parallel to the gradient of the blend.","However, applications are generally not restricted to outputting a blend comprising a purely linear gradient fill effect. In fact, color changes in gradient fill effects produced by some applications can be parabolic or even sinusoidal. An example of an object  having a sinusoidal gradient fill produced by a prior art application is shown in .","Typically, the GDI layer reduces the gradient fill to a set of single-colored parallelograms, referred to here as fill-paths, with an accompanying clipping object. For example, , shows the fill-paths and clipping object passed to the graphics rendering system by a typical prior art GDI layer, which were produced from the example gradient fill as shown in . The GDI layer reduces the gradient fill to a set of single colored fill-paths  and a clip object . For sake of clarity,  shows only two exaggerated fill-paths . The entire set of the fill-paths  covers a rectangular area , with each fill-path  parallel to and adjoining its adjacent fill-path(s). The length of the sides of these fill-paths  depends on the resolution at which rendering occurs. For example, at 600 dpi, each fill-path  is typically no greater than 100 pixels high, but each can vary in width by several pixels. Also, each fill-path  has a slightly different interior color from the previous fill-path . This produces a smooth blend of colors associated with the gradient fill when the object is rendered. Turning now to , there is shown the result of the rendering of the example shown in  by a typical prior art graphics rendering system. In the latter case, the rendering system has clipped the bounding box  comprising the fill-paths  with the clipping object  resulting in the object . In , the result after rendering is the same as .","There are a number of conventional methods for rendering such a representation of a gradient fill effect.","One conventional method is to simply render each fill-path. Many graphics rendering systems use a Painters algorithm style of rendering where each object is drawn onto a frame buffer as it arrives. A 2-stage object-graphics rendering system that firstly converts all incoming objects into some intermediate format for the page, and then renders each scanline, is at a disadvantage in rendering each fill-path. For the gradient fill shown in , the GDI layer generates 128 fill-paths at 600 dpi. It can be seen that in the case of the blend proceeding top to bottom or bottom to top, then on any scanline, only one fill-path is active. But in the worst case of the blend proceeding left to right or right to left, all 128 fill-paths are active on a scanline, equating to 256 edges per scanline. Hence for an object-based rendering system, such a method of rendering is considerably inefficient. Also, each flat fill must be stored in the intermediate object-graphics format, and accessed for each fill-path for each scanline. This method consists of large amounts of memory accesses and can also consume large amounts of fill resources when the number of fill-paths is in the order of thousands. This occurs frequently when printing to pages larger than A at high-resolutions.","On an aesthetic level, another disadvantage of simply rendering each fill-path is that although the intended effect is clearly a smooth blend, an artifact called Mach Banding can occur. Since the eye is more sensitive to edges than it is to smooth changes in color, the eye can often see the division of rectangles when a gradient fill effect is rendered this way. The divisions become even clearer at some parts of the color gamut. Also, if the entire image is enlarged, then each fill-path is also enlarged and Mach Banding becomes highly visible.","At the application-level, another conventional method for dealing with gradient fill effects is to simply render the fill effect onto a bitmap and send this to the GDI layer. This method is effective for small fill regions, but has the disadvantage of being slower to draw and cumbersome to render since every pixel of an image has to be dealt with by the graphic rendering system. This method also does not scale well when the object is enlarged (duplication of pixels) or reduced (loss of pixels).","Another conventional method is to test each incoming fill-path for linearity and when the next fill-path is no longer linear within some error, then to create an equivalent linear blend up to this fill-path. Tracking for linearity then starts again from this next fill-path. This method can dramatically reduce the number of graphic objects needing to be rendered. In the best case scenario the entire graphic object can be described by a single linear blend. For the diagonal gradient fill as shown in , this would represent a 1\/128reduction of the number of edges per scanline than if this were drawn with multiple fill-paths.","However, this method has its disadvantages. As described above, an application may provide gradient fill effects more advanced than a simple linear blend. Such effects may consist of several color changes throughout the object being filled (eg. sinusoidal as in ), or they may follow some non-linear curve as in  or B. Similarly, the lengths of the sides of consecutive fill-paths are not necessarily constant. In either case, the resulting set of fill-paths describing the object does not necessarily consist of a constant change in color for each fill-path even though the desired overall effect in each case is a smooth blend of color across the graphic object.","In this method an error factor is applied to determine the linearity of the next fill-path in a series of fill-paths. If the next fill-path is different to the previous fill-path by a constant difference plus or minus some error, then it is merged into the linear blend being tracked. If this error factor is too small, then it results in many linear blends, defeating the purpose of this method. If this error factor is too large, then it results in color shifting such that the output would not correctly represent the input. For example, turning to  there is shown a non-linear blend varying from black in the top-left corner to white in the bottom right corner, where the midpoint color between black and white is located at 25% of the distance between the top-left and bottom right corners. Also,  shows a similar non-linear blend, but where the midpoint color is located at 75% of the distance between the top-left and bottom right corners. If the non-linear fill-paths shown in  or B were tracked using a large enough such error factor, then the result would be a pure linear blend from black in the top-left corner to white in the bottom-right corner as shown . The result is clearly not what the user of the application intended.","Also, when the fill-paths are combined into multiple linear blends, then Mach Banding tends to become noticeable between adjacent linear blends. This banding is highly visible because the linear blends are split at their greatest error, delineating the adjacent linear blends more markedly than if individual fill-paths were rendered.","It is an object of the present invention to substantially overcome, or at least ameliorate, one or more disadvantages of existing arrangements.","According to a first aspect of the present disclosure, there is provided a method of generating one or more linear blends, wherein the method initially comprises a list of already received one or more fill-paths defining a current linear blend, and a newly received fill-path, where the fill-paths each comprise a single colored parallelogram, the method comprising the steps of: (a) adding the new fill-path to the list to become the last fill-path in the list, if a number of conditions are met, otherwise proceeding to step (c), wherein one of the number of conditions is based on the color of the new fill-path and the last fill-path and a threshold value, and the threshold value is preset to such a value so that the new fill-path will not be added to the list if the new fill-path does not visually form part of the current linear blend; (b) repeating step (a) for each new fill-path received; and (c) generating one or more linear blends from the first fill-path in the list to the last fill-path in the list.","According to a second aspect of the present disclosure, there is provided a method of generating one or more linear blends from a list of one or more fill-paths defining a current linear blend, and at least one new fill-path, where the fill-paths each comprise a single colored parallelogram, the method comprising the steps of:","(a) adding one said new fill-path to said list to become a last fill-path in said list, if each condition of a set thereof is met, otherwise proceeding to step (c), said set comprising at least one condition, said one condition being based on the color of the new fill-path and the last fill-path and a threshold value, and said threshold value is preset to such a value so that the new fill-path will not be added to the list if the new fill-path does not visually form part of the current linear blend;","(b) repeating said step (a) for each remaining said new fill-path; and","(c) generating one or more linear blends from the first fill-path in said list to the last fill-path in said list.","Preferably, the set of conditions further comprises conditions selected from the group consisting of:","a (second) condition that the new fill-path is physically contiguous with the last fill-path in the list;","a (third) condition that a height of the new fill-path is no greater than two times a height of the most recently added fill-path in the list, the height being measured in a direction determined by physical positions of the fill-paths of the list;","a (fourth) condition that the number of fill-paths in the current linear blend is greater than 1;","a (fifth) condition that a sum of the accumulated height of the fill-paths in the linear blend and a rectangle-height of the new fill-path is less than a predefined maximum;","a (sixth) condition that a raster operation for the currently received fill-path does not use a destination, and is the same as a raster operation for the current linear blend; and","a (seventh) condition that the currently received fill-path has the same clip as the current linear blend.","Other aspects of the invention, including apparatus, computer programs and computer media arranged to perform the methods, are also disclosed.","Where reference is made in any one or more of the accompanying drawings to steps and\/or features, which have the same reference numerals, those steps and\/or features have for the purposes of this description the same function(s) or operation(s), unless the contrary intention appears.","A method for generating linear blends is preferably implemented as a software module for running on a processor of a general-purpose computer. A typical general-purpose computer for executing such a software module is described below with reference to . The software module is preferably a part of a first stage of a graphics rendering system that interfaces to a graphics device interface (GDI) layer and receives graphics objects for a page, converting each graphics object to an intermediate edge-based format. In the second stage of the graphics rendering system, the job is rendered and the resulting pixels are output to a downstream device, such as a printer or graphics card. Preferably, both stages of the graphics rendering system are implemented as modules in a graphics software application. Alternatively, the first stage is implemented as a software application, which interfaces with the second stage, which is implemented as a hardware device coupled to a bus for communicating with the first stage operating on the processor.","The GDI layer is preferably an application-programming interface (API) and provides the graphics rendering system with a gradient fill as a series of fill-paths.","Although the following method describes the case of a non-orthogonal gradient fill effect, and specifically where the fill-paths arrive in the order top-left to bottom-right with vertical sides, it can be easily modified to handle the cases where the fill-paths proceed in any orthogonal or non-orthogonal direction.","Before proceeding with the detailed description, a brief review of terminology is discussed.","1.0 Definitions","A fill-path is defined as a single-colored (or flat-colored) parallelogram. The term parallelogram is also taken to include a rectangle or a square. Where a gradient fill proceeds exactly horizontally or vertically, the fill-path is generally rectangular in shape. For gradient fills proceeding diagonally across the page, the fill-path is a parallelogram.","The direction in which a non-orthogonal gradient fill travels can be any one of 8 directions. These directions are partitioned into gradient fills that use horizontal fill-paths and gradient fills that use vertical fill-paths and are defined as follows:\n\n",{"@attributes":{"id":"p-0067","num":"0080"},"figref":["FIGS. 5A to 5D","FIGS. 5A to 5D","FIGS. 6A to 6D"],"b":["6","6"]},{"@attributes":{"id":"p-0068","num":"0081"},"figref":"FIG. 5A","b":["600","620","610","610","620","630"]},{"@attributes":{"id":"p-0069","num":"0082"},"figref":"FIG. 5B","b":["600","620","640","640","620","630"]},{"@attributes":{"id":"p-0070","num":"0083"},"figref":"FIG. 5C","b":["600","620","660","620","650"]},{"@attributes":{"id":"p-0071","num":"0084"},"figref":"FIG. 5D","b":["600","620","670","620","650"]},{"@attributes":{"id":"p-0072","num":"0085"},"figref":"FIG. 6A","b":["600","605","625","625","620","615"]},"On the other hand, the fill-paths  of  proceed in a horizontal direction from the bottom left to the top right of the bounding box and are defined as Horizontal Up Right. Again the horizontal fill-paths , and are defined as Right.",{"@attributes":{"id":"p-0074","num":"0087"},"figref":"FIG. 6C","b":["600","605","655","655","605","645"]},"On the other hand, the fill-paths  of  proceed in a horizontal direction from the top right to the bottom left of the bounding box and are defined as Horizontal Down Left. Again, the horizontal fill-paths , and are defined as Left.","However, if a fill-path is deemed not aligned with an adjacent fill-path then no (ie. a NULL) direction is assigned. Having no direction means that a gradient fill will not be created, or the new fill-path will not be accepted as part of the current fill.","There are two different types of height that are referred to in the present description, those being rectangle-height and total-height. Depending on how the currently stored gradient fill is oriented the heights are defined differently.  illustrate the definitions of these different heights and how they differ depending on the orientation of a gradient fill.  shows fill-paths  in the form of parallelograms proceeding in a vertical direction and a bounding box  of a clipping object (not shown). In the case of vertical fill-paths (eg. ), the rectangle-height of a fill-path is defined as the length of the side of the parallelogram constituting the fill-path, in the y co-ordinate direction. In the case of vertical fill-paths (eg. ), the total-height at an n-th fill-path is defined as the sum of the rectangle-heights of the n-th fill-paths in the y co-ordinate direction. In the case of horizontal fill-paths (eg. B), a similar definition applies, however the lengths are measured in the x co-ordinate direction. Also, as will become apparent, the rectangle-height may differ from fill-path to fill-path.","When defining a linear gradient fill from individual fill-paths, the intermediate edge format accepts the color values and positions of two reference points on a line parallel to the gradient of the blend to define the gradient fill.  shows the equations used to find the second reference point (Q,P), which is used in defining the gradient fill. The first reference point (\u201cfill-path point \u201d as illustrated) is already known.  depicts the vertical angles associated with collected fill-paths inclined at an angle (\u03b8) and which transverse length (X). The angle (\u03b8) is determined from:",{"@attributes":{"id":"p-0079","num":"0092"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"\u03b8","mo":"=","mrow":{"mi":"arctan","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mi":["Y","X"]}}}}}},"br":[{},{},{},{},{},{}],"in-line-formulae":[{},{},{},{},{},{}],"b":"1"},{"@attributes":{"id":"p-0080","num":"0093"},"maths":[{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"P","mo":"=","mrow":{"mi":"Height","mo":"\u00b7","mrow":{"msup":{"mi":"cos","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"arctan","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mi":["Y","X"]}}}}}}}}},{"@attributes":{"id":"MATH-US-00002-2","num":"00002.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Q","mo":"=","mrow":{"mi":"Height","mo":["\u00b7","\u00b7"],"mrow":[{"mi":"sin","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"arctan","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mi":["Y","X"]}}}}},{"mi":"cos","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"arctan","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mi":["Y","X"]}}}}}]}}}}]},"Similarly, for the horizontal angles shown in . the following equations also may be derived:",{"@attributes":{"id":"p-0082","num":"0095"},"maths":[{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"\u03b8","mo":"=","mrow":{"mi":"arctan","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mi":["Y","X"]}}}}}},{"@attributes":{"id":"MATH-US-00003-2","num":"00003.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Z","mo":"=","mrow":{"mi":"Height","mo":"\u00b7","mrow":{"mi":"sin","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03b8"}}}}}},{"@attributes":{"id":"MATH-US-00003-3","num":"00003.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"P","mo":"=","mrow":{"mi":"Z","mo":"\u00b7","mrow":{"mi":"cos","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03b8"}}}}}},{"@attributes":{"id":"MATH-US-00003-4","num":"00003.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Q","mo":"=","mrow":{"mi":"Z","mo":"\u00b7","mrow":{"mi":"sin","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"\u03b8"}}}}}},{"@attributes":{"id":"MATH-US-00003-5","num":"00003.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"P","mo":"=","mrow":{"mi":"Height","mo":["\u00b7","\u00b7"],"mrow":[{"mi":"cos","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"arctan","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mi":["Y","X"]}}}}},{"mi":"sin","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"arctan","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mi":["Y","X"]}}}}}]}}}},{"@attributes":{"id":"MATH-US-00003-6","num":"00003.6"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Q","mo":"=","mrow":{"mi":"Height","mo":"\u00b7","mrow":{"msup":{"mi":"sin","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"arctan","mo":"\u2061","mrow":{"mo":["(",")"],"mfrac":{"mi":["Y","X"]}}}}}}}}}]},{"@attributes":{"id":"p-0083","num":"0096"},"figref":"FIG. 22","b":["1","2","1","1"]},"The direction in which a gradient fill travels can be described by any one of four directions. These directions are named after the alignment of the points that make up the fill-paths within a gradient fill. The four directions are defined as follows:\n\n",{"@attributes":{"id":"p-0085","num":"0102"},"figref":"FIGS. 23A to 23D"},"There are two different types of height that are referred to in the description, rectangle-height (or the height of a fill-path) and total-height. The total-height is defined as the sum of the individual rectangle heights of each of the fill-paths in the currently stored list of fill-paths. The side of the fill-path that defines the rectangle-height of a gradient fill is dependent on which direction the gradient fill is travelling.  show that for a direction of DIR_ the rectangle-height is defined as the length of the line between point  and point  of a fill-path. For a direction of DIR_ the rectangle-height is defined as the length of the line between point  and point . For a direction of DIR_ the rectangle-height is defined as the length of the line between point  and point . For a direction of DIR_, the rectangle-height is defined as the length of the line between point  and point . Also, it will become apparent that the fill-path heights may differ from fill-path to fill-path. The widths of each of the fill-paths is also shown in .","The term \u201cstored color gradient\u201d is defined as the color gradient between the most recently added fill-path and the second most recently added fill-path in the currently stored gradient fill. The value of this color gradient is stored so that any new fill-paths can be checked to ensure that its color gradient is within a reasonable limit of the stored color gradient.","The currently stored gradient fill is a dynamic list of fill-paths. For each of the fill-paths added to the currently stored gradient fill, 3 arrays are defined by the method as follows:\n\n","The phrase \u201cstored gradient fill\u201d refers to the variables necessary for describing the gradient fill currently being tracked. This includes the aforementioned color array, point array and heights array, the number of fills in the gradient fill, the direction of the gradient fill, and the color gradient between the first two colors in the gradient fill.","2.0 Overview","The method receives in turn the fill-paths from the GDI layer and adds those paths to the currently stored gradient fill depending upon certain criteria being met. Initially, the method checks whether the difference in color between a newly received fill-path and the fill-path that was most recently added to the currently stored gradient fill is greater than a reasonably large error factor. Preferably, this error factor is 2 times the difference in color between the 2 most recently added fill-paths of the currently stored gradient fill. Specifically, the method checks, for each color channel (e.g. RGB) of the image being generated, whether a color channel value Cof the newly received fill-path satisfies one of the following formulae:\n\n0\u22662() if C\n\n\u22122()\u2266\u22660 if \u2003\u2003Equation (1)\n\n","If the check returns true for each color channel, the method adds the newly received fill-path to the currently stored gradient fill and repeats these operations for the next received fill-path. Otherwise, if the check returns false for any one of the color channels, then the method undertakes to generate one or more linear blends from the color and position of the first fill-path of the currently stored gradient fill to the color and position of the most recently added fill-path of the currently stored gradient fill. In other words, the method continues adding fill-paths to the currently stored gradient fill until a fill-path is reached that no longer satisfies the aforementioned criteria. This occurs when one of the color channels for the next fill-path causes a significant change in direction for the current color channel's gradient. For example, this will occur when the direction of the color gradient changes sign.","As mentioned previously, if the check returns false, the method undertakes to generate one or more linear blends from the fill-paths already added to the currently stored gradient fill Specifically, the method determines an optimal set of linear blends fitting the set of fill-paths in the currently stored gradient fill. The method achieves this in the following manner.","Firstly, for the purposes of explanation, it is assumed that the currently stored gradient fill contains n fill-paths denoted as fill-path[] through to fill-path[n], where fill-path[] is the first fill-path added to the currently stored gradient fill and fill-path[n] is the last fill-path added to the currently stored gradient fill.","The method generates the set of linear blends fitting the fill-paths of currently stored gradient fill by first testing whether the color gradients between fill-path[] and fill-path[n] are not equal to the corresponding color gradients between fill-path[] and mid-point fill-path[n\/2] (within some acceptable error). If the test returns true, that is, if it is not equal, then the method then partitions the set of fill-paths into 2 sets, one for the first half of the fill-paths (fill-path[] . . . fill-path[n\/2]) and one for the second half of the fill-paths (fill-path[n\/2] . . . fill-path[n]) and repeats the test for each of these new sets of fill-paths. On the other hand, if the test returns false, that is the color gradients between fill-path[] and fill-path[n] are equal (within some acceptable error) to the corresponding color gradients between fill-path[] and fill-path[n\/2] for some set of fill-paths[ . . . n], then the method outputs a linear ramp call to the graphics rendering system for this set of fill-paths[ . . . n], using the colors array to define the start and end colors of the linear ramp, and the points array to define the area to be filled. This step can be implemented as a software module, which can-be defined recursively as:","Function find_and_put_ramps(C[ . . . n], H[ . . . n], P[ . . . n])",{"@attributes":{"id":"p-0095","num":"0116"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mrow":[{"mn":"1.","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}},"mi":"If"},{"mo":">","msub":{"mi":"E","mn":"0"}}],"mo":["\u2062","|","|"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mfrac":{"mrow":{"msub":[{"mi":["G","n"]},{"mi":"G","mrow":{"mi":"n","mo":"\/","mn":"2"}}],"mo":"-"},"msub":{"mi":["G","n"]}}},{"mi":["for","any","one","color","channel","where"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"1.1em","height":"1.1ex"}}}]},{"msub":{"mi":"G","mrow":{"mi":"n","mo":"\/","mn":"2"}},"mo":"=","mfrac":{"mrow":[{"msub":[{"mi":"C","mrow":{"mi":"n","mo":"\/","mn":"2"}},{"mi":"C","mn":"1"}],"mo":"-"},{"msub":[{"mi":"H","mrow":{"mi":"n","mo":"\/","mn":"2"}},{"mi":"H","mn":"1"}],"mo":"-"}]}},{"msub":{"mi":["G","n"]},"mo":"=","mfrac":{"mrow":[{"msub":[{"mi":["C","n"]},{"mi":"C","mn":"1"}],"mo":"-"},{"msub":[{"mi":["H","n"]},{"mi":"H","mn":"1"}],"mo":"-"}]}}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"1.9em","height":"1.9ex"}}},{"mtext":{}},{"mspace":{"@attributes":{"width":"1.9em","height":"1.9ex"}}},{"mtext":{}},{"mspace":{"@attributes":{"width":"1.9em","height":"1.9ex"}}},{"mtext":{}},{"mspace":{"@attributes":{"width":"1.9em","height":"1.9ex"}}}]}},{"mrow":{"mi":"Equation","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mo":["(",")"],"mn":"2"}}}]}}}}},"H, Hare the values of the accumulated rectangle-heights of fillpaths  to n and  to n\/2 respectively,","Cis the value of the color channel of the n-th fill-path,","Eis a threshold constant, preferably 0.1, and","where Cand Hare the values of the color channel and rectangle height respectively of the first fill-path in the set [ . . . n] passed to the function.\n\n","As can be seen, the method when partitioning the set of fill-paths, preferably uses the fill-path at the midpoint as both the end point of the first ramp and the start point of the second ramp. This ensures a smooth blend between adjacent linear ramps and eliminates Mach Banding when compared to previous implementations. Alternatively, traditional partitioning based upon (n\/2) and (n\/2)+1 may be used.","Turning now to , there is shown the values of a color channel of an exemplary set of fill-paths added to the currently stored gradient fill for the purposes of illustrating the method of generating one or more linear blends.  illustrate the color values in the y co-ordinate direction of the fill-paths  to , which are depicted in the x co-ordinate direction. The symbol C represents the value of the color channel of a fill-path, whereas the symbol H represents the value of the accumulated height, e.g total-height, of all the stored fillpaths. For simplicity, there is assumed to be only one color channel. As will be apparent, the fill-paths  . . .  are added to the currently stored gradient fill in turn, until the fill-path  is received from the GDI layer. As can be seen this fill-path  fails the criteria set out in Equation (1), and is not added to the currently stored gradient fill. The method then generates one or more linear blends from the fill-paths  . . .  already stored in the currently stored gradient fill in the following manner.","The preferred method compares the color gradient between fill-paths  . . .  with the color gradient between fill-paths  . . .  in accordance with Equation (2). This comparison also ensures that n is not below a predefined value. For the sake of simplicity this is ignored in this example. This comparision is illustrated in . The output of this comparision is in this case greater than the threshold constant E=0.1, so the method divides the set of fill-paths[ . . . ] into 2 sets: fill-paths[ . . . ] and fill-paths[ . . . ].","The method then compares the color gradient between fill-paths  . . .  with the color gradient between fill-paths  to  in accordance with Equation (2). Note, where n is odd, the value n\/2 is incremented to the next nearest highest integer, which in this case is three (3). This comparision is illustrated in . The output of this comparison is in this case less than the threshold constant E=0.1, so a linear blend is output for fill-paths  to .","The method then compares the color gradient between fill-paths  to  with the color gradient between fill-paths  to , in accordance with Equation (2). Note, in this particular case the first fill-path in the set is fill-path  and the gradients are measured from this fill-path. This comparision is illustrated in . The output of this comparison is in this case greater than the threshold constant E=0.1, so the method divides the set of fill-paths[ . . . ] into 2 sets: fill-paths[ . . . ] and fill-paths[ . . . ].","The method then compares the color gradient between fill-paths  to  with the color gradient between fill-paths  to  in accordance with Equation (2). This comparision is illustrated in . The output of this comparison is in this case less than the threshold constant E=0.1, so a linear blend is output for  to . In a similar fashion, the method determines the color gradient between fill-paths  and  is similar to the color gradient between fill-paths  and , so a linear blend is output for fill-paths  and . The method then terminates.","As can be seen, the method breaks the whole stored gradient fill into pieces depending on the linearity of the overall gradient fill and not simply those portions that have been processed to date. This ensures that the entire gradient fill is considered when determining the optimal set of linear blends, thus ensuring the best possible match is made to the original gradient fill with the least number of linear ramps. This method identifies the larger constant slopes within a gradient fill and outputs them accordingly. In this way, the method enables the reduction of the number of graphic objects needed to be rendered. Furthermore, Mach Banding is avoided by setting the midpoint of the partitioning as both the endpoint of the first ramp and the start point of the second ramp.","As mentioned previously, the method receives in-turn the fill-paths from the GDI layer and adds these to the currently stored gradient fill depending on whether the newly recieved fill-path meets the criteria as set out in Equation (1). In the case where this criteria is not met, the newly received fill-path is not stored in the currently stored gradient fill and the method then processes the already existing fill-paths in the currently stored gradient fill to produce one or more linear blends. Preferably, the newly received fill-path should also meet a number of other criteria in addition to the criteria specified in Equation(1) before it is added to the currently stored gradient fill. For example, the rectangle-height of the newly received fill-path should be less than or equal to two times the rectangle-height of the first fill-path in the currently stored gradient fill in order for the newly received fill-path to be added to the currently stored gradient fill. Otherwise, if the newly received fill-path is added to the currently stored gradient fill, then discontinuities in the blend will become apparent to the eye. Further criteria will be described below in more detail.","3.0 First Method","Turning now to , there is shown a flow chart of a method  of generating one or more linear blends. As mentioned previously, the method  is implemented as a software module for execution on a processor of a general-purpose computer. Such a general-purpose computer suitable for implementing the preferred method is described below with reference to . The software module is preferably a part of a first stage of a graphics rendering system that interfaces to a graphics device interface (GDI) layer and receives graphics objects for a page, converting each graphics object to an intermediate edge-based format. In the second stage of the graphics rendering system, the job is rendered and the resulting pixels are output to a downstream device, such as a printer or graphics card. Preferably, both stages of the graphics rendering system are implemented as a graphics rendering software application for execution on the processor of the computer. Any known graphics rendering software application would be suitable, with appropriate modifications for interfacing with the software module implementing the method .","The method  commences operation at step  when it is called by the first stage of the graphics rendering system. The method  is called when the graphics rendering system receives a new graphics object from the GDI layer. After this step , the method  then inputs at step  the graphics object currently being passed to the graphics rendering system. The method  also during this step  checks whether the currently received graphic object is a fill-path. If this step  determines that the currently received graphic object is not a fill-path, then the method  proceeds to step , where a sub-process named flush_ramp  is called. The sub-process flush-ramp  processes any fill-paths already stored in the currently stored gradient fill to produce one or more linear blends, which are then passed to the graphics rendering system. After the generation of the linear blends, the flush_ramp sub-process  empties the stored gradient fill. This sub-process flush_ramp  will be described in more detail below with reference to .","After completion of step , the method  terminates  and returns to the first stage of the graphics rendering system a message SKIP, which tells it that the currently received object is not a valid fill-path. The first stage of the graphics rendering system then tries to convert this fill-path to an edge based format if possible, otherwise the object is skipped and the system proceeds to the next object. As will be apparent from the foregoing, the currently received graphic object is not a valid fill-path and need not be pre-processed by the method  before conversion to an intermediate edge based format.","Otherwise, if the step  determines that the currently received graphic object is a fill-path, the method  proceeds to step . The method  in step  checks whether the currently received fill-path has the basic properties needed to form a gradient fill. In particular, step  tests whether the currently received fill-path: has one side that is at least smaller than a predefined configurable maximum size; is being filled with a flat color; contains 4 points that define a parallelogram; and does not use a raster operation that requires a destination. If the currently received fill-path meets these criteria then, the method  proceeds to step . Otherwise, if the fill-path does not meet the criteria then the method  proceeds to step , where a sub-process named flush_ramp  is called.","The method  then checks at step  whether the number of fill-paths in the currently stored gradient fill is currently zero. If the method  determines that currently stored gradient fill contains zero fill-paths, then the method  proceeds to step . During step , the method  initializes a new gradient fill by adding the currently received fill-path to the currently empty stored gradient fill. The height of the fill-path is not yet known because a direction has not yet been determined. A direction is defined when a second fill-path is received, this means the height for the first fill-path can only be added when a second fill-path is determined to be part of a gradient fill with the first fill-path. The height for the first fill-path is added to the stored gradient fill during an add_rect sub-process , called at step . Otherwise, if the number of fill-paths in the currently stored gradient are greater than zero, then the method  proceeds to step .","The method  in step  calls a sub-process named check_fill  to determine whether the currently received fill-path should be added to the currently stored gradient fill. The check_fill sub-process  returns true if the fill-path is to be added to the currently stored gradient fill, otherwise it returns false, if it is not to be added. This check_fill sub-process  is described below in detail with reference to .","After completion of step , the method  proceeds to step , which determines whether a true or false has been returned by the check_fill sub-process . If the step  determines a true has been returned, the method  proceeds to step  where the currently received fill-path is added to the currently stored gradient fill. The method  during step  calls the sub-process named add_rect  in order to add the currently received fill-path to the currently stored gradient fill. This sub-process add_rect  is described below in more detail with reference to . Otherwise if a false has been returned, the method  proceeds to step .","The method  during step  calls the aforementioned sub-process flush_ramp  for processing the currently stored gradient fill. After the completion of step , the method  then proceeds to step , where a new gradient fill is initialized by adding the currently received fill-path to the currently empty stored gradient fill.","After completion of steps  or  the method  terminates . When the method  terminates, it returns a parameter OK to the first stage of the graphics rendering system, telling that it does not need to convert and pass the fill-path on to the second stage of the graphics rendering system.","3.1 add_rect Sub-Process","Turning now to , there is shown a flow chart of the add_rect sub-process  called by the method  of . This add_rect sub-process  is responsible for adding a new fill-path to the currently stored gradient fill, which already contains one or more fill-paths. The add_rect sub-process   commences at step  when it is called by step  () of the method . Step  also passes to this add_rect sub-process  the currently received fill-path for adding to the currently stored gradient fill.","After step , the add_rect sub-process  proceeds to step , where the number of fill-paths in the currently stored gradient fill is checked. If this step  reveals there is only one fill-path in the currently stored gradient fill then the add_rect sub-process  proceeds to step , where the direction of the fill of the currently received fill-path is determined (eg. VDOWNRIGHT). This is achieved by calling a sub-process named get_alignment . This get_alignment sub-process  will be described in more detail below with reference to . Otherwise, if there are more than one fill-path in the currently stored gradient fill, the add_rect sub-process  proceeds directly to step .","After the direction of the fill has been determined in step , the add_rect sub-process  proceeds to step . In step , a switch statement is used to separate the directions into horizontal (HDOWNRIGHT, HUPRIGHT, HDOWNLEFT, or HUPLEFT) and vertical (VDOWNRIGHT, VUPRIGHT, VDOWNLEFT, or VUPLEFT) ramps. If the ramp is a horizontal ramp then step  is performed where the rectangle-height of the first fill-path in the currently stored gradient fill and the received fill-path is defined by the x-plane (see ). The height of the first fill-path is then stored in the currently stored gradient fill. Otherwise if the ramp is vertical, then step  is performed where the rectangle-height of the first fill-path in the currently stored gradient fill and the currently received fill-path is defined by the y-plane (see ). The height of the first fill-path is then stored in the currently stored gradient fill.","After the completion of steps , or  the add_rect sub-process  proceeds to step , where the accumulated height of this fill-path and all the previous fill-paths, if any, is stored in the heights array. The color of the currently received fill-path is added to the color array, and the number of fills is also incremented. The point array is also updated to hold the points of the currently received fill-path. After completion of step , the add_rect sub-process  terminates at step  and returns to step  of the method .","3.2 check_fill Sub-Process","Turning now to , there is shown a flow chart of the check_fill sub-process  called by step  of the method  of . This check_fill sub-process  is responsible for checking whether the currently received fill-path is suitable for adding to the currently stored gradient fill. The check_fill sub-process  commences at step  when it is called by step  () of the method . Step  also passes to this check_fill sub-process  the currently received fill-path.","After step , the check_fill sub-process  proceeds to step . The check_fill sub-process  at step  calculates the difference (i.e. C-C) between the color of the currently received fill-path and the color of most recently added fill-path to the currently stored gradient fill for each of the RGBA\/CMYK (depending on the color space used) color values. The color of the most recently added fill-path in the stored gradient fill is the color stored in the last position of the color array. After completion of step , the check_fill sub-process  proceeds to step .","The check_fill sub-process  during step  first tests to see if there is only one fill-path stored in the current gradient fill. Secondly, it tests that the currently received fill-path is aligned with the currently stored gradient fill. Thirdly, it tests if the fill-path in the currently stored gradient fill together the currently received fill-path will look correct by calling a sub-process named check_output_fill . Fourthly and lastly, it tests if the new fill-path has the same clipping region and raster operation as the previously added fill-paths in the currently stored gradient fill. This check_output_fill sub-process  is described below in more detail with reference to . If all these tests are met in the affirmative the check_fill sub-process  then proceeds to step . Otherwise, if any one of these tests are not met, then the check_fill sub-process  proceeds to step . It should be noted that the check_fill sub-process  evaluates each one of the tests in turn and if a test is not met in the affirmative then the check_fill sub-process  immediately proceeds to step  without evaluating the following tests. For example, if there is only one fill-path in the currently stored gradient fill, and the fill is aligned, then the first and second tests are met and third test then calls the check_output_fill sub-process . On the other hand for example, if there are more than one fill-paths in the currently stored gradient fill, then the check_fill sub-process  immediately proceeds to step  without evaluating the subsequent tests. Thus the check_output_fill sub-process  is only called when there is a currently received fill-path which is properly aligned and the stored gradient fill contains only one fill-path.","The check_fill sub-process  during step  then checks if the heights of the first two fill-paths are similar. Preferably, it checks this similarity by testing whether the rectangle-height of the currently received fill-path is no greater than two times the rectangle-height of the fill-path in the currently stored gradient fill. It should be noted that during step , there is only one fill-path in the currently stored gradient fill. If the test reveals the heights are similar, the check_fill sub-process  proceeds to step . Otherwise if the test reveals that the two heights are not similar then the check_fill sub-process  terminates  and returns FALSE to step  of the method , indicating that the currently received fill-path should not be added to the currently stored gradient fill.","The check_fill sub-process  during step  stores the color gradients of the two fill-paths that were calculated during step . After step , the check_fill sub-process  terminates  and returns TRUE to step  of the method , so that the method  will then add  the new fill-path to the stored gradient fill (which only contains one fill-path at this moment).","On the other hand, if any one of requirements are not met in step , the check_fill sub-process  proceeds to step . The check_fill sub-process  in step  then checks to see if the currently received fill-path is a suitable candidate to be added to the currently stored gradient fill. The step  does this by checking to ensure that:","1. The number of fills in the currently stored gradient fill is greater than ;","2. The sum of the accumulated height in the currently stored gradient fill and the rectangle-height of the currently received fill-path is less than a predefined maximum. This predefined maximum can be set to such a value, so that the fill does not extend beyond the page;","3. The color gradient between the currently received fill-path and the most recently added fill-path in the currently stored gradient fill-path has the same sign and is similar to the stored gradient. The gradient is checked for each of the color indices within the color space used (eg. if the color space is RGBA, each of the indicies R, G, B, and are all checked for consistency). Preferably, it checks to ensure that the color channel value C, for each color channel, of the currently received fill-path satisfies one of the relations of Equation (1) noted above.","4. The currently received fill-path is aligned correctly with the fill-paths in currently stored gradient fill;","5. The currently received fill-path is similar in height (rectangle-height) to the most recently added fill-path in the currently stored gradient fill. Preferably, it checks this similarity by testing whether the rectangle-height of the currently received fill-path is no greater than two times the rectangle-height of the first fill-path in the currently stored gradient fill.","6. The raster operation for the currently received fill-path is the same as the raster operation for the stored gradient fill.","7. The currently received fill-path has the same clip as the stored gradient fill.","If the step  determines that the currently received fill-path passes all the aforementioned checks  to , then the check_fill sub-process  then terminates  and returns TRUE to step  of the method , so that the method  will then add  the new fill-path to the currently stored gradient fill. Otherwise, if any one of these checks  to  fail, the sub-process check_fill  terminates at step  and returns FALSE to step  of the method , so that it does not add the currently received fill-path to the currently stored gradient fill.","3.3 check_output_fill Sub-Process","Turning now to , there is shown a flow chart of the check_outputfill sub-process  called by step  of the check_fill sub-process  of . This check_output_fill sub-process  is responsible for determining that the single fill-path in currently stored gradient fill and the currently received fill-path are suitable for creating a gradient fill. The check_output_fill sub-process  commences at step  when it is called by step  () of the check_fill sub-process . Step  also passes during step  to this check_output_fill sub-process  the currently received fill-path.","After step , the check_output fill sub-process  proceeds to step . The check_output_fill sub-process  firstly during step  calculates the absolute value of the color difference between the color of the currently received fill-path and the single fill-path in the currently stored gradient fill for each one of the color channels (eg. red, green, blue and alpha). The check_output_fill sub-process  then during step  determines and stores that one of the calculated absolute values of color differences that has the highest value (herein after called the maximum color gradient). After completion of step , the check_output_fill sub-process  proceeds to step .","The check_output_fill sub-process  during step  checks whether the maximum color gradient (calculated during step ) is less than a predefined maximum. Preferably, the predefined maximum is . if the check  reveals that it is less than the predefined maximum then the check_output_fill sub-process  terminates  and returns TRUE to step  of the check_fill sub-process  (). This tells the check_fill process  () that the gradient fill should be created. On the other hand if the check  reveals that the maximum color gradient is larger than or equal to the predefined maximum, then the check_output_fill sub-process  proceeds to . In the latter case it is still possible that the gradient fill should be created, that is, if the height of the individual fill-paths is very small, and this is determined during steps -.","The check_output_fill sub-process  in step  calls the sub-process named get_alignment  to determine the alignment of the fill-paths. This get_alignment sub-process  returns to the check_output_fill sub-process  the alignment (eg. VDOWNLEFT) of the currently received fill-path and the single fill-path in the currently stored gradient fill. Alter the termination of the get_alignment sub-process  called in step , the check_output_fill sub-process  proceeds to step .","The check_output_fill sub-process  in step  checks the alignment returned by step . If the check  reveals that the direction is not defined at all, that is the get_alignment sub-process  returns NONE, then the check_output_fill sub-process  terminates  and returns FALSE to step  of the check_fill sub-process  indicating that a gradient fill should not be created. If the check  reveals the direction is horizontal, that is the get_alignment sub-process  returns HDOWNLEFT, HUPLEFT, HDOWNRIGHT, or HUPRIGHT, then the check_output_fill sub-process  proceeds to step . Otherwise, if the check  reveals the direction is vertical, that is the get_alignment sub-process  returns VDOWNLEFT, VUPLEFT, VDOWNRIGHT, or VUPRIGHT, then the check_output_fill sub-process  proceeds to step .","The check_output_fill sub-process  during step  sets the rectangle-height of the currently received fill-path to the length of the side of the parallelogram that proceeds in the x co-ordinate direction (See ). On the other hand, the check_output_fill sub-process  during step  sets the rectangle-height of the currently received fill-path to the length of the side of the parallelogram that proceeds in the y co-ordinate direction (See ). After completion of steps  or , the check_output_fill sub-process  proceeds to step .","The check_output_fill sub-process  then in step  checks if the rectangle-height, calculated in step  or , to see if it is below some predefined maximum height and greater than zero. If the check  reveals that it is not then the check_output_fill sub-process  terminates  and returns FALSE to step  of the calling check_fill sub-process . Thus indicating a gradient fill should not be created. On the other hand, if the check  reveals that it is less than the predefined maximum height and greater than zero then the check_output_fill sub-process  terminates  and returns TRUE to step  of the calling check_fill sub-process . Thus indicating that the two fill-paths, that is the currently received fill-path and the single fill-path in the currently stored gradient fill, are potentially suitable for creating a gradient fill.","3.4 get_alignment Sub-Process","Turning now to , there is shown a flow chart of the get_alignment sub-process  called by the add_rect , check_fill , and check_output_fill  sub-processes of , , and  respectively. This get_alignment sub-process  is responsible for determining the direction of the gradient presently comprising the single fill-path in the currently stored gradient fill and the currently received fill-path. The get alignment sub-process  commences at step  when it is called either by step  () of the check_fill sub-process , step  () of the add_rect sub-process , or step  () of the check_output_fill sub-process . These steps , , and  passes during step  to this get_alignment sub-process  the currently received fill-path.","After completion of step , the get_alignment sub-process  proceeds to step , where the get_alignment sub-process  checks whether the currently received fill-path is rectangle. If the check  reveals the currently received fill-path is a rectangle then the get_alignment sub-process  proceeds to step . The get_alignment sub-process  in step  checks whether the currently received fill-path and the single fill-path in the currently stored gradient fill are aligned in the x-plane. If the check  reveals that they are aligned in the x-plane, the get_alignment sub-process  proceeds to step . On the other hand, if the check  reveals that they are not aligned in the x-plane the get_alignment sub-process  proceeds to step .","The get_alignment sub-process  in step  checks whether the currently received fill-path is joined on the top side of the single fill-path in the currently stored gradient fill. If the check  returns TRUE (yes), then the get_alignment sub-process  terminates  and returns the direction UP to its calling sub-process. On the other hand, if the check  returns FALSE (no), then the get_alignment sub-process  proceeds to step .","The get_alignment sub-process  in step  checks whether the currently received fill-path is joined on the bottom side of the single fill-path in the currently stored gradient fill. If the check  returns TRUE (yes), then the get alignment sub-process  terminates  and returns the direction DOWN to its calling sub-process. On the other hand, if the check  returns FALSE (no), then the get_alignment sub-process  terminates  and returns the direction NONE to its calling sub-process. It will be apparent in the latter case the fill-paths are not joined indicating there is no blend.","The get_alignment sub-process  in step  checks whether the currently received fill-path is joined on the left side of the single fill-path in the currently stored gradient fill. If the check  returns TRUE (yes), then the get_alignment sub-process  terminates  and returns the direction LEFT to its calling sub-process. On the other hand, if the check  returns FALSE (no), then the get_alignment sub-process  proceeds to step .","The get_alignment sub-process  in step  checks whether the currently received fill-path is joined on the right side of the single fill-path in the currently stored gradient fill. If the check  returns TRUE (yes), then the get_alignment sub-process  terminates  and returns the direction RIGHT to its calling sub-process. On the other hand, if the check  returns FALSE (no), then the get_alignment sub-process  terminates  and returns the direction NONE to its calling sub-process. It will be apparent in the latter case the fill-paths are not joined indicating there is no blend.","On the other hand if the check  reveals that the currently received fill-path is not a rectangle, then the get_alignment sub-process  proceeds to step . In step , the currently received fill-path and the single fill-path in the currently stored gradient fill are checked to see if their point's .y align. If so, then the gradient fill will be a horizontal type fill (), and the get_alignment sub-process  proceeds to step . Otherwise, the gradient fill will be a vertical type fill (), and the get_alignment sub-process  proceeds to step .","The get_alignment sub-process  at step  checks the single fill-path in the currently stored gradient fill to see if its point .x is less than its point .x in the x-plane. If this is so, then the fill is either HDOWNRIGHT, HUPRIGHT, or NONE ( or ) and the get_alignment sub-process  proceeds to step . In step , the get_alignment sub-process  checks whether point  of the fill-path of the currently stored gradient fill is located near the top bound of the bounding rectangle. If this is so, then the fill is deemed to be an HDOWNRIGHT fill, see  and the get_alignment sub-process  terminates  and returns HDOWNRIGHT to its calling step. Otherwise the get_alignment sub-process  proceeds to step . The get_alignment sub-process  then checks in step  whether point  of the fill-path of the currently stored gradient fill is located near the bottom bound of the bounding rectangle. If this is so, the fill is deemed to be an HUPRIGHT fill (see ) and the get_alignment sub-process  terminates  and returns HUPRIGHT to its calling step. Otherwise the fill is deemed not to have a direction, ie. NONE and the get_alignment sub-process  terminates and returns the value NONE to its calling step.","On the other hand, if the get_alignment sub-process  at step  determines that point .x of the single fill-path in the currently stored gradient fill is greater than or equal to its point .x in the x-plane, then the get alignment sub-process  proceeds to step . The get_alignment sub-process  at step  checks whether the point  of the single fill-path in the currently stored gradient fill is greater than its point  in the x-plane. If not then the fill is deemed to have no direction (viz NONE) and the get alignment sub-process  terminates  and returns the value NONE to its calling step. Otherwise the get_alignment sub-process  proceeds to step .","The get_alignment sub-process  in step , checks whether point .y of the single fill-path in the currently stored gradient fill is located near the top bound of the bounding rectangle in the y plane. If this is not so, then this fill is deemed to be an HUPLEFT () and the get_alignment sub-process  terminates  and returns the value HUPLEFT to its calling step. Otherwise, the get alignment sub-process  proceeds to step . The get_alignment sub-process  in step , checks whether point .y of the single fill-path in the currently stored gradient fill is located near the bottom bound of the bounding rectangle in the y plane. If this is so, then the fill is, deemed to be an HDOWNLEFT fill, (see ), and the get_alignment sub-process  terminates  and returns the value HDOWNLEFT to its calling step. Otherwise, the fill is deemed to have no direction (NONE) and the get_alignment sub-process  terminates  and returns the value NONE to its calling step.","The get_alignment sub-process  in step  checks to see if the currently received fill-path and the stored fill-path in the currently stored gradient fill have the same x value for point . If this is not true then the fill-paths are not aligned and don't form a gradient fill and the get_alignment sub-process  terminates and returns the value NONE to its calling step. Otherwise, the get_alignment sub-process  proceeds to step .","The get_alignment sub-process  in step  tests whether point  of the stored fill-path in the currently stored gradient fill is less than point  of the same fill-path in the y-plane. If this is true then the fill is either a VDOWNLEFT or VDOWNRIGHT, (refer to ) and the get_alignment sub-process  proceeds to step .","The get_alignment sub-process  in step  checks to see if point  of the stored fill-path in the currently stored gradient fill is located near to the right side of the bounding rectangle. If this is true then the fill is deemed to be VDOWNLEFT\u2014see  and the get_alignment sub-process  terminates  and returns the value VDOWNLEFT to its calling step. Otherwise, the get_alignment sub-process  proceeds to step .","The get_alignment sub-process  in step  checks to see if point  of the stored fill-path in the currently stored gradient fill is located near the left side of the bounding box. If this is true then the fill is deemed to be VDOWNRIGHT\u2014see , and the get_alignment sub-process  terminates  and returns the value VDOWNRIGHT to its calling step. Otherwise, the fill-paths are deemed not to be aligned, and the get_alignment sub-process  terminates  and returns the value NONE to its calling step.","Otherwise if step  returns false (No), then the get_alignment sub-process  proceeds to step  The get_alignment sub-process  in step  tests whether point  of the stored fill-path in the currently stored gradient fill is greater than point  (in the y-plane) of the same fill-path. If it is not the fill-paths are deemed not to be aligned and the get_alignment sub-process  terminates  and returns the value NONE to its calling step. Otherwise, the get_alignment sub-process  proceeds to step .","The get_alignment sub-process  in step , tests whether point  of the single fill-path stored in the currently stored gradient fill to see if it is located near to the right side of the bounding rectangle. If this is true the fill is deemed to be VUPLEFT\u2014see  and the get_alignment sub-process  terminates  and returns the value VUPLEFT to its calling step. Otherwise, the get_alignment sub-process  proceeds to step .","The get_alignment sub-process  in step  tests whether the point  of fill-path in the currently stored gradient fill to see if it is located near the left side of the bounding box. If this is true, then the fill is deemed to be an VUPRIGHT, see , and the get_alignment sub-process  terminates  and returns the value VUPRIGHT to its calling step. Otherwise the fill-paths are deemed not to be aligned, and the get_alignment sub-process  terminates  and returns the value NONE to its calling step.","As can been seen, at any stage the alignment or non-alignment has been determined then the alignment is simply returned to the calling sub-process.","3.5 flush_ramp Sub-Process","Turning now to , there is shown a flow chart of the flush_ramp sub-process  called by steps  and  of method . This flush_ramp sub-process  is primarily responsible for flushing the currently stored gradient fill. The flush_ramp sub-process  commences at step  when it is called by steps  and  () of the method . After commencement , the flush_ramp sub-process  proceeds to step .","The flush_ramp sub-process  at step  checks the number of fill-paths in the currently stored gradient fill. If the check  reveals that there is no fill-paths then the flush_ramp  terminates  and returns to the calling step  or  as any gradient fill has already been flushed. Otherwise, if the check  reveals that there is 1 or more fill-paths in the currently stored gradient fill, the flush_ramp sub-process  proceeds to step .","The flush_ramp sub-process  in step  again checks the number of fills in the currently stored gradient fill. This time if the check  reveals that the number of fills is one then the flush_ramp sub-process  proceeds to step . In step , a call is made to an external function draw_flat in the first stage of the graphics rendering system for converting the single fill-path to an edge based format. After completion of step , the flush_ramp sub-process  proceeds to step . On the other hand, if the check  reveals that the number of fill-paths in the currently stored gradient fill is greater than one then the find_and_put_ramps function  is called in step . The find_and_put_ramps function  is responsible for partitioning the currently stored gradient fill into a number of optimal linear blends and outputting these to the first stage of the graphics rendering system for conversion to an edge based format. The find_and_put_ramps function  is described below in more detail with reference to . After completion of the find_and_put_ramps function  in step , the flush_ramp sub-process  proceeds to step .","The flush_ramp sub-process  in step  then flushes any fill-paths in the currently stored gradient fill and resets the variable numfills to zero. After completion of step  the flush_ramp sub-process  terminates and returns to the calling step  or  of the method  ().","3.6 find_and_put_ramps Sub-Process","Turning now to , there is shown a flow chart of the find_and_put_ramps sub-process , which is initially called by step  of the flush_ramp sub-process  of . The find_and_put_ramps function  is responsible for partitioning the currently stored gradient fill into a number of optimal linear blends and outputting these to the first stage of the graphics rendering system for conversion to an edge based format. The find_and_put_ramps sub-process  is a recursive sub-process as will become apparent from the description below. The find_and_put_ramps sub-process  commences at step , where it takes as input the color, point and heights arrays of a set of fill-paths of the currently stored gradient fill-path. When the find_and_put_ramps sub-process  is initially called by step  of the flush_ramp process  (), the color, point and heights arrays of the complete set of fill-paths in the currently stored gradient fill are passed to the find_and_put_ramps sub-process . For sake of explanation, the complete set of fill-paths are denoted as fill-paths[ . . . n], and their respective color, point and height arrays as C[ . . . n], points[ . . . n], and H[ . . . n] respectively.","After commencement , the find_and_put_ramps sub-process  proceeds to step . The find_and_put_ramps sub-process  in step  then checks whether the color gradient of the first half of the set of fill-paths [ . . . n] is not similar to the color gradient of the entire set of fill-paths [ . . . n] (eg. red, green, blue and alpha channels for an RGBA flat color) in accordance with Equation (2) mentioned above. The step  also checks whether n is not below a predefined minimum, which minimum is preferably set to 5 or a number of similar order of magnitude. If the check  reveals the color gradients are not similar, that is fail to meet the requirements of Equation (2), and n is not below some predefined threshold, then the find_and_put_ramps sub-process proceeds  to step . Otherwise, the find_and_put_ramps sub-process  proceeds to step .","The find_and_put_ramps sub-process  in step  calculates the total-height depending on the direction of the fill, and calculates the two points necessary to define the points for which the gradient fill is to be applied. These two points need to be calculated such that the gradient fill can be applied in the correct direction, refer to . The first point is always defined as point one of the stored fill-path points. The second point, (Q, P), is found by using the total-height and the formula shown in , depending on whether the gradient fill is a horizontal or vertical type.","The find_and_put_ramps sub-process  in step  again calls in turn the find_and_put_ramps sub-process  for each one of these new two sets of arrays (C[ . . . n\/2], H[ . . . n\/2], P[ . . . n\/2]) and (C[n\/2 . . . n], H[n\/2 . . . n], P[n\/2 . . . n]). After completion of step , the find_and_put_ramps sub-process  terminates  and the method  returns to step of  of the flush-ramp sub-process  ().","The find_and_put_ramps sub-process  in step  calculates the total-height depending on the direction of the fill, and calculates the two points necessary to define the points for which the gradient fill is to be applied. These two points need to be calculated such that the gradient fill can be applied in the correct direction, refer to . The first point is always defined as point one of the stored fill-path points. The second point, (Q, P), is found by using the total-height and the formula shown in , depending on whether the gradient fill is a horizontal or vertical type.","After completion of step , find_and_put_ramps sub-process  proceeds to step . During step , a call is made to an external function draw_blend for generating and outputting to the graphics rendering system a linear blend using these two points determined in step , the starting color, and color gradient per color channel per pixel. Any known function for generating a linear blend would be suitable. After completion of step , the find_and_put_ramps sub-process  terminates and returns to its calling step  or .","The aforementioned method  and sub-processes comprise a particular control flow. There are other variants of the method , which use different control flows without departing the spirit of the invention. Furthermore one or more of the steps of the method  may be performed in parallel rather sequential.","4.0 Alternate Method","An alternate method of generating a linear blend may be performed by modifying the method , described above, in the manner shown in . This alternate method derives primarily from substantial simplification of the get_alignment sub-process and consequential modifications to some of the other sub-processes. In the following description, those method steps and processes that are common with steps and processes previously described are indicated using the same reference numeral.","As seen in , the alternate method  has an entry point  which passes to steps , ,  and  each of which operate in the manner previously described. A \u201cNo\u201d result from step  invokes a step  to check the gradient fill. The step  calls a modified_check_fill sub-process  seen in . The sub-process  has an entry point  which passes to step  which operates as before and passes to a decision step .","The modified_check_fill sub-process , during the decision step  first tests to see if there is only one fill-path stored in the current gradient fill. Secondly, it tests that the currently received fill-path is aligned with the currently stored gradient fill by calling an alternate_get_alignment sub-process  described below with reference to . Thirdly, it tests if the fill-path in the currently stored gradient fill together with the currently received fill-path will look correct by calling a modification to the check_output_fill flowchart of . Although the modification is not separately illustrated, such will be apparent from the following description and . In the modification, if the check  of  reveals that the maximum color gradient is larger than or equal to predefined maximum (ie. No), the present modification of the check_output fill sub-process directly terminates at  and returns a FALSE to step  of the modified_check_fill sub-process  (). In this modified implementation, steps , , ,  and  of  are completely omitted. This tells the modified_check_fill process  () that the gradient fill should not be created. The decision step  finally checks if the clip and the raster operation (ROP) for the currently received fill-path are the same as the fill-paths stored in the currently stored gradient fill. Clip objects contain a unique identifier that can be used to check for a consistent clip. This unique identifier is set by the GDI layer. Clipping regions that use the same area as the fill-path themselves are treated as a NULL clip.","The remaining steps ,  and  of the modified_check_fill sub-process  of  correspond to those described with respect to , which need not be repeated, and return via step  to step  of .","When the alternate_get_alignment sub-process  is called, process passes to an entry point  seen in .","In step  a side is picked to be the \u201cchosen_side\u201d. The chosen side is based on the points that make up the fill-path. Both the new fill-path and stored fill-path have the same chosen side at any one time. In this regard, the chosen side may be defined as the side that lies between point  and point  of a fill-path. Since no direction has yet been determined, the width is assumed to be the length of the chosen side, and the height as the length of the sides adjacent to the chosen side. If, in step , a chosen_side has already been assigned within this sub-process then a next side is assigned to be the chosen_side. No side is assigned to be the chosen_side more than once within any one call to the sub-process .","Step  then checks to see if the width of the newly received fill-path is the same as the width of the stored fill-path and that the slopes of these widths are similar. It is often found that two adjacent fill-paths are not exactly the same. There are definable tolerances within the algorithm to allow slight differences in the widths and lengths of a new fill-path compared to the first fill-path. The widths and heights of a particular fill-path are calculated using the individual x and y components of the points that make up a fill-path. The tolerance used in these calculations is preferably \u00b1one pixel for the individual x and y components, but is easily changed depending on the requirements of the system. This tolerance is also used in testing the similarity of slopes. Step  proceeds to check that the height of the new fill-path is equal or no more than two times the height of the first stored fill-path. If the heights are sufficiently similar, step  then proceeds to step , otherwise step  proceeds.","Step  then checks to see if the side opposite the chosen side of the newly received fill-path is coincident or overlaps the chosen side of the stored fill-path. To be a legitimate overlap, the full width of both the new fill-path and the stored fill-path must overlap. There is a configurable tolerance used in the determination of such an overlap, preferably in the order of \u00b1one pixel in the x and or y direction. An overlap is also only valid if the overlap height is less than half the height of the last fill-path in the currently stored gradient fill. Separate fill-paths that do not touch each other are not considered coincident or overlapping even if they are within the aforementioned tolerance levels. If the sides are coincident or overlap then a direction can be defined and step  proceeds. Otherwise if the sides do not coincide or overlap then a direction cannot be determined and step  proceeds to step .","In step , a direction is assigned to the currently stored linear ramp. The direction is based on the current chosen side. If the chosen side is  then the direction is DIR_, if the chosen side is  then the direction is DIR_, if the chosen side is  then the direction is DIR_ and of the chosen side is  then the direction is DIR_. The sub-process then terminates  and then returns the appropriate direction to the calling step .","In step , if all four sides have been picked as the chosen side, then all possible alignments have been exhausted and a direction cannot be assigned to the fill-paths, DIR_NONE is returned  to the calling step . If all four sides have not been exhausted then the algorithm proceeds to step .","After step , the alternate method  in step  checks if the modified_check_fill sub-process  has returned True. If not, steps  and  operate as previously described. If so, step  follows and a fill-path is added using a modified_add_rect sub-process  of . The sub-process  may be used for either of the methods  or . The sub-process  has an entry point  which passes to step  which operates as previously described. Where the number of fills is one (ie. Yes) step  follows where the height of the fill is determined directly from the direction of the fill, as seen in . This substantially simplifies the process previously performed in steps , ,  and  (see ).","After step , step  follows where the height of the first fill-path is determined and stored in the height array. If not, step  follows, as it does after step . The modified_add_rect sub-process  then returns at step  to the main method of , which then returns a parameter OK to the first stage of the graphics rendering system, telling that it does not need to convert and pass the fill-path on to the second stage of the graphics rendering system.","In operation of the alternate method  of , as before, the steps  and  call the flush-ramp sub-process  which, in turn, calls the find_and_put_ramps sub-process . Step  of the sub-process  as previously mentioned operates to define the direction of blend using two points. In the alternate method , those two points need to be calculated such that the gradient fill can be applied in the correct direction, as seen in . The first point chosen depends on the directions in which the gradient fill is travelling. If the fill has a direction of DIR_ then the first point chosen is point  of the first fill-path in the stored gradient fill. If the fill has a direction of DIR_ then the first point chosen is point  of the first fill-path in the stored gradient fill. If the fill has a direction of DIR_ then the first point chosen is point  of the first fill-path in the stored gradient fill. If the fill has a direction of DIR_ then the first point chosen is point  of the first fill-path in the stored gradient fill.","The second point chosen is determined by finding the intersection of Line B and Line C, this is shown as Point  (Q, P) in . Line B is the line perpendicular to Line A that passes through the first point of the gradient fill. Line A is the line that passes through the first point of the gradient fill and runs parallel to the width of the first fill-path in the stored gradient fill. Line C is the line runs parallel to the width of the stored fill-paths and passes through the second point that is described in the direction of the gradient fill (eg. for a DIR_ gradient fill, Line C would pass through point  of the last fill-path). For gradient fills that travel horizontally or vertically, the second point of the gradient fill is simply the second point described in the direction of the fill of the last fill-path in the stored gradient fill. for example, for a direction of DIR_, the second point of the gradient fill is point  of the last fill-path in the stored gradient fill.","5.0 Preferred Apparatus","The method of generating one or more linear blends is preferably practiced using a general-purpose computer system , such as that shown in  or , wherein the process may be implemented as software, such as an application program executing within the computer system . In particular, the steps of method of generating one or more linear blends are effected by instructions in the software that are carried out by the computer. The instructions may be formed as one or more code modules, each for performing one or more particular tasks. The software may also be divided into a number of separate parts, in which one part performs the method of generating one or more linear blends and another part manages a user interface between the first part and the user. The software may be stored in a computer readable medium, including the storage devices described below, for example. The software is loaded into the computer from the computer readable medium, and then executed by the computer. A computer readable medium having such software or computer program recorded on it is a computer program product. The use of the computer program product in the computer preferably effects an advantageous apparatus for generating one or more linear blends.","The computer system  is formed by a computer module , input devices such as a keyboard  and mouse , output devices including a printer , a display device  and loudspeakers . A Modulator-Demodulator (Modem) transceiver device  is used by the computer module  for communicating to and from a communications network , for example connectable via a telephone line  or other functional medium. The modem  can be used to obtain access to the Internet, and other network systems, such as a Local Area Network (LAN) or a Wide Area Network (WAN), and may be incorporated into the computer module  in some implementations.","The computer module  typically includes at least one processor unit , and a memory unit , for example formed from semiconductor random access memory (RAM) and read only memory (ROM). The module  also includes an number of input\/output (I\/O) interfaces including an audio-video interface  that couples to the video display  and loudspeakers , an I\/O interface  for the keyboard  and mouse  and optionally a joystick (not illustrated), and an interface  for the modem  and printer . In some implementations, the modem  may be, incorporated within the computer module , for example within the interface . A storage device  is provided and typically includes a hard disk drive  and a floppy disk drive . A magnetic tape drive (not illustrated) may also be used. A CD-ROM drive  is typically provided as a non-volatile source of data. The components  to  of the computer module , typically communicate via an interconnected bus  and in a manner which results in a conventional mode of operation of the computer system  known to those in the relevant art. Examples of computers on which the described arrangements can be practiced include IBM-PC's and compatibles, Sun Sparcstations or alike computer systems evolved therefrom.","Typically, the application program is resident on the hard disk drive  and read and controlled in its execution by the processor . Intermediate storage of the program and any data fetched from the network  may be accomplished using the semiconductor memory , possibly in concert with the hard disk drive . In some instances, the application program may be supplied to the user encoded on a CD-ROM or floppy disk and read via the corresponding drive  or , or alternatively may be read by the user from the network  via the modem device . Still further, the software can also be loaded into the computer system  from other computer readable media. The term \u201ccomputer readable medium\u201d as used herein refers to any storage or transmission medium that participates in providing instructions and\/or data to the computer system  for execution and\/or processing. Examples of storage media include floppy disks, magnetic tape, CD-ROM, a hard disk drive, a ROM or integrated circuit, a magneto-optical disk, or a computer readable card such as a PCMCIA card and the like, whether or not such devices are internal or external of the computer module . Examples of transmission media include radio or infra-red transmission channels as well as a network connection to another computer or networked device, and the Internet or Intranets including e-mail transmissions and information recorded on Websites and the like.","The method of generating one or linear blends may alternatively be implemented in dedicated hardware such as one or more integrated circuits performing the functions or sub functions of generating one or more linear blends. Such dedicated hardware may form part of graphics rendering system.","It is apparent from the above that the arrangements described are applicable to the computer graphics and printing industries.","The foregoing describes only some embodiments of the present invention, and modifications and\/or changes can be made thereto without departing from the scope and spirit of the invention, the embodiments being illustrative and not restrictive."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["One or more embodiments of the present invention will now be described with reference to the drawings, in which:",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2A","b":"210"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 2B","FIG. 2A"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 2C","FIG. 2B"]},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 4C","FIG. 4A","FIG. 4B"]},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIGS. 5A to 5D","b":["6","6"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIGS. 7A and 7B"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIGS. 8A and 8B"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIGS. 9A","b":["9","9"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":["FIG. 12","FIG. 10"]},{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 13","FIG. 12"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIGS. 14A","FIGS. 11"],"b":["14","14","12","13"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 15","FIG. 10"]},{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 16","FIG. 15"]},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 19","FIG. 10","FIG. 18"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 20","FIG. 18"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 21","FIG. 18"]},{"@attributes":{"id":"p-0058","num":"0057"},"figref":["FIG. 22","FIGS. 8A and 8B","FIG. 18"]},{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIGS. 23A to 23D","FIGS. 5A to 5D","FIG. 18"],"b":["6","6"]}]},"DETDESC":[{},{}]}
