---
title: Modeling system for retrieving and displaying data from multiple sources
abstract: A model development system provides tools for developers to define reusable, object oriented components and views for collecting and displaying data from multiple sources, and for incorporating such reusable components and views into an informational model. Using the system, a developer can create a reusable component, create multiple instances of that component, and connect each such instance to one or more corresponding back-end data sources. The developer can also define one or more associated views that specify how data collected by the component from the back-end data sources is to be displayed. Many different components and views may be defined and deployed to build an informational model of a business entity, such as a business that operates processing or manufacturing plants in various locations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07069514&OS=07069514&RS=07069514
owner: IndX Software Corp.
number: 07069514
owner_city: Aliso Viejo
owner_country: US
publication_date: 20031203
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["This application is a continuation of U.S. patent application Ser. No. 09\/704,471, filed Nov. 1, 2000, now U.S. Pat. No. 6,700,590, which claims the priority date of U.S. provisional patent application No. 60\/162,975, filed Nov. 1, 1999, which is hereby incorporated by reference.","1. Field of the Invention","The present invention relates to collecting, modeling, and providing access to information.","2. Description of the Related Art","A number of attempts have been made to retrieve data from a business organization's various data sources (called back-end data sources) and to present that data to users. An organization's various back-end data sources may contain different types and formats of data, including relational data, point data, time-series data, and object data. Relational data comprise data from multiple tables of multiple fields. The tables may be related to each other through indexes. Point data is single-type data typically associated with manufacturing systems. For example, a data system may continuously collect a motor's operating speed and operating temperature as point data. Unlike relational data, point data typically are not comprised of multiple tables. Time-series data are data that store the change in data value over time. Object data are data represented by objects. The concepts of object, object-oriented design, object-oriented programming and object-oriented databases are known to those skilled in the art.","Data warehouse products and more custom database approaches typically collect data from back-end data sources and deposit the data into a new data warehouse (or data mart) for data analysis and presentation. Some data mining processes operate on data warehouses to provide detailed analysis such as marketing and sales trends, and to test hypotheses such as customer buying patterns. However, those analyses are usually only available to a few analysts and executives in an organization. In addition, a data warehouse usually stores historical data for long term analysis, but is not suitable for real time or near real time applications.","Application packages such as Intellution Dynamics Package by Intellution, Inc. of Foxborough, Mass. and In Touch by Wonderware Corporation of Irvine, Calif. provide for visualization of plant operational data in some manufacturing systems. These packages have very limited abilities to retrieve and present relational data typically associated with other manufacturing systems and non-manufacturing systems such as enterprise resource planning (ERP) systems. Typically, the major limitations include an inability to monitor relational data as it changes over time, navigate the relational data for more detailed monitoring or status, and to find supporting details. Because they do not provide access to both point data and relational data, enterprises often have to use multiple systems to provide data visualization, navigation and analysis of various types and formats of data. Using multiple systems often results in high financial and computing expenses and programming and administrative complexity.","Some systems convert back-end data into relational data stored in a relational database for selection, analysis and visual presentation. Such a relational database typically needs to be managed by a database administrator in order to handle the complexity of a relational database comprising multiple tables and indexes. This is especially true when data has to be converted and acquired from different back-end systems. In addition, those systems cannot utilize the advantages of object data.","Some systems convert point data and relational data from back-end data sources into point data to present to users. Since the back-end data are converted into point data, those systems cannot utilize the advantages of object data and also lose any benefits associated with relational data.","Other systems convert back-end data into object data, but fail to provide access to the object data using a class-based representation model. What is needed is a system and method providing access to back-end data in object form, in real time, and using a class-based component and view model.","One aspect of the invention involves the use of a class-based component and view model to collect and display data from multiple sources. The class-based component and view model is preferably embodied within a system that uses reusable components and views to monitor the operation of a business entity, such as but not limited to a business entity that has manufacturing facilities or plants in various locations. The data that is collected and displayed by the system may, for example, include relational data, point data and\/or time-series data. The system also preferably includes development tools for creating and deploying the reusable components and views to generate an information model for monitoring the business entity.","To generate a model in a preferred embodiment, reusable components are initially defined for each type of business element or data source to be monitored. For example, a \u201cplant\u201d component may be generated that represents the general structure of a manufacturing or processing plant, and a \u201cpump\u201d component may be generated to represent a type of pump. A given component may include one or more other components as members. For example, if each plant within the business entity includes multiple pumps, the associated plant component may include multiple pump components. The task of generating the reusable components is performed in the preferred embodiment using a component builder tool.","In addition to defining reusable components, one or more reusable views may be defined for a given component to specify how data collected by that component is to be displayed. Each such view is generally a graphical representation of a corresponding component, and may include graphs, charts, animations, and\/or other types of graphical elements to represent the associated data collected by that component. If a first component is a member of a second component, a first view associated with the first component may optionally be inserted into a second view associated with the second component, such that the first view is automatically displayed as a subset of the second view. The task of generating the reusable views is performed in the preferred embodiment using a view builder tool.","The system preferably allows multiple views to be defined for the same component, and thus allows users or developers to build different views of varying levels of detail corresponding to the same component. This is advantageous because different people within a business organization may demand different views that connect to the same data. For example, a plant foreman may want views that show the operating temperature, speed and production numbers of machines. The plant supervisor may want views that show the production numbers of machines. The company executive may want views that show the production totals of each plant. Some prefer to have data displayed in tables while others prefer charts.","Once one or more reusable components and associated views have been generated, a solution builder tool may be used to generate an informational model or \u201csolution\u201d for a business entity. This task involves creating instances of specific components, and connecting these instances to respective back end data sources. For example, if a given business entity has physical plants in Chicago, Milwaukee and Cleveland, three separate instances of the \u201cplant\u201d component may be created, one for each physical plant. Each such component instance would also be connected to the corresponding back end data source or sources (point data sources, databases, etc.) associated with its respective physical plant. As part of this process, different data collection frequencies and other data connection parameters may be specified for different instances of the same component. The task of creating a solution from a set of preexisting components can advantageously be performed by a person having little or no knowledge of the structure of the associated components. If changes are made to a particular component or its view(s) over time, the changes may be propagated automatically to all instances of the associated component.","The solution or model may be navigated in the preferred embodiment using a navigation tree in which each instance of each component is represented by a respective node or icon within an expandable tree. Using the navigation tree, a user can select a node (component instance) and view the associated data collected by that instance. If multiple views have been defined for an associated component (e.g., basic view, detailed view, etc.), the user can also select between these alternative views. In one embodiment, users can access the navigation tree using an ordinary web browser.","Neither this summary nor the following detailed description purports to define the invention. The invention is defined by the claims.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 1","b":["100","102","104","106","100","200"]},"The application environment  comprises an enterprise server , a web server , and one or more solution servers . The application environment  is connected to a development environment . The development environment  comprises one or more development clients . In the preferred embodiment, the enterprise server, solution servers and development clients comprise application programs in Java and\/or C++ and running under Windows NT.","The application environment  is connected to a browsing environment . The browsing environment  comprises one or more browsing terminals . Each browsing terminal  comprises a communication program such as a web browser. In the preferred embodiment the browsing terminals  are connected to the application environment  through the Internet using web browsers such as Netscape Communicator or Internet Explorer launched from the browsing terminals . In another embodiment, the browsing terminals  are connected to the application environment  through an Intranet.","The system provides options for a developer or user to specify the frequency at which data is to be fetched from the back-end environment  into the application environment . If data were fetched too frequently, it would be a waste on system resources and may adversely affect system performance. On the other hand, if the data were not fetched frequently enough, a user could end up viewing data that is unacceptably out-dated. By fine-tuning the fetching frequency, a developer or user can ensure that users view data that is sufficiently timely. The system and method for specifying the data fetch frequencies are known to those skilled in the art.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":["FIG. 2","FIG. 2"],"b":["200","201","206","210"]},"The enterprise server  comprises a component table  that stores component definitions. A component is a reusable software resource that contains and represents the information associated with a data source, such as a business entity. Thus, for example, a component may represent a customer, a shipping route, or a credit check process. A component can represent a collection, for example, yesterday's customer orders from a back-end relational database. By using components to represent business elements, the system facilitates user understanding in terms of the business process. A component is made up of one or more members. Each member can be a number, a date, a text string, a Boolean logical value, or another component. For example, a \u201ccustomer\u201d component may be comprised of members such as name, identification number and address. A run-time usage of a component is called a component instance. When a component is reused, a unique instance of that component is created, with a unique name. Different instances of the same component can follow different instructions on where, when, how and how often to retrieve back-end data.","For each component represented in the component table , the component table  also stores definitions of views associated with that component. By storing all component and view definitions on the enterprise server , the system ensures that all developers and users across the enterprise can utilize and inherit the same component and view definitions. The enterprise server  also comprises a solution table  that stores the names, descriptions and locations of solutions, and a connector table  that stores the name, description and configuration code of all connectors. The connection process configurations are stored in the solution servers  in the connection processes module. The connection processes that execute commands to acquire component instance data and global collection data from back-end data sources are located on the solution servers . A solution is a component instance with a defined connection to a back-end data. A connector comprises program code for connecting a component instance or a global collection to a back-end data source. A global collection represents multiple instances of the same class of data, such as \u201call orders,\u201d \u201call customers,\u201d or \u201call customers from the East Region.\u201d","The web server  comprises an animation module  which displays views with animation effects and manages user interaction with the views, a trend module  which displays trends of component instance data change as data change over time, a navigation module  which manages the tree-structure navigation of views, and a support module  which supports data communication between the application environment  and the browsing environment . In one embodiment, the animation module , the trend module , the navigation module  and the support module  comprise one or more Java applets. The web server  also comprises a router  as the data communication gateway between the browsing terminals  and the application environment .","The solution server  comprises an object storage , a time-series historian , a component instance table , a connection group table  and a connection processes module . The object storage  receives data from the back-end data environment  and stores such data. The object storage  stores some objects in memory and commits other objects to disk to allow for storing large quantities of data. Those of ordinary skill will appreciate that objects may be stored entirely in memory or on disk or on other media, and the present invention is not limited by the type of media used to store objects.","Even if users want the same data, the data only needs to be retrieved from the back-end environment  once, and can then be transmitted from the object storage  to one or many users who request it. Since the data are stored directly in memory or disk, and not in a relational database, the data administration task is typically simpler than a relational database.","The time-series historian  is a database preferably optimized for storing time-centric data. The time series historian  stores time-stamped data values received from the back-end data environment . The time-series historian  can be an independent third-party product or can be custom-designed. It will be appreciated by those of ordinary skill that a flat file system or database may be used to implement the time-series historian .","The component instance table  stores the connection configurations for each component instance within the solution held by that solution server . The connection configurations comprise a connection group to connect to the back-end data, or a program command to select a subset of a global collection, as described in connection with .","A connection group comprises a connection process and a connector. A connection process is the program command that starts the execution of the connector. The connection group table  stores connection groups.","The connection processes module  comprises a table storing connection processes and their respective locations. The connection processes module  uses connection processes to retrieve data from the back-end data environment , and sends the retrieved data to the object storage . If a user or developer selects, for example, in the solution builder , an option to store data in time-series historian, the connection processes module  sends the retrieved data to the time-series historian  for storing.","The development client  comprises a catalog application , a component builder , a view builder , a solution builder , and a connector builder . Components and views are created or modified within the development client  and sent to the enterprise server  to be stored in the component table . The catalog application  is an interface that includes and provides access to a list of components. Each component is represented by a component name and an icon. When a developer or user selects a component from the list for modification or starts to create a new component, the developer\/user is directed from the catalog application  to the component builder . The component builder  allows a developer or user to create and edit components.","When a developer\/user selects a component from the catalog application , the developer\/user may select the menu option \u201ccreate new view\u201d to create a new view for that component, or may select the menu option \u201cedit view\u201d to edit a view for that component. The developer\/user will then be directed from the catalog application  to the view builder . The view builder  allows a developer or user to create and edit views to attach to existing components.","The solution builder  allows a developer or user to create or modify a solution, and to specify how to connect the solution to back-end data sources. In one embodiment, the present invention supports Microsoft's Dynamic Data Exchange (DDE) protocol and Microsoft's Open Database Connectivity (ODBC) application programming interface for connecting to back-end data sources. An example screen display of one embodiment of the solution builder  is shown in , with a solution tree shown on the left hand side. Another example screen display is shown in , which shows how a user of the solution builder  can select from a list of views that are available for a selected component instance to view data collected by that instance.","The connector builder  allows a developer or user to add, modify or delete a connector. A connector is the program code that connects to back-end data. The created or modified connector definitions are transmitted from the connector builder  to the enterprise server  and stored in the connector table . Each connector has an associated connector type such as ODBC, DDE, Oracle or MS-SQL.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 3","FIG. 3"],"b":["402","404","406","408","410","404","412","414","416","418"]},"The tree style display and navigation structure is preferred because it is visually intuitive. A tree branch may comprise sub-branches, as a component may comprise member components. However, solutions may also be displayed using other presentation and navigation structures. Programming controls, such as the Visual Basic Tree View control, are known to those of ordinary skill, and can be used to generate navigable displays representing hierarchical relationships between objects by a visual arrangement of labels and\/or icons associated with represented objects. See, for example, Microsoft Visual Basic\u2014Professional Features, Microsoft Corp., 1995.","At run time, a solution represents an instance of a corresponding component. A developer or user can define and modify the run-time attributes of a solution component instance, such as name, description, and connection characteristics. Such connection characteristics may include what data sources to connect to, when to connect, the program code or system command to connect to a data source and retrieve data, and how frequently to retrieve data. When one or more components that make up a solution have been changed, i.e., when members are added to, modified, or deleted from a component, or the name or icon of the component has been changed, a developer or user may update the solution through a menu option. This action updates the solution to include the latest changes to the components.","A node \u201cglobal collections\u201d and a sub-node \u201ccustomers\u201d are displayed at the bottom of the solution tree in . The global collection section will be described in connection with .",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 4","b":["100","200","206","100","206","240","100","232","248","234","234"]},"The object storage  receives and stores relational data and point data. Point data is retrieved by the connection processes module  from the back-end data environment  to the object storage , when a view corresponding to such point data is displayed on a browsing terminal . This run-time retrieval of point data retrieves only the set or subset of point data that is requested by the displaying view, and only when requested.","Relational data and other collection data are retrieved by the connection processes module  from the back-end data environment , to the object storage , when a solution connects such relational data to the solution using a connection group. A solution can also connect to back-end data by selecting a subset of a global collection that connects to back-end data. In one embodiment, a process connected to the relational data source in the back-end data environment  automatically detects changes and sends changes to the back-end data as change records to the object storage  and the recorded changes are applied to the data in the object storage . This method of applying changes reduces the quantity of data needed to be retrieved from the back-end data environment . In another embodiment, the back-end data environment  does not create change records, and data from the back-end data environment are transmitted to the object storage  according to the data retrieval frequency specified in the connection group.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 5","FIG. 16"],"b":["302","204","302","204","252","254","256","258","204","302","302","202","206","302","210"]},"The router  is the data communication gateway between the browsing terminals  and the application environment . The router  retrieves view definitions and component definitions from the component table  in the enterprise server . Data and component instances requested by the browsing terminals  are transmitted from the solution servers  through the router  to the browsing terminals .","A user\/developer can use the animation module  to pick a data display field within a view, and select a \u201cshow trend\u201d option to display the change of data over time for the component member represented by that data display field. The trend module  then provides a graphic representation of data change over time for the component member. Historical data is retrieved from the time-series historian  or the back-end time-series historian.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 6","b":["242","244","502","504"]},"The user\/developer is then prompted to define members of the component. The user\/developer is prompted to define the name of the member in step , and to select the data type of the member in step . The data type can be a primitive type such as integer, decimal number, Boolean logical value, text string or date, or an existing component. An example screen display illustrating the process of adding an existing component as a member is shown in . The user\/developer continues adding members to the component, until he\/she indicates at step  that all members have been added. In the preferred embodiment the user\/developer makes this indication by selecting a \u201csave component definition\u201d menu option. In step  the client development client  updates the catalog application  to include the name and icon of the new component. In step  the development client  also sends the new component definition to the component table  in the enterprise server . In another embodiment, the user or developer starts the process of creating a component in the component builder .",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 7"},"Once a global collection is created, a component member can be connected to back-end data as all or a subset of the global collection. For example, once a global collection of \u201call customers\u201d is created and its connection to back-end data defined, a component of \u201cactive customers\u201d can be connected to back-end data as a subset of the global collection. Components of \u201cinactive customers\u201d or \u201cpreferred customers\u201d can also be connected as a subset of the global collection. An example screen display illustrating the process of connecting a collection component to the global collection \u201cCustomers\u201d is shown in . Relational data records with multiple fields may be designated collection members. Members representing programmatic data, i.e, data structures returned from API (Application Programming Interface) calls, can also be designated collection members. In this specification, the term \u201crelational data\u201d comprises data structures returned from API calls.","In step , a user or developer selects a menu option of \u201ccreate global collection\u201d in the solution builder , and enters a name for the global collection. The user\/developer is then prompted in step  to select a component from a list of existing components to correspond to the new global collection. This defines the type of data that is associated with and managed by the global collection. The user\/developer is then prompted in step  to select a connection group from a list of existing connection groups to connect the global connection to back-end data. For example, an \u201cOracle\u201d connection group connects to a back-end Oracle database, and an \u201cMS-SQL\u201d connection group connects to a Microsoft SQL database.","In step , the user\/developer addresses the new global collection. Addressing a global collection provides information needed to acquire the desired collection data from the back-end environment . The user\/developer enters program commands and configurations to associate the members of the selected component with back-end data items. In one embodiment, the user\/developer addresses the new global collection by entering a query statement specifying the back-end data items to select data from, and maps the specified back-end data items to the members of the selected component. In step  the solution builder  updates the global collection list. In the preferred embodiment the updated global collection list is displayed at the bottom of the solution tree.","Connecting a component as a subset of an already defined global collection typically requires less technical skill than connecting a component directly to back-end data. Therefore, the method of creating a global collection first, then connecting components as a subset of the created global collection eases the technical burden on users and developers. Once the global collection is defined correctly, users or developers who connect components as a subset of the global collection will not connect the components to the wrong back-end data sources. The word \u201csubset,\u201d as used in the specification and the claims, comprises \u201ca part of\u201d and \u201call of.\u201d",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 8","b":["602","248","604","606","248"]},"In one embodiment, steps  through  are preformed using a system administration module. When an object model has been created and displayed as a solution tree, a user or developer proceeds from step  within the solution builder . In step  a user or developer selects a component represented by a node on the solution tree, and selects the \u201ccreate solution\u201d option to connect back-end data (i.e., a back end data source) to an instance of the selected component. The user\/developer is prompted in step  to select a member of the selected component for connecting to back-end data. In step  the user\/developer determines whether to designate the selected member as a collection data member.","If the selected member is designated a collection data member, then the user\/developer is prompted in step  to select a global collection from a list of existing global collections. The user\/developer is then prompted in step  to filter the selected global collection, by selecting a subset of said global collection. For example, for a component member \u201cactive customers,\u201d the user\/developer selects a global collection \u201call customers,\u201d and in one embodiment selects a subset of the global collection by entering program code \u201cselect from all-customers where customer-status=active.\u201d If the selected member is not designated a collection data member then the user\/developer connects the member to back-end data by selecting a connection group from a list of existing connection groups in step , and then addressing the member in step . The user\/developer addresses the selected member in step  by specifying the back-end data item that the member corresponds to.","In step , if the user\/developer indicates he\/she has completed connecting members to back-end data, then the solution builder  proceeds to step . Otherwise the solution builder  returns to step  to select another member for connection. In step  the solution builder  transmits the solution definition to the enterprise server  and solution server . The connection specification for each component member of the solution is stored in the component instance table , and the name and description of the solution are stored in the solution table .","As indicated above, a developer or user may specify a solution's connection to back-end data sources through connection groups, each comprising a connection process. Each connection process comprises the program command to execute a connector. Connectors can be independent third party packages or custom programmed for the system. One embodiment uses a connector toolkit developed by the applicant that allows developers to build connectors in Java, and optionally in C or C++. A developer or user can create different connection groups that use the same connector. For example, one connection group connects to production data for last year; another connection group connects to production data for the current month, contained in the same back-end data source. One connection group may scan for data at a frequency of every second, while another connection group may scan for data, using the same connector, at a frequency of every minute. The system allows a user or developer to specify the data scanning frequency. A connection group acquires back-end data using a connection process, which comprises the program command for running a connector. An example screen display showing a connection tab screen of the solution builder  is shown in .","The solution builder  allows a user or developer to add, modify or delete a connection process. To add a connection process, the user\/developer selects the option \u201cadd a connection process,\u201d and is prompted to enter a name and description for the new connection process. The user\/developer is then prompted to enter a program command for the connection process. A developer typically performs the task of entering a program command.","The solution builder  also allows a user or developer to add, modify or delete a connection group. To add a connection group, the user\/developer selects the option \u201cadd a connection group,\u201d and is prompted to enter a name and description for the new connection group. The user\/developer is then prompted to select a connection process from a list of connection processes and a connector type from a list of connector types. A connector type is the type of a connector defined in the connector builder . The selected connection process is the connection process that corresponds to the new connection group. In one embodiment, the user\/developer is then allowed to specify the data scanning frequency of the connection group.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":"FIG. 9","b":["702","242","246","704","704"]},"In step , the user\/developer is prompted to select a graphic tool. Graphic representations are created using graphic tools, which comprise tools for drawing tables, charts, lines, animations, etc. The view builder  has a set of drawing tools for presenting titles, charts, tables, backgrounds graphics, and other graphical elements. The view builder  also allows a developer or user to create and edit animations. Animation characteristics, such as fill color and size, change based on fluctuations in back-end data. Animations contain references to component members that are linked through a solution to collect data from back-end data sources. The view builder  also allows the creation and editing of views as web hyperlinks to URLs (Uniform Resource Locators). In one embodiment, the user or developer starts the process of creating a view from the view builder .","If the user\/developer selects a view-in-view tool, i.e. a tool for inserting a view inside a view, then step  proceeds to step . If the selected tool is not a tool for inserting a view inside a view, then step  proceeds to step . A view-in-view tool allows a user\/developer to insert, within a view representing a component, a sub-view representing a component member of that component at a location determined by the user\/developer. An example view builder screen display illustrating the process of inserting one view into another view is shown in .","In step  the user\/developer creates graphic representation using the selected tool. The graphic representation may comprise an animation. The graphic representation also may comprise program commands for associating data values with the graphic effects. For example, a user\/developer can use the selected graphic tool to represent a \u201cpump temperature\u201d field as a blue rectangle, and enter a program command to fill the rectangle with red color or flashing red color when temperature exceed five hundred degrees. The user\/developer then is directed to step .","If the user\/developer selects a view-in-view tool, then in step  the user\/developer is prompted to select a member of the selected component. Since a view representing the selected member is to be inserted to the newly created view representing the selected component, the selected member is a component itself. In one embodiment the user\/developer is prompted to select from a list of component members of the selected component. The user\/developer is prompted to select a view from the existing views of the member component, in step . The user\/developer uses the view-in-view tool to place the selected member view inside the newly created component view.","The view builder  then determines in step  if the selected member is designated as a collection member. If the selected member is a collection member, then the user\/developer is prompted in step  to determine the number of views to be displayed for the collection member. In one embodiment the user\/developer is prompted to enter the number of rows and columns to be displayed for the collection member.","In step , the user\/developer can opt to return to step  to continue preparation of the graphic representation of the selected component. If the user\/developer indicates that the view is complete, the view builder  transmits the created view definition to enterprise server  to be stored in the component table  (step ).","In one embodiment, a default view is defined for each component that has one or more views associated with the component. When a component has no corresponding views, the first view created for that component is defined as the default view. When a component has one or more corresponding views, a user\/developer can define the default view by selecting the component in the catalog application  and entering a \u201cupdate component\u2014update default view\u201d option. This embodiment can be achieved by having a \u201cdefault view? Yes or No\u201d logical field within the view definition, or by having a \u201cdefault view\u201d field within the component definition containing the name of the default view. When a view representing a component having a component member is displayed, the sub-view representing the component member is also displayed. When a user\/developer selects the sub-view, preferably by highlighting or double-clicking with a mouse, the default view representing the component member is displayed. For example, within a view representing a plant operation is displayed a view representing a motor. When the view representing the motor is selected, the default view representing the motor is displayed, which is typically a detailed view of the motor. A user\/developer is thus allowed to \u201cdrill down\u201d to further details. A user\/developer can also select another view of the component member, preferably by right-clicking on the sub-view to bring up a list of views corresponding to the component member and selecting one of the views from the list.","At run time, data is retrieved through connections defined in a solution, and displayed using a view associated with the component that is associated with the solution.","The provisional application on which this application is based, including its attached \u201cIndx XHQ User's Guide,\u201d is hereby incorporated into the specification.","Although the foregoing has been a description and illustration of specific embodiments of the invention, various modifications and changes can be made thereto by persons skilled in the art without departing from the scope and spirit of the invention as defined by the following claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":["FIG. 10","FIG. 2"]},{"@attributes":{"id":"p-0029","num":"0028"},"figref":["FIG. 11","FIG. 2"]},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 15","FIG. 2"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 16"}]},"DETDESC":[{},{}]}
