---
title: Scalable fine-grained multi-service authorization
abstract: A scalable cross-protocol mechanism is provided for describing, transmitting and checking large lists of authorizations for operations on network resources. At an authorization server, data is stored that represents operations that can be performed on a plurality of resources of a service provider at the request of one or more users. A set of {resource,operations} tuples is generated, wherein a resource describes an endpoint for a network service and operations is a list of operations that are authorized on an endpoint. The set of {resource,operations} tuples is partitioned into one or more subsets. A subset of the set of {resource,operations} tuples is combined into a string according to a predetermined rule. A hash is then computed, according to a hash function, to generate hash results. Hashes are passed instead of the lists themselves to minimize data transfer and latency.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08925043&OS=08925043&RS=08925043
owner: Cisco Technology, Inc.
number: 08925043
owner_city: San Jose
owner_country: US
publication_date: 20120710
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DESCRIPTION OF EXAMPLE EMBODIMENTS","Overview","Example Embodiments"],"p":["The present disclosure relates to providing authorized access to software services.","When running a large Software-as-a-Service (SaaS) provider, there are often many services created by disparate teams running over different network protocols that need to appear as a coherent set of products\/services to customers, partners, and the larger developer community that will use that set of subservices as a platform. A primary challenge for some SaaS providers is obtaining a centralized identity service, so that there is one user name and authentication mechanism (e.g., password) that works across all of the subservices. Once a user is identified, the next hurdle is to determine which, if any, services the user is authorized to access.","Several authorization systems that have been built in the past assume that if a user can access the service, there are a very fixed set of static permissions for which pieces of the service the user is entitled to use. This approach does not always work well, particularly for enterprises which prefer very fine-grained control over which users can use each feature of a service. Often, these enterprises like to use groups or roles to assign similar permissions to sets of users.","For security reasons, authorization decisions are performed server-side, since client applications are under control of untrusted parties, perhaps having been written entirely by untrusted parties in a fully-realized developer community scenario. However, clients often want to know what operations they are allowed to perform, so that they can disable or remove the portions of the user experience that the user is not allowed to access, rather than waiting for the user to try something that is going to fail.","In many enterprises, there are hundreds of millions of users and thousands of servers. With aggressive virtualization, services may be distributed across hundreds of thousands of servers. Therefore, complex, tightly-coupled, or centralized processing is best kept to a minimum. In particular, on the server side, the latency requirement dictates that processing can be simplified and calls to other internal services can be kept to a minimum.","A scalable cross-protocol mechanism is provided for describing, transmitting and checking large lists of authorizations for operations on network resources. At an authorization server, data is stored that represents operations that can be performed on a plurality of resources of a service provider at the request of one or more users. A set of {resource,operations} tuples is generated, wherein a resource describes an endpoint for a network service and operations is a list of operations that are authorized on an endpoint. The set of {resource,operations} tuples is partitioned into one or more subsets. A subset of the set of {resource,operations} tuples is combined into a string according to a predetermined rule. A hash is then computed, according to a hash function, to generate hash results.","Referring first to , a block diagram is shown of a system  in which a service provider  communicates with one or more clients ()-(L) by way of a network  to provide software services to one or more of the clients ()-(L). The service provider  has, or has access to, a plurality of servers ()-(K), physical and\/or virtual, that can provide software services to the clients ()-(L). The servers ()-(K) need not be co-located and need not be completely under control of the service provider. The network  may consist of one or more local area networks (wired and wireless) and one or more wide area networks (wired and wireless).","The clients ()-(L) are software applications that are running on a device such as a desktop computer, laptop computer, tablet computer, server computer, smartphone, or any other apparatus on which an application (called a client application herein) is running that at some point in time, involves a user accessing a service provided by the service provider . A user may be a person, or another computing apparatus.","For purposes of this description, the following terminology is defined.","A \u201cresource\u201d is a concrete, self-contained piece of functionality that is the smallest unit of authorization. A \u201cresource\u201d describes an endpoint for a network service.","An \u201coperation\u201d is a separate action that is authorized to be performed on a resource (endpoint). For example, in Hypertext Transport Protocol (HTTP)-based systems, this might correspond to the HTTP method used for the request.","A \u201c{resource,operations} tuple\u201d thus defines an endpoint for a network service and a collection of operations authorized on the endpoint. A {resource,operations} tuple is also referred to herein as a \u201cResOp\u201d.","A \u201cservice provider\u201d offers services that consist of one or more operations on each of one or more resources.","A \u201ctoken service\u201d or \u201cauthorization service\u201d is an entity trusted by the service provider to ensure that authentication has succeeded. The authorization service generates and signs tokens. The authorization service is provided\/supported by an authorization server  shown in .","An \u201cidentity provider\u201d is a system\/entity that authenticates users and maps them to identities that can be processed by the authorization service. The identity provider (IdP) is shown at reference numeral  in .","A \u201cclient\u201d is, as explained above, software application or process that uses the services provided by the service provider, after having communicated with the identity provider and authorization service.","An \u201cauthorization token\u201d or \u201ctoken\u201d is a time-limited list of permissions that entitles the bearer to access a long list of discreet services.","When a user is provisioned to have access to a set of services provided by one or more service providers, a token service or authorization service (e.g., the authorization server ) is given a list of protocols, host names, resources, and operations on those resources that are involved in that user having access. The authorization service does not need to know what semantic is associated with these ResOps. The service provider  may also inject extension data, which will be available to the service provider later in the process.","The ResOps lists described above can be very long in a real-world complex system, to the point where the length of the list would make the system impractical. However, the number of combinations of resources and operations used in practice are usually quite limited. Instead of passing around long lists, a pointer to the list is distributed as needed. One such pointer to the list can be constructed by ordering the list canonically (according to a predetermined rule), converting it to a canonical bytestream, e.g., using a JavaScript Object Notation (JSON) as set forth in RFC 4627, and performing a cryptographically-strong hash over the bytestream. These hashes can then be exchanged instead of the lists. Using the hash as a verification mechanism, any actor in the system that knows the original data that corresponded to the hash can then act as a trusted source of that information, leading to highly optimized transport of that data. For example, if an entity refers to a given hash in its capabilities description, that entity can be assumed to know the set of {resource,operations} tuples described by the hash. The service provider  stores a cache of hashes, shown at reference numeral  in , for facilitating the distribution of authorization information to clients, as described in further detail hereinafter.","When the client accesses an authorization service (AuthZ) provided by the authorization server  for the first time, normal single-service authentication\/authorization is performed (e.g., OAuth), perhaps involving the separate IdP .","Reference is made to .  shows a flow chart for operations performed at the authorization server , for example.  provides a pictorial representation of these operations. At , data is stored that represents operations that can be performed on a plurality of resources of a service provider, at the request of one or more users. At , a set of {resource,operations} tuples is generated that are authorized on a resource (endpoint), where, again, a \u201cresource\u201d defines an endpoint for a network service and \u201coperations\u201d is a collection of operations that are authorized on the endpoint.  shows a set of {resource,operations} tuples  comprising resource  (Res) and operation  (Op)-operation k (Op) that are authorized on Res, and Op-Opthat are authorized on Res, . . . , and Op-Opthat are authorized on Res.","For HTTP, the resource may be specified by a Universal Resource Locator (URL), and the operation may be a request method, e.g., GET, POST, etc. Other protocols may specify their own operations, e.g., publish\/subscribe, etc. The authorization server  treats resource and operations as opaque.","An example of a {resource,operations} tuple syntax is as follows:",{"@attributes":{"id":"p-0037","num":"0036"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"[{ \u201cres\u201d: \u201c\/auth\/*\u201d,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201cops\u201d: [\u201cGET\u201d, \u201cPOST\u201d]},"]},{"entry":[{},"{ \u201cres\u201d: \u201c\/meetings\/**\u201d,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201cops\u201d: [\u201cDELETE\u201d, \u201cGET\u201d, \u201cPOST\u201d]},"]},{"entry":[{},"{ \u201cres\u201d: \u201c\/print\u201d,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201cops\u201d: [\u201cDELETE\u201d, \u201cPOST\u201d]}"]},{"entry":[{},"... (MANY)]"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In this example, one resource hierarchy is \/auth\/* and the operations on this resource are GET and POST. Another deeper resource hierarchy is \/meetings\/** and the operations on this resource are DELETE, GET and POST. An explicit resource is \/print that has operations DELETE and POST.","At , the set of {resource,operations} tuples  are de-duplicated and then partitioned into one or more subsets, shown at ()-() in . The partitioning operation may be performed so as to minimize the number of subsets needed to describe authorizations across a user population. For example, the set of {resource,operations} tuples  is separated into one or more subsets so as to minimize the number of subsets and maximize the number of hash collisions so that the hash results cache optimally, as described further hereinafter. In so doing, there will be as few hashes alive or active in the system at any one time so that they cache more optimally.","The authorization server may compute an optimal set of ResOps subsets by looking for common patterns. Imagine a spectrum of subset sizes from one (where each user would need thousands of subsets) to the number of users (where each user would get a different subset, and no caching can occur). The optimal number of subsets will minimize the token size and maximize the number of cache hits using feedback from the number of times a subset is requested, the number of times that subset is given out, and cross-organizational scans for the most common subsets used.","At , at least one subset of {resource,operations} tuples is combined into a string according to a predetermined rule, e.g., alphabetical sorting, followed by JSON serialization. The string is shown at reference numeral  in . An example of a string for the example {resource,operations} tuple given above is (note: no newlines are intended in the below example):",{"@attributes":{"id":"p-0042","num":"0041"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"[{\u201cres\u201d: \u201c\/auth\/*\u201d, \u201cops\u201d: [\u201cGET\u201d, \u201cPOST\u201d]}, {\u201cres\u201d: \u201c\/meetings\/**\u201d,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u201cops\u201d: [\u201cDELETE\u201d, \u201cGET\u201d, \u201cPOST\u201d]}, {\u201cres\u201d: \u201c\/print\u201d, \u201cops\u201d:"},{"entry":"[\u201cDELETE\u201d, \u201cPOST\u201d]}]"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"At , a hash of the string is computed, using a hash function, to generate hash results. For example, the hash function may be a Secure Hash Algorithm 1 (SHA1) hash, an MD5 function, etc. The hash results are generically shown at reference numeral  in . The hash results may converted to a string of characters. For the example string referred to above, the string of characters for the hash results (derived from a SHA1 hash) is:","d669e4c30a1b9d360f86786ee448cd71bcf9dd6c","There are several possibilities\/options for use of the hash results. First, at , the subset of {resource,operations} tuples may be stored in a distributed hash table based on the hash results. A distributed hash table (DHT) provides a lookup service that stores (key, value) pairs, and any participating device\/entity can efficiently retrieve the value associated with a given key. Responsibility for maintaining the mapping from keys to values is distributed among the entities, in such a way that a change in the set of participants causes a minimal amount of disruption. Thus, a DHT can scale to large numbers of entities. The DHT may be maintained by memory in the authorization server  or service provider , or some other entity\/device in the system.","Another possibility is, as shown at , to generate a cacheable Universal Resource Identifier (URI) that points to the subset of {resource,operations} tuples and is described by the hash results for the string, for storage and use by the service provider and clients. An example of a cacheable URI for the hash results example provided above is https:\/\/authz\/d669e4c30a1b9d360f86786ee448cd71bcf9dd6c. The cacheable URI may be cacheable via a network protocol.","Still another possibility is, at , to generate a token in response to a request based on a user identity associated with a client. The token includes one or more hash results. At , the token is sent to the client (with a signature generated from the contents of the token).","Yet another possibility, as shown at , is to retrieve, the subset of {resource,operations} tuples using the hash results from any entity that is known to have the subset of {resource,operations} tuples. In other words, a client can request any entity to provide the subset, using the hash results, if the client has some knowledge that that entity should have the subset.","Reference is now made to  for a description of a token. A token, shown generally at reference numeral , includes data indicating time validity specifying the time period during which the token is valid, in the form of a start time field  and an end time field . There is an identity field  that identifies the user for which the token is intended. After the identity field there are one or more sets of ResOps fields, each set comprising a prefix field, a rule field and a hash results field, e.g., prefix(), rule (), and hash results (), prefix(), rule (), and hash results () . . . , prefix(), rule (), and hash results (). The prefix field specifies the initial portion of the resource and is to be combined with the resource suffixes in the ResOp set by simple concatenation. Moreover, the token is usable on\/by a plurality of service providers. The prefix fields indicate on which one or more service providers the token may be used. In the example token given below, the prefix \u201chttp:\/\/cisco.webex.com\u201d refers to one service provider, while the prefix \u201chttp:\/\/go.webex.com\u201d refers to another service provider. The rule field specifies a rule associated with the resource, such as allow, deny, or other rules, such as delegate. The hash results field contains the hash results for a subset of {resource,operations} tuples. Thus, there is a list of hash results, each having an associated prefix and rules for the operations indicated in the hash results. There is also an extension field  after the ResOps fields. The extension field  contains additional data provided by a service provider upon provisioning, such as inputs to other more complicated authorization schemes. The signature field  contains a cryptographic signature computed across all of the other fields shown in , and may be optional in some applications.","Set forth below is an example token syntax:",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{ \u201cstart\u201d: \u201c2011-12-20T02:08:50Z\u201d,"]},{"entry":[{},"\u201cend\u201d: \u201c2011-12-20T06:08:50Z\u201d,"]},{"entry":[{},"\u201cidentity\u201d:"]},{"entry":[{},"\u201chttps:\/\/ident.cluster1\/86bcc11f-7684-4529-b2dc-a25e1c6eaf51\u201d,"]},{"entry":[{},"\u201cresops\u201d: [{\u201cprefix\u201d: \u201chttp:\/\/cisco.webex.com\u201d,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201crule\u201d: \u201callow\u201d:"]},{"entry":[{},"\u201chash\u201d: \u201cd669e4c30a1b9d360f86786ee448cd71bcf9dd6c\u201d},"]},{"entry":[{},"{\u201cprefix\u201d: \u201chttp:\/\/go.webex.com\u201d,"]},{"entry":[{},"\u201crule\u201d: \u201callow\u201d:"]},{"entry":[{},"\u201chash\u201d: \u201cd669e4c30a1b9d360f86786ee448cd71bcf9dd6c\u201d}],"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u201c{http:\/\/example.com\/network}location\u201d: \u201cinside-firewall\u201d}"]},{"entry":[{},"+ signature"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Turning now to , a flow chart is described for techniques to minimize redundancy of data in the token by selecting a subset of {resource,operations} tuples that minimizes redundancy. At , in generating the token, the lists of hash results may be separated such that the resource with the same prefix goes into the same list. At , the minimal number of lists is output for inclusion in the token.","Multiple users will have the same set of authorizations. If the system maximizes the number of times that the same ResOp set occurs, more efficient caching can be performed on the hash of that set. There are several mechanisms which can increase the number of collisions.","First, the ResOp set is shared between users of the system. Second, the Universal Resource Locator (URL) prefix (e.g., scheme:\/\/hostname:port) can be removed from the hash, thereby reusing the hash across machines. Third, new lists with different prefixes can be added rather than creating a new, longer list. Fourth, allowing resources to apply hierarchically with * (match up to the next \u201cspecial\u201d character, like \u2018\/\u2019) and ** (match all resources that start with this resource). In addition, excess ResOps whose resource and operation match can be removed. Further still, ResOps that are more restrictive than a higher-level authorization which grants access to that same feature can be removed. For example [\u201c\/top\/*\u201d, [\u201cGET\u201d,\u201cPUT\u201d]] contains [\u201c\/top\/next\u201d, [\u201cGET\u201d]], so the latter is redundant and may be removed.","Reference is now made to , which illustrates an overall flow diagram for the operations performed by a client (), the service provider  and authorization server . At , the client sends a request, GetToken, to obtain a token from the authorization server . At , the authorization server  sends the token (optionally signed), to the client ().","The client provides the token every time it performs an operation on a resource of a service provider. Thus, a , the client () sends the token with a request to perform an operation on a resource to the service provider . At , the service provider  checks the signature of the token and its validity time to determine that the signature is valid and that it is not expired. If the signature and\/or validity time is not valid, then the process stops, and an appropriate message is sent to the client notifying the client of the token validity failure. If the signature and time validity check passes, then at , the service provider can grant access to one or more resources and operations on the service provider, and the service provider checks its ResOp cache to see if the operation requested is in its ResOp cache. If it is in the ResOp cache, then the processing continues at . If it is not in the ResOp cache, then at , the service provider sends a request to get the ResOp, Get ResOp, to the authorization server . At , the authorization server responds by sending the entire set of {resource,operations} tuples as described above in connection with , for the service provider , and the associated hash results, computed by the authorization server.","At , the service provider checks the hash results sent by the authorization server , and if the hash results are consistent with the set of {resource,operations} tuples contained in the response sent at , then the service provider  can store them in its ResOp cache.","At , the service provider  checks to ensure that the ResOp desired is allowed in the token, and otherwise satisfies any rules in the token. If the ResOp is not allowed or does not otherwise satisfy specified rules in the token, an error message is returned to the client. At , the service provider performs the requested service operation and sends the results to the client (), if the service operation worked as desired.","Once all of the ResOp lists pointed to in the token are cached and pre-processed, the checks at  and  can be performed quite rapidly, without accessing a service running on a separate machine. When cache hits are common, the system can perform well at scale, allowing bounds on memory usage by any given process by aging the least-recently-used ResOp lists out of the cache.","The Application Programming Interface (API) framework to support the operations depicted in  include APIs to check token validity, de-reference ResOp URI, check hash results, as well as matching a host\/source to an operation (via an URI).","Clients need to be able to determine what actions the current user is authorized to perform, in order to optimize the user experience. The mechanism specified above for the service provider is simple enough such that clients may have their own implementations. Removing the need for the client to constantly inquire if a feature is authorized substantially reduces server traffic.","Clients will also examine the contents of the token to retrieve the expiry times (indicated by the start and stop time fields) so that they can generate a new token before the old one expires. A further refinement will allow notification via a publish\/subscribe mechanism when the authorization server detects that an existing token is no longer valid.","None of the operations described herein require the authorization server  to understand anything about HTTP (e.g., the valid operations) or HTTP: URLs. Non-HTTP service providers can create string representations of their resources and operations in a consistent fashion, often using an available URI scheme as the encoding process.","Reference is now to  for an example of how a client may use a received token. At , the client parses a token received from the authorization server  and retrieves the list of subsets from the token. At , the client retrieves, for each hash results in the list (in the token), the corresponding ResOp subset. At , the client searches for a resource and an operation that are associated with a user interface element. For example, as shown in , the resource and operation that the client can perform is a print resource, e.g., the aforementioned explicit resource\/print that has operations DELETE and POST, for which a print icon  is displayed. The client searches for that resource and operation in each of the ResOps subsets retrieved in . If that resource and operation is found, the client is authorized for the print resource. Otherwise, the print icon  is grayed-out or opaque, as shown in .","Thus,  show that a client gets\/refreshes tokens from the authorization server and maps ResOps to user interface elements, such that unauthorized resources may be indicated as a removed or gray-out user interface element.","Turning now to , a diagram is shown that depicts how ResOps are loaded into the authorization server . ResOps may be injected into the authorization server  from a variety of resources, including entitlement , billing , administration , and other entities, such as security, etc. The entitlement server  will load user entitlements, the billing server will load billing entitlements and the administration server  will load custom organizational policies. The authorization server  will then build the set of {resource,operations} tuples, and can use this information to generate and sign tokens at the request of clients.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 10","FIG. 9","FIGS. 1-9"],"b":["40","40","42","44","45","46","46","400","40","410","410","44"]},{"@attributes":{"id":"p-0068","num":"0067"},"figref":["FIG. 11","FIGS. 6"],"b":["30","32","33","34","35","36","37","38","38","430","440","430","33","7","8"],"i":"i"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 12","b":["20","20","21","23","25","26","26","24","22","450","22","20","450"],"i":["i","i"]},"The memories ,  and  shown in  may comprise read only memory (ROM), random access memory (RAM), magnetic disk storage media devices, optical storage media devices, flash memory devices, electrical, optical, or other physical\/tangible (e.g., non-transitory) memory storage devices. The processors  shown in  are, for example, a microprocessor or microcontroller that executes instructions in their associated memory. Thus, in general, the memories ,  and  may comprise one or more tangible (non-transitory) computer readable storage media (e.g., a memory device) encoded with software comprising computer executable instructions and when the software is executed (by a processor) it is operable to perform the operations described herein.","In summary, disclosed herein is a scalable, performant, cross-protocol mechanism for describing, transmitting, and checking large lists of authorizations for operations on network resources. This mechanism drastically reduces the size of tokens that would otherwise contain exhaustive lists of all of the authorizations required to access a service. This allows the mechanism to be used for much finer-grained authorizations without sacrificing latency of processing.","The above description is intended by way of example only."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
