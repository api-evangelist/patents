---
title: Method and system for advanced restart of application servers processing time-critical requests
abstract: A method and apparatus for implementing a recovery process for a resource manager. The method and apparatus has the resource manager take checkpoints in a manner such that in the case of failure of the resource manager, the time it takes to have requests processed again is shorter than a specified request processing time.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07055063&OS=07055063&RS=07055063
owner: International Business Machines Corporation
number: 07055063
owner_city: Armonk
owner_country: US
publication_date: 20011108
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Description of the Preferred Embodiments"],"p":["1. Field of the Invention","The invention relates to a data processing environment consisting of one or more application servers processing requests, particularly time-critical requests, on behalf of at least one application and, more specifically, to a method and a system for controlling restart processing after termination of one or more resource managers that are involved in managing resources needed by an application server to fulfill application requests.","2. Background of the Invention","A typical data processing environment consisting of an application server for processing time-critical transactions is shown in . An application server implements a collection of related services which are requested from applications via application clients. Applications, application servers, and application clients may be implemented by computer programs of any nature not limited to a specific type of implementation. Application, application server, and application client are only logical structures; for example, an application server could be the application that requests services from another application server or even requests from itself.","Application servers typically run on the second tier of a three-tier system structure. In such a three-tier system structure the application client is on the first tier, requesting services from an application server on the second tier, which in turn requests services from back-end applications that are located on the third tier. The three-tier system structure is a conceptual structure. That means, even if it is typical to deploy the different tiers onto different computers, there is no need to do so; the deployment of the complete structure onto a single computer is a completely valid approach. It should be noted that a three-tier structure is just a special case of an n-tier structure. For example, if users are interacting via a Web browser, then the Web browser would be considered running on tier  and the associated web server which runs the application requesting services from the application server is considered running on tier .","Application servers are typically stateless, that is, they store any necessary state information into a persistent data storage. State information is data that the application server maintains between two subsequent requests from a client so that the individual requests from the application requesting services can be correlated.","Application servers, in general, run the processing of requests as transactions in the sense of ACID transactions which means all requests are either processed completely or not at all. A thorough representation of transaction technology is given by Jim Gray and Andreas Reuter, \u201cTransaction Processing: Concepts and Techniques\u201d, Morgan Kaufmann Publishers, Inc., 1993. In the case of an error, the transaction is aborted, all resources are reset to the state they have been before the transaction was started. For example, if the access to the relational database that maintains the application server state fails, all changes made to any of the involved resources are backed out, i.e. the message in a message queue that represents the request is put back into the queue from where it was read. This requires that all resources that are used by the application server for persistent data are managed by resource managers that can participate in transactions.","If any one of the involved software components fails, all components must be brought back to the state when the failure of the one or more components occurred so that processing can continue. The process of bringing a failed component back is called a restart process. The time it takes to restart a component depends on how much work needs to be undone and redone to re-establish the state of the component at the time of failure.","Resource managers maintain a log that contains entries about all changes that were applied to their managed resource. The log is typically maintained on highly available disks that, for example, exploit RAID technology. In addition, the resource managers periodically take snapshots of their current state and write this information as a checkpoint into the log. This information is used for recovery from resource manager failures, such as the abnormal termination of the resource manager or the loss of the media on which the resource manager maintains the resource. Recovering from an abnormal termination of the resource manager is called crash recovery, while recovering from a media failure is called media recovery. It should be noted that media recovery is no longer considered an issue in resource manager recovery due to the high availability of the disks on which the data is maintained and is therefor not considered in the present invention. The component of resource managers that is responsible for recovering from failures is typically called the restart manager. When the resource manager is restarted after the crash, the restart manager uses the checkpoint information and the individual log entries to reconstruct the latest state; that means the restart component needs to figure out which transactions need to be aborted, such as those executing when the crash occurred, and which committed updates need to be redone. This is done by locating the checkpoint record and processing all log records that are coming after the checkpoint record. Thus, the frequency with which checkpoint records are taken, determines the amount of processing that is required to restart the failing component after a failure.","In the prior art approaches, different resource managers have different policies when to write a checkpoint record. These policies are typically specified via some global settings, such as the number of processed messages in a message queuing system or the time period between two subsequent checkpoints in a relational database management system. These settings may be fixed so that they can not be changed by the user, as for example in a message queuing system MQSeries where the number of processed messages is set to 1000; or these settings may be variable, as for example in a relational database management system DB, where the time between checkpoints can be set by the user.","A resource manager typically serves multiple applications such as multiple different application servers. In this case, the log is used for all changes caused by all applications. However, some resource managers, such as DB, allow multiple instances to run. An instance consists of all the information needed to support users; it has its own catalog for managing metadata, own log, and appropriate user data. A particular application server can be associated with a particular instance. In this case, the log is only used for the operations of the particular application server.","The checkpoint record frequency settings for each of the involved resource managers determines how long it will take to recover from the crash of one or more of the resource managers. As each participating resource manager takes checkpoints independently, the maximum restart time of the application server can be calculated as the restart time of the resource manager with the longest restart time plus the restart time of the application server itself.","Typically, the restart time is obtained by running simulations with the application server. Since simulation never matches real-life situations, the estimated restart time is only an approximate value.","Taking checkpoints is not only a time-consuming operation, it also slows down processing of requests as the resource manager must dedicate processing and I\/O resources for taking the checkpoint. Since there is no correlation between the processing of the application server and the frequency of checkpoint taking by the involved resource managers, checkpoints may be taken, even if not required.","It is therefore an aspect of the present invention to provide a method and a system which guarantee that in the case of a failure of the environment, such as a crash of one or more of the resource managers, the request processing time of the application server does not exceed a pre-specified, in particular a user-defined, request processing time.","It is another aspect of the present invention to provide such a method and a system which enable an application server that processes time-critical requests to guarantee that a user-specified request processing time is not exceeded, even if any of the resource managers needed to satisfy the requests terminates abnormally.","It is yet another aspect of the present invention to provide such a method and a system which minimize the number of checkpoints being taken by the resource managers involved in running the application server transactions.","The prior art problems are solved by the method according to the invention by having the resource managers taking checkpoints in a frequency that guarantees that the restart of the application server, including the restart of the resource managers and including the processing time of the request, does not exceed the specified request processing time. Even in the case of failure of any of the involved resource managers, it is achieved that the time it takes to have the requests processed again is shorter than a specified request processing time. Thus the proposed mechanism ensures that the resource managers take checkpoints in such a frequency that the time it takes to have the application server processing requests again is shorter than the specified request processing time.","The concept underlying the invention is based on the observation that the frequency with which checkpoint records are taken determines the amount of processing that is required to restart a failing component after a failure.","The method according to the invention preferably specifies two mechanisms of controlling when a checkpoint needs to be written, one being a load-controlled mechanism and the other being a restart-time-controlled mechanism.","In both cases, specification of the request processing time may either be hard coded in the application server or provided to the application server as a parameter. As an additional option, the application server may support changing of the request processing time during operation, for example, by offering an appropriate application programming interface, or some graphical\/textual interface.","In the load-controlled method, the application server knows the amount of data that each resource manager writes into its log and the amount of time it takes the resource manager to process the log in the case of a restart. Thus, the application server knows at any time the currently necessary restart time of each resource manager and, based on that information, requests the taking of checkpoints from the resource managers so that the specified request processing time could even be met in the case of a failure of one or more resource managers. The load-controlled method is based on the assumption that the resource managers provide the capability for calling applications to request the taking of checkpoints.","In the restart-time-controlled method, the resource manager provides the capability for the specification of a restart time. This allows the application server to determine from the user specified request processing time the appropriate restart time for each of the involved resource managers. This information is handed over to the resource manager when the application server connects to the resource manager the first time or when the user specified request processing time is changed.","Thereupon, a further advantage of the proposed mechanism is that checkpoints have only to be taken if necessary, resulting in an improved throughput of the application server.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","b":["100","110","112","114","120","122","124","110","112","114","100","120","122","124","110","112","114","100","120","122","124","100","110","100","110","112","114","130"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 2","FIG. 2"],"b":["200","210","200"]},"When application  requests a service from application server , application client  puts a message reflecting the request of application  into application server input queue . This is done as transaction , labeled Transaction , so that when the request has been successfully put into application server input queue , the request of application  will be honored.","Application server  processes requests within transaction , labeled Transaction . The transaction consists of reading the request from input queue , performing processing based on the request, saving processing state information persistent into data store , and putting a response into application server output queue .","Application  gets this response by application client  reading the response from application server output queue . This process is run as transaction , labeled transaction .","In the processing of a request and generating a response by application server , multiple resources are accessed and possibly modified. Since multiple resources and thus multiple resource managers are involved in such a transaction, the transaction must be coordinated via transaction manager  typically using a two-phase-commit (2PC) protocol. The individual resources are typically managed by different resource managers. For example, the application server's input and output queue ,  are managed by a message queuing system (not shown) and data store  by a relational database management system (not shown). The involvement of multiple resource managers mandates a transaction manager which coordinates the processing of the individual resource managers when the transaction needs to be committed or aborted. The 2PC protocol is the protocol that transaction managers typically exploit to coordinate commit\/abort processing with the resource managers involved in a particular transaction. Further information can be found in the textbook \u201cTransaction Processing: Concepts and Techniques\u201d, authored by Jim Gray and Andreas Reuter and published by Morgan Kaufmann Publishers, Inc., 1993 which is regarded to be entirely incorporated herein by reference.","Referring again to , application server  processes each individual client request as a transaction. The term transaction should not be understood as limited to the classical definition of transactions, that means having ACID properties, but to all units of work concepts that provide some form of transaction control by weakening one or more of the ACID properties.","It is further noted that, although the above description is related to an application server, the scope of the present invention is by no means limited to such an application server and, moreover, can be used for any other application which performs the described interaction patterns with resource managers.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 3","FIG. 3"],"b":["300","310","320","330","350","340","360","370"]},"In the following, two different embodiments of the invention are described in more detail.","Load-Controlled Checkpointing","It is hereby assumed that resource managers provide the capability for applications to request checkpoints. How the resource managers externalize this capability is not relevant, whether it is the sending of a message to queue or the invocation of the request via an application programming interface.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 4"},"When the application server processes next request , it first determines the current settings for user specified request response time . This request response time must not be exceeded in case of failure. Next, the application server performs a set of actions (indicated by loop ) for all resource managers. First, the application server determines the restart time needed for current request  and the potential previous requests, which would participate in restart processing since the last checkpoint processing, and then calculates new restart time . If the new restart time would exceed the restart time necessary to keep within requested response time , the resource manager is requested to take checkpoint . The mapping of the request response time to the restart time takes into effect additional processing that is associated with the restart after a failure, such as starting the application server or reattaching to the failing resource manager. After all resource managers have been processed, the request is processed  and the new restart time is calculated for all resource managers . It should be noted, that  is for illustration purpose only; actual implementations are most likely more sophisticated.","If the resource manager does not support the notion of a resource manager instance, then the resource manager must provide the capability to assign a separate log to a particular application. In addition, the resource manager must provide the capability that applications can request that checkpoints are taken only for a particular log. When a crash occurs, then the resource manager must process this log before any other log, unless there is no time penalty when processing multiple logs in parallel.","To summarize, in the load-controlled checkpointing approach the above teaching is embodied within an application server which controls the checkpointing frequency based upon guaranteed response time requirements on behalf of the underlying resource managers. In addition, this approach reflects the processing required to restart the application server itself.","Restart Time Controlled Checkpointing","The load-controlled checkpoint approach requires that the application server has a deep understanding of the logging and restart operations of each of the involved resource managers. In particular, the metrics associated with logging and restart need to be changed whenever the resource manager is changed.","In order to increase performance and throughput of the application server(s), in the present embodiment, the resource managers themselves keep track of the restart time instead of the application server. The resource manager externalizes the capability for applications to set the restart time and the resource manager then takes a checkpoint whenever the specified restart time is reached.  shows how a resource manager could implement this capability.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 5","FIG. 3","FIG. 5"],"b":["500","510","520"]},"Although specific embodiments of the present invention have been illustrated in the accompanying drawings and described in the foregoing detailed description, it will be understood that the invention is not limited to the particular embodiments described herein, but is capable of numerous rearrangements, modifications and substitutions without departing from the scope of the invention. The following claims are intended to encompass all such modifications."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["The invention will now be described in the following in more detail by way of embodiments whereby reference is made to the accompanying drawings. In the drawings,",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
