---
title: Page prerequisite control mechanism
abstract: Apparatus and methods are provided for managing, tracking and controlling page prerequisites in a graphical user interface (GUI). According to one embodiment, in response to a request to display a destination page of the GUI and with reference to prerequisite information, one or more prerequisite pages associated with the destination page are identified. Then, a determination is made whether the requirements of an identified prerequisite page have been satisfied by invoking a method of an instance of a decider sub-component that causes stored information regarding the state of the identified prerequisite page to be retrieved from a current environment/context. Finally, the destination page is displayed if all the requirements of the one or more identified prerequisite pages have been satisfied, otherwise a prerequisite page having one or more requirements that remain unsatisfied is displayed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06922813&OS=06922813&RS=06922813
owner: E*Trade
number: 06922813
owner_city: Menlo Park
owner_country: US
publication_date: 20010404
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims the benefit of U.S. Provisional Application Nos. 60\/198,717 and 60\/205,813, filed Apr. 20, 2000 and May 19, 2000, respectively, both of which are incorporated herein by reference.","Contained herein is material that is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction of the patent disclosure by any person, as it appears in the Patent and Trademark Office patent files or records, but otherwise reserves all rights to the copyright whatsoever.","1. Field of the Invention","The invention relates generally to graphical user interfaces (GUIs). More particularly, the invention relates to a mechanism for enforcing prerequisites in the context of GUI navigation.","2. Description of the Related Art","In the context of web page navigation, there may be various requirements that must be met before a particular page or content is accessible by a user. For example, a website may require that the user read and accept some disclosure, fill out a registration questionnaire, or login before certain content, such as real-time stock quotes, or pages, such as a securities trading page, or an account overview page, are made available to the user. Once all the requirements are met, e.g., the disclosure has been presented and acknowledged by the user, the protected content or pages, e.g., the securities trading page, may be displayed any time it is requested by the user. In this example, the displaying of the disclosure page thus becomes a \u201cprerequisite\u201d to displaying the securities trading page.","Of course, there might be a series of prerequisite pages that must be shown to the user; and some may require data entry by the user before their requirements are met. For example, login pages typically require both a user ID and a password to be entered. After the user is authenticated, a required disclosure page may be displayed to the user before the desired destination page is presented. The disclosure page may have an \u201cI ACCEPT\u201d button, which when selected, takes the user to the desired destination page. Prerequisite tracking is a simple issue when there is a one-to-one relationship between disclosure pages and the desired destination pages. However, it should be apparent that the complexity of prerequisite tracking increases rapidly as the number of destination pages requiring a particular disclosure page increases and as the number of inter-page dependencies to be enforced increases.","One potential solution to this prerequisite tracking problem is to have logic associated with the destination page, e.g., the securities trading page, perform the check whether the appropriate disclosure page has been displayed or not and if not to execute the appropriate code to cause its display. After the appropriate disclosure page has been displayed, subsequent requests for the securities trading page will not cause the disclosure page to be shown to the user since it has already been displayed. However, there are many disadvantages of this solution. First, every destination page becomes tightly coupled to its disclosure page(s). Second, changing the prerequisites or adding new prerequisites requires coding changes. Third, the reusability of pages is adversely affected since the destination page cannot be used in other contexts. Finally, if other pages require the same prerequisites, the same code needs to be copied to all such page objects. While the examples above have focused on pages as a whole, similar difficulties relating to prerequisite tracking exist in the context of web page sub-component interdependencies.","Thus, what is needed is a mechanism by which a web publisher may specify components and\/or sub-components that are prerequisites to other components and\/or sub-components. Also needed is framework for implementing a methodology by which prerequisite components and sub-components may ensure that their requirements have been met before they are displayed.","Apparatus and methods are described for managing, tracking and controlling page prerequisites in a graphical user interface (GUI). According to one embodiment, prerequisite information regarding pages that are prerequisites to other pages is provided. In response to a request to display a destination page and with reference to the prerequisite information, one or more prerequisite pages associated with the destination page are identified. A \u201cdecider\u201d sub-component of an identified prerequisite page is identified that is capable of confirming whether or not requirements of the identified prerequisite page have been satisfied. Then, an instance of the decider sub-component is created and a determination is made whether the requirements of the identified prerequisite All page have been satisfied by invoking a method of the decider sub-component instance that retrieves stored information regarding the state of the identified prerequisite page from a current environment\/context. Finally, the destination page is displayed if all the requirements of the one or more identified prerequisite pages have been satisfied, otherwise a prerequisite page having one or more requirements that remain unsatisfied is displayed.","Other features of the present invention will be apparent from the accompanying drawings and from the detailed description that follows.","Apparatus and methods are described for managing, tracking and controlling page prerequisites. Broadly stated, according to embodiments of the present invention, page prerequisite objects and page sub-component prerequisite objects ensure that conditions for which they are responsible have been met before associated pages and page sub-components, respectively, are permitted to perform a particular action, such as display information to a user. According to one embodiment, a properties data store, such as a properties file, defines the relationships between prerequisite and destination pages and\/or destination page sub-components. Advantageously, in this manner, the relationships may be modified using an editor and without requiring recompilation. Additionally, the processing of the prerequisites may be abstracted from the destination pages and destination page sub-components by performing the prerequisite processing by the framework. Thus, reusability is enhanced by the fact that any destination page or destination page sub-component may be taken out of its current context and placed unchanged into any other context, in which it may no longer have any prerequisites or may have different prerequisites.","In the following description, for the purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It will be apparent, however, to one skilled in the art that the present invention may be practiced without some of these specific details. In other instances, well-known structures and devices are shown in block diagram form.","The present invention includes various steps, which will be described below. The steps of the present invention may be performed by hardware components or may be embodied in machine-executable instructions, which may be used to cause a general-purpose or special-purpose processor or logic circuits programmed with the instructions to perform the steps. Alternatively, the steps may be performed by a combination of hardware and software.","The present invention may be provided as a computer program product that may include one or more machine-readable mediums having stored thereon instructions, which may be used to program a computer (or other electronic devices) to perform a process according to the present invention. The machine-readable medium may include, but is not limited to, floppy diskettes, optical disks, CD-ROMs, and magneto-optical disks, ROMs, RAMs; EPROMs, EEPROMs, magnetic or optical cards, flash memory, or other type of media\/machine-readable medium suitable for storing electronic instructions. Moreover, the present invention may also be downloaded as a computer program product, wherein the program may be transferred from a remote computer (e.g., a server) to a requesting computer (e.g., a client) by way of data signals embodied in a carrier wave or on other propagation medium via a communication link (e.g., a modem or network connection). Accordingly, herein, a carrier wave shall be regarded as comprising a machine-readable medium.","Importantly, while embodiments of the present invention will be described with reference to web page processing and Java properties files, the apparatus and methods described herein are equally applicable to various other types of user interfaces and mechanisms for maintaining property\/attribute information.","Network Overview","The present invention may be included within a client-server system  such as that illustrated in FIG. . According to the embodiment depicted in , a server  may be communicatively coupled to clients  through a communications medium , such as a local area network (LAN) or a wide area network (WAN). A representative data connection between the clients  and the server  includes a direct-dial, bi-directional data connection, which may be telephone (POTS, i.e., \u201cplain old telephone service\u201d), Integrated Services Digital Network (ISDN), digital subscriber line (DSL) or other similar type of connection. Various other data connections between the clients  and the server  are possible. For example, the connection may be via a network interface card or via a modem pool (not show) such as that conventionally known in the art for providing access to the Internet and private networks. Alternatively, the connection may be established through an Internet service provider (ISP) that allows the clients  to exchange information with the server .","The server  includes a novel prerequisite enforcing framework (not shown) that manages, tracks and controls page and\/or page sub-component prerequisites. As will be discussed further below, the server  may access a properties data store (not shown), such as a Java properties file, that includes information defining the relationships between prerequisites and destination pages and\/or destination page sub-components. Various exemplary software architectures of the prerequisite enforcing framework and preferred syntax and representations of the information in the properties database are described below.","Computer System Overview","A computer system  in which features of the present invention may be implemented will now be described with reference to FIG. . Computer system  comprises a bus or other communication means  for communicating information, and a processing means such as processor  coupled with bus  for processing information. Computer system  further comprises a random access memory (RAM) or other dynamic storage device  (referred to as main memory), coupled to bus  for storing information and instructions to be executed by processor . Main memory  also may be used for storing temporary variables or other intermediate information during execution of instructions by processor . Computer system  also comprises a read only memory (ROM) and\/or other static storage device  coupled to bus  for storing static information and instructions for processor .","A data storage device  such as a magnetic disk or optical disc and its corresponding drive may also be coupled to bus  for storing information and instructions. Computer system  can also be coupled via bus  to a display device , such as a cathode ray tube (CRT) or Liquid Crystal Display (LCD), for displaying information to a computer user. Typically, an alphanumeric input device , including alphanumeric and other keys, may coupled to bus  for communicating information and\/or command selections to processor . Another type of user input device is cursor control , such as a mouse, a trackball, or cursor direction keys for communicating direction information and command selections to processor  and for controlling cursor movement on display .","A communication device  is also coupled to bus  for accessing remote servers or other servers via the Internet, for example. The communication device  may include a modem, a network interface card, or other well-known interface devices, such as those used for coupling to an Ethernet, token ring, or other types of networks. In any event, in this manner, the computer system  may be coupled to a number of clients and\/or servers via a conventional network infrastructure, such as a company's Intranet and\/or the Internet, for example.","Exemplary Prerequisite Enforcing Framework",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3","b":["305","310","320","305","10","310"]},"The application server  appropriately routes requests received from the web server  to the object application  and conveys output of the object application  to the web server . For example, in response to page or page sub-component requests, e.g., Uniform Request Locator (URL) requests, the application server  (1) determines the appropriate base agent of the object application , i.e., the base agent associated with the requested page or page sub-component, (2) creates an instance of the base agent, (3) transfers control to the object application  by invoking an execute method of the instantiated base agent, and (4) transfers streamed data, received from the object application  that has been generated by a page, page sub-component, page prerequisite, or page sub-component prerequisite, to the web server .","The object application  provides an abstraction for objects, such as containers and components. According to one embodiment, an object may be thought of conceptually as a hierarchy of potentially nested sub-objects to any number of levels of nesting. The objects and nested sub-objects may be components or containers. Components are leaf nodes in the hierarchy. Containers are non-leaf nodes in the hierarchy and may contain one or more other containers or components. In the embodiments described herein, containers typically represent pages and components of containers represent the pages' sub-components, such as charts, tables, scroll lists, data entry forms, etc.","Architecture of an Exemplary Object Application","Having briefly described an exemplary environment in which the present invention may be employed, a software architecture of the object application , according to one embodiment, will now be described with reference to FIG. . The architecture depicted seeks to facilitate the management, tracking and controlling of page sub-component prerequisites.","According to this example, the software architecture of the object application  includes a base agent , a container object , and a sub-component prerequisite factory . The base agent  includes logic to instantiate and execute the container object  that corresponds to a page associated with the base agent . The base agent  receives the page request . The container object outputs the sub-component output . In one embodiment, the base agent  is instantiated by the application server  in response to a URL request for the page associated with the base agent . Then, the application server  causes the requested page to be displayed by invoking the base agent's execute method. The base agent's execute method, in turn calls the execute method of the container object .","The container object  includes logic to instantiate and execute its sub-objects and determine prerequisites of its sub-objects. The execute method of the container object  first determines its sub-objects (e.g., containers and\/or components) with reference to a properties data store , such as a Java properties file (e.g., \u201c<name>.properties\u201d). Then, for each component, the container object  determines what the next prerequisite is for the component by consulting with a special sub-component prerequisite factory object, such as the sub-component prerequisite factory . As discussed further below, either the next prerequisite or the component will be added to the container object's list of sub-objects to be displayed. If the container object  includes nested containers, when the execute method of the nested containers is invoked, and the nested containers will instantiate and execute their components. When the leaf-level of the hierarchy of objects is reached, those of the components added to the container object's list of sub-objects to be displayed calculate their individual results and stream out these results to the base agent .","According to one embodiment, the sub-component prerequisite factory  includes a method called \u201cgetNextPreReq\u201d that returns either the next prerequisite sub-component object for a specified destination sub-component or null. First, the sub-component prerequisite factory  determines what, if any, prerequisite sub-component objects have been associated with the specified destination sub-component. In the example depicted, this operation is accomplished by retrieving information from the properties data store , such as the value of a \u201cprereq\u201d property. Second, for each of the prerequisite sub-component objects, the sub-component prerequisite factory  determines if the requirements for the prerequisite sub-component have been satisfied. As described further below, in one embodiment, this determination is made by calling a \u201cmetReqs\u201d method of the prerequisite sub-component object. In any event, if the sub-component prerequisite factory  returns a non-null object, it means the destination sub-component is associated with a prerequisite managed by the prerequisite sub-component object that has not yet been satisfied; and rather than displaying the destination sub-component, the prerequisite sub-component object should be displayed to the user. If a null value is returned by the sub-component prerequisite factory , it means that either the specified destination sub-component has no prerequisites or that all the prerequisites for the sub-component have been fulfilled and therefore the destination sub-component may be displayed. Advantageously, according to this novel architecture, the container object  is abstracted from the task of prerequisite processing. In alternative embodiments, the container object  may be even further abstracted from this process by removing its interface with the properties data store  and requiring all access to the properties data store  be by way of the sub-component prerequisite factory .","The software architecture of the present example also includes page sub-component objects , page sub-component prerequisite objects , and a status data store . The page sub-component objects  are each associated with one or more container objects . Importantly, the page sub-component objects  and the page sub-component prerequisite objects  may be coded independently of each other and do not even need to be aware of each other. That is, the page sub-component objects  have no knowledge regarding their prerequisites and include no code relating to determining whether or not such prerequisites have been met. Advantageously, by decoupling the sub-component objects from the sub-component prerequisite objects, reusability of the page sub-component objects  is greatly enhanced.","The page sub-component prerequisite objects  ensure that the conditions for which they are responsible are met. Typically, page sub-component prerequisite objects  display information to the user and\/or collect some information from the user and ensure the correctness of the collected information. In the embodiment depicted, the page sub-component prerequisite objects  store and retrieve the state of their requirements to\/from the status data store . For example, once a required disclosure is displayed to the user that is a precondition to display of a particular page sub-component object, the associated page sub-component prerequisite object may record that fact in the status data store . Then, subsequently, when the particular page sub-component object is requested, its output will be seen rather than that of its page sub-component prerequisite object.","Page Sub-Component Display Processing",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 5A","b":"202"},"In the example illustrated, display processing begins at processing block  where a request for a destination page, such as an HTTP request, is received by the web server  and conveyed to the object application  by way of the application server .","At processing block , the sub-components of the destination page are identified. According to one embodiment, this is accomplished by the container object  querying the properties data store . In alternative embodiments, the sub-component prerequisite factory  may query the properties data store .","At processing block , the page sub-component prerequisites for the destination page sub-components are identified. As above, depending upon the implementation, this may be accomplished by the sub-component prerequisite factory  querying the properties data store . In alternative embodiments, the container object  may query the properties data store . Advantageously, by defining the relationships between prerequisites and destination pages in a data store, no compilation is required when the system administrator modifies those relationships. Rather, if the data store is a text file, it may simply be modified by an editor.","At processing block , an appropriate sub-component object (either a page sub-component objects or a page sub-component prerequisite object ) is added to the destination page's list of sub-component objects to display for each sub-component identified in processing block . According to one embodiment, the container object  calls the \u201cgetNextPreReq\u201d method for each of the page sub-components of the destination page and adds the either the object returned (a page sub-component prerequisite object) or the page sub-component object to the destination page's list for subsequent display. According to one embodiment, the \u201cgetNextPreReq\u201d method sequentially checks page sub-component prerequisites of the specified page sub-component in an order indicated by the properties data store and returns the first page sub-component prerequisite that has one or more requirements that are not satisfied. Advantageously, in this manner, hierarchical relationships of prerequisites may be defined easily.","Finally, at processing block , the destination page is displayed with the appropriate page sub-component outputs and appropriate page sub-component prerequisite outputs by causing each of the sub-component objects on the destination page's list to stream its output to the base agent .",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 5B","FIG. 5A"],"b":["530","531","430","430","532","534","533"]},"At processing block , since it has been determined that one or more requirements of the page sub-component prerequisite object has not been met, the instance of the page sub-component prerequisite object is returned by the sub-component prerequisite factory  and added to the destination page's list. In this example, after the first page sub-component prerequisite object has been found with one or more unsatisfied requirements (i.e., after processing block ), control returns to processing block .","At decision block , a determination is made whether or not there are more page sub-component prerequisites. If so, processing continues with processing block . If not, no page sub-component prerequisite objects have been found that have unmet requirements; and processing continues with processing block . At processing block , because either the specified page sub-component has no page sub-component prerequisites or all have been satisfied, an instance of the specified page sub-component is added to the destination page's list.","Architecture of Another Exemplary Object Application",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 6","b":["320","610","630","640","650","630","660","610","600","640","650","670"]},"The base agent  includes logic to determine which page object is responsible for streaming out the content of the destination page based upon predetermined properties stored in the properties data store  and\/or the specified URL. According to one embodiment, when the user requests the destination page by selecting a link or specifying a URL, for example, in the client browser, the request is passed to the application server  via the web server . Then , the application server  determines the appropriate base agent  for the specified URL, creates an instance of the base agent , and calls the execute method of the base agent . After the base agent  has determined the appropriate page object associated with the URL, it consults with the prerequisite factory  to determine what the next prerequisite is for the page object. If there are no prerequisites or all the prerequisites have been satisfied then the base agent  creates an instance of the page object and executes it to cause the object to stream its output to the display. However, if a prerequisite is returned by the prerequisite factory , then the base agent  instead executes the page prerequisite object causing the prerequisite object to stream its output to the display.","According to one embodiment, the prerequisite factory  includes a method called \u201cgetNextPreReq\u201d that returns either the next page prerequisite object for a specified destination page or null. First, the prerequisite factory  determines what, if any, page prerequisite objects  have been associated with the specified destination page. In the example depicted, this operation is accomplished by retrieving information from the properties data store , such as the value of a \u201cprereq\u201d property. Second, for each of the page prerequisite objects identified, the prerequisite factory  determines if the requirements for the page prerequisite object have been satisfied. As described further below, in one embodiment, this determination is made by calling a \u201cmetReqs\u201d method of a \u201cdecider\u201d component of the page prerequisite object. Because pages may have multiple sub-components, it is preferable to designate one as a decider component that can be used to determine whether or not the conditions for which it is responsible have occurred. In any event, if the prerequisite factory  returns a non-null object, it means the destination page is associated with a prerequisite managed by the page prerequisite object that has not yet been satisfied; and rather than displaying the destination page, the page prerequisite object should be displayed to the user. If a null value is returned by the prerequisite factory , it means that either the specified destination page has no prerequisites or that all the prerequisites for the destination page have been fulfilled and therefore the destination page may be displayed. Advantageously, according to this novel architecture, the base agent  is abstracted from the task of prerequisite processing. In alternative embodiments, the base agent  may be even further abstracted from this process by removing its interface with the properties data store  and requiring all access to the properties data store  be by way of the prerequisite factory .","As above, the page objects  and the page prerequisite objects  may be coded independently of each other and do not even need to be aware of each other. Thus, reusability is enhanced because the page objects  and the page prerequisite objects  are decoupled thereby allowing page objects  to be easily taken out of the current context and placed unchanged into a new context.","The page prerequisite objects  ensure that the conditions for which they are responsible are met. Typically, page prerequisite objects  display information to the user and\/or collect some information from the user and ensure the correctness of the collected information. In the embodiment depicted, the page prerequisite objects  store and retrieve the state of their requirements to\/from the status data store . For example, once a required disclosure is displayed to the user that is a precondition to display of a particular page object, the associated page prerequisite object may record that fact in the status data store . Then, subsequently, when the particular page object is requested, its output will be seen rather than that of its page prerequisite object.","Importantly, the exemplary software architectures depicted in  are not mutually exclusive. Rather, it is anticipated that depending upon the particular implementation either or both page sub-component prerequisites and page prerequisites may be used in the context of the same user interface for purposes of achieving the desired objectives.","Page Display Processing",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 7A","b":"202"},"In the example illustrated, display processing begins at processing block  where a request for a destination page, such as an HTTP request, is received by the web server  and conveyed to the object application  by way of the application server .","At processing block , the page prerequisite objects for the destination page are identified. According to one embodiment, this is accomplished by the base agent  calling the \u201cgetNextPreReq\u201d method of the prerequisite factory , which, in turn, queries the properties data store . Again, the advantage of defining relationships between prerequisites and destination pages in a data store is the fact that no compilation is required when the system administrator modifies those relationships.","At processing block , prerequisite page objects that have one or more requirements that are not fulfilled are displayed sequentially until all prerequisite page objects' requirements are satisfied. According to one embodiment, the \u201cgetNextPreReq\u201d method sequentially checks page prerequisite objects associated with the destination page in an order indicated by the properties data store  and returns the first page prerequisite object that has one or more requirements that are not satisfied thereby facilitating definition of hierarchical relationships among page prerequisite objects and page objects.","Finally, after all the page prerequisite objects' requirements have been satisfied at processing block , the destination page is displayed.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 7B","FIG. 7A"],"b":["730","731","620","630"]},"At processing block , an instance of the \u201cdecider\u201d sub-component is created. According to one embodiment, a special method is made available to allow creation of the page prerequisite object for the purpose of checking if the requirements have been met. Alternatively, the standard create method may be called with a control flag indicating the purpose of the create call, e.g., check prerequisites vs. true creation. At any rate, at decision block , the prerequisite factory  determines if the page prerequisite object's requirements have been satisfied by invoking a method of the newly created instance, such as a \u201cmetReqs\u201d method that preferably all \u201cdecider\u201d sub-components implement. If all the page prerequisite object's requirements have been met, then flow continues with decision block ; otherwise processing branches to processing block .","At decision block , a determination is made whether or not there are more page prerequisite objects associated with the destination page. If so, processing continues with processing block . If not, no page prerequisite objects have been found that have unmet requirements; and processing continues with processing block .","At processing block , since it has been determined that one or more requirements of the page prerequisite object has not been met, the output of the prerequisite page is streamed to the display. Therefore, in this example, after the first page prerequisite object has been found with one or more unsatisfied requirements that page is displayed rather than the destination page selected by the user. In one embodiment, because the decider sub-component has already been instantiated, an optimization involves the framework saving the decider object created during the metReqs call so that it does not have to be recreated when the prerequisite page object is executed.","At decision block , a determination is made whether or not the page prerequisite has been closed. If so, control branches to decision block . If not, control loops back to decision block  thereby preventing the destination page from being displayed until the requirements of the prerequisite page object have been fulfilled.","Properties File Syntax Enhancements","Before describing various improvements to existing properties file syntax, it may be instructive to briefly discuss the current usage model of such files with referent to FIG. . Java has a special built-in mechanism for handling internalization. Locale specific properties\/attributes are placed in files having a \u201c.properties\u201d extension (herein referred to as a \u201cproperties file\u201d). The properties file contains one or more lines of attribute name value pairs (hereinafter \u201cattribute-value pairs\u201d) in the general form represented by expression . The first portion of the attribute-value is an attribute name, such as \u201cprompt1\u201d, as illustrated in expression . The attribute name is followed by an equal sign. The final portion of the attribute value pair comprises a string value, such as \u201cplease enter your name\u201d, as illustrated in expression , to be associated with the particular attribute. In the Java framework, properties files may be loaded into objects of type \u201cResourceBundle\u201d. Then, the resulting resource bundle objects may be queried to determine a value associated with a particular attribute of interest. For example, if a properties file contained the line:\n\nAbc.def.gh\n\nthen invoking the appropriate resource bundle object's get method, e.g., resourceBundle.getString (\u201cAbc.def.gh_I\u201d) would return the string value \u201cj\u201d. In this manner, applications can query the value of an attribute during runt time. However, one limitation of this prior art syntax is that both properties files and the corresponding internal resource bundle representations are flat, non-object oriented collections of key-value pairs. In connection with an object-oriented implementation of page sub-component prerequisites, page prerequisites, and\/or other applications, the assignee of the present invention has found it to be advantageous to (1) allow properties\/attributes to be defined and accessed on an object basis; (2) enable inheritance of properties\/attributes through some hierarchy of objects; (3) specify and override properties\/attributes of objects as they are used in different contexts, and () enable inheritance of contexts.\n\nDefinition and Access of Properties on an Object-by-Object Basis\n",{"@attributes":{"id":"p-0083","num":"0082"},"figref":"FIG. 9","b":["910","910"]},"The syntax represented by expression  allows one or more attribute-value pairs to represent what is referred to herein as a \u201cproperties file object\u201d or simply an object. For example, attribute-value pairs  and  together define a properties file object called \u201cObj1\u201d having two attributes, attr1 and attr2. Similarly, attribute-value pairs  and  specify a properties file object named \u201cObj2\u201d that also includes two attributes, attr1 and attr3. Attribute-value pair  associates the value, wa11, with the attribute named attr1 of object, Obj1. Likewise, attribute-value pairs , , , and , associate val12, val21, val23, and \u201cplease enter your name\u201d with attr2, attr1, attr3, and prompt1 of Obj1, Obj2, Obj2, and Trading, respectively.","Importantly, this improved syntax is fully compliant with standard Java properties files thereby making this syntax enhancement transparent to Java. To Java, the attribute-value pairs , , , and  have no additional meaning. Rather, Java will interpret them as simply representing four independent attribute-value pairs. For example, Java interprets the attribute-value pair  as the value, val11, being associated with an attribute named \u201cObj1.attr1\u201d. Similarly, attribute-value pairs ,  and , respectively, are interpreted as the value, val12, being assigned to \u201cObj1.attr2\u201d, the value, val21, being assigned to an attribute named \u201cObj2.attr1\u201d, and \u201cObj2.attr3\u201d being associated with a value of val23. Consequently, as described further below, the syntax enhancements discussed herein may be implemented on top of standard Java properties file semantics by supplying the standard Java Application Programming Interfaces (APIs) and\/or resource bundle methods with attribute names that include appropriate delimiters to separate the object name from the attribute name.","Inheritance of Properties","Currently, inheritance is not supported by the flat, non-object oriented structure of properties files. Therefore, the concept of a base object (e.g., an object upon which other objects may be built) does-not exist. If common attributes are required in a properties file, they must be replicated as many times as necessary. Unfortunately, such replication becomes problematic when changes become necessary to the common attributes since each change must be accurately performed for each of the replicated attributes.",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 10","b":"1010"},"As illustrated by attribute-value pairs , , , , and , this mechanism allows attributes and values of objects to be inherited by other objects; and the other objects may each override the value of an inherited attribute as well as add its own attributes and values. In the present example, two \u201cproperties file objects\u201d are defined, Obj1 and Obj2. Obj1 and its associated attributes and values are defined by attribute-value pairs  and . Obj2 and its associated attributes and values are defined by attribute-value pairs , , and . The use of the special attribute name \u201cextends\u201d in attribute-value pair  causes Obj2 to extend Obj1. That is, Obj2 inherits all the attributes of Obj1. Additionally, in this example, attribute-value pair  overrides the value of attr2 of Obj2 with val22. Finally, attribute-value pair  specifies that Obj2 has an attribute, attr3, in addition to those specified for Obj1, which is assigned the value val23.","Advantageously, this novel inheritance syntax saves time for the person specifying attributes. For example, in a system in which two or more objects have many attributes and values in common, the common attributes need only be specified once in a base object. Then, extending objects need only specify overridden values or new attributes and values. Thus, by employing the inheritance mechanism described herein, time savings proportionate to the-commonality of attributes among objects of a system can be achieved during specification of the attributes.","This notation also facilitates maintainability of properties files in which it is employed. Rather than replicating common attributes among many objects as would be required in a non-hierarchical environment that lacks a mechanism for inheritance, such as that imposed by current properties file syntax, the notation of  facilitates modification of object attributes and\/or attribute values by allowing common attributes to be specified in base objects. As a result, a change to a particular common attribute is localized to the base object that specifies that common attribute; and semantically this change is automatically accomplished for all sub-objects (e.g., extending objects) that inherit from the modified base object.","While the special attribute name \u201cextends\u201d has been chosen to enhance the readability and understandability of the properties file, the invention is not limited to any particular naming convention. Thus, in alternative embodiments, the name \u201cextends\u201d may be replaced with other names, such as \u201cinheritsfrom\u201d, \u201cisa\u201d, or other arbitrary string values.","Specification and\/or Overriding of Object Properties in Different Contexts",{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 11","b":"1110"},"importantly, this enhanced syntax provides for context sensitive overriding of properties file object attributes. In the present case, attribute-value pairs  and  define an object, Obj1, having attr1 and attr2. The value of attr1 is always val11. However, as a result of the attribute-value pair , the value of attr2 is val12 except when Obj1 is running in the context of Page1 in which case the value of attr2 is val112. Therefore, assuming an object has the ability to determine its context, a mechanism is provided by the syntax of expression  for context sensitive overriding of attributes of objects.","While, in the examples illustrated herein, the context name, object name, and attribute name appear in a specific order relative to each other within attribute-value pairs, the invention is not limited to any particular ordering of these names. Consequently, in other embodiments, alternative orderings of these names may be used.","Inheritance of Contexts",{"@attributes":{"id":"p-0095","num":"0094"},"figref":["FIG. 12","FIG. 10"]},"In the present example, properties files may include attribute-value pairs having the form of expression , which includes a context name, a special attribute name, \u201cextends\u201d, and an indication of the context to be extended (e.g., the context from which to inherit objects and\/or attributes). Attribute-value pairs  and  indicate that normally, or by default, the value of attribute attr2 of Obj1 is val12. However, attribute-value pair  overrides the definition of attr2 of Obj1 when Obj1 is running in the context of Page1. Attribute-value pairs  and  specify a context, Page2, that includes all the objects and attributes of Page1 but overrides the value of attr2 of Obj1 when Obj1 is running in the context of Page2. Thus, the value of attr2 of Obj1 may have one of three values depending upon its current context. For example, when the context is Page1, attr2 is val112; when the context is Page2, attr2 is val212; otherwise, attr2 is val12.","Property Retrieval Processing",{"@attributes":{"id":"p-0097","num":"0096"},"figref":"FIG. 13"},"In the embodiment depicted, the property retrieval process begins at processing block . Processing block  is representative of the first stage of the three stages. During processing block , an attempt is made to retrieve a specified attribute by climbing a specified object hierarchy (presumably created by the inheritance mechanisms described earlier) with which the attribute is thought to be associated. If a value for the specified attribute is located during this stage, processing is complete; otherwise processing proceeds with processing block  (the second stage). At processing block , the context is no longer held fixed as in processing block . Rather, the context hierarchy is climbed to search parent contexts. Within each context, every level of the specified object hierarchy is also searched until the desired value is located or the levels are exhausted. Again, if the desired value is found, processing may cease at this point; otherwise, a final attempt is made to retrieve the value of the specified attribute in processing block . During processing block  (the third stage), context is ignored; and a final search is made for the desired value by climbing the object hierarchy without regard to the current context.",{"@attributes":{"id":"p-0099","num":"0098"},"figref":"FIG. 14A"},{"@attributes":{"id":"p-0100","num":"0099"},"figref":["FIG. 14B","FIG. 13"],"b":["14","13","14"]},"First, the object will attempt to locate the value of attr by searching a first group of attribute-value pairs . More specifically, the object will first look in its current context, e.g., by calling its getValue ( ) method with the string value \u201cPage3.Obj3.attr\u201d. If the value of attr for Obj3 is not overridden by Page3, then the object will begin climbing its hierarchy. In this example, the object will look to its parent, Obj2, to see if a value has been associated with attr, e.g., by making the call getValue (\u201cPage3.Obj2.attr\u201d). If this retrieval is unsuccessful, e.g., returns a null value, then a final attempt within the current context will be made to retrieve the desired value from Obj1.","Assuming the desired value was not found during the first stage. The search continues into a second group of attribute-value pairs . The search of the second group  represents the second stage where an attempt is made to locate the object's attribute by climbing the object's hierarchy in the parent context, Page2, until a level is found in which the attribute is assigned a value or until the levels are exhausted. The search proceeds as above, climbing the object hierarchy within the current context, Page2. Once the object hierarchy has been exhausted, however, the search continues with the parent of the current context, Page1.","Again, assuming the desired value was not located by a previous stage, the search enters a final stage  in which context is disregarded and the object hierarchy is traversed. First the object determines if it has defined a value for attr, e.g., by making the call getValue(\u201cObj3.attr\u201d). If this call is unsuccessful, then a subsequent retrieval is made with reference to the object's parent, Obj2. If that call fails, a final attempt to retrieve the desired value will be made with reference to Obj2's parent, Obj1, e.g., by calling getValue(\u201cObj1.attr\u201d).",{"@attributes":{"id":"p-0104","num":"0103"},"figref":"FIG. 15","b":["1510","1520","1530"]},"At decision block , a determination is made whether or not the object hierarchy has been exhausted. If the current object has a parent, then another level in the object hierarchy exists. However, if the current object does not have a parent, then the object hierarchy has been exhausted. At any rate, assuming the object hierarchy has been exhausted, processing continues with processing block  during which the current object is updated to be the next object in the object hierarchy, i.e. its parent, and processing returns to processing block .","Returning to decision block , if the object hierarchy has been exhausted, processing proceeds to decision block . At decision block  a determination is made whether or not the context hierarchy has been exhausted. If there is no parent of the current context (context hierarchy exhausted), then the current stage of the search is complete. Otherwise, if the current context has a parent (context hierarchy not exhausted), then processing continues with processing block .","At processing block , the current context is updated to the next context (i.e., the parent of the current context). Then, at processing block , the current object is reset to the original object to restart object hierarchy traversal in the new context.","It is worth mentioning at this point that while the processing blocks of a flow diagram illustrating a particular embodiment are presented and described in a particular order, there should be no implication that the present invention is limited by that particular ordering. Rather, it is contemplated that in alternative embodiments, the ordering of the processing blocks may be changed while preserving the core functionality. For example, in , at least the ordering of processing blocks  and  may be reversed without any effect.",{"@attributes":{"id":"p-0109","num":"0108"},"figref":"FIG. 16","b":["1610","1620","1630","1630","1640","1640","1610"]},"Importantly, while the flow diagrams described above imply a simple, linear, non-recursive algorithm, it is contemplated that in an actual code implementation it may be desirable to implement one or more of the methods as recursive procedures\/functions.","Software Architecture for Processing an Improved Properties File Syntax",{"@attributes":{"id":"p-0111","num":"0110"},"figref":"FIG. 17","b":["1710","1711","1713","1715","1717","1711","1710"]},"According to one embodiment, object  inherits logic from a base object that serves as an abstraction for the interface to API . In this manner, object  automatically has the ability to retrieve the value of any of its attributes without needing knowledge of the data store, e.g., properties file  (e.g., by making the call underlying interface to the property data store, e,g.,properties file  (e.g., by making the call getString ). Additionally, inheritance of this logic saves design and development time.","In one embodiment, the functionality of the getWithContextInheritance( ) method  and get WithObjectInheritance( ) method  are represented by the processing described with reference to ; and the functionality of the getwithInheritance( ) method  is represented by the processing described with reference to FIG. .","Importantly, while, for sake of generality, the properties file  is shown as being accessed by API , it is appreciated that the properties file  may be internally represented with a resourceBundle object as described above. Also, if this is the case, the API  would be the resourceBundle's exposed methods.","Exemplary Methods Accessible by the Objects","For the sake brevity, in the code examples of , it is assumed that there exists a getContextname( )method in every object that returns a string value containing the context\/container name. Every object also is assumed to know how to figure out its name. In Java this is done by performing the call: getClass( ).getName( ). Subsequently, the left sub-parts of the name are removed to reveal the object name. In the following examples, this left sub-part removal (or alternatively, right sub-part extraction) is assumed to be performed by getName( ). Therefore, \u201cpkg1.sub2.Obj3\u201d would result in the object name of \u201cObj3\u201d. In the exemplary implementation every object is additionally assumed to extend some base object that implements a get Value( ) method, which returns the value of a key-value pair corresponding to a specified key. Therefore, every sub-component inherits the logic in the method getValue( ).",{"@attributes":{"id":"p-0116","num":"0115"},"figref":["FIG. 18","FIG. 17"]},{"@attributes":{"id":"p-0117","num":"0116"},"figref":["FIG. 19","FIG. 17"]},{"@attributes":{"id":"p-0118","num":"0117"},"figref":["FIG. 20","FIG. 17"]},{"@attributes":{"id":"p-0119","num":"0118"},"figref":["FIG. 21","FIG. 17"]},"Importantly, while not shown in the exemplary code fragments, a memory cache may be implemented to avoid repeating lookups for attributes. Briefly, when an object needs to calculate the value of some property it first checks if it is available in the cache. If it is, the value is retrieved from the cache; otherwise, the value may be retrieved from the properties file (via the resourceBundle and algorithms described above or the exemplary code of FIGS. -). If the value is found in the properties file, a copy may be stored in the cache to avoid future file lookups and related processing.","In the foregoing specification, the invention has been described with reference to specific embodiments thereof. It will, however, be evident that various modification and change may be made thereto without departing from the broader spirit and scope of the invention. The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense."],"BRFSUM":[{},{}],"heading":["COPYRIGHT NOTICE","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the figures of the accompanying drawings and in which like reference numerals refer to similar elements and in which:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 5B","FIG. 5A"],"b":"530"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 7B","FIG. 7A"],"b":"730"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 14A"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 14B","b":["14","13"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 18","FIG. 17"]},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 19","FIG. 17"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":["FIG. 20","FIG. 17"]},{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 21","FIG. 17"]}]},"DETDESC":[{},{}]}
