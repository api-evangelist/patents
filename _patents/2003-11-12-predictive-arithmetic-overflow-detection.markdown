---
title: Predictive arithmetic overflow detection
abstract: A method for arithmetic overflow detection includes receiving a first instruction defined for a first processor having a first base, where the instruction comprises an operator and at least one operand having an operand type. The method also includes indicating whether the at least one operand has potential overflow based at least in part on the operator and the relationship between the operand type and a result type associated with the operator.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07010786&OS=07010786&RS=07010786
owner: Sun Microsystems, Inc.
number: 07010786
owner_city: Santa Clara
owner_country: US
publication_date: 20031112
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This Application is a continuation-in-part of application Ser. No. 10\/686,513 filed on Oct. 14, 2003 in the name of inventors Zhiqun Chen and Judith Schwabe and entitled \u201cOptimization of N-Base Typed Arithmetic Expressions\u201d, which is a continuation of application Ser. No. 10\/002,437 filed Nov. 1, 2001 now U.S. Pat. No. 6,687,898 in the name of inventors Zhiqun Chen and Judith Schwabe and entitled \u201cOptimization of N-Base Typed Arithmetic Expressions\u201d, which is a continuation of application Ser. No. 09\/439,113 filed Nov. 12, 1999 (now U.S. Pat. No. 6,363,523) in the name of inventors Zhiqun Chen and Judith Schwabe and entitled \u201cOptimization of N-Base Typed Arithmetic Expressions\u201d, commonly assigned herewith.","This application is related to the following:","U.S. patent application Ser. No. 09\/243,101, filed Feb. 2, 1999 in the name of inventors Joshua Susser and Judith Schwabe and entitled \u201cObject-Oriented Instruction Set for Resource-Constrained Devices\u201d, commonly assigned herewith.","U.S. patent application Ser. No. 10\/712,463, filed Nov. 12, 2003 in the name of inventors Judith Schwabe and Zhiqun Chen, entitled \u201cOptimization of N-Base Typed Arithmetic Instructions via Rework\u201d, commonly assigned herewith.","U.S. patent application Ser. No. 10\/712,918, filed Nov. 12, 2003 in the name of inventor Judith Schwabe and entitled \u201cOverflow Sensitive Arithmetic Instruction Optimization Using Chaining\u201d, commonly assigned herewith.","U.S. patent application Ser. No. 10\/712,919, filed Nov. 12, 2003 in the name of inventors Judith Schwabe and Zhiqun Chen, entitled \u201cOverflow Predictive Arithmetic Instruction Optimization Using Chaining\u201d, commonly assigned herewith.","The present invention relates to the field of computer science. More particularly, the present invention relates to a system and method for predictive arithmetic overflow detection.","Preparation of a computer program is illustrated in . The user writes programs in a high-level programming language . The programs written in the high-level program language  are compiled into a low-level machine language , which can be executed by the targeted machine. For example, programs written in the high-level Java\u2122 programming language are compiled into low level bytecode instructions. The bytecode instructions are the machine language for a Java\u2122 Virtual Machine. The Java\u2122 Virtual Machine Specification is described in Lindholm et al., \u201cThe Java\u2122 Virtual Machine Specification\u201d, 1999, Addison Wesley, Second Edition.","Typical high-level programming languages support arithmetic expressions. Arithmetic expressions are defined by an arithmetic operator that operates on one or more operands. Operators typically supported include addition, subtraction, multiplication, division, remainder, negate, shift, bitwise OR, bitwise AND and bitwise exclusive OR. Intermediate values are the results of one or more arithmetic operations.","High-level languages also typically support multiple or n-base integral types and arithmetic operations are overloaded. Overloading allows operators to accept operands having mixed types. For example, the Java\u2122 programming language supports four base integral types: \u201cbyte\u201d, \u201cshort\u201d, \u201cint\u201d and \u201clong\u201d. These types support 8-, 16-, 32- and 64-bit values, respectively. Operators such as the \u201c+\u201d operator may accept operands of any of these integral types. The three examples below illustrate overloading the \u201c+\u201d operator for operations on operands having mixed base types.\n\n","This overloading is typically performed by widening values to a wider base type and then performing the arithmetic operation. For example, C and Java\u2122 compilers typically widen values of type \u201cbyte\u201d and \u201cshort\u201d to type \u201cint\u201d. In the Java\u2122 language, type \u201cint\u201d is always 32 bits. Thus, 16-bit values of type \u201cshort\u201d and 8-bit values of type \u201cbyte\u201d are widened to the 32-bit type \u201cint\u201d before performing the arithmetic operation. In the Java\u2122 language, the following byte code is generated for each of the three examples listed above:\n\n","The \u201ciload\u201d instruction loads any of the 8, 16 or 32-bit variables and puts a 32-bit operand on the stack. The \u201ciadd\u201d instruction pops two 32-bit operands off the stack, adds them and puts the 32-bit result back on the stack.","Unlike Java\u2122, some high-level languages define only the relationship between the integral types, and not the size of each type. For example, one C compiler vendor may define the bit sizes of types \u201cbyte\u201d, \u201cshort\u201d and \u201cint\u201d to be 8, 16 and 32 bits, respectively. However, another C compiler vender may define the sizes of the same types to be 16, 32 and 64 bits, respectively. Yet another compiler may define the bit sizes to be 16, 32 and 32 bits, respectively. In all cases, the relationship between the sizes of each type is maintained (number of values represented by type \u201cbyte\u201d<number of values represented by type \u201cshort\u201d, number of values represented by type \u201cshort\u201d<number values represented by type \u201cint\u201d), but the actual number of bits used to represent each type may differ. Like Java\u2122, however, C performs arithmetic operations in the size of the \u201cint\u201d type defined by each particular compiler. This requires widening values having a smaller base type to type \u201cint\u201d.","This type widening approach reduces the number of machine instructions, thus reducing the complexity of the target machine. However, this type widening typically requires more computational stack space. For example, adding two 16-bit values of type \u201cshort\u201d after they have been widened to the 32-bit type uses the same amount of stack space as adding two 32-bit values of type \u201cint\u201d, as illustrated in .","Turning now to , a flow diagram that illustrates stack usage when adding two 16-bit values of type \u201cshort\u201d in the Java\u2122 language is illustrated. At , the first 16-bit operand is loaded and pushed onto the operand stack. The operand stack at this point is illustrated by reference numeral . At , the first 16-bit operand is expanded to 32 bits (). At , the second 16-bit operand is loaded and pushed onto the operand stack . At , the second 16-bit operand is expanded to 32 bits (). At this point, the operand stack occupies 4\u00d716=64 bits. At , the two 32-bit operands are added using a 32-bit \u201cadd\u201d operator, leaving the 32-bit result on the stack .","Turning now to , a flow diagram that illustrates stack usage when adding two 32-bit values of type \u201cint\u201d is presented. At , the first 32-bit operand is loaded and pushed onto the operand stack . At , the second 32-bit operand is loaded and pushed onto the operand stack . At , the two 32-bit operands are added using a 32-bit \u201cadd\u201d operator, leaving the 32-bit result on the stack . Thus, in the 16-bit \u201cadd\u201d and the 32-bit \u201cadd\u201d examples above, two 32-bit operands are pushed onto the stack before being popped off the stack and added using a 32-bit \u201cadd\u201d operation.","During the course of program execution, the stack size may vary in size due to factors such as the level of nested procedure calls, the complexity of computed expressions and the number of locally declared variables. On resource-constrained devices such as smart cards, there is typically insufficient memory available to perform such computations where type widening takes place.","Resource-constrained devices are generally considered to be those that are relatively restricted in memory and\/or computing power or speed, as compared to typical desktop computers and the like. By way of example, other resource-constrained devices include mobile telephones, boundary scan devices, field programmable devices, personal digital assistants (PDAs) and pagers and other miniature or small footprint devices.","Smart cards, also known as intelligent portable data-carrying cards, generally are made of plastic or metal and have an electronic chip that includes an embedded microprocessor or microcontroller to execute programs and memory to store programs and data. Such devices, which can be about the size of a credit card, have computer chips with 8-bit or 16-bit architectures. Additionally, these devices typically have limited memory capacity. For example, some smart cards have less than one kilo-byte (1K) of random access memory (RAM) as well as limited read only memory (ROM), and\/or non-volatile memory such as electrically erasable programmable read only memory (EEPROM).","Furthermore, smart cards with 8-bit or 16-bit architectures typically have built-in 8-bit or 16-bit arithmetic operations, respectively. As such, smart cards can typically perform 8-bit or 16-bit operations more efficiently than 32-bit operations. Performing 32-bit operations on data that has been widened to 32-bits is especially inefficient. Thus, the limited architecture and memory of resource-constrained devices such as smart cards make it impractical or impossible to execute programs where the values have been widened to a larger integral type.","The Java\u2122 Virtual Machine instruction set defines an arithmetic instruction set to handle values of integral types \u201cbyte\u201d, \u201cshort\u201d and int. Variables of type \u201cbyte\u201d and \u201cshort\u201d are widened to the integral type \u201cint\u201d during compilation. By contrast, the Java Card\u2122 (the smart card that supports the Java\u2122 programming language) Virtual Machine defines a separate instruction set to handle variables of type \u201cbyte\u201d and \u201cshort\u201d, in addition to the instruction set to handle variables of integral type \u201cint\u201d. Most Java Card\u2122 applications operate on data values of type \u201cshort\u201d or \u201cbyte\u201d.","There is an increasing trend in the computer industry to support high-level computer languages designed for execution on relatively memory-rich desktop computers, such that the same programs can be run on resource-constrained devices, thus achieving interoperability across vertical platforms. This interoperability across vertical platforms requires that programs written in the high-level programming language render the same result when run on resource-constrained devices as they would when ran on relatively memory-rich devices. For example, it is desirable to support execution of programs written in the Java\u2122 programming language on a variety of platforms including smart card platforms, hand-held devices, consumer appliances, desktop computers and supercomputers.","A method for arithmetic overflow detection includes receiving a first instruction defined for a first processor having a first base, where the instruction comprises an operator and at least one operand having an operand type. The method also includes indicating whether the at least one operand has potential overflow based at least in part on the operator and the relationship between the operand type and a result type associated with the operator.","Embodiments of the present invention are described herein in the context of a method and apparatus for predictive arithmetic overflow detection. Those of ordinary skill in the art will realize that the following detailed description of the present invention is illustrative only and is not intended to be in any way limiting. Other embodiments of the present invention will readily suggest themselves to such skilled persons having the benefit of this disclosure. Reference will now be made in detail to implementations of the present invention as illustrated in the accompanying drawings. The same reference indicators will be used throughout the drawings and the following detailed description to refer to the same or like parts.","In the interest of clarity, not all of the routine features of the implementations described herein are shown and described. It will, of course, be appreciated that in the development of any such actual implementation, numerous implementation-specific decisions must be made in order to achieve the developer's specific goals, such as compliance with application- and business-related constraints, and that these specific goals will vary from one implementation to another and from one developer to another. Moreover, it will be appreciated that such a development effort might be complex and time-consuming, but would nevertheless be a routine undertaking of engineering for those of ordinary skill in the art having the benefit of this disclosure.","In accordance with one embodiment of the present invention, the components, process steps, and\/or data structures may be implemented using various types of operating systems (OS), computing platforms, firmware, computer programs, computer languages, and\/or general-purpose machines. The method can be run as a programmed process running on processing circuitry. The processing circuitry can take the form of numerous combinations of processors and operating systems, or a stand-alone device. The process can be implemented as instructions executed by such hardware, hardware alone, or any combination thereof. The software may be stored on a program storage device readable by a machine.","In addition, those of ordinary skill in the art will recognize that devices of a less general purpose nature, such as hardwired devices, field programmable logic devices (FPLDs), including field programmable gate arrays (FPGAs) and complex programmable logic devices (CPLDs), application specific integrated circuits (ASICs), or the like, may also be used without departing from the scope and spirit of the inventive concepts disclosed herein.","In accordance with one embodiment of the present invention, the method may be implemented on a data processing computer such as a personal computer, workstation computer, mainframe computer, or high performance server running an OS such as Solaris\u00ae available from Sun Microsystems, Inc. of Santa Clara, Calif., Microsoft\u00ae Windows\u00ae XP and Windows\u00ae 2000, available from Microsoft Corporation of Redmond, Wash., or various versions of the Unix operating system such as Linux available from a number of vendors. The method may also be implemented on a multiple-processor system, or in a computing environment including various peripherals such as input devices, output devices, displays, pointing devices, memories, storage devices, media interfaces for transferring data to and from the processor(s), and the like. In addition, such a computer system or computing environment may be networked locally, or over the Internet.","In the context of the present invention, the term \u201cnetwork\u201d comprises local area networks, wide area networks, the Internet, cable television systems, telephone systems, wireless telecommunications systems, fiber optic networks, ATM networks, frame relay networks, satellite communications systems, and the like. Such networks are well known in the art and consequently are not further described here.","In the context of the present invention, the term \u201cprocessor\u201d may be used to refer to a physical computer or a virtual machine.",{"@attributes":{"id":"p-0071","num":"0079"},"figref":["FIG. 4","FIG. 4"],"b":["400","400","402","404","406","408","410","412","414","416","418","420","422","424","426","428","430","414","432","416","432","434"]},"Many other devices or subsystems (not shown) may be connected in a similar manner. Also, it is not necessary for all of the devices shown in  to be present to practice the present invention, as discussed below. Furthermore, the devices and subsystems may be interconnected in different ways from that shown in . The operation of a computer system such as that shown in  is readily known in the art and is not discussed in detail in this application, so as not to overcomplicate the present discussion. Code to implement the present invention may be operably disposed in system memory  or stored on storage media such as fixed disk , floppy disk  or CD-ROM .","Resource-constrained devices are generally considered to be those that are relatively restricted in memory and\/or computing power or speed, as compared to typical desktop computers and the like. Although the particular implementation discussed below is described in reference to a smart card, the invention can be used with other resource-constrained devices including, but not limited to, mobile telephones, boundary scan devices, field programmable devices, personal digital assistants (PDAs) and pagers, as well as other miniature or small footprint devices. The invention can also be used on non-resource-constrained devices.","Turning now to , a block diagram that illustrates converting arithmetic expressions for execution on a resource-constrained device according to one embodiment of the present invention is presented. A compiler takes arithmetic expressions  written in a high-level language  and widens the operands to a larger integral type, creating larger base typed instructions  for execution on a typical desktop machine . The larger base typed instructions  are optimized to semantically equivalent smaller base typed instructions  for execution on a resource-constrained device . For example, a \u201cshort\u201d-type addition instruction is used to operate on \u201cshort\u201d-typed operands, and the result is type \u201cshort\u201d.","According to another embodiment of the present invention, the optimization to semantically equivalent smaller base typed instructions is part of a just-in-time code generator. Just before a set of instructions is executed for the first time, the unoptimized instructions are optimized to semantically equivalent smaller base typed instructions for execution on a resource-constrained device. Subsequent execution of the same set of instructions use the set of optimized instructions.","According to another embodiment of the present invention, when a larger type instruction  is required to preserve the semantics of an arithmetic instruction, and larger type instructions are not supported by the target processor, the arithmetic expression is rejected as not supported.","Turning now to , a block diagram that illustrates converting instructions in accordance with one embodiment of the present invention is presented. Java\u2122 class files  containing instructions with 32-bit operands are received by a Java Card\u2122 class file converter . The converter  generates instructions  optimized for execution on a resource-constrained device. The optimizations include, by way of example, providing less stack usage, smaller program size and faster execution.","Target machines may support n-typed arithmetic operators. While the Java\u2122 Virtual Machine supports type \u201cint\u201d operators, the Java Card\u2122 Virtual Machine supports type \u201cshort\u201d operators and optionally supports type \u201cint\u201d operators. Other devices may support only \u201cbyte\u201d-typed arithmetic operations, or all of \u201cbyte\u201d-, \u201cshort\u201d- and \u201cint\u201d-typed operations. Typically, relatively less time is required to perform 16-bit arithmetic on an 8-bit or 16-bit processor and relatively more time is required to perform 32-bit arithmetic on the same processor.","Since the actual values used in an arithmetic operation are not known at optimization time, the optimization must assume the worst case value for each operand. The worst case value for an operand is determined based upon the input operand type. A small-type operation can have results that require large-type representation or overflow into a larger type. Thus, according to embodiments of the present invention, arithmetic operators are categorized into operators affected by overflow and operators with the potential to create overflow. For the purposes of this disclosure, overflow comprises the underflow of negative values. The result of a small-type operation is said to carry potential overflow if the operator used to create the result belongs to the group of operators with the potential to create overflow into a large-type representation. Intermediate values are allowed to carry potential overflow as long as the intermediate value is not used as an operand for an operator belonging to the group of operators affected by overflow.","The operators with a potential to create overflow comprise addition, subtraction, multiplication, division, negate and left-shift. The Java\u2122 bytecodes for these operators are shown in Table 1.",{"@attributes":{"id":"p-0081","num":"0089"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Operations with Potential Overflow"},{"entry":"Java\u2009\u2122 Bytecode"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"iadd"},{"entry":"isub"},{"entry":"imul"},{"entry":"idiv"},{"entry":"ineg"},{"entry":"ishl"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The operators affected by overflow are shown in Table 2. The arithmetic operators affected by overflow comprise division, remainder, negate, right-shift and unsigned right-shift. Non-arithmetic operators affected by overflow comprise array operations, switch operations and compare operations.",{"@attributes":{"id":"p-0083","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Operations Affected by Overflow"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Java\u2009\u2122","Operation","Which Operand(s) Affected by"]},{"entry":[{},"Bytecode","Type","Overflow"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"idiv","Arithmetic","both input operands"]},{"entry":[{},"irem","Arithmetic","both input operands"]},{"entry":[{},"ineg","Arithmetic","only has one operand"]},{"entry":[{},"ishr","Arithmetic","operand being shifted only"]},{"entry":[{},"iushr","Arithmetic","operand being shifted only"]},{"entry":[{},"if<*>","Compare","only has one operand"]},{"entry":[{},"if_icmp<*>","Compare","both operands to the compare"]},{"entry":[{},"tableswitch","Switch","switch value"]},{"entry":[{},"lookupswitch","Switch","switch value"]},{"entry":[{},"*newarray","array","number of elements"]},{"entry":[{},"*aload","array","array index"]},{"entry":[{},"*astore","array","array index"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},"When optimizing Table 1 operations to a smaller type, the result may overflow into the larger type. The result of an expression with one of the operators in Table 2 may lose precision if one of the operands in the expression is an intermediate value and contains potential overflow data. To enable optimization and preserve the semantics of the high-level source code, the potential overflow must be corrected using an explicit source level cast to the type of the result if the result is input to one of the operations in Table 2.","If input operand(s) to any of the operations in Table 2 are the result of an operation in Table 1 and an explicit high level source code cast is not present, optimization cannot occur. Such an erroneous optimization would not guarantee a semantically equivalent result. In other words, the optimized code generated for execution on a resource-constrained device could render a result different than the non-optimized code generated for a desktop computer. For example, overflow data could be present in the Java\u2122 32-bit representation of the operand(s), but not in the Java Card\u2122 16-bit representation.","The result of operations with the operators listed in Table 1 may cause overflow if an operator with a smaller type is applied. Examples of these problems associated with optimizing instructions targeted to a desktop computer platform to instructions targeted to a resource-constrained computer platform are provided in . The examples assume the desktop computer is based on a 32-bit architecture and is relatively memory rich. The resource-constrained computer is assumed to be based on a 16-bit architecture with relatively little memory. Those of ordinary skill in the art will recognize the invention applies to computing platforms having various architectures.",{"@attributes":{"id":"p-0087","num":"0095"},"figref":"FIGS. 7A\u201310B"},"Turning now to , a code sample that illustrates the addition of two values of type \u201cshort\u201d on a desktop computer is illustrated. The value \u201ca\u201d contains the maximum value that can be represented by a 16-bit signed \u201cshort\u201d type. As described above, even though the values are 16-bit \u201cshort\u201d values, \u201cint\u201d-type addition is used. Thus, overflow from the 16-bit range to the 32-bit range is present in the result value and the effect of the overflow is to create a larger positive 32-bit number.","Turning now to , a code sample that illustrates adding the same values as in  on a resource-constrained computer is presented. Since execution is being performed on a resource-constrained computer and both values are 16-bit \u201cshort\u201d types, the instructions are optimized to use \u201cshort\u201d-typed addition, thus using less stack space. However, because 16-bit addition is used instead of 32-bit addition, the addition creates overflow in the sign bit. Whereas the desktop computer computed a value of 32,768, the result computed in the resource-constrained computer example is \u221232,768, a negative number. This result is unacceptable because it is different from the desktop computer result, preventing interoperability across multiple computer platforms.","Turning now to , a code sample that illustrates the addition of two values of type \u201cshort\u201d and immediately casting the result is presented. This example is the same as that in FIG. A, except that the result of the addition is cast to type \u201cshort\u201d. Casting the type to \u201cshort\u201d truncates the most significant sixteen bits to a \u201cshort\u201d value and sign extends to a 32-bit value. The result of an operation that potentially carries overflow (the \u201cadd\u201d operation) is cast to type \u201cshort\u201d, thereby eliminating any potential overflow problem.  illustrates adding the same values as in  represented as 16-bit values on a resource-constrained computer. The result values for both the desktop computer and the resource-constrained computer are the same.","Turning now to , a code sample that illustrates the addition of three values of type \u201cshort\u201d on a desktop computer is presented. In the example, \u201cint\u201d-type addition is used to add 16-bit \u201cshort\u201d values \u201ca\u201d and \u201cb\u201d and add the result to \u201cc\u201d. The final result is cast to a \u201cshort\u201d type.","Turning now to , a code sample that illustrates performing an operation that is not affected by overflow on operands created by an operation that potentially carries overflow on a resource-constrained computer is presented. Since all values in this example are 16-bit \u201cshort\u201d types, \u201cshort\u201d-typed addition is used for all intermediate additions. As indicated in Table 1, the addition operator potentially creates overflow, but is not affected by overflow. Thus, adding \u201ca\u201d and \u201cb\u201d creates a value that potentially carries overflow. This value is added to \u201cc\u201d, creating another value that potentially carries overflow. Although the second \u201cadd\u201d operation contains one operand that potentially carries overflow (the \u201ca+b\u201d result), the \u201cadd\u201d operation is not affected by operands carrying overflow. The final result is cast to type \u201cshort\u201d, removing the potential overflow from the addition operation. Thus, the result values for both the desktop computer and the resource-constrained computer are the same.","Turning now to , a code sample that illustrates the addition of two values of type \u201cshort\u201d and dividing the result by a value of type \u201cshort\u201d on a desktop computer is presented. Since execution is being performed on a desktop computer, \u201cint\u201d-type operations are used. The values \u201ca\u201d and \u201cb\u201d are added together using \u201cint\u201d-type \u201cadd\u201d. This intermediate value is divided by \u201cc\u201d.","Turning now to , a code sample that illustrates performing an operation that is affected by overflow on operands created by an operation that potentially carries overflow on a resource-constrained computer is presented. Since execution is being performed on a resource-constrained computer, \u201cshort\u201d-type operations are used. The values \u201ca\u201d and \u201cb\u201d are added together using \u201cshort\u201d-type \u201cadd\u201d. The addition creates an intermediate value having overflow from the 16-bit range. This intermediate value is divided by \u201cc\u201d. Unlike the addition operator used in , the division operator is affected by overflow, as shown in Table 2. The 16-bit value is considered to be negative, since the high bit is set. Thus, the desktop computer and resource-constraint computer examples provide different results that have not been corrected by type conversion expressed in the program as in .","According to embodiments of the present invention, arithmetic expressions are optimized using typed instructions that are optimal based upon the types of operands. The optimization process proceeds until a potential overflow problem is encountered. At this point, instruction inputs are recursively changed from a smaller type to a larger type until the origin of the smaller type is reached. This process repeats until the appropriate type of instructions are chosen so that arithmetic expressions render the same result on desktop computers and on resource-constrained devices with optimized instruction sets.","Turning now to , a flow diagram that illustrates a method for n-base typed arithmetic expression optimization in accordance with one embodiment of the present invention is presented. At , data initialization is performed.  illustrates data initialized at . Block  is performed per instruction, starting with the first instruction and proceeding sequentially. At , instruction inputs are validated. If the inputs to the instruction are different sized types, the smaller-typed inputs are changed to equal the larger-typed inputs. By way of example, if one instruction input is type \u201cint\u201d and another instruction input is type \u201cshort\u201d, the type \u201cshort\u201d instruction input is changed to an \u201cint\u201d type. This process continues recursively until the origin of the smaller type and all of its subsequent instructions are changed to the larger type.","Still referring to , at  the optimized instruction type is determined. At , the instruction is matched with its operand types. If the instruction inputs are a smaller type than the instruction type, the instruction inputs are changed to the larger instruction type. This process of matching an instruction with its operand types continues recursively until the origin of the smaller type and all of its subsequent instructions are changed to the larger type.","Still referring to , at  the output of the converted instruction is set for use when converting subsequent instructions. The actions for reference numerals \u2013 are repeated per remaining instruction. At , a determination is made regarding whether at least one instruction was changed in the last pass through block . If at least one instruction was changed, block  is repeated for the set of instructions being optimized.","Turning now to , a block diagram that illustrates instruction data maintained during expression optimization in accordance with one embodiment of the present invention is presented. The instruction data  may comprise the instruction  and its associated static attributes . The static attributes  may comprise the type of instruction, the number and type of input operands, the operation and the number and type of output operands. The static attributes  may also comprise an indicator of whether the instruction creates potential overflow, an indicator of whether the instruction propagates potential overflow, an indicator of whether the instruction removes potential overflow and an indicator of whether the instruction is sensitive to overflow. The instruction data may also comprise an indication of whether the instruction includes potential overflow , any required minimum type , any input instructions , the original instruction  and the instruction output . The original instruction  may include a link to each consumer instruction . The instruction output  may include a link to the output stack  that may comprise one or more operands associated with the current instruction . The output stack  may also comprise other data associated with one or more source instructions .","It is not necessary for all of the data shown in  to be present to practice the present invention. Furthermore, the data may be interrelated in different ways from that shown in .","Turning now to , a block diagram that illustrates procedure- or method-calling relationships in accordance with one embodiment of the present invention is presented. Converting a program unit such as a method, procedure or the like comprises recording input instructions  and converting each instruction . Converting each instruction  comprises validating input stacks , optimizing the instruction type  to the smallest usable type, validating operand types  and recording the results . Validating input stacks  comprises comparing the input stacks  and changing the operand type  from a smaller instruction type to a larger instruction type when necessary. The change operand type process  proceeds recursively until the source of the smaller instruction type is found. For each instruction encountered during the recursion, the change instruction type process  is invoked to change the type of the instruction. Validating operand type  comprises changing the operand type  if an instruction type is greater than an operand type. Recording results  comprises determining potential overflow  of a converted instruction and generating an output stack  that includes the result of simulating the execution of the converted instruction.","Turning now to , a detailed flow diagram that illustrates a method for n-base typed arithmetic expression optimization in accordance with one embodiment of the present invention is presented. At , an initial stack is created. The initial stack for the first instruction may comprise one or more parameters. The initial stack may also comprise one or more local variables. At , input instructions are recorded. At , an \u201canother pass\u201d flag is set to indicate that another instruction conversion pass is not required. At , the first instruction is obtained. At , the instruction is converted to an optimal type. At , a determination is made regarding whether there are more instructions. If there are more instructions, the next sequential instruction is obtained at  and the instruction is converted at . When the instruction is converted at , the \u201canother pass\u201d flag may be set to \u201ctrue\u201d. If there are no more instructions, at  the \u201canother pass\u201d flag is checked to determine whether another pass is required. If another conversion pass is required, it is initiated at .","For the purposes of this disclosure, the \u201cinput instruction\u201d of a current instruction refers to an instruction that is executed immediately prior to execution of the current instruction. By way of example, the \u201csload <b>\u201d instruction of the following code sequence is an input instruction with respect to the \u201csadd\u201d instruction:\n\n","For the purposes of this disclosure, the \u201cconsumer instruction\u201d of a current instruction refers to an instruction that is executed immediately subsequent to execution of the current instruction. By way of example, the \u201csadd\u201d instruction of the above code sequence is a consumer instruction with respect to the \u201csload <b>\u201d instruction. Other examples of consumer instructions and input instructions are presented herein. Because an input instruction may be a branch instruction, an input instruction may be associated with one or more consumer instructions. Similarly, a consumer instruction may be associated with one or more input instructions. By way of example, in , the \u201cL2: iadd\u201d instruction () has two input instructions: \u201cgoto L2\u201d () and \u201ciload <c>\u201d (). Similarly, \u201cif_eq L1\u201d () has two input consumer instructions: \u201ciload <a>\u201d () and \u201cL1: iload <a>\u201d ().","Turning now to , a flow diagram that illustrates a method for recording input instructions in accordance with one embodiment of the present invention is presented.  provides more detail for reference numeral  of . At , the current instruction is set to the first instruction. At , the current instruction is recorded as an input instruction for each consumer instruction of the current instruction. By way of example, if the current instruction is a branch instruction that sets the program counter to a first address or a second address based upon the state of a variable, the current instruction is recorded as an input instruction for both the instruction located at the first address and the instruction located at the second address. At , a determination is made regarding whether more instructions remain. If more instructions remain, at  the current instruction is set to the next sequential instruction. This process continues until the input instructions for each instruction are recorded.","Turning now to , a flow diagram that illustrates a method for converting an instruction in accordance with one embodiment of the present invention is presented.  provides more detail for reference numeral  of . At , the input stacks for the instruction to be converted are received. The number of input stacks associated with an instruction corresponds to the number of input instructions associated with the instruction. By way of example, if a particular instruction has three input instructions, the instruction has three input stacks, each of which is associated with one of the three input instructions. At , a determination is made regarding whether any of the input stacks are empty or nonexistent. If any of the input stacks are null, then the corresponding input instruction has not yet been converted and an indication that another pass is required is set at . If at least one input stack is non-empty, the input stacks are validated at  to ensure that corresponding entries in input stacks have the same types and to ensure that the input stacks have the correct number of operands and type of operands. At , the instruction type is optimized based on instruction inputs to determine the smallest usable instruction type. At , the operand types are matched with the instruction type to ensure that the types of operands in the input stack are compatible with the instruction requirements. At , the results are recorded by performing the operations of the instructions on the stack.","Turning now to , a flow diagram that illustrates a method for validating input stacks in accordance with one embodiment of the present invention is presented.  provides more detail for reference numeral  of . At , if the current instruction is associated with multiple input stacks, the input stacks are compared to determine whether corresponding entries in each input stack have equivalent types and that the types are the same size. At , one of the input stacks is received. At , a determination is made regarding whether the input stack has the correct number of operands. An input stack has the correct number of operands if the number of operands in the input stack is at least as much as the number of operands defined for the current instruction. By way of example, if the current instruction is \u201ciadd\u201d and the \u201ciadd\u201d instruction adds two numbers, the input stack has the correct number of operands if the input stack comprises two or more operands. If the input stack has the correct number of operands, at  a determination is made regarding whether all operands have a valid type. An operand has a valid type if the operand type is defined for the current instruction. By way of example, if the current instruction were a compare instruction that accepts a boolean operand, an input stack having a single pointer-type operand would be invalid. If the operand has an invalid type or if the input stack has an incorrect number of operands, an error is indicated at  and instruction conversion terminates.","Turning now to , a flow diagram that illustrates a method for comparing input stacks in accordance with one embodiment of the present invention is presented.  provides more detail for reference numeral  of . At , a determination is made regarding whether the stack entries of each input stack have equivalent types. Stack entries of multiple input stacks have equivalent types if the types of corresponding stack entries of each stack are equivalent. By way of example, an input stack having two integer type entries is equivalent to another input stack having two integer type entries, but it is not equivalent to an input stack having two boolean type entries. If the stack entries of each input stack do not have equivalent types, a failure indication is made at  and instruction conversion terminates. If the stack entries of each input stack have equivalent types, at  a determination is made regarding whether any stack entries have a smaller type than corresponding entries in other input stacks. By way of example, a stack entry of type \u201cshort\u201d is smaller than a stack entry of type \u201cint\u201d. If any stack entries have a smaller type than corresponding entries in other input stacks, the operand type for the input instruction is changed to the larger type at . Using the above example, the \u201cshort\u201d stack entry would be changed to an \u201cint\u201d stack entry.","Turning now to , a flow diagram that illustrates a method for optimizing an instruction type in accordance with one embodiment of the present invention is presented.  provides more detail for reference numeral  of . At , if a required minimum type has been set, the instruction type is set to the required minimum type. Otherwise, the instruction type is set to the smallest usable type. By way of example, if the original instruction is \u201ciadd\u201d which requires operands of type \u201cint\u201d, the instruction type is set to \u201cshort\u201d and the corresponding instruction is \u201csadd\u201d. Block  is performed per input stack and block  is performed per operand in an input stack. The operand processing begins at , where a determination is made regarding whether the instruction type that was set at  is less than the operand type. By way of example, if the instruction type is \u201cshort\u201d and the operand type is \u201cint\u201d, the instruction type is less than the operand type. If the instruction type is less than the operand type, at  the instruction type is set to the operand type. Using the above example, the instruction type is set to \u201cint\u201d and the corresponding instruction is \u201ciadd\u201d. If the instruction type is greater than or equal to the operand type, at  a determination is made regarding whether the instruction type is the same as the operand type. By way of example, if the instruction type is \u201cint\u201d and the operand type is \u201cint\u201d, the instruction type is the same as the operand type. If the instruction type is greater than the operand type or if the operand has no potential overflow or if the operand has potential overflow but the instruction is insensitive to overflow, no optimization is performed. An operand may carry potential overflow if it was created by one of the operators listed in Table 1, or if it is created by an operator that propagates overflow in an operand. Operators that propagate overflow include, by way of example, the \u201cand\u201d, \u201cor\u201d and exclusive \u201cor\u201d (xor) operators.","Still referring to , if the instruction type is equal to the operand type () and the operand has potential overflow () and the instruction is sensitive to overflow (), at  a determination is made regarding whether the instruction type is less than the original (before conversion) instruction type. The Java\u2122 bytecodes that are sensitive to overflow are listed in Table 2. Those of ordinary skill in the art will recognize that the list of operators affected by overflow may vary for different high-level languages, and that this invention may be applied to these other languages as well. If the instruction type is less than the original instruction type, the instruction type is set to the next larger type (). By way of example, if the instruction type is \u201cshort\u201d and the original instruction type is \u201cint\u201d, the instruction type is set to \u201cint\u201d. If the instruction type is not less than the original instruction type, no optimization is performed.","Turning now to , a flow diagram that illustrates a method for matching operand types with an instruction type in accordance with one embodiment of the present invention is presented.  provides more detail for reference numeral  of . At , the instruction type is received. Block  is repeated per input stack associated with the instruction and block  is repeated per operand in an input stack. Operand processing begins at , where a determination regarding whether the instruction type is greater than the operand type is made. If the instruction type is greater than the operand type, the input instruction that generates the operand is received at  and at  the operand type of the input instruction is changed to the instruction type that was received at .","Turning now to , a flow diagram that illustrates a method for changing an operand type in accordance with one embodiment of the present invention is presented.  provides more detail for reference numeral  of  and reference numeral  of . This method is used to recursively follow the chain of operand creation to change the origin of a smaller type and all of its subsequent instructions to a larger type. At , a determination is made regarding whether a received instruction generates a received operand. An instruction generates an operand if execution of the instruction results in creation of the operand. If the instruction generates the operand, the instruction type of the received instruction is changed to a received type at . If the instruction does not generate the operand, the operand type for each input instruction of the received instruction is recursively changed to the received type at . At , the results are recorded.","Turning now to , a flow diagram that illustrates a method for changing an instruction type in accordance with one embodiment of the present invention is presented.  provides more detail for reference numeral  of . At , a determination is made regarding whether the instruction type of a received instruction equals a received type. If the instruction type of the received instruction is not the same as the received type, the minimum required type is set to the received type at . The minimum required type may be used to force a minimum type in subsequent instruction conversions. At , the instruction type of the received instruction is set to generate output with the operand equal to the received type.","Still referring to , block  is repeated per input stack associated with the instruction. At , the input instruction associated with a particular input stack is received. Block  is repeated per incorrect operand in the input stack. At , the operand type of an incorrect operand is changed to the required minimum type set at . At , the results are recorded.","Turning now to , a flow diagram that illustrates a method for recording results in accordance with one embodiment of the present invention is presented.  provides more detail for reference numeral  of , reference numeral  of  and reference numeral  of . At , potential overflow generated by the current instruction is determined. At , an output stack is generated.",{"@attributes":{"id":"p-0116","num":"0127"},"figref":["FIGS. 24A and 24B","FIG. 24A","FIG. 24B"]},"Turning now to , a flow diagram that illustrates a method for determining potential overflow in accordance with one embodiment of the present invention is presented.  provides more detail for reference numeral  of . At , a flag that indicates the potential for overflow is initialized to \u201cfalse\u201d. The flag is set to \u201ctrue\u201d if the instruction type of the converted instruction is not the same as the original instruction type () before conversion, if the instruction does not remove potential overflow () and if the instruction creates potential overflow (). Operators with a potential to create overflow are shown in Table 1. If the instruction does not create potential overflow but instead propagates potential overflow (), the flag is set to \u201ctrue\u201d () if any operand on any input stack associated with the instruction has potential overflow ().","Turning now to , a flow diagram that illustrates a method for determining potential overflow in accordance with one embodiment of the present invention is presented.  is similar to  except that  examines the instruction to determine whether it creates potential overflow (), whereas  determines whether overflow is possible based on the operation and the relationship between the input type and the result type (). The Java Card\u2122 result types and overflow indications returned are summarized in tables 3 to 10, below. The tables are organized according to the type of instruction. Each table indicates the result type and the overflow indication based upon the types of one or two operands.",{"@attributes":{"id":"p-0119","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Addition, Multiplication, and Subtraction"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type(A)","and\/or","type(B)","Result Type","Overflow"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]},{"entry":[{},"byte","and","byte","short","false"]},{"entry":[{},"int","or","int","int","false"]},{"entry":[{},"others",{},{},"short","true"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0120","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Division"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type(A)","and\/or","type(B)","Result Type","Overflow"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]},{"entry":[{},"byte","and","byte","short","false"]},{"entry":[{},"byte","and","short","short","false"]},{"entry":[{},"int","or","int","int","false"]},{"entry":[{},"others",{},{},"short","true"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0121","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Left Shift"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type(A)","Result Type","Overflow"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"byte","short","true"]},{"entry":[{},"short","short","true"]},{"entry":[{},"int","int","false"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0122","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Right Shift"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type(A)","Result Type","Overflow"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"byte","byte","false"]},{"entry":[{},"short","short","false"]},{"entry":[{},"int","int","false"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0123","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Negate"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type(A)","Result Type","Overflow"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"byte","short","false"]},{"entry":[{},"short","short","true"]},{"entry":[{},"int","int","false"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0124","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 8"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Unsigned Right Shift"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type(A)","Result Type","Overflow"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"byte","short","true"]},{"entry":[{},"short","short","true"]},{"entry":[{},"int","int","false"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0125","num":"0136"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 9"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Remainder"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"type(A)","and\/or","type(B)","Result Type","Overflow"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]},{"entry":[{},"int","or","int","int","false"]},{"entry":[{},"others",{},{},"short","false"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0126","num":"0137"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 10"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"and, or, xor"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["type(A)","and\/or","type(B)","Result Type","Overflow"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["byte","and","byte","byte","false"]},{"entry":["int","or","int","int","false"]},{"entry":["others",{},{},"short","=overflow(operands)"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"Suppose the operation of the instruction being converted is 16-bit integer addition (\u201csadd\u201d in Java Card\u2122 technology). According to Table 3, if both inputs to the addition operation are of type \u201cbyte\u201d, no overflow results from the operation. No overflow is results in this case because while adding two 8-bit \u201cbyte\u201d values may overflow an 8-bit \u201cbyte\u201d result, the same addition cannot overflow a 16-bit \u201cshort\u201d result.","Although Tables 3\u201310 illustrate the use of Java Card\u2122 result types and overflow indications, the invention may be applied to other computer languages having a similar size relationship between integer types. In more detail, the invention is applicable to any computer language supporting two or more integer types of different sizes. By way of example, the invention is applicable to a computer language supporting four integer types, wherein the size of a first integer type is less than the size of a second integer type, the size of the second integer type is less than the size of a third integer type and the size of the third integer type is less than the size of a fourth integer type. As an additional example, the invention is applicable to a computer language supporting three integer types, wherein the size of a first integer type is half the size of a second integer type and wherein the size of the second integer type is half the size of a third integer type.","Turning now to , a flow diagram that illustrates a method for generating an output stack in accordance with one embodiment of the present invention is presented.  provides more detail for reference numeral  of . At , any input stack is copied. At , the stack is updated based on the operation of the instruction. By way of example, before performing an \u201ciadd\u201d operation, the corresponding input stack will have at least two operands on the stack. The \u201ciadd\u201d instruction removes the top two stack entries, adds them and puts the result (which has the same type as the two operands) on the stack. Thus in this example, at  the two stack entries representing the two operands are replaced with one entry representing the result of the \u201ciadd\u201d operation. At , a determination is made regarding whether an output stack for the instruction already exists. If an output stack for the instruction already exists, at  a determination is made regarding whether the new stack is the same as the existing stack. If the new stack is not the same as the existing stack, at  an indication that another conversion pass is required is made. This ensures that consumers of the instruction are updated based on the new results. At , the new output stack is saved, replacing any existing output stack.",{"@attributes":{"id":"p-0130","num":"0141"},"figref":"FIGS. 26\u201332"},"The examples illustrated in  demonstrate application of the present invention in optimizing an expression to smaller type instructions (), handling an expression that cannot be optimized to smaller type instructions (), converting an instruction with multiple input stacks () and converting an instruction with multiple consumer instructions ().","The examples illustrated in  demonstrate application of the present invention within the context of Java\u2122 and Java Card\u2122 technology. As such, Java\u2122 bytecode is optimized into Java Card\u2122 bytecode. Those of ordinary skill in the art will recognize that the invention may be applied to other computer languages.","Turning now to , a block diagram that illustrates conversion of an arithmetic expression that can be optimized to smaller type instructions in accordance with one embodiment of the present invention is presented. In , the conversion process is applied to the Java\u2122 expression\n\n=(short) ((short) ()\/)\n\nwhere the values \u201ca\u201d, \u201cb\u201d and \u201cc\u201d are of type \u201cshort\u201d. The Java\u2122 bytecode sequence for this expression is shown at reference numeral .\n","Instruction conversion begins with the source Java\u2122 bytecode shown at reference numeral , processing each instruction in sequence. The results of optimizing are shown in Java Card\u2122 bytecodes at reference numeral . Beginning with the first instructions, the \u201ciload <a>\u201d instruction () and \u201ciload <b>\u201d instruction () both operate on local variables, \u201ca\u201d and \u201cb\u201d, declared as type \u201cshort\u201d. Therefore, these instructions are optimized to the Java Card\u2122 load instructions of type \u201cshort\u201d as shown at reference numerals  (\u201csload <a>\u201d) and  (\u201csload <b>\u201d). Because the \u201csload <a>\u201d and \u201csload <b>\u201d inputs to the \u201ciadd\u201d instruction at reference numeral  are both type \u201cshort\u201d, the \u201ciadd\u201d instruction is optimized to the Java Card\u2122 type short add bytecode \u201csadd\u201d, as shown at reference numeral . The \u201ci2s\u201d instruction at reference numeral  converts an \u201cint\u201d value to a \u201cshort\u201d value in the Java\u2122 bytecode. Because the Java Card\u2122 \u201csadd\u201d instruction () already outputs a \u201cshort\u201d value, this conversion instruction is not needed in the result bytecode. In addition, as specified in Table 1, the addition instruction creates overflow, but the subsequent bytecode \u201ci2s\u201d () removes the potential overflow. Therefore, the \u201csadd\u201d output of the Java Card\u2122 bytecode does not contain potential overflow. The \u201ciload <c>\u201d instruction () is converted to the \u201csload <c>\u201d instruction () for the same reason described above. The inputs to the \u201cidiv\u201d instruction () are the \u201csadd\u201d instruction () and the \u201csload <c>\u201d instruction (). Since both of these inputs render short type results, the \u201cidiv\u201d instruction () is optimized to the \u201csdiv\u201d instruction (). The \u201csdiv\u201d instruction () is sensitive to overflow as indicated in Table 2, however neither inputs (\u201csadd\u201d where the original Java\u2122 bytecode contained an explicit cast to \u201cshort\u201d, and \u201csload <c>\u201d) contain potential overflow. The \u201ci2s\u201d instruction at reference numeral  is discarded for the same reason as the \u201ci2s\u201d instruction at reference numeral . Finally, the \u201cistore <c>\u201d instruction at reference numeral  is optimized to the \u201csstore <c>\u201d instruction at reference numeral  for the same reasons as described above for other local variables.","To further aid in an understanding of the present invention, the example illustrated in  and discussed above will now be described in more detail, with reference to . Referring to , an initial stack is created at . The initial stack for the first instruction  comprises entries for variables \u201ca\u201d, \u201cb\u201d and \u201cc\u201d. The initial stack may also comprise one or more local variables and one or more parameters. At , input instructions are recorded. Instructions , , , , ,  and  are input instructions with respect to instructions , , , , ,  and , respectively. At , a flag that indicates whether another conversion pass is required is initialized to \u201cfalse\u201d. At , the first instruction (\u201ciload <a>\u201d ) is obtained. At , the \u201ciload <a>\u201d instruction  is converted to the \u201csload <a>\u201d instruction . The remaining instructions , , , , ,  and  are converted at . After all instructions have been converted, the flag that indicates whether another conversion pass is required will be \u201cFalse\u201d as demonstrated in the description below, thus ending the method conversion process.","Referring to , conversion of the first instruction (\u201ciload <a>\u201d  of ) begins with obtaining the input stack. At  the input stack is not empty since it contains at least the local variables \u201ca\u201d, \u201cb\u201d and \u201cc\u201d, so the input stack is validated at . At , the \u201ciload <a>\u201d instruction type is optimized as illustrated in . At , the instruction type is set to the smallest usable type (\u201cshort\u201d) because the variable \u201ca\u201d is type \u201cshort\u201d. The corresponding instruction is \u201csload <a>\u201d.","Referring again to , at  the operand types are matched with the instruction type as illustrated in . The \u201csload\u201d instruction has no operands, so there is nothing to match at . At , the \u201csload\u201d instruction type (\u201cshort\u201d) is obtained.","Referring again to , at  the conversion results are recorded as illustrated in . At , potential overflow is determined. Potential overflow may be determined as illustrated in . At , a \u201cpotential overflow\u201d flag is set to \u201cfalse\u201d. At  the \u201csload <a>\u201d instruction type (\u201cshort\u201d) does not equal the original instruction type (\u201cint\u201d), at  the \u201csload\u201d instruction does not remove potential overflow, at  \u201csload\u201d instruction does not create potential overflow and at  the \u201csload\u201d instruction does not propagate potential overflow. Thus, the \u201cpotential overflow\u201d flag remains \u201cfalse\u201d. The operand does not propagate potential overflow at  because the operand was loaded directly from a local variable and thus was not created by an operation that creates overflow. At , an output stack is generated as illustrated in .","Alternatively, potential overflow may be determined as illustrated in . At , overflow is not possible based on the operator (\u201csload\u201d) and the relationship between the input type (\u201cshort\u201d) and the result type (\u201cshort\u201d).","Referring to , at  the input stack is updated based upon operation of the \u201csload\u201d instruction. The \u201csload\u201d instruction loads a \u201cshort\u201d value and places it on the stack, so an entry representing a \u201cshort\u201d value is placed on the input stack.","The \u201ciload <b>\u201d instruction (reference numeral  of ) is processed in a manner similar to that of the \u201ciload <a>\u201d instruction , resulting in an \u201csload <b>\u201d instruction  and an input stack with two short-type entries: One entry representing the \u201csload <a>\u201d result and one entry representing the \u201csload <b>\u201d result.","Next, the \u201ciadd\u201d instruction (reference numeral  of ) is processed. Referring to , the input stacks are validated at . There is only a single input stack, so reference number  is skipped. Since at  the \u201ciadd\u201d instruction takes two operands and there are two operands on the stack (\u201csload <a>\u201d result and \u201csload <b>\u201d result) and since at  the two stack entries represent integer types, an indication that the input stack has been successfully validated is made at .","Referring again to , the \u201ciadd\u201d instruction type (\u201cint\u201d) is optimized at . At , the instruction type is set to the smallest usable type (\u201cshort\u201d). The corresponding instruction is \u201csadd\u201d. The following checks are performed for both the \u201csload <a>\u201d result and \u201csload <b>\u201d result operands. At  and , the \u201csadd\u201d instruction type (\u201cshort\u201d) equals the operand type (\u201cshort\u201d). At , the operand (both \u201csload <a>\u201d result and \u201csload <b>\u201d result) was loaded directly from a local variable so it does not have potential overflow, and optimization of the instruction ends.","Referring again to , the operand types are matched at . For both the \u201csload <a>\u201d result and \u201csload <b>\u201d result operands, at  the instruction type (\u201csadd\u201d) is not greater than the operand type (\u201cshort\u201d), so validation of the operand types ends.","Referring again to , the results are recorded at . Referring to , at potential overflow is determined at . The Java Card\u2122 result types and overflow indications returned are summarized in tables 3 to 10, above.","Referring again to , potential overflow is determined at . Because according to Table 3 the \u201csadd\u201d instruction creates potential overflow, an indication that the result has potential overflow is made at reference numeral  of . At , the output stack is generated. At , the input stack is updated to remove the \u201cshort\u201d-type entries representing the \u201csload <a>\u201d result and \u201csload <b>\u201d result and replaced with a \u201cshort\u201d-type entry representing the \u201csadd\u201d result.","Next, the \u201ci2s\u201d instruction (reference numeral  of ) is processed. The \u201ci2s\u201d instruction is a type conversion instruction. At reference numeral  of , the instruction type is set to the smallest usable type. Since both the operand type (\u201cshort\u201d) and the instruction type are the same, potential overflow is eliminated, obviating the need for a type conversion instruction.","Next, the \u201ciload <c>\u201d instruction (reference numeral  of ) is processed. Like values \u201ca\u201d and \u201cb\u201d, \u201cc\u201d is of type \u201cshort\u201d and the \u201ciload <c>\u201d instruction is converted to an sload <c> instruction. Next, the \u201cidiv\u201d instruction is processed. As specified in Table 2, \u201cidiv\u201d is an instruction that may be affected by overflow. The \u201ca+b\u201d result operand does not carry potential overflow due to the explicit source-level cast to \u201cshort\u201d (), so the optimized divide instruction type is determined to be type \u201cshort\u201d at reference numeral . The corresponding instruction is \u201csdiv\u201d.","Next, the second \u201ci2s\u201d instruction (reference numeral  of ) is processed. At reference numeral  of , the instruction type is set to the smallest usable type. Since both the operand type (\u201cshort\u201d) and the \u201ci2s\u201d instruction type (\u201cshort\u201d) are the same, potential overflow is eliminated, obviating the need for a type conversion instruction.","Finally, the \u201cistore <c>\u201d instruction (reference numeral  of ) is processed. Since the minimum type is type \u201cshort\u201d and the input from \u201csdiv\u201d does not carry overflow, the \u201cistore <c>\u201d instruction  is optimized to a \u201csstore <c>\u201d instruction  at reference numeral  of . The converted bytecodes are shown at reference numeral  of .",{"@attributes":{"id":"p-0151","num":"0162"},"figref":["FIGS. 27 and 28","FIG. 27","FIG. 28"]},"Turning now to , a high-level block diagram that illustrates conversion of an arithmetic expression that cannot be optimized to smaller type instructions in accordance with one embodiment of the present invention is presented.  illustrates the conversion process for the Java\u2122 expression\n\n(short)((2)\/)\n\nwhere the values \u201ca\u201d, \u201cb\u201d and \u201cc\u201d are of type \u201cshort\u201d. The Java\u2122 bytecode sequence for this expression is shown at reference numeral . Note that expression  of  is similar to expression  of  except that the result of the addition operation is explicitly cast to \u201cshort\u201d () in expression , whereas expression  is not explicitly cast. Conversion of expression  proceeds in a manner similar to the conversion of expression  until conversion of the \u201cidiv\u201d instruction . At this point, the input stack comprises entries for the \u201csload <b>\u201d result and the \u201csadd\u201d result (a+2). Value \u201cb\u201d was loaded directly from a local variable via the \u201csload <b>\u201d instruction  and thus does not carry potential overflow. The \u201csadd\u201d result carries potential overflow that has not been removed by an explicit cast to \u201cshort\u201d. Since the \u201csadd\u201d result carries potential overflow and since the \u201cidiv\u201d instruction is sensitive to overflow as indicated in Table 2, the instruction type is set to \u201cidiv\u201d. Since the \u201cidiv\u201d instruction requires inputs of type \u201cint\u201d, both inputs from \u201csload <b>\u201d and \u201csadd\u201d are changed to type \u201cint\u201d. Forcing a larger type for \u201csadd\u201d result in turn requires forcing a larger type for its corresponding inputs \u201csload <a>\u201d and \u201csconst2\u201d. Conversion continues with the \u201ci2s\u201d instruction  and the \u201cistore <c>\u201d instruction .\n","Turning now to , a detailed block diagram that illustrates instruction conversion of an arithmetic expression that cannot be optimized to smaller type instructions in accordance with one embodiment of the present invention is presented.  provides more detail for . Sequence 1 () shows the original Java\u2122 bytecode. In sequence 2 (), the initial results of conversion render \u201cshort\u201d-type instructions. When the divide operation is encountered, an \u201cint\u201d-type divide instruction (\u201cidiv\u201d) is generated because one of the inputs (\u201csadd\u201d result) has potential overflow from a \u201cshort\u201d-type value and the divide operation is sensitive to overflow. The \u201cint\u201d-type divide (\u201cidiv\u201d) forces each input operand to become type \u201cint\u201d. In sequence 2 (), this conversion is triggered for the \u201cshort\u201d-type addition instruction \u201csadd\u201d, rendering an \u201cint\u201d-type addition instruction (\u201ciadd\u201d)","The \u201cint\u201d-type addition instruction (\u201ciadd\u201d) forces each input operand to become \u201cint\u201d-type. In sequence 3 (), this conversion is triggered for the \u201cshort\u201d-type load instruction of variable \u201ca\u201d (\u201csload <a>\u201d), rendering a conversion instruction from \u201cshort\u201d-type to \u201cint\u201d-type (\u201csload <a>\u201d; \u201cs2i\u201d), resulting in an \u201cint\u201d-type constant instruction (iconst2).","The \u201cint\u201d-type addition instruction (\u201ciadd\u201d) forces each input operand to become \u201cint\u201d-type. In sequence 4 (), this conversion is triggered for the \u201cshort\u201d-type constant instruction (sconst2).","The \u201cint\u201d-type divide instruction (\u201cidiv\u201d) forces each input operand to become \u201cint\u201d-type. In sequence 5 (), this conversion is triggered for the \u201cshort\u201d-type load instruction of variable \u201cb\u201d (\u201csload <b>\u201d), rendering a conversion instruction from \u201cshort\u201d- to \u201cint\u201d-type (\u201csload <b>\u201d; \u201cs2i\u201d). In sequence 6, conversion continues through the end of the code sequence.","To further aid in an understanding of the present invention, the example illustrated in  and discussed above will now be described in more detail, with reference to  and . As mentioned above, the initial results of conversion render \u201cshort\u201d-type instructions. When the divide operation (\u201cidiv\u201d) is encountered, at  the instruction type is set to \u201cshort\u201d, the smallest possible instruction type. Next, each operand is checked for potential overflow. Checking the \u201csadd\u201d result operand proceeds as follows. At , the instruction type of \u201csdiv\u201d (\u201cshort\u201d) is not less than the operand type for \u201csadd\u201d (\u201cshort\u201d). At , the \u201csdiv\u201d instruction type (\u201cshort\u201d) equals the \u201csadd\u201d operand type (\u201cshort\u201d). At , the \u201csadd\u201d operand has potential overflow, as indicated in Table 2. At , the \u201csdiv\u201d instruction is sensitive to overflow, as indicated in Table 1. At , the \u201csdiv\u201d instruction type (\u201cshort\u201d) is less than the original instruction type (\u201cint\u201d). Thus, at , the instruction type is set to the next largest type (\u201cint\u201d). The corresponding instruction in this example is \u201cidiv\u201d.","Checking the \u201csload <b>\u201d operand proceeds as follows. At  the \u201cidiv\u201d instruction type (\u201cint\u201d) is not less than the operand type (\u201cshort\u201d). At  the instruction type (\u201cint\u201d) is also not equal to the operand type (\u201cshort\u201d), so optimization of the current instruction terminates.","Next, the operand types for the \u201cidiv\u201d instruction are matched at . At , the instruction type for \u201cidiv\u201d is int.","The \u201cidiv\u201d instruction has two operands: the \u201csadd\u201d result and the \u201csload <b>\u201d result. Validation of the \u201csadd\u201d result operand proceeds as follows. At , the \u201cidiv\u201d instruction type (\u201cint\u201d) is greater than the operand type (\u201cshort\u201d). At  the input instruction (\u201csload <b>\u201d) is obtained. At , the operand type (\u201cshort\u201d) of the \u201csadd\u201d result operand is changed to the \u201cidiv\u201d instruction type (\u201cint\u201d).","Changing the operand type of the \u201csadd\u201d result operand proceeds as follows. At , the \u201csload <b>\u201d instruction does not generate the \u201csadd\u201d result. At , the input instruction (\u201csadd\u201d) is obtained. At , the operand type (\u201cshort\u201d) of the input instruction (\u201csadd\u201d) is changed to the instruction type (\u201cint\u201d).","Changing the operand type proceeds as follows. The instruction (\u201csadd\u201d) generates the operand (\u201csadd\u201d result), so at  the instruction type of the \u201csadd\u201d instruction is changed to the instruction type (\u201cint\u201d).","Changing the instruction type proceeds as follows. At  the \u201csadd\u201d instruction type (\u201cshort\u201d) is not equal to the desired type (\u201cint\u201d). At  the minimum required type is set to the desired type (\u201cint\u201d). At  the instruction type is set to \u201cint\u201d. The corresponding instruction is \u201ciadd\u201d, the \u201cint\u201d-based addition instruction that generates an \u201cint\u201d-type result. Sequence 3 () is next in the example illustrated in .","Next, the operand type of each incorrect operand in each input stack is changed to the desired type (\u201cint\u201d). The \u201csadd\u201d instruction has two input operands: \u201csload <a>\u201d and sconst2. Changing the operand type for the \u201csload <a>\u201d operand proceeds as follows. At , the input instruction is set to \u201csconst2\u201d. At  the operand type for the \u201csload <a>\u201d operand is changed to the desired type (\u201cint\u201d).","The \u201cchange operand type\u201d process proceeds as follows. At , the \u201csconst2\u201d instruction does not generate the \u201csload <a>\u201d result. At , the input instruction of the \u201csconst2\u201d instruction (\u201csload <a>\u201d) is obtained. At , the operand type (\u201cshort\u201d) of the \u201csload <a>\u201d result operand is changed to the instruction type (\u201cint\u201d).","Changing the operand type proceeds as follows. At , the \u201csload <a>\u201d instruction generates the \u201csload <a>\u201d result so at  the instruction type of the \u201csload <a>\u201d instruction is changed to the desired type (\u201cint\u201d).","Changing the instruction type proceeds as follows. At  the \u201csload <a>\u201d instruction type (\u201cshort\u201d) is not equal to the desired type (\u201cint\u201d), so the minimum required type is set to the desired type (\u201cint\u201d) at . At  the instruction type is set to \u201cint\u201d. The corresponding instruction sequence is \u201csload <a>; s2i\u201d. Since \u201csload <a>\u201d has no input operands, the block at  is skipped. At  the results are associated with the (\u201csload <a>; s2i\u201d) instruction sequence.","Changing the operand type for the \u201csconst2\u201d operand of the \u201csadd\u201d instruction proceeds as follows. At , the input instruction is set to \u201csconst2\u201d. At  the operand type for the \u201csconst2\u201d operand is changed to the desired type (\u201cint\u201d).","Changing the operand type proceeds as follows. At , the \u201csconst2\u201d instruction generates the \u201csconst2\u201d result so at  the instruction type of the \u201csconst2\u201d instruction is changed to the desired type (\u201cint\u201d).","Changing the instruction type proceeds as follows. At  the instruction type (\u201cshort\u201d) is not equal to the desired type (\u201cint\u201d), so the minimum required type is set to the desired type (\u201cint\u201d) at . At  the instruction type is set to \u201cint\u201d. The corresponding instruction is \u201ciconst2\u201d. At  the results are associated with the \u201ciconst2\u201d instruction.","At , the results of changing the instruction type for the \u201ciadd\u201d instruction are stored. Sequence 3 () is next in the example illustrated in .","Validation of the \u201csload <b>\u201d result operand proceeds as follows. At , the \u201cidiv\u201d instruction type (\u201cint\u201d) is greater than the \u201csload <b>\u201d result operand type (\u201cshort\u201d). At , the input instruction (\u201csload <b>\u201d) is obtained. At , the operand type (\u201cshort\u201d) of the input instruction (\u201csload <b>\u201d) is changed to the \u201cidiv\u201d instruction type (\u201cint\u201d).","Changing the \u201csload <b>\u201d result operand type proceeds as follows. At  the \u201csload <b>\u201d instruction generates the \u201csload <b>\u201d result operand, so at  the instruction type of the input instruction (\u201csload <b>\u201d) is changed to \u201cint\u201d.","Changing the instruction type proceeds as follows. At  the \u201csload <b>\u201d instruction type (\u201cshort\u201d) is not equal to the desired type (\u201cint\u201d), so at  the minimum required type is set to the desired type (\u201cint\u201d). At  the instruction type is set to generate output with an operand equal to the desired type (\u201cint\u201d). In this case, the required output is generated by the instruction sequence (\u201csload <b>; s2i\u201d). Since \u201csload <b>\u201d does not have input operands, block  is skipped. Results are recorded at . Sequence 6 () is next in the example illustrated in . Instruction conversion continues with conversion of the \u201ci2s\u201d instruction and ends with the conversion of the \u201cistore <c>\u201d instruction.","A second pass through the code segment will occur because instructions were changed during the first pass, resulting in the \u201canother pass flag\u201d being set at reference numeral  of . During the second pass, all of the instructions that had been set to \u201cint\u201d type will remain that type based on the assignment to \u201cRequired minimum type\u201d at reference numeral  of . This completes the example of  resulting in the bytecode of sequence 7 ().","Turning now to , a block diagram that illustrates instruction conversion where input stacks do not match in accordance with one embodiment of the present invention is presented. In , \u201cint\u201d-based source instructions  are converted to \u201cshort-based instructions beginning with the \u201ciload <x>\u201d instruction . Conversion proceeds up to the \u201ciadd\u201d instruction . The \u201ciadd\u201d instruction  has two input instructions: the \u201cgoto L2\u201d instruction  and the \u201ciload <c>\u201d instruction . However, the input stacks associated with the two input instructions do not match. The input stack associated with the \u201cgoto L2\u201d instruction  comprises a variable of type \u201cint\u201d (\u201ciload <a>\u201d result) and a variable of type \u201cshort\u201d (\u201csload <b>\u201d result), while the input stack associated with the \u201ciload <c>\u201d instruction  comprises two variables of type \u201cint\u201d (\u201ciload <a>\u201d result and \u201ciload <c>\u201d result). Accordingly, the stacks are made the same by changing the operand type of the \u201cgoto L2\u201d instruction  to the \u201cint\u201d type, which in turn changes the operand type of the \u201csload <b>\u201d instruction  to the \u201cint\u201d type, which in turn changes the instruction type of the \u201csload <b>\u201d instruction  to the \u201cint\u201d type. The corresponding instruction is \u201csload <b>; s2i\u201d. Conversion continues with the conversion of the \u201cistore <d>\u201d instruction .","Turning now to , a detailed block diagram that illustrates instruction conversion where input stacks do not match in accordance with one embodiment of the present invention is presented.  provides more detail for . Conversion occurs as discussed above up to item  in sequence 2 () of the example. At , input stacks are compared for the \u201ciadd\u201d instruction. At  the stack entries have equivalent types, since types \u201cshort\u201d and \u201cint\u201d are both \u201cinteger\u201d types. At  an input stack entry has a type that is smaller than other corresponding input stack entries. In particular, entry  from input stack  is of type \u201cshort\u201d, while corresponding entry  from input stack  is of type \u201cint\u201d. At  the operand type for the input instruction (\u201cgoto L2\u201d instruction ) is changed to the larger type (\u201cint\u201d).","Changing the operand type of the input instruction \u201cgoto L2\u201d  proceeds as follows. At  the \u201cgoto L2\u201d instruction  does not generate the \u201csload <b>\u201d result, so at  the operand type of the input instruction of the \u201cgoto L2\u201d instruction (\u201csload <b>\u201d) is changed to the larger type (\u201cint\u201d) and at  the results are associated with the \u201cgoto L2\u201d instruction.","Changing the operand type of the input instruction \u201csload <b>\u201d proceeds as follows. At  the \u201csload <b>\u201d instruction generates the \u201csload <b>\u201d result, so at  the operand type of the input instruction (\u201csload <b>\u201d) is changed to the larger type (\u201cint\u201d) and at  the results are associated with the \u201csload <b>\u201d instruction.","Changing the instruction type of the input instruction \u201csload <b>\u201d proceeds as follows. At  the instruction type (\u201cshort\u201d) of the input instruction (\u201csload <b>\u201d) is not equal to the larger type (\u201cint\u201d), so at  the minimum required type is set to the larger type (\u201cint\u201d). At  the instruction type is set to \u201cint\u201d. The corresponding instruction is \u201csload <b>; s2i\u201d. The block at  is skipped since load instructions to not have input operands. At  the results are associated with the \u201csload <b>\u201d instruction. Sequence 3 () is next in the example illustrated in . Conversion in sequence 3 () and sequence 4 () proceeds as discussed above.",{"@attributes":{"id":"p-0181","num":"0192"},"figref":"FIGS. 31 and 32"},"Turning now to , a block diagram that illustrates conversion of an instruction that has multiple consumers in accordance with one embodiment of the present invention is presented. Instruction conversion proceeds up to the \u201cdup_x1\u201d instruction , converting \u201cint\u201d-based instructions and operands to the smallest usable type (\u201cshort\u201d) wherever possible. At this point, the top item on the stack is the \u201csload <b>\u201d result and the second-from-top item is the \u201csload <a>\u201d result. The \u201cdup_x1\u201d instruction  is converted to a \u201cdup_x11\u201d in duplicates the top word (\u201csload <b>\u201d result) on the stack and inserts the duplicate one word down in the stack. The \u201cimul\u201d instruction  is converted to an \u201csmul\u201d instruction that pops the top two items from the stack, multiplies them and puts the result on the stack. At this point, the stack comprises two entries. The top entry corresponds to the \u201csmul\u201d result and the bottom entry corresponds to the \u201csload <b>\u201d result duplicated by the \u201cdup_x 1\u201d instruction. The \u201ci2s\u201dinstruction is not required because the top item on the stack is already a \u201cshort\u201d-type and the \u201cistore <c>\u201d instruction  is converted to a \u201csstore <c>\u201d instruction that pops the \u201cshort\u201d-type \u201csmul\u201d result from the stack and stores it in the variable \u201cc\u201d. At this point, the stack comprises only the \u201csload <b>\u201d result duplicated by the \u201cdup_x1\u201d instruction. The \u201ciload <d>\u201d instruction  cannot be converted to a smaller type because \u201cd\u201d is declared as an \u201cint\u201d type. The \u201ciload <d>\u201d instruction  pushes the \u201cint\u201d-typed \u201cd\u201d value on the top of the stack, leaving the \u201cshort\u201d-typed \u201csload <b>\u201d result at the bottom of the stack. The \u201ciadd\u201d instruction  cannot be optimized to a smaller type because one of its operands (\u201ciload <d>\u201d result) is \u201cint\u201d-typed. However, the other operand (\u201csload <b> result\u201d) is a \u201cshort\u201d type, so the operand generation chain is followed recursively until the instruction that generates the smaller-typed operand (\u201csload <b>\u201d result duplicated by \u201cdup_x\u201d) is located. The instruction type of the instruction that generates the smaller-typed operand is changed to generate the larger-typed operand. The first instruction conversion pass concludes with the \u201cistore <d>\u201d instruction . Because the \u201ciadd <d>\u201d result operand could not be optimized to a smaller type, the \u201cistore <d>\u201d instruction  cannot be optimized to a smaller type.","The second instruction conversion pass begins with the \u201csload <a>\u201d instruction and proceeds to the \u201cimul\u201d instruction. At this point, the \u201cdup_x 0x21\u201d-based \u201csload <a>\u201d result on the stack is type \u201cshort\u201d and the \u201cimul\u201d instruction requires type \u201cint\u201d. This forces changing the instruction type to \u201cdup_x 0x22\u201d so that it will produce an \u201cint\u201d value for the \u201csload <a>\u201d result. The \u201cdup_x 0x22\u201d instruction requires two int-typed variables and the \u201csload <a>\u201d result is a \u201cshort\u201d type, so the \u201csload <a>\u201d instruction is forced to an \u201cint\u201d type by using the \u201cs2i\u201d instruction to force the \u201csload <a>\u201d result to an \u201cint\u201d type. Instruction conversion then proceeds to the \u201csstore <c>\u201d instruction. At this point, an \u201cint\u201d-typed value (\u201cimul\u201d result) is on the stack. The operand is forced to a \u201cshort\u201d type using the \u201ci2s\u201d instruction.","Turning now to , a detailed block diagram that illustrates conversion of an instruction that has multiple consumers in accordance with one embodiment of the present invention is presented.  provides more detail for . Instruction conversion proceeds up to the \u201ciadd\u201d instruction . At this point, the stack comprises two entries. One entry corresponds to an \u201cint\u201d-typed \u201ciload <d>\u201d  result. The other entry corresponds to a \u201cshort\u201d-typed copy of the \u201csload <b>\u201d result that remains from the \u201cdup_x11\u201d 3224 result. At , validation of the input stacks is successful. At , the \u201ciadd\u201d instruction is optimized. At , the instruction type is set to the smallest useable type (\u201cshort\u201d). The corresponding instruction is \u201csadd\u201d. The \u201cdup_x11\u201d-based \u201csload <b>\u201d result and \u201ciload <d>\u201d  result operands are checked at . With regard to the \u201cdup_x 11\u201d-based \u201csload <b>\u201d result operand, at  the instruction type (\u201cshort\u201d) is not less than the \u201cdup_x 11\u201d-based \u201csload <b>\u201d result operand type (\u201cshort\u201d), at  the \u201csadd\u201d instruction type (\u201cshort\u201d) equals the \u201cdup_x11\u201d-based \u201csload <b>\u201d result operand type (\u201cshort\u201d) and at  the \u201cdup_x11\u201d-based \u201csload <b>\u201d result operand does not have potential overflow. With regard to the \u201ciload <d>\u201d  result operand, at  the \u201csadd\u201d instruction type (\u201cshort\u201d) is less than the \u201ciload <d>\u201d operand type (\u201cint\u201d), at  the instruction type is set to the \u201ciadd\u201d operand type (\u201cint\u201d), at  the instruction type (\u201cint\u201d) equals the \u201ciload <d>\u201d operand type (\u201cint\u201d), at  the \u201ciload <d>\u201d operand does not have potential overflow.","Referring again to , at  the operand types are matched. At  the \u201ciadd\u201d instruction type is \u201cint\u201d. The \u201cdup_x11\u201d-based \u201csload <b>\u201d result operand and \u201ciload <d>\u201d  result operand are checked at . Regarding the \u201ciload <d>\u201d  result, at  the instruction type (\u201ciadd\u201d) is not greater than the \u201ciload <d>\u201d  result, completing validation of the \u201ciload <d>\u201d  result. Regarding the \u201cdup_x11\u201d-based \u201csload <b>\u201d result operand, at  the \u201ciadd\u201d instruction type (\u201cint\u201d) is greater than the \u201cdup_x 11\u201d-based \u201csload <b>\u201d result operand type (\u201cshort\u201d), so at  the input instruction \u201ciload <d>\u201d is obtained. At  the \u201cchange operand type\u201d process is invoked to change the \u201cdup_x11\u201d instruction to generate an \u201cint\u201d type for the \u201csload <b>\u201d result. At  the \u201ciload <d>\u201d instruction does not generate the \u201cdup_x11\u201d-based \u201csload <b>\u201d result operand, so the same check is performed on the input instruction (\u201csstore\u201d) of the \u201ciload <d>\u201d instruction. At  the \u201csstore\u201d instruction does not generate the \u201cdup_x11\u201d-based \u201csload <b>\u201d result operand, so the same check is performed on the input instruction (\u201csmul\u201d) of the \u201csstore\u201d instruction. At  the \u201csmul\u201d instruction does not generate the \u201cdup_x11\u201d-based \u201csload <b>\u201d result operand, so the same check is performed on the input instruction (\u201cdup_x 0x11\u201d) of the \u201csmul\u201d instruction. At  the \u201cdup_x 0x11\u201d instruction generates the \u201cdup_x11\u201d-based \u201csload <b>\u201d result operand, so at  the instruction type of the \u201cdup_x 0x11\u201d instruction is changed to the desired type, which is the \u201ciadd\u201d instruction type (\u201cint\u201d).","Changing the instruction type is illustrated in . At  the \u201cdup_x 0x11\u201d instruction type (\u201cshort\u201d) does not equal the desired type (\u201cint\u201d). Thus, at  the minimum required type is set to the desired type (\u201cint\u201d). At  the instruction is set to generate output of the desired type. In this particular example, the \u201cdup_x 0x21\u201d instruction outputs an \u201cint\u201d type, so the instruction is set to \u201cdup_x 0x21\u201d. This completes sequence 3 () in the example illustrated in . At , the input instruction (\u201csload <b>\u201d) is determined. The \u201csload <b>\u201d result type (\u201cshort\u201d) is incorrect because it does not equal the \u201cint\u201d type, so at  the input instruction (\u201csload <b>\u201d) is checked to determine whether it generates the incorrect operand (\u201csload <b>\u201d result). At  the \u201csload <b>\u201d instruction generates the \u201csload <b>\u201d result so at  the \u201csload <b>\u201d instruction type is changed to the desired type (\u201cint\u201d). At  the \u201csload <b>\u201d instruction type does not equal the desired type \u201cint\u201d, so at  the required minimum type is set to the desired type (\u201cint\u201d). At  the instruction is set to generate output of the desired type (\u201cint\u201d). In this particular example, the instruction sequence \u201csload <b>; s2i\u201d outputs an \u201cint\u201d value. At  the results are associated with the \u201cdup_x 0x21\u201d instruction.","Referring again to , after validating the operand types for the \u201ciadd\u201d instruction, the conversion results are recorded at . Recording conversion results comprises determining potential overflow and generating an output stack. At , the \u201ciadd\u201d instruction type (\u201cint\u201d) equals the original instruction type (\u201cint\u201d), so there is no potential overflow. This completes sequence 4 () in the example illustrated in .","In sequence 5 () of , the second instruction conversion pass begins with the \u201csload <a>\u201d instruction (converted from the original \u201ciload <a>\u201d instruction) and proceeds to the \u201csmul\u201d instruction (converted from the original \u201cimul\u201d instruction). A stack manipulation instruction (\u201cdup_x 0x21\u201d) precedes the \u201csmul\u201d instruction. In operation, the \u201cdup_x 0x21\u201d instruction makes a copy of the top \u201cint\u201d value on the stack and places it one position down in the stack. At this point, the stack comprises three entries. The top and bottom stack entries correspond to a \u201cdup_x 0x21\u201d-based \u201csload <b>; s2i\u201d result of type \u201cint\u201d. The middle stack entry corresponds to a \u201cdup_x 0x21\u201d-based \u201csload <a>\u201d result of type \u201cshort\u201d. At , validation of the input stacks is successful. At , the \u201csmul\u201d instruction is optimized. At , the instruction type is set to the smallest usable type (\u201cshort\u201d). The top two stack entries are operands for the \u201csmul\u201d instruction. With regard to the operand corresponding to the \u201cdup0x21\u201d-based \u201csload <b>; s2i\u201d result, at  the \u201csmul\u201d instruction type (\u201cshort\u201d) is less than the \u201cdup_x21\u201d-based \u201csload <b>; s2i\u201d operand type (\u201cint\u201d). At , the instruction type is set to the \u201cdup_x21\u201d-based \u201csload <b>; s2i\u201d operand type (\u201cint\u201d). At , the \u201cimul\u201d instruction type (\u201cint\u201d) equals the \u201cdup_x21\u201d-based \u201csload <b>; s2i\u201d operand type (\u201cint\u201d). At , the \u201cdup_x21\u201d-based \u201csload <b>; s2i\u201d result operand does not have potential overflow. Sequence 5 () is next in the example illustrated in .","With regard to the \u201cdup_x 0x21\u201d-based \u201csload <a>\u201d result operand, at  the \u201cimul\u201d instruction type (\u201cint\u201d) is not less than the \u201cdup_x 0x21\u201d-based \u201csload <a>\u201d result operand type (\u201cshort\u201d) and at  the \u201cimul\u201d instruction type (\u201cint\u201d) does not equal the \u201csload <a>\u201d operand type (\u201cshort\u201d).","Referring again to , at  the operand types are matched. At  the \u201cimul\u201d instruction type is \u201cint\u201d. With regard to the \u201cdup_x21\u201d-based \u201csload <b>; s2i\u201d result operand, at  the instruction type (\u201cint\u201d) is not greater than the \u201cdup_x11\u201d-based \u201csload <b>; s2i\u201d operand type (\u201cint\u201d). With regard to the \u201cdup_x21\u201d-based \u201csload <a>\u201d result operand, at  the instruction type \u201cint\u201d is greater than the \u201csload <a>\u201d result operand type (\u201cshort\u201d), so at  the input instruction (\u201cdup_x 0x21\u201d) is checked to determine whether it generates the \u201csload <a>\u201d result. At  the \u201cdup_x 0x21\u201d instruction generates the \u201csload <a>\u201d result, so at  the instruction type of the \u201cdup_x 0x21\u201d instruction is changed to the desired type, which is the \u201cimul\u201d instruction type (\u201cint\u201d).","Changing the instruction type is illustrated in . At  the \u201cdup_x 0x21\u201d-based \u201csload <a>\u201d instruction type (\u201cshort\u201d) does not equal the desired type (\u201cint\u201d). Thus, at  the minimum required type is set to the desired type (\u201cint\u201d). At  the instruction is set to generate output of the desired type. In this particular example, the \u201cdup_x 0x22\u201d instruction outputs an \u201cint\u201d type, so the instruction is set to \u201cdup_x 0x22\u201d. Sequence 6 () is next step in the example illustrated in .","At , the input instruction (\u201csload <b>\u201d) is obtained. Block  is performed per incorrect operand. The \u201csload <a>\u201d result operand is incorrect because the \u201csload <a>\u201d result type (\u201cshort\u201d) does not equal the \u201cint\u201d type, so at  the input instruction (\u201csload <b>\u201d) is checked to determine whether it generates the incorrect operand (\u201csload <a>\u201d result). At  the \u201csload <b>\u201d instruction does not generate the \u201csload <a>\u201d result, so the same check is performed on the input instruction (\u201csload <a>\u201d) of the \u201csload <b>\u201d instruction. At  the \u201csload <a>\u201d instruction generates the \u201csload <a>\u201d result, so at  the instruction type of the \u201csload <a>\u201d instruction is changed to the desired type, which is the \u201cint\u201d type.","Changing the instruction type is illustrated in . At  the \u201csload <a>\u201d instruction type (\u201cshort\u201d) does not equal the desired type (\u201cint\u201d). Thus, at  the minimum required type is set to the desired type (\u201cint\u201d). At  the instruction type is set to generate output of the desired type. In this particular example, the instruction sequence \u201csload <a>; s2i\u201d outputs an \u201cint\u201d type, so the instruction is set to \u201csload <a>; s2i\u201d. At  the results are associated with the \u201csload <a>; s2i\u201d instruction.","Instruction conversion continues with conversion of the \u201csstore <c>\u201d instruction. At , validation of the input stacks is successful. At , the \u201csstore <c>\u201d instruction is optimized. At , the instruction type is set to the smallest useable type (\u201cshort\u201d). At this point, the top element of the stack is the \u201cimul\u201d result, an \u201cint\u201d-typed value. With regard to the \u201cimul\u201d result operand, the \u201csstore <c>\u201d instruction type (\u201cshort\u201d) is less than the \u201cimul\u201d result operand type (\u201cint\u201d) so at  the instruction type is set to the \u201cimul\u201d result operand type (\u201cint\u201d). The corresponding instruction in this case is the \u201ci2s; sstore <c>\u201d instruction. At , the \u201ci2s; sstore <c>\u201d instruction type (\u201cshort\u201d) equals the \u201cimul\u201d result operand type. At  the \u201cimul\u201d result does not have potential overflow. Conversion continues as discussed above.","Although embodiments of the present invention have been described with regard to integral types, those of ordinary skill in the art will recognize that the invention may be applied to floating-point arithmetic expressions as well, given a computer language that supports casting a large floating point type to a smaller floating point type and a source processor that supports both floating point types. Furthermore, although embodiments of the present invention have been illustrated with respect to Java Card\u2122 technology, those of ordinary skill in the art will recognize that the invention is applicable to many other platforms. These platforms include, by way of example, K virtual machine (KVM) technology. KVM technology is described in \u201cThe K Virtual Machine (KVM)\u2014A White Paper\u201d, Jun. 8, 1999, Sun Microsystems, Inc.","While embodiments and applications of this invention have been shown and described, it would be apparent to those skilled in the art having the benefit of this disclosure that many more modifications than mentioned above are possible without departing from the inventive concepts herein. The invention, therefore, is not to be restricted except in the spirit of the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated into and constitute a part of this specification, illustrate one or more embodiments of the present invention and, together with the detailed description, serve to explain the principles and implementations of the invention.","In the drawings:",{"@attributes":{"id":"p-0027","num":"0035"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0036"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0037"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0038"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0031","num":"0039"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0032","num":"0040"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0033","num":"0041"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0034","num":"0042"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0035","num":"0043"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0036","num":"0044"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0037","num":"0045"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0038","num":"0046"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0039","num":"0047"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0040","num":"0048"},"figref":"FIG. 10B"},{"@attributes":{"id":"p-0041","num":"0049"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0042","num":"0050"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0043","num":"0051"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0044","num":"0052"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0045","num":"0053"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0046","num":"0054"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0047","num":"0055"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0048","num":"0056"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0049","num":"0057"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0050","num":"0058"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0051","num":"0059"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0052","num":"0060"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0053","num":"0061"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0054","num":"0062"},"figref":"FIG. 24A"},{"@attributes":{"id":"p-0055","num":"0063"},"figref":"FIG. 24B"},{"@attributes":{"id":"p-0056","num":"0064"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0057","num":"0065"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0058","num":"0066"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0059","num":"0067"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0060","num":"0068"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0061","num":"0069"},"figref":"FIG. 30"},{"@attributes":{"id":"p-0062","num":"0070"},"figref":"FIG. 31"},{"@attributes":{"id":"p-0063","num":"0071"},"figref":"FIG. 32"}]},"DETDESC":[{},{}]}
