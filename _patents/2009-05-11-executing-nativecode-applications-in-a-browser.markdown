---
title: Executing native-code applications in a browser
abstract: Techniques for leveraging legacy code to deploy native-code desktop applications over a network (e.g., the Web) are described herein. These techniques include executing an application written in native code within a memory region that hardware of a computing device enforces. For instance, page-protection hardware (e.g., a memory management unit) or segmentation hardware may protect this region of memory in which the application executes. The techniques may also provide a narrow system call interface out of this memory region by dynamically enforcing system calls made by the application. Furthermore, these techniques may enable a browser of the computing device to function as an operating system for the native-code application. These techniques thus allow for execution of native-code applications on a browser of a computing device and, hence, over the Web in a resource-efficient manner and without sacrificing security of the computing device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09588803&OS=09588803&RS=09588803
owner: Microsoft Technology Licensing, LLC
number: 09588803
owner_city: Redmond
owner_country: US
publication_date: 20090511
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["Developers have spent decades developing an abundance of desktop applications for execution on local machines of users. These applications include word processors, drawing applications, games and countless others. Since the development of many of these applications, however, users have begun to desire applications that are made available over a network (e.g., the Internet) rather than simply on a local machine of the user.","Because of this desire, developers have now begun the task of providing the functionality of previously-written desktop applications over the Web. Unfortunately, developers wrote many or all of these desktop applications in a type-unsafe language, such as C or C++. Based in large part on security concerns, the code of these applications typically cannot execute safely within a browser and, hence, has by and large not been made available for consumption over the Web. Instead, some developers have simply begun re-writing desktop applications (or applications similar to the previously-written desktop applications) in a type-safe language that a browser may utilize.","While re-writing applications for deployment over the Web may make sense in some circumstances, this strategy requires enormous monetary and time resources and fails to leverage the work that developers have already completed over the past several decades.","Techniques for leveraging legacy code to deploy native-code desktop applications over a network (e.g., the Web) are described herein. These techniques include executing an application written in native code within a memory region that hardware of a computing device enforces. For instance, page-protection hardware (e.g., a memory management unit) or segmentation hardware may protect this region of memory in which the application executes. The techniques may also provide a narrow system call interface out of this memory region by dynamically enforcing system calls made by the application. Furthermore, these techniques may enable a browser of the computing device to function as an operating system for the native-code application. These techniques thus allow for execution of native-code applications on a browser of a computing device and, hence, over the Web in a resource-efficient manner and without sacrificing security of the computing device.","This summary is provided to introduce concepts relating to user interfaces. These techniques are further described below in the detailed description. This summary is not intended to identify essential features of the claimed subject matter, nor is it intended for use in determining the scope of the claimed subject matter.","The disclosure describes techniques for enabling users to safely and efficiently execute applications written in potentially unsafe and potentially un-trusted code on browsers of client computing devices. For instance, a user may send a request to execute a particular native-code application over a network, such as the Web, to a server that hosts the application. In response to the request, the server may serve native code of the application to the computing device of the user. The computing device may then assign a portion of memory to the received native code. In some instances, hardware of the computing device enforces reads and writes made by the application from this portion of the memory. For instance, page-protection hardware (e.g., a memory management unit), segmentation hardware, or another type of hardware may enforce the portion of memory that the computing device assigns to the native-code application.","After assigning the portion of memory to the native code, this code may safely execute within this portion of memory. Because the computing device comes equipped with the hardware that enforces this memory region, the native code may execute without placing an additional burden on the computing device. That is, the hardware enforcing the memory performs this function in parallel to the executing of the application and, hence, does not place a significant speed penalty on the execution of the application.","In addition, the techniques described herein provide a secure interface that allows the native-code application to make calls for system services. To do this in a secure manner, the techniques prevent the application (and its un-trusted code) from making calls through the standard system call (sys call) interface. Additionally, the techniques only allow the application to call a much narrower interface. This narrow interface dynamically enforces the system calls and, for calls that the interface deems permissible, passes the system calls on to a browser of the computing device on which the application runs. As such, this interface prevents the application from calling an underlying operating system (OS) of the computing device and, in lieu of the OS, enables the browser to function as the OS for the native-code application.","By bounding this native-code application into a region of memory protected by hardware of the computing device, the described techniques ensure that this application does not gain access to memory outside of this region (e.g., to the kernel of the computing device). Additionally and as noted above, because the computing device already includes the hardware enforcing this memory and because this hardware already performs this function, the described techniques efficiently enforce the memory protection without placing a speed penalty on the application.","Furthermore, by providing a narrow interface that only passes certain predefined specified commands outside of the memory region, the native code is unable to issue potentially malicious instructions to the operating system. Next, by routing system calls made by the application to the browser, the techniques enable the browser to provide existing services to the application and, hence, enable the browse to function as the operating system for the native code application with little or no modification to the browser. As a result, the techniques facilitate the running of native-code applications in an exceedingly efficient manner that is as secure as other functions performed by the browser. Finally and as discussed below, the techniques necessitate only slight modifications to the native-code applications for the applications to execute as explained above.","The discussion begins with a section entitled \u201cExample Computing Architecture,\u201d which describes one non-limiting environment that may implement the described techniques. This section also pictorially illustrates a process of deploying a native-code application for execution within a browser of a computing device. Next, a section entitled \u201cExample Computing Device\u201d and its numerous sub-sections illustrate and describe additional components that may be used to implement the described techniques in some implementations. A third and final section, entitled \u201cExample Process\u201d, describes an example process for deploying native-code applications over a network, such as the Web.","This brief introduction, including section titles and corresponding summaries, is provided for the reader's convenience and is not intended to limit the scope of the claims, nor the proceeding sections.","Example Computing Architecture",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["100","100","102","104","106","1","106","2","106","108","106","1","110","1","110","2","110","112","1","112","2","112"]},"Here, the user  operating the computing device  accesses a content provider (e.g., the content provider ()) over the network  to access an application (e.g., the application ()) written in native code. This application may comprise a word processing application, a drawing application, a game, or any other type of application. The network  is representative of any one or combination of multiple different types of networks, interconnected with each other and functioning as a single large network (e.g., the Internet or an intranet). The network  may include wire-based networks (e.g., cable) and wireless networks (e.g., cellular, satellite, etc.). The network  may use any number of protocols and configurations to enable the computing device  to access other devices and resources.","The computing device  of the user , meanwhile, may comprise a personal computer, a laptop computer, a thin client, a mobile telephone, a portable music player or any other sort of suitable computing device. As illustrated, the computing device  here comprises a personal computer that includes hardware  and memory , which resides upon hardware . The hardware  may include some or all hardware traditionally found in a computing device, such as one or more processors  as well as hardware configured to enforce memory isolation boundaries and configured to enforce requests for reads and writes from applications executing within the boundaries. This hardware may comprise page-protection hardware (e.g., a memory management unit), segmentation hardware (i.e., segment registers) or any other hardware configured to enforce memory isolation boundaries and requested reads and writes.","As illustrated, the memory  of the computing device  includes a hardware-isolation boundary , enforced by a component of the hardware . The memory also includes an operating system  as well as a browser  that enables the user  to access the content provider () over the network .","In response to sending a request (e.g., via the browser ) to the content provider () to execute the native-code application (), the content provider () provides a portion or all of the application to the device  of the user . As illustrated, the device  then assigns a portion of memory \u2014bounded by the hardware-isolation boundary \u2014to the native-code application (). Because the boundary  contains the application (), the application is unable to access memory outside of the assigned portion of memory . As such, the application is unable to perform malicious acts outside of this area and, hence is unable to seriously harm the device  of the user .","Furthermore, because the hardware  of the device enforces this memory region in which the application executes, and because this hardware  already performs this type of task, the cost of this security is extremely low.","In addition to containing the native-code application () within the assigned portion of memory , the computing device  also provides a narrow interface  between the portion of memory  and the browser . This narrow interface  functions to block all but a few system calls made by the application (). Furthermore, when the application makes a proper system call, the interface (and additional components described with reference to ) route these calls to the browser . As such, the browser  is able to provide the requested services and is able to function as an operating system for the native-code application ().","As the reader appreciates, the narrow interface  thus provides security to the computing device  by disallowing calls to any place other than the browser . As such, the native-code application () is unable to access trusted areas of the device  and is unable to seriously harm the computing device . In fact, because the described techniques enable the native-code application () to execute with use of existing services provided by the browser , in some instances these techniques require that no additional functionality be added to the browser . Also for this reason, the techniques provide security that is no less secure than operations typically performed by the browser  (e.g., accessing a website, running Flash objects, etc.).","Taken together, the architecture  of  enables a user  to access a native-code application  over the network  and execute the application on a local device  of the user . These techniques contain the application in a hardware-enforced region of memory  and provide a narrow interface  that only allows the application () to run within a browser  of the device . As such, these techniques enable content providers ()-(N) to deploy applications that have been years and decades in the making over the web in a secure manner and, as discussed below, with only slight modifications to the deployed applications.","Having described one of many architectures that may employ the described techniques,  illustrate an example process  for deploying native-code applications.","The process  includes a computing device  of the user  sending a request for a native-code application () to a content provider () over a network  at an operation . At an operation , the content provider () sends native code of the application () to the computing device  in response to receiving the request. Next, at an operation , the computing device  assigns a portion of memory  that is enforced by hardware  to the native-code application (). The computing device  then loads and executes the native-code application () in the assigned portion of memory  at an operation .",{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 3","b":["200","210","104","128","112","1","112","1","128","124","104","212","112","1"]},"With this process  in mind, the following section describes in more detail an example computing device to implement the described techniques.","Example Computing Device",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 4","b":["104","104","104","114","116","114","402","104","116","116","122","118","116"]},"The memory  also includes the native-code application () (acquired by the user  over the network ). As illustrated, the page-protection hardware  functions to create a hardware-enforced isolation boundary  around the region of memory  in which the application () resides. As such, the application is allowed to operate within this region of memory  but not outside this region. In addition, the application () may make certain system calls outside of this region  via a narrow interface  and, optionally, through a platform abstraction layer (PAL) . As described in detail below, the PAL  may translate calls made from the application in a manner appropriate for the type of operating system  on the device . That is, the PAL  may translate these calls in a certain way for a Windows\u00ae operating system and in another way for a Linux\u00ae operating system, for example.","Furthermore, once these calls pass through the interface , a monitor  routes these calls to the browser . As such, the monitor  and the browser  together provide services to the application () and, hence, act as an operating system for the application. In some instances, the browser  comprises the monitor  as well as the traditional functionality of the browser. In combination, the browser  and the monitor  may simply provide only existing traditional services to the application. For instance, the browser may provide memory management (e.g., allocation and de-allocation) memory input\/output (), storage , object caching, user input, and other services to the native-code application ().","In other instances, however, the browser  may be modified to include additional functionality and, hence, to provide additional or different services to the native-code application (). For instance, the browser may expose a video display block image transfer (BLIT) interface to the application. This interface may form a portion of the narrow interface . By configuring the browser to expose this video blitting interface, the application may execute a block image transfer to the browser  each time the application wishes to display an image within the browser . While this interface requires the adding of functionality to the browser , enabling the application to \u201cBLIT\u201d image representations creates a secure and easy way for applications of any kind to display desired images in the browser . Similarly, in some instances the browser may be modified to include an audio channel interface that is exposed to the native-code application. Again, such an interface may form a portion of the illustrated narrow interface  and may allow an array of different applications to safely and easily send desired audio for output of the audio via the browser .",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 4","b":["410","126","112","1","412","414"]},"In some instances, the techniques described with reference to  may be implemented via a plug-in to the browser , although other implementations may use other technologies. In each instance, however, the techniques strive to meet the following four design goals: security, operating system (OS) independence, performance and legacy support.","Addressing security first, the particular form of security required for web applications comprises protecting the client computing device  against malicious code. Part of what makes web applications attractive is that they are supposed to run safely without requiring explicit trust assumptions from the user . This stands in contrast to installed desktop applications, which have nearly unfettered access to the client computing device , so users make trust assumptions whenever they install a desktop program from a compact disc (CD) or via the Internet. Web applications are considered safe because they execute within a sandbox that sharply restricts the reach of the program.","Next, the techniques strive for OS-independence. Unlike desktop applications, web applications are not tied to a particular operating system, because they do not make direct use of OS services. Instead, web applications invoke services provided by the browser or by a browser plug-in, which is responsible for exporting the same interface and semantics across OS implementations. Ideally, web applications are also independent of the particular browser in which they run.","In addition, the techniques described herein strive to enable high performance of the application () running on the computing device . Simple web applications, such as web pages with dynamic menus, may not require much performance from their execution environments. However, the performance demands may be significant for feature-rich applications that provide functionality comparable to desktop applications, such as animated D rendering.","Finally, the techniques strive to enable legacy support for native-code applications, such as the native code application () shown in the device  of . Again, leveraging existing applications is highly preferable to developing complex, feature-rich applications, which requires an enormous effort and an enormous cost.","To accomplish the four goals, the described techniques including the following four main concepts, described above and now described in detail below: (1) executing a native-code application () behind a hardware-enforced memory region  and providing a narrow interface  from the region (i.e., a \u201cpicoprocess\u201d); (2) providing a platform abstraction layer (PAL)  to provide an OS-independent Application Binary Interface (ABI) ; (3) providing hooks to existing browser mechanisms to provide applications with system services (e.g., network communication, user interface, local storage, etc.) that respect browser security policies, and (4) lightweight modifications to existing tool chains and code bases of the native-code applications for retargeting legacy code to the environment of .","The Picoprocess","The first technique is the picoprocess, which can be thought of as a stripped-down virtual machine without emulated physical devices, MMU, or CPU kernel mode. Alternatively, a picoprocess can be thought of as a highly restricted OS process that is prevented from making kernel calls. In either view, a picoprocess is a single hardware-memory-isolated address space with strictly user-mode CPU execution and a very narrow interface to the world outside the picoprocess, as illustrated in .","A browser plug-in that includes the monitor  may create the picoprocesses. Like a virtual machine monitor (in the VM analogy) or an OS kernel (in the OS process analogy), the monitor  is part of the browser's trusted code base, (\u201cTCB\u201d), so keeping the monitor small is important. The picoprocess communicates by making calls to the monitor .","Because the monitor  uses OS services to create and manage picoprocesses, it is necessarily OS-specific. Moreover, to ease the implementation burden and help keep the monitor  simple, the described techniques do not generally enforce a standard narrow interface. The specific set of calls, as well as the call invocation mechanism, may vary depending on the underlying OS platform. The discussion below describes some differences regarding Linux\u00ae and Windows\u00ae implementations. In terms of functionality, the provided calls provide means for memory allocation and de-allocation, raw communication with the browser, raw communication with the origin server, access to uniform resource location (URL) query parameters, and picoprocess exit.","The simplicity of the narrow interface makes it very easy to implement on commodity operating systems, which assists OS-independence. This simplicity also aids security, since it is much easier to reason about the security aspects of a narrow interface with simple semantics than a wide interface with complex semantics. Because a picoprocess executes native code, it typically provides good performance. However, it is not necessarily clear that this architecture supports legacy code that was written with the expectation of running in an OS process with access to rich OS services. The discussion addresses this point below.","Platform Abstraction Layer","As mentioned in the previous sub-section, the narrow interface may vary slightly across OS platforms. For OS-independence, the techniques define a consistent Application Binary Interface (ABI)  irrespective of the underlying OS. By necessity, the ABI  varies across architectures, so the x86 ABI is different from the PowerPC ABI.","The ABI  is exported by an OS-specific Platform Abstraction Layer (PAL) , which translates the OS-independent ABI  into the OS-specific calls of the monitor . The PAL  is included with the OS-specific implementation, while everything above the ABI  is native code that a content provider (e.g., a server) delivers. The PAL  runs inside the picoprocess, so its code is not trusted. The narrow interface  provides security, while the PAL  merely provides ABI consistency across different host operating systems, such as the operating system  of the computing device  of the user .","In some instances, all calls from the native-code application () are non-blocking except for poll, which can optionally yield until I\/O is ready. This provides sufficient functionality for user-level threading. For illustration purposes only, the following discussion presents one example of the ABI . For memory allocation and de-allocation, the ABI  includes the following two calls:",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"void *xabi_alloc("]},{"entry":[{},"\u2003\u2003void *start, long len);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Map len zero-filled bytes of picoprocess memory, starting at start if specified. Return the address.","int xabi_free(void*start);","Free the memory region beginning at start, which must be an address returned from xabi alloc. Re-turn 0 for success or \u22121 for error.","As described below, the picoprocess appears to the browser  as a web server and communication is typically over HTTP. When the browser  opens a connection to the picoprocess, this connection can be received by the following call:","int xabi_accept 0;","Return a channel identifier, analogous to a Unix\u00ae file descriptor or a Windows\u00ae handle, connected to an in-coming connection from the browser . Return \u22121 if no incoming connection is ready.","The picoprocess can also initiate connection to the server that provided the picoprocess application. To initiate a connection to the home server, the picoprocess uses the following call:",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int xabi_open_url("]},{"entry":[{},"\u2003\u2003const char * method,"]},{"entry":[{},"\u2003\u2003const char *url);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Return a channel identifier connected to the given URL, according to the specified method, which may be \u201cget\u201d, \u201cput\u201d, or \u201cconnect\u201d. Fetch and cache the URL according to the Same Origin Policy (SOP) rules for the domain that provided the picoprocess.","The operations that can be performed on an open channel are read, write, poll, and close:",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int xabi_read("]},{"entry":[{},"\u2003\u2003int chnl, char *buf, int len);"]},{"entry":[{},"int xabi_write("]},{"entry":[{},"\u2003\u2003int chnl, char *buf, int len);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Transfer data on an open channel. Return the number of bytes transferred, 0 if the channel is not ready, or \u22121 if the channel is closed or failed.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct {"]},{"entry":[{},"\u2003\u2003int channel;"]},{"entry":[{},"\u2003\u2003short events; \/* requested *\/"]},{"entry":[{},"\u2003\u2003short revents; \/* returned *\/"]},{"entry":[{},"} xabi_poll_fd;"]},{"entry":[{},"int xabi_poll("]},{"entry":[{},"\u2003\u2003xabi_poll_fd *pfds, int npfds, bool block);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Indicate the ready status of a set of channels by updating events. If block is true, do not return until at least one requested event is ready, thereby allowing the picoprocess to yield the processor. Return the number of events ready; do not return 0 if block is true.","int xabi close(int chnl);","Close an open channel. Return 0 for success or \u22121 for error.","During picoprocess boot, the loader  needs to know the URL from which to fetch the application image. The techniques could require a custom loader for each application, with the URL baked into the loader's image. Conversely, the techniques may include a general loader that reads the application URL from the query parameters of the URL that launched the picoprocess. The following call, which is normally used only by the loader , provides access to these parameters. Note that there is no corresponding call via the interface , as the parameters are written into the PAL  during picoprocess initialization.","const char**xabi_args( );","Return a pointer to a NULL-terminated list of pointers to arguments specified at instantiation.","Lastly, the ABI  provides a call to exit the picoprocess when it is finished:","void xabi exit( );","Although the PAL  runs inside the picoprocess, it is not part of the native-code application (). More specifically, it is not delivered with the OS-independent application code. Instead, the appropriate OS-specific PAL  remains resident on the client computing device , along with the monitor  and the browser , whose implementations are also OS-specific. When a native-code application is delivered to the device , the application and the PAL  are loaded into the picoprocess and linked via a simple dynamic-linking mechanism: The ABI  de-fines a table of function pointers and the calling convention for the functions. For x86 architectures, this calling convention is cdec 1; for the PowerPC, it is the one standard calling convention; and, for other architectures, other calling conventions may be defined.","In some instances, the techniques create a simple shim library (included in the libraries  of ) to which an application may statically link. This library may export a set of symbols (xabi read, xabi openurl, etc.) that obey the function linkage convention of the developer's tool chain. The shim converts each of these calls to the corresponding ABI call in the PAL . This shim thus provides a standard Application Programming Interface (API) to native-code applications that have been modified to function in this environment.","Services Via Browser Mechanisms","In order for the browser  to function as an operating system for the native-code application (), a key principle is that the browser contains sufficient functionality to support the system services needed by web applications. In fact, the browser  not only has sufficient functionality, but employing the browser as an operating system also improves security. That is, because the techniques reuses the existing security policy\u2014and much of the mechanism\u2014in the browser, the described techniques do not introduce any new security vulnerabilities in some instances.","The monitor  has the job of providing the services indicated by the narrow interface . These services include memory allocation\/de-allocation, access to URL query parameters, and picoprocess exit, among others. The monitor  also provides a communication path to the browser , via which the picoprocess appears as a web server to the browser . This communication path enables the native-code application () to use read and write calls to serve HTTP to the browser . From the perspective of the browser , these HTTP responses appear to come from the remote server that supplied the native-code application (). This approach is secure, since the native-code application () is unable to do anything that the remote server could not have done by serving content directly over the Internet to the browser  in some instances.","Using the picoprocess-to-browser communication path, the native-code application () can employ JavaScript code in the browser  to perform functions on its behalf, such as user interface operations, DOM manipulation, and access to browser cookies. In some applications, the native-code application () may provide an HTML page to the browser , with the page containing JavaScript stubs which translate messages from the picoprocess into JavaScript function invocations.","It would be possible but awkward to use JavaScript for network communication. To pass through JavaScript, an application or library binary from a remote server would have to be uuencoded, encapsulated in JSON, transferred via HTTP, de-encapsulated, and decoded. To simplify this process, the described techniques provide the ABI call \u201cxabi openurl\u201d to allow direct communication between a picoprocess and its origin server. Both Linux\u00ae and Windows\u00ae monitors  provide corresponding calls that implement the primitives efficiently.","Lightweight Code Modification","In some instances, the techniques require a rather small effort to port a native-code application (), library , or tool chain to the minimalist ABI . This is surprising because this legacy code was written to run atop an operating system , while the described techniques essentially eliminate the OS  from the perspective of the application and still enable the legacy code to perform its main function.","Although the particular modifications required are application-dependent, in some instances these modifications follow a design pattern that covers five common aspects: disabling irrelevant dependencies, restricting application interface usage, applying failure-oblivious computing techniques, internally emulating syscall functionality, and (only when necessary) providing real syscall functionality via new calls tailored to the narrow interface .","The first step in some instances is to use compiler flags to disable dependencies on irrelevant components. Not all libraries and code components are necessary for use within the web-application framework, and removing them reduces the download size of the web application and also reduces the total amount of code that needs to be ported.","The second step in some instances is to restrict the interfaces that the native-code application () uses. For instance, an application might handle I\/O either via named files or via stdin\/stdout, and the latter may require less support from the system. Depending on the application, restricting the interface is done in various ways, such as by setting command-line arguments or environment variables.","The third step in some instances is to identify which of the remaining system calls of the native-code application () can be handled trivially. For example, the techniques can often return error codes indicating failure, in a manner similar to failure-oblivious computing.","The fourth step in some instances is to emulate syscall functionality within the syscall interpose layer. For instance, some applications read library files from a file system at runtime. Here, the library files may be packaged as a tar ball, and a subset of file-system calls using libtar to access the libraries may be emulated. The tar ball may be read-only, which may be all that these applications require. For other ported applications, the techniques could also provide read\/write access to temporary files by creating a RAM disk in the interpose layer. Code in the interpose layer looks at the file path to determine whether to direct calls to the tar ball, to the RAM disk, or to somewhere else, such as a file downloaded from the origin server.","The fifth and final step in some instances is to provide real backing functionality for the remaining system calls via the ABI . For some applications, most of the remaining syscalls are for user input and display output, which may be routed to UI in the browser .","In some instances, the first three steps are application-specific, but for the final two steps, much of the syscall support developed for one application may be readily reusable for other applications. For any given application, once the needed modifications are understood, the changes may become mechanical. Thus, in some instances the task of maintaining both a desktop version of a native-code application () and a version for implementation with the techniques described herein is fairly straightforward for a developer, using a configure flag to specify the build target. Additionally, it is noted that this is already a common practice for a variety of applications that compile against Linux\u00ae and BSD and Win32 syscall interfaces.","OS-Specific Implementations","The following sub-sections describes the example implementations of the described techniques on Linux\u00ae and Windows\u00ae, as well as a proxy-based browser integration, with reference to . Although they have some significant differences, the two described implementations share a great deal common structure. The main aspect in which they differ is in the kernel support for picoprocess isolation and communication, which will be discussed after first describing the common aspects.","Monitor, Boot Block and Platform Abstraction Layer (PAL)","The monitor  is a user-mode process that creates, isolates, and manages each picoprocess, and that provides the functionality of calls to the narrow interface  from the native-code application (). A picoprocess is realized as a user-level OS process, thus leveraging the hardware memory isolation that the OS already enforces on its processes. Before creating a new picoprocess, the monitor  first allocates a region of shared memory, which will serve as a communication conduit between the picoprocess and the monitor . Then, the picoprocess is created as a child process of the Monitor process.","This child process begins by executing an OS-specific boot block , which performs three steps. First, it maps the shared memory region into the address space of the child process, thereby completing the communication conduit. Second, it makes an OS-specific kernel call that permanently revokes the ability of the child process to make subsequent kernel calls, thereby completing the isolation. Third, it passes execution to the OS-specific PAL , which in turn loads and passes execution to the native-code application ().","Note that the boot block  is part of the TCB, even though it executes inside the child process. The child process does not truly become a picoprocess until after the boot block  has executed. At that point, the child process has no means to de-isolate itself, since this would require a kernel call but the picoprocess is prevented from making kernel calls.","After transferring control to the application (), the PAL  has the job of implementing the ABI  by making appropriate calls to the monitor . To make a call, the PAL  writes the call identifier and arguments into the shared memory region, then traps to the kernel. In an OS-specific manner (described below) the kernel notifies the monitor  of the call. The monitor  then reads the shared memory, performs the indicated operation, writes the result to the shared memory, and returns control to the picoprocess.","Although the monitor  has different implementations on different operating systems, it handles most calls in more-or-less the same way irrespective of the OS . The alloc and free calls are exceptions to this rule, so their different implementations are described in the following two sections. For accept, the monitor  maintains a queue of connection requests from the browser , and each call dequeues the next request. The openurl call makes an HTTP connection to a remote resource; the returned channel identifier corresponds to either a socket handle or a file handle, depending on whether the requested data is cached. The I\/O calls read, write, poll, and close are implemented by reading, writing, polling, and closing OS file descriptors on sockets and files. The exit call simply terminates the child process.","Linux\u00ae Kernel Support","The Linux\u00ae implementation described below involves no custom kernel code. Instead, it makes use of the ptrace facility of the Linux\u00ae kernel, which enables a process to observe and control the execution of another process.","As described above, the boot block  makes a kernel call to revoke the ability of the child process to make subsequent kernel calls. In this implementation, this is done by calling ptrace (TRACEME), which causes the kernel to intercept the entry and exit of every subsequent syscall, transferring control to the Monitor parent process. On entry to a syscall, the monitor  normally replaces whatever system call the child process requested with a harmless system call (e.g., getpid) before releasing control to the kernel. This prevents the child process from passing a syscall to the OS .","Syscalls are also legitimately used by the PAL  to signal an appropriate call to the narrow interface . Thus, when ptrace notifies the monitor  of an entry to a syscall, the monitor  checks whether the shared memory contains a legitimate call identifier and arguments. If it does, the monitor  performs the operation and returns the result, as described above. If the call is a memory-management operation (alloc or free), it has to be handled specially, because Linux\u00ae does not provide a mechanism for a process to allocate memory on behalf of another process. So, in this case, the monitor  does not overwrite the syscall with getpid. Instead, it overwrites the syscall with mmap and a set of appropriate arguments. Since the return from the syscall is also intercepted by ptrace, the monitor  has an opportunity to write a return value for the alloc call into the shared memory, based on the return value from the mmap syscall.","Use of an existing kernel facility (ptrace) enables the described Linux\u00ae implementation to be deployed without kernel-module installation or root privilege. However, it may entail a slight performance hit, because every call may require three syscalls from the monitor : one to swap out the syscall with getpid or mmap, a second to enter the kernel, and a third to resume the picoprocess. More importantly, if the monitor  fails and exits without proper signal handling, the child process may continue to run without having its syscalls intercepted. This failure condition could turn the picoprocess back into a regular OS process, which would violate security. These performance and security problems, however, may be mitigated by using a custom kernel module instead of ptrace.","Windows\u00ae Kernel Support","In the described Windows\u00ae implementation, when the boot block  of the child process makes a kernel call to establish an interposition on all subsequent syscalls, it makes this call to a custom kernel module. Because every Windows\u00ae thread has its own pointer to a table of system call handlers, this custom kernel module is able to isolate a picoprocess by replacing the handler table for the thread of that process. The replacement table converts every user-mode syscall into an inter-process call (IPC) to the user-space monitor . For a syscall originating from kernel mode (e.g., for paging), the custom kernel module passes the call through to the original handler, preserving the dispatcher's stack frame for the callee's inspection.","When the monitor  receives an IPC, it reads the call identifier and arguments from the shared memory and performs the operation. Unlike the Linux\u00ae case, no special handling is required for memory-management operations, because Windows\u00ae NtMapViewOfSection allows the monitor  to map memory on behalf of its child process.","Although the custom kernel module has to be ported to each version of Windows\u00ae on which it runs, the changes are minimal, involving two constant scalars and a constant array: (1) the offset in the kernel thread block for the pointer to the syscall handler table, (2) the count of system calls, and (3) for each system call, the total parameter byte count. This information is readily available from the kernel de-bugger in the Windows\u00ae Driver Kit.","As an alternative to implementation of the customer kernel module described above would be to patch every entry in the standard system-call table. However, this may transparently change the behavior of every process in the system in some instances. Furthermore, even if the interposed handlers were to properly fall through to the original handlers, they would still add overhead to every system call.","Loaders","The Linux\u00ae toolchain emits standard statically-linked Elf binaries. These binaries are loaded by a small loader. This loader reads the target binary, parses it to learn where to map its program regions, and looks up two symbols: a global symbol where the binary's copy of the custom library discussed above expects to find a pointer to the dispatch table of the PAL , and the address of the start symbol. Then, the loader maps the program, writes the dispatch table location into the pointer, and jumps to start.","The Windows\u00ae toolchain, meanwhile, emits statically-linked .EXE binaries in the native PE-COFF format of Windows\u00ae. This loader performs the corresponding tasks to map and launch PE executables.","Browser Integration","Recall that the native-code application () appears to the browser  as part of the origin server that just happens to handle HTTP requests very quickly; this ensures that the picoprocess is governed by the Same-Origin Policy just as is the origin server. In one implementation, the techniques are integrated into the browser  via an HTTP proxy. This approach is expedient, and one implementation serves all makes of browser . The proxy passes most HTTP requests transparently to the specified host. However, if the URL's path component begins with a specified entry, the proxy interposes on the request to direct the request to an existing picoprocess or to create a new one. The proxy is integrated with the monitor process, and allows each picoprocess to contact its origin server via xaxopenurl. This contact employs the same mechanism that fetches ordinary URLs, and thus obeys the SOP.","By implementing the described techniques, for example, as a plug-in to the browser , the techniques enable developers to adapt legacy code for use in rich web applications, while maintaining security, performance, and OS-independence. This security stems from the use of the picoprocess minimalist isolation boundary and browser-based services. Furthermore, this results in a TCB that is orders of magnitude smaller than alternative approaches to the same problem.","The OS-independence, meanwhile, stems from the use of picoprocesses and its platform abstraction layer (PAL) . Furthermore and as discussed above, applications compiled on any toolchain may run on any OS host. Next, the performance of the native-code application () derives from native code execution in picoprocesses. In many instances, the compute performance of these applications in the browser  is comparable to native execution. Finally, the legacy support comes from lightweight code modification. Over decades of software development in type-unsafe languages, vast amounts of design, implementation, and testing effort have gone into producing powerful legacy applications. By enabling developers to leverage this prior effort to deploy and execute into web applications, the techniques described above may change the landscape of web applications.","Example Process",{"@attributes":{"id":"p-0105","num":"0104"},"figref":"FIG. 5","b":["500","500"]},"Process  includes an operation , which represents a client computing device sending a request, from a browser of the device, to execute a native-code application. For instance, the device  of  may send a request to execute the native-code application () that the content provider () stores. Next, an operation  represents that the device receives native code of the application for execution. At an operation , the device assigns a portion of memory (that hardware of the device enforces) to the received native code.","After assigning the memory, the native-code application is able to securely execute on the client computing device within this assigned memory at an operation . Furthermore, as the application makes calls for system services from this assigned portion of memory, the device dynamically enforces these interface calls at an operation . By doing so, the device prevents the application from accessing the operating system of the device as well as other portions of the memory, thus restricting the application's ability to damage the client computing device. Finally, these calls are routed to a browser of the computing device. As such, the browser is able to function as an operating system for the native-code application at an operation .","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as exemplary forms of implementing the claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The detailed description is described with reference to the accompanying figures. In the figures, the left-most digit(s) of a reference number identifies the figure in which the reference number first appears. The same numbers are used throughout the drawings to reference like features and components.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIGS. 2-3","FIG. 1"]},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 4","FIG. 1","FIG. 4"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
