---
title: Stateless animation, such as bounce easing
abstract: An animation system is described herein that uses a transfer function on the progress of an animation that realistically simulates a bounce behavior. The transfer function maps normalized time and allows a user to specify both a number of bounces and a bounciness factor. Given a normalized time input, the animation system maps the time input onto a unit space where a single unit is the duration of the first bounce. In this coordinate space, the system can find the corresponding bounce and compute the start unit and end unit of this bounce. The system projects the start and end units back onto a normalized time scale and fits these points to a quadratic curve. The quadratic curve can be directly evaluated at the normalized time input to produce a particular output.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09262855&OS=09262855&RS=09262855
owner: Microsoft Technology Licensing, LLC
number: 09262855
owner_city: Redmond
owner_country: US
publication_date: 20100318
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Simulation is often used to approximate natural phenomena, such as the laws of physics, in software applications. For example, games often simulate real world experiences, such as racing, flying, and so forth. Simulation typically involves a complex software model designed to mimic behavior of a physical system. Software applies Inputs to the model similar to real world inputs. For example, a gravity simulator may receive inputs about the mass of an object, its aerodynamic properties, one or more forces applied to the object, and so forth.","Simulation can also be useful in user interface animation to increase the reality of interacting with objects experienced by users of the interface. For example, folders that animate from one location to another are easier to understand than those that simply disappear and reappear at another location. One type of user interface animation is a \u201cbounce,\u201d which refers to the desirability of an object having some amount of elasticity as it moves from one location to another. For example, a software designer may want an object dragged from one location to another to bounce at the destination as it would if physically dropped. The bounce calls the user's attention to the object's new location and gives the object a more realistic feel, making the interface more pleasing to use.","Unfortunately, typical simulations are difficult to use for user interface animation and similar applications. It is often not feasible to setup and run a complex model that includes state information stored over time. The requirements of such models are resource intensive and do not allow for starting the simulation in the middle or even running the simulation in reverse. Rather, such models often are designed to run from start to finish uninterrupted. Animation for a user interface is typically more declarative, in that an application author knows a from and to value and wants an animation to occur for values in between. Such animations are more difficult than simple linear interpolation.","An animation system is described herein that uses a transfer function on the progress of an animation that realistically simulates a bounce behavior. The transfer function maps normalized time and allows a user to specify both a number of bounces and a bounciness factor. Given a normalized time input, the animation system maps the time input onto a unit space where a single unit is the duration of the first bounce. In this coordinate space, the system can find the corresponding bounce and compute the start unit and end unit of this bounce. The system projects the start and end units back onto a normalized time scale and fits these points to a quadratic curve. The quadratic curve can be directly evaluated at the normalized time input to produce a particular output. Thus, the animation system provides a simulation for which: 1) the user has customizable control over the number of bounces and the bounciness, 2) the system can statelessly evaluate the output of the transfer function at any point without simulating prior states or output values, and 3) the resulting transfer function accurately simulates the motion of an object falling under gravity and bouncing with elastic collisions.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","An animation system is described herein that uses a transfer function on the progress of an animation that realistically simulates a bounce behavior (such as a bouncing ball). The transfer function maps normalized time and allows a user to specify both a number of bounces and a bounciness (relative amplitude between the peaks of two consecutive bounces). Given a normalized time input, the animation system maps the time input onto a unit space where a single unit is the duration of the first bounce. In this coordinate space, the system can find the corresponding bounce and compute the start unit and end unit of this bounce. The system projects the start and end units back onto a normalized time scale, calculates an amplitude of the bounce (to define a midpoint), and fits these points to a quadratic curve. The quadratic curve can be directly evaluated at the normalized time input to produce a particular output (e.g., height of the bounce at the given time). Thus, the animation system provides a simulation for which: 1) the user has customizable control over the number of bounces and the bounciness, 2) the system can evaluate the output of the transfer function at any point without simulating prior states or output values (i.e., stateless), and 3) the resulting transfer function accurately simulates the motion of an object falling under gravity and bouncing with friction (e.g., each bounce is symmetric and a duration of each bounce is proportional to its peak amplitude).","Unlike an absolute value of a sine wave with dampened exponential decay, the transfer function of the animation system provides for bounces that speed up properly at smaller bounces (i.e., the bounces are closer together as they would occur naturally), and whose amplitude is symmetric around peaks (i.e., the amplitude is not smaller after the bounce as would occur naturally if air friction is ignored). Symmetric bouncing is visually more accurate because air friction on this scale is negligible, so the only loss in energy is due to the collision with the ground between bounces. In addition, a sine wave with dampened exponential decay may not pass through a destination point as expected. Thus, although the animation system can be used with a variety of transfer functions, including sine wave based simulations, in its default implementation the system provides results that are more realistic.",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1","b":["100","110","120","130","140","150","160"]},"The application interface component  provides an interface between a software application and the system . An application may include many user interface objects or other visual objects for which the animation provided by the system  produces a visually pleasing effect. Thus, the application may invoke the system to calculate an object's position during an animation so that the application can display the object appropriately. For example, an application may animate a bouncing ball or a window moving from one location to another with a bounce effect, and use the system to determine the object's position at regular intervals over a period of the animation. The application interface component  may include an object model, classes, functions, and other common application interface techniques for an application to provide data to the system  and receive one or more results.","The input component  receives one or more parameters that affect a particular animation. For example, the input component  may receive a bounciness coefficient and a current time at which the software application wants to determine the position of an object having the specified bounciness. The input component  may receive parameters based on initialization values of a declared class that inherits from a class provided by the system  as well as function parameters or other method of passing data between software components. The input component  may also receive an animation mode that it provides to the animation mode component  to alter behavior of the animation produced by the system .","The animation mode component  receives one or more animation modes from the software application and modifies behavior of the system  based on a received mode. In some embodiments, the animation system  provides multiple modes. For example, for a bounce animation, the system may allow an object to ease in (i.e., opposite of gravity, smaller to larger bounces), ease out (i.e., like an object dropped under the influence of gravity), or both ease in and out (i.e., start small and bounce to a peak, then trail off again). If an ease in is thought of as a function of time (f(t)) that provides amplitude on a unit scale, then ease out is the reverse (e.g., 1.0\u2212f(1.0\u2212t)).","The stateless animation component  determines a current animated value of an animated object based on a specified time. The stateless animation component  uses a stateless transfer function to determine the current animated value without performing a long simulation from the beginning to the current time. The software application may invoke the system repeatedly at regular intervals (e.g., in an animation loop) to determine a present position at which to display the animated object. The stateless animation component  may provide a variety of animation types or transfer functions through the animation mode component  that an application can select to obtain different animation behavior.","The output component  provides the current animated value of the animated object as a result to the software application. For example, the software application may invoke a class method of the system and receive the result as a return parameter. The animated value may include a position or other animated properties, such as color, rotation angle, and so forth. Although position is used herein as an example, a position may include these other types of animated values. The output component  may also communicate with a display component  to display the animated object. As the software application invokes the system  over time the output component  provides the current position of the animated object at whatever time is specified by the software application.","The display component  optionally displays the animated object. While the system  may be used in some embodiments by software applications that provide their own display capabilities and use the system  to receive position values and other animation characteristics, the system  may also be implemented in a manner in which the system  provides the displayed animation through the display component . The system may provide a default display capability that applications can override for more complex object types or animations.","The computing device on which the system is implemented may include a central processing unit, memory, input devices (e.g., keyboard and pointing devices), output devices (e.g., display devices), and storage devices (e.g., disk drives or other non-volatile storage media). The memory and storage devices are computer-readable storage media that may be encoded with computer-executable instructions (e.g., software) that implement or enable the system. In addition, the data structures and message structures may be stored or transmitted via a data transmission medium, such as a signal on a communication link. Various communication links may be used, such as the Internet, a local area network, a wide area network, a point-to-point dial-up connection, a cell phone network, and so on.","Embodiments of the system may be implemented in various operating environments that include personal computers, server computers, handheld or laptop devices, multiprocessor systems, microprocessor-based systems, programmable consumer electronics, digital cameras, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and so on. The computer systems may be cell phones, personal digital assistants, smart phones, personal computers, programmable consumer electronics, digital cameras, and so on.","The system may be described in the general context of computer-executable instructions, such as program modules, executed by one or more computers or other devices. Generally, program modules include routines, programs, objects, components, data structures, and so on that perform particular tasks or implement particular abstract data types. Typically, the functionality of the program modules may be combined or distributed as desired in various embodiments.",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 2","b":["210","220"]},"Continuing in decision block , if the received animation mode specifies an ease in animation behavior, then the component continues at block , else the component continues at block . Continuing in block , the component invokes a stateless animation component to determine a current position of an animated object based on the received input parameters. In the example shown, an ease in animation is handled by the transfer function of the stateless animation component by default, so that the time is passed in directly (although it may be normalized first to a unit scale) to the stateless animation component to receive the appropriate resulting position back.","Continuing in decision block , if the received animation mode specifies an ease out animation behavior, then the component continues at block , else the component continues at block . Continuing in block , the component invokes a stateless animation component to determine a current position of an animated object based on the received input parameters. In the example shown, an ease in animation is handled by the transfer function of the stateless animation component by default, so that for an ease out behavior the time scale is reversed by passing 1.0 minus the input time. The result is also flipped by subtracting the result from 1.0 to receive the appropriate resulting position back.","Continuing in decision block  (corresponding to an ease in\/out animation mode), if the received input time is less than 0.5 (halfway complete), then the component continues at block , else the component continues at block . Continuing in block , the component invokes a stateless animation component to determine a current position of an animated object based on the received input parameters. In the example shown, the first half of the animation is an ease in, and thus the input time is doubled and the result is cut in half. This fits an ease in animation to the first half of the unit time scale. If, on the other hand execution continues to block , where the second half of the animation is an ease out, then the input time is reversed, the result is flipped, and the animation is scaled to fit the appropriate half of the unit time scale.","Continuing in block , the component returns the result from the stateless animation component as a response to the caller. The result indicates a current position of the animated object in a particular coordinate system. After block , these steps conclude. Note that although the stateless animation component is shown here as producing a default ease in animation and the input parameters and result are modified to produce other behaviors, other transfer functions can be used with the system that may include a different default behavior and other modifications of the input parameters and result to produce different behaviors. Thus, the implementation shown is provided as an example to demonstrate one function of the system without limiting other possible implementations.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3","b":["310","320"]},"Continuing in block , the component projects a start and end time of the current bounce into time space. The component can determine the start and end times based on the current bounce and the bounciness coefficient. A proper bounce takes less and less time as the animation progresses (for ease out). Many bounce techniques fail to properly simulate this aspect of bouncing animation, unlike the animation system described herein. Continuing in block , the component determines a duration and peak of the current bounce to which to fit a curve. For example, the peak can be found at the mid-point of the start and end time, and the amplitude of the peak can be determined based on the bounciness coefficient.","Continuing in block , the component determines a curve that fits the determined start time, end time, and peak of the current bounce. For example, the system may fit a quadratic curve that passes through the start and end time points and peaks at an amplitude that matches the bounce peak. Continuing in block , the component returns a resulting position based on the determined curve and the received input parameters. The time specified in the input parameters will determine which position on the fit curve to return. Note that no state is stored by the steps described herein between iterations. The system can efficiently determine the current position based on the received input parameters without executing a costly simulation from start to finish (or from start to a current time). After block , these steps conclude.","A bounce transfer function as described herein may be a function of three input parameters: number of bounces (\u03b1), bounciness (\u03b2), and time (t). The bounciness is a relative duration between two consecutive bounces. For example, a bounciness of two means that the second bounce is twice as high as the first bounce. Time is normalized time between 0 and 1. In some embodiments, given the input values above, the bounce transfer function follows the steps below to compute the bounce height.",{"@attributes":{"id":"p-0032","num":"0031"},"maths":[{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mn":"1.","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"pow"},"mo":"=","msup":{"mi":["\u03b2","\u03b1"]}}}},{"@attributes":{"id":"MATH-US-00001-2","num":"00001.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mn":"2.","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"oneMinusBounciness"},{"mn":"1","mo":"-","mi":"\u03b2"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00001-3","num":"00001.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mn":"3.","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"sumOfUnits"},{"mfrac":[{"mrow":{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mi":"pow"}},"mi":"oneMinusBounciness"},{"mi":"pow","mn":"2"}],"mo":"+"}],"mo":"="}}}],"br":{}},"4. unitAtT=t*sumOfUnits","Maps the normalized time input onto the unit scale.","5. bounceAtT=log(1\u2212unitAtT*oneMinusBounciness)","Computes which bounce the animation would be in based on the normalized time. This will give, e.g., 2.3, which means t is 30% into the second bounce.","6. start=\u2514bounceAt\u2518, end=start+1","Truncate the previous value to the nearest integer less than bounceAtT. 2.3 will become 2 for start and 3 for end.",{"@attributes":{"id":"p-0036","num":"0035"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":{"mn":"7.","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mi":"startTime"},"mo":"=","mfrac":{"mrow":[{"mn":"1","mo":"-","msup":{"mi":["\u03b2","start"]}},{"mi":["oneMinusBounciness","sumOfUnits"],"mo":"*"}]}},{"mi":"endTime","mo":"=","mfrac":{"mrow":[{"mn":"1","mo":"-","msup":{"mi":["\u03b2","end"]}},{"mi":["oneMinusBounciness","sumOfUnits"],"mo":"*"}]}}],"mo":[",","\u2062","\u2062"],"mstyle":[{"mtext":{}},{"mspace":{"@attributes":{"width":"1.7em","height":"1.7ex"}}}]}}}},"8. Given the start time and end time of the bounce (in the normalized time scale), the system computes the duration and the peak of the curve, and then fits a quadratic curve given these set of points.","9. The final step in evaluating the bounce transfer function is to evaluate this quadratic equation at time t:",{"@attributes":{"id":"p-0039","num":"0038"},"maths":[{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"4.4em","height":"4.4ex"}}},"mo":"\u2062","mrow":{"mi":"midtime","mo":"=","mfrac":{"mrow":{"mi":["startTime","endTime"],"mo":"+"},"mn":"2"}}}}},{"@attributes":{"id":"MATH-US-00003-2","num":"00003.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"4.4em","height":"4.4ex"}}},"mo":"\u2062","mrow":{"mi":"timeRelToPeak","mo":"=","mrow":{"mi":["normalizedTime","midTime"],"mo":"-"}}}}},{"@attributes":{"id":"MATH-US-00003-3","num":"00003.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"4.4em","height":"4.4ex"}}},"mo":"\u2062","mrow":{"mi":"radius","mo":"=","mrow":{"mi":["midTime","startTime"],"mo":"-"}}}}},{"@attributes":{"id":"MATH-US-00003-4","num":"00003.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mstyle":{"mspace":{"@attributes":{"width":"4.4em","height":"4.4ex"}}},"mo":"\u2062","mrow":{"mi":"amplitude","mo":"=","msup":{"mrow":[{"mo":["(",")"],"mfrac":{"mn":"1","mi":"\u03b2"}},{"mi":["bounces","start"],"mo":"-"}]}}}}},{"@attributes":{"id":"MATH-US-00003-5","num":"00003.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"output","mo":"=","mrow":{"mrow":[{"mo":"-","mfrac":{"mi":"amplitude","msup":{"mi":"radius","mn":"2"}}},{"mo":["(",")"],"mrow":{"mi":["timeRelToPeak","radius"],"mo":"-"}},{"mo":["(",")"],"mrow":{"mi":["timeRelToPeak","radius"],"mo":"+"}}],"mo":["\u2062","\u2062"]}}}}]},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 4","b":["410","420","410"]},"The graph  shows a sample bounce function. The transfer function for a bounce has a domain in the 0-1 range and a range in the 0-1 range. The bounces are computed such that the peak of the last bounce is at 1.0. The number of bounces for a bounce function does not include the last half bounce bringing it back to the peak. Thus, the graph  shows a bounce function with two bounces. The graph  shows the same bounce function with additional parameters defined by the animation system. The system defines a duration of the first bounce to be one unit. The duration of subsequent bounces depends on the bounciness factor. For inputs \u03b1=2 and \u03b2=2, then the total units will be five (1 for first bounce+2 for second bounce+4\/2 for the last half bounce to get back to the peak of the bounce). In graph  the current time t is part way into the second bounce so start will be 1 and end will be 2.","The following example C# code shows one possible implementation of the steps described herein and illustrated further with reference to . The EaseInCore function provides a function that returns a current position for an ease in type of bounce animation based on input parameters that specify a current normalized time, a number of bounces, and a bounciness factor. The Ease function wraps the EaseInCore function to provide other animation modes, such as ease out and ease in\/out, as described further herein.",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"protected override double EaseInCore(double normalizedTime)"},{"entry":"{"},{"entry":"\u2003\u2003\/\/ The math below adheres to the following goals to get the correct"},{"entry":"\u2003\u2003\/\/ look for a bounce:"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["\u2003\u2003\/\/ \u20021)","The bounces will be symetrical"]},{"entry":["\u2003\u2003\/\/ \u20022)","Bounciness will control both the amplitude and the period"]},{"entry":["\u2003\u2003\/\/","of the bounces"]},{"entry":["\u2003\u2003\/\/ \u20023)","Bounces will control the number of bounces without"]},{"entry":["\u2003\u2003\/\/","including the final half bounce to get back to 1.0"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\/\/"},{"entry":"\u2003\u2003\/\/ Constants"},{"entry":"\u2003\u2003double bounces = Math.Max(0.0, (double)Bounces);"},{"entry":"\u2003\u2003double bounciness = Bounciness;"},{"entry":"\u2003\u2003\/\/ Clamp the bounciness to avoid divide by zero"},{"entry":"\u2003\u2003if (bounciness < 1.0 || DoubleUtil.IsOne(bounciness))"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\/\/ Make it just over one. \u2002In practice, this will look like 1.0"},{"entry":"\u2003\u2003\u2003\u2003\/\/ but avoid divide by zero errors."},{"entry":"\u2003\u2003\u2003\u2003bounciness = 1.001;"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003double pow = Math.Pow(bounciness, bounces);"},{"entry":"\u2003\u2003double oneMinusBounciness = 1.0 \u2212 bounciness;"},{"entry":"\u2003\u2003\/\/ \u2018unit\u2019 space calculations."},{"entry":"\u2003\u2003\/\/ Bounces grow in the x axis exponentially. \u2002The"},{"entry":"\u2003\u2003\/\/ first bounce has a \u2018unit\u2019 width of 1.0 and"},{"entry":"\u2003\u2003\/\/ the total number of \u2018units\u2019 is determined using a geometric"},{"entry":"\u2003\u2003\/\/ series, then compute which \u2018unit\u2019 the current time is in."},{"entry":"\u2003\u2003double sumOfUnits = (1.0 \u2212 pow) \/ oneMinusBounciness +"},{"entry":"\u2003\u2003pow * 0.5;"},{"entry":"\u2003\u2003double unitAtT = normalizedTime * sumOfUnits;"},{"entry":"\u2003\u2003\/\/ \u2018bounce\u2019 space calculations."},{"entry":"\u2003\u2003\/\/ Knowing which \u2018unit\u2019 the current time is in, this can"},{"entry":"\u2003\u2003\/\/ determine which bounce the animation is in by solving the"},{"entry":"\u2003\u2003\/\/ following geometric equation for bounce:"},{"entry":"\u2003\u2003\/\/ unitAtT = (1 \u2212 bounciness{circumflex over (\u2009)}bounce) \/ (1 \u2212 bounciness)"},{"entry":"\u2003\u2003double bounceAtT = Math.Log(\u2212unitAtT * (1.0\u2212bounciness) + 1.0,"},{"entry":"\u2003\u2003\u2003\u2003bounciness);"},{"entry":"\u2003\u2003double start = Math.Floor(bounceAtT);"},{"entry":"\u2003\u2003double end = start + 1.0;"},{"entry":"\u2003\u2003\/\/ \u2018time\u2019 space calculations."},{"entry":"\u2003\u2003\/\/ Project the start and end of the bounce into \u2018time\u2019 space"},{"entry":"\u2003\u2003double startTime = (1.0 \u2212 Math.Pow(bounciness, start)) \/"},{"entry":"\u2003\u2003\u2003\u2003(oneMinusBounciness * sumOfUnits);"},{"entry":"\u2003\u2003double endTime = (1.0 \u2212 Math.Pow(bounciness, end)) \/"},{"entry":"\u2003\u2003\u2003\u2003(oneMinusBounciness * sumOfUnits);"},{"entry":"\u2003\u2003\/\/ Curve fitting for bounce."},{"entry":"\u2003\u2003double midTime = (startTime + endTime) * 0.5;"},{"entry":"\u2003\u2003double timeRelativeToPeak = normalizedTime \u2212 midTime;"},{"entry":"\u2003\u2003double radius = midTime \u2212 startTime;"},{"entry":"\u2003\u2003double amplitude = Math.Pow(1.0 \/ bounciness, (bounces \u2212 start));"},{"entry":"\u2003\u2003\/\/ Evaluate a quadratic that hits (startTime,0), (endTime, 0), and"},{"entry":"\u2003\u2003\/\/ peaks at amplitude."},{"entry":"\u2003\u2003return (\u2212amplitude \/ (radius * radius)) * (timeRelativeToPeak \u2212"},{"entry":"\u2003\u2003\u2003\u2003radius) * (timeRelativeToPeak + radius);"},{"entry":"}"},{"entry":"public double Ease(double normalizedTime)"},{"entry":"{"},{"entry":"\u2003\u2003switch (EasingMode)"},{"entry":"\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003case EasingMode.EaseIn:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return EaseInCore(normalizedTime);"},{"entry":"\u2003\u2003\u2003\u2003case EasingMode.EaseOut:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ EaseOut is the same as EaseIn, except time is reversed"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ and the result is flipped."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return 1.0 \u2212 EaseInCore(1.0 \u2212 normalizedTime);"},{"entry":"\u2003\u2003\u2003\u2003case EasingMode.EaseInOut:"},{"entry":"\u2003\u2003\u2003\u2003default:"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ EaseInOut is a combination of EaseIn and EaseOut fit to"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\/\/ the 0-1, 0-1 range."},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003return (normalizedTime < 0.5) ?"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003EaseInCore( \u2003\u2003\u2003\u2003normalizedTime \u2003* 2.0 ) *"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u20030.5 : (1.0 \u2212 EaseInCore((1.0 \u2212 normalizedTime) *"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u20032.0)) *0.5 + 0.5;"},{"entry":"\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In some embodiments, the animation system is implemented in an application-programming interface (API) that developers can invoke to provide animations for their software applications. For example, implementations of the animation system are currently provided in the SILVERLIGHT\u2122 3.0 and WINDOWS\u2122 Presentation Foundation 4.0 APIs. The animation system can also be integrated into a single software application or packaged differently in other APIs or graphics libraries as appropriate for a particular application.","The stateless nature of the animation provided by the animation system allows common user interface paradigms to be implemented more easily. For example, because the system can efficiently determine a position of the animation at any given time, it is easy to reverse the animation or seek to a particular position in the animation simply by specifying the right time parameters. Thus, recording of user interface (UI) behavior and later playback are provided inherently by the system. Previous simulation techniques become unwieldy in such situations.","In some embodiments, the animation system caches parts of the bounce transfer function. For example, for a given bounciness and bounce, it is possible for the system to avoid determining a curve at every call and the system can instead cache the determined curve and use the cached curve to respond to later calls to the transfer function. Such techniques are optimizations that do not affect the results provided by the system but may improve the efficiency, particularly for performance sensitive uses of the system (e.g., a user interface function invoked at high frequency).","In some embodiments, the animation system may be provided as a delegate or via inheritance rather than as an interface. An interface has the advantage integrating more easily with declarative systems, such as an Extensible Application Markup Language (XAML)-based declarative user interface definition. However, it is also possible to provide the system to third party code using other programming techniques such as delegates, was will be recognized by those of ordinary skill in the art. The system may also provide, in some embodiments, its own internal clock that progresses the animation forward and calls out to an external software application with the progress of the animation. These and other variations are not explicitly described herein but are within the skill of those skilled in the art.","From the foregoing, it will be appreciated that specific embodiments of the animation system have been described herein for purposes of illustration, but that various modifications may be made without deviating from the spirit and scope of the invention. Accordingly, the invention is not limited except as by the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
