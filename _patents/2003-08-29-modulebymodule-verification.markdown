---
title: Module-by-module verification
abstract: A method, computer program, signal transmission and apparatus pre-verify instructions in a module of a computer program one module-at-a-time. First it is determined whether checking an instruction in a first module which is loaded requires information in a referenced module different than the first module. If the information is required, a constraint for the referenced module is written without loading or otherwise accessing the referenced module. During linking it is determined whether a first module which is loaded has passed pre-verification one-module-at-a-time before linking. A pre-verification constraint on a constrained module is read, if any, if the first module has passed such verification. If any pre-verification constraint is read, the pre-verification constraint is enforced if the constrained module is already loaded.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07051343&OS=07051343&RS=07051343
owner: Sun Microsystems, Inc.
number: 07051343
owner_city: Santa Clara
owner_country: US
publication_date: 20030829
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This is a continuation of application Ser. No. 09\/320,574, filed May 27,1999, now U.S. Pat. No. 6,618,769 which is incorporated herein by reference.","This application is related to U.S. patent application Ser. No. 575,291 (P1000) filed Dec. 20, 1995, Yellin and Gosling, entitled BYTECODE PROGRAM INTERPRETER APPARATUS AND METHOD WITH PRE-VERIFICATION OF DATA TYPE RESTRICTIONS AND OBJECT INITIALIZATION, now U.S. Pat. No. 5,740,441; U.S. patent application Ser. No. 09\/134,477 (P3135) filed Aug. 14, 1998, Bracha and Liang, entitled METHODS AND APPARATUS FOR TYPE SAFE, LAZY, USER-DEFINED CLASS LOADING; the disclosures of which are incorporated herein in their entireties by reference.","This application is also related to U.S. patent application Ser. No. 09\/321,223, filed May 27, 1999, entitled FULLY LAZY LINKING; U.S. patent application Ser. No. 09\/321,226, filed May 27, 1999, entitled FULLY LAZY LINKING WITH MODULE-BY-MODULE VERIFICATION; U.S. patent application Ser. No. 09\/320,581, filed May 27, 1999, entitled CACHING UNTRUSTED MODULES FOR MODULE-BY-MODULE VERIFICATION; U.S. patent application Ser. No. 09\/321,228, filed May 27, 1999, entitled DATAFLOW ALGORITHM FOR SYMBOLIC COMPUTATION OF LOWEST UPPER BOUND TYPE.","This invention generally relates to computer programming languages, and more particularly to computer programming languages with dynamic linking that verify instructions while supporting lazy loading.","In general, computer programs are written as source code statements in a high level language which is easy for a human being to understand. As the computer programs are actually executed, a computer responds to machine code, which consists of instructions comprised of binary signals that directly control the operation of a central processing unit (CPU). It is well known in the art to use a special program called a compiler to read the source code and to convert its statements into the machine code instructions of the specific CPU. The machine code instructions thus produced are platform dependent, that is, different computer devices have different CPUs with different instruction sets indicated by different machine codes.","It is also known in the art to construct more powerful programs by combining several simpler programs. This combination can be made by copying segments of source code together before compiling and then compiling the combined source. When a segment of source code statements is frequently used without changes it is often preferable to compile it once, by itself, to produce a module, and to combine the module with other modules only when that functionality is actually needed. This combining of modules after compilation is called linking. When the decision on which modules to combine depends on run time conditions and the combination of the modules happens at run time, just before execution, the linking is called dynamic linking.","An advantage of linking is that programs can be developed a module at a time and productivity can be enhanced as different developers work, possibly at different sites, simultaneously on separate modules.","An advantage of linking performed at run time, that is, dynamic linking when the program is being executed, is that modules not used during execution need not be linked, thus reducing the number of operations that must be executed and likely reducing the size of the executing code. In general, modules have to be loaded, that is identified and brought into memory, before being linked. The deferred linking of modules until the module is needed allows a deferral in loading those modules as well, which is called lazy loading.","It is prudent, when assembling several modules that may have been written independently, to check both that each module performs properly within its own four corners, i.e., with intra-module checks, and also that the modules work properly together, i.e. with inter-module checks. By analogy with the terminology used by the designers of the JAVA\u2122 programming language, this post compilation module checking can be called verification.","As an example of a computer architecture that benefits from dynamic linking is a virtual machine (VM) such as the JAVA\u2122 virtual machine (JVM) of Sun Microsystems, Inc., which is an abstract computer architecture that can be implemented in hardware or software. Either implementation is intended to be included in the following descriptions of a VM.","A VM can provide platform independence in the following manner. Statements expressed in a high level computing language, such as the JAVA\u2122 programming language, are compiled into VM instructions that are system independent. The VM instructions are to the VM what machine code is to a central processing unit (CPU). The VM instructions can then be transferred from one machine to another. Each different processor needs its own implementation of a VM. The VM runs the VM instructions by translating or interpreting the VM instructions one or more instructions at a time. In many implementations, the VM implementation is a program running on the CPU of a particular computer, but the VM instructions may also be used as the native instruction set of a particular processor or device. In the latter case, the VM is an \u201cactual\u201d machine. Other operations can also be performed by the VM including dynamic linking and verification.","The process of programming using such a VM then has two time epochs associated with it; \u201ccompile time\u201d refers to the steps which convert the high level language into the VM instructions, and \u201crun time\u201d refers to the steps which in a JAVA\u2122 VM environment, interpret instructions to execute the module. Between compile time and run time, the modules of instructions compiled from statements can reside dormant for extended, arbitrary periods of time, or can be transferred from one storage device to another, including being transferred across a network.","The problems encountered in trying to implement dynamic linking with verification and with or without lazy loading can be illustrated for the example of the JAVA\u2122 virtual machine. The JVM is a particular VM for the object oriented JAVA\u2122 high level programming language that is designed to perform dynamic linking, verification and lazy loading as described for the conventional JVM in , by T. Lindholm and Frank Yellin, Addison-Wesley, Menlo Park, Calif., 1997.","Object oriented programming techniques such as those used by the JAVA\u2122 platorm are widely used. The basic unit of object oriented programs is the object which has methods (procedures) and fields (data), herein called members. Objects that share members are grouped into classes. A class defines the shared members of the objects in the class. Each object then is a particular instance of the class to which it belongs. In practice, a class is often used as a template to create multiple objects (multiple instances) with similar features.","One property of classes is encapsulation, which describes the property that the actual implementation of the members within the class are hidden from an outside user, and other classes, except as exposed by an interface. This makes classes suitable for distributed development, for example by different developers at different sites on a network. A complete program can be formed by assembling the classes that are needed, linking them together, and executing the resulting program.","Classes enjoy the property of inheritance. Inheritance is a mechanism that enables one class to inherit all of the members of another class. The class that inherits from another class is called a subclass; the class that provides the attributes is the superclass. Symbolically, this can be written as subclass<=superclass, or superclass=>subclass. The subclass can extend the capabilities of the superclass by adding additional members. The subclass can override an attribute of the superclass by providing a substitute member with the same name and type.","The JVM operates on a particular binary format for the compiled classes\u2014the class file format. A class file contains JVM instructions and a symbol table, as well as other ancillary information. For the sake of security, the JVM imposes strong format and structural constraints on the instructions in a class file. In particular example, JVM instructions are type specific, intended to operate on operands that are of a given type as explained below. Similar constraints could be imposed by any VM. Any language with functionality that can be expressed in terms of a valid class file can be hosted by the JVM. The class file is designed to handle object oriented structures that can represent programs written in the JAVA\u2122 programming language, but may also support several other programming languages.","In the class file, a variable is a storage location that has associated a type, sometimes called its compile-time type, that is either a primitive type or a reference type. The reference types are pointers to objects or a special null reference which refers to no object. The type of a subclass is said to be a subtype of its superclass. The primitive types for the JVM include boolean (taking the truth values true and false), char (code for a Unicode character), byte (signed eight bits of 0 or 1), short (signed short integer), int (signed integer), long (signed long integer), float (single-precision floating point number) or double (double precision floating point number).","The members of a class type are fields and methods; these include members inherited from the superclass. The class file also names the superclass. A member can be public, which means that it can be accessed by members of any class. A private member may be accessed only by members of the class that contains its declaration. A protected member may be accessed by members of the declaring class or from anywhere in the package in which it is declared. In the JAVA\u2122 programming language, classes can be grouped and the group can be named; the named group of classes is a package.","The actual instructions for the JVM are contained within methods of the class encoded by the class file.","When a JAVA\u2122 language program violates constraints of an operation, the JVM detects an invalid condition and signals this error to the program as an exception. An exception is said to be thrown from the point where it occurred and it is said to be caught at the point to which control is transferred. Every exception is represented by an instance of the class Throwable or one of its subclasses; such an object can be used to carry information from the point at which an exception occurs to part of the program, an exception handler, that catches it and deals with it.","The JVM starts execution by invoking the method \u201cmain\u201d of some specified class, passing it a single argument which is an array of strings. This causes the specified class to be loaded, linked and initialized.","Loading refers to the process of finding the binary form of a class or package with a particular name, typically by retrieving a binary representation previously compiled from source code. In the JVM, the loading step retrieves the class file representing the desired class. The loading process is implemented by the bootstrap class loader or a user defined class loader. A user-defined class loader is itself defined by a class. A class loader may indicate a particular sequence of locations to search in order to find the class file representing a named class. A class loader may cache binary representations of classes, pre-fetching based on expected usage, or load a group of related classes together. The more classes that are pre-fetched or group loaded the more \u201ceager\u201d is the loader. A \u201clazy\u201d loader pre-fetches or groups as few classes as possible. The conventional JVM specification permits a broad spectrum of loading behaviors between eager and almost fully lazy.","A VM is fully lazy if it calls a class loader to load a class only at the time that the class is first necessary to execute an instruction of a class currently being processed. Fully lazy loading, if achieved, does not waste run time resources, such as system memory and execution time, loading classes that are not strictly required at run time.","Linking in the JVM is the process of taking a binary form of a class in memory and combining it into the run time state of a VM, so that it can be executed. A class must be loaded before it can be linked. Three different activities are involved in linking according to the JVM spec: verification, preparation and resolution of symbolic references.","During verification, necessary constraints on a binary class in the class file format are checked. Doing so is fundamental to the security provisions of the JVM. Verification ensures that illegal operations are not attempted by the JVM that can lead to meaningless results or that can compromise the integrity of the operating system, the file system, or the JVM itself. However, checking these constraints sometimes requires knowledge of subtyping relations among other classes; so successful verification typically depends on the properties of other classes referenced by the class being verified. This has the effect of making the current JVM design specification for verification context sensitive.","The binary classes of the JVM are essentially exemplars of general program modules that contain instructions produced from compiled source statements. Context sensitivity of validity checks means that those checks depend on information spread across more than one module, i.e., those checks are called cross-module checks or inter-module checks herein. Validity checks that do not require information from another module are called intra-module checks herein.","Context sensitive verification has some disadvantages. For example in an object oriented programming system like The JAVA\u2122 platform, it leads to a verifier initiating class loading when the verifier needs to check subtype relations among classes not already loaded. Such loading can occur even if the code referencing the other classes is not ever executed. That is, context sensitive verification can interfere with fully lazy loading. Because of this, loading can consume memory and slow execution at run time compared to a process that does not load the classes unless they are referenced by the instructions that are actually executed.","When verification is context sensitive there is also no provision for verifying one class or module at a time before run time. This is a disadvantage because classes cannot be verified ahead of time, e.g. before run time, so verification must incur a run time cost. Thus there is a need for module-by-module, also called module-at-a-time, verification before run time. Such verification is herein called pre-verification because technically it is distinct from the verification which occurs during run time linking by the JVM.","Also, since verification is performed at run time, a class that has been run once, and passed verification, is subjected to verification again each time the class is loaded\u2014even if the class is being used in the same application on the same host computer, where no new verification issues are likely or where a situation can be arranged such that no changes that would affect verification can be made. This can lead to redundant verification, thereby requiring more memory and executing more slowly during run time than ought to be necessary. Thus there is a need for an option to use pre-verified modules without further, or with minimum, verification at run time.","The needs for pre-verification and fully lazy loading are separate needs that might be met separately. There is also a need for supporting module-by-module pre-verification along with fully lazy loading.","The need for pre-verification, including reduction of run time verification, may conflict with the goals of security that require all modules supplied to a virtual machine or any computing architecture be checked at run time to prevent illegal or damaging operations. For example, in an untrusted situation, such as downloading a module and its pre-verification output from the Internet, an attacker may be able to spoof the pre-verification output\u2014possibly making a malignant class appear benign. Thus, there is a need for pre-verification that is usable in untrusted situations, as in downloading modules across the Internet.","The need for fully lazy loading or module-by-module pre-verification engenders a need for a substitute representation of a type lattice. A type lattice is a mathematical structure expressing subtyping relationships among types. A representation of a type lattice is built by the JVM for indicating the types and subtypes of classes during run time. The JVM also maintains references and types of all the attributes of the classes that are being linked. Similar run time structures are expected to be useful for any dynamic linking process. To support class-by-class pre-verification or fully lazy loading, type checking must be done without full knowledge of the type lattice, most of which is typically defined in other modules which may not yet otherwise need to be loaded. In particular, the JVM typically needs to find a LUB (lowest upper bound) type in the type lattice during verification. Thus, there is a need to perform the functions that rely on a LUB even when the type lattice is unavailable.","The foregoing and other features, aspects and advantages of the present invention will become more apparent from the following detailed description of the present invention when taken in conjunction with the accompanying drawings.","It is an object of the invention to allow verification during linking while without preventing fully lazy loading. It would be advantageous for a dynamic linker, and in particular the JVM, to require that all resolution of referenced modules (e.g. classes) would be done lazily at specific, defined points during execution of instructions (e.g., of a method). The advantages include:\n\n","It is another object of the present invention to provide one-module-at-a-time pre-verification. It is also an object of the present invention to utilize pre-verified instructions to reduce run time verification. Some users of the JAVA\u2122 platform would want to perform context insensitive, or context independent, verification checks on some classes. There are a number of advantages to context independent checking which can be performed during or after compilation and before run time. The advantages include:\n\n","It is another object of the present invention to allow one-module (or class)-at-a-time pre-verification to be combined with run time verification that may permit fully lazy loading, in order to enjoy the benefits of both at the same time.","It is another object of the present invention to allow classes from untrusted sources to be pre-verified to increase the scope of situations in which the benefits of pre-verification apply.","It is another object of the present invention to utilize a substitute for a LUB when full knowledge of the type lattice is lacking to simplify inter-module validity checks.","These and other objects and advantages of the present invention are provided by a method, computer program, signal transmission and apparatus for verifying instructions in a module of a computer program one module-at-a-time before linking. This aspect of the invention includes determining whether checking an instruction in a first module which is loaded requires information in a referenced module different than the first module. If the information is required, a constraint for the referenced module is written without loading the referenced module.","In another aspect of the invention, instructions of a pre-verified module of a computer program are verified during linking. The method, computer program product, transmission signal and apparatus include determining whether a first module which is loaded has passed verification one-module-at-a-time before linking. If the first module has passed such verification, a pre-verification constraint on a constrained module is read, if any. If any pre-verification constraint is read, it is determined whether the constrained module is loaded. If the constrained module is loaded, the pre-verification constraint is enforced.","In another aspect of the invention, a pre-verification system includes a network and a computer readable storage medium connected to the network for storing a module of a computer program. A memory into which a module may be loaded is also connected to the network. A processor connected to the network is configured to determine before linking whether checking an instruction in a first module which is loaded requires information in a referenced module different than the first module, and to write a constraint for the referenced module without loading the referenced module if the information is required. This way, verification is performed one module at a time before linking. The same or a different processor is connected to the network and is configured to determine during linking whether a first module which is loaded has passed verification one-module-at-a-time before linking. A pre-verification constraint on a constrained module is read, if any, if the first module has passed verification. If any pre-verification constraint is read, the pre-verification constraint is enforced if the constrained module is already loaded. This way verification is performed one-module-at-a-time before linking with reduced verification during linking.","The detailed descriptions which follow may be presented in terms of program procedures executed on a computer or network of computers. These procedural descriptions and representations are the means used by those skilled in the art to most effectively convey the substance of their work to others skilled in the art.","A procedure is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. These steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It proves convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like. It should be noted, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to those quantities.","Further, the manipulations performed are often referred to in terms, such as adding or comparing, which are commonly associated with mental operations performed by a human operator. No such capability of a human operator is necessary, or desirable in most cases, in any of the operations described herein which form part of the present invention; the operations are machine operations. Useful machines for performing the operations of the present invention include general purpose digital computers or similar devices.","The present invention also relates to apparatus for performing these operations. This apparatus may be specially constructed for the required purpose or it may comprise a general purpose computer as selectively activated or reconfigured by a computer program stored in the computer. The procedures presented herein are not inherently related to a particular computer or other apparatus. Various general purpose machines may be used with programs written in accordance with the teachings herein, or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these machines will appear from the description given.",{"@attributes":{"id":"p-0068","num":"0073"},"figref":["FIG. 1A","FIG. 1A","FIG. 1A"],"b":["100","110","110","110","110","110","110","120","130","140"]},{"@attributes":{"id":"p-0069","num":"0074"},"figref":["FIG. 1B","FIG. 1A"],"b":["150","155","160","165","170","150","173","172","171","125","120","175"]},{"@attributes":{"id":"p-0070","num":"0075"},"figref":["FIG. 1C","FIG. 1B","FIG. 1A"],"b":["173","110"]},{"@attributes":{"id":"p-0071","num":"0076"},"figref":"FIG. 1D","b":["190","100","195","100","190","180"]},{"@attributes":{"id":"p-0072","num":"0077"},"figref":["FIG. 1E","FIG. 1E","FIG. 1D","FIG. 1E"],"b":["162","164","162","165","166","167","165","166","165","167","194","192","195","150","151","100","100","192","162","196","194","195","190","156","100","150","156"]},"Specifically, the present invention is described using the JVM but is not limited to the JVM. The invention applies to any process which at run time links program modules from various sources, and which verifies those program modules before they are executed.","As an example of pseudo-source code for a program module representing a class that exhibits the conditions that cause problems to be solved by the present invention,  shows pseudo source code written in a programming language similar to the JAVA\u2122 programming language. The first line names the class \u201cBAR.\u201d The first set of ellipses represents other statements that contribute to the definition of class BAR but will not be considered here. The next line through the end of the example defines a method named FOO in the class BAR (also denoted as BAR.FOO); the type \u201cvoid\u201d indicates that no value is returned when an invocation of the method FOO terminates. The next line introduces an \u201cif else\u201d construct that provides two branches during execution. If the method argument, named \u201carg,\u201d is true, one branch is executed, represented by the next set of ellipses, the assignment statement inside the braces and the following ellipses. The assignment statement states that the variable named \u201cvar\u201d of class type A will be assigned a new instance of the class B. Thus, in this branch, reference is made to two other classes, class A and class B, the referenced classes. The next line, the else of the if else construct, signals the beginning of an alternate branch of the method, the branch taken if arg is false. This alternate branch is contained between the next braces and is represented by another set of ellipses to indicate that no reference is made to either class A or B in this branch. The branches converge again at the statement where the value of variable z is assigned to its original value squared.","Using example class BAR and its method FOO, the difference between eager loading, almost lazy loading, and fully lazy loading, and the advantages of the present invention, can be illustrated in a virtual machine such as the JVM. Of course, the JVM does not operate on the JAVA\u2122-like programming language listed in , but operates instead on a module containing instructions typically generated by a compiler; the compiler operated on the high level programming language code such as that listed in .",{"@attributes":{"id":"p-0076","num":"0081"},"figref":["FIG. 3","FIG. 3"],"b":["310","1","320","2","3","1","2","3"]},"During linking , verification is performed by the JVM. Many details on the procedures used during verification are described in U.S. Pat. No. 5,740,441 referenced above. As described in that patent, verification includes identifying any instruction sequence in a method that attempts to process data of the wrong type, or any instructions that would cause underflow or overflow of an operand stack of the virtual machine. Instructions in the JVM are type specific, so the operands operated on by the instruction must match the type the instruction is defined for. Operand stack overflow is an attempt to put an item, such as a primitive value or object reference, on an operand stack that would cause the stack to exceed the preset maximum size for the stack defined in the class file, i.e. when the stack is already full. Operand stack underflow occurs when an instruction attempts to take an item from an operand stack when there are no valid items left on the stack, i.e., when the stack is already empty. It is anticipated that any validity checks that can be performed prior to execution of the instructions in a module may be included in verification.","If verification of a module fails, the virtual machine should identify the error and not attempt to execute the instructions in the module. In the case of the JVM, the JVM throws a linkage or verification error message (not shown) that can be handled gracefully by class exception handlers.","If verification of a module succeeds and linking is complete, execution may begin. In this example case, the current class BAR may be initialized, step , and the method FOO.BAR of the current class is run, step , as the JVM interprets each instruction and executes it. The interpreter does not need to check types, or operand stack overflow or underflow, because that was already done by verification performed during linking .","Two advantages of the process involving dynamic linking, described above, are that classes developed and compiled by others can be used safely and that, after linking, execution is faster. Classes compiled by others can be used because they are verified during linking, prior to execution, to prevent invalid, and possibly dangerous operations. Because type checking and operand stack overflow and underflow were performed during verification, they are not performed upon instruction execution, so that execution times are faster. Similarly, other validity checks performed during verification can be safely skipped at execution.","In lazy loading, as illustrated in , a class is not loaded until it is needed during execution. The advantage of this can be illustrated with the sample class BAR in . If arg is false, the assignment referencing classes A and B in the \u201cif\u201d branch is never made, and neither A nor B may need be loaded or linked. Thus processing is faster at run time with lazy loading.","For example, as shown in , after loading class BAR with class loader L in step , classes A and B referenced by BAR are not immediately loaded. Instead, class BAR is verified during linking in step ; and, if class BAR passes verification and linking, the JVM goes on to initialize class BAR in step . On the other hand, if class BAR does not pass linking and verification, then an error message is thrown (not shown) and execution is not attempted (not shown). After class BAR is initialized in step , the main method in class BAR is executed and eventually method FOO is invoked in step . If the variable arg is false, the \u201celse\u201d branch is taken in method FOO and neither class A nor class B is used. This is represented in  by the decision step  determining whether the current instruction requires resolving a reference to class B. If class B is not required, the current instruction is executed and execution continues with the next instruction looping back to  until no more instructions remain to be verified. If, on the other hand, variable arg is true, the \u201cif\u201d branch is executed. This branch contains the assignment in which the variable var of type class A is set to a new instance of class B. When the first instruction referencing B is encountered, a method of class B must be invoked (the constructor of B), and the reference to class B must be resolved. The test represented by step , asking whether B must be resolved for this instruction, is answered in the affirmative. Then, step  loads class B, if it is not already loaded, using class loader L.","In the conventional JVM, processing simply continues where a Post Load step  is shown in , and moves directly to step . Since a new instance of class B is being created, it must first be linked and initialized. So, the next step is for class B to be linked in step  if it has not already been linked. If class B passes linkage (including verification) in step , then in step  class B is initialized and then processing continues in step , in which the newly-resolved class B can be used by the current instruction.","This flow appears to be fully lazy in that a class is not loaded until it is needed to resolve a reference during execution. As will be shown later, however, according to the conventional JVM spec, the verifying step during linking  might require the loading of class B. In such a case, the process cannot be considered fully lazy; and the process is called almost lazy loading.","One problem identified during almost lazy loading illustrated in , is class name ambiguity. When several classes are compiled together, the compiler generates a name space containing class names that are unique within the name space. However, when several classes are compiled at different times by different compilers, name uniqueness for a class cannot be guaranteed. At run time, class loaders may introduce multiple name spaces. As a result, a class type during run time is defined not by its name alone but rather by the combination of the class name and its defining class loader, e.g. <BAR,L>. This circumstance can fool the verifier even in the conventional system where the verifying step loads all referenced classes needed to resolve types. During Linking , including verification, it is assumed that the referenced class, e.g. B, has the type that would be conferred by the current class loader, e.g., L; that is, the \u201ctype\u201d of class B is assumed to be <B,L>. If this assumption is not true, then problems of access privileges can arise. For example, if B's class loader L is different than BAR's class loader L, and if <B,L> declares a variable to be private that <B,L> declares to be public, then VM may allow access to the private variable from outside the class B and program security can be compromised.","In the most recent version of the JVM spec, the second edition, released April, 1999, this problem is avoided as described in another related application, U.S. Ser. No. 09\/134,477 Bracha and Liang, entitled METHODS AND APPARATUS FOR TYPE SAFE, LAZY, USER-DEFINED CLASS LOADING, also referenced above.  shows a flowchart illustrating the solution utilized in the second edition of the JVM specification. Using this solution, extra steps are included in the Post Load step . The step  determines whether class B, as actually loaded with L, produces the type assumed based on the name and BAR's loader L; i.e., step  determines whether <B,L> equals <B,L>. If loading B actually produces a type different from the type assumed, then class B fails the name\/type constraint, and an error is thrown in step . Otherwise, execution continues in step . This process, described in the application cited immediately above, does not change the fact that the linking in step  might require loading the referenced classes A and\/or B to check subtyping for their use by class BAR, as described below. Thus the cited patent application does not solve the problems interfering with providing fully lazy loading.","Verification steps within linking  of  are illustrated for the example using , B and C.  is a flowchart that shows that linking class BAR in step  includes starting verification of the current class BAR  followed eventually by a step  in which the method FOO of current class BAR undergoes verification. Subsequently, the verification of class BAR within step  is finished in step . The procedures employed during the conventional embodiment of step  to verify method FOO of class BAR, are shown in . The method starts in step . If the method references other classes such as A and B, and which are not yet already loaded, the verify process may need to load classes A and\/or B. This first determination is made for each instruction in step . If referenced class B is needed, it is then determined whether class B is already loaded, step . If needed and not already loaded, the referenced class is loaded, step . Thus, even though lazy loading is desired, verification of methods may load other classes before the classes are actually needed during execution. As represented by step , if an incorrect subtyping relation between A and B or other verification problem is found during verification, a verification error is thrown in step . If the current instruction passes verification, the verification process continues to the end of the method in step  looping back to step  until no more instructions need to be verified. That is, a sufficient set of instructions are verified so that execution of the method may begin.",{"@attributes":{"id":"p-0088","num":"0093"},"figref":["FIG. 5C","FIG. 4B","FIG. 2"],"b":["537","533","534","535","536"]},"As shown by , verification of a method that references other classes may prevent fully lazy loading because the verifier may have to load referenced classes. The loading of referenced classes is not assured\u2014it depends upon the context in which the references are made. In the example, A must be a superclass of B for the assignment statement to be legal. This subtyping relationship can be checked by loading class B. If A is a superclass of B, A would have itself been loaded in the process of loading B. If A is not loaded after loading B, it cannot be a superclass B. If A is loaded, one can directly check if the relation holds.","Verification with Fully Lazy Loading","To achieve fully lazy loading with verification according to the present invention, it must be made possible to delay the checking of cross-module relationships that trigger loading according to conventional practice.","If, during the verification of example class BAR, B is already loaded, one can determine immediately if the subtyping relation holds. The supertype has either been loaded when loading B or else it cannot be a supertype of B. If class B is not already loaded, according to the present invention, a constraint is placed or imposed on class B which will be checked or enforced after class B is loaded, if ever. An example of this embodiment of the invention is illustrated in  through .",{"@attributes":{"id":"p-0093","num":"0098"},"figref":["FIG. 6A","FIG. 5A","FIG. 5B"],"b":["530","530","530","632","655","640","637","639","682"],"i":["b","a "]},"However, if it is determined in step  that class B is not already loaded, the class loader for class B is not called to load class B at this time. Instead, verification constraints for class BAR's use of class B are written in step . Then it is assumed all cross-module checks on B, such as subtyping checks, are passed, and the verification of method FOO continues in step  as before. The circumstances that lead to writing constraints, and the form of those constraints, in step , are described in more detail later for the examples. According to this embodiment of the present invention, the verification step during linking does not interfere with the fully lazy loading of modules, as is desired.","Verification with Symbolic Computation of LUB.","If a referenced module or class is not yet loaded, it remains not loaded during such fully lazy linking. In the JVM, this impacts the result of merging snapshots because the LUB inserted in step , illustrated in , may not be known. Stated another way, the representation of the type lattice by the JVM may not be sufficiently populated to determine the LUB for the multiple different referenced types.  shows how the merge snapshots function is accomplished according to one embodiment of the present invention. Steps , ,  and  are analogous to corresponding steps , ,  and . However, in step , if the LUB is not known, its type cannot be inserted into the appropriate position of the merged snapshot. Instead, a list of referenced types at the appropriate fixed position in the snapshots of the predecessor instructions is inserted or otherwise associated with that fixed position in the merged snapshot. That is, instead of identifying and placing the reference to a LUB in the snapshot at this location by loading classes or modules as necessary to construct the type lattice, the several references to different types, e.g., class types X, X, . . . , X, that cause the need for an LUB, are listed symbolically, perhaps separated by a sign or symbol such as a ^. The symbol indicates the types must share this relationship of having an LUB.","Constraint Enforcement.","The constraints written or otherwise recorded for use by the VM in steps  are enforced, e.g. checked, when and if referenced class B is actually loaded. Thus, the constraints are enforced immediately after loading during the Post Load step represented by step  in .  illustrates the enforcement of verification constraints on referenced class B according to an example embodiment of the present invention. This embodiment of the invention represents a new process that may include the steps of illustrated in . The enforcement begins at step . In the examples, the actual supertypes of B are used to determine whether B satisfies the subtyping verification constraints previously written. This check is made in step . If the referenced class B does not satisfy the constraints, then an error is thrown in step . The handler for this error may then terminate execution or allow execution to continue. Alternatively, execution may be terminated without throwing an error. If the referenced class B does satisfy the written constraints, then Post Load processing finishes in step .","With such modifications, a VM can implement fully lazy loading with verification. The advantages of imposing fully lazy loading include:\n\n","One of the advantages of the present invention is that a programmer can test for the availability of classes on a platform in a reliable and simple way. For example, if a programmer wishes to use modules of a newer release and use those newer modules only if they are available, then lazy linking makes that easier. Somewhere in the code produced by the programmer in this case will be a branch with a reference to the new modules of the new release. Execution of that branch would be designed by the programmer to not occur if the current version of the platform does not support the modules referenced in that branch. If the new module is not available on that platform, and the module being verified references the new module, a virtual machine which is not fully lazy may require the verifier to attempt to load the missing new module. This loading will necessarily fail, which will lead to failure of the verification step. Thus, verification will cause a failure due to a missing module even though the module is only referenced in a branch that would never be executed. With fully lazy loading required, verification will not fail due to modules referenced by instructions not actually executed. This ability to pass verification while checking for the latest releases of modules, such as classes, provides a significant motivation for adopting fully lazy loading, supported by the present invention, as a requirement of a virtual machine.","Even with required lazy loading, different implementations of a VM could be free to load and link earlier\u2014provided that any failures manifest themselves only at the legal, defined points. The code must be able to execute up to the point when the class with the faulty type must be resolved. For example, a just-in-time (JIT) code generator may choose to prelink a class or method as it compiles it. However, if any of the linking fails, rather than failing immediately, the JIT should generate code that will cause the appropriate exception to be raised at the point lazy loading would have otherwise done so (it need not actually do the link time tests, though it can). As another example, a static compiler can fail during its proprietary link phase due to an invalid class reference. If, nonetheless, it chooses to compile code even though it cannot be completely linked, that code must fail when executed, at the same point as would code complied by the JIT. As a final example, when dynamically loading a class (e.g., through a class loader), an implementation may choose to prelink it, wholly or partially. However, if there are any failures, the code must again be able to execute up to the point of the invalid reference.","Module-by-Module Verification","In another aspect of the present invention, verification of a referenced module is not performed even if a referenced module is loaded. This module-by-module verification, also called one-module(class)-at-a-time verification, is desirable for a number of reasons. It allows verification to be performed before run time with beneficial consequences. The run time costs of verification in time and space can be reduced or removed altogether. Redundant or run-by-run verification can be obviated. The JAVA\u2122 runtime environment can be smaller and simpler because the amount of code implementing verification it contains can be reduced. This one-module-at-a-time verification, implemented as an extension to the JAVA\u2122 platform as class-by-class verification, is not automatically provided by either the conventional JVM specification, or the proposed fully lazy loading described above. In the first case, the verifier automatically loads referenced classes if needed with no option to avoid doing so. In the latter case, verification of the referenced class will occur if the referenced class is loaded and this verification is also performed with no option to avoid doing so. Thus, two embodiments of class-by-class verification are anticipated, one that can be used with the conventional JVM design and one that can be used with the new fully lazy loading design.","According to one embodiment of this invention, the checks usually performed during verification may be performed before run time. Because checks before run time are technically not part of linking and thus not part of the verification stage of linking, these checks are herein designated pre-verification, indicating potentially pre-run time checks of validity.","In this embodiment, any time after a binary class has been generated by a compiler, the programmer can perform pre-verification on the binary class, and do so independently of any other classes that might be referenced in that class. As a consequence, access to a referenced class or referenced module is not required. This class-by-class pre-verification of the present invention is illustrated in . The method begins, for example, with loading the class BAR from a storage medium into memory, step . Then in step  the validity checks are made, such as type checks and operand stack overflow\/underflow checks, that would conventionally be made during verification. During such checks, any inter-module information needed for verification of instructions referencing other modules, such as subtyping relationships between classes A and B referenced from class BAR, is optimistically assumed so that instructions are valid. However, the assumed information or relationship places a constraint on the referenced module that must be remembered by the virtual machine. Such constraints must be checked if such a referenced module is ultimately loaded. If, in spite of these assumptions, the module such as class BAR does not pass the checks performed, an error results, step . As such an error is not necessarily a runtime error, it might not be thrown to a handler during execution. Instead, such an error might have to be communicated to the programmer, for example using an error message that appears on an output device such as a printer or display screen. If the module passes all the checks, then any pre-verification constraints to be recalled are written in step  for later use at run time. Subsequently, the process stops at step  when pre-verification is complete. Another class or module can then be. pre-verified following the steps illustrated in . Not all the instructions in a module may need to be pre-verified, just the instructions needed for a particular use of the module. For example, it may be necessary only to verify the instructions in method FOO, but not other methods in class BAR.","Optionally, the pre-verification constraints can be written to a file or otherwise associated with the module for checking later, at run time. For use with the JVM, these constraints could be recorded as data associated with the class in the binary class format on the storage medium. When the class is loaded into memory, these constraints could be internalized by the JVM for checking when it becomes necessary, for example, after loading of the referenced class B.","As a further option, according to this invention, the pre-verification constraints, however stored, or the module itself, or both, can have attached a signal, such as a digital signature, that can be used to reliably identify the source of the module or constraints and indicate whether they may have been tampered with since being signed.","In this manner, intra-module verification checks of validity tantamount to those performed during conventional verification, but not requiring cross-module information about referenced modules such as classes A and B, can be performed prior to runtime. That is, substantially complete module-by-module pre-verification can be performed for the intra-module checks. Inter-module checks are turned into pre-verification constraints.",{"@attributes":{"id":"p-0109","num":"0117"},"figref":["FIG. 7B","FIG. 7A"],"b":["716","732","755","737","750","737","737","782","755"]},{"@attributes":{"id":"p-0110","num":"0118"},"figref":["FIG. 7C","FIG. 7C","FIG. 5B"],"b":["530","530","530","792","780","555","783","784","783","784","778"],"i":["a ","b ","c "]},"If a pre-verification constraint was written for a referenced module, e.g., classes A or B, then the run time verifier determines whether the referenced module in the constraint is already loaded, step . If it is, the pre-verification constraint is enforced in step . If the referenced module fails the constraint, an error is thrown for catching by an error handler, step . Otherwise control goes to step  which loops through the pre-verification constraints until none remain. If, in step , it is determined that the referenced module, such as a referenced class, is not loaded, then the referenced module, such as a class, is loaded in step , and the constraint is enforced in step .","So long as the class has been pre-verified (and optionally, passes trust checks), whether pre-verification constraints were written on a referenced class or not, no intra-class checks need be performed; they were already done during the class-by-class pre-verification before run time. According to the present invention, then, after a module passes one-module-at-a-time pre-verification, run time verification does not perform intra-module checks; it only enforces inter-module constraints.","In the example described, a module is pre-verified as soon as it is compiled, without loading any other module. This allows for much of verification to be done before run time and not repeated every time a module is loaded and linked, thus saving valuable time and space resources (e.g. on processors running the virtual machine).","Module-by-Module Pre-Verification with Fully Lazy Loading",{"@attributes":{"id":"p-0115","num":"0123"},"figref":["FIG. 8","FIG. 8","FIG. 8","FIG. 8","FIG. 7C","FIG. 6A"],"b":["530","530","530","530","892","880","883","884","878","886","862","792","780","783","784","778","786","762","892","880","655","883","884","884","878"],"i":["a ","b ","c ","d "]},"If a pre-verification constraint is read for a referenced module, e.g., classes A or B, then the run time verifier determines whether the referenced module in the constraint is already loaded, step . If it is, the pre-verification constraint is enforced in step . If the referenced module fails the constraint, an error is thrown for catching by an error handler, step . If the referenced module passes the constraint without qualification, flow goes to step  which loops through the pre-verification constraints until none remain.","The remaining steps in  for fully lazy loading differ substantially from their counterparts for almost lazy loading. If, in step , it is determined that the referenced module, such as a referenced class, is not loaded, then the referenced module is not loaded. Instead, the pre-verification constraint is copied to, or otherwise retained in, a memory or storage medium, step , to be enforced when the not yet loaded module, such as a class, is loaded, if ever.","In , the enforcing of step  may have three results. Besides failure and passing without condition, it is possible that the already loaded referenced module can pass only if the contents of one or more other not yet loaded modules are known. This result can be considered as \u201cpassing subject to a condition\u201d that the pre-verification constraint on several referenced modules be re-written as a verification constraint on the not yet loaded referenced module or modules. Step  rewrites the pre-verification constraint as a verification constraint only on the not yet loaded referenced modules, such as classes. After the rewrite, if needed, control goes to step .","Module-by-Module Verification of Untrusted Classes","As mentioned above, verification according to the present invention relies on the ability to construct and annotate a module with constraints that must be satisfied by referenced modules. Unfortunately, the procedures do not always prevent an attacker from spoofing such annotations\u2014possibly making a malignant class appear benign. Therefore, the optional trusted check is included in  at step  and in  at step  according to one embodiment of the present invention. Absent these checks, pre-verification can be used in trusted situations, for instance where the classes can be pre-verified and loaded into a trusted (tamper proof) database prior to execution.","In untrusted situations, however, more protection is needed. According to an embodiment of the present invention, a cache is created as shown in . The cache  would contain trusted modules, such as trusted classes and\/or per-verification constraints, e.g. . Modules and\/or constraints imported to a virtual machine from an untrusted source, for example a source on the Internet, would be placed outside the cache, e.g., at . Any pre-verification constraints coming with the class from the untrusted source, e.g. , would be ignored. Instead, the first time such a module is loaded it is eagerly pre-verified in a pre-verifier  according to the method depicted in . If the module fails pre-verification, it will be rejected immediately. If the module does not fail per-verification, new pre-verification constraints are generated as needed and the module annotated, or associated with, the new constraints, e.g. , is then stored in a trusted module cache . On subsequent attempts to load the module from an untrusted source, the module cache  will be searched first. If the cached, pre-verified module is found, the module can then be safely used as pre-verified. With this modification, checking of class-by-class per-verification constraints as shown  will proceed correctly. In effect, step  of  answers the question about whether pre-verification has been performed by checking the module cache. With this modification, the digital signing of the pre-verification constraints, step  in , is not needed. Similarly, with this modification the check of whether the pre-verification output is trusted shown in step  of  of  is also not needed, and flow proceeds directly from step  or  to step  or , respectively.","Forms of Constraints.","The methods illustrated in flowcharts in , C, A, B and  all provide elements for checking referenced classes as late as possible. The form of the constraints written, and the manner in which those constraints are subsequently checked is as follows. The constraints may be written, for example, in step  of , step  of , and steps  and  of . Enforcing of the constraints can be applied in step  of  and step  of  and step  of .","Constraint generation and constraint checking will be described in more detail by example. Referring to , the assignment statement states that a new instance of class B will be stored in the variable var of class type A. In an object oriented language, this assignment requires that B be a subtype of class A, as represented by the expression B<=A. This is not known during verification of BAR unless B is loaded at that time. If B is loaded and B is a subclass of A, then A must also be loaded (because A had to be loaded to load B). Therefore, the contrapositive is true, that is, if B is loaded and A is not loaded, then B is not a subclass of A; the assignment statement causes a subtyping mismatch which causes class BAR to fail verification. If both A and B are loaded, as in eager loading shown in , then the indicator of the superclass for B can be traced to see if A is somewhere a superclass of B. If so, B is a subclass of A and this assignment passes verification. If A is not found by following the superclass indicators up the hierarchy, then B is not a subclass of A; the assignment statement causes a subtyping mismatch, and class BAR fails verification.","Using the conventional JVM specification, if class B was not loaded already, the verifier would load class B and check its type, specifically whether it is a subtype of class A.","According to the present invention, in order to achieve fully lazy loading, or class-by-class verification, or both, it is desired not to load class B. Therefore, according to this embodiment of the present invention, B is not loaded; and, instead, a constraint B<=A is written. This constraint can be written in any of the steps listed above for writing constraints (e.g. , , , ). Later when BAR.FOO is executed, if this branch with the assignment statement is not executed, and B is not likewise referenced from any other instruction that is executed, class B is never loaded. But if the branch including this assignment statement is executed and B is not yet loaded, class B will be loaded at that time; and, at that time, after class B is loaded, the check will be made whether class B satisfies the constraint B<=A. This checking can be performed, as, for example, in the steps listed above for checking constraints (e.g. , , ). This will be easy to do because if class B is indeed a subclass of class A, and inherits its attributes from class A, then class A would have to have been loaded already. Thus a constraint of this type allows fully lazy loading, class-by-class per-verification, or both.","There is another check on class type of non-local classes that may be treated differently in class-by-class pre-verification than it is treated in the fully lazy loading implementation, according to the present invention. This is the receiver access check for protected members:","In the JAVA\u2122 virtual machine, a protected member R may be accessed by a class or interface D if and only if:","1. D is in the same run time package as the class C that declared R OR BOTH","2. D is a subclass of C, the class that declared R, AND","3. if R is an instance member, then T, the static type of the instance R being accessed, is a subtype of D.","Requirement 3, is known as the receiver protected check.","In a conventional JAVA\u2122 virtual machine, the first two requirements are checked when the reference from D to R is resolved during linking of D, while the third requirement is checked during verification of D. During verification, the class C that declares R may not have been loaded yet. In this case, it is evident that C is not a superclass of D (otherwise, C would per force have been loaded, because loading a class implies the loading of all its superclasses). In that case, the access is only legal if C and D are in the same run time package. The verifier can optimistically assume that this holds. The requirement will be checked when the reference is resolved. Hence, the verifier only needs to perform the protected receiver check if C has already been loaded. In this situation, it is possible to determine whether R is a protected member at all. If R is not protected, no protected receiver check is necessary. If R is protected, the verifier can test to see whether D is in the same run time package as C. If this is the case, the access is legal and again, no protected receiver check is needed. If D and C are not in the same run time package, the verifier can check whether D is subclass of C and whether T, the static type of the instance being accessed, is a subtype of D. If not, an error is raised. Note that the check T<=D may require loading of T if it has not already been loaded.","In verification with fully lazy loading, when verifying D, its superclass is assumed to have been loaded. Control proceeds in the same manner as in the non-lazy case, with one exception. If it is determined that a check if T<=D is needed, and T is not loaded, loading must be avoided. Instead, the loading constraint T<=D is imposed on T.","In class-by-class verification, the situation is different. Neither the superclass of D nor the class C that declared R have been loaded. Therefore, the protected receiver check can not be performed. The assumption that if C is a superclass of D, it must have been loaded cannot be made, hence the declaration of R cannot be examined. It follows that it cannot even be determined whether R is protected or not. Instead, appropriate constraints must be generated that will be checked at a later time, when the program executes. This problem can be solved by generating the conditional constraint:","If (D<=X) then {if (X.m protected) then {T<=D}else {true}} else {true} for every instruction of the form:","invoke o, X.m,","where o has type T. A similar strategy applies to field references. This constraint is examined prior to the initialization of D. At that point, D<=X can be decided (since D and all its superclasses have already been loaded). If D<=X is not true, no further action is necessary. If D is not a subclass of X, then D cannot possibly be a subclass of C, the class that declared m. The reason is that C must necessarily be a superclass of X. It follows that the reference to X.m is only legal if either m is not protected or C is in the same run time package as D. This will be checked when the reference to X.m is resolved. If it is true that D<=X, then it can be checked whether X.m is protected or not. If X.m is not protected, the protected receiver check need not be done. Otherwise, the test if T<=D can be made which, as above, may cause T to be loaded.","When combining fully lazy verification with class by class verification, the procedure for class-by-class verification is followed, except that when evaluating the conditional constraint:","if(D<=X) then {if(X.m protected) then {T<=D}else {true)}} else {true} if one must evaluate T<=D and if T is not loaded, one should impose the loading constraint T<=D on T, as in the lazy case.","Another constraint is appropriate when verification examines the state of the operand stack at a statement that is a successor statement to several prior executed statements, i.e., where two or more branches converge. At this point, the verification is currently designed to merge the snapshots of the operand stack and local variables from the preceding instructions to which the current instruction is a successor. If the references are to types defined in classes that are not yet loaded, which will always be the case in class-by-class pre-verification and sometimes the case in fully lazy loading, the type lattice is not available and the LUB is not known. Following the symbolic representation of an LUB described above for step  of , a constraint such as \u201cthe LUB<=class T\u201d can be replaced by a constraint on a list represented symbolically as:\n\n\n\nThis can be factored out into a series of constraints on individual classes Xas follows:\n\n\n","When the current method of a loaded class is executed and goes through a branch that requires resolution of class X, for example, then class Xis loaded and the constraint X<=T can be checked at that time. Alternatively, a constraint on the list can be rewritten dropping Xfrom the list, if Xpasses the check when Xis loaded.","As described above, the constraints are written during any of several steps (e.g. , , , ) and the constraints are then checked at any of the several checking steps (e.g. , , ).","With this symbolic representation of the LUB, the actual computations may take longer to converge. However, the process is guaranteed to converge because the constant pool of a class file of the JVM is finite. Hence, only a finite number of types can be referenced by a method, directly or indirectly. As a result, the symbolic representation of an LUB must be a finite sequence of class names X^ . . . ^X. In turn, this means that the number of iterations through the type inference algorithm is finite for the JVM, since iterations continue until no new types can be added to the LUB.","Conclusion of Detailed Description","Although the present invention has been described and illustrated in detail, it is clearly understood that the same is by way of illustration and example only and is not to be taken by way of limitation, the spirit and scope of the present invention being limited only by the terms of the appended claims."],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","FIELD OF THE INVENTION","DESCRIPTION OF RELATED ART","SUMMARY OF THE INVENTION","NOTATIONS AND NOMENCLATURE","DESCRIPTION OF THE PREFERRED EMBODIMENT"],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The objects, features and advantages of the system of the present invention will be apparent from the following description in which:",{"@attributes":{"id":"p-0045","num":"0050"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0046","num":"0051"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0047","num":"0052"},"figref":"FIG. 1C"},{"@attributes":{"id":"p-0048","num":"0053"},"figref":"FIG. 1D"},{"@attributes":{"id":"p-0049","num":"0054"},"figref":"FIG. 1E"},{"@attributes":{"id":"p-0050","num":"0055"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0051","num":"0056"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0052","num":"0057"},"figref":["FIG. 4A","FIG. 2"]},{"@attributes":{"id":"p-0053","num":"0058"},"figref":["FIG. 4B","FIG. 4A"],"b":"475"},{"@attributes":{"id":"p-0054","num":"0059"},"figref":["FIG. 5A","FIG. 4A","FIG. 2"],"b":"435"},{"@attributes":{"id":"p-0055","num":"0060"},"figref":["FIG. 5B","FIG. 5A","FIG. 2"],"b":"530"},{"@attributes":{"id":"p-0056","num":"0061"},"figref":["FIG. 5C","FIG. 5B"],"b":"537"},{"@attributes":{"id":"p-0057","num":"0062"},"figref":["FIG. 6A","FIG. 5A","FIG. 2"],"b":"530"},{"@attributes":{"id":"p-0058","num":"0063"},"figref":["FIG. 6B","FIG. 6A","FIG. 6C","FIG. 4A","FIG. 2"],"b":["637","475"]},{"@attributes":{"id":"p-0059","num":"0064"},"figref":["FIG. 7A","FIG. 2"]},{"@attributes":{"id":"p-0060","num":"0065"},"figref":["FIG. 7B","FIG. 7A"],"b":"716"},{"@attributes":{"id":"p-0061","num":"0066"},"figref":["FIG. 7C","FIG. 5A","FIG. 2"],"b":"530"},{"@attributes":{"id":"p-0062","num":"0067"},"figref":["FIG. 8","FIG. 5A","FIG. 2"],"b":"530"},{"@attributes":{"id":"p-0063","num":"0068"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
