---
title: Compression aware physical database design
abstract: A plurality of indicators representing a plurality of respective candidate database configurations may be obtained, each of the candidate database configurations including a plurality of database queries and a plurality of candidate database indexes associated with a database table. A portion of the candidate database indexes included in the plurality of database indexes may be selected based on skyline selection. An enumeration of the portion of the plurality of the candidate database indexes may be determined based on a greedy algorithm.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09009124&OS=09009124&RS=09009124
owner: Microsoft Technology Licensing, LLC
number: 09009124
owner_city: Redmond
owner_country: US
publication_date: 20110617
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["In the rapidly expanding Information Age, relational database systems (RDBMSs) have been implemented to handle many large-scale applications. As the databases grow larger and larger, processing efficiency may erode. Many systems support lossless compression methods such as null suppression and dictionary encoding on physical design structures such as clustered and non-clustered indexes. Depending on the compression method and the distribution of values in the index, a compressed index may utilize only a small fraction of the storage space otherwise occupied by an uncompressed index. For decision support queries which frequently scan large indexes, compression may provide reduced input\/output (I\/O) overhead. However, while some compression strategies may improve system performance, others may hamper the performance.","According to one general aspect, a design manager may include a request receiving engine configured to receive a request for an estimate size of a first compressed index associated with a first database index that is based on a database table. The design manager may also include a base index engine configured to obtain a plurality of values indicating sizes of a plurality of second compressed indexes associated with a plurality of respective second database indexes other than the first database index, the second database indexes based on the database table. The design manager may also include a size estimate engine configured to determine the estimate size of the first compressed database index based on one or more of the plurality of values.","According to another aspect, a plurality of indicators representing a plurality of respective database indexes associated with a database table may be obtained. An estimate size for a target group of the plurality of database indexes may be determined, based on a directed graph that includes a plurality of index nodes that represent size estimations associated with a portion of the respective database indexes, and a plurality of deduction nodes that include candidate deductions that are associated with one or more of the index nodes that are arranged as parent nodes relative to the deduction nodes in the directed graph, the plurality of deduction nodes associated with one or more of the index nodes arranged as children nodes relative to the deduction nodes, each of the children nodes indicating a candidate deduction compression associated with the each of the children nodes.","According to another aspect, a computer program product tangibly embodied on a computer-readable storage medium may include executable code that, when executed, may cause at least one data processing apparatus to obtain a plurality of indicators representing a plurality of respective candidate database configurations, each of the candidate database configurations including a plurality of database queries and a plurality of candidate database indexes associated with a database table. Further, the at least one data processing apparatus may select a portion of the candidate database indexes included in the plurality of database indexes based on skyline selection. Further, the at least one data processing apparatus may determine an enumeration of the portion of the plurality of the candidate database indexes based on a greedy algorithm.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter. The details of one or more implementations are set forth in the accompanying drawings and the description below. Other features will be apparent from the description and drawings, and from the claims.","Relational database systems (RDBMSs) may support data compression using techniques such as null suppression and dictionary encoding. Data compression may reduce storage overhead, and may thus improve input\/output (I\/O) performance for decision support queries. However, compression may also slow down query and update performance due to the CPU costs of compression and decompression.","Example techniques discussed herein may provide a design-time analysis of effects of data compression with regard to choices of elements of physical database design, such as indexes, for a given workload. For example, example techniques that decouple the decision of whether or not to choose an index from whether or not to compress the index may provide suboptimal designs.","Thus, according to an example embodiment, example techniques discussed herein may integrate compression into physical database design in a scalable manner. For example, example techniques discussed herein may be implemented based on modifications to MICROSOFT SQL SERVER and the DATABASE ENGINE TUNING ADVISOR (DTA) physical design tool. However, example techniques discussed herein may also be used with DBMSs that support other compression methods.","Example techniques discussed herein may provide design strategies for generating system designs that may improve system performance. For example, techniques are discussed for estimating the size of a compressed index that may scale to a large number of indexes. Further, example techniques are discussed for extending physical design tools to provide incorporation of compressed physical design structures.","According to an example embodiment, example techniques discussed herein may provide estimation sizes of a large number of compressed indexes. According to an example embodiment, example techniques discussed herein may extend search algorithms used in physical design tools with regard to incorporating compressed physical design structures.","Relational database systems may support lossless compression methods such as null suppression and dictionary encoding on physical design structures such as clustered and non-clustered indexes. Depending on the compression technique and the distribution of values in the index, a compressed index may utilize a small fraction of the storage space of a corresponding uncompressed index.","In this context, a database \u201cindex\u201d may refer to a data structure that may include a portion of the information stored in a database table. For example, an index may be created based on one or more database columns associated with the database table.","For decision support queries which frequently scan large indexes, compression may reduce input\/output (I\/O) costs. However, while compression may improve performance, it also may hamper performance. For example, processing a query may involve decompressing the data, which may incur additional CPU costs. This may hamper queries that are already CPU bound.","Further, updates (e.g., INSERT\/UPDATE statements) may involve additional CPU costs since processing the updates may involve decompressing the data, updating and then compressing the updated data. Thus, compression may introduce additional overhead considerations to physical database design techniques.","Automated physical design tools may assist database administrators (DBAs) in making physical design choices. Such tools may accept as input a workload of a Structured Query Language (SQL) query, update statements and a storage bound, and may provide a configuration (e.g., a set of indexes) that may optimize workload performance, while not exceeding the given storage bound.","For example, a performance metric for optimization techniques may include an optimizer's estimated costs of statements in a workload. According to an example embodiment, example techniques discussed herein may further consider an impact of compression on physical database design.","As further discussed herein, compression may be incorporated into automated physical database design. As further discussed herein, the example designs may consider compression of indexes, and example techniques discussed herein may further extend to other physical design structures such as partial indexes and materialized views (which may also be compressed).","In design considerations, decoupling a decision of whether or not to choose an index from whether or not to compress the index may result in suboptimal solutions. Different indexes may achieve different compression fractions (i.e., ratios of compressed size to uncompressed size), and therefore the I\/O reduction as well as the update cost of an index for a query\/update relative to another index may change when compression is considered. For example, a strategy may include staging index selection and compression; i.e., select indexes without considering compression, compress the selected indexes, and repeat the technique if the space consumed is below the storage bound. As shown below, the staged approach may ignore otherwise beneficial solutions.","As a first example, a table may be indicated as\n\n","and a query may be indicated as\n\n","Two example indexes on Sales may be indicated as\n\n","For this example, a storage bound is 100 GB and the sizes of indexes I, Irespectively are 95 GB, 170 GB. For this example, CIand CIare compressed versions of Iand Irespectively and the sizes of CIand CIrespectively are 50 GB and 90 GB.","For this example, if indexes are selected without considering compression, then Imay be selected, as Idoes not fit within the given space budget. Once Iis selected, there will not be enough storage to add CIlater.","However, if compression is considered during the index selection process, CImay be selected, as the size of CIis below the given storage bound. For this example, CIis a covering index for Q (i.e., it includes all columns involved in answering Q) and may thus can improve the query's I\/O performance.","Similarly, choosing an index without considering how its update cost will increase if the index is subsequently compressed may also result in suboptimal solutions due to high update cost.","In design techniques for integrating compression into physical design, several considerations may include the following. For example, a large number of new (compressed) indexes may be considered. In principle, for each index, compressed variants of that index may also be considered, one per compression method available in the RDBMS. For example, in MICROSOFT SQL SERVER both null suppression and dictionary encoding methods may be available for compressing an index. For each compressed index, an accurate and efficient estimate of the size (i.e., number of pages) of each index may be beneficial, as this information may be provided to the query optimizer in determining the cost of the execution plan that uses the index.","As discussed further below, for an uncompressed index, the size may be estimated once the number of rows and average row length are known. However, for a compressed index, the size may depend on the compression method and the value distribution of columns in the index. For example, an index that is dictionary compressed may have a significantly different size than if compressed using null suppression.","As discussed further below, sampling may aid in decreasing CPU time for estimation of compressed indexes (i.e., a sample may be obtained and the index may be generated on the sample). As discussed further below, a compression fraction thus obtained may be used to infer the size of the full compressed index.","As discussed further below, compression may amplify a space vs. time trade-off involved in physical design tools. For example, for scalability reasons, physical design tools may be designed to perform early pruning by eliminating indexes that are not part of an \u201coptimal\u201d configuration for at least one query in the workload. Such pruning may be based on query costs. Thus, a compressed index that may reduce storage space while increasing query costs a little may likely be pruned. However, retaining such indexes may improve the overall quality of solutions noticeably since the reduced storage allows other indexes to be added (potentially benefiting many other queries).","As discussed further below, physical design tools may rely on extensions to the query optimizer application programming interface (API) to support \u201cwhat-if\u201d analysis. For example, given a configuration and a query, the API may return the optimizer's estimated cost of the query under the configuration. Integrating compression into physical design may involve extending the query optimizer's cost model to reflect the cost of using a compressed index. As discussed further below, example cost models may be extended to make them \u201ccompression-aware.\u201d For example, cost models may capture CPU costs of compression and decompression as well as I\/O cost reduction due to compression. For example, example techniques discussed herein may be integrated into automated physical database design tools so that they may recommend a combination of compressed and uncompressed indexes.","As further discussed herein,  is a block diagram of a system  for database design. As shown in , a system  may include a design manager  that includes a request receiving engine  that may be configured to receive a request  for an estimate size  of a first compressed index  associated with a first database index  that is based on a database table .","According to an example embodiment, the design manager  may be embodied via executable instructions that may be stored on a computer-readable storage medium, as discussed below. According to an example embodiment, the computer-readable storage medium may include any number of storage devices, and any number of storage media types, including distributed devices. According to an example embodiment, one or more of the executable instructions may be executed via one or more device processors .","In this context, a \u201cprocessor\u201d may include a single processor or multiple processors configured to process instructions associated with a processing system. A processor may thus include multiple processors processing instructions in parallel and\/or in a distributed manner. Although the device processor  is depicted as external to the design manager  in , one skilled in the art of data processing will appreciate that the device processor  may be implemented as a single component, and\/or as distributed units which may be located internally or externally to the design manager , and\/or any of its elements.","For example, a database  may include the first database index  and the database table , and may be accessed via a database interface engine . One skilled in the art of data processing will appreciate that there are many techniques for storing database information discussed herein, such as various types of database configurations (e.g., SQL SERVERS) and non-database configurations.","According to an example embodiment, the design manager  may include a memory  that may store the request  and other data for processing by the design manager . In this context, a \u201cmemory\u201d may include a single memory device or multiple memory devices configured to store data and\/or instructions. Further, the memory  may span multiple distributed storage devices.","According to an example embodiment, a user interface engine  may be configured to manage communications between a user  and the design manager . The user  may be associated with a receiving device  that may be associated with a display  and other input\/output devices. For example, the display  may be configured to communicate with the receiving device , via internal device bus communications, or via at least one network connection.","According to an example embodiment, the design manager  may include a network communication engine  that may manage network communication between the design manager  and other entities that may communicate with the design manager  via at least one network . For example, the at least one network  may include at least one of the Internet, at least one wireless network, or at least one wired network. For example, the at least one network  may include a cellular network, a radio network, or any type of network that may support transmission of data for the design manager . For example, the network communication engine  may manage network communications between the design manager  and the receiving device . For example, the network communication engine  may manage network communication between the user interface engine  and the receiving device .","A base index engine  may be configured to obtain a plurality of values  indicating sizes of a plurality of second compressed indexes  associated with a plurality of respective second database indexes  other than the first database index , the second database indexes  based on the database table .","A size estimate engine  may be configured to determine the estimate size  of the first compressed database index  based on one or more of the plurality of values .","According to an example embodiment, the database table  may be included in a relational database system.","According to an example embodiment, a column set determination engine  may be configured to determine a first set  of table columns associated with the database table , wherein the first database index  is based on the first set  of table columns.","According to an example embodiment, a compression type engine  may be configured to determine that a compression  associated with the requested estimate size  associated with the first compressed index  generates compressed indexes that share a common compressed size independent of an ordering of tuples associated with database table columns, as discussed further below.","According to an example embodiment, an index selection engine  may be configured to select one of the second database indexes  that is, in common with the first database index , based on the first set  of table columns.","According to an example embodiment, the size estimate engine  may be configured to determine the estimate size  of the first compressed database index  based on deducing the estimate size  of the first compressed database index  based on the value indicating the size of the compressed index associated with the selected one of the second database indexes , as discussed further below.","According to an example embodiment, the compression  associated with the requested estimate size  may include one or more of null suppression or global dictionary compression.","According to an example embodiment, the column set determination engine  may be configured to determine a first set  of table columns associated with the database table , wherein the first database index  may be based on the first set  of table columns.","According to an example embodiment, a compression type engine  may be configured to determine that a compression  associated with the requested estimate size  associated with the first compressed index  generates compressed indexes that share a common compressed size independent of an ordering of tuples associated with database table columns.","According to an example embodiment, an index selection engine  may be configured to select one or more of the second database indexes  that are based on one or more of the table columns included in one or more subsets of the first set  of table columns.","According to an example embodiment, the size estimate engine  may be configured to determine the estimate size  of the first compressed database index  based on extrapolating the estimate size  of the first compressed database index  based on determining one or more size reduction values  for each selected second database index , based on determining differences between the value indicating the size of the compressed index associated with the selected one of the second database indexes  and a value indicating the size of the selected one of the second database indexes , as discussed further below.","According to an example embodiment, a column set determination engine  may be configured to determine a first set  of table columns associated with the database table , wherein the first database index  is based on the first set  of table columns.","According to an example embodiment, an index selection engine  may be configured to select one or more of the second database indexes  that are based on one or more of the table columns included in one or more subsets of the first set  of table columns.","According to an example embodiment, the size estimate engine  may be configured to determine the estimate size  of the first compressed database index  based on extrapolating the estimate size  of the first compressed database index  based on an order-dependent column extrapolation, based on determining one or more run lengths  of values stored in one or more columns of the selected one or more of the second database indexes , and determining at least one penalty value  associated with a size reduction that is associated with one or more columns of the selected one or more of the second database indexes , as discussed further below.","According to an example embodiment, a compression  associated with the requested estimate size  may include one or more of page-local dictionary encoding or run length encoding, as discussed further below.","According to an example embodiment, a table sample locator  may be configured to determine whether a database table sample associated with the database table  is stored in a table sample storage device.","According to an example embodiment, a table sample retrieval engine  may be configured to obtain the database table sample, based on a first result of the determination of whether a database table sample associated with the database table  is stored in a table sample storage device.","According to an example embodiment, a table sample determination engine  may be configured to obtain a random sample from the database table, based on a second result of the determination of whether a database table sample associated with the database table  is stored in a table sample storage device, the random sample including a subset of rows included in the database table .","According to an example embodiment, a sample storage engine  may be configured to initiate storage of the random sample obtained by the table sample determination engine , as the database table sample in the table sample storage device.","According to an example embodiment, the base index engine  may be configured to obtain the plurality of values  based on one or more compression fraction values  associated with the obtained database table sample, as discussed further below.","According to an example embodiment, a partial index sample locator  may be configured to determine whether a partial index table sample associated with a database partial index associated with the database table  is stored in a table sample storage device.","According to an example embodiment, a partial index sample engine  may be configured to obtain the partial index table sample, based on a first result of the determination of whether the partial index table sample is stored in the table sample storage device, as discussed further below.","According to an example embodiment, a filtered sample determination engine  may be configured to obtain a filtered sample from the database table sample, based on a second result of the determination of whether the partial index table sample is stored in the table sample storage device, as discussed further below.","According to an example embodiment, a filtered sample storage engine  may be configured to initiate storage of the filtered sample obtained by the filtered sample determination engine , as the partial index table sample in the table sample storage device.","According to an example embodiment, a materialized view sample locator  may be configured to determine whether a materialized view sample associated with a materialized view associated with the database table  is stored in a table sample storage device.","According to an example embodiment, a materialized view sample determination engine  may be configured to obtain the materialized view sample, based on a first result of the determination of whether the materialized view table sample is stored in the table sample storage device.","According to an example embodiment, a join synopsis determination  engine may be configured to obtain a plurality of join synopses of a database associated with the database table , based on a second result of the determination of whether the partial index table sample is stored in the table sample storage device, as discussed further below.","According to an example embodiment, a join synopsis storage engine  may be configured to initiate storage of the plurality of join synopses obtained by the join synopsis determination engine , as the partial index table sample in the table sample storage device.",{"@attributes":{"id":"p-0079","num":"0083"},"figref":["FIGS. 2","FIG. 1","FIG. 2"],"i":["a","g ","a"],"b":["2","202","104"]},"A plurality of values indicating sizes of a plurality of second compressed indexes associated with a plurality of respective second database indexes other than the first database index may be obtained, the second database indexes based on the database table (). For example, the base index engine  may obtain a plurality of values indicating sizes of a plurality of second compressed indexes associated with a plurality of respective second database indexes other than the first database index, the second database indexes based on the database table, as discussed above.","The estimate size of the first compressed database index may be determined based on one or more of the plurality of values (). For example, the size estimate engine  may determine the estimate size of the first compressed database index based on one or more of the plurality of values, as discussed above.","According to an example embodiment, the database table may be included in a relational database system ().","According to an example embodiment, a first set of table columns associated with the database table may be determined, wherein the first database index is based on the first set of table columns (). For example, the column set determination engine  may determine a first set of table columns associated with the database table, wherein the first database index is based on the first set of table columns;","According to an example embodiment, it may be determined that a compression associated with the requested estimate size associated with the first compressed index generates compressed indexes that share a common compressed size independent of an ordering of tuples associated with database table columns (). a compression type engine configured to determine that a compression associated with the requested estimate size associated with the first compressed index generates compressed indexes that share a common compressed size independent of an ordering of tuples associated with database table columns;","According to an example embodiment, one of the second database indexes that is, in common with the first database index, based on the first set of table columns may be selected (). For example, the index selection engine  may select one of the second database indexes that is, in common with the first database index, based on the first set of table columns, as discussed above.","According to an example embodiment, the estimate size of the first compressed database index may be determined based on deducing the estimate size of the first compressed database index based on the value indicating the size of the compressed index associated with the selected one of the second database indexes (). For example, the size estimate engine  may determine the estimate size of the first compressed database index based on deducing the estimate size of the first compressed database index based on the value indicating the size of the compressed index associated with the selected one of the second database indexes, as discussed above.","According to an example embodiment, the compression associated with the requested estimate size includes one or more of null suppression or global dictionary compression ().","According to an example embodiment, a first set of table columns associated with the database table may be determined, wherein the first database index is based on the first set of table columns (). For example, the column set determination engine  may determine a first set of table columns associated with the database table, wherein the first database index is based on the first set of table columns, as discussed above.","According to an example embodiment, it may be determined that a compression associated with the requested estimate size associated with the first compressed index generates compressed indexes that share a common compressed size independent of an ordering of tuples associated with database table columns (). For example, the compression type engine  may determine that a compression associated with the requested estimate size associated with the first compressed index generates compressed indexes that share a common compressed size independent of an ordering of tuples associated with database table columns, as discussed above.","According to an example embodiment, one or more of the second database indexes that are based on one or more of the table columns included in one or more subsets of the first set of table columns may be selected (). For example, the index selection engine  may select one or more of the second database indexes that are based on one or more of the table columns included in one or more subsets of the first set of table columns, as discussed above.","According to an example embodiment, the estimate size of the first compressed database index may be determined based on extrapolating the estimate size of the first compressed database index based on determining one or more size reduction values for each selected second database index, based on determining differences between the value indicating the size of the compressed index associated with the selected one of the second database indexes and a value indicating the size of the selected one of the second database indexes (). For example, the size estimate engine  may determine the estimate size of the first compressed database index based on extrapolating the estimate size of the first compressed database index based on determining one or more size reduction values for each selected second database index, based on determining differences between the value indicating the size of the compressed index associated with the selected one of the second database indexes and a value indicating the size of the selected one of the second database indexes, as discussed above.","According to an example embodiment, a first set of table columns associated with the database table may be determined, wherein the first database index is based on the first set of table columns (). For example, the column set determination engine  may determine a first set of table columns associated with the database table, wherein the first database index is based on the first set of table columns, as discussed above.","According to an example embodiment, one or more of the second database indexes that are based on one or more of the table columns included in one or more subsets of the first set of table columns may be selected (). For example, the index selection engine  may select one or more of the second database indexes that are based on one or more of the table columns included in one or more subsets of the first set of table columns, as discussed above.","According to an example embodiment, the estimate size of the first compressed database index may be determined based on extrapolating the estimate size of the first compressed database index based on an order-dependent column extrapolation, based on determining one or more run lengths of values stored in one or more columns of the selected one or more of the second database indexes, and determining at least one penalty value associated with a size reduction that is associated with one or more columns of the selected one or more of the second database indexes (). For example, the size estimate engine  may determine the estimate size of the first compressed database index based on extrapolating the estimate size of the first compressed database index based on an order-dependent column extrapolation, as discussed above.","According to an example embodiment, a compression associated with the requested estimate size may include one or more of page-local dictionary encoding or run length encoding ().","According to an example embodiment, it may be determined whether a database table sample associated with the database table is stored in a table sample storage device (). For example, the table sample locator  may determine whether a database table sample associated with the database table is stored in a table sample storage device, as discussed above.","According to an example embodiment, the database table sample may be obtained, based on a first result of the determination of whether a database table sample associated with the database table is stored in a table sample storage device (). For example, the table sample retrieval engine  may obtain the database table sample, based on a first result of the determination of whether a database table sample associated with the database table is stored in a table sample storage device, as discussed above.","According to an example embodiment, a random sample from the database table may be obtained, based on a second result of the determination of whether a database table sample associated with the database table is stored in a table sample storage device, the random sample including a subset of rows included in the database table (). For example, the table sample determination engine  may obtain a random sample from the database table, based on a second result of the determination of whether a database table sample associated with the database table is stored in a table sample storage device, the random sample including a subset of rows included in the database table, as discussed above.","According to an example embodiment, storage of the random sample obtained by the table sample determination engine, as the database table sample in the table sample storage device, may be initiated (). For example, the sample storage engine  may initiate storage of the random sample obtained by the table sample determination engine, as the database table sample in the table sample storage device, as discussed above.","According to an example embodiment, the plurality of values may be obtained based on one or more compression fraction values associated with the obtained database table sample (). For example, the base index engine  may obtain the plurality of values based on one or more compression fraction values associated with the obtained database table sample, as discussed above.","According to an example embodiment, it may be determined whether a partial index table sample associated with a database partial index associated with the database table is stored in a table sample storage device (). For example, the partial index sample locator  may determine whether a partial index table sample associated with a database partial index associated with the database table is stored in a table sample storage device, as discussed above.","According to an example embodiment, the partial index table sample may be obtained, based on a first result of the determination of whether the partial index table sample is stored in the table sample storage device (). For example, the partial index sample engine  may obtain the partial index table sample, based on a first result of the determination of whether the partial index table sample is stored in the table sample storage device, as discussed above.","According to an example embodiment, a filtered sample may be obtained from the database table sample, based on a second result of the determination of whether the partial index table sample is stored in the table sample storage device (). For example, the filtered sample determination engine  may obtain a filtered sample from the database table sample, based on a second result of the determination of whether the partial index table sample is stored in the table sample storage device, as discussed above.","According to an example embodiment, storage of the filtered sample obtained by the filtered sample determination engine, as the partial index table sample in the table sample storage device, may be initiated (). For example, the filtered sample storage engine  may initiate storage of the obtained filtered sample, as the partial index table sample in the table sample storage device, as discussed above.","According to an example embodiment, it may be determined whether a materialized view sample associated with a materialized view associated with the database table is stored in a table sample storage device (). For example, the materialized view sample locator  may determine whether a materialized view sample associated with a materialized view associated with the database table is stored in a table sample storage device, as discussed above.","According to an example embodiment, the materialized view sample may be obtained, based on a first result of the determination of whether the materialized view table sample is stored in the table sample storage device (). For example, the materialized view sample determination engine  may obtain the materialized view sample, based on a first result of the determination of whether the materialized view table sample is stored in the table sample storage device, as discussed above.","According to an example embodiment, a plurality of join synopses of a database associated with the database table may be obtained, based on a second result of the determination of whether the partial index table sample is stored in the table sample storage device (). For example, the join synopsis determination engine  may obtain a plurality of join synopses of a database associated with the database table, based on a second result of the determination of whether the partial index table sample is stored in the table sample storage device, as discussed above.","In this context, \u201cjoin synopses\u201d may refer to precomputed samples of a small set of distinguished joins, in reference to relational databases. For example, the join synopses may be used for determining approximate join aggregates","According to an example embodiment, storage of the obtained plurality of join synopses, as the partial index table sample in the table sample storage device, may be initiated (). For example, the join synopsis storage engine  may initiate storage of the plurality of join synopses, as discussed above.",{"@attributes":{"id":"p-0110","num":"0114"},"figref":["FIGS. 3","FIG. 1","FIG. 3"],"i":["a","b ","a"],"b":["3","302"]},"An estimate size for a target group of the plurality of database indexes may be determined, via a device processor, based on a directed graph that includes a plurality of index nodes that represent size estimations associated with a portion of the respective database indexes, and a plurality of deduction nodes that include candidate deductions that are associated with one or more of the index nodes that are arranged as parent nodes relative to the deduction nodes in the directed graph, the plurality of deduction nodes associated with one or more of the index nodes arranged as children nodes relative to the deduction nodes, each of the children nodes indicating a candidate deduction compression associated with the each of the children nodes (). The directed graph is discussed further below.","According to an example embodiment, a predetermined error value representing a predetermined error ratio, a predetermined confidence value representing a predetermined confidence parameter, and a predetermined sampling ratio value representing a predetermined sampling ratio may be obtained (), as discussed further below.","According to an example embodiment, determining the estimate size may include determining the estimate size for the target group of the plurality of database indexes, based on the predetermined error value, the predetermined confidence value, and the predetermined sampling ratio value ().","According to an example embodiment, determining the estimate size may include initializing a plurality of the index nodes representing the target group of the plurality of database indexes with a state value indicating an initial state, updating a first one of the index nodes with a state value indicating a deduced state, when a first candidate design strategy includes a task associated with estimating a size of the index associated with the first one of the index nodes based on size deduction, and updating a second one of the index nodes with a state value indicating a sampled state, when a second candidate design strategy includes a task associated with estimating a size of the index associated with the first one of the index nodes based on database table sampling ().","According to an example embodiment, determining the estimate size may include updating a first one of the deduction nodes with a state value indicating an enabled state, when the one or more children nodes associated with the first one of the deduction node are associated with one or more of a sampled state or a deduced state (), as discussed further below.",{"@attributes":{"id":"p-0116","num":"0120"},"figref":["FIGS. 4","FIG. 4"],"i":["a","b ","a"],"b":["4","402"]},"A portion of the candidate database indexes included in the plurality of database indexes may be selected based on skyline selection (), as discussed further below.","An enumeration of the portion of the plurality of the candidate database indexes may be determined based on a greedy algorithm (), as discussed further below.","According to an example embodiment, the portion of the candidate database indexes included in the plurality of database indexes may be selected based on skyline selection, based on determining a cost estimate associated with each of the respective candidate database configurations, based on index size estimates and query runtime estimates associated with each database query associated with of the respective candidate database configurations ().","According to an example embodiment, the portion of the candidate database indexes included in the plurality of database indexes may be selected based on skyline selection, based on ranking the respective candidate database configurations, based on a combination of speed of estimated query runtime and small size determinations associated with each respective candidate database configuration (), as discussed further below.","According to an example embodiment, the enumeration of the portion of the plurality of the candidate database indexes may be determined based on the greedy algorithm and backtracking (), as discussed further below.","According to an example embodiment, the greedy algorithm may include one or more of a pure greedy algorithm or a density-based greedy algorithm (), as discussed further below.","According to an example embodiment, the backtracking may be based on determining that one of the candidate database configurations included in a greedy algorithm selection exceeds a size limit, and replacing a candidate database index that is included in the one of the candidate database configurations included in the greedy algorithm selection that exceeds the size limit, with a compressed candidate database index that is based on the replaced candidate database index ().","As mentioned above, example dictionary encoding techniques may compress a data page by finding frequently occurring values and replacing them with small pointers to a dictionary, which includes the distinct set of replaced values. For example, a data page which includes the values {AA, BB, BB, AA} may be compressed to a dictionary {AA=1, BB=2} and a compressed data page {1, 2, 2, 1}. For example, systems such as IBM DB2 may maintain one dictionary across all data pages in a table partition (e.g., a \u201cglobal dictionary\u201d) while other databases (e.g., ORACLE) may maintain one dictionary per disk block (e.g., a \u201clocal dictionary\u201d). For example, a global dictionary may provide good compression, while a local dictionary may provide greater flexibility and better update performance.","According to an example embodiment, NULL suppression may eliminate leading NULLs or blank spaces in data. For example, a database system may replace these characters with a special character and a length of the sequence of NULLs or spaces. For example, a fixed length CHAR value with many leading NULLs \u201c00000abc\u201d may be replaced by \u201c@5abc\u201d where \u201c@\u201d is the special character for representing compressed NULLs.","According to an example embodiment, prefix suppression may be used similarly as NULL suppression, but it may compress arbitrary prefixes instead of NULLs. For example, the values {aaabc, aaacd, aaade} share the leading prefix \u201caaa\u201d. Prefix compression may replace them with {@bc, @cd, @de} where \u201c@\u201d represents the leading \u201caaa\u201d. For example, systems such as MICROSOFT SQL SERVER may support NULL suppression, prefix suppression and local dictionary compression.","According to an example embodiment, a compression fraction may be estimated for use with database design techniques. For example, data compression may provide a reduced data size. Thus, estimating the size of a compressed index, (e.g., via a compression fraction (CF)) may aid in database design considerations. For example, the compression fraction may be depicted more formally as",{"@attributes":{"id":"p-0128","num":"0132"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mi":["C","F"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":"=","mfrac":{"mrow":[{"mi":["Size","of","compressed","index"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},{"mi":["Size","of","uncompressed","index"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]}]}}},{"mrow":{"mo":["(",")"],"mn":"1"}}]}}}}},"According to an example embodiment, the compression fraction may depend on the compression technique used. For example, scanning the entire data set and running the compression technique on it may provide an accurate estimate of the compression fraction of the index; however, such computations may prove expensive on large databases.","According to an example embodiment, the compression fraction may be estimated based on statistics of columns in the index (e.g., histograms or the number of distinct values). Such statistics may be maintained by the query optimizer for purposes of cardinality estimation.","For example, random samples may be collected. For example, a sampling based estimation method for the compression fraction (e.g., referred to as SampleCF) may be used. SampleCF(I) for an index I may first acquire a random sample of the data using a given sampling fraction f (e.g. a 1% sample), and may create the index I on the sample (e.g., the index size is S). SampleCF(I) may then compress the index using the given compression method to obtain the compressed index I(e.g., the index size is S). SampleCF may then return the compression fraction as S\/S. According to an example embodiment, SampleCF may be advantageously used for NULL suppression, prefix suppression and global dictionary compression. However, although SampleCF may be more efficient than building an index on a full set of data, processing time may still be expensive in terms of obtaining a uniform random sample from the original table for each invocation of SampleCF, and generating an index on a sample (e.g., due to a cost of sorting and compression).","According to an example embodiment, techniques for compression aware physical database design discussed herein may be incorporated into database systems (e.g., MICROSOFT SQL SERVER's tool DATABASE ENGINE TUNING ADVISOR (DTA)).",{"@attributes":{"id":"p-0133","num":"0137"},"figref":["FIG. 5","FIG. 5"],"b":["500","502","504","506","508"]},"According to an example embodiment, the design advisor  may include candidate selection , merging , and enumeration modules , as discussed further herein. The candidate selection  module may include a size estimation  module.","As shown in , the design advisor  may communicate with a database system  (e.g., MICROSOFT SQL SERVER) that may include temporary database storage  that may store samples  such as the samples discussed herein. The database system  may further include a query optimizer  that may include a compression aware cost model.","As shown in , the tuning advisor  may communicate with the database system  via SampleCF  and a what-if analysis , as discussed further herein.","According to an example embodiment, a request for performing what-if analysis  may include transmitting a request to the query optimizer  to return a plan for a given query and a given (hypothetical) physical design configuration. According to an example embodiment, the compression-aware cost model may consider the CPU costs to compress and decompress data in compressed indexes, as discussed below.","Generally, an index or a materialized view (MV) may affect the performance of a database either positively or negatively. For example, an index may increase the speed performance of reads (e.g., SELECT) while it may decrease the speed performance of updates (e.g., INSERT\/DELETE\/UPDATE). An example technique in automatic database design, referred to as What-If analysis, may analytically quantify the benefits of having each candidate index in a system by calling the database's query cost models, and may select a set of indexes that achieve the largest benefits overall. Therefore, in providing a database design tool that may consider the effects of compressing indexes, the query cost models of the database may consider both reads and updates.","According to an example embodiment, the database system  (e.g., SQL SERVER) may compress data when an update operation (e.g., INSERT) modifies a page. For example, the database system  may include two types of compressions: ROW (null-suppression) and PAGE (local dictionary and prefix encoding). ROW suppression may include an order-independent (ORD-IND) compression while PAGE may include an order-dependent (ORD-DEP) compression. As PAGE may involve higher overheads to compress, the example database system  may delay applying PAGE compression even if the page belongs to a PAGE compressed index. Such a page may be first compressed with ROW compression, and then again compressed with PAGE compression when the page is \u201cdone\u201d with modifications (e.g., page becomes full or is ejected from the bufferpool).","According to an example embodiment, a cost model for update operations on compressed indexes in the database system  may be adjusted in accordance with\n\nCPUCost=BaseCPUCost+\u03b1*#tuples\u2003\u2003(2)\n\nwherein BaseCost represents the existing cost model for the update operation and \u03b1 is a constant defined for each compression type which represents the CPU cost to compress the tuple (e.g., larger for PAGE compression). According to an example embodiment, the value of \u03b1 may be determined based on one or more benchmarks (e.g., a micro benchmark).\n","According to an example embodiment, when reading data in compressed indexes, the database system  may retrieve the index pages from the disk and may keep them compressed in a bufferpool to save memory consumption, decompressing the buffered page each time the page is read. Therefore, a read operation on a compressed index may invoke the same CPU overhead for decompression, no matter how many pages of the index reside in the bufferpool.","However, the database system  may avoid decompressing unused columns in the index page. For example, it may decompress only the columns that are projected, predicated or aggregated by a query. If #columnsread represents the number of such used columns in the query, an example cost model for read operations on compressed indexes may be indicated as\n\nCPUCost=BaseCPUCost+\u03b2*#tuples*#columns\u2003\u2003(3)\n\nwherein \u03b2 is a constant that represents a cost of decompressing one column data of one tuple (again, higher for PAGE compression) which may be determined by benchmarking\n","According to an example embodiment, estimations of compressed indexes considered by a design tool may be determined based on example sampling techniques, as well as techniques based deducing the size without further sorting and compressing samples, as discussed further herein.","According to an example embodiment, physical design tools may utilize a predetermined storage bound (i.e., a space budget), thus addressing space vs. performance trade-offs. However, with compression, such trade-offs may become amplified. For example, a compressed index, although sub-optimal for a particular query, may save a lot of space, thereby allowing other indexes to benefit the same or other queries. According to an example embodiment, this may affect the candidate selection techniques (e.g., candidate indexes, MVs are selected based on a per query analysis), as well as enumeration techniques (e.g., where the search for the final configuration is performed over all candidates).","According to an example embodiment, a size of an index may be estimated without actually creating the compressed index. For example, the SampleCF techniques discussed herein may reduce the cost of sampling. As a further example, example deduction techniques discussed herein may reduce the cost by avoiding invocation of SampleCF.","According to an example embodiment, SampleCF may provide size estimation based on random sampling. However, taking a uniform random sample from a large table may consume large amounts of processing capacity. Since a physical design tool may consider a large number of indexes for a workload (e.g., thousands of indexes for complex workloads), taking a random sample for estimating the size of each index may prove infeasible. According to an example embodiment, the sampling cost may be amortized across all indexes on a given table by taking a random sample only once per table. Thus, when a database design tool requests a calculation of the compressed size of an index, a check may determine whether a sample of the table already exists, and if so, the already obtained sample may be used. If not, a random sample may be taken from the original table and may be saved (e.g., in tempdb  of ) for future use. According to an example embodiment, compressed indexes may be generated on this sample table to estimate their compression fraction.","According to an example embodiment, special samples for partial indexes and materialized views (MVs) with grouping and joins may be maintained based on filtering and join-synopses, as a sample of pre-joined tables.","According to an example embodiment, a size estimation framework may maintain sample tables for applying SampleCF. Although the base sample tables may be sufficient for SampleCF on simple indexes, they may be unsuitable for more complex indexes that include WHERE clauses (partial indexes), JOINs and\/or GROUP-BYs (indexes on MVs). Thus, according to an example embodiment, a size estimation framework may also maintain filtered samples and MV samples.","According to an example embodiment, a filtered sample may be generated by applying the WHERE clause on the base sample table and may be used for partial indexes. For example, a partial index may be indicated as\n\n","A filtered sample may be obtained via SQL, based on\n\n","This filtered sample may provide an estimation as far as SLINEITEM is uniformly random (not skewed with respect to the WHERE clause) and may include a reasonably large number of tuples.","However, an MV sample may be more difficult to construct. A first consideration in this regard includes the JOIN command. For example, an MV which joins LINEITEM with SUPPLIER may be indicated as\n\n","According to an example embodiment, a sample for this MV may be obtained by joining two sample tables, which may be indicated as\n\n","However, this may provide few tuples in the MV sample, as each base sample is obtained randomly and may not include tuples that match the foreign key values. To address this concern, a join synopsis of the database may be generated, and may be applicable for Key-Foreign Key join views.","According to an example embodiment, when the framework is initialized, a random sample of fact tables (e.g., LINEITEM) may be obtained. Next, the sample fact table may be joined with the original dimension tables so that foreign key values have matching tuples, resulting in a wide joined sample. According to an example embodiment, such join synopses may be used to create MV samples when the database design tool requests them. For example, an MV sample for MV1 may be obtained by running the same SQL as discussed above, but on the joined synopses. Then, compressed indexes may be generated on the sample to estimate the compressed size of indexes on the MV.","According to an example embodiment, materialized views with GROUP BY and aggregation may be included in design considerations. To estimate the size of a compressed index, the number of entries (tuples) in the index may be obtained. Although the base table's statistics may be used for simple indexes, it may be desirable to estimate how many distinct groups the MV will have. For example, an MV and its MV sample may be indicated as\n\n","For example, SMV2 may include approximately 1,000 tuples. If the number of tuples scales up to the sampling ratio (e.g., SLINEITEM may include 1% of LINEITEM), the MV may include approximately 100K tuples. However, an actual number of tuples in the MV may approximate 2,000 (the number of distinct SHIPDATE values). Thus, unlike partial indexes, a distribution of distinct values may be considered in estimating the number of tuples in MVs.","For example, a query indicated as\n\n",{"@attributes":{"id":"p-0159","num":"0176"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Algorithm 1"},{"entry":"Algorithm 1: CreateMVSample ( )"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2002a. \u2002SELECT <MV-Project>, COUNT(*) AS cnt INTO S"]},{"entry":[{},"FROM <join-synopses> WHERE <MV-WHERE>"]},{"entry":[{},"GROUP BY <MV-GROUP BY>."]},{"entry":[{},"\u2002b. \u2002r = SELECT SUM(cnt) FROM S"]},{"entry":[{},"\u2002c. \u2002d = SELECT COUNT(*) FROM S"]},{"entry":[{},"\u2002d. \u2002FilterFactor = r \/ <join-synopses>.#tuple"]},{"entry":[{},"\u2002e. \u2002n = RootTable.#tuple * FilterFactor"]},{"entry":[{},"\u2002f. \u2002f= SELECT cnt AS frequency, COUNT(*) AS value"]},{"entry":[{},"FROM SGROUP BY cnt"]},{"entry":[{},"\u2002g. \u2002MV.#tuple = AdaptiveEstimator(f, d, r, n);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"As shown, Algorithm 1 above may address this issue without adding overheads to the design tool. For example, a DBMS may expect an MV with aggregation to include a COUNT(*) column in its definition (or internally add as a hidden column) for incremental maintenance. The DBMS may increase or decrease the counter when a newly inserted or deleted tuple falls into the group, and may eliminate the group when the counter reaches zero. According to an example embodiment, this information may be used as frequency statistics for distinct value estimators.","According to an example embodiment, a distinct value estimator (e.g., Adaptive Estimator) may provide an estimated number of distinct values based on frequency statistics f={f, f, . . . f} where frepresents the number of distinct values that appear k times in the random sample. For example, the statistics may be obtained by querying on the MV sample and aggregating on the COUNT column. Additionally, r and d may be determined (the number of tuples in the MV sample before and after the aggregation respectively) as well as n, the number of tuples in the original table. According to an example embodiment, an Adaptive Estimator may accept these values as inputs and may determine the estimated number of tuples in the MV. According to an example embodiment, these estimates may be preserved in storage for each MV sample taken.","According to an example embodiment, indexes may be generated on the join synopses. For example, this technique may speed up querying on them, for creating MV samples. According to an example embodiment, indexes on primary keys and foreign keys may speed up this process.","According to an example embodiment, example techniques discussed herein may deduce the size of a compressed index based on other indexes whose sizes are known. For example, such example deduction techniques may incur minimal cost to estimate the size of an index.","According to an example embodiment, deduction of an index size may depend on a type of compression scheme. For example, compression techniques discussed herein may be described as belonging to one of two groups: Order-Independent (ORD-IND) and Order-Dependent (ORD-DEP) compression techniques. For example, ORD-IND compressions such as NULL-suppression and global dictionary encoding may produce compressed indexes having the same (or approximately the same) compressed size regardless of the order of tuples in the index page, while ORD-DEP compressions such as local dictionary encoding and run length encoding (RLE) may be sensitive to the order of tuples, or the value distribution in each page.","For example, compressed indexes CI, CImay be based on two columns A, B. As shown in , the ordering of tuples in the two composite indexes is different. However, NULL-suppression suppresses the same total number of NULLs in both cases. Similarly, global dictionary encoding may generate the same (or approximately the same) dictionary for the two indexes and may replace the same (or approximately the same) number of entries with pointers to the dictionary (based on a DBMS that generates a dictionary per column).","According to an example embodiment, a column set deduction (ORD-IND) technique may deduce the size of CIfrom that of CIas Size(CI)=Size(CI), since the order of data does not affect the compressed size. More generally, every two indexes compressed in ORD-IND may have the same (or approximately the same) size if they include the same set of columns.","According to an example embodiment, column set deduction (ColSet deduction) may be useful for clustered indexes. All clustered indexes on the table may have the same (or approximately the same) compressed size because all include the same set of columns. Thus, SampleCF may be avoided for all but one clustered index per table.","According to an example embodiment, a column extrapolation (ORD-IND) technique (e.g., ColExt) may estimate the size of a composite index from subsets of the index. For example, a user may wish to estimate Size(CI), and Size(CI) and Size(CI) may already be available. R(I) may represent the size reduction achieved by compressing I(i.e., R(I)=Size(I)\u2212Size(CI)). If the compression is ORD-IND, then R(I) may be estimated from R(I) and R(I) as R(I)=R(I)+R(I) because ORD-IND achieves the same (or approximately the same) size reduction for each column. Therefore, Size(CI) may be determined as\n\nSize()=Size()\u2212()\u2212().\u2003\u2003(4)\n",{"@attributes":{"id":"p-0169","num":"0186"},"figref":["FIGS. 6","FIG. 6","FIG. 6","FIG. 6"],"i":["a","b ","a","a","b. "],"b":["6","602","606","602","608","604","602","606"],"sub":["AB","AB ","A ","BA "]},"According to an example embodiment, to account for the fragmentation , the average number of distinct values in each page may be estimated and the size reduction attributed to following columns may be penalized.","For example, DV(I, Y) may represent an average number of distinct values of a column Y and T(I) may represent a number of tuples in a page of an index I. According to an example embodiment, the average fraction of Y replaced by the dictionary may be indicated as",{"@attributes":{"id":"p-0172","num":"0189"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"F","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","X"]},"mo":",","mi":"Y"}}},{"mfrac":{"mrow":[{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["I","X"]}}},{"mi":"DV","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","X"]},"mo":",","mi":"Y"}}}],"mo":"-"},{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["I","X"]}}}]},"mo":"."}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"5"}}]}}}}},"For example, T(I)=4, DV(I, A)=1, and F(I, A)=3\/4 of the values of A were eliminated. The size of Imay be deduced from Iand I, so that R(I) and R(I) may be known. As the space saving of compression may be linear to the number of values replaced by the dictionary,",{"@attributes":{"id":"p-0174","num":"0191"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["I","AB"]}}},{"mrow":[{"mrow":{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["I","B"]}}},"mo":"\u2062","mfrac":{"mrow":[{"mi":"F","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","BA"]},"mo":",","mi":"B"}}},{"mi":"F","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","B"]},"mo":",","mi":"B"}}}]}},{"mrow":[{"mi":"R","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["I","A"]}}},{"mfrac":{"mrow":[{"mi":"F","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","BA"]},"mo":",","mi":"A"}}},{"mi":"F","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","A"]},"mo":",","mi":"A"}}}]},"mo":"."}],"mo":"\u2062"}],"mo":"+"}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"6"}}]}}}}},"As B is the leading key of I, its value distribution in pages may equal that of I, thus F(I, B)=F(I, B). The value distribution of A may be fragmented by B, and thus, F(I, A)<F(I, A).","In determining F(I, A) and F(I, A) (i.e., DV(I, A) and DV(I, A)), the average run length of a value of A in Iand Imay be considered. For example, L(I, Y) may represent the average run length of a value of Y in I. For example, L(I, A)=2, L(I, A)=L(I, A)=4, as shown in the example of -","According to an example embodiment, the values may be approximated with cardinality statistics as:",{"@attributes":{"id":"p-0178","num":"0195"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mrow":[{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","A"]},"mo":",","mi":"A"}}},{"mo":["\u230a","\u230b"],"mfrac":{"mrow":[{"mi":["#","TotalTuples"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}},{"mo":["\uf603","\uf604"],"mi":"A"}]}}],"mo":"="},{"mrow":[{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","BA"]},"mo":",","mi":"A"}}},{"mo":["\u230a","\u230b"],"mrow":{"mrow":{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","A"]},"mo":",","mi":"A"}}},"mo":"\u2062","mfrac":{"mrow":[{"mo":["\uf603","\uf604"],"mi":"A"},{"mo":["\uf603","\uf604"],"mi":"AB"}]}}}],"mo":"="}],"mo":","}},{"mrow":{"mo":["(",")"],"mn":"7"}}]}}}}},"In accordance with the example of -, approximated values may be indicated as L(I, A)=8\/2=4 and L (I, A)=4*2\/4=2. According to an example embodiment, in determining L(I, A), L(I, A) is not divided by |B| because A and B may be correlated, i.e., |A|\/|AB|<<|B|.","According to an example embodiment, the number of distinct values may be approximated as:",{"@attributes":{"id":"p-0181","num":"0198"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mrow":{"mi":"When","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","X"]},"mo":",","mi":"Y"}}}},"mo":">","mn":"1"},{"mrow":[{"mi":"DV","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","X"]},"mo":",","mi":"Y"}}},{"mo":["\u2308","\u2309"],"mfrac":{"mrow":[{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["I","X"]}}},{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","X"]},"mo":",","mi":"Y"}}}]}}],"mo":"="}],"mo":","}},{"mrow":{"mo":["(",")"],"mn":"8"}}]}}}}},"For example, DV(I, A)=4\/2=2.",{"@attributes":{"id":"p-0183","num":"0200"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mrow":{"mi":"If","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","X"]},"mo":",","mi":"Y"}}}},"mo":"<=","mn":"1"},{"mrow":[{"mi":"DV","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msub":{"mi":["I","X"]},"mo":",","mi":"Y"}}},{"mrow":[{"mo":["\uf603","\uf604"],"mi":"Y"},{"mrow":{"mo":["\uf603","\uf604"],"mi":"Y"},"mo":"\u2062","msup":{"mrow":[{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mfrac":{"mn":"1","mrow":{"mo":["\uf603","\uf604"],"mi":"Y"}}}},{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["I","X"]}}}]}}],"mo":"-"}],"mo":"="}],"mo":","}},{"mrow":{"mo":["(",")"],"mn":"9"}}]}}}},"br":{},"sub":"X"},"According to an example embodiment, this estimation may also be used with run length encoding (RLE) compression.","According to an example embodiment, deduction may provide techniques that may eliminate some SampleCF calls and may thus reduce the cost of index size estimation. However, both SampleCF (when using a low sampling fraction) and deduction may result in size estimation errors.","A database design tool may evaluate a large number of indexes. Inefficient size estimation may thus lead to suboptimal runtime of the tool. For example, an index size estimation without deduction techniques may generate a dominating overhead on a database design tool. Thus, it may be desirable to determine an optimal sample size for SampleCF and an optimal strategy with regard to selection of indexes for estimation using SampleCF, and selection of indexes for estimation using deduction.","However, an erroneous size estimation may lead to a decrease in design quality because the compression fraction of a compressed index may impact the beneficial usefulness of the index. Therefore, a trade-off between accuracy and performance may be balanced. According to an example embodiment, this problem may be expressed as an optimization problem, and an example graph search algorithm may be used as a solution to the problem, as discussed further herein.","For example, a problem of index size estimation may be indicated as shown below.","According to an example embodiment, inputs to the problem include a set of indexes whose sizes need to be estimated (e.g., indicated as targets), a tolerable error ratio e and a confidence parameter q such that the estimated sizes of the targets have errors less than e for at least q probability.","According to an example embodiment, outputs from the solution to the problem include a sampling ratio f (e.g., fraction of table to sample) and the deduction strategy that minimizes the total cost of size estimation without violating the accuracy constraint.","For example, when e=20% and q=95%, the estimated size of a compressed index whose size is 100 MB may include values between 120 MB and 83.3 MB for at least 95% probability. Higher e and lower q may allow a smaller sample size and more deductions, and may therefore be faster at the cost of accuracy. For determining whether an estimate satisfies the accuracy constraint, its error may be quantified as discussed below.","According to an example embodiment, a sample-based size estimation technique may lead to an arbitrary error. However, according to an example embodiment, an expected error (bias) and its variance may be inferred. For example, SampleCF for NULL suppression encoding may be unbiased and may have at most 1\/rfvariance where f represents a sampling ratio and r represents the number of sampled tuples.","According to an example embodiment, Xmay represent a random variable to denote a result of size estimation for Idivided by its true size. Thus, X=1 may represent a most accurate estimation. For example, for an index Ifor which the size of Imay be inferred from Iand Iwith ColExt, a deduced result may be indicated as X=XXXwhere Xis the random variable to denote the result of the deduction for perfectly accurate inputs (sizes of Iand I), in order to account for amplified errors by deduction. The variance of such a product of random variables may be determined as",{"@attributes":{"id":"p-0194","num":"0211"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"munderover":{"mo":"\u220f","mi":"i","mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"V","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["X","i"]}}},"mo":"+","msup":{"mrow":{"mi":"E","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["X","i"]}}},"mn":"2"}}}},{"munderover":{"mo":"\u220f","mi":"i","mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"mo":["(",")"],"msup":{"mrow":{"mi":"E","mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mi":["X","i"]}}},"mn":"2"}}}],"mo":"-"}},{"mrow":{"mo":["(",")"],"mn":"10"}}]}}}},"br":{}},"According to an example embodiment, a cost of index size estimation may be modeled as the amount of data for indexing. A cost of SampleCF on an index may be indicated as the number of data pages in the index before compression. Hence, SampleCF on wider indexes with larger samples may cost more than narrow indexes. The cost of deduction may be indicated as zero (or approximately zero).","In many situations, a database may already have a compressed index before running the database design tool. Such an index may provide an accurate size of itself from the database statistics. Hence, such an index may be indicated as having zero (or approximately zero) bias and variance, as well as zero (or approximately zero) cost for size estimation.",{"@attributes":{"id":"p-0197","num":"0214"},"figref":["FIG. 7","FIG. 7"]},{"@attributes":{"id":"p-0198","num":"0215"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Algorithm 2"},{"entry":"Algorithm 2: Graph Search Algorithm"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003a.","Add existing indexes to the graph with SAMPLED state."]},{"entry":[{},"\u2003b.","Add target indexes to the graph with NONE state;"]},{"entry":[{},"\u2003c.","foreach(target) { \/\/ from narrower to wider"]},{"entry":[{},"\u2003d.","\u2002Add all child deduction nodes of this node to the graph;"]},{"entry":[{},"\u2003e.","\u2002Add children of the deduction nodes, if not yet added;"]},{"entry":[{},"\u2003f.","\u2002if (any deduction is already enabled and satisfies the"]},{"entry":[{},{},"constraint with the given f, e and q) {"]},{"entry":[{},"\u2003g.","\u2003Mark this node DEDUCED from the deduction node;"]},{"entry":[{},{},"(if multiple deductions are eligible, pick the one with the"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"highest probability)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003h.","\u2002} else if (any deduction can be enabled by doing"]},{"entry":[{},{},"SampleCF on its children such that the sum of their costs is"]},{"entry":[{},{},"lower than the cost of sampling this node) {"]},{"entry":[{},"\u2003i.","\u2003Mark this node DEDUCED from the deduction node and"]},{"entry":[{},{},"mark its children SAMPLED; (if multiple deductions are"]},{"entry":[{},{},"eligible, pick the one with the least cost)"]},{"entry":[{},"\u2003j.","\u2002} else {"]},{"entry":[{},"\u2003k.","\u2003Mark this node SAMPLED;"]},{"entry":[{},"\u2003l.","}}"]},{"entry":[{},"\u2003m.","foreach (enabled index) \/\/from wider to narrower"]},{"entry":[{},"\u2003n.","\u2002if (not targeted nor used by parents) Remove the node;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"As shown in , the graph may include two types of nodes, indicated as index nodes , , , , , and deduction nodes , , . According to an example embodiment, an index node (e.g., \u201cAB\u201d) may represent the size estimation for an index and may have one of three states, indicated as NONE, DEDUCED and SAMPLED. For example, NONE may be an initial state of all index nodes wherein the size of the index is not estimated (step 2 of Algorithm 2). For example, DEDUCED and SAMPLED states may indicate that the size is estimated by deduction and SampleCF, respectively. According to an example embodiment, edges may connect index nodes from\/to deduction nodes. For example, a node from which an edge emerges may be indicated as a child node (e.g., nodes , , , , , , ), and a node at which the edge is directed may be indicated as a parent node (e.g., nodes , , , , ).","According to an example embodiment, a deduction node may represent a possible deduction to estimate the size of its parent based on its children. For example, the deduction node \u201cA+B\u201d () has a parent index node \u201cAB\u201d  (the index whose size can be deduced) and child index nodes \u201cA\u201d  and \u201cB\u201d  (indexes using a deduction that can be performed). According to an example embodiment, a deduction node may be enabled only when all its children are DEDUCED or SAMPLED (i.e., their sizes are known). As shown in , the deduction node  is enabled, as its children ,  are both indicated as SAMPLED.","According to an example embodiment, the directed graph of  may be used to determine an assignment of the states to each node such that all target indexes are marked as DEDUCED or SAMPLED, and also satisfy a desired level of accuracy (i.e., error constraints).","As shown in the example of , I(e.g., node ) and I(e.g., node ) may be indicated as target indexes. The solution shown in  is to SampleCF on I(e.g., node ) and I(e.g., node ) and then deduce the size of I(e.g., node ) from the samples. Compared to SampleCF on Iand I, this solution may provide less accuracy on the size estimation of I, due to the deduction.","However, since building a sample composite index on ABC may cost more than building on C, the solution may be better unless the error constraint is too tight to allow the deduction. According to an example embodiment, another possible solution may include a SampleCF on all singleton indexes and a deduction of the size of Iand I. For this solution, candidates for deducing the size of Imay include A+B+C and AB+C.","A determination of a \u201cbetter\u201d deduction may depend on the states of children of their deduction nodes, as errors may be recursively calculated from children to parents. As there exist a potentially large number of target indexes, an exact algorithm for determining an optimal solution may prove to be infeasible. Thus, an example heuristic technique may be used, as discussed below.","As a background consideration of an example technique, indexes considered in a design tool may be correlated as the technique exhaustively considers syntactically relevant indexes for each query. For example, when Iis considered, Iand Imay also be considered and vice versa. Thus, narrower indexes may be considered first, and a passive examination may be conducted to determine an opportunity to deduce wider indexes from the narrower indexes.","According to an example embodiment, an example technique may be run with a few f and one solution with the smallest total cost among valid results may be selected. It may be observed that some combination off, e and q provides an invalid result where even directly applying SampleCF on all targets does not satisfy the accuracy constraint. However, the example technique may achieve smaller total cost while maintaining a good accuracy of size estimation.",{"@attributes":{"id":"p-0207","num":"0224"},"figref":["FIG. 8","FIG. 8"],"b":["800","800","802","804","806","808","802","804","810","812","802","804","810","812","810","812","814"]},"While it may be possible to generate compressed variants of all syntactically relevant indexes ,  without changing the candidate selection and enumeration logics, such an approach may not capture a database design that fully exploits the benefits of compressed indexes.","A number of all syntactically relevant indexes may be large, although few of them may be useful. Therefore, a design tool may select a few small seed configurations by picking a configuration that performs fastest for each query. This best-per-query approach may work well for a large space budget, but may result in designs that speed up only a small number of queries with a tight space budget. Such techniques may not capture space efficient indexes that are not the \u201cbest\u201d in terms of query performance, but which may achieve the best overall performance as they may include more indexes for other queries.","Compression may make this space-performance trade-off even more prominent. Compressed indexes may not be the fastest indexes due to their decompression CPU costs. For example, a selection method may miss many useful compressed indexes except for indexes with good compression fractions that may negate the decompression cost by the reduced I\/O cost.",{"@attributes":{"id":"p-0211","num":"0228"},"figref":["FIG. 9","FIG. 9"],"b":["902","904","906","908"]},"An overhead for generating the skyline may be indicated as O(n) where n represents the number of configurations for each query. According to an example embodiment, the skyline selection along with the backtracking described further below may provide the benefits of compressed indexes in a tight space budget. Across all indexes of all seed configurations, enumeration selects a \u201cbest\u201d set of indexes that speed up the query workload and also satisfy the space budget.",{"@attributes":{"id":"p-0213","num":"0230"},"figref":["FIGS. 10","FIGS. 10"],"i":["a","b ","a","b"],"b":["10","10","1002","1004","1004","1006","1008","1004","1010","1008","1006"],"sub":["A ","B ","B ","C ","B ","B ","B ","C "]},"This situation may occur with heavily compressed clustered indexes, as they may save a large space by compressing the entire table but may perform slowly with queries. As one table may include one clustered index (otherwise the design is infeasible), the pure greedy approach may not improve the design if an uncompressed clustered index is selected in an earlier step. A similar problem may result from competing indexes which speed up the same queries but only one of them can be used at the same time, as I and CI in the above example. It may be possible to avoid the suboptimal choice by considering the density at each greedy step, selecting the index that has the highest benefit divided by its size.","For simplicity, one query may be considered. For this example, indexes I, CI, and I may speed up the query for 10, 8 and 5 seconds, respectively. The density of these indexes at a first greedy step is 10\/10=1, 8\/5=1.6 and 5\/10=0.5 (, , ), respectively. Thus, CI may be selected at this step. At the next step, the benefit of adding I is still 5 seconds while that of adding I is 2 (=10) seconds because the slower but competing index CI is included. The density of I and I are 2\/10=0.2 and 0.5 (, ), thus I is selected at this step, resulting in an optimal design .","However, the density based greedy technique as shown results in the same design even for a 20 MB space budget where the optimal design is I and I. Further, a density based approach may add many small indexes that may add little benefit, which may generate a suboptimal design for larger budgets.",{"@attributes":{"id":"p-0217","num":"0234"},"figref":["FIG. 11","FIG. 11"],"b":"1102"},"According to an example embodiment, a database design with more indexes and heavier compression may be used for SELECT intensive workloads while a database design with fewer indexes and lighter compression may be used for INSERT intensive workloads because of the overheads to maintain indexes against INSERT statements, as discussed above.","Thus, example techniques discussed herein may provide database design tools that may consider compressed and uncompressed database structures in determinations of optimal designs.","Implementations of the various techniques described herein may be implemented in digital electronic circuitry, or in computer hardware, firmware, software, or in combinations of them. Implementations may implemented in a propagated signal, or, alternatively, as a computer program product, i.e., a computer program tangibly embodied in an information carrier, e.g., in a machine usable or machine readable storage device (e.g., a magnetic or digital medium such as a Universal Serial Bus (USB) storage device, a tape, hard disk drive, compact disk, digital video disk (DVD), etc.), for execution by, or to control the operation of, data processing apparatus, e.g., a programmable processor, a computer, or multiple computers. A computer program, such as the computer program(s) described above, can be written in any form of programming language, including compiled or interpreted languages, and can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment. A computer program that might implement the techniques discussed above may be deployed to be executed on one computer or on multiple computers at one site or distributed across multiple sites and interconnected by a communication network.","Method steps may be performed by one or more programmable processors executing a computer program to perform functions by operating on input data and generating output. The one or more programmable processors may execute instructions in parallel, and\/or may be arranged in a distributed configuration for distributed processing. Method steps also may be performed by, and an apparatus may be implemented as, special purpose logic circuitry, e.g., an FPGA (field programmable gate array) or an ASIC (application specific integrated circuit).","Processors suitable for the execution of a computer program include, by way of example, both general and special purpose microprocessors, and any one or more processors of any kind of digital computer. Generally, a processor will receive instructions and data from a read only memory or a random access memory or both. Elements of a computer may include at least one processor for executing instructions and one or more memory devices for storing instructions and data. Generally, a computer also may include, or be operatively coupled to receive data from or transfer data to, or both, one or more mass storage devices for storing data, e.g., magnetic, magneto optical disks, or optical disks. Information carriers suitable for embodying computer program instructions and data include all forms of non volatile memory, including by way of example semiconductor memory devices, e.g., EPROM, EEPROM, and flash memory devices; magnetic disks, e.g., internal hard disks or removable disks; magneto optical disks; and CD ROM and DVD-ROM disks. The processor and the memory may be supplemented by, or incorporated in special purpose logic circuitry.","To provide for interaction with a user, implementations may be implemented on a computer having a display device, e.g., a cathode ray tube (CRT) or liquid crystal display (LCD) monitor, for displaying information to the user and a keyboard and a pointing device, e.g., a mouse or a trackball, by which the user can provide input to the computer. Other kinds of devices can be used to provide for interaction with a user as well; for example, feedback provided to the user can be any form of sensory feedback, e.g., visual feedback, auditory feedback, or tactile feedback; and input from the user can be received in any form, including acoustic, speech, or tactile input.","Implementations may be implemented in a computing system that includes a back end component, e.g., as a data server, or that includes a middleware component, e.g., an application server, or that includes a front end component, e.g., a client computer having a graphical user interface or a Web browser through which a user can interact with an implementation, or any combination of such back end, middleware, or front end components. Components may be interconnected by any form or medium of digital data communication, e.g., a communication network. Examples of communication networks include a local area network (LAN) and a wide area network (WAN), e.g., the Internet.","Although the subject matter has been described in language specific to structural features and\/or methodological acts, it is to be understood that the subject matter defined in the appended claims is not necessarily limited to the specific features or acts described above. Rather, the specific features and acts described above are disclosed as example forms of implementing the claims. While certain features of the described implementations have been illustrated as described herein, many modifications, substitutions, changes and equivalents will now occur to those skilled in the art. It is, therefore, to be understood that the appended claims are intended to cover all such modifications and changes as fall within the scope of the embodiments."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DRAWINGS","p":[{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":["FIGS. 2","FIG. 1"],"i":["a","g "],"b":"2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":["FIGS. 3","FIG. 1"],"i":["a","b "],"b":"3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIGS. 4","FIG. 1"],"i":["a","b "],"b":"4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 6","i":["a","b "],"b":"6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIGS. 10","i":["a","b "],"b":"10"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
