---
title: Techniques for application tuning
abstract: Techniques for tuning systems generate configurations that are used to test the systems to determine optimal configurations for the systems. The configurations for a system are generated to allow for effective testing of the system while remaining within budgetary and/or resource constraints. The configurations may be selected to satisfy one or more conditions on their distributions to ensure that a satisfactory set of configurations are tested. Machine learning techniques may be used to create models of systems and those models can be used to determine optimal configurations.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08954309&OS=08954309&RS=08954309
owner: Oracle International Corporation
number: 08954309
owner_city: Redwood Shores
owner_country: US
publication_date: 20110531
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCES TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["This application is relating to co-pending U.S. patent application Ser. No. 13\/149,701, filed May 31, 2011, entitled \u201cApplication Configuration Generation,\u201d which is hereby incorporated herein by reference for all purposes.","One of the biggest issues in configuration of enterprise and other applications is to ensure optimal performance given the hardware and software platform they are deployed on throughout the life cycle of the application. While application tuning can be done during the initial installation, such tuning can be rendered useless throughout the life-cycle of the application by the fact that the nature of the data may change. In addition, many variables may force an application to be configured in a way that results in less than optimal performance.","Processes, such as enterprise applications, can contain numerable configurable parameters, resulting in large numbers of possible configurations. Determining which configuration will produce the best desired performance under a particular usage pattern is a difficult problem that often requires intricate knowledge of the complex interdependencies among the various parameters under different workloads. In many contexts, this requires expertise in enterprise application tuning. The acquisition of this expertise can be not only nontrivial, but also time-consuming. In addition, because an application may have different optimal performance points, tuning an application based on workload type and tuning an application instance are two different problems since the performance of an application instance likely depends on its state.","One way to tune an application is to perform experiments that measure how the application performs when configured with different configurations. An application, however, takes time to test and, while being tested, the application may utilize computing resources that could be used for other purposes. Due to the large number of configurations, budgets and resources may not allow for the testing of all configurations.","The following presents a simplified summary of some embodiments of the invention in order to provide a basic understanding of the invention. This summary is not an extensive overview of the invention. It is not intended to identify key\/critical elements of the invention or to delineate the scope of the invention. Its sole purpose is to present some embodiments of the invention in a simplified form as a prelude to the more detailed description that is presented later.","In an embodiment, a computer-implemented method of determining system configurations is performed under the control of one or more computer systems configured with executable instructions. The method may include determining a set of configurations for a system; measuring performance of the system for members of the determined set of configurations; creating, based at least in part on the measured performance, a model of the system; generating, based at least in part on the model, one or more configurations; and providing the generated one or more configurations for tuning the system.","Variations of the method are also considered as being within the scope of the present disclosure. For example, the method may further comprise tuning the system according to at least one of the generated one or more configurations. Determining the set of configurations may include testing at least a first set of configurations for the system to determine a set of configuration constraints; and selecting the set of configurations from within the determined set of configuration constraints. Determining the set of constraints may include modeling the system to determine the set of configuration constraints. Selecting the set of configurations may include selecting the set of configurations to have a distribution that satisfies one or more distribution conditions. Measuring the performance of the system for each configuration may include configuring the system with the configuration; simulating the configured system; and measuring one or more performance characteristics of the system.","In another embodiment, a computing system for determining configurations for a system under test, which may be a system for which configurations are generated to determine an optimal set of configurations, is disclosed. The computing system may include one or more processors; and memory including executable instructions that, when executed by the one or more processors, cause the computing system to implement at least a configuration selector, an application simulator, a model creator, and a model optimizer. The configuration selector may be configured to select a set of configurations for the system under test. The application simulator may be configured to simulate the system under test under the selected set of configurations and provide, based at least in part on simulating the system under test, performance data for the system under test. The model creator may be configured to create, based at least in part on the provided performance data, a model of the system under test. The model optimizer may be configured to determine, based at least in part on the created model, one or more configurations for the system under test. The system under test may be an application which may be on a host system.","As with any embodiment described or suggested herein, the variations of the computing system are considered as being within the scope of the present disclosure. For example, the configuration selector may include a configuration validator, a classification trainer, and\/or a configuration generator. The configuration validator may be configured to determine whether configurations are valid and the configuration selector may avoid selecting invalid configurations. The classification trainer may be configured to learn constraints for configurations and the configuration selector may select the set of configurations from within the learned constraints. The configuration generator may be configured to generate valid configurations within a set of constraints and the configuration selector may select the set of configurations from the generated valid configurations. The configuration selector may be configured to select the set of configurations in a manner satisfying one or more configuration distribution conditions.","In accordance with another embodiment, one or more computer-readable storage media having collectively stored thereon instructions executable by one or more processors to cause a computer system to generate and provide configurations are disclosed. The instructions, when executed by the one or more processors, cause the computer system to determine a set of configurations for the system; measure performance of the system for members of the determined set of configurations; create, based at least in part on the measured performance, a model of the system; generate, based at least in part on the model, one or more configurations; and provide the generated one or more configurations for tuning the system.","Determining the set of configurations may include testing at least a first set of configurations for the system to determine a set of configuration constraints; and selecting the set of configurations from within the determined set of configuration constraints. Determining the set of constraints may include modeling the system to determine the set of configuration constraints. Selecting the set of configurations may include selecting the set of configurations to have a distribution that satisfies one or more distribution conditions. Measuring performance of the system for each configuration may include configuring the system with the configuration, simulating the configured system and measuring one or more performance characteristics of the system. The set of configurations, in an embodiment, is a proper subset of a set of possible configurations for the system. Each configuration may comprise a plurality of configurable parameters of the system. Simulating the configured system may include causing virtual users of the system to interact with the system.","In an embodiment, a computer-implemented method of determining system configurations that may be performed under the control of one or more computer systems configured with executable instructions is discussed. The method, in an embodiment, includes determining a set of configurations for a system; generating a set of testing results by at least testing the validity of configurations in the set of configurations; creating, based at least in part on the testing results, a model that defines one or more configuration constraints; determining, based at least in part on the generated model, an updated set of configurations that are valid according to the defined configuration constraints of the generated model; and providing the updated set of configurations for testing the system.","Generating the set of testing results may include operating the system under the configurations. The method may also further comprise operating the system under the configurations of the updated set of configurations; measuring performance of the operated system to generate a second set of testing results; creating, based at least in part on the second testing results, a second model by at least testing the system under the configurations of the updated set of configurations; and using the second model to determine at least one optimal configuration for the system. The updated set of configurations may be generated to form an optimal Latin hypercube. Creating the model may include determining at least one configuration constraint without prior knowledge of the configuration constraint. Determining the updated set of configurations may include performing a particle swarm optimization algorithm to determine the updated set of configurations and the particle swarm optimization algorithm may be a permutation particle swarm optimization algorithm.","In another embodiment, a computing system for generating configurations for a system under test includes one or more processors and memory including executable instructions that, when executed by the one or more processors, cause the computing system to implement at least a configuration validator, a trainer, and a configuration generator. The configuration validator may be configured to generate validity data that indicates whether configurations are valid. The trainer may be configured to determine, based at least in part on the generated validity data, one or more configuration constraints. The configuration generator may be configured to generate configurations within the determined one or more configuration constraints.","The computing system may be configured to operate the configuration validator, the trainer, and the configuration generator iteratively to determine a set of configurations for testing the system. The configuration generator generates configurations to satisfy one or more distribution conditions for the configurations. The trainer may train a model and determines, based at least in part on the trained model, the one or more configuration constraints. The configuration validator includes a tester configured to test the system under the generated configurations.","In another embodiment, one or more computer-readable storage media having collectively stored thereon instructions executable by one or more processors to cause a computer system to generate configurations are disclosed. The instructions, when executed by the one or more processors, may cause the computer system to at least determine a set of configurations for a system; generate a set of testing results by at least testing the validity of configurations in the set of configurations; create, based at least in part on the testing results, a model that defines one or more configuration constraints; determine, based at least in part on the generated model, an updated set of configurations that are valid according to the defined configuration constraints of the generated model; and provide the updated set of configurations for testing the system.","Generating the set of testing results includes operating the system under the configurations. The one or more computer-readable storage media may further include instructions executable by the one or more processors to cause the computer system to further: operate the system under the configurations of the updated set of configurations; measure performance of the operated system to generate a second set of testing results; create, based at least in part on the second testing results, a second model by at least testing the system under the configurations of the updated set of configurations; and use the second model to determine at least one optimal configuration for the system. The updated set of configurations, in an embodiment, forms an optimal Latin hypercube. Creating the model may include determining at least one configuration constraint without prior knowledge of the configuration constraint. Determining the updated set of configurations may include performing a particle swarm optimization algorithm, which may be a permutation particle swarm optimization algorithm, to determine the updated set of configurations. As above, the system may be an application on a host system.","In the following description, various embodiments will be described. For purposes of explanation, specific configurations and details are set forth in order to provide a thorough understanding of the embodiments. However, it will also be apparent to one skilled in the art that the embodiments may be practiced without the specific details. Furthermore, well-known features may be omitted or simplified in order not to obscure the embodiment being described. The following description describes an embodiment of the present invention in the application testing domain. However, the scope of the present invention is not restricted to applications, but may be applied to other domains or applications. For example, any domain or application where systems configurations can be tested may make use of the present invention.","Embodiments of the present disclosure relate to generating configurations for a system and using those configurations to determine optimal configurations for the system. In an embodiment, techniques to create a decision support system are used to tune the configuration settings of systems, such as complex information technology (IT) applications. A system in accordance with an embodiment may use two statistical models that capture the constraints between various configuration settings and 2) capture the relationship of configuration settings to performance characteristics for various user-provided system workloads. In an embodiment, both models are created using closed-loop training techniques. The process and system, in an embodiment, may create the second model for performance tuning.","In an embodiment, the first model is used, along with design of experiment techniques, to find an optimal set of simulations to employ in order to collect data that is used to create the second model. The second model, in an embodiment, predicts performance based on configuration settings, and can also be used, via optimization techniques, to recommend configuration settings to tune an application's performance so that it meets given goals. The system may be configured as a generalized off-line automated process for creating a statistical model of the performance characteristics of a system, which may be then coupled with an optimization algorithm to create a decision support system (DSS) that recommends configuration settings that will best achieve desired performance characteristics. The process and system may combine and adapt a number of algorithms for optimization, machine learning, and statistical analysis. In an embodiment, the system is configured to model and optimize enterprise applications, but can be adapted to tune any configurable system, such as configurable IT applications or, generally, automated processes.","In an embodiment, configurations used to test a system to determine optimal configurations for the system utilize a design of experiment (DoE) process that, in the presence of a mechanism for testing the validity of a given experiment (test of the system under a configuration), removes the need to know the constraints in advance. The process may use a closed-loop process for finding a DoE that, given a variable domain and a \u201cvalidity tester,\u201d creates a set of experiments that does not need a priori knowledge of variable constraints. Thus, an advantage is obtained since the process allows capture of known constraints but does not require knowledge of all constraints in advance. The process includes use of a variable domain definition, a target number of experiments, and a way of testing whether or not a given experiment is valid according to a set of constraints, which may be referred to as a \u201ctester.\u201d","The process, in an embodiment, begins by performing a DoE, based at least in part on the variable domain and number of desired experiments. The process may then use the tester to test all of the proposed experiments for validity, noting those that are and are not valid in validity results. These validity results may be used to train a statistical model of the tester. That model can outperform the tester by several orders of magnitude. With a model, the model may be used to re-run the DoE, excluding any experiments that are invalid according to the model. The resulting experiments may be tested using the slower tester, and the model may be refined. This process may repeat until there are enough experiments and a model of the tester that meets an acceptable level of quality. This process, therefore, removes the need for the user to know all of the variable constraints in advance, results in a good DoE, and also produces a validity tester model that can be used for purposes other than DoE.","As discussed, techniques, including systems and methods, described herein, relate to automated processes that make few or no assumptions about a system's tunable parameters. The techniques can, therefore, be adapted to automatically suggest a configuration for best achievable performance for many different systems in many different states.  shows an illustrative example of a system  that may be used to implement the processes described and suggested herein. In an embodiment, the system  includes a plurality of components that each playa role in a process for suggesting configurations. Each of the components may be implemented various ways. In an embodiment, a computer system is configured with instructions that are executed by one or more processors, thereby causing each component to function according to its role in the process. In an embodiment, the system includes four components: a configuration selector , an application simulator , a model creator , and a model optimizer .  shows how information my flow among the components, in accordance with various embodiments.","Performance data for an application is obtained by observing the application during short representative runs (also called \u201csimulations\u201d) under different configurations and workloads. Each configuration and workload pair may require a representative run of the application, and each representative run of the application may be time-consuming. Accordingly, in an embodiment, the configuration selector  uses design of experiments (DoE) techniques to find a set of valid configurations to feed into an application simulator. In an embodiment, the configuration selector uses processes that are designed to find a minimal set of configurations that will produce the best possible performance model of the application.","Selecting the best small subset of valid configurations for simulating the application is generally a non-trivial task. It is desirable to select a subset of possible configurations that, when tested, will provide a representative set of performance data for the application. A DoE, in an embodiment, begins with a definition of an experimental domain that defines the space in which experiments will be performed. The experimental domain may be, for example, a set of all possible configurations for an application. DoE techniques may then be used to attempt to find a subset of experiments (aka points) that are distributed optimally throughout this space.  respectively show two distributions of points in a three-dimensional space, with the points in  being distributed better than the points shown in . Since the performance characteristics of what is being modeled are completely unknown, having an evenly distributed set of points is more likely to result in better data samples, and therefore, in a better model. Hence, given a configuration variable domain and a desired number of representative runs, the configuration selector , in an embodiment, uses DOE to find a quality set of valid configurations to feed the application simulator .","Enterprise and other applications can have many tunable parameters; furthermore, an enterprise application's tunable parameter values may be constrained by the values of other parameters. It follows that there can be many constraints between parameters. In an embodiment, the system  allows a user to specify at least some tunable parameters of an application by defining a variable domain. However, in many instances, it is unreasonable to have the user specify every constraint. Not only are there potentially a great many, these constraints are frequently unspecified and therefore unknown to users. Accordingly, in an embodiment, the configuration selector  is configured with the functionality to learn the variable constraints, as described below.","In an embodiment, a configuration selector  using a process  for selecting configurations is shown in . Some or all of the process  (or any other processes described herein, or variations and\/or combinations thereof) may be performed under the con) of one or more computer systems configured with executable instructions and may be implemented as code (e.g., executable instructions, one or more computer programs, or one or more applications) executing collectively on one or more processors, by hardware, or combinations thereof. The code may be stored on a computer-readable storage medium, for example, in the form of a computer program comprising a plurality of instructions executable by one or more processors. The computer-readable storage medium may be non-transitory.","In an embodiment, a configuration selector , such as in , comprises three components utilized in the process : a configuration validator , a classifier trainer , and a configuration generator . As with the system  described above, each of the components may be modules configured to perform various functions described herein. In an embodiment, the configuration validator  is configured to determine whether one or more configurations are valid. The configuration validator  may be application-dependent. Valid configurations may be passed to an application simulator , which may be an application simulator pictured in . The configuration validator  may check whether there are enough valid configurations before the configurations are passed on to the application simulator.","In an embodiment, if there are not enough valid configurations, then the classifier trainer  may be given the list of configurations along with a list of Boolean values that each indicate whether a corresponding configuration is valid. The classifier trainer  may take the data from the configuration validator and use that data to train a classifier. The classifier may be a module that, when trained, encodes the learned variable constraints which may then be passed to the configuration generator . In an embodiment, the classifier trainer  trains a multi-layer perceptron (MLP) or other artificial neural network (ANN), although many different types of classifiers can be used. Generally, the classifier may be any component that is configured to generate a model based at least in part on analysis of data.","The configuration generator  subcomponent, in an embodiment, generates a list of configurations which are valid with respect to the constraints encoded in the experimental domain and the learned constraints obtained from the classifier trainer. In an embodiment, the generated list of configurations is passed on to the configuration validator  and the process is repeated until one or more conditions on the list of configurations are satisfied. The conditions may, for example, relate to the number of configurations and\/or their distribution. For example, the process illustrated in  may repeat until a threshold number of configurations is achieved. The configuration generator  may generate configurations in a manner that achieves even distributions.","In an embodiment, the DoE techniques used by the configuration generator are independent from an underlying mathematical model of an application for which configurations are being generated. In an embodiment, the configuration generator  generates points utilizing a permutation particle swarm optimization (PSO) to determine an optimal Latin hypercube (OLH) DoE, as described in more detail below. In an embodiment, the permutation particle swarm optimization algorithm is to find solutions for the OLH DoE and to be compatible with the variable constraint learning that occurs in the system .","The application simulator , in an embodiment, simulates an application under various configurations and usage patterns while collecting performance data from these simulations. Since many simulations are being performed, in an embodiment, the simulations are short, representative runs of the application, although longer runs may be used when time and\/or resources permit. The application simulator may utilize various available tools to record performance data from the simulated applications. For example, Enterprise Manager from Oracle International Corporation may be used to write performance metrics into a database at regular intervals. Thus, performance data can be collected from Enterprise Manager (EM) and passed on to the model creator component. As another example, Oracle Application Testing Software (OATS) from Oracle International Corporation is a load-testing tool that can be used to run the application, simulate a configurable number of clients, and collect performance data from the simulations. Generally, the application simulator  may use any suitable tool for testing and measuring performance of applications and the application simulator my be programmed itself to perform such tasks.","Returning to , using the performance data gathered from the application simulator  component, the model creator , in an embodiment, creates a statistical model that predicts the application's performance for a given configuration and workload. A model may be a function that accepts configurations as input and outputs one or more performance characteristics of an application. A model may, for example, accept a configuration as input and output an estimate whether the application will start under the configuration. However, a model may be configured to have more complex outputs. For example, a model may output multiple values, each representing a different characteristic of an application's performance. In an embodiment, the model creator  creates the model using supervised learning with the application's configurations and workload as the model's input, and the performance data as sample output. There are many different methods and algorithms available for creating a statistical model of the application. In an embodiment, the performance characteristics are modeled by an MI-P. Feed-forward ANNs, such as MLPs, are useful for many applications since the have a single hidden layer and have been theoretically shown to be able to approximate any continuous function on an interval. While other machine learning techniques may be used and while other machine learning techniques may be more efficient, ANNs are versatile and capable of modeling complex multivariate functions and, therefore, are suitable for a wide range of applications.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 5","b":["500","500","500"]},"In an embodiment, the process  includes setting  an initial set of constraints. A constraint, in an embodiment, is a limit for a configurable parameter of an application. The limits may be actual limits. For example, if a certain value of an application parameter has a limited range of possible values, a constraint for the value may be a maximum or minimum value that the parameter may take. The limits may also be limits that are not actual limits. For instance, if a parameter may be set to zero, the constraint may be set to a value that is greater than zero.","Once the constraints are set , in an embodiment, a set of configurations for the system is generated . Generating the configurations may be done in various ways. In an embodiment, OLH DoE techniques are used to generate configurations within the constraints. Use of OLH DoE techniques allows for generation of a set of configurations with minimal size, which may be particularly useful when resources for testing configurations are limited. However, other techniques for generating configurations may be used. For example, a set of random configurations that are within the constraints may be generated. As yet another example, a configuration space may be partitioned and one or more configurations may be selected from each of the partitions in order to generate a set of configurations that is spatially distributed.","In an embodiment, when the configurations have been generated , the configurations are tested . Testing the configurations may be completed, for instance, operating (or attempting to operate) the system under each configuration. For example, if the system is a Java Virtual Machine (JVM) testing a configuration may include attempting to start the JVM under configuration. The configuration may be a set of configurable parameters for the NM. Example parameters are maximum heap size, minimum heap size, garbage collector type, parameters for a garbage collector type being tested, and the like. If the JVM starts, the configuration may be identified as valid. If the JVM does not start under the configuration, the configuration may be identified as invalid and subsequently disregarded.","In an embodiment, a determination is made  whether to update constraints and generate an updated set of configurations. The determination may be made in any suitable manner. For example, the determination may be made based at least in part on the number of configurations determined to be valid, characteristics of how configurations determined to be valid are distributed, and other considerations. In an embodiment, if it is determined not to update the constraints and generate an updated set of configurations, configurations determined to be valid are provided, such as to test the system under the configurations. If however, it is determined to update the constraints and generate an updated set of configurations, the constraints may be updated  and a new set of configurations within the updated constraints may be generated  and tested , such as described above. As noted, various machine learning techniques may be used to update constraints. For example, machine learning techniques may be used to identify constraints and\/or ranges of constraints that are invalid. Further, the techniques may identify subsets of constraints that are not valid. As an example, the value of one application parameter may affect possible values for another parameter. In this manner, the machine learning techniques may be used to efficiently update constraints to avoid testing configurations that are likely to be invalid. In this manner, a set of configurations may be obtained efficiently without users having to know the constraints for a system.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 6","b":["600","500","600","602","600","604","606"]},"In an embodiment, a determination is made  whether the configuration under which the system was tested is a valid configuration. If it is determined  that the configuration is a valid configuration, the configuration is recorded  as valid. If it is determined  that the configuration is not valid, the configuration may be recorded  as invalid. In an embodiment, once the validity of the configuration has been recorded, a determination is made  whether there are additional configurations to test. If there are additional configurations, the next configuration may be obtained  and used to test the system, as described above. This process may continue until a determination is made  that there are no additional configurations to test. At this point, the process  may include providing  an updated set of configurations. The updated set of configurations may be encoded in one or more electronic documents. The updated set of configurations may be used, for example, in a machine learning process in order to learn constraints of the system being tested, as described above.","Returning to , the model optimizer, in an embodiment, takes the model created by the model creator  component, and determines one or more configurations that produce optimal performance with respect to one or more user-specified objective functions. Optimal performance may be measured based at least in part on latency, throughput, calculations per time period, and, generally any characteristic of an application. Depending on the type of statistical model of the application's performance characteristics, there are many candidate optimization algorithms that may be used. Example suitable algorithms are PSO and GA (genetic algorithm). PSO and GA algorithms may be used to find an optimal set of inputs regardless of the type of model that is used. In an embodiment, the model optimizer is configured to monitor a running application's performance and compare the monitored performance to the predicted performance of one or more models that have been created in accordance with the various embodiments. If a model is found to be lacking for any reason, the process can be restarted, making the entire process iterative.","As noted, embodiments of the present disclosure may be used in connection with various applications. One example of an application that may be used in accordance with the various embodiments are Governance, Risk, and Compliance Controls (GRCC) applications available from Oracle International Corporation. In particular, the various embodiments described herein may be used to construct a GRCC decision support system (DSS) tool that utilizes a custom connector to extract data from a specified source, such as Enterprise Manager, and uses the data to optimize a performance model of an application. It should be noted that some, but not all components described may be used and that components other than those illustrated may be present. For instance, a DSS tool may be mapped to the model creator and model optimizer components that are described above. Data acquisition from sources such as OATS and EM, and the creation of the performance model may correspond to the model creator.","Using the performance model GRCC DSS tool, in an embodiment, gives users the option of making comparisons between predicted and observed values for an application's performance. For example, a first comparison between the application's observed performance and the application's performance as predicted by the model may be provided to a user. This allows the user to visualize how well the model will be able to predict the application's performance, assuming the application's behavior does not change. A next comparison may display the application's observed performance versus the predicted optimal performance. Such visualizations help users determine if a model needs to be retrained or if the application might need to be reconfigured.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 7","FIG. 7"],"b":["700","700"]},{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIGS. 8","FIGS. 8"],"i":["a ","b ","a ","b"],"b":["8","802","804","8"]},"In this example, the system selected 60 valid EGRCM configurations, and used OATS to simulate each of the 60 configurations six times for a total of 360 configurations. Since the parameters that were being tuned had to be set before startup, the EGRCM server had to be started up before and shut down after every OATS simulation. Web Logic Scripting Tool (WLST) was used to set the configurations, and start and stop EGRCM. The OATS simulation itself consisted of creating one-hundred virtual users, and having each of those virtual users log in to EGRCM, navigate through a couple of pages, and perform a search. Each user performed this sequence of actions five times. A model was trained using the performance data obtained from OATS. The performance data averaged server latency, measured in seconds, and throughput, measured in transaction per second, although, as noted above, performance measures could be any measure of a system's performance.","The configuration suggested by the Model Optimizer component was not one of the configurations that was simulated. As a result, the suggested configuration that was simulated was the configuration that was suggested by a model optimizer component for comparison to the default configuration (with no flags set). The results are shown in and . and demonstrate the improvement the suggested configuration has over the default configuration both in average latency and in throughput. While there is some overlap in the data, there is a marked improvement in the suggested configuration, as illustrated in the figures.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":["FIG. 9","FIG. 9"],"b":["900","900"]},"In an embodiment, the process  includes receiving  configurations for a system test. The configurations may have been generated in accordance with the above description or, generally, in any suitable manner. The received configurations, for example, may be a set of configurations that fits within a space of possible constraints that were learned in accordance with the above description. The received configurations may be used to simulate  the system under each of the configurations. Simulating the system may be performed in any suitable manner, and the manner in which the system is simulated may depend on specifics of the system itself. For example, as described above, a system may be simulated by creating virtual users for the system and causing the virtual users to interact with the system. One or more scripts may be utilized to create the users and\/or to cause the users to interact with the system. The script may, for example, utilize an application programming interface (API) of an application of the system to make API calls to the system on behalf of the virtual users. Generally, simulating the system may involve any type of operation of the system under any type of load.","In an embodiment, when the system is simulated , the performance of the system is measured . As discussed, measuring the system's performance while it is being simulated may include measuring one or more performance characteristics of the system. Performance characteristics may include latency, throughput, memory usage, processor usage, and, generally, any characteristic of the system's performance. Because of the complexity of systems being tested, simulating the system and measuring the system's performance may be performed several times to improve the accuracy of the measurements. In an embodiment, the system is simulated between six and ten times for each configuration, although the system may be simulated a different number of times, which may depend on the cost and resources available for simulating the system. When the system is simulated multiple times, measuring the performance of the system may include calculating statistical measurements of the system's performance, such as average values, median values, standard deviations, variances, and the like.","Once the performance of the system has been simulated and performance has been measured for the various configurations, in an embodiment, the results are used to create  a model of the system, where the model may be a function that takes a configuration as input and provides one or more values as output. The one or more output values may be estimates of system performance under an input configuration. Once a model has been generated, in an embodiment, the model may be used to generate one or more optimal configurations for a system. Generating an optimal configuration for a system may include determining one or more configurations that, when input into the model, result in a maximum, minimum, or other desirable value for some performance characteristic that the model represents. For example, the model may be used to find a configuration that results in minimum latency.","In addition, a model may be used to determine an optimal configuration for multiple outputs. As an example, a model may be used to determine a configuration that simultaneously optimizes both latency and throughput. To do this, a function that takes latency and throughput as values and outputs another value may be determined. The model that outputs both latency and throughput values may be used to find a maximum or minimum value of the function, depending on how the function is configured. Further, determining the optimal set of configurations may include setting one or more values of a configuration and determining the other values. A user, for instance, may specify an anticipated average workload on the system of a particular garbage collector, and, generally, any other parameters that, while configurable, a user prefers to have set in a particular way. In some embodiments, a user is able to specify multiple workloads and determining an optimal set of configurations may include determining configurations that are acceptable for some workloads while optimized for others. As one example, a user may expect a light workload on a system for normal operation and a high workload on the system at other times, such as at month end, quarter end, fiscal year end, and the like. The user may only require some minimal performance from the system during normal operation because of the light workload, but may require high throughput during the high-workload times. Accordingly, a model may be used to find one or more configurations that satisfy both the minimal condition at low workloads while being optimal at high workloads. In other words, users may be able to provide one or more conditions on a model's inputs and one or more conditions on a model's outputs and one or more configurations may be determined that both satisfy the conditions and optimize one or more outputs. Locating the optimal configuration may be accomplished by performing a heuristic search for an optimal configuration from a set of possible configurations and\/or using other techniques.","In an embodiment, once the optimal configuration(s) are determined, the one or more optimal configurations may be provided . As noted above, providing the one or more optimal configurations may be performed in any suitable manner, such as any manner that enables tuning of the system accordingly.","As with any process described and suggested herein, variations are considered as being within the scope of the present disclosure. For example, the process  may also include checking whether a configuration determined as optimal is valid. A system performing the process  may, for instance, test configuration validity before providing any configurations. The system performing the process may, for example, determine whether a configuration falls within constraints that have been learned, as described above, or constraints of which there is prior knowledge. The system may actually test the configuration, such as described above. If a configuration is determined to be invalid, another configuration may be determined in its place. This process may continue until a valid, optimal configuration is determined.","As noted above, various techniques may be used to determine a set of configurations for testing a system. As discussed, a configuration may be a set of values that may be set for a system (e.g., application). Further, because limited budgets and resources limit the number of configurations that can be tested, it is often desirable to determine a set of configurations for testing that is well distributed. In an embodiment, an Audze-Eglais Latin hypercube optimization process is used, as described more completely below.","In an embodiment, an optimal Latin hypercube DoE is determined for p and v, where p represents a number of experiments within an experimental domain, where an experimental domain (often called a design space) is defined as a domain of v variables. The value for p may be set, for example, based on the number of experiments budget and resources allow for. A Latin hypercube is an extension of a Latin square, where a Latin square is a p\u00d7p table filled with p different symbols such that each symbol occurs exactly once in each row and exactly once in each column. (Sudoku puzzles are Latin squares with an additional constraint.) A Latin hypercube, being an extension of a Latin square into more than 2 dimensions, i.e. the v variables in our domain, therefore is a hypercube of v dimensions, each having a cardinality of p (since there are p \u201csymbols\u201d). A Latin hypercube DoE is an arbitrary set of p points, where each point is represented by v-tuple. Furthermore, each point is within the bounds of an experimental domain of the v variables where, as noted, each point represents an experiment.","To spend our budget wisely (i.e. to test a system in a manner that is most likely to allow for determination of an optimal configuration given the constraints on the number of tests that can be done), in an embodiment, a search for an Optimal Latin Hypercube (OLH) forum experimental domain of v variables and p points is performed. The OLH, for a given p and v, may be a set of p v-tuples (points) such that the individual points are as evenly distributed as possible throughout the hypercube. As discussed below, DoE processes can use a variety of objective functions to distribute the points throughout an OLH, like maximizing entropy, a maximum of distance between points, minimized integrated mean square error, various heuristic methods, and an Audze-Egiais objective function that is based on potential energy.","The Audze-Eglais objective function, in an embodiment, treats each point as a unit of mass that exerts a repulsive force on its neighbors. The force is inversely proportional to the squared distance between the two points, if the hypercube is thought of as a container that can hold these units, and p units are inserted into the container, the units will repel one another and eventually reach an equilibrium in which the points are all as far apart as possible. This state is the lowest potential energy state. The location of each point in this state, in an embodiment, provides our design of experiments.","The equation used in the Audze-Eglais for p points may be:",{"@attributes":{"id":"p-0075","num":"0074"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["min","U"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":"min","mo":"\u2062","mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"p","mo":"=","mn":"1"},"mi":"P"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"munderover":{"mo":"\u2211","mrow":{"mi":"q","mo":"=","mrow":{"mi":"p","mo":"+","mn":"1"}},"mi":"P"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mfrac":{"mn":"1","msubsup":{"mi":["L","pq"],"mn":"2"}}}}}],"mo":"="}}},"br":{},"sub":"pq "},"For a given experimental domain, each possible set of experiments (DoE) can be evaluated using equation above. The DoE that has the minimal value, U, will have the most even distribution of points and is therefore favored.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 10","FIG. 10(A)","FIG. 10(B)","FIG. 10(C)"],"sub":["1 ","2 ","2 "]},"As discussed, particle swarm optimization (PSO) algorithms can be used in various embodiments. The PSO algorithm was inspired by biology as the algorithm simulates and interprets the social behavior of groups such as schools of fish and flocks of birds. In PSO, groups are called swarms and individuals are called particles. The PSO algorithm, in an embodiment, proceeds by searching for an optimal solution by generating a set of candidate solutions, called particles, which, taken as a group, comprise a swarm. The algorithm iteratively moves particles through the search space looking for a better solution. The movement of each particle is guided by the best position at which the particle has been (local best position) and the best position at which any particle in the swarm has been (global best position).","In standard formulations of the PSO algorithm, there may be a single swarm and each particle in the swarm has a position x and a velocity v, where both x and v are points in n-dimensional Euclidean space, R. These points are denoted by xand v, the position and velocity, respectively, at iteration t of the algorithm. Each particle may be initialized with a random position xand velocity v. The algorithm may proceed by iteratively updating each particle's position and velocity until a predefined termination condition has been met. Some examples of termination conditions include, but are not limited to, running the algorithm for a max number of iterations, or not finding a better solution for a given number of iterations.","At each iteration, time is incremented by one step. Therefore, a particle's position is updated by adding its current velocity to the position, so:\n\n\n\nAfter a particle's position has been updated, its velocity may be updated in the following manner:\n\n()+()\n\nwhere \u03b1 is the coefficient of inertia, cand care in the range (0,1], rand rare random numbers in [0,1), lis the local best position up to iteration t, and gis the global best position up to iteration t.\n","Once a particle has been updated for a given iteration, a check may be performed to see if its new position is now the local best position, and if the new best position is the new global best position. Before iterating again, the algorithm may check to see if any of the termination conditions have been reached, and if so, stops. While few assumptions of the underlying problem are made, the standard PSO algorithm does assume that the solution space is a continuous subset of R. Despite this limiting assumption, the PSO algorithm may be modified to deal with problems where the solution space contains discrete and\/or mixed (both discrete and continuous) values.","The problem of finding the OLH DoE requires finding a set of p points in the v-dimensional lattice of integers modulo p, Z. Not only does the PSO algorithm need to be modified to search Z, but it also has to account for the fact that not every set of p points in Zis a valid Latin hypercube. In fact, the sets of p points which are valid may satisfy the following condition: given an ordering of the p points, for i ranging from 0 to v\u22121, the icoordinates of the p points form a permutation of the integers modulo p. For example, for v=2 and p=3, the points (0,1), (1,0), and (2,2) form a valid LH. The permutation (0 1 2) is obtained by taking the set of the first coordinates of each point, white the permutation (1 0 2) is obtained by taking just the second coordinates. Accordingly, the problem of finding the OLE DoE is equivalent to finding the sequence of v permutations on the integers modulo p that minimizes the Audze-Eglais objective function. To search for the OLH DoE using the PSO algorithm, several modifications may need to be made to allow the algorithm to operate on this space of permutations. Embodiments of this modified version are referred to herein as a permutation PSO, permPSO.","PSO, in an embodiment, works by moving a set of particles by updating each particle's position by adding its position to its velocity. In this algorithm, a particle is represented by an array of v permutations on the integers modulo p. In order for the PSO algorithm to be applicable to this problem, two notions need to be defined for the set of permutations: 1) a metric, and 2) the concept of velocity. With these notions, a particle's velocity and position can be updated one permutation at a time.","Before defining a metric on the set of permutations, a transposition needs to be defined. A transposition is an operation which exchanges two elements and keeps all others fixed. For example, the transposition of 1 and 2 in the permutation (0 1 2) results in the permutation (0 2 1). For any two permutations, there is a minimal number of transpositions that will transform one permutation into the other. This, in an embodiment, serves as our distance metric, although other distance metrics may be used.","The notion of velocity is a bit more complex to define on the set of permutations. For the standard PSO with particles in R, velocity is defined as the change in position over the change in time. Since the algorithm treats one iteration as a single time unit, the only notion that needs to be defined for the set of permutations is the change in position by a given distance.","Defining direction is difficult for several reasons including the fact that there may be multiple ways to get from one permutation to another. Therefore, the permPSO algorithm, in an embodiment, replaces the notion of velocity from the PSO algorithm with the notion of moving toward another position. Since there is no notion of direction, we simply keep a transposition vector for each particle, denoted by s, by virtue of being somewhat analogous to \u201cspeed\u201d. The icomponent of the transposition vector denotes the number of transpositions that are applied to the ipermutation. The greater the \u201cspeed\u201d, the more transpositions.","For each iteration of the permPSO algorithm, and for each particle, the particle's transposition vector is updated, then the position is updated, and lastly, a check for updates to the best local and global positions is made. The update of the icomponent of the transposition vector at iteration t is given as follows:\n\n=Round(())\n\nwhere dis the coefficient of drag in (0, 1), cis the update coefficient in (0, 1], ris a randomly generated number in the range [0,1), sand sare the \u201cspeeds\u201d at iterations t and t\u22121, respectively, band is the ipermutation of the best position at iteration t. Whether it is the global best or the local best is decided randomly for each particle at each iteration. Note that since sdenotes the number of transpositions applied to the ipermutation, smust be an integer, and the sum on the right-hand side of the above equation is therefore rounded to the nearest integer value in this example. The position is then, in an embodiment, updated by moving the ipermutation by stranspositions towards b. If sgreater than the distance to b, then random transpositions may be applied, up to a total of s. In an embodiment, all dand cmay be set to 0.6 and 0.5, respectively.\n","Various systems may be utilized to implement the above algorithms. In an embodiment, the above algorithms are implemented using the Java programming language. The permGA algorithm, for example, may be implemented using a Watchmaker Framework for Evolutionary Computation. PermGA may be implemented using simple crossover instead of the inversion crossover, and changing the elitist size, for example, to 20%.  shows a table of results for an experiment that was performed comparing the above-described techniques. In particular, the population size for the permGA was set to 100 for the 2\u00d7120 and the 3\u00d7120, and 200 for the remaining problems. The permPSO algorithm that was used is much slower; so the number of particles in the swami for each problem was half of the population for the permGA.","As illustrated in , the results indicate that permPSO is a suitable alternative to the permGA algorithm in terms of finding a solution that minimizes the Audze-Elais potential. Even though the two algorithms produce similar quality solutions, the algorithms behave differently for different problem sizes. The permPSO algorithm was noted to tend to find a solution of fitness that is comparable to the best permGA solution in a number of fitness function evaluations that is one order of magnitude less, hut the larger the p value, the longer each iteration takes.","In an embodiment, when formulating an OLH DoE, every set of values that can be assigned to a variable is finite and discrete, and the values are required to be equally spaced. This means that in the definition of the experiment domain, variables that take on real number values must have the set of possible values restricted by only selecting numbers that are a fixed interval apart and belong to abounded subset of the real numbers. Also, as formulated, the OLH DoE problem requires selecting p experiments, and each variable to have a cardinality of p, but this may be too limiting. It is unlikely that every parameter will have the same number of values, and that the number of values is equal to the number of experiments desired. For these reasons, the generalized OLH DoE, in an embodiment, allows each variable to have its own cardinality, while p still denotes the number of experiments. To minimize the number of repeated values for each variable, the restriction that the number of repeated values does not exceed the ceil(c\/p), where ceil(x) is the ceiling function mapping a real number x to the smallest integer greater than or equal to x, may be imposed. For example, if variable i has cardinality 3 and p=5, then the number of repeated values for variable i cannot exceed ceil(3\/5)=2. Thus, (0 0 1 2 2) is a valid permutation of values, while (0 1 2 2 2) is not since there are three values of 2.","Since the generalized OLH DoE allows for values to be repeated in a permutation, and since the values are not repeated the same number of times if c\/p is not an integer, the permPSO algorithm has to consider different sets of values in addition to permutations of these values. To do so, the definition of distance needs to be redefined. Before doing so, a valid value replacement needs to be defined. A value replacement is the action of replacing a value in the set of values being permuted with another value. A value replacement is valid when the resulting set of values does not repeat any value more than ceil(c\/p) times. Again, suppose variable i has cardinality 3 and p=5; then replacing 0 with 1 in the permutation (0 0 1 2 2) results in (0 1 1 2 2). This is a valid value replacement since no value is repeated more than twice. Now, for two permutations \u03c3and \u03c3, d(\u03c3, \u03c3) is the minimal number of valid value replacements and transpositions required to transform \u03c3into \u03c3.","For a given software system, it may be the case that variables are not independent. For instance, the values that can be assigned to a variable may be constrained by the value assigned to another. For example, one parameter, m, may specify the minimum size of some resource and another parameter, M, its maximum size. These two parameters would not be independent since a value assigned to one constrains the value assigned to the other. In other words, in some instances the value of m must be greater than (or equal to) the value M. The OLH DoE methodology generally does not account for such constraints, and in order for the OLH DoE methodology to not have to account for variable constraints, in an embodiment, the experiment domain is transformed.","The experiment domain may be transformed by grouping dependent variables together. That is, variables that constrain each other are grouped into the same set. These sets of variables, in an embodiment, are replaced by a single variable in the transformed domain. This single variable enumerates all the valid combinations of values for the variables associated with this new variable. Each value for the new variable maps to a valid assignment of the variables in the original experiment domain. Variables that do not constrain and are not constrained by any variables are left unchanged in the transformed domain. For example, suppose we have three variables v, v, and v. Variable vcan take on a value from {1, 2, 3}, va value from {2, 4}, and va value from {0, 1}. Also, suppose that vmust be strictly less than the value of v. Then in the transformed domain, variables vand vmap to a single variable, u, and vmaps to the variable uwhich is identical to vsince the value assigned to vdoes not constrain vor v2. Variable u1 in the transformed domain has a set of four values, each one mapping to one of the following four assignments vand v: (1, 2), (1, 4), (2, 4), (3, 4), where the first value is the assignment for vand the second for v.","While this mapping, in an embodiment, guarantees that every LH is a valid assignment, it may not be an isometry (distance-preserving map). Since the Audze-Eglais objective function is based on distance, this may be an issue which may be addressed by abstracting into the permPSO algorithm's fitness function, where a particle's position is transformed back into a position in the original experiment domain before passing it to the Audze-Eglais objective function.","For experiment domains with many variables, there may be many complex constraints, making it unreasonable to describe and manually encode these constraints. Thus, in an embodiment, an algorithm that can learn inter-variable constraints by training a classifier with a set of valid\/invalid variable assignments is used. A trained classifier, such as described above, may encode the inter-variable constraints that determine whether a configuration is valid or not. In an embodiment, the constraints are extracted from the classifier and used to create a transformed experiment domain of the type described above. For many classifiers, such as Artificial Neural Networks (ANN), extracting learned constrains is far from trivial; thus an alternative method of incorporating these learned constraints into the permPSO algorithm may be used. As with the issue with the experiment domain mapping not being an isometry that was abstracted into the permPSO fitness function, the issue of not being able to extract the learned constraints from a classifier can also be abstracted away into the permPSO fitness function. In this case, it may be done by actually passing the trained classifier into the fitness function, and giving experiments containing invalid value assignments a highly unfavorable fitness value. While not as effective in all instances, this may lead the algorithm away from experiments containing invalid value assignments.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIG. 12","FIG. 12","FIG. 12"],"b":["1200","1200","1202","1220","1200","1202","1204","1206","1208","1210","1212","1214","1216"]},"Bus subsystem  provides a mechanism for letting the various components and subsystems of computer system  communicate with each other as intended. Although bus subsystem  is shown schematically as a single bus, alternative embodiments of the bus subsystem may utilize multiple busses.","Network interface subsystem  provides an interface to other computer systems, networks, and portals. Network interface subsystem  serves as an interface for receiving data from and transmitting data to other systems from computer system .","User interface input devices  may include a keyboard, pointing devices such as a mouse, trackball, touchpad, or graphics tablet, a scanner, a barcode scanner, a touch screen incorporated into the display, audio input devices such as voice recognition systems, microphones, and other types of input devices. In general, use of the term \u201cinput device\u201d is intended to include all possible types of devices and mechanisms for inputting information to computer system . A user may use an input device to provide to configure systems that perform the various methods described herein and to otherwise work with such systems.","User interface output devices  may include a display subsystem, a printer, a fax machine, or non-visual displays such as audio output devices, etc. The display subsystem may be a cathode ray tube (CRT), a flat-panel device such as a liquid crystal display (LCD), or a projection device. In general, use of the term \u201coutput device\u201d is intended to include all possible types of devices and mechanisms for outputting information from computer system . Results of system tests, such as outputs from a DSS may be displayed on an output device.","Storage subsystem  provides a computer-readable medium for storing the basic programming and data constructs that provide the functionality of the present invention. Software (programs, code modules, instructions) that when executed by a processor provide the functionality of the present invention may be stored in storage subsystem . These software modules or instructions may be executed by processor(s) . Storage subsystem  may also provide a repository for storing data used in accordance with the present invention, for example, the data stored in the diagnostic data repository. For example, storage subsystem  provides a storage medium for persisting one or more ontologies. Storage subsystem  may comprise memory subsystem  and foe\/disk storage subsystem .","Memory subsystem  may include a number of memories including a main random access memory (RAM)  for storage of instructions and data during program execution and a read-only memory (ROM)  in which fixed instructions are stored. File storage subsystem  provides persistent (non-volatile) storage for program and data files, and may include a hard disk drive, a floppy disk drive along with associated removable media, a Compact Disk Read-Only Memory (CD-ROM) drive, an optical drive, removable media cartridges, and other like storage media.","Computer system  can be of various types including a personal computer, a portable computer, a workstation, a network computer, a mainframe, a kiosk, a server or any other data processing system. Due to the ever-changing nature of computers and networks, the description of computer system  depicted in  is intended only as a specific example for purposes of illustrating the preferred embodiment of the computer system. Many other configurations having more or fewer components than the system depicted in  are possible.","Other variations are within the spirit of the present invention. Thus, while the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific form or forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention, as defined in the appended claims.","The use of the terms \u201ca\u201d and \u201can\u201d and \u201cthe\u201d and similar referents in the context of describing the invention (especially in the context of the following claims) are to be construed to cover both the singular and the plural, unless otherwise indicated herein or clearly contradicted by context. The terms \u201ccomprising,\u201d \u201chaving,\u201d \u201cincluding,\u201d and \u201ccontaining\u201d are to be construed as open-ended terms (i.e., meaning \u201cincluding, but not limited to,\u201d) unless otherwise noted. The term \u201cconnected\u201d is to be construed as partly or wholly contained within, attached to, or joined together, even if there is something intervening. Recitation of ranges of values herein are merely intended to serve as a shorthand method of referring individually to each separate value falling within the range, unless otherwise indicated herein, and each separate value is incorporated into the specification as if it were individually recited herein. All methods described herein can be performed in any suitable order unless otherwise indicated herein or otherwise clearly contradicted by context. The use of any and all examples, or exemplary language (e.g., \u201csuch as\u201d) provided herein, is intended merely to better illuminate embodiments of the invention and does not pose a limitation on the scope of the invention unless otherwise claimed. No language in the specification should be construed as indicating any non-claimed element as essential to the practice of the invention.","Preferred embodiments of this invention are described herein, including the best mode known to the inventors for carrying out the invention. Variations of those preferred embodiments may become apparent to those of ordinary skill in the art upon reading the foregoing description. The inventors expect skilled artisans to employ such variations as appropriate, and the inventors intend for the invention to be practiced otherwise than as specifically described herein. Accordingly, this invention includes all modifications and equivalents of the subject matter recited in the claims appended hereto as permitted by applicable law. Moreover, any combination of the above-described elements in all possible variations thereof is encompassed by the invention unless otherwise indicated herein or otherwise clearly contradicted by context.","Although specific embodiments of the invention have been described, various modifications, alterations, alternative constructions, and equivalents are also encompassed within the scope of the invention. Embodiments of the present invention are not restricted to operation within certain specific data processing environments, but are free to operate within a plurality of data processing environments. Additionally, although embodiments of the present invention have been described using a particular series of transactions and steps, it should be apparent to those skilled in the art that the scope of the present invention is not limited to the described series of transactions and steps.","Further, while embodiments of the present invention have been described using a particular combination of hardware and software, it should be recognized that other combinations of hardware and software are also within the scope of the present invention. Embodiments of the present invention may be implemented only in hardware, or only in software, or using combinations thereof.","The specification and drawings are, accordingly, to be regarded in an illustrative rather than a restrictive sense. It will, however, be evident that additions, subtractions, deletions, and other modifications and changes may be made thereunto without departing from the broader spirit and scope as set forth in the claims.","All references, including publications, patent applications, and patents, cited herein are hereby incorporated by reference to the same extent as if each reference were individually and specifically indicated to be incorporated by reference and were set forth in its entirety herein."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 4","FIG. 1"]},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIGS. 8","i":["a ","b "],"b":"8"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 10(A)"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 10(B)"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 10(C)"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
