---
title: Systems and methods to scan memory for a threat
abstract: A computer-implemented method to scan memory for a threat is described. At least one application programming interface (API) is monitored. A back-trace operation is performed from the at least one API to identify a process that called the at least one API. An address in memory is retrieved for the identified process. At least a portion of the memory associated with the address of the identified process is scanned. A signature based on the scanned portion of the memory is generated.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08874925&OS=08874925&RS=08874925
owner: Symantec Corporation
number: 08874925
owner_city: Mountain View
owner_country: US
publication_date: 20110721
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS"],"p":["The use of computer systems and computer-related technologies continues to increase at a rapid pace. This increased use of computer systems has influenced the advances made to computer-related technologies. Indeed, computer systems have increasingly become an integral part of the business world and the activities of individual consumers. Computer systems may be used to carry out several business, industry, and academic endeavors. The wide-spread use of computers has been accelerated by the increased use of computer networks, including the Internet.","Many businesses use one or more computer networks to communicate and share data between the various computers connected to the networks. The productivity and efficiency of employees often require human and computer interaction. Users of computer technologies continue to demand an increase in the efficiency of these technologies. Improving the efficiency of computer technologies is always desirable to anyone who uses and relies on computers.","Various threats may be harmful to computers. These threats may include malware, shellcode, viruses, worms, and the like. Threats to computers are a problem in modern day computing. For example, a computer threat may be a program that may attach to other programs and\/or objects, may replicate itself, and\/or may perform unsolicited or malicious actions on a computer. Computer threats may cause unrecoverable errors, delete files, create intermittent problems and otherwise cause individuals and businesses much frustration and other damage. Attacks on computers carried out by these threats seek to exploit vulnerabilities in computers.","Threats may enter a computer system in a number of ways. For example, a threat may be knowingly downloaded to a computer, such as where the undesired malicious effect is not known or appreciated at the time of downloading the threat. Further, a threat may tag along with other threats that are downloaded to the computer. Still further, the threat may enter the computer system unknown to the computer user. These threats have effects on the computer that may be unknown to the user and\/or undesired by the user.","According to at least one embodiment, a computer-implemented method to scan memory for a threat is described. At least one application programming interface (API) is monitored. A back-trace operation is performed from the at least one API to identify a process that called the at least one API. An address in memory is retrieved for the identified process. At least one signature is retrieved from a database. At least a portion of the memory associated with the address of the identified process is scanned. Upon determining that the scanned memory matches the at least one retrieved signature, the execution of the identified process is blocked. Upon determining that the scanned memory does not match the at least one retrieved signature, a signature based on the scanned portion of the memory is generated.","In one embodiment, the generated signature identifies the threat. In one configuration, the threat may be decrypted shellcode stored in memory. In one example, the threat may be unpacked malware stored in memory. In one embodiment, a first set of rules associated with the at least one API may be created. In one configuration, a second set of rules associated with a process used by the threat may be created.","A predetermined size of memory to scan may be set based on the location of the address of the identified process. In one configuration, a search may be performed for predetermined operational code in the memory from the location of the address of the identified process.","In one embodiment, the generated signature may be transmitted to a server. The server may store the generated signature in a database.","A computing device configured to scan memory for a threat is also described. The computing device may include a processor and memory in electronic communication with the processor. The computing device may also include a detection module configured to monitor at least one application programming interface (API) and perform a back-trace operation from the at least one API to identify a process that called the at least one API. The detection module may also be configured to retrieve an address in memory for the identified process and at least one signature from a database. The module may be further configured to scan at least a portion of the memory associated with the address of the identified process Upon determining that the scanned memory matches the at least one retrieved signature, the detection module may be configured to block the execution of the identified process. Upon determining that the scanned memory does not match the at least one retrieved signature, the detection module may be further configured to generate a signature based on the scanned portion of the memory.","A computer-program product to scan memory for a threat is also described. The computer-program product may include a non-transitory computer-readable medium having instructions thereon. The instructions may include code programmed to monitor at least one application programming interface (API) and code programmed to perform a back-trace operation from the at least one API to identify a process that called the at least one API. The instructions may also include code programmed to retrieve an address in memory for the identified process and also retrieve at least one signature from a database. The instructions may further include code programmed to scan at least a portion of the memory associated with the address of the identified process. Upon determining that the scanned memory matches the at least one retrieved signature, the instructions may include code programmed to block the execution of the identified process. Further, upon determining that the scanned memory does not match the at least one retrieved signature, the instructions may include code programmed to generate a signature based on the scanned portion of the memory.","Features from any of the above-mentioned embodiments may be used in combination with one another in accordance with the general principles described herein. These and other embodiments, features, and advantages will be more fully understood upon reading the following detailed description in conjunction with the accompanying drawings and claims.","While the embodiments described herein are susceptible to various modifications and alternative forms, specific embodiments have been shown by way of example in the drawings and will be described in detail herein. However, the exemplary embodiments described herein are not intended to be limited to the particular forms disclosed. Rather, the instant disclosure covers all modifications, equivalents, and alternatives falling within the scope of the appended claims.","A threat to a computing system may be used to cause harm to the system. A threat may include malicious software, also known as malware. In one configuration, malware may be software that is included or inserted in a part of a computing system or computing systems for a harmful purpose. The term threat may include possible, potential, and actual threats. Types of malware may include, but are not limited to, malicious libraries, viruses, worms, trojans, adware, malicious active content, and denial of service attacks.","In one example, a threat may also include shellcode. Shellcode may include a small piece of code used as the payload in the exploitation of a software vulnerability. Shellcode may begin executing by starting a command shell from which an attacker can control the compromised computing system. Shellcode may either be local or remote, depending on whether it gives the attacker control over the system it runs on (local) or over another system through a network (remote).","Local shellcode may be used by an attacker who has limited access to a system, but can exploit a vulnerability in a higher-privileged process on that system. If successfully executed, the shellcode may provide the attacker access to the system with the same higher privileges as the targeted process.","Remote shellcode may be used when an attacker desires to target a vulnerable process running on another system on a local network or intranet. If successfully executed, the shellcode may provide the attacker access to the target system across the network.","In one example, processes may filter or restrict the data that can be injected into the processes. In addition, anti-malware programs may exist to detect and combat malware. Developers, however, of malware and shellcode may use different packers or encryption techniques to make the threat hard to detect or to analyse. For example, with shellcodes, the encryption may prevent readable strings within the shellcode such as Uniform Resource Locators (URLs), Application Programming Interface (API) names, and the like from being visible in raw form.","Developers of anti-virus and anti-malware programs may generate a signature to identify a detected threat. These signatures, however, may be generated using emulation techniques or decryption techniques to detect the threat. A disadvantage of the emulation technique is that not all packers of threats may be capable of being emulated.","Signatures for threats may also be generated based on a packed and encrypted file. In addition, signatures may be generated based on how the threat was packed. In these cases, the signatures based on the packer and encryption techniques are usually limited. For example, shellcode includes small pieces of code and different decrypted shellcodes may be similar with one of the only differences being how these different shellcodes are encrypted.","In one configuration, the present systems and methods may perform a scan on decrypted shellcode without using emulation to prevent an attack and generate a signature for the decrypted shellcode that could be used to identify future threats. The present systems and methods may also be applied to malware to detect the unpacked form of the code and generate a signature for the unpacked form of the code that may be used to detect malicious code and functions that are being reused by developers of malware.","In one embodiment, the present systems and methods may scan an unpacked and decrypted sample from the memory of a computing system. Using a set of API rules, a back-trace operation may be performed to identify a caller of an API function. A range of memory from the caller code may be set for scanning. A shellcode signature may be generated from a decrypted form of shellcode and a malware signature may be generated from an unpacked form of a suspicious file. These signatures may be used to identify and prevent future threats.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1","b":["100","102","110","108","102","108","110","112","112","110","110","102","112"]},"In one example, the client device  may include a detection module  and memory . The detection module  may detect and identify a threat that may be present on the client device . Further, the detection module  may detect and identify a potential threat attempting to compromise the client device . In one configuration, the threat may be stored in the memory . The detection module  may scan some or all of the memory  to detect and identify the threat. For example, the threat may be packed or encrypted. The threat may be unpacked or decrypted and stored in the memory . The detection module  may detect and identify the unpacked or decrypted threat by scanning the memory . Details regarding the detection module  will be described below.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 2","b":["204","204","214","214","216","218","220","222","224","226","228"]},"The monitoring module  may monitor at least one API. For example, the monitoring module  may monitor APIs that are commonly used by shellcode to execute an attack on a computing device. Examples of APIs that the monitoring module  may monitor may include, but are not limited to, LoadLibraryA, GetProcAccress, URLDownloadToFile, and the like. The API rule creation module  may create a first set of at least one rule regarding the APIs being monitored by the monitoring module . For example, the API rule creation module  may create a rule that is satisfied if LoadLibraryA and GetProcAddress are called. Another example of a satisfied rule may include when an executable is downloaded using an API (e.g., URLDownloadToFile) monitored by the monitoring module .","In one configuration, the process filter rule creation module  may create a second set of at least one rule regarding one or more processes that are usually initiated by shellcode during an attack. For example, a rule may be satisfied if at least one of iexplorer.exe, java.exe, firefox.exe, adobe.exe, etc. is executed. The termination module  may terminate or prevent an API function and\/or a process from executing if one or more rules from the first set of rules and\/or the second set of rules are satisfied. As a result, the API rules or the process filter rules may act as a choke point to prevent a shellcode attack from continuing to occur when at least one of these rules is satisfied.","The back-tracing module  may perform a back-tracing operation in the memory  of the client device  and in the hooked API call to determine the process that called the hooked API (e.g., URLDownloadToFile). The back-tracking module  may retrieve an address in memory of the process that called the API. With the memory address of the process that called the API, a certain size of the memory  from the memory address may be determined. In addition, a search for a certain code (as opcode) from the memory address of the process that called the API may be conducted. For example, the memory may be scanned for one or more signatures retrieved from a database of signatures of known threats and exploits.","The scanning module  may conduct a scan of the memory  from either of these determined memory locations to determine if the one or more signatures retrieved from the database matches a signature stored in memory. As a result, the scanning module  may scan the area of the memory  that stores decrypted shellcode. In one configuration, the scanning module  may use any type of scanning engine such as, but not limited to, an anti-virus scan engine or a separate scan engine. Before the scanning module  conducts the scan of the memory, additional rules regarding the characteristics of the shellcode may be applied. For example, a rule may be applied that includes checking whether the address of the process that called the API is in heap memory, stack memory, and the like. If the scanning module  identifies a signature stored in memory that matches the one or more signatures retrieved from the database, the termination module  may terminate or block the process from executing.","If, however, the scanning module  does not identify a signature in memory that matches the one or more retrieved signatures, the signature generating module  may generate a signature based on the scanned data in the memory . The signature generating module  may generate a signature if certain conditions are satisfied. For example, the signature generating module  may generate a signature if the source of the memory (e.g., file or URL) is determined to be suspicious. The source of the memory may be found to be suspicious based on reputation data received from reputation services. The signature generating module  may also generate a signature if the process in memory calls APIs that are commonly used by exploits or threats.","A signature may be generated to identify decrypted shellcode that attempted to initiate an attack on the client device . The generated signature may be transmitted to the back-end server  across the network . The signature may be stored in the database  and retransmitted to additional client devices to prevent attacks by the shellcode identified by the signature.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 3","b":["304","304","330","330","316","332","322","324","326","328"]},"The monitoring module  may monitor at least one API. For example, the monitoring module  may monitor APIs that are commonly used by malware to execute an attack on a computing device. Examples of APIs that the monitoring module  may monitor may include, but are not limited to, CreateMutex, CreateRemoteThread, WriteFile, and the like. The file filter  may determine whether a file calling the monitored APIs is suspicious. Using the file filter  may reduce false positives and performance issues. In one embodiment, the file filter  may verify the reputation of the file stored in the cloud. In addition, the file filter  may check a cache of previously scanned files to determine whether the file has already been scanned. The termination module  may terminate or prevent an API function and\/or a process from executing if the file filter  determines the file is suspicious.","The back-tracing module  may perform a back-tracing operation in the memory  of the client device  to identify the process that called a particular API. In addition, the back-tracing module  may perform a back-tracing operation of a hooked API call to determine the process that called the API (e.g., CreateMutex). The back-tracking module  may retrieve an address in memory of the process that called the API. With the memory address of the process that called the API, a certain size of the memory  from the memory address may be determined. In addition, a search for a certain code (as opcode) from the memory address of the process that called the API may be conducted. In one configuration, the memory may be scanned for one or more signatures previously retrieved from a database.","The scanning module  may conduct a scan of the memory  from either of these determined memory locations to determine is a match of the retrieved signatures exists in the memory. As a result, the scanning module  may scan the area of the memory  that stores unpacked malware. In one configuration, the scanning module  may use any type of scanning engine such as, but not limited to, an anti-virus scan engine or a separate scan engine. Before the scanning module  conducts the scan of the memory, additional rules regarding the characteristics of the malware may be applied.","In one embodiment, if no matching signature is found in the scanned memory, the signature generating module  may generate a signature based on the scanned data in the memory . As a result, a signature may be generated to identify unpacked malware that attempted to initiate an attack on the client device . The generated signature may be transmitted to the back-end server  across the network . The signature may be stored in the database  and retransmitted to additional client devices to prevent attacks by the malware identified by the signature.","In one example, if a matching signature if identified in the memory during the scan of the memory, the process may be blocked or terminated. In one embodiment, the termination module  may block or terminate the process, which may be considered to be an exploit or threat.",{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 4","b":["400","102","400","104"]},"In one example, at least one API may be monitored . A back-trace operation may be performed  to identify a caller of the API. An address in memory for the identified caller of the API may be retrieved . In addition, at least one signature may be retrieved  from a database. In one configuration, at least a portion of the memory associated with the address of the identified caller may be scanned . A determination  may be made as to whether the scanned memory matches the at least one retrieved signature. If it is determined  that the scanned memory matches the signature, the execution of the identified caller may be blocked  or terminated. If, however, it is determined  that the memory does not match the signature, a signature may be generated  based on the scanned portion of the memory. As a result, a scan of the memory may allow a scan of an unpacked\/decrypted threat to occur. The generated signature may represent the threat in an unpacked\/decrypted form.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 5","b":["500","102","500","214"]},"In one embodiment, at least one API may be monitored . A first set of rules regarding the at least one monitored API may be created . Further, a second set of rules regarding at least one process used by shellcode may be created . In one example, a determination  may be made as to whether the first set of rules and the second set of rules have been satisfied. If it is determined  that the first and second sets of rules have not been satisfied, the method  may return to continue to determine  whether the sets of rules have been satisfied. If, however, it is determined  that the first set of rules and the second set of rules have been satisfied, a back-trace operation may be performed  to identify a caller of the API. An address in memory may be retrieved  for the identified caller. In one configuration, at least a portion of the memory associated with the address of the identified caller may be scanned . In addition, a signature for the shellcode may be generated  based on the scanned portion of the memory. As a result, a scan of the memory may allow a scan of the decrypted shellcode to occur. The generated signature may represent the shellcode in a decrypted form.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 6","b":["600","102","600","330"]},"In one example, at least one API may be monitored . A file associated with the at least one monitored API may be analyzed . A determination  may be made as to whether the analyzed file is suspicious. If it is determined  that the analyzed file is not suspicious, the method  may return to monitor  at least one API. If, however, it is determined that the analyzed file is suspicious, a back-trace operation may be performed  to identify a caller of the API. In one embodiment, an address in memory for he identified caller may be retrieved . At least a portion of the memory associated with the address of the identified caller may be scanned . In one configuration, a signature for the file may be generated  based on the scanned portion of the memory. As a result, a scan of the memory may allow a scan of unpacked malware to occur. The generated signature may represent the malware in unpacked form.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 7","b":["710","710","712","710","714","717","718","720","722","724","726","728","730","732","733","792","791","734","737","738","735","790","735","739","740","742","746","712","728","747","712","730","748","712"]},"Bus  allows data communication between central processor  and system memory , which may include read-only memory (ROM) or flash memory (neither shown), and random access memory (RAM) (not shown), as previously noted. The RAM is generally the main memory into which the operating system and application programs are loaded. The ROM or flash memory can contain, among other code, the Basic Input-Output system (BIOS) which controls basic hardware operation such as the interaction with peripheral components or devices. For example, the detection module  to implement the present systems and methods may be stored within the system memory . Applications resident with computer system  are generally stored on and accessed via a non-transitory computer readable medium, such as a hard disk drive (e.g., fixed disk ), an optical drive (e.g., optical drive ), a floppy disk unit , or other storage medium. Additionally, applications can be in the form of electronic signals modulated in accordance with the application and data communication technology when accessed via network modem  or interface .","Storage interface , as with the other storage interfaces of computer system , can connect to a standard computer readable medium for storage and\/or retrieval of information, such as a fixed disk drive . Fixed disk drive  may be a part of computer system  or may be separate and accessed through other interface systems. Modem  may provide a direct connection to a remote server via a telephone link or to the Internet via an internet service provider (ISP). Network interface  may provide a direct connection to a remote server via a direct network link to the Internet via a POP (point of presence). Network interface  may provide such connection using wireless techniques, including digital cellular telephone connection, Cellular Digital Packet Data (CDPD) connection, digital satellite data connection or the like.","Many other devices or subsystems (not shown) may be connected in a similar manner (e.g., document scanners, digital cameras and so on). Conversely, all of the devices shown in  need not be present to practice the present systems and methods. The devices and subsystems can be interconnected in different ways from that shown in . The operation of a computer system such as that shown in  is readily known in the art and is not discussed in detail in this application. Code to implement the present disclosure can be stored in a non-transitory computer-readable medium such as one or more of system memory , fixed disk , optical disk , or floppy disk . The operating system provided on computer system  may be MS-DOS\u00ae, MS-WINDOWS\u00ae, OS\/2\u00ae, UNIX\u00ae, Linux\u00ae, or another known operating system.","Moreover, regarding the signals described herein, those skilled in the art will recognize that a signal can be directly transmitted from a first block to a second block, or a signal can be modified (e.g., amplified, attenuated, delayed, latched, buffered, inverted, filtered, or otherwise modified) between the blocks. Although the signals of the above described embodiment are characterized as transmitted from one block to the next, other embodiments of the present systems and methods may include modified signals in place of such directly transmitted signals as long as the informational and\/or functional aspect of the signal is transmitted between blocks. To some extent, a signal input at a second block can be conceptualized as a second signal derived from a first signal output from a first block due to physical limitations of the circuitry involved (e.g., there will inevitably be some attenuation and delay). Therefore, as used herein, a second signal derived from a first signal includes the first signal or any modifications to the first signal, whether due to circuit limitations or due to passage through other circuit elements which do not change the informational and\/or final functional aspect of the first signal.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 8","b":["800","810","820","830","840","840","810","850","104","840","840","840","860","1","840","860","1","870","880","1","840","840","810","820","830","850","890","870"]},"With reference to computer system , modem , network interface  or some other method can be used to provide connectivity from each of client computer systems , , and  to network . Client systems , , and  are able to access information on storage server A or B using, for example, a web browser or other client software (not shown). Such a client allows client systems , , and  to access data hosted by storage server A or B or one of storage devices A()-(N), B()-(N), ()-(N) or intelligent storage array .  depicts the use of a network such as the Internet for exchanging data, but the present systems and methods are not limited to the Internet or any particular network-based environment.","While the foregoing disclosure sets forth various embodiments using specific block diagrams, flowcharts, and examples, each block diagram component, flowchart step, operation, and\/or component described and\/or illustrated herein may be implemented, individually and\/or collectively, using a wide range of hardware, software, or firmware (or any combination thereof) configurations. In addition, any disclosure of components contained within other components should be considered exemplary in nature since many other architectures can be implemented to achieve the same functionality.","The process parameters and sequence of steps described and\/or illustrated herein are given by way of example only and can be varied as desired. For example, while the steps illustrated and\/or described herein may be shown or discussed in a particular order, these steps do not necessarily need to be performed in the order illustrated or discussed. The various exemplary methods described and\/or illustrated herein may also omit one or more of the steps described or illustrated herein or include additional steps in addition to those disclosed.","Furthermore, while various embodiments have been described and\/or illustrated herein in the context of fully functional computing systems, one or more of these exemplary embodiments may be distributed as a program product in a variety of forms, regardless of the particular type of computer-readable media used to actually carry out the distribution. The embodiments disclosed herein may also be implemented using software modules that perform certain tasks. These software modules may include script, batch, or other executable files that may be stored on a computer-readable storage medium or in a computing system. In some embodiments, these software modules may configure a computing system to perform one or more of the exemplary embodiments disclosed herein.","The foregoing description, for purpose of explanation, has been described with reference to specific embodiments. However, the illustrative discussions above are not intended to be exhaustive or to limit the invention to the precise forms disclosed. Many modifications and variations are possible in view of the above teachings. The embodiments were chosen and described in order to best explain the principles of the present systems and methods and their practical applications, to thereby enable others skilled in the art to best utilize the present systems and methods and various embodiments with various modifications as may be suited to the particular use contemplated.","Unless otherwise noted, the terms \u201ca\u201d or \u201can,\u201d as used in the specification and claims, are to be construed as meaning \u201cat least one of\u201d In addition, for ease of use, the words \u201cincluding\u201d and \u201chaving,\u201d as used in the specification and claims, are interchangeable with and have the same meaning as the word \u201ccomprising.\u201d"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings illustrate a number of exemplary embodiments and are a part of the specification. Together with the following description, these drawings demonstrate and explain various principles of the instant disclosure.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
