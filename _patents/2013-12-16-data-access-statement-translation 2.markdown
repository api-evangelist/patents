---
title: Data access statement translation
abstract: Techniques are described for dynamic translation of data access statements. A first set of statements is sent by an executing process to access a first data storage that supports a first query language. The first set of statements is intercepted and translated into a second set of statements configured to access a second data storage that supports a second query language. The second set of statements may be executed on the second data storage, and the result data set may be sent to the executing process that generated the first set of statements. The first and second storages may employ different data storage formats, such as relational and non-relational storage formats. The behavior of the executing process may be monitored to determine the feasibility of modifying the source code of the process to employ a different query language.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09535948&OS=09535948&RS=09535948
owner: Amazon Technologies, Inc.
number: 09535948
owner_city: Reno
owner_country: US
publication_date: 20131216
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","DETAILED DESCRIPTION"],"p":["Applications, libraries, and other types of software modules may include hard-coded statements written in a particular query language to access data stored on a particular type of data storage device. In some cases, an organization that operates or maintains the software modules may migrate data from one type of data storage device to another type of data storage. In cases where existing software modules include hard-coded statements in a particular query language, the software modules may not function properly when attempting to access a data storage device that supports a different query language or that implements a different transaction model.","Certain implementations and embodiments will now be described more fully below with reference to the accompanying figures, in which various aspects are shown. However, various aspects may be implemented in many different forms and should not be construed as limited to the implementations set forth herein. Like numbers refer to like elements throughout.","This disclosure describes implementations of systems, devices, methods, and computer-readable media for dynamically intercepting and translating statements configured to access a data storage device or service. An application may include data access statements (e.g., statements that are written into the source code) to access data stored on a first data storage. The application may be modified such that the application is linked with, or otherwise incorporates, a database driver that redirects the statements to a statement processing device instead of the first data storage. The statement processing device may perform operations to translate the statements from their original query language (e.g., a language supported by the first data storage) into a different query language. The translated statements may then be executed on a second data storage that supports the different query language, a different transaction model, or a different storage format. The result data set generated through execution of the translated statements may be returned to the statement processing device. The statement processing device may then return the result data set to the application that sent the original statements, in some cases after processing the result data set. Implementations may return the result data set to the application as if the result data set was generated based on executing the original statements on the first data storage. In some implementations, the interception and translation of the statements may be substantially transparent to the application that sent the statements, and may not require any modification of the application apart from incorporating a different database driver into the application.","The behavior of the application after receiving the result data set may provide an indication of the feasibility of modifying (e.g., refactoring or recoding) the application to interact with the second data storage instead of the first data storage. Accordingly, implementations may enable an estimate of the cost that may be expended to make such modifications, such as the cost in money, time, computing resources, human resources, and so forth. For example, if it determined that the application exhibits errors, failures, exceptions or other problems in response to receiving the result data set, a determination may be made that the modification of the application may be arduous or time-consuming.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 1","FIG. 1","FIG. 3"],"b":["100","100","102","104","102","102","102","102"]},"The host device(s)  may execute one or more application(s)  that include one or more statements for accessing a data storage. The application(s)  may include any type of application specified using any programming language, including but not limited to any version of: Java\u2122 or JavaScript\u2122, provided by Oracle\u2122 Corporation of Redwood City, Calif., USA; C; C++; C#, developed by Microsoft\u2122 Corporation of Redmond, Wash., USA; Perl; Python\u2122, developed by the Python Software Foundation; BASIC; assembly language; and so forth. The application(s)  may be specified using a programming language that is a compiled programming language, such that the application(s)  are compiled into machine-executable binary code that is executable on the host device(s) . The application(s)  may also be specified using a scripting language or an interpreted programming language, such that the application(s)  execute within a virtual machine, runtime, or interpreter engine executing on the host device(s) . The application(s)  may be parallelized across one or more processes or threads executing on one or more host device(s) . The application(s)  may include one or more statements for accessing a data storage to retrieve data, store data, update or modify stored data, or delete data from the data storage. For example, an application  that is written to manage employee data records in an employee data storage may include statements to retrieve, update, and store employee information that describes an employee name, department, title, employee identification number, office location, email address, and so forth. The statements may be written using any query language. A query language may include a data manipulation language (DML) or any structured language arranged to access, retrieve, modify, add, or delete data stored in any type of data storage. The statements described herein may be specified using query languages including but not limited to any version of the Structured Query Language (SQL), Language-Integrated Query (LINQ), the Hadoop Query Language (HQL), or MapReduce.","Each statement may indicate one or more operations to be performed on stored data. For example, statements may be configured to perform operations including, but not limited to: operations to retrieve records from a dataset (e.g., select operations); operations to add new records to a dataset (e.g., insert operations); operations to modify existing records in a dataset (e.g., update operations); or operations to remove records from a dataset (e.g., delete operations). Statements may also perform operations to process records from multiple datasets in data storage, such as an inner join operation, a left outer join operation, a right outer join operation, a full outer join operation, a cross join operation, and so forth.","In some cases, the host device(s)  may execute a first instance of the application(s) () that incorporates a database driver  such as any version of a Java Database Connectivity (JDBC) driver or any version of an Open Database Connectivity (ODBC) driver. The database driver  may be incorporated into the application(s) () as a library, Application Programming Interface (API), or other type of software module, and may enable the application(s) () to send a first set of statements  to interact with a first data storage . The first set of statements  may include statements that are hard-coded or otherwise included in the specification (e.g., source code) of the application(s) . In some cases, the first set of statements  may include one or more statements specified using a first query language that is supported by the first data storage . For example, in cases where the first data storage  is a relational data storage that employs a data storage format such as that supported by the Oracle\u2122 database management system, the first set of statements  may be specified using Oracle\u2122 SQL.","The first data storage  may include any number of datastores, databases, or data storage systems that support any type of data storage format. In some cases, the first data storage  may employ a relational data storage format including one or more formally described tables, each table including one or more columns associated with data attributes. The first data storage(s)  may be managed through any type of relational database management system (RDBMS) software. The first data storage(s)  may implement a transaction model that determines how multiple operations may be processed by the first data storage(s)  as part of a same transaction. The first data storage(s)  may include any number of relational databases, including but not limited to databases managed through any of the following: Oracle\u2122 Database and MySQL\u2122, from Oracle\u2122 Corporation of Redwood City, Calif., USA; DB2\u2122, from International Business Machines\u2122 (IBM) Corporation of Armonk, N.Y., USA; Linter\u2122, from the RELEX Group of Voronezh, Russia; Microsoft Access\u2122 and Microsoft SQL Server\u2122, from Microsoft\u2122 Corporation of Redmond, Wash., USA; PostgreSQL\u2122, from the PostgreSQL Global Development Group; or SQLite\u2122, from D. Richard Hipp.","The first data storage(s)  may also include any number of non-relational datastores that employ a non-relational data storage format and that may not comply with a relational database model. Such non-relational datastores may employ a hierarchical database model, or a network database model. The non-relational datastores may also include key-value datastores, hash tables, flat files, associative arrays, other types of data structures, or unstructured data storage. In some cases, the non-relational datastores may store metadata describing data attributes or other aspects of the stored data. The first data storage(s)  may include any number of non-relational datastores, including but not limited to datastores managed through any of the following: FoxPro\u2122 database management system, from Microsoft\u2122 Corporation of Redmond, Wash., USA; ParAccel\u2122 Analytic Database, from ParAccel\u2122 Incorporated of San Diego, Calif., USA; Berkeley DB from Oracle\u2122 Corporation of Redwood City, Calif., USA; MongoDB\u2122 from MongoDB, Inc. of New York, N.Y., USA; or Cassandra\u2122, CouchDB\u2122, and Hadoop\u2122 from the Apache Software Foundation.","The first set of statements  may be executed on the first data storage  to generate a first result data set . The first result data set  may then be sent to the application(s) () executing on the host device(s) , enabling the application(s) () to further process the data included in the first result data set .","In implementations, the host device(s)  may execute a second instance of the application(s) () that incorporates a redirection database driver  that differs from the database driver . The application(s) () may share a same or similar design or source code specification with the application(s) (), and may operate substantially similarly to the application(s) (). However, during execution of the application(s) () the redirection database driver  may redirect the first set of statements  to one or more statement processing device(s)  instead of to the first data storage . The statement processing device(s)  may comprise any type of computing device, including but not limited to any of the types of computing devices described with reference to the host device(s) . In some cases, two or more of the statement processing devices  may comprise a cluster, cloud, farm, or other grouping of multiple devices that coordinate operations to provide load balancing, failover support, parallel processing capabilities, shared storage resources, or other aspects. The statement processing device(s)  are described further with reference to .","The statement processing device(s)  may execute a statement processing module  to receive, translate, analyze, or otherwise process the first set of statements . Operations of the statement processing module  are described further with reference to . In some implementations, the statement processing module  may include a parser module . The parser module  may operate to parse the first set of statements  based on a grammar for the first query language in which the first set of statements  are specified. The parser module  may generate a parse data structure , such as a parse tree, that describes one or more data access operations specified in the first set of statements . The parse data structure  may be provided to a statement generation and execution module , which generates a second set of statements . The second set of statements  may include one or more statements that are specified using a second query language that is different from the first query language of the first set of statements . In this way, the statement processing module  may translate the first set of statements  from a first query language to a second query language.","The statement generation and execution module  may execute the second set of statements  on a second data storage  that supports the second query language. The second data storage  may be a relational or a non-relational data storage, and may store data using any data storage format including a relational or non-relational data storage format. The second data storage  may include any number of databases, datastores, or data storage systems that are operated through any of the data storage management systems described above with reference to the first data storage . A second result data set  may be generated based on the execution of the second set of statements . The second result data set  may be received by the statement processing module  and sent to the application(s) () executing on the host device(s) , enabling the application(s) () to further process the data included in the second result data set . In some cases, the statement processing module  may perform one or more operations to reformat or otherwise process the second result data set  prior to sending the second result data set  to the application(s) (). For example, the second result data set  may be reorganized into a format similar to a format in which the first result data set  is generated.","In some cases the execution of the application(s) () and the application(s) () may be monitored to determine any differences in behavior between the application(s) () and the application(s) () after respectively receiving the first result data set  and the second result data set . Any detected differences in behavior may enable a determination of the feasibility or cost of modifying the application(s)  to interact with the second data storage  instead of the first data storage . Such information may be used in planning for a data migration when large quantities of data may be migrated from storage on the first data storage  to the second data storage .","In some cases, the first data storage  may employ a different data storage format compared to the second data storage . For example, the first data storage  may employ a relational data storage format and the second data storage  may employ a non-relational data storage format. As another example, the first data storage  may employ a non-relational data storage format and the second data storage  may employ a relational data storage format. In such cases, implementations may enable the dynamic and automatic translation of statements that are configured to access data stored in a first data storage format, to generate statements that are configured to access data stored in a second data storage format. In some cases, the first set of statements  may be described using a version of SQL to accessing a relational database, and the second set of statements  may be described using a query language for accessing a non-relational datastore such as a key-value store.","Implementations also support statement translation in cases where the first data storage  and the second data storage  both support a similar data storage format (e.g., are both relational databases), but that support different query languages. For example, the first data storage  may be a relational database that supports a first version of SQL and the second data storage  may be a relational database that supports a second, different version of SQL. In such cases, statement translation may be performed to translate the first set of statements  from the first version to the second version of SQL. Although the example of  depicts two data storages, the environment  may include any number of data storages of any type that support any data storage format or any query language.","In some cases, the first data storage  may implement a different transaction model compared to the second data storage . For example, the first data storage  may order two or more insert, update, or delete statements issued concurrently, and the second data storage  may interleave these statements. In cases where the first data storage  and the second data storage  implement different transaction models, the application(s) (s) may exhibit errors, failures, exceptions, or other aberrant behavior on receiving the second result data set . For example, in some cases the second data storage  may be a NoSQL datastore or some other data storage that does not support transactional processing or the set of features for Atomicity, Consistency, Isolation, and Durability (ACID) that may be supported by a relational database. In such cases, and where multiple applications  may attempt to alter the same data simultaneously or otherwise be configured to expect transactional processing, errors in data processing may occur.","Although the first data storage  and the second data storage  are depicted in  as separate devices from the other entities in the environment , implementations are not so limited. In some cases, one or both of the first data storage  and the second data storage  may be a data storage service executing on one or more computing devices which may include the statement processing device(s) , the host device(s) , or other devices.","The various devices of the environment  may communicate with one another using one or more networks. Such networks may include public networks such as the Internet, private networks such as an institutional or personal intranet, or some combination of private and public networks. The networks may include any type of wired or wireless network, including but not limited to local area networks (LANs), wide area networks (WANs), wireless WANs (WWANs), wireless LANs (WLANs), mobile communications networks (e.g. 3G, 4G, etc.), and so forth. In some implementations, communications between the various devices in the environment  may be encrypted or otherwise secured. For example, such communications may employ one or more public or private cryptographic keys, digital certificates, or other credentials supported by a security protocol such as any version of the Secure Sockets Layer (SSL) protocol, the Transport Layer Security (TLS) protocol, or the Advanced Encryption Standard (AES).",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 2","b":["200","110","128","110","202","110","128","204","128","204","202","202","204","104","104","104","110","128"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 3","b":["300","102","300","102","302","302"]},"The host device  may include one or more input\/output (I\/O) devices . The I\/O device(s)  may include input devices such as a keyboard, a mouse, a pen, a game controller, a touch input device, an audio input device (e.g., a microphone), a gestural input device, a haptic input device, an image or video capture device (e.g., a camera), or other devices. In some cases, the I\/O device(s)  may also include output devices such as a display, an audio output device (e.g., a speaker), a printer, a haptic output device, and so forth. The I\/O device(s)  may be physically incorporated with the host device , or may be externally placed.","The host device  may include one or more I\/O interfaces  to enable components or modules of the host device  to control, interface with, or otherwise communicate with the I\/O device(s) . The I\/O interface(s)  may enable information to be transferred in or out of the host device , or between components of the host device , through serial communication, parallel communication, or other types of communication. For example, the I\/O interface(s)  may comply with a version of the RS-232 standard for serial ports, or with a version of the Institute of Electrical and Electronics Engineers (IEEE) 1284 standard for parallel ports. As another example, the I\/O interface(s)  may be configured to provide a connection over Universal Serial Bus (USB) or Ethernet. In some cases, the I\/O interface(s)  may be configured to provide a serial connection that is compliant with a version of the IEEE 1394 standard. The host device  may also include one or more busses or other internal communications hardware or software that allow for the transfer of data between the various modules and components of the host device .","The host device  may include one or more network interfaces  that enable communications between the host device  and other network accessible computing devices such as the statement processing device(s) . The network interface(s)  may include one or more network interface controllers (NICs) or other types of transceiver devices configured to send and receive communications over a network.","The host device  may include one or more memories, described herein as memory . The memory  comprises one or more computer-readable storage media (CRSM). The CRSM may include one or more of an electronic storage medium, a magnetic storage medium, an optical storage medium, a quantum storage medium, a mechanical computer storage medium, and so forth. The memory  provides storage of computer-readable instructions that may describe data structures, program modules, processes, applications, or other data for the operation of the host device . In some implementations, the memory  may provide storage of computer-readable instructions or other information in a non-transitory format.","The memory  may include an operating system (OS) module . The OS module  may be configured to manage hardware resources such as the I\/O device(s) , the I\/O interface(s) , and the network interface(s) , and to provide various services to applications, processes, or modules executing on the processor(s) . The OS module  may include one or more of the following: any version of the Linux\u2122 operating system; any version of iOS\u2122 from Apple\u2122 Corp. of Cupertino, Calif., USA; any version of Windows\u2122 or Windows Mobile\u2122 from Microsoft\u2122 Corp. of Redmond, Wash., USA; any version of Android\u2122 from Google\u2122 Corp. of Mountain View, Calif., USA and its derivatives from various sources; any version of Palm OS\u2122 from Palm Computing\u2122, Inc. of Sunnyvale, Calif., USA and its derivatives from various sources; any version of BlackBerry OS\u2122 from Research In Motion\u2122 Ltd. of Waterloo, Ontario, Canada; any version of VxWorks\u2122 from Wind River Systems\u2122 of Alameda, Calif., USA; or other operating systems.","The memory  may include one or more of the modules described above as executing on the host device , such as the application(s) . As described above, the memory  may include a first instance of the application(s) () that incorporate the database driver , e.g., for interacting with the first data storage . The memory  may also include a second instance of the application(s) () that incorporates the redirection database driver , which redirects statements from the application(s) () to the statement processing device(s) . In some implementations, the memory  may include a diagnostic module  configured to collect information regarding the behavior of the application(s)  during execution. For example, the diagnostic module  may detect errors, failures, exceptions, or other problems exhibited by the application(s) . The diagnostic module  may also be configured to compare the first result data set  and the second result data set , to detect potential problems associated with a data migration from the first data storage  to the second data storage , or to identify other issues. The memory  may also include one or more other modules , such as a user authentication module or an access control module to secure access to the host device , and so forth.","The memory  may include data storage  to store data for operations of the host device . The data storage  may comprise a database, array, structured list, tree, or other data structure, and may be a relational or a non-relational datastore. The data storage  may store data such as that described above as being stored on or employed by the host device , including one or more of the first result data set  or the second result data set . In some implementations, the data storage  may store application diagnostic information  that describes how one or both of the application(s) () and the application(s) () behavior during execution. For example, the application diagnostic information  may describe errors, failures, exceptions, or other problems exhibited during execution. The application diagnostic information  may also include memory dumps, stack traces, communications logs, or other information to enable one or more users to examine the behaviors of the application(s) . The application diagnostic information  may be generated by the diagnostic module . The data storage  may also store other data , such as user authentication information or access control data. In some implementations, at least a portion of the information stored in the data storage  may be stored externally to the host device , on other devices that may communicate with the host device  via the I\/O interface(s)  or via the network interface(s) .",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 4","b":["400","116","400","116","402","402","116","404","406","408","304","306","308"]},"The statement processing device  may include one or more memories, described herein as memory . The memory  comprises one or more CRSM, as described above with reference to the memory . The memory  may include an OS module  that is configured to manage hardware resources such as the I\/O device(s) , the I\/O interface(s) , and the network interface(s) , and to provide various services to applications, processes, or modules executing on the processor(s) . The OS module  may include one or more of the operating systems described above with reference to the OS module . The memory  may include one or more of the modules described above as executing on the statement processing device , such as the statement processing module , the parser module , and the statement generation and execution module . Although the examples herein may describe the parser module  and the statement generation and execution module  as sub-modules, sub-components, or sub-processes of the statement processing module  (e.g., as shown in ), implementations are not so limited. In some cases, one or both of the parser module  and the statement generation and execution module  may execute separately from the statement processing module .","In some implementations, the memory  may include one or more parser generation modules  that generate one or more parser module(s) . The parser generation module  may generate at least one parser module  for each query language used to specify the first set of statements . Implementations support the use of any parser generation module  to generate the parser module(s) , including but not limited to the CUP parser generator supported by the Technical University of Munich or the Java Compiler Compiler\u2122 (JavaCC\u2122) from Oracle\u2122 Corporation of Redwood City, Calif., USA. The parser generation module  may receive, as input, a grammar specification for one or more query languages and generate a parser module  corresponding to each of the grammars. For example, the parser generation module  may access a grammar for a version of SQL and output a parser module  that parses statements written in that version of SQL. The parser generation module  may also access a grammar for a version of HQL and output a parser module  that parses statements written in that version of HQL. Accordingly, the memory  may store any number of parser modules  configured to parse any number of query languages.","In some cases, the memory  may store a statement processing module  that includes multiple parser modules  to parse statements received in multiple query languages. Alternatively, the memory  may store a plurality of statement processing modules  that each includes a parser module  to parse statements received in a particular query language. The memory  may also include one or more other modules , such as a user authentication module or an access control module to secure access to the statement processing device , and so forth.","The memory  may include data storage  to store data for operations of the statement processing device . The data storage  may comprise a database, array, structured list, tree, or other data structure, and may be a relational or a non-relational datastore. The data storage  may store data such as that described above, including one or more of the first set of statements , the second set of statements , the second result data set , or the parse data structure(s) . The data storage  may also store one or more grammars  to be input to the parser generation module , to generate the parser module(s)  for each of one or more query languages employed by the first set of statements  to be translated. In some cases, the grammar(s)  may include context-free grammar(s) described using the Backus-Naur Form or the Backus Normal Form (BNF) for grammars. The data storage  may also store other data , such as user authentication information or access control data. In some implementations, at least a portion of the information stored in the data storage  may be stored externally to the statement processing device , on other devices that may communicate with the statement processing device  via the I\/O interface(s)  or via the network interface(s) .",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 5","b":["500","108","108","126","108","126","128","118","120","124","116","314","102"]},"At , the first set of statements  may be intercepted or otherwise received. The first set of statements  may be sent by an executing process such as the application(s) (), and may be configured to interact with a first data storage  that is implemented as hardware, software, or a combination of hardware and software. As described above, the first set of statements  may be described using a first query language that is supported by the first data storage .","At , the first set of statements  may be translated from the first query language to a second query language, to generate the second set of statements  described using the second query language. The translation is described further with reference to .","At , in some implementations a first set of credentials may be determined, the first set of credentials providing access to the first data storage . The first set of credentials may include a login, password, digital certificate, token, or any other type of credential. In some cases, the first set of credentials may be included in the first set of statements . Alternatively, the first set of credentials may be employed to establish a connection with the first data storage .","At , a second set of credentials may be determined that enable access to the second data storage  that is implemented as hardware, software, or a combination of hardware and software. In some cases, the second set of credentials may correspond to the first set of credentials in that they provide access to the two storage devices for a same user, a same device, or a same process. In some implementations, the second set of credentials may be determined based on mapping data that describes a correspondence between the first and second sets of credentials. In some implementations, the second set of credentials may be determined through a call to Lightweight Directory Access Protocol (LDAP) service, credentialing service, or some other service. Such a service may execute on the statement processing device(s)  or on another device. In some cases, one or both of the first set of credentials and the second set of credentials may be included in a configuration file that is present on, or accessible from, the host device(s)  or the statement processing device(s) .","At , the second set of credentials may be employed to execute the second set of statements  on the second data storage . At , the second result data set  generated from executing the second set of statements  may be received. In some implementations, the second result data set  may be modified, reformatted, or otherwise processed at . For example, the second result data set  may be modified such that its format resembles a format corresponding to the first result data set . At , the second result data set  may be sent to the executing application(s) (). In some cases, the second set of credentials may be employed to establish an authenticated connection or communication session between the statement processing device(s)  and the second data storage . Alternatively, the second set of credentials may be included with one or more of the second set of statements , and may be employed to authenticate the statement(s).","At , a determination may be made whether the executing application(s) () exhibit a failure, error, exception, or other problem after receiving the second result data set . Such a problem may indicate potential complications in refactoring or modifying the source code of the application(s)  to access a different type of data storage. For example, the application(s)  may be written such that it expects one or more statements to be executed within a transactional block by a data storage, and such transactional processing may not be supported by the second data storage . In such cases, a transaction-based failure of the application(s) () may expose transactional processing as a potential problem to be addressed during refactoring of the source code for the application(s) .",{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 6","b":["600","108","126","110","128","118","120","124","116","314","102"]},"At , the first set of statements  sent by the application(s) () and sent by the application(s) () may be intercepted or otherwise accessed, as described above with reference to . At , the first set of statements  may be translated from a first query language supported by the first data storage  to a second query language supported by the second data storage , to generate the second set of statements  as described above.","At , the first result data set  may be generated by executing the first set of statements  (e.g., the original, not translated statements) on the first data storage . At , the second result data set  may be generated by executing the second set of statements  (e.g., the translated statements) on the second data storage . The first result data set  may be received by the executing application(s) (), and the second result data set  may be sent to the executing application(s) () as described above. In some implementations, the generation of the first result data set  (e.g., at ) may be performed at least partly in parallel with the generation of the second result data set  (e.g., at ), such that the first set of statements  and the second set of statements  are executed to access data that is substantially similar within a particular time period.","At , the first result data set  may be compared to the second result data set . In some cases, differences between the two result data sets may indicate problems associated with migrating data from the first data storage  to the second data storage . Differences between the two result data sets may also indicate problems that may be encountered when refactoring or otherwise modifying the source code of the application(s)  to access the second data storage . Such differences may be reported to one or more users for further investigation.","At , the first result data set  and the second result data set  may respectively be sent to the application(s) () and the application(s) (). At , the behaviors of the application(s) () and the application(s) () may be compared, and differences in behavior may be reported to one or more users for further investigation. In some cases, differences in behavior may indicate problems to be addressed when refactoring or otherwise modifying the source code of the application(s)  to access the second data storage .","Some implementations may perform operations (e.g., at ) to compare the first result data set  and the second result data set  and may omit the operations (e.g., at ) to compare the behaviors of the first and second instances of the executing application . In such implementations, the second instance of the application () may be executing, and the first instance of the application () may not be executing. The first set of statements  may, in such implementations, be intercepted from the second instance of the application () at , and not from the first instance of the application ().",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 7","b":["700","108","126","108","420","108","118","120","124","116"]},"At , the first set of statements  sent by the application(s) () may be intercepted or otherwise accessed, as described above with reference to . At , the first set of statements  may be parsed to generate the parse data structure . In some cases, the parse data structure  may be a parse tree or a modified parse tree exhibiting any branching factor. Implementations also support the use of other types of data structures. The parse data structure  may describe one or more data access operations indicated by the first set of statements . As described above, the parsing may be performed by a parser module  that is generated based on a grammar  for the first query language employed by the first set of statements .","At , the parse data structure  may be traversed and each of the data access operations may be analyzed and processed to generate the second set of statements . Such processing may include mapping one or more subsets of the nodes of the parse data structure  to one or more statements to be included in the second set of statements . The second set of statements  may then be executed on the second data storage  as described above.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIGS. 8 and 9","FIGS. 8 and 9","FIGS. 8 and 9"],"b":["122","126","130","126","108","110","128","128","110","128"]},"The examples of  reference two example datasets. The first dataset is named \u201cemployees,\u201d and may include any number of records each providing information describing an employee. In the example, the \u201cemployees\u201d dataset includes four columns, \u201cemployee_ID,\u201d \u201cfirst_name,\u201d \u201clast_name,\u201d and \u201cdepartment_ID,\u201d with \u201cemployee_ID\u201d being the hash key that is a searchable column of the dataset. The second dataset is named \u201cdepartments,\u201d and may include any number of records each providing information describing a department of a business or other organization. In the example, the \u201cdepartments\u201d dataset includes two columns, \u201cdepartment_ID\u201d and \u201cdepartment_name,\u201d with \u201cdepartment_ID\u201d being the hash key for the dataset. The \u201cemployees\u201d and \u201cdepartments\u201d datasets in the key-value store may include the second set of stored data  that has been migrated (e.g., copied and reformatted) from the first set of stored data  that includes two relational database tables \u201cemployees\u201d and \u201cdepartments.\u201d Accordingly, the second set of stored data  may store substantially similar data to the first set of stored data , in a different data storage format.",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 8","b":["800","108","118","120","124","116"]},"At , the parse data structure  is accessed, and a set of one or more nodes may be identified as corresponding to a SQL statement. As described above, the parse data structure  may be a parse tree generated by parsing the first set of statements . In the example of , the set of nodes may correspond to a select statement, an update statement, or a delete statement, specified according to any version of SQL.","At , a determination is made whether the statement includes a where clause to apply a condition to the select, update, or delete statement. If not, the process may proceed to . Statements that do not include a where clause may be statements such as \u201cselect * from employees\u201d or \u201cdelete from departments,\u201d which may operate against all records of the dataset corresponding to the relational database table \u201cemployees\u201d or \u201cdepartments.\u201d","At , the statement may be applied to all of the records in the dataset of the key-value store that is referenced in the statement. For example, based on a SQL statement of \u201cselect * from employees\u201d a statement of the second set of statements  may be generated to retrieve all the records of the \u201cemployees\u201d dataset in the key-value store. In that case, the second result data set  may include all records from the \u201cemployees\u201d dataset. As another example, based on a SQL statement of \u201cdelete from employees\u201d a statement of the second set of statements  may be generated to delete all the records of the \u201cemployees\u201d dataset in the key-value store. In that case the second result data set  may be empty or null. As another example, based on a SQL statement of \u201cupdate employees set last_name=\u2018Smith\u2019\u201d a statement of the second set of statements  may be generated to modify all the records of the \u201cemployees\u201d dataset in the key-value store and set each \u201clast_name\u201d value to \u201cSmith.\u201d In that case the second result data set  may be empty or null.","If it is determined at  that the statement includes a where clause with one condition, the process may proceed to . At , a determination is made whether the where clause is a condition on a hash key of the key-value store, such as in the statement \u201cselect first_name from employees where employee_ID=55.\u201d If so, the process may proceed to . At , the one or more records of the key-value store are accessed based on the hash key, and the statement may be applied to the accessed records. In the above example \u201cselect first_name from employees where employee_ID=55,\u201d a statement of the second set of statements  may be generated to retrieve the values of the data attribute \u201cfirst_name\u201d from the \u201cemployees\u201d dataset, for all records that have the hash key equal to 55. The second result data set  may then include the \u201cfirst_name\u201d values of all such records. As another example, based on a SQL statement of \u201cupdate employees set first_name=\u2018Austin\u2019 where employee_ID=55,\u201d a statement of the second set of statements  may be generated to modify all such records to set the \u201cfirst_name\u201d value to \u201cAustin.\u201d In that case, the second result data set  may be empty or null.","If it is determined at  that the condition of the where clause is not on a hash key of the key-value store, such as in the statement \u201cselect first_name from employees where last_name=\u2018Smith\u2019,\u201d the process may proceed to . At , a determination is made whether there is an inversion table that associates the data attribute included in the where clause with the data attribute for the hash key in the key-value store, e.g., if the where clause is a condition on the hash key of an existing inversion table. If so, the process may proceed to . If not, the process may proceed to . At , all records of the key-value store may be accessed and filtered based on the condition in the where clause. Such filtering may include removing those records that do not satisfy the condition. The statement may then be applied to the filtered record(s).","If it is determined at  that an appropriate inversion table exists, the inversion table may be accessed that associates the data attribute included in the where clause with the data attribute for the hash key in the key-value store. In the above example \u201cselect first_name from employees where last_name=\u2018Smith\u2019,\u201d an inversion table may be accessed that maps \u201clast_name\u201d to \u201cemployee_ID.\u201d Any number of such inversion tables may be stored in the second set of stored data  in the second data storage . In some cases, the inversion table(s) may be created through pre-processing of the second set of stored data  prior to the dynamic statement translation operations described herein. In cases where the first data storage  is a relational database managed through RDBMS, indices present in the first data storage  may be employed to create the inversion table(s) that are included in the second data storage .","At , the inversion table may be employed to determine one or more hash key value(s) that correspond to the data attribute included in the where clause. At , one or more records of the key-value store may be accessed based on the hash key value(s) determined at , and the statement may be applied to each of the accessed record(s) as described above.","Implementations support the application of where clauses in which the condition is an equality condition on a data attribute that is a hash key of the key-value store, or on a data attribute that is not a hash key. For example, implementations support the application of a condition data attribute=value. Some implementations also support the application of other types of conditions. In some cases, where the condition to be applied is a range of values (e.g., value<data attribute<value), implementations may translate the condition over a range to a plurality of equality conditions applied to discrete values of the data attribute included in the condition. In cases where the key-value store includes a range key as well as a hash key, such range-based conditions may be applied to the range key. In some cases where the condition to be applied is not an equality condition, all records of the key-value store may be retrieved and filtered to apply the condition.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 9","b":["900","108","118","120","124","116"]},"At , the parse data structure  is accessed, and a set of one or more nodes may be identified as corresponding to a SQL statement. As described above, the parse data structure  may be a parse tree generated by parsing the first set of statements . In the example of , the set of nodes may correspond to a select statement, an update statement, or a delete statement that includes a where clause having two or more conditions.","At , a determination may be made whether the conditions include one or more conditions on hash key(s) of the targeted dataset in the key-value store. If so, the process may proceed to  and retrieve one or more records of the key-value store based on the hash key(s), to generate an initial result data set. By applying the condition on the hash key(s) first in the process, implementations may reduce the number of records to be used in the subsequent application of the other conditions of the where clause. In some implementations, further analysis may be performed to determine the first condition to apply based on which condition is likely to select the smallest set of records as the initial result data set (e.g., which condition has the highest degree of cardinality). In cases where the conditions include at least two conditions on hash keys of at least two different datasets, the hash keys may be employed to determine at least two sets of records by applying each condition on a hash key of a dataset. In such cases, the initial result data set may be generated as a union (e.g., a hash join) of the at least two sets of records from the at least two different datasets. After , or if it is determined at  that the conditions do not include condition(s) on hash key(s), the process may proceed to .","At , a condition is identified from among the remaining conditions included in the where clause of the statement. At , an inversion table is accessed that associates the data attribute included in the condition with the data attribute for the hash key of the dataset in the key-value store. At , the inversion table may be employed to determine one or more hash key value(s) that correspond to the data attribute included in the condition. Employment of the inversion tables in  and  may proceed as described above with reference to . In cases where an inversion table is not present that associates the data attribute included in the condition with the data attribute for the hash key, the process may access all records of the dataset of the key-value store and filter the records based on the condition to be applied, as described with reference to .","At , if the process is on a first iteration and no initial result data set was determined at , one or more records of the key-value store may be accessed based on applying the hash key value(s) determined at  and the record(s) may be incorporated into a working result data set. At , if the process is on a first iteration and an initial result data set was determined at , the hash key value(s) determined at  may be employed to determine record(s) of the initial result data set with the hash key value(s), and the record(s) may be saved in memory as the working result data set. At , if the process is on at least a second iteration, the hash key value(s) determined at  may be employed to determine record(s) of the current working result data set with the hash key value(s), and the record(s) may be saved in memory as the next iteration of the working result data set.","At , a determination is made whether there is at least one additional condition to analyze from the conditions included in the where clause of the statement. If so, the process may return to  and identify another condition to analyze. If not, the process may proceed to .","At , in cases where the statement is a select statement, one or more data attributes of the working result data set may be determined as the second result data set . For example, if the SQL statement is \u201cselect * from employees inner join departments d on e.department_ID=d.department_ID and first_name=\u2018Austin\u2019 and department_name=\u2018ENG\u2019,\u201d then all the records of the working result data set may be returned as the second result data set . If the SQL statement specifies one or more columns, then the values of the corresponding data attribute(s) in the working result data set may be returned as the second result data set . At , in cases where the statement is other than a select statement (e.g., an update or delete statement), then the statement may be applied to the records of the work result data set.","Table 1 provides a non-limiting example of pseudo-code that may be employed in at least some implementations. In the pseudo-code of Table 1, the \u201cstatement\u201d may be included in the first set of statements  to be translated, and the \u201cresults\u201d may be included in the second result data set .",{"@attributes":{"id":"p-0080","num":"0079"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"generate_inital_result_set(tables, conditions)"},{"entry":"\u2003let tables = the set of all tables referred to by the statement"},{"entry":"\u2003let conditions = the set of all conditions from the where clauses in the"},{"entry":"\u2003statement"},{"entry":"{"},{"entry":"\u2003\u2003let initial_table_results = a map whose keys are a table t from tables"},{"entry":"\u2003\u2003\u2003and whose values are a set of rows from t initialized to a sentinel"},{"entry":"\u2003\u2003\u2003value ALL_ROWS"},{"entry":"\u2003\u2003for each table t in tables {"},{"entry":"\u2003\u2003\u2003\u2003if conditions includes an equality condition on t where one side"},{"entry":"\u2003\u2003\u2003\u2003\u2003is a constant value cv and the other refers to the hash key of"},{"entry":"\u2003\u2003\u2003\u2003\u2003 t {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003let t_entry = the entry from t with hash key cv"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if t_entry is not null {"},{"entry":"\u2003\u2003\u2003\u2003\u2003initial_table_results[t] = set(t_entry)"},{"entry":"\u2003\u2003\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003\u2003\u2003initial_table_results[t] = the empty set"},{"entry":"\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return the cross product across all tables from initial_table_results"},{"entry":"}"},{"entry":"handle_condition(tables, conditions, results)"},{"entry":"\u2003let tables = the set of all tables referred to by the statement"},{"entry":"\u2003let conditions = the set of all conditions from the where and join"},{"entry":"\u2003clauses in the statement minus those handled by"},{"entry":"\u2003generate_initial_result_set"},{"entry":"\u2003let results = the output from generate_initial_result_set"},{"entry":"{"},{"entry":"\u2003\u2003for each condition c in conditions {"},{"entry":"\u2003\u2003\u2003if c is an equality condition {"},{"entry":"\u2003\u2003\u2003\u2003if one side of c is a constant value cv and"},{"entry":"\u2003\u2003\u2003\u2003\u2003the other side ncv refers to a column in table t {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if with an inversion table tinv exists for ncv {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003let inv_results = the entries from tinv with hash key cv"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003results = hash_join(results, inv_results)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003results = filter(results, c)"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003let lhs = the left side of c"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003let rhs = the right side of c"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003results = hash_join(results[lhs], results[rhs])"},{"entry":"\u2003\u2003\u2003\u2003\u2003}"},{"entry":"\u2003\u2003\u2003} else {"},{"entry":"\u2003\u2003\u2003\u2003results = filter(results, c)"},{"entry":"\u2003\u2003\u2003}"},{"entry":"\u2003\u2003}"},{"entry":"\u2003\u2003return results"},{"entry":"}"},{"entry":"filter(rows, condition) and hash_join(rows1, rows2) are filter and hash"},{"entry":"join operations with the ability to expand ALL_ROWS sentinels into full"},{"entry":"table queries."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Although the examples herein may describe particular types of statements (e.g., select, update, and delete statements), implementations are not limited to these examples. Implementations also support the translation of SQL insert statements. In such cases, the second set of statements  may be determined to add additional records into the specified dataset of the key-value store. Implementations also support the translation of hierarchical statements supported in Oracle\u2122 SQL. Such statements may be translated into a series of statements in the second set of statements  that recursively select subsets of records to generate results similar to those of a hierarchical statement. Implementations also provide for the translation of SQL analytic functions such as count, max, min, sum, and avg.","Although the above examples describe intercepting and translating statements sent by executing application(s) , implementations are not so limited. Implementations may also be employed to translate data access statements present in source code of the application(s) , while the application(s)  are not executing. For example, implementations may be employed to refactor or otherwise modify source code of an application , to enable the application  to access a different type of data storage than the application  was originally designed to access. Implementations may also be employed to translate data access statements retrieved from logs of statements executed in a data storage device.","Those having ordinary skill in the art will readily recognize that certain steps or operations illustrated in the figures above may be eliminated, combined, or performed in an alternate order. Any steps or operations may be performed serially or in parallel. Moreover, the methods described above may be implemented as one or more software programs for a computer system and may be encoded in a computer-readable storage medium as instructions executable on one or more processors.","Embodiments may be provided as a computer program product including a non-transitory computer-readable storage medium having stored thereon instructions (in compressed or uncompressed form) that may be used to program a computer (or other electronic device) to perform processes or methods described herein. The computer-readable storage medium may be one or more of an electronic storage medium, a magnetic storage medium, an optical storage medium, a quantum storage medium, and so forth. For example, the computer-readable storage media may include, but is not limited to, hard drives, floppy diskettes, optical disks, read-only memories (ROMs), random access memories (RAMs), erasable programmable ROMs (EPROMs), electrically erasable programmable ROMs (EEPROMs), flash memory, magnetic or optical cards, solid-state memory devices, or other types of physical media suitable for storing electronic instructions. Further, embodiments may also be provided as a computer program product including a transitory machine-readable signal (in compressed or uncompressed form). Examples of machine-readable signals, whether modulated using a carrier or unmodulated, include but are not limited to signals that a computer system or machine hosting or running a computer program can be configured to access, including signals transferred by one or more networks. For example, the transitory machine-readable signal may comprise transmission of software by the Internet.","Separate instances of these programs can be executed on or distributed across any number of separate computer systems. Thus, although certain steps have been described as being performed by certain devices, software programs, processes, or entities, this need not be the case and a variety of alternative implementations will be understood by those having ordinary skill in the art.","Additionally, those having ordinary skill in the art readily recognize that the techniques described above can be utilized in a variety of devices, environments, and situations. Although the present disclosure is written with respect to specific embodiments and implementations, various changes and modifications may be suggested to one skilled in the art. It is intended that the present disclosure encompass such changes and modifications that fall within the scope of the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0003","num":"0002"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
