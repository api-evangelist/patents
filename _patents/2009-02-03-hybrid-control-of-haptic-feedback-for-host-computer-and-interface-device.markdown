---
title: Hybrid control of haptic feedback for host computer and interface device
abstract: A hybrid haptic feedback system in which a host computer and haptic feedback device share processing loads to various degrees in the output of haptic sensations, and features for efficient output of haptic sensations in such a system. A haptic feedback interface device in communication with a host computer includes a device microcontroller outputting force values to the actuator to control output forces. In various embodiments, the microcontroller can determine force values for one type of force effect while receiving force values computed by the host computer for a different type of force effect. For example, the microcontroller can determine closed loop effect values and receive computed open loop effect values from the host; or the microcontroller can determine high frequency open loop effect values and receive low frequency open loop effect values from the host. Various features allow the host to efficiently stream computed force values to the device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07916121&OS=07916121&RS=07916121
owner: Immersion Corporation
number: 07916121
owner_city: San Jose
owner_country: US
publication_date: 20090203
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCES TO RELATED APPLICATION","GOVERNMENT INTERESTS","COPYRIGHT NOTIFICATION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Hybrid Architecture","Embodiments","Basic Architecture","Streaming Processing","Processing Sharing","Effect Types","Actual Processing","Hybrid Control of Open-Loop Forces","Device Memory Handling","Descriptor Processing","Computational Methods","Dual Mode Devices","Caching","Recovery from Data Transfer Errors","Interpolation for \u201cMissing\u201d Force Streaming Reports","Redundant Data Transfers","Device Shutdown if Stream is not Maintained","Streaming Processing with Devices Having Kinematics"],"p":["This application is a continuation of U.S. patent application Ser. No. 10\/184,041, filed Jun. 25, 2002, entitled \u201cHybrid Control of Haptic Feedback for Host Computer and Interface Device,\u201d which is a continuation of U.S. patent application Ser. No. 09\/687,744, filed Oct. 13, 2000, entitled \u201cHybrid Control of Haptic Feedback for Host Computer and Interface Device,\u201d and a continuation-in-part of U.S. patent application Ser. No. 09\/322,245 filed May 28, 1999, entitled, \u201cShaping Force Signals Output by a Force Feedback Device,\u201d which is a continuation of U.S. patent application Ser. No. 08\/747,841, now U.S. Pat. No. 5,959,613, filed Nov. 13, 1996; and this application claims the benefit of U.S. Provisional Applications No. 60\/160,401, filed Oct. 19, 1999, entitled, \u201cHybrid Control of Force Feedback for a Host Computer and Interface Device,\u201d and No. 60\/221,496, filed Jul. 27, 2000, entitled, \u201cHybrid Control of Vibrations in Haptic Feedback Devices,\u201d all of which are incorporated herein by reference in their entirety.","Certain inventions provided herein were made with government support under Contract Number M67004-97-C-0026, awarded by the Department of Defense. The government has certain rights in these inventions.","A portion of the disclosure of this patent document and its attachments contain material which is subject to copyright protection. The copyright owner has no objection to the facsimile reproduction by anyone of the patent document or the patent disclosure, as it appears in the Patent and Trademark Office patent files or records, but otherwise reserves all copyrights whatsoever.","The present invention relates generally to interface devices for allowing humans to interface with computer systems, and more particularly to low-cost computer interface devices that allow computer systems to provide haptic feedback to the user.","Haptic feedback interface devices are currently available to interface a person with a host computer device such as a personal computer, game console, portable computer, or other type of computer. Several different types of consumer level haptic feedback devices are available, including joysticks, mice, steering wheels, gamepads, etc. The computer displays a graphical environment such as a game, graphical user interface, or other program and the user controls a graphical object or other aspect of the graphical environment by inputting data using the interface device, typically by moving a manipulandum or \u201cuser manipulatable object\u201d such as a joystick handle or steering wheel. The computer also may output haptic feedback information to the interface device which controls the device to output haptic feedback to the user using motors or other actuators on the device. The haptic feedback is in the form of vibrations, spring forces, textures, or other sensations conveyed to the user who is physically grasping or otherwise contacting the device. The haptic feedback is correlated to events and interactions in the graphical environment to convey a more immersive, entertaining, and functional environment to the user. In some interface devices, kinesthetic feedback is provided, while others may provide tactile feedback; these are collectively and generally referenced herein as \u201chaptic feedback.\u201d","In most commercially available haptic feedback interface devices, the goal has been to reduce the processing loading on the host computer by offloading as much of the processing as possible to the device itself. Thus, while haptic feedback devices may have significant differences, most of the more sophisticated devices share a common feature: a local microcontroller on the device that is able to compute and output forces as directed by high-level commands from the host computer. These dual-architecture systems produce very high quality haptic feedback output while presenting a minimal processing load on the host system.","However, in order to achieve these capabilities on the device, there is a price to pay. The force computations that are required to generate the output can be computationally expensive operations. As a result the microcontroller that is embedded in the interface device needs to be sufficiently powerful in order to handle this processing. The end result is that the device microcontroller is expensive, and the completed interface products have a significant cost to consumers. While this extra cost is bearable when the market for these devices is new, the cost of these consumer devices is constantly being driven to lower levels as the market continues to mature.","In order to reduce the processing power (and thereby the cost) of the device microcontroller and maintain the product quality level, other alternate solutions should be explored.","The present invention is directed to a hybrid haptic feedback system in which a host computer and haptic feedback device can share processing loads to various degrees in the output of haptic sensations, and is also directed to features for efficient output of haptic sensations in such a system.","More particularly, a haptic feedback interface device in communication with a host computer includes a user manipulatable object physically contacted and moveable by a user, an actuator outputting forces felt by the user, a sensor detecting motion of the user manipulatable object, and a device microcontroller outputting force values to the actuator to control the forces and receiving sensor signals. The microcontroller determines a closed loop force value based at least in part on a sensor signal and outputs the closed loop force value to the actuator. The microcontroller does not compute open loop force values but instead receives open loop force values from the host computer and directs the these force values to the actuator. Preferably, the open loop force values are primarily based on time, such as periodic forces, and are computed on the host computer. The closed loop forces, such as springs and damping forces, are based on user object position or motion and are computed on the local microcontroller. The open loop force values can be received from the host over a streaming serial communication channel.","Other features allow the microcontroller to extrapolate a force value or output a previously received force value if a force value received from the host is corrupted or missing; or to terminate an output force if a time from receiving host force values reaches a predetermined length. An emulator layer on the host which computes force values can emulate a haptic feedback device so that a host application program or other host layer sends a command as if it were sending the command to the haptic feedback device. A streaming channel of force values can be kept continuously full of streaming data by providing a transfer request to a communication driver on the host while the communication driver is outputting data from a previous transfer request to the device. Force values can be stored by the host and retrieved to be output as repeating force values.","In another aspect of the present invention, a method for providing haptic feedback functionality on a host computer in a hybrid system includes receiving on a driver of the host computer a command provided by an application program to provide a force effect having a type. Based on the type of force effect, information derived from the command is either directed to the haptic feedback device so the device computes a force value from the information, or information derived from the command is stored in memory of the host and a force value is computed using the driver, where the driver provides the computed force value to the haptic feedback device. The force value is output as a force by the haptic feedback device to a user of the haptic feedback device. In one embodiment, the type is either open loop or closed loop, where the force value from the closed loop effect is computed by the haptic feedback device and the force value from the open loop effect is computed by the driver. The driver can emulate a haptic feedback device so that the application program is ignorant of any division in computation of forces. The driver can select a particular period of sending information to the device based on a processing burden on the host computer or device or communication bandwidth.","In another aspect of the present invention, a force feedback interface device includes a user manipulatable object, an actuator outputting forces felt by the user, a sensor detecting motion of the user manipulatable object, and a device microcontroller determining a force value of a high frequency open loop effect based at least in pant on a command received from the host computer. The microcontroller does not determine force values for low frequency open loop effects and instead receives the low frequency open loop force values from the host. The microcontroller directs all open loop force values to the actuator. The low frequency open loop force values preferably describe an effect having a frequency under a threshold frequency, and high frequency open loop values are for an effect having a frequency over the threshold frequency. The open loop force values can define vibration force effects. Similar or other embodiments allow the microcontroller to determine closed loop force values based at least in part on sensor signals describing a position or motion of the user manipulatable object, where the microcontroller does not determine low frequency open loop force values and receives low frequency open loop force values from the host computer to be output by the actuator.","The present invention advantageously provides a hybrid haptic feedback system that allows the processing burden to be shared between device and host to different degrees depending on the needs of the system designer or producer. The greater the processing burden the host takes on, the less expensive the device can be made; various features of the present invention allow the host to tale on a greater processing burden than allowed by existing dual-architecture haptic feedback systems yet maintain quality haptic feedback.","These and other advantages of the present invention will become apparent to those skilled in the art upon a reading of the following specification of the invention and a study of the several figures of the drawing.","In many preferred embodiments, the present invention reduces the complexity of the device microcontroller and maintains the quality of haptic feedback by sharing the force processing loading between the device microcontroller and the processor of the host computer. This sharing of processing results in a \u201chybrid\u201d haptic feedback system that functions much like existing haptic systems but allows a more limited, inexpensive processor to be used in the interface device and allows the host computer to handle at least a portion of the computations yet maintain the overall quality of the haptic feedback system. Several inventive embodiments and aspects of a hybrid system are described herein.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 1","b":["10","10","12","14"]},"Host computer system  can be any of a variety of computing devices. Host  can be a personal computer, such as a PC or Macintosh personal computer, or a workstation, such as a SUN or Silicon Graphics workstation. Alternatively, host computer system  can be one of a variety of home video game systems, such as systems available from Nintendo, Sega, or Sony, a television \u201cset top box\u201d or a \u201cnetwork computer\u201d, a portable computer, game device, personal digital assistant, arcade game machine, main microprocessor in a vehicle or other system, etc. Host computer system  preferably implements one or more host application programs with which a user  is interacting via peripherals and haptic feedback interface device . For example, the host application program can be a video game, medical simulation, scientific analysis program, operating system, graphical user interface, or other application program that utilizes haptic feedback. Typically, the host application provides images to be displayed on a display output device, as described below, and\/or other feedback, such as auditory signals.","Host computer system  preferably includes a host microprocessor , random access memory (RAM) , read-only memory (ROM) , input\/output (I\/O) electronics , a clock , a display screen , and an audio output device . Display screen  can be used to display images generated by host computer system  or other computer systems, and can be a standard display screen, CRT, flat-panel display, 3-D goggles, visual projection device, or any other visual output device. Audio output device , such as speakers, is preferably coupled to host microprocessor  via amplifiers, filters, and other circuitry well known to those skilled in the art (e.g. in a sound card) and provides sound output to user  from the host computer . Other types of peripherals can also be coupled to host processor , such as storage devices (hard disk drive, CD ROM\/DVD-ROM drive, floppy disk drive, etc.), printers, and other input and output devices. Data for implementing the interfaces of the present invention can be stored on computer readable media such as memory (e.g., RAM or ROM), a hard disk, a CD-ROM or DVD-ROM, etc.","An interface device  is coupled to host computer system  by a bi-directional bus . The bi-directional bus sends signals in either direction between host computer system  and the interface device, and can be a serial bus, parallel bus, Universal Serial Bus (USB), Firewire (IEEE 1394) bus, wireless communication interface, etc. An interface port of host computer system , such as an RS232 or Universal Serial Bus (USB) serial interface port, parallel port, game port, etc., connects bus  to host computer system .","Interface device  includes a local microprocessor , sensors , actuators , a user object , optional sensor interface , au optional actuator interface , and other optional input devices . Local microprocessor  is coupled to bus  and is considered local to interface device  and is dedicated to haptic feedback and sensor I\/O of interface device . Microprocessor  can be provided with software instructions to wait for commands or requests from computer lost , decode the commands or requests, and handle\/control input and output signals according to the commands or requests. In addition, processor  preferably operates independently of host computer  by reading sensor signals and calculating appropriate forces from those sensor signals, time signals, and stored or relayed instructions selected in accordance with a host command. Suitable microprocessors for use as local microprocessor  include the I-Force Processor from Immersion Corp., the MC68HC711E9 by Motorola, the PIC16C74 by Microchip, and the 82930AX by Intel Corp., for example, or tore lower-end microprocessors in some embodiments (e.g. if the host is sharing significant force processing according the present invention). Microprocessor  can include one microprocessor chip, or multiple processors and\/or co-processor chips, and\/or digital signal processor (DSP) capability. In some embodiments, the microprocessor  can be more simple logic circuitry, state machines, or the like.","Microprocessor  can receive signals from sensors  and provide signals to actuators  of the interface device  in accordance with instructions provided by host computer  over bus . For example, in a preferred local control embodiment, host computer system  provides high level supervisory commands to microprocessor  over bus , and microprocessor  manages low level force control loops to sensors and actuators in accordance with the high level commands and independently of the host computer . The haptic feedback system thus provides a host control loop of information and a local control loop of information in a distributed control system. This operation is described in greater detail in U.S. Pat. No. 5,739,811 and U.S. patent application Ser. Nos. 08\/877,114 and 08\/050,665 (which is a continuation of U.S. Pat. No. 5,734,373), all incorporated by reference herein in their entirety. The microprocessor  is preferably operative to implement local closed loop effects dependent on position (and\/or velocity, acceleration) of the user manipulatable object, as well as operative to receive commands for open loop effects which axe calculated and directly output when conditions are appropriate, although the host can share in this processing according to the present invention, as described in detail below. Microprocessor  can also receive commands from any other input devices  included on interface apparatus , such as buttons, and provides appropriate signals to host computer  to indicate that the input information has been received and any information included in the input information. Local memory , such as RAM and\/or ROM, is preferably coupled to microprocessor  in interface device  to store instructions for microprocessor  and store temporary and other data. In addition, a local clock  can be coupled to the microprocessor  to provide timing data.","Sensors  sense the position, motion, and\/or other characteristics of a user manipulatable object  of the interface device  along one or more degrees of freedom and provide signals to microprocessor  including information representative of those characteristics. Rotary or linear optical encoders, potentiometers, optical sensors, velocity sensors, acceleration sensors, strain gauge, or other types of sensors can be used. Sensors  provide an electrical signal to an optional sensor interface , which can be used to convert sensor signals to signals that can be interpreted by the microprocessor  and\/or host computer system .","Actuators  can transmit forces to user object  of the interface device  in one or more directions along one or more degrees of freedom in response to \u201cforce values\u201d received from microprocessor . A force value can indicate a magnitude of force to be output by the actuator, and may also in some embodiments indicate direction of force output in the degree of freedom of force output of the actuator. In some embodiments, the actuators  transmit forces to the housing of the device  (instead of or addition to object ) which are felt by the user. Actuators  can include two types: active actuators and passive actuators. Active actuators include linear current control motors, stepper motors, pneumatic\/hydraulic active actuators, a torquer (motor with limited angular range), voice coil actuators, and other types of actuators that transmit a force to move an object. Passive actuators can also be used for actuators , such as magnetic particle brakes, friction brakes, or pneumatic\/hydraulic passive actuators. Actuator interface  can be optionally connected between actuators  and microprocessor  to convert signals from microprocessor  into signals appropriate to drive actuators . Optionally, some or all of the functionality of the sensor interface  and\/or actuator interface  can be incorporated into the microprocessor , such as pulse width modulation (PWM) controllers for actuators, encoder processing circuitry, etc. Force values can be implemented as analog signals, PWM signals, or other signals that are input to the actuator.","Other input devices  can optionally be included in interface device  and send input signals to microprocessor  or to host processor . Such input devices can include buttons, dials, switches, levers, or other mechanisms. For example, in embodiments where user object  is a joystick, other input devices can include one or more buttons provided, for example, on the joystick handle or base. Power supply  can optionally be coupled to actuator interface  and\/or actuators  to provide electrical power. A safety switch  is optionally included in interface device  to provide a mechanism to deactivate actuators  for safety reasons.","User manipulable object  (\u201cuser object\u201d or \u201cmanipulandum\u201d) is a physical object, device or article that may be grasped or otherwise contacted or controlled by a user and which is coupled to interface device . By \u201cgrasp\u201d, it is meant that users may releasably engage a grip portion of the object in some fashion, such as by hand, with their fingertips, or even orally in the case of handicapped persons. The user  can manipulate and move the object along provided degrees of freedom to interface with the host application program the user is viewing on display screen . Object  can be a joystick, mouse, trackball, stylus, steering wheel, sphere, medical instrument (laparoscope, catheter, etc.), pool cue (e.g. moving the cue through actuated rollers), hand grip, rotary or linear knob, button, gamepad, gamepad control, gun-shaped targeting device, or other article. Many types of mechanisms and linkages can also be employed to provide the degrees of freedom to the user manipulatable object, as well as amplification transmissions such as gears, capstan drives, and belt drives, to amplify movement for increased sensor resolution and amplify forces for output. In some embodiments, the user object and\/or the device itself can be a handheld device, e.g., a gamepad controller for video games or computer games, a portable computing device, or a hand-held remote control device used to select functions of a television, video cassette recorder, sound stereo, internet or network computer (e.g., Web-TV\u2122).","The \u201chybrid\u201d architecture of the present invention allows sharing of the force processing between the haptic feedback interface device and the host computer. In a hybrid architecture, the host computer computes at least some of the force values that are sent to the actuators of the device, thus reducing the processing requirements of the local microprocessor  on the device. A \u201cforce value\u201d is a value that indicates a magnitude and (in some cases) a direction of a force and which can be directly translated into that force by the actuator and\/or by an actuator interface, such as a PWM circuit. For example, a force value can be provided for each axis or degree of freedom for a device (including direction on that axis), or a force value can include a magnitude portion and a direction portion for a force in a multi-dimensional space. In preferred hybrid embodiments, force values sent from the host system to the device can be summed with any force values computed on the device. In some embodiments, the device can then perform post-processing on the total force value to implement such features as kinematics, linearization, and safety ramping, if such features are present, and the processed force value is sent to an actuator as an appropriate signal to be output as a force.","Implementing a hybrid device presents several technical challenges that need to be overcome to make this invention feasible. The first significant issue to deal with is the architecture of the hybrid system. One basic goal of the hybrid architecture is to employ some of the host processing power in order to compute force values over-time. One solution is to allow the host to precompute the force output values for each time step of a force effect that is to be output and transfer this data to the device before the force effect is to be output, where the device can output the effect when it is required. This approach allows some variance in the tine of delivery of the force values to the device as long as the host sends values before they are needed to be output. However, since high quality force output requires updating the output on the order of hundreds of times a second, this would require the device to have sufficiently large memory to store the force samples for a large portion of the effect, such as an entire period. The cost of this additional memory, which would likely be comparable to the savings obtained by scaling the device microcontroller back, makes this option potentially less desirable.","Another solution is to have the host system compute the force outputs in \u201creal time\u201d and send this data to the device at a fixed periodic rate. This method would not require the extra device memory, as the data is delivered to the device from the host as it is required and is directly output by the device. However, the host system would be required to compute the output at relatively high output rates.","Another issue that exists, regardless of the system architecture, is the processing loading that would be added to the host system. Because the computation of the force output values is a relatively complex process, moving this computation loading to the host system could have a significant impact on the host system performance. This may be especially true in processor-intensive host applications such as a gaming environment, where the host processor is already significantly loaded performing the computations to handle the graphics and audio output.","Despite these issues, there are two industry trends that will make the shared processing architecture become more feasible over time. First, the processing power of computer systems is growing rapidly. If it is assumed that the computations required to handle haptic feedback output remain relatively consistent, then the percentage of the processing power required from the host system will only decrease over time. This will continue to reduce the impact of any force processing on the host system.","The second trend that aids the shared processing architecture is the introduction of newer peripheral communication busses that are designed to support the concept of an isochronous or streaming data channel. If the host system were to attempt to generate a fixed period output stream using traditional peripheral busses, it would greatly complicate the host software. This is especially true for a desktop operating system, such as Microsoft Windows\u2122, as it is not a goal of these systems to allow true real time operation. Busses that have built in support for isochronous data transfers greatly aid the host system and significantly reduce the processing burden required to ensure the data transfers occur at a fixed frequency. Examples of peripheral busses that provide support for isochronous data transfers include Firewire (IEEE 1394) and the Universal Serial Bus (USB).","The following description details investigative work concerning the issues and implementations of a consumer haptic feedback device that uses a shared processing, or hybrid, architecture. A basic architecture of host computer and device processor, such as shown in , are also described in greater detail in U.S. Pat. No. 5,734,373 and in U.S. Pat. No. 5,959,613 (and copending U.S. application Ser. No. 09\/322,245), which are all incorporated herein by reference in their entirety.","A fundamental goal of this invention is to increase the capabilities of a simple, low-cost haptic feedback device connected to a host computer by using some of the host system's processing to emulate a device with increased processing power. An \u201cemulation layer\u201d \u201cemulator\u201d), e.g. a software functionality layer, can be implemented on the host to handle this emulation of a highly capable device. Many different implementations of the emulator can be provided. However, in some systems (such as Microsoft\u00ae Windows\u2122), significant advantages are gained if a very low level driver on the host implements the emulation layer on the host system, e.g. a driver situated below most other programs running on the host computer in the hierarchy of programs running. There are several reasons for this.","One reason is that, since the host operating system cannot determine whether the capabilities being enumerated are being emulated or not, it will treat a fully capable device and an emulated device identically. This means that any software that can use the fully capable device will be able to use the emulated device without any changes. Another reasons is that, by performing the emulation processing at a very low level in the system, there is reduced overhead to perform the transfers from the host to device. Since these transfers are occurring very frequently, this processing reduction will result in an increase in system performance.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 2","b":["100","102","104","102","104","106","106","108","108","110","110","112","114","116","118"]},"Even though the emulation may function better if it is lower in the system driver stack, it is possible to handle the emulation at a different, e.g. higher, level and still function. For example, the application program  itself, or a driver just below the application program, could handle the host effects. Herein, the term \u201cdriver\u201d is intended to mean any program running on the host computer below the application program level that can implement the force-related functions and features described herein.","The methods and embodiments described below, such as the emulator functionality, may be implemented with program instructions or code stored on or transferred through a computer readable medium. Such a computer readable medium may be digital memory chips or other memory devices; magnetic media such as hard disk, floppy disk, or tape; or other media such as CD-ROM, DVD, PCMCIA cards, etc. The program instructions may also be transmitted through a channel (network, wireless transmission, etc.) to the host computer or device (where appropriate) from a different source. Some or all of the program instructions may also be implemented in hardware, e.g. using logic gates.","In order for the host system to effectively perform emulation for the device, it will need to execute computational processing to generate the force output in a timely manner. Since many other processes are operating on the host system in addition to this force processing, generating this timely execution presents several issues.","Determining the frequency of execution for the emulation processing is a bit of a tradeoff. It needs to be fast enough that the device appears to be responsive to the requests of the host software. However, each execution of the emulation processing will generally have some overhead processing time involved. This can take many forms on the host system including an interrupt context switch or a thread context switch. In determining the final frequency of execution, these two factors must be balanced against One another in a compromise.","There are several ways to implement the timing of the execution of the emulation processing. In one embodiment, a timer on the system (derived from the host system clock or some other source) can be used to trigger the processing. In another embodiment, the haptic feedback device can generate messages at a specific time interval which are sent to the host system to trigger the emulation aid to trigger the emulator to send force values to the device.","However, when communications interfaces that have built in support for fixed period streaming channels are used, it is far more efficient to control the timing of the emulation based on the communication channel. The emulator  preferably works to try to keep the streaming channel filled with data to be sent to the device. In some operating system implementations (e.g., Windows), it is also a requirement tit stoning channels are continuously filled with data after they are initiated. As each streaming request is completed, the emulator is triggered to generate new data to be sent to the device.",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 3","b":"130"},"As shown in , the emulation process can provide two transfer requests, A and B. In the startup processing at stage , Transfer Request A is provided to and begun to be processed immediately by the communication driver (e.g., to output data to the device), while Request B is provided to the communication driver during the processing of Request A. When Request A is complete, the communication driver indicates this completion to the emulator with a trigger, and the emulator begins runtime processing (refilling) of Transfer Request A at stage . Meanwhile, after it has sent the trigger to the emulator, the communication driver processes Transfer Request B. During the processing of Request B by the communication driver, the emulator finishes refilling Request A and provides the Request A to the driver. When the communication driver finishes Request B and triggers the emulator, the driver can then process the refilled Request A and the emulator can begin refilling Request B at stage . The runtime processes repeat to allow delays to have minimal effect in streaming data to the device.","The implementation of the trigger to cause the emulator to perform subsequent computations (such as refilling a request) can be accomplished in many ways. One way is to include an interrupt response routine that is executed when the transfer to the device is completed. However, in most operating systems, the host controller driver (communication hardware) handles interrupts, not the communication driver, so the interrupts are not exposed high enough to be acted upon and thus the interrupt option is often unavailable. In a different embodiment, a callback routine can be executed when the communication driver has completed the transfer. However, callback routines execute with very high priority. If the callback routine takes an excessive time to complete, some other processes could be starved of processing time. Furthermore, since the callback routine is at an elevated priority, it may not be able to access all the memory it needs (aged out) or use all the system services, e.g. it may be too high a priority to be able to access paged memory which is intended for lower-level priority processes.","A preferred implementation provides an execution thread (on a multi-threaded system) that is awakened from a suspended state by a synchronization object indicating that a pending transfer is completed. This implementation does not have the restrictions of a callback routine, as is well known to those skilled in the art.","When an emulation driver is being used for a device, it enables a wide spectrum of \u201cloading sharing\u201d possibilities. These possibilities can range from the emulation driver performing essentially no processing (for a highly capable and sophisticated device) to the emulation driver handling all the force effect computations and sending only a raw force output to the device (for a simple device). As more of the processing is handled in the emulation driver, the processing power of the microprocessor used in the device can be increasingly reduced. For example, if the emulation driver handles substantially all force computation, the microcontroller on the haptic feedback device can be as simple as a state machine or simple logic circuitry. However, for a variety of reasons, the most effective and preferred solution is one that divides the force effect computation\/processing between the host system and the device based on the type of the effects being generated. This sharing of the processing presents a few issues that must be dealt with.","As described above, haptic sensations can be commanded in many haptic system embodiments by the host computer with high level commands. The high level commands are formulated by the host computer based on events or interactions occurring in an application program on the host computer, or based on other events or instructions. The high level commands are sent to the haptic feedback device and are parsed or decoded by the local microprocessor on the haptic device. The local microprocessor implements the commands by performing any necessary computations, and outputs an appropriate force effect at an appropriate time, as dictated by parameters or instructions sent with the command and\/or any instructions associated with that command as stored in the memory of the haptic feedback device.","When controlling haptic feedback devices, the force commands that are sent to the device are commonly executed as \u201ceffects\u201d, \u201cforce effects\u201d, or \u201chaptic effects\u201d which herein is used to indicate any type of force sensation, i.e., each effect is a description of a force sensation to be output by the device, and these terms may describe a single force output on the user or a series, sequence, or combination of many forces over time and\/or space. A force sensation is represented by the effect's parameters; some parameters cal be common to all effects. These may include parameters such as the effect type, the duration of the effect, and button triggers that can be associated with the effect. Other parameters may be specific to the type of effect. For example, a constant effect needs only a single additional parameter to describe its magnitude. However, a periodic force effect such as a sine wave may require several other parameters for a complete description, such as magnitude, phase, period (frequency), and offset.","When dealing with effects, it is often convenient to group them into two categories. The first group of effects would be those that provide a force primarily based on time. These effects would include such types as constant forces (e.g. pulses or jolts), periodic forces (e.g. vibrations), or sampled force outputs. The important feature that these effects share is that they are all completely independent of the sensed motion measurements on the device. No matter how the device is manipulated by the user, the force output for these effects will be the same. These effects are classified herein as \u201copen loop\u201d effects.","The other group of effects includes effects providing a force that is primarily based on a, position (or velocity, acceleration, or \u201cjerk\u201d\u2014derivative of acceleration, which are all based ultimately on position) of a user manipulatable object of the device. These effects include types such as springs, dampers, and spatial textures. The force output from these effects is directly related to the motion that occurs, and which is sensed, on the device. Because the force output from these effects is generated by a sensor feedback (servo) loop on the device, they are called \u201cclosed loop\u201d effects herein, and can also be referred to as \u201cconditions.\u201d Some devices may not be able to output kinesthetic haptic effects that provide resistance to a user object or housing in its degrees of freedom, but may still be able to output closed-loop forces that are dependent on user object or device position, For example, some tactile devices may output forces on the housing of a device but cannot output resistance forces in the degrees of freedom of motion of a manipulandum or the device.","When creating an emulator processor to operate on behalf of a device, it has been found that \u201copen loop\u201d types of effects are very good candidates for processing by the emulation layer. These types of effects are generally a function of time only and the force value content of these force effects is not based on changing manipulandum positions in real time. Because of this, the emulation layer (or other host layer) can easily compute the force output for each effect at the current time as well as in advance for all times until the effect's completion. This allows the computation of a buffer of force values into the future that are simply fed into the streaming channel to the device. This allows the host system to emulate these types of effects without any degradation in the quality of the effect generation and without requiring any device processing.","\u201cClosed loop\u201d types of effects are fax more complicated. These effects are strongly dependent on the sensor values that are measured on the device itself. If the emulation layer on the host system is going to compute the force output for these effects, the data from the sensor readings needs to be transferred from the device to the host system before the force effect can be computed. This presents several issues:","1. The input reporting of the device sensor data to the host should not be accomplished through a streaming channel. It could be performed this way, but it greatly increases the burden on both the host and device systems.","2. \u201cClosed loop\u201d effects cannot be accurately computed for future time values. This results from the fact that it is usually not possible to accurately predict the motion of the user manipulandum when the user is interacting with it.","3. As the delay between reading a sensor value and using the data in a computation of a \u201cclosed loop\u201d effect increases, the stability and quality of the effect execution is greatly decreased. This is because closed loop effects are essentially small servo loops requiring rapid updates to maintain quality of feel and prevent instability.","4. Generally the operating system or communication device driver requires the output streaming channel to be continuously filled (see discussion above). Because of this, at least two transfer requests frequently must be kept pending to the device at all times (or the requests are interleaved at least part of the time, as shown in ). The requirement of multiple pending transfer requests can greatly increase the latency between the time the effect force values are computed and the time where the force values are actually transferred to the device.","As a result of these factors, the quality of \u201cclosed loop\u201d effects that are emulated from the host system will be significantly lower than if the effects are actually computed on the device itself. Because this reduction in quality is very perceptible to a user, it is often more attractive to compute the outputs for closed loop effects on the device itself using a local microcontroller such as a microprocessor.","These factors lead to a preferred embodiment of the hybrid system of the present invention where the actual processing is shared between the host system and the device based on the types of effects being generated. Those effects that are directly dependent on the sensor values in the device are computed on the device, while those effects that are essentially time dependent are processed by the host system. This leads to the shared processing, or hybrid, system architecture. Herein, the term \u201chost effects\u201d indicates those effects to be computed on the host (e.g. by the emulation layer), and the term \u201cdevice effects\u201d indicates those effects to be computed on die device (which are closed loop effects in a preferred embodiment).","In a preferred method, the application program sends haptic commands down through the hierarchy of host levels as shown in , e.g. a command to output a force as commanded by the application program  can be translated to the appropriate forms to each successive layer of the host operating system. At some point, the emulation layer receives idle command. Since the emulation layer is emulating a device, the layer above the emulation layer believes it is outputting the haptic command (or other device command) to the device itself. The haptic commands can be such instructions as: \u201ccreate\u201d to create a new force effect (and its parameters) in the memory of the device; \u201cparameter\u201d command to load one or more new parameters in device memory for a loaded effect or otherwise modify a loaded effect; \u201cdestroy\u201d to remove an effect from device memory, \u201cplay\u201d to output a particular effect stored in device memory; or other instructions that may instruct the device to delay the output of a force effect by a designated time period, combine two or more force effects, or perform other tasks.","If a particular command is for a device effect, then the emulation layer sends the command to the device so that the local microcontroller can store the effect and compute force values at the time of output (or before output, if the device has enough memory to store force value data). If a command is for a host effect, then the emulation layer processes the command. For a create command, the emulation layer can store the created effect in a device memory model provided in host memory, as explained below. The emulation layer can compute force values for host effects in one of two ways (or a mixture of these methods to achieve more efficiency). In a first method, the emulation layer computes force values when a \u201ccreate\u201d command or a parameter command is received from an application program. The force values are then stored on the host until they are commanded to be played, at which point they are sent out to the device. In a second method, the emulation layer can compute the force values when a \u201cplay\u201d command is received, where the force values are sent out to the device (or buffered) as they are computed. If the device computes fore values when a create or parameter command is received, there is a possibility that the effect is never played, and the computation would have then been wasteful of processing availability of the device. However, if the force values are computed at the time of playing the command, performance will be slightly less due to the computational resources required at the time values are output. Once the emulation layer computes the force values, they are streamed to the device to be output in real time, as described above.","Some effects may be a combination of the sensor based computations and other computations. For example, it may be possible to command a damping force flat is only active when the device is operating in a specific range of its motion. Thus, for example, the computation of a force value for the damping force is based on the current velocity of the user manipulandum, and whether the damping force is to be computed at all is determined by the location of the manipulandum, e.g. whether the manipulandum is in a predefined damping region of the device workspace\/displayed graphical environment. In such a case, \u201chybrid effects\u201d can be used, where the emulation processor may partially assist the device in handling the output. For example, in one embodiment the device may be capable of generating that damping force output, but may be unable to gate (turn on or off) this damping output based on the position of the device. In this instance, the emulator can, for example, interpret input position reports that are received from the device and use this information to turn the damping force on and off. This allows the damping effect output to remain stable (and have good quality) and still only be effective in the region of interest without having the device perform unnecessary processing to determine the location of the region of interest and determine when to output effects.","It may sometimes be desirable to handle the all the force computations, including closed loop effects, on the host system even though there is a greater reduction in the quality of haptic feedback sensations. This embodiment leads to the greatest reductions in the processing power required for the device microcontroller and therefore the greatest reduction in device cost. In this type of design, efforts must be made to limit, as much as possible, the delay between reading the sensor data on the device and generating the force output requests. One method to help reduce this lag is the introduction of an input streaming pipe to the communications. This pipe allows the device to send information about its sensor values very rapidly and very often to the host system. Isochronous transmissions, for example, are intended for this type of transfer. This type of communication channel helps to reduce the lag introduced on the inbound transfers from the device.","However, even with the input streaming channel, there is still a delay in the output channel. One of the primary contributors to this results from the need to keep the output streaming channel full of data. There may be a way to minimize this delay, but it is not likely to be an \u201capproved\u201d method, i.e. it may not be according to established standards or may not be robust in some applications. One way this would work is to modify or update data after it has been submitted to the communication driver.","Once a transfer buffer has been submitted for transfer to the device, it technically no longer belongs to the haptic feedback driver. However, it may still be feasible to modify the contents of the data buffer even though the haptic feedback driver has relinquished the data. This may allow the haptic feedback driver to update the streaming data with far less latency before it is sent to the device. In this way, lower overall latency and improved performance for closed loop effects may be achieved.","For example,  is a block diagram  showing one such embodiment of modifying the buffer. Initially, a Transfer Request A and B are submitted, as shown in  (not shown in ). At time T of , a request to refill buffer A with a new Transfer Request A is submitted by the communication driver to the emulation layer while Transfer Request B starts to be processed by the communication driver. The emulation layer begins to refill Transfer Request A. At time T, sensor data from the device is reported to the host computer describing the position (and\/or velocity, etc.) of the user manipulatable object on the device, and the communication driver receives this sensor data and sends it to the emulation layer. The emulation layer processes the received sensor data to determine if the already-submitted force values in buffer B should be modified to correlate with the sensor data. If so, buffer B is modified accordingly. Buffer A is not so modified, however, since it is currently being refilled with a new transfer request until time T. At time T, Transfer Request B is still being processed and output by the communication driver, and sensor data is again received from the device. The emulation layer determines if data in both buffer A and buffer B should be changed in accordance with the sensor data. Both buffers may be changed since no refill processing is occurring by the emulation driver. Addition changes to the buffers can be made at additional time points, such as time T.","At time T, Transfer Request B has finished processing by the communication driver, and the communication driver indicates this to the emulation layer. The emulation layer begins refilling Transfer Request B in buffer B while the communication driver begins processing and outputting Transfer Request A. Similarly to time T, at time T sensor data is received, and only buffer A is updated if appropriate since buffer B is being written to. At time T the refill operation is complete, so that at times T and T when sensor data is again received, both buffers A and B may be modified if appropriate.","As described above, an implementation of a \u201chybrid\u201d system provides the host computer to compute some types of force values and stream the values down to the device, so that the device simply outputs the force values to the actuators of the device to provide force output. The host can stream die data to the device using, for example, a serial communication bus such as USB or the like, or other type of communication link or channel. The local microprocessor, however, computes force values for other types of force sensations and controls the actuators without any need of further host computer processing once a high level host command is received. In a preferred embodiment, the host computer determines and streams force values to tie device for open-loop, primarily time-based effects, while the local microprocessor computes and controls output forces for closed-loop, position-based effects.","Another aspect of the present invention can divides the tasks of the host computer and local microprocessor yet further. Instead of the host computer determining and streaming all open-loop force effects, the host computer can only determine \u201clow frequency\u201d open-loop effects and send those effects to the device. \u201cHigh frequency\u201d open-loop effect force values are determined and output by the local microprocessor, once a command from the host computer has been received by the local microprocessor instructing the output of the high frequency effect. If a particular embodiment also provides closed loop effects such as dampers, springs, and spatial textures, then those effects are preferably computed and controlled by. the local processor (although in alternate embodiments, some or all of such closed loop effects can be provided and streamed from the host computer).","The control of high frequency open-loop effects may in many embodiments be more appropriate for the local microprocessor to handle than the host. Since the force values in a high frequency effect are changing rapidly, the host computer may not be able to send the values across the communication link to the device as quickly as desired to maintain the fidelity or frequency of the effect. This may especially be the case if a low-bandwidth or high-latency communication link between host computer and interface device is used. Low frequency open-loop effects, however, are changing more slowly and thus allow force values to be streamed more effectively from the host system across the communication link to the device.","One way to determine the difference between \u201clow frequency\u201d and \u201chigh frequency\u201d open-loop effects, in a described embodiment, is to compare the frequency of a force effect with a predetermined threshold frequency; those open-loop effects having a frequency below the threshold are \u201clow frequency,\u201d and those having a frequency above are \u201chigh frequency.\u201d For example, an application program running on the host computer might determine that a 200 Hz periodic vibration (an open-loop effect) is to be output by the haptic feedback device. A driver or other program on the host (e.g., the \u201cemulation layer\u201d as described above) can compare the frequency parameter of the commanded vibration to the threshold frequency, which might be set at 50 Hz, for example. Since the effect's frequency is over the threshold, the effect is considered a high frequency open-loop effect, and therefore the computation of the force values for the effect is performed by the local microprocessor. The driver thus simply sends a high level vibration command to the local microprocessor with appropriate parameters, and the local microprocessor decodes the command, computes the force values for output, and sends those values to the actuator(s). If the frequency were under the threshold, the emulator (or other program layer on the host) knows that the host should be computing the force values and streaming them to the device for output, and does so as described above. In other embodiments, the distinction between low frequency and high frequency open loop effects can be determined in other ways or according to different or additional criteria. For example, a command or parameter of a force effect might directly designate that effect as high frequency or low frequency, as predetermined by a developer or user.","This division of labor between local microprocessor and host computer allows the local microprocessor to be reduced in complexity and therefore leads to a reduced cost for the haptic feedback device. For example, in some types of haptic devices, the local microprocessor can be simplified to handle only one force effect at a time. Since the host computer can stream, data to the local microprocessor at the same time the local microprocessor is controlling its own force effect, two simultaneous force effects can effectively be output, even with such a simplified local processor. For example, one common force effect in tactile devices is the simultaneous (superimposition) of two vibration effects, one vibration having a high frequency and one vibration having a low frequency. In the present invention, such simultaneous output of two vibrations is possible even when using a simplified processor, where the local microprocessor computes the content for the high frequency vibration and the host computes and streams the content for the low frequency vibration. Similarly, the host can stream a low frequency opens loop effect simultaneously with the control and output of a closed-loop effect handled by the local microprocessor in those devices capable of closed-loop effects. Preferably, the local microprocessor performs a summation of locally-determined effect values and force values received from the host computer to determine a final total force value to output from the actuator(s) of the haptic interface device.","It should be noted that other types of force effects can be selectively handled by the host computer in a hybrid embodiment, if desired. For example, the host computer might be designated to compute and stream force values only for obstruction and\/or texture closed-loop force effects, or for all closed-loop effects, as well as the low-frequency open-loop effects described above. The computation of force values for other subcategories of effects can be divided between host and local microprocessor as desired.","In other embodiments, the interface device need not have the capability of outputting closed loop effects such as springs or damping. For example, many tactile devices such as particular gamepads or mice can only output vibrations or pulses to the user through the housing, and spring and damping forces in the degrees of freedom of the user manipulandum cannot be output. The present invention is still applicable in such an embodiment, where the host streams force values for low frequency vibrations and the local microprocessor computes force values for high frequency vibrations. For example, gamepad tactile devices or mouse tactile devices moveable in a planar workspace can be used in hybrid systems, such as those disclosed in application Ser. Nos. 09\/456,887 and 09\/585,741, incorporated herein by reference in their entirety.","Device memory management becomes important when providing haptic feedback effects, since the memory on the device is typically limited in size, thereby limiting the type and number of effects which can be output by the device. When using an emulation layer, however, the emulator can potentially use the relatively large amount of host computer memory to store effects. Thus, if some effects are processed and stored by the emulator while some effects are processed and stored by the device, issues arise as to when an effect","For the consumer haptic feedback devices available at present, there are two memory management methods in use. The fist is a \u201chost-managed\u201d method, For the devices that support this method, the device will indicate how much memory it has available and the host system is then responsible for dealing with the allocation and usage of this memory. The host maintains a model of the device memory in host memory and can thus determine when device memory has space available for new effects, what effects are currently playing, etc. This saves communication between device and host since the host knows when new effects can be loaded to the device without having to request and receive a memory status update from the device. This type of method is described in greater detail in copending U.S. patent application Ser. Nos. 08\/970,953 and 09\/305,872, both of which are incorporated herein by reference in their entirety.","The other method is \u201cdevice-managed\u201d method, in which the host does not maintain its own model of device memory. Devices that support this method of operation require that host request an allocation of memory on the device for each effect that is created. The device receives the request and, if there is memory available, assigns a handle or ID number to the created effect and then provides that ID value to the host (such as the haptic feedback driver or application program) so that the host can reference and command that effect in device memory (to play it, destroy it, etc.). The host is also responsible for communicating to the device when the host no longer needs the memory for each effect. While the host managed architecture requires some extra processing by the host system to keep track of the device memory, it greatly reduces the complexity and volume of the communication with the device as well as the complexity of the device itself when compared with a device managed architecture.","If the emulation driver is operating on behalf of a device that supports device managed memory for its effects, then there are no real complications for a hybrid system. In this case, the device will inform the host when enough memory is available for an effect being created on the device and when memory is full. The emulation layer can receive the device messages and simply relay them to a higher level program, such as a haptic feedback driver or application. Thus, the emulation layer can allow device-effect requests to transfer to and from the device without any changes, i.e., no changes to those effects that the emulation layer is not processing and implementing. For host effects that the emulation layer is implementing, the emulation layer needs to provide the handle or identification (ID) values to identify the host effects.","The main complication is that the emulation layer needs to ensure that its memory ID values do not overlap with the values the device is using. This overlap can easily be avoided by having the emulation layer \u201cwrap\u201d all the ID values to make sure no values overlap, and perform some translation for the messages that are actually sent to the device to avoid the overlap. For example, if the emulation layer assigns a host effect an ID of 2, and then the device assigns an ID of 2 to a device effect, there may be an overlap problem. The value for the host effect cannot be changed since in typical embodiments there is no method for telling the haptic feedback driver (or application) that the ID has been modified. Instead, the emulation layer can map the ID of the device effect to a different \u201cmapped\u201d ID, such as \u201cn,\u201d which is reported to the upper level driver and to the application in some form. When messages from the upper drivers or programs reference an effect having an ID value of \u201cn,\u201d the emulator can look up the n value (e.g. in a look-up table) and determine that it identifies the device effect having a device ID value of 2. The emulator then modifies the message before it is sent to the device so that an ID value of 2 is used and so that the device can reference the correct effect in its memory. Such mappings can be handled in a variety of ways, including providing special values which are known to be mapped, or mapping all values.","A more difficult situation exists when an emulation driver is used to share the processing with a device that supports the host managed model. The problem is that since some of the effects are actually implemented by the device itself, the emulation layer can't report that the device has any more memory than is actually available on the device without risking an invalid effect creation. If, for example, a very limited or inexpensive device is being used which can store only a small number of effects, then to be safe the emulation layer would have to report that only the small amount of memory is available. Then the application program would never command more than the small number of effects which can be held by the device.","Thus, the emulation layer would like to report that it has a lot of memory available to store effects, since that is the case for host effects. However, if the emulation driver were to indicate that a large amount of memory was available, there is nothing that would prevent the host from locating the data for an effect in the upper portions of that large memory space. If this effect were actually a device effect to be handled on the device, it would fail because the data memory associated with that effect is located outside the small valid range of the device memory The emulation layer could attempt to \u201cremap\u201d the effects that are actually transferred to the device so that it would fit in device memory, but this would lead to further problems. First, the emulation driver would have a difficult time determining when device memory has been freed and is available (unlike the device-managed memory model). This would prevent the emulation driver from doing any \u201ccleanup\u201d activities on the device memory. Also, since the host software cannot know how much of the enumerated memory is actually available on the device, it could attempt to create more effects than the device can support. If all of these effects were device effects that needed to be loaded to the device to execute (e.g. they were closed loop effects), then it is impossible for this to occur. Because the host software would assume it has complete knowledge of the device, it would not be able to know that the effect creations had failed.","One method of avoiding this problem is to allow the emulation layer to simulate an interface using the device-managed method for the device. If the emulation driver enumerates the device to the operating system in this manner, then any software accessing the device will know to use device-managed communication methods to control the device. When host effects are created that are implemented by the emulation layer, the emulation processor will handle the allocating and releasing of whatever memory it requires to implement the effects. If device effects are created, the emulation layer will need to handle the processing for the device memory management. In these cases, the emulation layer will be required to remap the effect id values in outbound messages from the controlling software to the actual memory offsets on the device before the messages are sent to the device, since the device expects to receive actual memory offsets and not effect id values. Even though the host software will need to execute the additional communication required for a device managed interface, this should not add any significant delays since these requests are all handled in the emulation driver and do not require any actual communication exchange with the device itself. If too many effects are commanded, the emulation layer will know this based on received device messages and can inform upper level programs that an effect creation has failed.","One trend that is becoming increasingly common for computer peripheral devices is to provide the ability for peripherals to enumerate their capabilities to the host system. When this enumeration is standardized, the host software can be made flexible enough that it will be able to handle many different devices with different capabilities dynamically without having to be programmed specifically for each device. An example of an existing standard that allows peripherals to enumerate their abilities in this manner is the Human Interface Device (HID) Class specification for USB devices. Using this specification, devices can describe how they provide data to host systems and how they expect to receive data in a very standard manner. The HID specification is further supplemented by other usage documents, such as the Physical Interface Device (PID) Class specification for USB devices, which define other standard information, such as information related to haptic feedback, that devices can use in communications with host systems. The information that describes the communication capabilities of the device is commonly called a \u201cdescriptor.\u201d","When an emulation driver is used to enumerate a descriptor for a device, the situation is more complicated. Some devices may have no descriptor information at all. In these cases, the emulation driver needs to provide a complete descriptor for the device. For this to occur, the emulation driver must be able to at least identify what device is connected using, for example, standard vendor ID and product ID values.","If a haptic feedback device of limited capabilities provides its descriptor to the host system, it may enumerate only a small number of reports. As a simple example, say the descriptor for the device only describes two reports: one is the position input report from the device to the host (describing a position or motion of a user manipulatable object) and the other is an output report received by the device that allows the host to command raw forces to the device actuators. If the emulation layer is operating in this system, then the descriptor for the device must be changed (before it is reported to operating system) to describe the further capabilities that are made possible through emulation. If the emulation layer is made flexible to handle multiple devices, then it can be required to build the new descriptor that is to be reported to the operating system. This new descriptor will need to combine the input report information (describing the device's actual position report) as well as the additional output reports (for the functionality that is handled by the emulation processor). Creating this descriptor will require that the emulation driver be able to extract at least a portion of the descriptor that is returned from the device in order to build the complete descriptor for the device that includes the emulated functionality. An alternative to this approach allows the emulation driver to generate the complete descriptor as it would have to do for devices that had no descriptor information, i.e., create a new descriptor regardless if the device already provides a (limited) descriptor. The emulation layer still needs to extract relevant information from the reported descriptor; or, a \u201chard coded\u201d descriptor (e.g. appropriate for the type of device, manufacturer, model, etc.) which is stored on the host accessible to the emulation driver can be used while ignoring any description information reported by the device.","Because of the significant architectural differences between desktop computers and the microcontrollers commonly used in peripherals such as interface devices, new methods for computing the force output are enabled. The microcontrollers that are commonly employed in most low cost computer peripherals tend to be under serious cost restrictions. Because of this, they are not only limited in their processing capabilities, but they are usually restricted to only a very small amount of data memory (RAM). In order to maximize the number of effects that the device can store and play, each effect must be described using only a small number of control parameters. For example, a period type of effect (say a sine wave) might be stored on the device as only the data for its magnitude, period, direction, duration, etc., rather than being stored as a series of points or values, which requires much more memory, From the stored parameters, the device computes the force value at each time step of its playback by knowing how much time has expired for the effect. While this functions correctly, the device will end up computing the same force values several different times if the effect is played for a time that is longer than its period.","The host system is not generally subject to the same constraints as the device microcontroller. In addition to having much more processing capacity, the host system also contains far more memory (RAM). This may allow the host processing to be more efficient. Instead of recalculating the same values multiple times (e.g. for each period of a periodic wave), the host can compute the repeated values once and store the result; a stored value can then be quickly retrieved for the next time it is required to be output or otherwise used. In order for this method to operate effectively, the effects that are being computed must be repetitive over time.","One way this computation\/storage can be handled is by performing the computations for each time step of the period as they occur during the first period of the effect playback, e.g. a cycle of computing a value, storing the value, and outputting the value to the device, and then doing the same for each successive value of the initial period. As subsequent periods of the effect are repeated, the stored values can be used to generate the output. An alternative approach would be to precompute and store one entire period of force values for the effect when the command to load the effect parameters is received from the host software. Then, during output, stored values are retrieved, even for the first period of the effect. This method can reduce the chance of the host missing an output period during the first effect period, but may significantly increase the time required to process the outbound message.","Another issue with this computation approach is that the processing for an effect may need to include some combination of retrieving a stored value for the given time step and a real time computation to get the final force output value. This would be the case, for example, when computing the output of a periodic effect that has an envelope applied. An envelope is a modification of a force effect based on a desired \u201cshape\u201d that the developer wishes to obtain, e.g. a ramp up and ramp down (fade out) at the begin and ends of a periodic waveform. While the frequency\/period of such a periodic effect remains the same, the envelope alters the magnitude of the effect, at different points in time during the effect. In such a case, the raw values used in the computation of the periodic output could be precomputed or stored during the first period of execution. However, if the effect had any significant duration, it would be very costly (in terms of memory requirements) to compute and store the force values for the entire effect.","While storing the force values for a single period of an effect will help reduce the processing load on the host system, there are also other methods that can be used to reduce the processing. One method is to have a variable computation rate for different effects, e.g. different types of effects (vibration vs. spring force, etc.), different frequencies. of effects, etc. For example, a high speed periodic effect, such as a 100 Hz sine wave, would require very rapid force computations in order to achieve high quality force output. However, a slower periodic (or other type) effect may not require such rapid computations. When processing an effect, the emulation layer can be designed to adapt its processing rate for each effect. For a slowly changing force effect, less computations can be made for every unit of tine, i.e., there can be more time elapsed between successive computations. This will result in a reduction of processing loading on the host system without a degradation in the output quality.","If the adaptive processing rate method is combined with the storage of samples for one effect period, the usage of memory on the host system can also be reduced. For example, say that a \u00bd Hz sine wave force is to be produced. If the output for this force were to be computed every millisecond, then 2,000 sampled points would be needed to define a single period of the effect. However, if a new force sample is computed only every 8 milliseconds, then only 250 samples need be computed and stored to describe the complete effect. In systems where the resolution of the force commands is low (say, 8 bit values), there would be no perceptible degradation in the quality of the force output. When the computation rate is changed for an effect, this rate must be kept track of for each effect in order to know for how long each force sample value should be applied.","With the possibility of force value streaming, a device is enabled that can handle two modes of functionality. In the first mode, the device would handle all of the effect processing. If a microcontroller used in the device is scaled back from those typically used in currently-available devices, then this device would potentially have reduced capabilities and performance from the current devices. Thus, for example, the device may have less memory and thus can output fewer effects at once and\/or fewer types of effects, and the force sensations that are output may have less quality or realism. However, in this mode, the processing requirements on the host computer would be minimized.","In the second mode of operation, the device can be enabled for hybrid operation. It is still enabled to handle all the effects processing that it could handle in the first mode, aid would also be able to accept streamed force information from the host system. The host emulation processor could then work to balance the force processing effectively between the host processor and the device. This can increase the quantity (in terms of the number of concurrent effects) and quality of the force output that is possible with the device. In some embodiments, the division of the processing between the host system and the device can be varied in this mode. This variation may be controlled automatically by the emulation driver (with the emulation driver capping its consumption of host processor usage), a different driver, or by a host application program, or through a user preference or software setting.","A central ability of the dual mode device is to be able to effectively balance the force processing distribution in such a way that the output quality is maximized while the impact on the host system performance is minimized. Some characteristics, parameters, and other aspects of the system that can be adjusted to achieve this balance include the time granularity of the effects output on the device (effects having less time per successive force output have greater resolution and greater quality but require more processing); the host processor loading (the host may be able to compute some or all of a particular type of force effect, relieving the device microprocessor but potentially adding delay and loss of quality); and device capability consideration (different devices have different capabilities and some may be able to particular effects better than other devices based on the hardware of the device). Some of these balancing methods, such as the time granularity of forces, could be balanced in all hybrid systems.","In some embodiments, the balancing can be performed automatically by lower level host software such as the emulation layer which can examine a device's capabilities using the descriptor or other information received from the device, examine current host processor loading, or other factors to arrive at a balancing level. Also, an application program or high level driver could handle the balancing. For example, a game program might only use certain types of effects which are simple and of generally high quality, and thus the processing loading on the host can be reduced. In addition, the balancing can be adjusted by the user through a software interface control panel or the like, where the user may desire a certain level of quality and host performance in a particular application or in general.","Another characteristic of the haptic feedback system that can be adjusted in some embodiments to balance processing is the period of the streaming data sent from host to device. The streaming data can, for example, be sent once per millisecond to the device to be output, or can be sent 8 times per millisecond. The smaller the period, the greater the fidelity and quality of the force sensations based on that data. To provide balancing, the host can preferably select one of a plurality of different periods at which to send the data, based on factors such as the processing load of the host and the capabilities of the device. For example, if the host is particularly burdened with processing at a particular time, then the emulation layer (or other driver) can select a longer period, thus causing lower quality haptic feedback to be output but reducing the processing burden on the host. On the other hand, if a particular system has a high bandwidth interface between host and device and the device is more sophisticated, then a lower period can be selected to increase the quality of haptic feedback. In some embodiments, a device can send information to the host to indicate at which speeds\/periods it may receive data, and the host driver can select from the available periods. Also, the host application and\/or user can in some embodiments select particular streaming periods or provide conditions to adjust the period.","Another feature that may be enabled by emulation processing is \u201ceffect caching.\u201d This type of caching allows the host computer to store some effects which have been commanded to be output to the device when the device's memory is full. Since the host usually has more memory thin the device, the host can store (cache) effects, at a low hierarchical level, which the device is not able to store and can send the cached effects to the device when they are to be played or output. In this scheme, the application program and other higher software levels believe that the cached effects have been created and stored on the device. This requires less memory to be provided on the device and reduces device cost. This method is described in greater detail in copending patent application Ser. No. 09\/305,872, which is incorporated herein by reference in its entirety. That application discussed implementing effect caching at a higher level than the preferred level for the emulation layer described herein; however, there may be some significant advantages to performing the actual implementation of effect caching at the lower level of the emulator; for example, there is less computational overhead when communicating with the device. If the emulator is implementing the effect caching, then the device preferably appears as \u201cdevice-managed\u201d (rather than using the host-managed method) to the operating system to easily allow the emulation layer to handle the processing for device effects as explained above.","Most of the following embodiments are related to gracefully handling the recovery for data transfer errors or crashes of the host system during haptic feedback operation.","When the host system is performing emulation for a haptic feedback device using a serial data bus to transfer the data, there is a strong possibility that some of the messages that are sent from the host to the device may be corrupted. When the device receives a corrupted packet, it has no choice but to reject any data that may be included in the message. This can happen to any type of transfer messages, but it represents a more significant issue when messages are transferred using an isochronous data channel. Since isochronous data channels are designed to favor timely delivery of messages as opposed to a guaranteed delivery without errors, messages sent on this channel are not resent if an error occurs.","Because of this lack of resending ability, there will be situations where the device needs to generate a force output for a new time step without having received new (or uncorrupted) data from the host system. There are several different methods the device can employ to generate a force on such occasions. One of the simplest methods to handle this is for the device to simply reuse the last force value it received. In many cases, this will work without a problem. If the time variance of the force output is slow relative to the period between force streaming values, then the force samples will be close to one another and the user will not detect that an error has occurred. However, if the force value is changing rapidly relative to the force steaming period, using this method will result in a discontinuity in the effect output. At a minimum, this will result in an incorrect effect output on the device. In addition, this behavior may actually decrease the stability of the system. For example, if an output force effect has a high frequency and a high magnitude, then missing samples can generate unintended longer periods in the output force waveform.","One alternative to outputting this discontinuity is to have the device extrapolate the force output based on the last series of force values it received. In this case, the device may be able to closely estimate the force values for those times that it receives corrupted data from the host system. This would help reduce the discontinuity of the force output on the device. For example, if the device were receiving successive values in an arithmetic or geometric series (or approximately so), the device could determine the next value in the series. Alternatively, especially if successive values are based on a more complex relationship, the host can transmit a delta value to the device, which the device applies as a time step (or adds to a time step) until a flew delta value is received from the host.","An alternate approach to handling missed or corrupted data transfers is to encode redundant data into each of the streaming data packets. If, for example, force output values with a period of 1 ms are streaming, then size of each packet that is sent can be doubled, and the force values for this millisecond as well as the force values for the next millisecond can be included in each packet. Then, if the message for the next millisecond were corrupted, the device would be able to use the data that was sent in the previous data packet to get the correct force output without discontinuity. This method is described in greater detail in U.S. Pat. No. 5,959,613, which is incorporated herein by reference in its entirety.","Another consideration when using force streaming is that the host system way experience a failure after it has commanded a force output to the device. When this happens, the device may be left in a state where the last command received from the host system commanded a non-zero output and the device will be generating a force output. Since no more commands will be received from the host system until it restarted, the output force may remain indefinitely. This can present safety problems for the user if the output force is strong, or present problems for the device, such as overheating of actuators.","In order to prevent this situation, the device may implement an internal timer that may only allow each force sample to remain active for a short period of time. As new streaming messages are received from the host system, this timer can be continually reset. As long as the timer period is longer than the actual period between received force samples, the device would continue to generate the force outputs. However, if this timer were to expire before a new force value is received, then the device would detect this as a communication failure with the host system and the force output would be terminated until new messages are received from the host system.","Furthermore, once communication is reestablished and force output resumed, the force can be \u201cramped\u201d up smoothly from a zero or low value to its original value to avoid any sudden jump in force magnitude to the user. Such a ramping force is described in greater detail in U.S. Pat. Nos. 5,734,373 and 5,691,898, both incorporated herein by reference in their entirety.","Some of the more complicated haptic feedback devices have relatively complicated kinematics, where complex mechanisms are required in order to generate efficient force output to the user. The kinematics equations allow motion of various members of a mechanical linkage connected to the user manipulandum to be translated into motion of the manipulandum in desired degrees of freedom, such as x, y, and z directions. For example, the mechanisms described in copending patent application Ser. No. 08\/965,720 is a relatively simple mechanism requiring kinematics. The mechanism described in U.S. Pat. No. 5,828,197 is a much more complicated device requiring complex kinematics.","One aspect of the device processing that would likely not shift to the host system or emulator is the kinematics processing. Instead, all the devices can handle their own kinematics computations and exchange data and commands with the host system using only Cartesian coordinates (or any other required coordinates). While this does require more local processing power for the microcontrollers on complex devices, the benefit of this approach is that the host software sees a uniform interface no matter what devices are connected to the systems.","While this invention has been described in terms of several preferred embodiments, it is contemplated that alterations, permutations and equivalents thereof will become apparent to those skilled in the art upon a reading of the specification and study of the drawings, Furthermore, certain terminology has been used for the purposes of descriptive clarity, and not to limit the present invention. It is therefore intended that the following appended claims include all such alterations, permutations, and equivalents as fall within the true spirit and scope of the present invention."],"GOVINT":[{},{}],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
