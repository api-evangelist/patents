---
title: Indexing and querying semi-structured data
abstract: Generating an inverted index is disclosed. Semi-structured data from a plurality of sources is parsed to extract structure from at least a portion of the semi-structured data. The inverted index is generated using the extracted structure. The inverted index includes a location identifier and a data type identifier for one or more entries of the inverted index.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09507848&OS=09507848&RS=09507848
owner: VMware, Inc.
number: 09507848
owner_city: Palo Alto
owner_country: US
publication_date: 20100923
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO OTHER APPLICATIONS","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application claims priority to U.S. Provisional Patent Application No. 61\/277,571 entitled INDEXING AND QUERYING SEMI-STRUCTURED DATA filed Sep. 25, 2009 which is incorporated herein by reference for all purposes.","Traditionally organizations have invested in systems that enable rapid access to structured data stored in database systems. However, structured data only represents a fraction of all information stored by an organization. It is often difficult to search, find, and analyze patterns in unstructured and semi-structured data using traditional tools. These types of data often cannot be managed efficiently and cost-effectively in traditional databases or in data warehouses that try to force a structure on to the unstructured and semi-structured data. When the unstructured or semi-structured data changes or becomes larger in size, it becomes difficult to maintain and scale traditional solutions. Organizations have also tried to utilize keyword search solutions, but its success has been limited by its inability to handle sophisticated pattern search analysis. Therefore, there exists a need for an efficient and scalable pattern search handling of unstructured or semi-structured data.","The invention can be implemented in numerous ways, including as a process; an apparatus; a system; a composition of matter; a computer program product embodied on a computer readable storage medium; and\/or a processor, such as a processor configured to execute instructions stored on and\/or provided by a memory coupled to the processor. In this specification, these implementations, or any other form that the invention may take, may be referred to as techniques. In general, the order of the steps of disclosed processes may be altered within the scope of the invention. Unless stated otherwise, a component such as a processor or a memory described as being configured to perform a task may be implemented as a general component that is temporarily configured to perform the task at a given time or a specific component that is manufactured to perform the task. As used herein, the term \u2018processor\u2019 refers to one or more devices, circuits, and\/or processing cores configured to process data, such as computer program instructions.","A detailed description of one or more embodiments of the invention is provided below along with accompanying figures that illustrate the principles of the invention. The invention is described in connection with such embodiments, but the invention is not limited to any embodiment. The scope of the invention is limited only by the claims and the invention encompasses numerous alternatives, modifications and equivalents. Numerous specific details are set forth in the following description in order to provide a thorough understanding of the invention. These details are provided for the purpose of example and the invention may be practiced according to the claims without some or all of these specific details. For the purpose of clarity, technical material that is known in the technical fields related to the invention has not been described in detail so that the invention is not unnecessarily obscured.","Enabling pattern search of unstructured and semi-structured data is disclosed. An example of semi-structured data includes data that may not conform to the formal structure of tables and data models of databases but is associated with tags, data types, metadata or other markers to identify semantic elements, information, and\/or hierarchies of records and\/or fields of the data. A semi-structured data from a plurality of sources are parsed to extract structure data, semantic elements, information, and\/or hierarchies from the semi-structured sources of data. An inverted index is generated using the extracted information. The inverted index includes a location and a data type for one or more entries of the inverted index and\/or one or more fields from the extracted information. A user may query the inverted index to analyze patterns associated with the unstructured and semi-structured data.","For example, in the context of technical support, support engineers may utilize the inverted index to improve support provided to customers. Typically when customers encounter problems, they send semi-structured support artifacts such as logs, configurations, scripts, code, system status, or performance statistics to the product vendor for diagnosis. These semi-structured data can be efficiently indexed in an inverted index, and the inverted index can be easily searched to analyze patterns associated with the support artifacts to provide efficient support. For example, an inverted index that includes data associated with new data can be queried using a signature query of a known problem to determine whether the new data is also associated with the know problem.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 1","FIG. 1"],"b":["104","110","112","108","108","104","110","112","108","104","106","106","110","112","104","104","106","106","104","110","112","104","104"]},"Application  utilizes index  to provide user desired functionality associated with index . For example, application  facilitates a user interface that can be used to query and view query results of index . In another example, application  facilitates data pattern search and\/or analysis using index . Application  accesses index  via data processor . For example, application  facilitates pattern searches and\/or analysis associated with unstructured and semi-structured data indexed by index  by querying index  via data processor . In some embodiments, application  directly queries index . In some embodiments, index  can be access by application  via an Application Programming Interface (API). For example, web services APIs allow users to build custom applications that use index .",{"@attributes":{"id":"p-0021","num":"0020"},"figref":["FIG. 2","FIG. 1","FIG. 2","FIG. 2","FIG. 1"],"b":["104","102","202","202","110","112"]},"At , the data to be indexed is parsed. In some embodiments, parsing the data includes extracting structure information from the received data. Examples of the extracted structure information include tags, data types, metadata, or other markers to identify semantic elements, structures, information, and\/or hierarchies of records and\/or fields of the data. In some embodiments, parsing the data includes converting at least a portion of the received data to an intermediate format before the data is indexed. Converting the data into the indeterminate format may include identifying data types associated with text elements of a semi-structured data by extracting structural information associated with the semi-structured data. In various embodiments, additional processing is performed on the received data. For example, the received data is automatically and dynamically analyzed while the data is being parsed to detect patterns, trends, commonalties and\/or differences.","At , an index is generated using information parsed at . In some embodiments, indexing includes organizing parsed data in a manner that facilitates pattern matching and\/or searching of semi-structured and unstructured data. In some embodiments, indexing the received data includes enabling terms of the semi-structured or unstructured data to be searched efficiently and associating a data structure\/type information and\/or data location information with one or more of the terms. In some embodiments, an inverted index is created at .","At , data is analyzed using the index. For example, a structured query of the index is processed and matching result(s) of the query is returned. In some embodiments, a structured query includes a constraint on data-type and value of an element of the index. In some embodiments, at least a portion of the process of  is performed in a distributed processing environment. For example, each of one or more worker processes\/systems process at least a portion of the processing required in  and\/or , and the processing result of these worker processes\/systems are managed\/combined by a master process\/system.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 3","FIG. 1","FIG. 3","FIG. 2","FIG. 3","FIG. 3","FIG. 2"],"b":["104","204","302","302","302","202","302","304","306"]},"If at  it is determined that the data is not associated with a preconfigured parser, at  at least a determined portion of the data is tested using a library of parse expressions to determine how to parse the data. In some embodiments, the received data is scanned to detect segments such as repeating patterns or logical groupings within the received data. At least one of these groupings\/segments is tested against each parse expression from a library of parse expressions to determine a parse expression that can be used to parse the grouping\/segment. For example, a log file includes multiple log messages, and each log message is tested against a library of parse expressions. A parse expression may match with a log message because the parse expression specifies that a matching log entry includes a timestamp, a message type, and a free text message body. Different parse expressions may match the log message depending upon log attributes or message fields in the free text message body of the log message.","If at  a matching parse expression is found, at  at least a portion of the received data is parsed using at least a portion of a parser associated with the matched parse expression. In some embodiments, the parser associated with the matching parse expression is the matching parse expression that can be used to parse at least a portion of the received data. In some embodiments, the parser associated with the matching parse expression is used to parse more than the data portion determined at . For example, once one log message is matched with a parse expression, other associated log messages may be parsed using the parser associated with the matched parse expression. A plurality of parsers and\/or parser portions may be associated with matched parse expression, and one or more of these parsers\/portions may be used to parse at least a portion of the received data.","In some embodiments, parsing the data at  and\/or at  includes extracting structure information from the received data. Examples of the structure information include tags, data types, metadata, or other markers to identify semantic elements, information, and\/or hierarchies of records and\/or fields of the data. In some embodiments, parsing the data includes converting at least a portion of the received data to an intermediate format before the data is indexed. Converting the data into the indeterminate format may include identifying data types associated with text elements of a semi-structured data by extracting structural information associated with the semi-structured data. In some embodiments, a parser uses a configuration file (e.g., eXtensible Markup Language based configuration file) to obtain information associated with parsing rules.","At , if it is determined that the entire received data has not been parsed, the process returns to  where at least a portion of the unparsed portion is tested against the library of parse expressions. At , if it is determined that the entire received data has been parsed, the process ends. At , if a parse expression match is not found, at , at least a portion of the received data is parsed using a standard parser. The standard parser may associate a generic tag, data type, marker, identifier, information, or hierarchy information with extracted information\/text of the received data. The data parsed by the standard parser may be unstructured data and\/or semi-structured that does not match any determined parse expression. In various embodiments, the standard parser is a generic parser that is able to parse any type of valid data to a desired form. After , the process returns to .",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 4A","FIG. 1","FIG. 4A","FIG. 2","FIG. 4A","FIG. 4A","FIG. 3","FIG. 1"],"b":["104","206","402","402","110","112"]},"At , an index is generated using the received parsed information. In some embodiments, generating the index includes organizing the parsed information in a manner that facilitates pattern matching\/searching. In some embodiments, elements of data to be indexed are broken into terms that are the basic unit of definable search patterns. For example, a log message \u201cmonitor target=159.170.100.80\u201d may be broken into three terms of \u201cmonitor\u201d, \u201ctarget\u201d, and \u201c159.170.100.80.\u201d In some embodiments, the index is an inverted index. For example, for each term in the previous example, an inverted list of log file identifiers that contain the term is created. In some embodiments, one or more instances of a term in the index is associated with structure information parsed from indexed data. For example, a data type and a position where the term appears in the log file are associated with each instance of the term. Other examples of structure information include tags, data types, metadata, semantic element identifiers, hierarchy information, and data attributes.","In some embodiments, the inverted index is associated with a sequence of documents. Each document is associated with a log file and assigned a unique document identifier. The document may contain one or more fields. Each field is further split into individual terms as appropriate. For example a term includes a text string. The inverted index stores mappings of terms to the documents that contain the term. In some embodiments, the inverted index includes for each term, a sorted list of document identifiers of documents that contain the term. In some embodiments, the inverted index includes for each term and each document, a sorted list of positions in the document that includes the term.","For example, three log files exist, and the files contain the following message.","Log File 1: System encountered fatal error.","Log File 2: Fatal system error: configuration error.","Log File 3: System configuration succeeded.","For the example above, the corresponding inverted index includes the following entries.",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Term (field = \u2018text\u2019)","List of Document Identifiers"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Configuration","1, 2"]},{"entry":[{},"Encountered","0"]},{"entry":[{},"Error","0, 1"]},{"entry":[{},"Fatal","0, 1"]},{"entry":[{},"Succeeded","2"]},{"entry":[{},"System","0, 1, 2"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},{},"Positions in Documents:"]},{"entry":[{},"Term (field = \u2018text\u2019)","doc (positions)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Configuration","doc 1 (2), doc 2 (1)"]},{"entry":[{},"Encountered","doc 0 (1)"]},{"entry":[{},"Error","doc 0 (3), doc 1 (2, 4)"]},{"entry":[{},"Fatal","doc 0 (2), doc 1 (0)"]},{"entry":[{},"Succeeded","doc 2 (0)"]},{"entry":[{},"System","doc 0 (0), doc 1 (1), doc 2 (0)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"To efficiently preserve information of which terms belong to the same log message, positions of the first terms of every message in the same document are aligned on fixed boundaries. With the boundary size known a priori, deciding whether occurrences of terms belong to the same log message requires one in-memory arithmetic operation. For example, a log file indexed as doc 0 includes the following.","Message 0: File system checking passed.","Message 1: Memory system checking failed.","If the position boundaries are multiples of 2048, the term positions in the inverted index would include the following.",{"@attributes":{"id":"p-0043","num":"0042"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},{},"Positions in Documents:"]},{"entry":[{},"Term (field = \u2018text\u2019)","doc (positions)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Checking","doc 0 (2, 2050)"]},{"entry":[{},"Failed","doc 0 (2051)"]},{"entry":[{},"File","doc 0 (0)"]},{"entry":[{},"Memory","doc 0 (2048)"]},{"entry":[{},"Passed","doc 0 (3)"]},{"entry":[{},"System","doc 0 (1, 2049)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"In embodiments, a same term is associated with a plurality of fields. The \u201ctext\u201d field is the default field. For example, in the following log files, the term \u201cerror\u201d appears in both the \u201cseverity\u201d field and the \u201ctext\u201d field.","Log File 1: [ERROR] file system fatal error.","Log File 2: [WARN] Failed to recover the fatal error.","The inverted index for the example above includes the following entries.",{"@attributes":{"id":"p-0047","num":"0046"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Term (field = \u2018severity\u2019)","List of Document Identifiers"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Error","0"]},{"entry":[{},"Warn","1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Term (field = \u2018text\u2019)","List of Document Identifiers"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Error","0, 1"]},{"entry":[{},". . .",". . ."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"In some cases, log messages contain fields that include numeric values (e.g., Timestamps of log messages). Indexing numeric values the same way as regular text fields may slow down range queries because all possible values that fall in the range would need to be searched. To speed up range queries of numeric fields, numeric field values are organized in a tree data structure. Each numeric value in the log message is indexed as multiple terms, and the terms become the root nodes of the tree.  is a chart shows tree data structure  for numerical terms , , , , , , , , , , , and . The root nodes include the numeric terms, and the intermediate nodes include successive beginning digit portions of the numeric terms. If a query seeks to find all numeric terms with values between  and , inclusive, only log messages with the four shaded terms as shown in tree data structure  of  need to searched rather than searching log messages with six terms (i.e., , , , , , and ) if the numeric values were just indexed as text.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 5A","FIGS. 1, 2, 3","FIG. 1","FIG. 5A","FIG. 2","FIG. 5A","FIG. 5A"],"b":["4","104","102","208","502","502"]},"At , the received query is translated into an index query. For example, the received structured search query is translated to a query form that can be processed by the index. In some embodiments, translating the received query includes checking the received query for errors. In some embodiments, translating the received query includes using a lexer to tokenize the received query and using a parser to map the received query to a grammar to be used to translate the received query to an index query form.","In various embodiments, translating the query includes first parsing the received query including by identifying a query item that specifies a pattern to be matched\/found. For example, the received query is parsed into a logic query tree with constraints. Each leaf of the tree represents an item constraint that may be composed of boolean sub-queries on one or multiple fields. A non-leaf node describes the relationship constraint among its children. To achieve better performance, the logic constraints of the received query is converted to a Disjunctive Normal Form of a logical formula and the constraints are reduced to the simplest form. For example, the received query is: SELECT*FROM*WHERE MESSAGE.text:\u201cscsi retry failed\u201d AS i & (MESSAGE.text:\u201creboot\u201d|MESSAGE.severity:\u201ccritical\u201d) AS j HAVING COUNT(i)>=2 & COUNT(j)>=1. This query is parsed into logic query tree  as shown in .","Second, each leaf node is converted to a boolean tree. Each leaf node is one sub-query on a single field, which is a simple inverted index query on a term or a phrase on a field. For the example above, the right child leaf for item j is converted to boolean query tree  as shown in .","Third, the inverted list is retrieved from the index for each term in each sub-query on a single field. For example, for a phrase sub-query MESSAGE.text:\u201cscsi retry failed\u201d, three inverted lists are retrieved from index for terms \u201cscsi\u201d, \u201cretry\u201d and \u201cfailed\u201d on field MESSAGE.text.","At , the index is queried using the translated index query. In some embodiments, querying the index includes sending the translated index query to a system and\/or processor (e.g., data processor  of ) associated with the index. In some embodiments, querying the index includes directly querying an index such as index  of . Processing the index query may include walking through elements of a sorted inverted index. For each term, a sorted position list is traversed to find a block of positions in which all terms of interest appear in a desired order. The sorted position list enables this search to be performed in a single pass through the index.","For example, candidate messages are found by walking through the inverted lists for the terms in an item boolean query tree, and it can be determined whether the terms belong to the same log message and a phrase based on the term positions stored in the index. In the meantime, the boolean relationship described in the item boolean tree, if any, is applied to the terms in the same log message. If the constraints are satisfied, the log message will become a candidate. Then, candidate logs are found. By walking through the candidate message lists, it can be determined whether the messages belong to the same log based on the term positions. Applying the constraints described in the logic query tree on the candidate messages from the same log, all log candidates can be found if the constraints are satisfied.","At , an index query result is received. In some embodiments, this result includes one or more of the following: identifier(s) associated with a file(s) and\/or location(s) of the data that matches the query, a copy of the data matches the query, structural information associated with the data matches query, other search results\/patterns related to the data matches the query and any other information associated with the data that matches the query.","At , at least a portion of the received result is returned to a user. For example, the query results displayed in a user interface that allows the user to efficiently identify a pattern associated with the received result.","In the context of technical customer support, the process of  can be used to efficiently trouble shoot user problems. For example, a higher tier support engineer can codify his or her knowledge into a signature query after resolving an issue. Next time a beginning tier support engineer receives an issue, the support engineer can check a semi-structured support artifact (e.g., error log or a configuration file) against the signature query by querying an index that contains the support artifact using the signature query. If a match is found against one of the signature structured queries, a solution associated with the matching signature query can be offered as a solution to the customer. In some cases, this process can be automated by generating a report when a support artifact is received. This report includes results of one or more results of a signature query against an index that includes the received support artifact. The report will indicate any matches for known signature queries and associated causes and solutions.","In some cases, information technology vendors collect data from systems in use. Using the parsing, indexing, and searching processes described above, the vendor can analyze the collected data efficiently. For example, a product manager can find out if a new feature in the latest release of the product is functioning properly by querying an index generated using data collected from users.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":["FIG. 6","FIG. 1","FIG. 2","FIG. 5A","FIG. 5A"],"b":["102","208","502","510","600","602","604","606","608","610","602"]},"In some embodiments, the query language described above is the Pattern Insight Query Language (PIQL). PIQL allows users to: query single-item pattern, using multiple conditions on item fields using Boolean logic, to query for multiple-item patterns; constrain the data source by specifying section names and log attributes; specify multiple types in conditions, including string, float and version; express patterns not only on whether an item occurs, but also on how many times it occurs; express multiple-item patterns on their temporal order; add a time-range constraint on patterns; and limit the scope of query results being returned.","Below is a chart summarizing PIQL Syntax clauses.",{"@attributes":{"id":"p-0064","num":"0063"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Clause","Syntax Example","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SELECT","SELECT*","Define the level of pattern"]},{"entry":[{},{},"matches retrieval."]},{"entry":["FROM","FROM messages, sys-config","Define the source to "]},{"entry":[{},{},"retrieve pattern "]},{"entry":[{},{},"matches from."]},{"entry":["WHERE","WHERE","Define the patterns."]},{"entry":[{},"messages.text:\u201ckernel\u201das i",{}]},{"entry":["HAVING","HAVING COUNT(i) > 5","Filter pattern matches on"]},{"entry":[{},{},"occurrence times and"]},{"entry":[{},{},"occurrence orders."]},{"entry":["TIME WINDOW","TIMEWINDOW 3600","Specify the time-range"]},{"entry":[{},{},"constraint on patterns."]},{"entry":["LIMIT","LIMIT 1, 9","Limit the scope of query"]},{"entry":[{},{},"results."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The SELECT, FROM and WHERE clauses of PIQL construct the basic form of query statement. The SELECT clause defines what will be returned from the query, the FROM clause defines from which sections query results are retrieved from, and the WHERE clause defines conditions on items and log attributes. The PIQL query in its basic form has the following syntax: SELECT what FROM sections WHERE pattern. In the SELECT clause, what can be \u201c*\u201d, which means the query will return results at item level. In the FROM clause, sections can be in the form of section [AS alias] [, section [AS alias]]* or use \u201c*\u201d to refer to all sections. Only these section names (and aliases) specified in the FROM clause can be used in the WHERE clause to define log pattern. In the WHERE clause, pattern is defined in a form of a tree using Boolean operators such as & (AND), | (OR) and &! (AND NOT). The following statement, for example, returns matches satisfying condtion1 and one of condtion2 and condition3: SELECT*FROM*WHERE condition1 & (condition2| condition3).","There three types of leaf conditions: item_condition, log_attribute_condition and section_attribute_condition. The item_condition specifies conditions at item-level; while the log_attribute_condition and the section_attribute_condition specify conditions at log-level and section-level, respectively. The item_condition is defined in form of a tree using Boolean operators. The following statement, for example, returns matched log items that satisfy both item_condition1 and item_condition2: SELECT*FROM*WHERE (item_condition1 & item_condition2) AS item_alias.","The leaf item_condition has syntax section.field compare_op value, where section must be included in the FROM clause and compare_op must be comparable with types of field and value. The following statement, for example, returns log items which are from section MESSAGES and have \u201creboot\u201d and \u201ckernel\u201d in their field text: SELECT*FROM*WHERE (MESSAGES.text:\u201creboot\u201d & MESSAGES.text:\u201ckernel\u201d) AS item1.","The log_attribute_condition has syntax ATTR(log_attribute) compare_op value, where compare_op must be comparable with types of log_attribute and value. The following statement, for example, returns log items which are from section MESSAGES and have \u201creboot\u201d and \u201ckernel\u201d in their field text: SELECT*FROM*WHERE (MESSAGES.text:\u201creboot\u201d & MESSAGES.text:\u201ckernel\u201d) AS item1 & ATTR(version)<VERSION(\u201c2.6\u201d). Furthermore, all matched log items must be from logs whose attribute version is lower than 2.6.","The section_attribute_condition has syntax ATTR(section, section_attribute) compare_op value, where section must be included in the FROM clause and compare_op must be comparable with types of section_attribute and value. The following statement, for example, returns log items which are from section MESSAGES and have \u201creboot\u201d and \u201ckernel\u201d in their field text: SELECT*FROM*WHERE (MESSAGES.text:\u201creboot\u201d & MESSAGES.text:\u201ckernel\u201d) AS item1 & ATTR(MESSAGES, system): \u201clinux\u201d. Furthermore, all matched log items must be from MESSAGES sections whose attribute system contains the string \u201clinux.\u201d","The HAVING clause is an optional part of a PIQL query, specifying filter on query matches. COUNT clause specifies filtering condition on item occurrence time while BEFORE clause specifies filtering condition on items. temporal order. The PIQL query with HAVING clause has the following syntax: SELECT what FROM sections WHERE pattern HAVING filter. The filter is defined in a form of a tree using Boolean operators such as & (AND), | (OR) and &! (AND NOT). The following statement, for example, returns matches filtered on filter1 and filter2: SELECT*FROM*WHERE pattern HAVING filler1 & filter2.","There are two types of leaf filters: COUNT filter and BEFORE filter. The COUNT filter has syntax COUNT(item_alias) compare_op value, where item_alias must be defined in one of Item clauses at the WHERE clause; compare_op must be one of <, <=, >, and >=; and value must be with type of integer. The following statement, for example, returns log items which are from section MESSAGES and have \u201creboot\u201d and \u201ckernel\u201d in their field text: SELECT*FROM*WHERE (MESSAGES.text:\u201creboot\u201d & MESSAGES.text:\u201ckernel\u201d) AS item1 HAVING COUNT(item1)>3. Furthermore, the log item must appear for more than 3 times within the same log file.","The BEFORE filter has syntax BEFORE(item_alias1, item_alias2). The following statement, for example, returns two-item log patterns which are from section MESSAGES and have \u201cpanic\u201d and \u201creboot\u201d in their field text, respectively: SELECT*FROM*WHERE MESSAGES.text:\u201cpanic\u201d AS item1 & MESSAGES.text:\u201creboot\u201d AS item2 HAVING BEFORE(item1, item2). Furthermore, the log item has \u201cpanic\u201d must be temporally ahead of the log item has \u201creboot.\u201d","Optionally, BEFORE filter can specify minimal distance between two items, using syntax BEFORE(item_alias1, item_alias2,minDistance). The following statement, for example, requires minimal distance between any appearances of the two items to be at least 5 minutes (inclusive) in addition to requirements mentioned above: SELECT*FROM*WHERE MESSAGES.text:\u201cpanic\u201d AS item1 & MESSAGES.text:\u201creboot\u201d AS item2 HAVING BEFORE(item1, item2, 300).","The TIMEWINDOW clause is an optional part of a PIQL query, specifying time range (exclusive) of log patterns. Without the TIMEWINDOW clause, the default time range is the whole log file. The PIQL query with TIMEWINDOW clause has the following syntax: SELECT what FROM sections WHERE pattern TIMEWINDOW seconds.","The LIMIT clause is an optional part of a PIQL query, specifying the range of log pattern matches to be returned. Without the LIMIT clause, the first 10 log pattern matches are returned. The PIQL query with LIMIT clause has the following syntax: SELECT what FROM sections WHERE pattern LIMIT start, length.","The following table summarizes supported types and corresponding operations in the WHERE clause.",{"@attributes":{"id":"p-0077","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Type","Operators","Syntax Example"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"String",":","MESSAGES.text:\u201creboot\u201d"]},{"entry":[{},"Long",">, <, >=, <=, =","MESSAGES.retryCount >= 5"]},{"entry":[{},"Version",">, <, >=, <=, =","ATTR(kernelVer) <="]},{"entry":[{},{},{},"VERSION(\u201c2.6\u201d)"]},{"entry":[{},"Timestamp",">, <, >=, <=, =","ATTR(logTime) <="]},{"entry":[{},{},{},"\u20188\/31\/2009 12:00:00\u2019"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Below are examples of PIQL queries.\n\n","Although the foregoing embodiments have been described in some detail for purposes of clarity of understanding, the invention is not limited to the details provided. There are many alternative ways of implementing the invention. The disclosed embodiments are illustrative and not restrictive."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Various embodiments of the invention are disclosed in the following detailed description and the accompanying drawings.",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4C"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 5B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5C"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
