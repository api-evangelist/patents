---
title: Estimating sample-domain distortion in the transform domain with rounding compensation
abstract: Techniques and tools are described for compensating for rounding when estimating sample-domain distortion in the transform domain. For example, a video encoder estimates pixel-domain distortion in the transform domain for a block of transform coefficients after compensating for rounding in the DC coefficient of the block. In this way, the video encoder improves the accuracy of pixel-domain distortion estimation but retains the computational advantages of performing the estimation in the transform domain. Rounding compensation includes, for example, looking up an index (from a de-quantized transform coefficient) in a rounding offset table to determine a rounding offset, then adjusting the coefficient by the offset. Other techniques and tools described herein are directed to creating rounding offset tables and encoders that make encoding decisions after considering rounding effects that occur after an inverse frequency transform on de-quantized transform coefficient values.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08059721&OS=08059721&RS=08059721
owner: Microsoft Corporation
number: 08059721
owner_city: Redmond
owner_country: US
publication_date: 20060407
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["Digital video consumes large amounts of storage and transmission capacity. A typical raw digital video sequence includes 15 or 30 frames per second. Each frame can include tens or hundreds of thousands of pixels (also called pels), where each pixel represents a tiny element of the picture. In raw form, a computer commonly represents a pixel as a set of three samples totaling 24 bits. Thus, the number of bits per second, or bit rate, of a typical raw digital video sequence may be 5 million bits per second or more.","Many computers and computer networks lack the resources to process raw digital video. For this reason, engineers use compression (also called coding or encoding) to reduce the bit rate of digital video. Compression decreases the cost of storing and transmitting video by converting the video into a lower bit rate form. Decompression (also called decoding) reconstructs a version of the original video from the compressed form. A \u201ccodec\u201d is an encoder\/decoder system. Compression can be lossless, in which the quality of the video does not suffer, but decreases in bit rate are limited by the inherent amount of variability (sometimes called entropy) of the video data. Or, compression can be lossy, in which the quality of the video suffers, but achievable decreases in bit rate are more dramatic. Lossy compression is often used in conjunction with lossless compression\u2014the lossy compression establishes an approximation of information, and the lossless compression is applied to represent the approximation.","A basic goal of lossy compression is to provide good rate-distortion performance. So, for a particular bit rate, an encoder attempts to provide the highest quality of video. Or, for a particular level of quality\/fidelity to the original video, an encoder attempts to provide the lowest bit rate encoded video. In practice, considerations such as encoding time, encoding complexity, encoding resources, decoding time, decoding complexity, decoding resources, overall delay, and\/or smoothness in quality\/bit rate changes also affect decisions made in codec design as well as decisions made during actual encoding.","In general, video compression techniques include \u201cintra-picture\u201d compression and \u201cinter-picture\u201d compression. Intra-picture compression techniques compress individual pictures, and inter-picture compression techniques compress pictures with reference to a preceding and\/or following picture (often called a reference or anchor picture) or pictures.","I. Intra Compression",{"@attributes":{"id":"p-0006","num":"0005"},"figref":["FIG. 1","FIG. 1"],"b":["105","110","105","120","115","125"]},"With quantization, the encoder essentially trades off quality and bit rate. More specifically, quantization can affect the fidelity with which the transform coefficients are encoded, which in turn can affect bit rate. Coarser quantization tends to decrease fidelity to the original transform coefficients as the coefficients are more coarsely approximated. Bit rate also decreases, however, when decreased complexity can be exploited with lossless compression. Conversely, finer quantization tends to preserve fidelity and quality but result in higher bit rates.","Different encoders use different parameters for quantization. In most encoders, a level or step size of quantization is set for a block, picture, or other unit of video. In some encoders, the encoder can also adjust the \u201cdead zone,\u201d which is the range of values around zero that are approximated as zero. Some encoders quantize coefficients differently within a given block, so as to apply relatively coarser quantization to perceptually less important coefficients, and a quantization matrix can be used to indicate the relative weights. Or, apart from the rules used to reconstruct quantized values, some encoders vary the thresholds according to which values are quantized so as to quantize certain values more aggressively than others.","Returning to , further encoding varies depending on whether a coefficient is a DC coefficient (the lowest frequency coefficient shown as the top left coefficient in the block ()), an AC coefficient in the top row or left column in the block (), or another AC coefficient. The encoder typically encodes the DC coefficient () as a differential from the reconstructed DC coefficient () of a neighboring 8\u00d78 block. The encoder entropy encodes () the differential. The entropy encoder can encode the left column or top row of AC coefficients as differentials from AC coefficients a corresponding left column or top row of a neighboring 8\u00d78 block. The encoder scans () the 8\u00d78 block () of predicted, quantized AC coefficients into a one-dimensional array (). The encoder then entropy encodes the scanned coefficients using a variation of run\/level coding ().","In corresponding decoding, a decoder produces a reconstructed version of the original 8\u00d78 block. The decoder entropy decodes the quantized transform coefficients, scanning the quantized coefficients into a two-dimensional block, and performing AC prediction and\/or DC prediction as needed. The decoder inverse quantizes the quantized transform coefficients of the block and applies an inverse frequency transform (such as an inverse DCT (\u201cIDCT\u201d)) to the de-quantized transform coefficients, producing the reconstructed version of the original 8\u00d78 block. When a picture is used as a reference picture in subsequent motion compensation (see below), an encoder also reconstructs the picture.","II. Inter Compression","Inter-picture compression techniques often use motion estimation and motion compensation to reduce bit rate by exploiting temporal redundancy in a video sequence. Motion estimation is a process for estimating motion between pictures. In one common technique, an encoder using motion estimation attempts to match a block of samples in a current picture with a block of samples in a search area in another picture, called the reference picture. When the encoder finds an exact or \u201cclose enough\u201d match in the search area in the reference picture, the encoder parameterizes the change in position of the blocks as motion data (such as a motion vector). In general, motion compensation is a process of reconstructing pictures from reference picture(s) using motion data.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":["FIG. 2","FIG. 2"],"b":["215","210","235","230","235","215","210"]},"The encoder computes the sample-by-sample difference between the current unit and the predictor to determine a residual (also called error signal). The residual is frequency transformed, quantized, and entropy encoded. The overall bit rate of a predicted picture depends in large part on the bit rate of residuals. The bit rate of residuals is low if the residuals are simple (i.e., due to motion estimation that finds exact or good matches) or lossy compression drastically reduces the complexity of the residuals. Bits saved with successful motion estimation can be used to improve quality elsewhere or reduce overall bit rate. On the other hand, the bit rate of complex residuals can be higher, depending on the degree of lossy compression applied to reduce the complexity of the residuals.","Encoders typically spend a large proportion of encoding time performing motion estimation, attempting to find good matches and thereby improve rate-distortion performance. In most scenarios, however, an encoder lacks the time or resources to check every possible motion vector for every block or macroblock to be encoded. The encoder therefore uses motion vector search patterns and matching heuristics deemed likely to find a good match in an acceptable amount of time.","The number of motion vectors used to represent a picture can also affect rate-distortion performance. Using four motion vectors for four different 8\u00d78 blocks of a 16\u00d716 macroblock (instead of one motion vector for the macroblock) allows an encoder to capture different motion for the different blocks, potentially resulting in better matches. On the other hand, motion vector information for four motion vectors (instead of one) is signaled, increasing bit rate of motion data.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3","b":["335","315","325"]},"The encoder applies a frequency transform () to the residual (), producing a block of transform coefficients (). Some encoders switch between different sizes of transforms, e.g., an 8\u00d78 transform, two 4\u00d78 transforms, two 8\u00d74 transforms, or four 4\u00d74 transforms for an 8\u00d78 prediction residual block. Smaller transform sizes allow for greater isolation of transform coefficients having non-zero values, but generally require more signaling overhead.  shows the encoder using one 8\u00d78 transform.","The encoder quantizes () the transform coefficients () and scans () the quantized coefficients () into a one-dimensional array () such that coefficients are generally ordered from lowest frequency to highest frequency. The encoder entropy codes the data in the array ().","If a predicted picture is used as a reference picture for subsequent motion compensation, the encoder reconstructs the predicted picture. When reconstructing residuals, the encoder reconstructs transform coefficients that were quantized and performs an inverse frequency transform. The encoder performs motion compensation to compute the motion-compensated predictors, and combines the predictors with the residuals. During decoding, a decoder typically entropy decodes information and performs analogous operations to reconstruct residuals, perform motion compensation, and combine the predictors with the reconstructed residuals.","III. Computing Pixel-domain Distortion When Making Encoding Decisions","The previous two sections mention some of the decisions that an encoder can make during encoding. When encoding a block of a predicted picture, an encoder can evaluate and set a number of coding parameters, including: (1) whether the block should be encoded as an intra or inter; (2) the number of motion vectors; (3) the value(s) of motion vector(s); (4) the type of frequency transform; (5) the size of frequency transform (e.g., 8\u00d78, 4\u00d78, 8\u00d74, or 4\u00d74); (6) the quantization step size; (7) the quantization thresholds to apply; (8) the dead zone size; and (9) the quantization matrix. Or, for a block of an intra-coded picture, the encoder can evaluate and set various quantization-related parameters. Depending on implementation, an encoder may finalize certain parameter decisions before starting to evaluate other parameters. Or, the encoder may jointly explore different combinations of coding parameters, which makes the decision-making process even more complex given the number of permutations to evaluate.","In making encoding decisions, an encoder often evaluates the distortion and rate associated with the different choices. In particular, for a block to be encoded, pixel-domain distortion of the block encoded according to different coding choices is an important criterion in encoder mode decisions. There are several approaches to determining pixel-domain distortion.","In one approach, an encoder performs inverse quantization to reconstruct transform coefficients for a block and performs an inverse frequency transform on the de-quantized transform coefficients. The encoder directly measures pixel-domain distortion by comparing the reconstructed pixel-domain values for the block to the original pixel-domain values for the block. While this approach yields accurate pixel-domain distortion measurements, it is expensive in terms of encoding time and resources. Performing an inverse frequency transform for every evaluated coding choice greatly increases the computational complexity of the encoding task. As a result, encoding time increases or more encoding resources are required. Or, to handle practical time or resource constraints, an encoder evaluates fewer coding options, which can result in the encoder missing efficient options.","In another approach, an encoder performs inverse quantization to reconstruct transform coefficients for a block but measures distortion in the transform domain. The encoder measures transform-domain distortion by comparing the de-quantized transform coefficients for the block to the original transform coefficients for the block. To estimate pixel-domain distortion for the block, the encoder can multiply the transform-domain distortion by a scale factor that depends on the frequency transform used. If the transform is orthogonal, the encoder multiplies the transform-domain distortion by a non-zero scale factor so that the energy in the transform domain is roughly equivalent to the energy in the pixel domain. In this approach, the encoder does not perform an inverse frequency transform for every evaluated coding choice, so computational complexity is lowered. The pixel-domain distortion estimated by this approach is often inaccurate, however, particularly when only the DC coefficient of a block has a significant value. This inaccuracy in pixel-domain distortion estimation can lead to inefficient choices of coding parameters and poor rate-distortion performance.","Given the critical importance of video compression to digital video, it is not surprising that video compression is a richly developed field. Whatever the benefits of previous video compression techniques, however, they do not have the advantages of the following techniques and tools.","The present application is directed to techniques and tools for compensating for rounding when estimating sample-domain distortion in the transform domain. For example, a video encoder estimates pixel-domain distortion in the transform domain for a block of transform coefficients after compensating for rounding effects in the DC coefficient of the block. In this way, the video encoder improves the accuracy of the pixel-domain distortion estimation but retains the computational advantages of performing the estimation in the transform domain.","According to a first aspect of the described techniques and tools, a tool such as a video encoder compensates for rounding in a coefficient of a set of transform coefficients. The tool estimates sample-domain distortion using the rounding-compensated coefficient and other transform coefficients of the set. The tool then makes a decision based on the estimated distortion and outputs results.","For example, a video encoder compensates for rounding by looking up a table index (determined from a DC coefficient of a block of de-quantized transform coefficients) in a rounding offset table to determine a rounding offset, then adjusting the DC coefficient by the rounding offset. When estimating distortion, the encoder computes the difference between the original DC coefficient and the rounding-compensated DC coefficient. The encoder eventually selects between intra and inter encoding for the block based upon distortion estimates.","According to a second aspect of the described techniques and tools, an encoder includes a frequency transformer, a quantizer, an entropy encoder, an inverse quantizer and a controller. The controller makes encoding decisions after considering post-inverse frequency transform rounding effects on de-quantized transform coefficient values.","According to a third aspect of the described techniques and tools, a range of values for a de-quantized transform coefficient is identified. A rounding offset is computed for each of multiple values in the range. A periodic pattern in the offsets is identified, and representative values are mapped to corresponding rounding offsets in an offset table. The corresponding rounding offsets show at least one period of the pattern without the table including all values in the range. In this way, table size is reduced. The table is stored in computer storage or elsewhere. For example, the offset table is created off-line and distributed with a video encoder for use during video encoding.","This summary introduces a selection of concepts in a simplified form. The concepts are further described below in the detailed description. This summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used to limit the scope of the claimed subject matter.","The foregoing and other objects, features, and advantages will become more apparent from the following detailed description, which proceeds with reference to the accompanying figures.","The present application relates to techniques and tools for estimating sample-domain distortion in the transform domain with rounding compensation. In various described embodiments, a video encoder incorporates techniques for estimating pixel-domain distortion in the transform domain with rounding compensation.","Various alternatives to the implementations described herein are possible. For example, certain techniques described with reference to flowchart diagrams can be altered by changing the ordering of stages shown in the flowcharts, by repeating or omitting certain stages, etc. The various techniques and tools described herein can be used in combination or independently. Different embodiments implement one or more of the described techniques and tools. Aside from uses in video encoding, sample-domain distortion estimation in the transform domain with rounding compensation can be used in image encoding, video transcoding, image classification, or other areas.","Some of the techniques and tools described herein address one or more of the problems noted in the Background. Typically, a given technique\/tool does not solve all such problems. Rather, in view of constraints and tradeoffs in encoding time, resources, and\/or quality, the given technique\/tool improves encoding performance for a particular implementation or scenario.","I. Computing Environment",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 4","b":["400","400"]},"With reference to , the computing environment () includes at least one processing unit () and memory (). In , this most basic configuration () is included within a dashed line. The processing unit () executes computer-executable instructions and may be a real or a virtual processor. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power. The memory () may be volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory, etc.), or some combination of the two. The memory () stores software () implementing an encoder with one or more of the described techniques and tools for sample-domain distortion estimation in the transform domain with rounding compensation.","A computing environment may have additional features. For example, the computing environment () includes storage (), one or more input devices (), one or more output devices (), and one or more communication connections (). An interconnection mechanism (not shown) such as a bus, controller, or network interconnects the components of the computing environment (). Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment (), and coordinates activities of the components of the computing environment ().","The storage () may be removable or non-removable, and includes magnetic disks, magnetic tapes or cassettes, CD-ROMs, DVDs, or any other medium which can be used to store information and which can be accessed within the computing environment (). The storage () stores instructions for the software () implementing the video encoder.","The input device(s) () may be a touch input device such as a keyboard, mouse, pen, or trackball, a voice input device, a scanning device, or another device that provides input to the computing environment (). For audio or video encoding, the input device(s) () may be a sound card, video card, TV tuner card, or similar device that accepts audio or video input in analog or digital form, or a CD-ROM or CD-RW that reads audio or video samples into the computing environment (). The output device(s) () may be a display, printer, speaker, CD-writer, or another device that provides output from the computing environment ().","The communication connection(s) () enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer-executable instructions, audio or video input or output, or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired or wireless techniques implemented with an electrical, optical, RF, infrared, acoustic, or other carrier.","The techniques and tools can be described in the general context of computer-readable media. Computer-readable media are any available media that can be accessed within a computing environment. By way of example, and not limitation, with the computing environment (), computer-readable media include memory (), storage (), communication media, and combinations of any of the above.","The techniques and tools can be described in the general context of computer-executable instructions, such as those included in program modules, being executed in a computing environment on a target real or virtual processor. Generally, program modules include routines, programs, libraries, objects, classes, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer-executable instructions for program modules may be executed within a local or distributed computing environment.","For the sake of presentation, the detailed description uses terms like \u201cdecide\u201d and \u201canalyze\u201d to describe computer operations in a computing environment. These terms are high-level abstractions for operations performed by a computer, and should not be confused with acts performed by a human being. The actual computer operations corresponding to these terms vary depending on implementation.","II. Generalized Video Encoder",{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 5","b":["500","500","505","595"]},"The encoder () processes video pictures. The term picture generally refers to source, coded or reconstructed image data. For progressive video, a picture is a progressive video frame. For interlaced video, a picture may refer to an interlaced video frame, the top field of the frame, or the bottom field of the frame, depending on the context. The encoder () is block-based and use a 4:2:0 macroblock format for frames, with each macroblock including four 8\u00d78 luminance blocks (at times treated as one 16\u00d716 macroblock) and two 8\u00d78 chrominance blocks. For fields, the same or a different macroblock organization and format may be used. The 8\u00d78 blocks may be further sub-divided at different stages, e.g., at the frequency transform and entropy encoding stages. The encoder () can perform operations on sets of samples of different size or configuration than 8\u00d78 blocks and 16\u00d716 macroblocks. Alternatively, the encoder () is object-based or uses a different macroblock or block format.","Returning to , the encoder system () compresses predicted pictures and intra-coded, key pictures. For the sake of presentation,  shows a path for key pictures through the encoder system () and a path for predicted pictures. Many of the components of the encoder system () are used for compressing both key pictures and predicted pictures. The exact operations performed by those components can vary depending on the type of information being compressed.","A predicted picture (e.g., progressive P-frame or B-frame, interlaced P-field or B-field, or interlaced P-frame or B-frame) is represented in terms of prediction from one or more other pictures (which are typically referred to as reference pictures or anchors). A prediction residual is the difference between predicted information and corresponding original information. In contrast, a key picture (e.g., progressive I-frame, interlaced I-field, or interlaced I-frame) is compressed without reference to other pictures.","If the current picture () is a predicted picture, a motion estimator () estimates motion of macroblocks or other sets of samples of the current picture () with respect to one or more reference pictures. The picture store () buffers a reconstructed previous picture () for use as a reference picture. When multiple reference pictures are used, the multiple reference pictures can be from different temporal directions or the same temporal direction. The encoder system () can use the separate stores () and () for multiple reference pictures.","The motion estimator () can estimate motion by full-sample, \u00bd-sample, \u00bc-sample, or other increments, and can switch the precision of the motion estimation on a picture-by-picture basis or other basis. The motion estimator () (and compensator ()) also can switch between types of reference picture sample interpolation (e.g., between bicubic and bilinear) on a per-picture or other basis. The precision of the motion estimation can be the same or different horizontally and vertically. The motion estimator () outputs as side information motion information () such as differential motion vector information. The encoder () encodes the motion information () by, for example, computing one or more motion vector predictors for motion vectors, computing differentials between the motion vectors and motion vector predictors, and entropy coding the differentials. To reconstruct a motion vector, a motion compensator () combines a motion vector predictor with differential motion vector information.","The motion compensator () applies the reconstructed motion vectors to the reconstructed (reference) picture(s) () when forming a motion-compensated current picture (). The difference (if any) between a block of the motion-compensated current picture () and corresponding block of the original current picture () is the prediction residual () for the block. During later reconstruction of the current picture, reconstructed prediction residuals are added to the motion compensated current picture () to obtain a reconstructed picture that is closer to the original current picture (). In lossy compression, however, some information is still lost from the original current picture (). Alternatively, a motion estimator and motion compensator apply another type of motion estimation\/compensation.","A frequency transformer () converts spatial domain video information into frequency domain (i.e., spectral, transform) data. For block-based video pictures, the frequency transformer () applies a DCT, variant of DCT, or other forward block transform to blocks of the samples or prediction residual data, producing blocks of frequency transform coefficients. Alternatively, the frequency transformer () applies another conventional frequency transform such as a Fourier transform or uses wavelet or sub-band analysis. The frequency transformer () may apply an 8\u00d78, 8\u00d74, 4\u00d78, 4\u00d74 or other size frequency transform.","A quantizer () then quantizes the blocks of transform coefficients. The quantizer () applies uniform, scalar quantization to the spectral data with a step-size that varies on a picture-by-picture basis or other basis. The quantizer () can also apply another type of quantization to the spectral data coefficients, for example, a non-uniform, vector, or non-adaptive quantization. In addition to adaptive quantization, the encoder () can use frame dropping, adaptive filtering, or other techniques for rate control.","When a reconstructed current picture is needed for subsequent motion estimation\/compensation, an inverse quantizer () performs inverse quantization on the quantized spectral data coefficients. An inverse frequency transformer () performs an inverse frequency transform, producing blocks of reconstructed prediction residuals (for a predicted picture) or samples (for a key picture). If the current picture () was a key picture, the reconstructed key picture is taken as the reconstructed current picture (not shown). If the current picture () was a predicted picture, the reconstructed prediction residuals are added to the motion-compensated predictors () to form the reconstructed current picture. One or both of the picture stores (, ) buffers the reconstructed current picture for use in subsequent motion-compensated prediction. In some embodiments, the encoder applies a de-blocking filter to the reconstructed frame to adaptively smooth discontinuities and other artifacts in the picture.","The entropy coder () compresses the output of the quantizer () as well as certain side information (e.g., motion information (), quantization step size). Typical entropy coding techniques include arithmetic coding, differential coding, Huffman coding, run length coding, LZ coding, dictionary coding, and combinations of the above. The entropy coder () typically uses different coding techniques for different kinds of information, and can choose from among multiple code tables within a particular coding technique.","The entropy coder () provides compressed video information () to the multiplexer (\u201cMUX\u201d) (). The MUX () may include a buffer, and a buffer level indicator may be fed back to a controller. Before or after the MUX (), the compressed video information () can be channel coded for transmission over the network. The channel coding can apply error detection and correction data to the compressed video information ().","A controller (not shown) receives inputs from various modules such as the motion estimator (), frequency transformer (), quantizer (), inverse quantizer (), entropy coder (), and buffer (). The controller evaluates intermediate results during encoding, for example, estimating distortion and performing other rate-distortion analysis. The controller works with modules such as the motion estimator (), frequency transformer (), quantizer (), and entropy coder () to set and change coding parameters during encoding. When an encoder evaluates different coding parameter choices during encoding, the encoder may iteratively perform certain stages (e.g., quantization and inverse quantization) to evaluate different parameter settings. The encoder may set parameters at one stage before proceeding to the next stage. Or, the encoder may jointly evaluate different coding parameters, for example, jointly making an intra\/inter block decision and selecting motion vector values, if any, for a block. The tree of coding parameter decisions to be evaluated, and the timing of corresponding encoding, depends on implementation.","The relationships shown between modules within the encoder () indicate general flows of information in the encoder; other relationships are not shown for the sake of simplicity. In particular,  usually does not show side information indicating the encoder settings, modes, tables, etc. used for a video sequence, picture, macroblock, block, etc. Such side information, once finalized, is sent in the output bitstream, typically after entropy encoding of the side information.","Particular embodiments of video encoders typically use a variation or supplemented version of the generalized encoder (). Depending on implementation and the type of compression desired, modules of the encoder can be added, omitted, split into multiple modules, combined with other modules, and\/or replaced with like modules. For example, the controller can be split into multiple controller modules associated with different modules of the encoder. In alternative embodiments, encoders with different modules and\/or other configurations of modules perform one or more of the described techniques.","III. Estimating Sample-domain Distortion with Rounding Compensation","Techniques and tools described herein provide ways to estimate sample-domain distortion accurately in the transform domain. In particular, an encoder or other tool estimates sample-domain distortion using transform coefficients, after compensating for at least some of the rounding that would occur following an inverse frequency transform.","A. Theory and Explanation","When selecting certain coding parameters, an encoder evaluates the distortion and\/or rate associated with different coding parameter choices in order to improve rate-distortion performance. In particular, pixel-domain distortion is an important factor in encoding decisions in many systems. The pixel-domain distortion for a block is based on differences between original sample values for the block and reconstructed sample values for the block. As such, the pixel-domain distortion reflects fidelity changes from throughout encoding (e.g., from quantization) and reconstruction (e.g., from rounding after an inverse frequency transform).","One problem with computing distortion in the sample domain is that fully reconstructing sample values requires an inverse frequency transform. This adds a small computational cost every time a coding parameter or combination is evaluated with pixel-domain distortion measurement. Even if the cost of performing a single inverse frequency transform is small, in the aggregate, the computational cost becomes significant.","One way to avoid the cost of performing an inverse frequency transform per distortion measurement is to estimate pixel-domain distortion in the transform domain, with reference to transform coefficients. By speeding up estimation, a particular set of coding parameters can be evaluated more quickly, or more coding parameters can be evaluated within a particular duration of time. Such transform-domain estimations are inaccurate in many cases, however, in that they do not correlate well with corresponding pixel-domain distortion measurements, even when scaling factors compensate for differences in pixel-domain energy and transform-domain energy.","For example, suppose an encoder frequency transforms an 8\u00d78 block of uniform sample values (all \u201c1\u201d) into the following 8\u00d78 block of transform coefficients.",{"@attributes":{"id":"p-0074","num":"0073"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mn":"7"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]}]}},"mo":"."}},{"mrow":{"mo":["(",")"],"mi":"a"}}]}}}}},"Following quantization and inverse quantization, suppose the 8\u00d78 block of transform coefficients has the following de-quantized values.",{"@attributes":{"id":"p-0076","num":"0075"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mn":"5"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]}]}},"mo":"."}},{"mrow":{"mo":["(",")"],"mi":"b"}}]}}}}},"If the encoder estimates pixel-domain distortion using the transform coefficients of blocks (a) and (b), the difference in DC coefficient values indicates distortion has been introduced. This might not correlate with pixel-domain distortion, however. Suppose that when the encoder applies an inverse frequency transform to block (b), due to rounding effects after the inverse frequency transform, an 8\u00d78 block of uniform sample values (all \u201c1\u201d) is reconstructed. In that case, effectively no pixel-domain distortion has been introduced, contrary to the estimate of pixel-domain distortion made using only the transform coefficients.","Depending on the distortion metric used, block (b) might be even considered less favorable than another block such as:",{"@attributes":{"id":"p-0079","num":"0078"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mn":"7"},{"mn":"1"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]},{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"},{"mn":"0"}]}]}},"mo":"."}},{"mrow":{"mo":["(",")"],"mi":"c"}}]}}}}},"If the encoder applies an inverse frequency transform to block (c), however, the 8\u00d78 block may have non-uniform sample values due to the effect of the non-zero AC coefficient. This shows another mismatch between estimated and actual pixel-domain distortion values.","In many implementations, after an encoder performs an integer forward frequency transform, the results of the transform are not normalized completely. In other words, the intermediate representation of information has a higher resolution than the original representation. This allows the encoder to retain precision in intermediate results. Although rounding may occur in the intermediate results after the forward integer transform, the rounding often is insignificant in absolute terms and relative to subsequent quantization. After the encoder or a decoder performs the integer inverse frequency transform, however, rounding effects are typically much more significant. After the inverse transform, results are returned to the resolution of the original representation, which can include normalization to account for retained precision\/expansion from the forward transform as well as expansion from the inverse transform.","More formally, suppose {circumflex over (X)} represents de-quantized transform coefficients for a block, and {circumflex over (x)} represents the inverse frequency transformed de-quantized transform coefficients, T({circumflex over (X)}). The de-quantized transform coefficients are not necessarily the same as the transform of {circumflex over (x)}. For example, {circumflex over (X)}does not equal T(T({circumflex over (X)})). Due to rounding effects, distortion calculated in the transform domain using de-quantized transform coefficient values {circumflex over (X)} and original transform coefficient values X is biased and may lead the encoder to make a wrong decision.","For many inverse transforms, the DC coefficient has consistent and pronounced rounding effects. In contrast, rounding effects due to AC coefficients are less predictable and less pronounced. A typical frequency transform matrix has a top row of matrix coefficients with all positive values. Subsequent rows have positive and negative values. For many patterns of information, positive and negative effects cancel each other out for an AC coefficient, but the positive values of the top row consistently affect rounding due the DC coefficient. In addition, the DC coefficient affects all samples in a block in the same way, whereas an AC coefficient affects different samples differently. AC coefficients also tend to have smaller magnitudes than DC coefficients. Finally, to the extent AC coefficients do have rounding effects, the rounding effects for different AC coefficients often cancel each other out.","Therefore, in some embodiments, one or more rounding offsets parameterize the difference(s) between T({circumflex over (x)}) and {circumflex over (X)}, thereby accounting for rounding effects that follow an inverse frequency transform. In some implementations, rounding compensation accounts for rounding effects from DC coefficients but not AC coefficients. For a block of de-quantized transform coefficients {circumflex over (X)}, an encoder compensates for rounding effects in the DC coefficient {circumflex over (X)}(0,0) of the block before estimating sample-domain distortion in the transform domain. The encoder does not adjust the de-quantized AC coefficients of the block, as the overall effect of AC rounding on distortion calculation is typically negligible. Alternatively, rounding compensation accounts for rounding effects in at least some AC coefficients. For example, rounding compensation accounts for rounding effects for the top row or left column of AC coefficients for a block of transform coefficients.","The encoder determines a rounding offset for a particular DC coefficient {circumflex over (X)}(0,0) by looking up an index for the DC coefficient in a table that maps indices to rounding offsets. The table is implemented as an array or other data structure. In a simple case, the index is the DC coefficient itself, and the table includes a rounding offset for each possible de-quantized DC coefficient value. The rounding offset is then added to the DC coefficient to produce a rounding-compensated DC coefficient.\n\n(0,0)=(0,0)+OFFSET[(0,0)],\n\nwhere {circumflex over (X)}(0,0) is the rounding-compensated DC coefficient, and DCOFFSET[] is an table mapping indices to corresponding rounding offsets. Or, the DC coefficient is first mapped to an integer ranging from 0 to N\u22121, which is used as an index to a table that maps indices to rounding offsets.\n\n(0,0)=(0,0)+OFFSET[\u0192((0,0))],\n\nwhere \u0192(\u00b7) is an index-mapping function that maps a de-quantized DC coefficient to an index in the range [0, N\u22121], and DCOFFSET[ ] has length N.\n","In the sample domain, distortion is computed using original sample values and reconstructed sample values. Suppose x denotes a block of sample values, and {circumflex over (x)} denotes a block of reconstructed sample values obtained through inverse transform of {circumflex over (X)}: {circumflex over (x)}=T({circumflex over (X)}). Distortion measured in the sample domain is based on x and {circumflex over (x)}. The distortion metric D can be defined in different ways. For example, D can be a sum of squared differences or errors (\u201cSSE\u201d):",{"@attributes":{"id":"p-0087","num":"0086"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"D","mo":"=","mrow":{"munder":{"mo":"\u2211","mrow":{"mrow":{"mi":["for","all","i"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":",","mi":"j"}},"mo":"\u2062","msup":{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"x","mrow":{"mi":["i","j"],"mo":","}},{"mover":{"mi":"x","mo":"^"},"mrow":{"mi":["i","j"],"mo":","}}],"mo":"-"}},"mn":"2"}}},"mo":","}}},"br":{},"sub":["i ","i "]},"The cost of performing an inverse transform T(\u00b7) on a large number of possible coding parameters or permutations for each block can be very expensive in the aggregate. Given the rounding-compensated de-quantized coefficient matrix {circumflex over (X)}and original transform coefficients X, however, sample-domain distortion can be estimated without performing the inverse transform T(\u00b7). Adapting the SSE metric, one rounding-compensated sample-domain distortion metric is:",{"@attributes":{"id":"p-0089","num":"0088"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msup":{"mi":["D","rc"]},"mo":"=","mrow":{"munder":{"mo":"\u2211","mrow":{"mrow":{"mi":["for","all","i"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":",","mi":"j"}},"mo":"\u2062","mrow":{"msup":{"mrow":{"mo":["(",")"],"mrow":{"msubsup":{"mover":{"mi":"X","mo":"^"},"mrow":{"mi":["i","j"],"mo":","},"mi":"rc"},"mo":"-","msub":{"mi":"X","mrow":{"mi":["i","j"],"mo":","}}}},"mn":"2"},"mo":"."}}}}}},"Alternatively, an adapted SAD metric is used:",{"@attributes":{"id":"p-0091","num":"0090"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msup":{"mi":["D","rc"]},"mo":"=","mrow":{"munder":{"mo":"\u2211","mrow":{"mrow":{"mi":["for","all","i"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":",","mi":"j"}},"mo":"\u2062","mrow":{"mrow":{"mo":["\uf603","\uf604"],"mrow":{"msubsup":{"mover":{"mi":"X","mo":"^"},"mrow":{"mi":["i","j"],"mo":","},"mi":"rc"},"mo":"-","msub":{"mi":"X","mrow":{"mi":["i","j"],"mo":","}}}},"mo":"."}}}}}},"Or, an adapted MSE metric is used:",{"@attributes":{"id":"p-0093","num":"0092"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msup":{"mi":["D","rc"]},"mo":"=","mrow":{"mfrac":{"mrow":[{"munder":{"mo":"\u2211","mrow":{"mrow":{"mi":["for","all","i"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":",","mi":"j"}},"mo":"\u2062","msup":{"mrow":{"mo":["(",")"],"mrow":{"msubsup":{"mover":{"mi":"X","mo":"^"},"mrow":{"mi":["i","j"],"mo":","},"mi":"rc"},"mo":"-","msub":{"mi":"X","mrow":{"mi":["i","j"],"mo":","}}}},"mn":"2"}},{"mi":["I","J"],"mo":"\u2a2f"}]},"mo":"."}}}}},"In some implementations, the distortion metric is scaled by a transform-specific scaling factor \u03b1, for example, as follows:",{"@attributes":{"id":"p-0095","num":"0094"},"maths":{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msup":{"mi":["D","rc"]},"mo":"=","mrow":{"mi":"\u03b1","mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mrow":{"mrow":{"mi":["for","all","i"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}]},"mo":",","mi":"j"}},"mo":"\u2062","msup":{"mrow":{"mo":["(",")"],"mrow":{"msubsup":{"mover":{"mi":"X","mo":"^"},"mrow":{"mi":["i","j"],"mo":","},"mi":"rc"},"mo":"-","msub":{"mi":"X","mrow":{"mi":["i","j"],"mo":","}}}},"mn":"2"}}}}}}},"The scaling factor accounts for differences between pixel-domain energy and transform-domain energy when the applied transform is non-unitary. When an encoder applies a frequency transform, the transform matrix values may cause a difference in energy in the transform domain and pixel domain. This is particularly true for integer transforms that are not completely normalized. In general, the scaling factor \u03b1 for a transform depends on the norms of the transform. For example, consider the following transforms:",{"@attributes":{"id":"p-0097","num":"0096"},"maths":{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":"T","mn":"8"},"mo":"=","mrow":{"mrow":[{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mn":"12"},{"mn":"12"},{"mn":"12"},{"mn":"12"},{"mn":"12"},{"mn":"12"},{"mn":"12"},{"mn":"12"}]},{"mtd":[{"mn":"16"},{"mn":"15"},{"mn":"9"},{"mn":"4"},{"mrow":{"mo":"-","mn":"4"}},{"mrow":{"mo":"-","mn":"9"}},{"mrow":{"mo":"-","mn":"15"}},{"mrow":{"mo":"-","mn":"16"}}]},{"mtd":[{"mn":"16"},{"mn":"6"},{"mrow":{"mo":"-","mn":"6"}},{"mrow":{"mo":"-","mn":"16"}},{"mrow":{"mo":"-","mn":"16"}},{"mrow":{"mo":"-","mn":"6"}},{"mn":"6"},{"mn":"16"}]},{"mtd":[{"mn":"15"},{"mrow":{"mo":"-","mn":"4"}},{"mrow":{"mo":"-","mn":"16"}},{"mrow":{"mo":"-","mn":"9"}},{"mn":"9"},{"mn":"16"},{"mn":"4"},{"mrow":{"mo":"-","mn":"15"}}]},{"mtd":[{"mn":"12"},{"mrow":{"mo":"-","mn":"12"}},{"mrow":{"mo":"-","mn":"12"}},{"mn":"12"},{"mn":"12"},{"mrow":{"mo":"-","mn":"12"}},{"mrow":{"mo":"-","mn":"12"}},{"mn":"12"}]},{"mtd":[{"mn":"9"},{"mrow":{"mo":"-","mn":"16"}},{"mn":"4"},{"mn":"15"},{"mrow":{"mo":"-","mn":"15"}},{"mrow":{"mo":"-","mn":"4"}},{"mn":"16"},{"mrow":{"mo":"-","mn":"9"}}]},{"mtd":[{"mn":"6"},{"mrow":{"mo":"-","mn":"16"}},{"mn":"16"},{"mrow":{"mo":"-","mn":"6"}},{"mrow":{"mo":"-","mn":"6"}},{"mn":"16"},{"mrow":{"mo":"-","mn":"16"}},{"mn":"6"}]},{"mtd":[{"mn":"4"},{"mrow":{"mo":"-","mn":"9"}},{"mn":"15"},{"mrow":{"mo":"-","mn":"16"}},{"mn":"16"},{"mrow":{"mo":"-","mn":"15"}},{"mn":"9"},{"mrow":{"mo":"-","mn":"4"}}]}]}},"mo":[".","\u2062"],"mstyle":{"mtext":{}},"msub":{"mi":"T","mn":"4"}},{"mo":["[","]"],"mtable":{"mtr":[{"mtd":[{"mn":"17"},{"mn":"17"},{"mn":"17"},{"mn":"17"}]},{"mtd":[{"mn":"22"},{"mn":"10"},{"mrow":{"mo":"-","mn":"10"}},{"mrow":{"mo":"-","mn":"22"}}]},{"mtd":[{"mn":"17"},{"mrow":{"mo":"-","mn":"17"}},{"mrow":{"mo":"-","mn":"17"}},{"mn":"17"}]},{"mtd":[{"mn":"10"},{"mrow":{"mo":"-","mn":"22"}},{"mn":"22"},{"mrow":{"mo":"-","mn":"10"}}]}]}}],"mo":"="}}}}},"A VC-1 encoder can perform forward 4\u00d74, 4\u00d78, 8\u00d74, and 8\u00d78 transforms on a residual data block D(having i rows and j columns) as follows:\n\n=()\u2218for a 4\u00d74 transform,\n\n=()\u2218for a 8\u00d74 transform,\n\n=()\u2218for a 4\u00d78 transform, and\n\n=()\u2218for a 8\u00d78 transform,\n\nwhere \u00b7 indicates a matrix multiplication, \u2218 Nindicates a component-wise multiplication by a normalization factor, T\u2032 indicates the inverse of the matrix T, and {circumflex over (D)}represents the transform coefficient block. The values of the normalization matrix Nare given by:\n",{"@attributes":{"id":"p-0099","num":"0098"},"maths":[{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"N","mrow":{"mi":["i","j"],"mo":"\u2a2f"}},"mo":"=","mrow":{"msubsup":{"mi":["c","i","\u2032"]},"mo":"\u00b7","msub":{"mi":["c","j"]}}},{"mi":"where","mo":"\u2062","mstyle":{"mtext":":"}}],"mo":[",","\u2062"],"mstyle":{"mtext":{}}}}},{"@attributes":{"id":"MATH-US-00010-2","num":"00010.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msub":{"mi":"c","mn":"4"},"mo":"=","mrow":{"mo":["(",")"],"mtable":{"mtr":{"mtd":[{"mfrac":{"mn":["8","289"]}},{"mfrac":{"mn":["8","292"]}},{"mfrac":{"mn":["8","289"]}},{"mfrac":{"mn":["8","292"]}}]}}}},"mo":",","mi":"and"}}},{"@attributes":{"id":"MATH-US-00010-3","num":"00010.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":"c","mn":"8"},"mo":"=","mrow":{"mrow":{"mo":["(",")"],"mtable":{"mtr":{"mtd":[{"mfrac":{"mn":["8","288"]}},{"mfrac":{"mn":["8","289"]}},{"mfrac":{"mn":["8","292"]}},{"mfrac":{"mn":["8","289"]}},{"mfrac":{"mn":["8","288"]}},{"mfrac":{"mn":["8","289"]}},{"mfrac":{"mn":["8","292"]}},{"mfrac":{"mn":["8","289"]}}]}}},"mo":"."}}}}]},"The forward transform causes an average expansion of a little more than 34in the transform coefficients, and the inverse transform causes an average expansion of a little more than 34in the other direction. Collectively, the inverse transform includes right shifts by 10 for simple normalization, which corresponds to division by 1024 with truncation. So, the normalization in the inverse transform is essentially by ( 1\/32). The forward transform includes normalization by an average of roughly ( 1\/36). The average normalization in the forward transform (roughly ( 1\/36)) more than compensates for the average expansion (roughly 34), so as to simplify normalization in the inverse transform for decoder implementations. As a result, considering expansion and normalization of the forward transform, the average effect is 34\/36\u22480.9. As such, an example scaling factor \u03b1 between sample-domain distortion and transform domain distortion for an adapted SSE metric is 0.9\u22480.8","The scaling factor \u03b1 for a different transform is similarly determined considering expansion and normalization in the forward transform.","B. Distortion Estimation Tools with Rounding Compensation",{"@attributes":{"id":"p-0103","num":"0102"},"figref":"FIG. 6","b":["600","600","640"]},"An encoder such as the encoder () of  incorporates the tool () in a controller or other module. Alternatively, another type of encoder or system incorporates the distortion estimation tool ().","In , x denotes a block or other set of sample values () in a sample domain. For example, the sample values () are intensity values in the pixel domain for an image or video picture. For a video picture, the sample values of an intra-coded block are original intensity values, and the sample values of an inter-coded block are intensity values for a prediction residual. In encoders that use spatial prediction of sample values for intra-coded blocks, the intensity values of the block x can be for a prediction residual following spatial prediction. In some implementations, the intensity values are for the Y channel (i.e., luminance). In other implementations, the intensity values are for the U and V channels (i.e., chrominance) or for Y, U, and V channels at different times.","The frequency transform module () transforms the sample values () into a block or other set of transform coefficients (). The transform module () applies a DCT, DCT-like transform, or other block-based transform. The size of the transform is 8\u00d78, 8\u00d74, 4\u00d78, 4\u00d74 or some other size.","The quantization module () quantizes the transform coefficients (). Any of various types of quantization are applied. For example, the quantization module () applies uniform or non-uniform quantization, scalar or vector quantization, and\/or adaptive or non-adaptive quantization. The quantization module () produces a block or other set of quantized coefficients.","The inverse quantization module () performs inverse quantization on the quantized transform coefficients. The inverse quantization module () produces a block or other set of de-quantized transform coefficients ().","The rounding compensation module () adjusts one or more of the de-quantized transform coefficients (). For example, the rounding compensation module () adds a rounding offset to the DC coefficient of the de-quantized transform coefficients (). Alternatively, the rounding compensation module () adjusts one or more of the de-quantized transform coefficients () using some other mechanism. The rounding compensation module () produces the de-quantized transform coefficients (), denoted with {circumflex over (X)}in , which include the rounding-compensated coefficient(s).","The distortion estimation module () computes a distortion estimate using the original transform coefficients () and the de-quantized transform coefficients () that include the rounding-compensated coefficient(s). The distortion metric is SSE, SAD, MSE, or some other metric, and can be scaled or unscaled.","Particular embodiments of encoders or other tools typically use a variation or supplemented version of the generalized tool (). Depending on implementation, modules of the tool can be added, omitted, split into multiple modules, combined with other modules, and\/or replaced with like modules. In alternative embodiments, tools with different modules and\/or other configurations of modules perform one or more of the described techniques.","C. Estimating Distortion with Rounding Compensation",{"@attributes":{"id":"p-0113","num":"0112"},"figref":["FIGS. 7 and 8","FIG. 7","FIG. 8"],"b":["700","800","700","800"]},"1. Generalized Technique","With reference to , a tool such as a video encoder, video transcoder, image encoder, or image classification tool gets () a block or other set of transform coefficients to evaluate. For example, the tool gets de-quantized transform coefficients following partial decompression of the transform coefficients. Alternatively, the tool gets the transform coefficients in some other way.","The tool then performs () rounding compensation on one or more of the transform coefficients. For example, the tool adjusts the DC coefficient by a rounding offset associated with the value of the DC coefficient. In some implementations, the tool uses a rounding offset table that maps DC coefficients (or indices derived from DC coefficients) to rounding offsets. Alternatively, the tool performs rounding compensation for other and\/or additional transform coefficients or uses another mechanism for determining rounding offsets.","The tool estimates () sample-domain distortion using the rounding-compensated transform coefficients. For example, the distortion metric is scaled or unscaled SAD, MSE, or SSE. The tool determines () whether there are any other sets of transform coefficients to be evaluated before making a decision based upon the results of the distortion estimate(s). If so, the tool continues with the next transform coefficients to evaluate. Otherwise, the tool makes () a decision based upon the results of the previous distortion estimate(s).","2. Distortion Estimation in Video Encoding","With reference to , a video encoder uses distortion estimation with rounding compensation in making encoding decisions. The encoder uses this low-complexity approach to computing pixel-domain distortion accurately to improve the choice of coding parameters at the encoder without significantly increasing encoder complexity.","The video encoder sets () one or more coding parameters for a block to be encoded. Depending on implementation, at different times, the coding parameters can include: (1) whether the block should be encoded as intra or inter; (2) a number of motion vectors; (3) value(s) of motion vector(s); (4) a type of a frequency transform; (5) a size of a frequency transform (e.g., 8\u00d78, 4\u00d78, 8\u00d74, or 4\u00d74); (6) a quantization step size; (7) quantization thresholds; (8) a dead zone size; and\/or (9) perceptual quantization factors. The technique () can be applied to set parameters for an intra block or macroblock, inter block or macroblock, or other unit of video. Alternatively, the coding parameters relate to other and\/or additional coding options.","The encoder encodes () the block according to the set coding parameter(s), performing a frequency transform and quantization, and gets () the transform coefficients to be analyzed. The encoder inverse quantizes () the transform coefficients, producing de-quantized transform coefficients. The encoder then performs rounding compensation () on one or more of the de-quantized transform coefficients, for example, adjusting the DC coefficient by a rounding offset associated with the value of the DC coefficient.","The encoder estimates () pixel-domain distortion using the rounding-compensated transform coefficient(s). For example, the encoder computes a scaled SSE or other distortion metric that compares original transform coefficients with the rounding-compensated de-quantized transform coefficient(s) (from ()) and other de-quantized transform coefficients the encoder got.","The encoder determines () whether there are any other sets of transform coefficients to be evaluated before making an encoding decision based upon the distortion estimate(s). The encoder stops the evaluation process if constrained by time or resource requirements, if the encoder has evaluated a complete range of options, if the previous transform coefficients provide acceptable results, or according to some other criteria.","If the encoder continues evaluation, the encoder changes () one or more of the coding parameter(s) and encodes the block according to the current coding parameter(s). In changing the coding parameter(s), the encoder can consider the results of previous distortion estimates so as to more accurately identify coding parameters likely to provide good rate-distortion performance.","Otherwise, the encoder makes () an encoding decision based upon the previous distortion estimate(s). For example, the encoder reviews one or more of the previous distortion estimate(s), determines the lowest distortion estimate, and adopts coding parameter(s) used to produce the transform coefficients with the lowest distortion estimate.","Instead of evaluating distortion estimates for different coding parameters on a block-by-block basis, alternatively, an encoder can evaluate distortion estimates for different coding parameters on some other basis.","3. Distortion Estimation in Video Transcoding","As another example, a video transcoder estimates sample-domain distortion from transform coefficients with rounding compensation in transcoding operations. A video transcoder converts encoded video in one format and bit rate to encoded video in another format and\/or bit rate. In \u201chomogeneous\u201d transcoding, a transcoder converts encoded video from a bit stream of a particular format at a first bit rate to a bit stream of the same format at a lower bit rate. In \u201cheterogeneous\u201d transcoding, a transcoder converts encoded video to a different format.","In one example of homogeneous transcoding, a transcoder uses distortion estimation with rounding compensation when selecting a quantization step size for a block in transcoded video. The transcoder applies different quantization step sizes and estimates pixel-domain distortion relative to the transform coefficients of the block of the original, encoded video. For a given quantization step size, after inverse quantization the transcoder gets a block of de-quantized transform coefficients and performs rounding compensation on one or more of them. The transcoder computes a distortion metric that compares transform coefficients from the first encoded video with the rounding-compensated transform coefficient(s) and other de-quantized transform coefficients the transcoder got for the evaluated quantization step size. The transcoder reviews the distortion estimates and stops the evaluation process if it finds a quantization step size for the block that gives good rate-distortion performance for encoding at the lower bit rate. If the tool continues, the tool gets a block of transform coefficients for different quantization step size.","For heterogeneous transcoding, a transcoder can use rounding compensation as in the homogeneous transcoding case, also using a scaling factor to account for energy differences between transform coefficients in the first format and transform coefficients in the second format.","4. Distortion Estimation in Image Classification","As another example, an image classification tool estimates sample-domain distortion from transform coefficients with rounding compensation in analysis and classification operations. For example, the tool determines how closely a first compressed image matches a second compressed image. To do this without fully decompressing each image, the tool compares transform coefficients from the first image to corresponding transform coefficients from the second image. By using rounding compensation, the tool accounts for rounding that would occur in an inverse frequency transform, thereby more accurately estimating pixel-domain distortion (here, differences between the two images). After comparing transform coefficients for blocks or other sections of the images, the image classification tool reviews distortion estimate(s) and makes a classification decision on how closely two images match. The image classification tool then outputs the classification decision to a file or screen.","Or, the image classification tool determines how closely an image matches an image signature or image pattern, comparing rounding-compensated transform coefficients of the image to the image signature or image pattern.","D. Computing Rounding Offset Tables",{"@attributes":{"id":"p-0135","num":"0134"},"figref":["FIG. 9","FIG. 5"],"b":["900","900","900"]},"To start, a range of de-quantized transform coefficient values is identified (). In an example implementation, the range of samples is [0 . . . 255] and, following an 8\u00d78 forward frequency transform, quantization, and inverse quantization, the range of de-quantized DC coefficients is [\u22121816 . . . 1816]. More specifically, {circumflex over (X)}(0,0) can take the value of any even integer in the range of [\u22121816 . . . 1816]-odd integers are not possible due to the rules applied in inverse quantization. In different implementations, the range of values for de-quantized transform coefficients is different or the transform size is different. Different ranges of input sample values typically result in different ranges of de-quantized transform coefficient values. Depending on size (e.g., 4\u00d74, 4\u00d74, or 8\u00d74) or type, different transforms often have different scaling factors, which also results in different ranges of de-quantized transform coefficient values. Finally, different quantization and inverse quantization rules affect which de-quantized transform coefficient values are possible within a range. Although only even values are possible in the immediately preceding example implementation, the approach can be applied to non-integer quantization parameters (\u201cQPs\u201d) in which QPs can have \u00bd-step increments. In this case, reconstructed DC coefficients can have odd values.","Next, rounding offsets for the de-quantized transform coefficient values in the range are computed (). In the example implementation, the rounding offsets for DC coefficient values are computed and stored in a table labeled DCOFFSET[]. For each de-quantized coefficient value k in the identified range (here, even numbers in the range of [\u22121816 . . . 1816]), an inverse frequency transform is performed on a block having that value as its DC coefficient and zeros for all AC coefficients. A forward frequency transform is performed on the result. The difference is then computed between the DC coefficient of the forward transform results and the initial de-quantized coefficient value k. (To compensate for scaling in the transforms in some implementations, k is multiplied by a scaling factor.) The following equation yields rounding offset values for quantized coefficient values from \u22121816 to 1816, which can be stored in an array DCOFFSET.",{"@attributes":{"id":"p-0138","num":"0137"},"maths":{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":"DCOFFSET","mo":"\u2061","mrow":{"mo":["[","]"],"mfrac":{"mrow":{"mi":"k","mo":"+","mn":"1816"},"mn":"2"}}},{"mrow":[{"mo":["(",")"],"mrow":{"mi":["DC","coefficient","of"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":"T","mrow":{"mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mover":{"mi":"X","mo":"^"},"mi":"k"}}}}}}},{"mo":["(",")"],"mrow":{"mi":"k","mo":"\u00d7","mn":"16"}}],"mo":"-"}],"mo":"="},"mo":","}}},"br":{},"sub":"k "},{"@attributes":{"id":"p-0139","num":"0138"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DC Rounding Offsets in Example Implementation for Scaling"},{"entry":"Factor = 16"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"DC coeff. of",{},"rounding"]},{"entry":[{},"k","T(T({circumflex over (X)}))","k \u00d7 16","offset"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"\u22121816","\u221229014","\u221229056","42"]},{"entry":[{},"\u22121814","\u221229014","\u221229024","10"]},{"entry":[{},"\u22121812","\u221229014","\u221228992","\u221222\u2002"]},{"entry":[{},"\u22121810","\u221229014","\u221228960","\u221254\u2002"]},{"entry":[{},"\u22121808","\u221228900","\u221228928","28"]},{"entry":[{},"\u22121806","\u221228900","\u221228896","\u22124"]},{"entry":[{},"\u22121804","\u221228900","\u221228864","\u221236\u2002"]},{"entry":[{},"\u22121802","\u221228786","\u221228832","46"]},{"entry":[{},"\u22121800","\u221228786","\u221228800","14"]},{"entry":[{},"\u22121798","\u221228786","\u221228768","\u221218\u2002"]},{"entry":[{},"\u22121796","\u221228786","\u221228736","\u221250\u2002"]},{"entry":[{},"\u22121794","\u221228672","\u221228704","32"]},{"entry":[{},"\u22121792","\u221228672","\u221228672","\u20020"]},{"entry":[{},"\u22121790","\u221228672","\u221228640","\u221232\u2002"]},{"entry":[{},"\u22121788","\u221228559","\u221228608","49"]},{"entry":[{},"\u22121786","\u221228559","\u221228576","17"]},{"entry":[{},"\u22121784","\u221228559","\u221228544","\u221215\u2002"]},{"entry":[{},"\u22121782","\u221228559","\u221228512","\u221247\u2002"]},{"entry":[{},"\u22121780","\u221228445","\u221228480","35"]},{"entry":[{},"\u22121778","\u221228445","\u221228448","\u20023"]},{"entry":[{},"\u22121776","\u221228445","\u221228416","\u221229\u2002"]},{"entry":[{},"\u22121774","\u221228331","\u221228384","53"]},{"entry":[{},"\u22121772","\u221228331","\u221228352","21"]},{"entry":[{},"\u22121770","\u221228331","\u221228320","\u221211\u2002"]},{"entry":[{},"\u22121768","\u221228331","\u221228288","\u221243\u2002"]},{"entry":[{},"\u22121766","\u221228217","\u221228256","39"]},{"entry":[{},"\u22121764","\u221228217","\u221228224","\u20027"]},{"entry":[{},"\u22121762","\u221228217","\u221228192","\u221225\u2002"]},{"entry":[{},"\u22121760","\u221228104","\u221228160","56"]},{"entry":[{},"\u22121758","\u221228104","\u221228128","24"]},{"entry":[{},"\u22121756","\u221228104","\u221228096","\u22128"]},{"entry":[{},"\u22121754","\u221228104","\u221228064","\u221240\u2002"]},{"entry":[{},"\u22121752","\u221227990","\u221228032","42"]},{"entry":[{},"\u22121750","\u221227990","\u221228000","10"]},{"entry":[{},"\u22121748","\u221227990","\u221227968","\u221222\u2002"]},{"entry":[{},"\u22121746","\u221227990","\u221227936","\u221254\u2002"]},{"entry":[{},"\u22121744","\u221227876","\u221227904","28"]},{"entry":[{},". . .",". . .",". . .",". . ."]},{"entry":[{},"\u20021808","\u200228899","\u200228928","\u221229\u2002"]},{"entry":[{},"\u20021810","\u200229013","\u200228960","53"]},{"entry":[{},"\u20021812","\u200229013","\u200228992","21"]},{"entry":[{},"\u20021814","\u200229013","\u200229024","\u221211\u2002"]},{"entry":[{},"\u20021816","\u200229013","\u200229056","\u221243\u2002"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"In other implementations, the scaling factor of 16 is not needed since normalization is completed in the inverse and forward transforms. The scaling factor of 16 is not incorporated in the computation of rounding offsets, and the following equation yields rounding offset values for quantized coefficient values from \u22121816 to 1816, which can be stored in an array DCOFFSET.",{"@attributes":{"id":"p-0141","num":"0140"},"maths":{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"DCOFFSET","mo":"\u2061","mrow":{"mo":["[","]"],"mfrac":{"mrow":{"mi":"k","mo":"+","mn":"1816"},"mn":"2"}}},{"mrow":[{"mo":["(",")"],"mrow":{"mi":["DC","coefficient","of"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mrow":{"mi":"T","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"msup":{"mi":"T","mrow":{"mo":"-","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"msub":{"mover":{"mi":"X","mo":"^"},"mi":"k"}}}}}}},{"mi":"k","mo":"."}],"mo":"-"}],"mo":"="}}},"br":{}},{"@attributes":{"id":"p-0142","num":"0141"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DC Rounding Offsets in Example Implementation with No"},{"entry":"Scaling Factor"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"DC coeff. of",{},"rounding"]},{"entry":[{},"k","T(T({circumflex over (X)}))","k \u00d7 1","offset"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},"\u22121816","\u22121813","\u22121816","3"]},{"entry":[{},"\u22121814","\u22121813","\u22121814","1"]},{"entry":[{},"\u22121812","\u22121813","\u22121812","\u22121\u2002"]},{"entry":[{},"\u22121810","\u22121813","\u22121810","\u22123\u2002"]},{"entry":[{},"\u22121808","\u22121806","\u22121808","2"]},{"entry":[{},"\u22121806","\u22121806","\u22121806","0"]},{"entry":[{},"\u22121804","\u22121806","\u22121804","\u22122\u2002"]},{"entry":[{},"\u22121802","\u22121799","\u22121802","3"]},{"entry":[{},"\u22121800","\u22121799","\u22121800","1"]},{"entry":[{},"\u22121798","\u22121799","\u22121798","\u22121\u2002"]},{"entry":[{},"\u22121796","\u22121799","\u22121796","\u22123\u2002"]},{"entry":[{},"\u22121794","\u22121792","\u22121794","2"]},{"entry":[{},"\u22121792","\u22121792","\u22121792","0"]},{"entry":[{},"\u22121790","\u22121792","\u22121790","\u22122\u2002"]},{"entry":[{},"\u22121788","\u22121785","\u22121788","3"]},{"entry":[{},"\u22121786","\u22121785","\u22121786","1"]},{"entry":[{},"\u22121784","\u22121785","\u22121784","\u22121\u2002"]},{"entry":[{},"\u22121782","\u22121785","\u22121782","\u22123\u2002"]},{"entry":[{},"\u22121780","\u22121778","\u22121780","2"]},{"entry":[{},"\u22121778","\u22121778","\u22121778","0"]},{"entry":[{},"\u22121776","\u22121778","\u22121776","\u22122\u2002"]},{"entry":[{},"\u22121774","\u22121771","\u22121774","3"]},{"entry":[{},"\u22121772","\u22121771","\u22121772","1"]},{"entry":[{},"\u22121770","\u22121771","\u22121770","\u22121\u2002"]},{"entry":[{},"\u22121768","\u22121771","\u22121768","\u22123\u2002"]},{"entry":[{},"\u22121766","\u22121764","\u22121766","2"]},{"entry":[{},"\u22121764","\u22121764","\u22121764","0"]},{"entry":[{},"\u22121762","\u22121764","\u22121762","\u22122\u2002"]},{"entry":[{},"\u22121760","\u22121756","\u22121760","4"]},{"entry":[{},"\u22121758","\u22121756","\u22121758","2"]},{"entry":[{},"\u22121756","\u22121756","\u22121756","0"]},{"entry":[{},"\u22121754","\u22121756","\u22121754","\u22122\u2002"]},{"entry":[{},"\u22121752","\u22121749","\u22121752","3"]},{"entry":[{},"\u22121750","\u22121749","\u22121750","1"]},{"entry":[{},"\u22121748","\u22121749","\u22121748","\u22121\u2002"]},{"entry":[{},"\u22121746","\u22121749","\u22121746","\u22123\u2002"]},{"entry":[{},"\u22121744","\u22121742","\u22121744","2"]},{"entry":[{},". . .",". . .",". . .",". . ."]},{"entry":[{},"\u20021808","\u20021806","\u20021808","\u22122\u2002"]},{"entry":[{},"\u20021810","\u20021813","\u20021810","3"]},{"entry":[{},"\u20021812","\u20021813","\u20021812","1"]},{"entry":[{},"\u20021814","\u20021813","\u20021814","\u22121\u2002"]},{"entry":[{},"\u20021816","\u20021813","\u20021816","\u22123\u2002"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"Alternatively, another mechanism is used to compute rounding offsets for the de-quantized transform coefficient values in the identified range.","Different ranges and transforms\/inverse transforms result in different rounding offsets. For example, if odd values of reconstructed DC coefficients are possible (due to non-integer QPs or otherwise), the offsets of the DCOFFSET[] table include offsets for odd DC values.","Table 2 shows example values of k and corresponding rounding offsets for a generalized and idealized example in which the range of de-quantized transform coefficient values is any integer and the scaling factor for the transform\/inverse transform is 1.",{"@attributes":{"id":"p-0146","num":"0145"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DC Rounding Offsets in Generalized Example"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"77pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"DC coeff. of",{},"rounding"]},{"entry":[{},"k","T(T({circumflex over (X)}))","k \u00d7 1","offset"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]},{"entry":[{},". . .",". . .",". . .",". . ."]},{"entry":[{},"\u22123\u2002","\u22125\u2002","\u22123\u2002","\u22122\u2002"]},{"entry":[{},"\u22122\u2002","0","\u22122\u2002","2"]},{"entry":[{},"\u22121\u2002","0","\u22121\u2002","1"]},{"entry":[{},"0","0","0","0"]},{"entry":[{},"1","0","1","\u22121\u2002"]},{"entry":[{},"2","0","2","\u22122\u2002"]},{"entry":[{},"3","5","3","2"]},{"entry":[{},"4","5","4","1"]},{"entry":[{},"5","5","5","0"]},{"entry":[{},"6","5","6","\u22121\u2002"]},{"entry":[{},"7","5","7","\u22122\u2002"]},{"entry":[{},"8","10\u2002","8","2"]},{"entry":[{},"9","10\u2002","9","1"]},{"entry":[{},". . .",". . .",". . .",". . ."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"4","align":"center","rowsep":"1"}}]}]}}]}}},"A rounding offset table is then created (). For example, the rounding offset table is an array that maps de-quantized transform coefficient values to corresponding rounding offset values. A tool looks up a rounding offset by direct indexing with the value of a de-quantized transform coefficient. Alternatively, the rounding offset table is represented with a different data structure.","Optionally, a periodic pattern in the rounding offset values is identified () before the rounding offset table is created. For example, a person performing the technique () identifies a periodic pattern visually, by plotting rounding offsets versus de-quantized transform coefficient values, or using analytical software. In general, periodicity in the DC rounding offsets allows for reduction in table size. In the generalized, idealized example of Table 3, the DC rounding offset is periodic with a period of 5. In the example implementation of Table 1 or Table 2, the DC rounding offset is periodic with a period of 32. The array DCOFFSET[] stores the first 32 rounding offset values, and the length Nis 32. Specifically, the values in the DC rounding offset table are DCOFFSET[32]={42, 10, \u221222, \u221254, 28, \u22124, \u221236, 46, 14, \u221218, \u221250, 32, 0, \u221232, 49, 17, \u221215, \u221247, 35, 3, \u221229, 53, 21, \u221211, \u221243, 39, 7, \u221225, 56, 24, \u22128, \u221240}. To look up the correct DC rounding offset for a de-quantized DC coefficient, the de-quantized DC coefficient value is converted to a table index by an index mapping function \u0192(\u00b7) as follows: \u0192(i)=((i+1816)>>1)& 31.","If the scaling factor of 16 is not incorporated in the computation of rounding offsets (see Table 2), the values in the table are DCOFFSET[32]={3, 1, \u22121, \u22123, 2, 0, \u22122, 3, 1, \u22121, \u22123, 2, 0, \u22122, 3, 1, \u22121, \u22123, 2, 0, \u22122, 3, 1, \u22121, \u22123, 2, 0, \u22122, 4, 2, 0, \u22122}.","The index-mapping function is different for different ranges of de-quantized transform coefficient values and different periodic patterns. The index-mapping function can use different operations, for example, computing \u201ccoefficient value\u201d MOD \u201cperiod.\u201d Different ranges of de-quantized transform coefficient values and different forward\/inverse transforms result in different periodic patterns.","IV. Extensions","Although the techniques and tools described herein are in places presented in the context of video encoding, sample-domain distortion estimation from transform coefficients with rounding compensation may be applied to other data compression schemes in which an integer-based transform (especially a DCT-like transform) is used. For example, the techniques and tools may be applied when encoding images with an integer-based, DCT-like transform. In addition, as noted above, the techniques and tools may be applied in transcoding applications and image classification and analysis applications.","Finally, an encoder can use results of rounding compensation in operations other than distortion estimation. For example, an encoder groups quantized DC coefficient values using rounding offset information. The quantized DC coefficient values within a group have rounding offsets that make the values within the group equivalent for purposes of estimating distortion. In terms of the example of Table 1, the values \u22121816, \u22121814, \u22121812, and \u22121810 are grouped, since T(T(\u00b7)) of each of these values results in the same value (\u221229014). The values \u22121808, \u22121806, and \u22121804 are in a second group, and so on. The encoder can perform the grouping off-line. During entropy coding, if a first DC coefficient value in a group can be represented with fewer bits than a second DC coefficient value in the same group, the encoder uses the first DC coefficient value instead of the second DC coefficient value in the encoded data.","Having described and illustrated the principles of our invention with reference to various embodiments, it will be recognized that the various embodiments can be modified in arrangement and detail without departing from such principles. It should be understood that the programs, processes, or methods described herein are not related or limited to any particular type of computing environment, unless indicated otherwise. Various types of general purpose or specialized computing environments may be used with or perform operations in accordance with the teachings described herein. Elements of embodiments shown in software may be implemented in hardware and vice versa.","In view of the many possible embodiments to which the principles of our invention may be applied, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
