---
title: Hardware-accelerated computation of radiance transfer coefficients in computer graphics
abstract: A hardware-accelerated process of computing radiance transfer coefficients (such as for use in image rendering based on precomputed radiance transfer (PRT) techniques) is re-ordered as compared to previously known PRT precomputations to iterate over a sampling of directions about an object. The hardware-accelerated process uses a set of textures representing positions and normals for a sampling of points over a modeled object. In iterating over the directions, the process computes the depth of the object in a shadow buffer, then computes a texture of the radiance contribution based on the normal and position textures and depth from the shadow buffer. The resulting radiance contribution textures of the iterated directions are accumulated to produce a texture representing the radiance transfer coefficients of the sampled positions. This enables the process to avoid reduction operations, ray tracing and slow read-back path limitations of graphical processing units.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07948490&OS=07948490&RS=07948490
owner: Microsoft Corporation
number: 07948490
owner_city: Redmond
owner_country: US
publication_date: 20031022
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The invention relates generally to computer graphics techniques for rendering images of a modeled object with realistic lighting.","Generating accurate depictions of complex scenes in interesting lighting environments is one of the primary goals in computer graphics. The general solution to this problem requires the solution of an integral equation that is difficult to solve even in non-interactive settings. In interactive graphics, short cuts are generally made by making simplifying assumptions of several properties of the scene; the materials are generally assumed to be simple, the lighting environment is either approximated with a small number of point and directional lights, or environment maps and transport complexity (i.e., how the light bounces around the scene, such as, inter-reflections, caustics and shadows) is only modeled in a limited way. For example, shadows may be computed for dynamic point lights, but not for environment maps.","Pre-Computed Radiance Transfer","Sloan et al., \u201cGraphics Image Rendering With Radiance Self-Transfer For Low-Frequency Lighting Environments\u201d, U.S. patent application Ser. No. 10\/389,553, filed Mar. 14, 2003, and published as Publication No. US-2003-0179197-A1 (the disclosure of which is hereby incorporated by reference) [hereafter \u201cSloan '553 application\u201d], describes a technique called \u201cprecomputed radiance transfer\u201d (PRT) that enables rigid objects to be illuminated in low frequency lighting environments with global effects like soft shadows and inter-reflections in real time. It achieves these results by running a lengthy pre-process that computes how light is transferred from a source environment to exit radiance at a point. Previous methods for running this pre-process were designed to execute on the central processing unit (CPU) of a computer, and utilized the processing and memory resources of the CPU in a traditional manner.","Graphics Processing Unit","Computers commonly have a graphics adapter or graphics accelerator that contains a specialized microprocessor, generally known as a graphics co-processor or graphics processing unit (GPU). A GPU also can be integrated into the chip set contained on the motherboard of the computer. The GPU handles high-speed graphics-related processing to free the computer's central processing unit (CPU) for other tasks. Today's graphics adapters (e.g., various graphics adapter models available from NVIDIA and ATI Technologies, among others) feature GPUs that are specifically designed to render 3-dimensional (3D) graphics images and video at high frame rates, such as for use in computer games, video and other graphics intensive applications. Some CPUs for computers also include specialized instructions in their instruction sets that are designed for graphics-related processing (e.g., the MMX instructions in Intel Corporation microprocessors).","In past graphics adapters, the GPU generally provided fixed functionality for graphics processing operations. Application programs (e.g., a game with 3D graphics) would interact with the graphics adapter through a graphics application programming interface (API), such as Microsoft Corporation's DirectX\u00ae, and OpenGL\u00ae of Silicon Graphics, Inc. Through a graphics API, the application programs directed the GPU to execute its fixed graphics processing functions.","In its version 8, Microsoft DirectX\u00ae more recently introduced the concept of a programmable graphics shader for recent programmable graphics hardware. A shader is a program that executes on graphics hardware to perform graphics processing on a per pixel, or per vertex (or other graphics component or fragment) basis for 3D graphics rendering. DirectX\u00ae 8 included a language for writing shaders. DirectX\u00ae version 9 further introduced a high level programming language for shaders (called the High Level Shading Language or HLSL) to make it easier for application developers to create shaders. The HLSL is syntactically similar to the well known C programming language. This makes it easier for programmers who are familiar with C to understand.","The architecture or design of current GPUs is optimized to execute particular graphics operations, but has limitations that prevent practical and efficient execution of others. The PRT preprocessing technique as previously implemented on the CPU includes operations that do not execute efficiently on the GPU. Accordingly, a direct mapping of the previous PRT preprocessing technique from the CPU onto GPU hardware would not be practical or efficient. For example, current GPUs do not practically or efficiently execute reduction operations, ray tracing, rasterization, as well as providing slow read-back paths, among others. In particular, the computations in the previous CPU-based PRT preprocessing technique that involve iterating over vertices and shooting rays do not map well to current GPU hardware.","A technique for hardware-accelerated computation of radiance transfer coefficients described herein is designed for practical and efficient execution on the GPU. The technique optimizes the radiance transfer computation to take into account the strengths and weaknesses of GPU architectures versus that of the CPU.","In one implementation, this hardware-accelerated radiance transfer computation technique is applied to precomputation of the PRT on the GPU. For efficient PRT pre-processing on the GPU, the computation is re-ordered relative to the previous PRT preprocessing technique on the CPU. In particular, the hardware-accelerated radiance transfer computation iterates over a sampling of directions about an object, as compared to iterating over points sampled over the object as in the previous PRT preprocessing technique. This enables the inner loop of the computation to be performed using a pixel shader as operations on a set of textures representing positions and normals of a set of sampling points over the object mapped into texture space. In this inner loop of the computation, a texture is computed containing the depth of the object for the currently iterated direction, the radiance transfer contribution for the direction at the position in the texture is calculated, and the texture for the direction is accumulated into texture representing the final transfer coefficients.","Additional features and advantages of the invention will be made apparent from the following detailed description of embodiments that proceeds with reference to the accompanying drawings.","The following description is directed to various implementations of techniques for hardware-accelerated computation of radiance transfer coefficients. The description presents an exemplary application of this technique to computer graphics image rendering based on pre-computed radiance transfer (PRT), such as described in the Sloan '553 application. More particularly, an exemplary application of the technique evaluates the PRT preprocess for diffuse objects with shadows efficiently on the GPU. However, the hardware-accelerated computation of radiance transfer coefficients alternatively can be applied to other image rendering applications in computer graphics.","1. Precomputed Radiance Transfer Overview","As described more fully in the Sloan '553 application, PRT is a technique that enables rendering images of rigid objects illuminated in low frequency lighting environments with global effects like soft shadows and inter-reflections in real time. The technique achieves this by running a lengthy preprocess that computes how light is transferred from a source environment to exit radiance at a point. The following section summarizes the basis of this PRT technique.","For a diffuse object illuminated in distant lighting environment L, the reflected radiance at a point P on the surface is:",{"@attributes":{"id":"p-0027","num":"0026"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["R","p"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"v","mo":"\u2192"}}},{"mfrac":{"msub":{"mi":["\u03c1","d"]},"mi":"\u03c0"},"mo":"\u2062","mrow":{"msub":{"mo":"\u222b","mi":"s"},"mo":"\u2062","mrow":{"mrow":[{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"mi":"s"}},{"msub":{"mi":["V","p"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"s"}},{"msub":{"mi":["H","N"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mi":"s"}},{"mo":"\u2146","mi":"s"}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.2em","height":"0.2ex"}}}}}}],"mo":"="}},{"mrow":{"mo":["(",")"],"mn":"1"}}]}}}}},"Where Vrepresent visibility; a binary function that is 1 in a given direction if a ray in that direction originating at the point can \u201csee\u201d the light source, and 0 otherwise. Hrepresents the projected area (or cosine term) and the integration is over the hemisphere about the points normal. The diffuse reflectance (or albedo) of the surface is \u03c1and is generally a RGB color where each values is in between zero and one. The division by \u03c0 maps irradiance (the integral) into exit radiance (what we see) and guarantees energy conservation (i.e., the amount of energy reflected is never greater then the amount of energy arriving at a point.)","With a point or directional light, the lighting environment is effectively a delta function, which turns the integral into a simple function evaluation\u2014the cosine of the angle between the light and the normal if the direction is not in shadow or just zero if it is. Since the object is diffuse, the reflected radiance is the same in all directions and the integral does not depend on the view direction. The key idea behind precomputed radiance transfer is to approximate the lighting environment using a set of basis functions over the sphere:",{"@attributes":{"id":"p-0030","num":"0029"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"s","mo":"\u2192"}}},{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":{"mi":["l","i"]},"mo":"\u2062","mrow":{"msub":{"mi":["B","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"s","mo":"\u2192"}}}}}],"mo":"\u2248"}},{"mrow":{"mo":["(",")"],"mn":"1"}}]}}}}},"Where the B's are a set of basis functions and the l's are the coefficients corresponding to the optimal (in a least squares sense) projection of the lighting environment into the basis functions, that is they minimize:",{"@attributes":{"id":"p-0032","num":"0031"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mo":"\u222b","mrow":{"msup":{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"L","mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"s","mo":"\u2192"}}},{"mo":["\u2211","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":{"mi":["l","i"]},"mo":"\u2062","mrow":{"msub":{"mi":["B","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"s","mo":"\u2192"}}}}}],"mo":"-"}},"mn":"2"},"mo":"\u2062","mrow":{"mo":"\u2146","mi":"s"}}}},{"mrow":{"mo":["(",")"],"mn":"2"}}]}}}}},"If the basis functions are orthogonal this just amounts to integrating the lighting environment against the basis functions, while in general it is necessary to integrate against the duals of the basis functions.","Now substitute the approximation of the lighting environment into (1):",{"@attributes":{"id":"p-0035","num":"0034"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["R","p"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"v","mo":"\u2192"}}},{"mfrac":{"msub":{"mi":["\u03c1","d"]},"mi":"\u03c0"},"mo":"\u2062","mrow":{"msub":{"mo":"\u222b","mi":"s"},"mo":"\u2062","mrow":{"mrow":[{"mo":["(",")"],"mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":{"mi":["l","i"]},"mo":"\u2062","mrow":{"msub":{"mi":["B","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"s","mo":"\u2192"}}}}}},{"msub":{"mi":["V","p"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"s","mo":"\u2192"}}},{"msub":{"mi":["H","N"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"s","mo":"\u2192"}}},{"mo":"\u2146","mi":"s"}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.2em","height":"0.2ex"}}}}}}],"mo":"\u2248"}},{"mrow":{"mo":["(",")"],"mn":"3"}}]}}}}},"And now recall two concepts from basic calculus: that the integral of a sum equals the sum of the integrals and that constants-can be pulled outside of integrals. This allows us to reformulate (3) as follows:",{"@attributes":{"id":"p-0037","num":"0036"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["R","p"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"v","mo":"\u2192"}}},{"msub":{"mi":["\u03c1","d"]},"mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":{"mi":["l","i"]},"mo":"\u2062","mrow":{"msub":{"mo":"\u222b","mi":"s"},"mo":"\u2062","mrow":{"mfrac":{"mn":"1","mi":"\u03c0"},"mo":["\u2062","\u2062","\u2062","\u2062","\u2062"],"mrow":[{"msub":{"mi":["B","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"s","mo":"\u2192"}}},{"msub":{"mi":["V","p"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"s","mo":"\u2192"}}},{"msub":{"mi":["H","N"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"s","mo":"\u2192"}}},{"mo":"\u2146","mi":"s"}],"mstyle":{"mspace":{"@attributes":{"width":"0.2em","height":"0.2ex"}}}}}}}}],"mo":"\u2248"}},{"mrow":{"mo":["(",")"],"mn":"4"}}]}}}}},"The important thing to note about the above equation is that the integral only depends on the choice of basis functions, not on the value of the particular lighting environment or the albedo of the surface. This means that if you precompute the integral for each basis function at every point on the object you are left with the following expression for reflected radiance:",{"@attributes":{"id":"p-0039","num":"0038"},"maths":{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mrow":[{"msub":{"mi":["R","p"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mover":{"mi":"v","mo":"~"}}},{"msub":{"mi":["\u03c1","d"]},"mo":"\u2062","mrow":{"munder":{"mo":"\u2211","mi":"i"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":["l","i"]},{"mi":["t","pi"]}],"mo":"\u2062"}}}],"mo":"\u2248"}},{"mrow":{"mo":["(",")"],"mn":"5"}}]}}}}},"A dot product between the global lighting coefficients and the spatially varying (through the index p) transfer vector scaled by the albedo is all that is required. One implementation of the hardware-accelerated radiance transfer technique described herein is efficient computation of t.","2. Previous PRT Pre-Computation","With reference now to , the Sloan '553 application presents a pre-process  () for computing the PRT of an object. In this pre-process, the radiance transfer including shadow effects is first computed in a first \u201cshadow\u201d pass , then the contribution to radiance transfer from interreflections is computed in one or more additional \u201cinterreflection\u201d passes . In the shadow pass , the preprocess iterates over a set of points (e.g., vertices) on the object at . Then, in an inner loop at -, the preprocess iterates over directions from the point (as depicted in ), integrating the shadow transfer at the point over the directions. In the interreflections pass(es) , the preprocess again iterates over the points on the object at , now integrating interreflection transfer at the respective point over the occluded directions in inner loop -\u2032.","One example implementation of the hardware-accelerated radiance transfer technique described herein focuses on evaluating the PRT preprocess for diffuse objects with shadows efficiently on the GPU. In other words, the technique provides more efficient computation of the radiance transfer including shadows, which compares to the shadow pass  of the previous PRT preprocess . This previous preprocess for precomputing the PRT with shadow effects can be expressed in pseudo-code  as shown in .","For each point (P), this pseudo-code process  () iterates over a set of uniform directions on the unit sphere (as in Monte-Carlo integration), only adding the contribution for the basis functions in the directions that can see the light (again, as depicted in ). The contributions are just a numerical evaluation of the integral in equation (4) above, which is the basis functions times the cosine of the angle between the ray direction and the normal times the visibility function evaluated in the given direction. The normalization constant for monte-carlo integration is",{"@attributes":{"id":"p-0045","num":"0044"},"maths":{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":{"mn":"4","mo":"\u2062","mi":"\u03c0"},"mi":"N"},"mo":","}}},"br":{}},"Unfortunately, the previous PRT precomputation as expressed in the flow chart of  and the pseudo-code  of  is not suitable for efficient, accelerated execution on graphics hardware. The previous PRT precomputation technique requires ray tracing, which while possible to do on graphics hardware is not very efficient. Further, the previous PRT precomputation requires an accumulation of disparate points in space, which also can not be done very efficiently on the GPU.","3. Hardware-Accelerated Radiance Transfer Computation","In accordance with one implementation of the hardware-accelerated computation of radiance transfer coefficients technique, the PRT preprocess is altered to become more suitable for hardware-accelerated execution on a GPU. This altered or hardware-accelerated version of the PRT preprocess can be expressed in pseudo-code  as shown in . As compared to the previous PRT preprocess pseudo-code  of , the order of the inner- and outer-loops of the hardware-accelerated PRT preprocess  are reversed to be more suitable for GPU execution. In particular, while the previous PRT preprocess iterated over sample points on the object in the outer loop and over directions from the respective point in the inner loop, this hardware-accelerated PRT preprocess iterates over directions in the outer loop and points in the inner loop.","The hardware-accelerated PRT preprocess uses a couple of textures, which are defined as follows: object space position texture (G) is a texture that contains the position of each point mapped into texture space; and object space normal texture (N) is a texture with the same correspondence as above, but contains the surface normal at each sample instead of position. If the object has a parameterization, such parameterization can be used for mapping the position into texture space in the texture G. Otherwise, it is reasonable to simply pack the points or vertices into the texture in a coherent fashion.","With reference now to the flow chart depiction of the hardware-accelerated PRT preprocess  shown in  (which corresponds to the pseudo-code  in ), the object space position (G) and object space normal (N) textures are first generated and initialized at . In one implementation, the object space position texture (G) is stored in RGB (red\/green\/blue) component form, using a 16-bit fixed or floating point number format. Alternative implementations can use different texture size and formats. In some implementations, the mapping of the position and normal into texture space can use a parameterization of the object, or a unique mapping of vertex to pixel. For example, when using PRT with textured objects, the objects can require unique texturing over the object surface. However, other implementations may use other mappings of the points into texture space, including arbitrary mappings that need not be a one-to-one parameterization. In some implementations, this unique point to texel mapping can be\u2014performed using a conventional texture synthesis algorithm (as described in, e.g., Turk, G., , SIGGRAPH 2001, 347-354), which can use a texture atlas for the mapping (e.g., to minimize distortion). For example, any mapping of the sphere to a square by a single cut will have a lot of distortion, but if the sphere is broken into patches the individual patches will have much less distortion. In deciding the number of patches, a trade-off is made between inefficiencies from packing the patches into the texture and distortion. If a texture atlas is used, a \u201cgutter\u201d region preferably is defined and filled with valid values, so that bi-linear interpolation can be used. In this implementation of the hardware-accelerated PRT preprocess , the object is drawn once at a near depth and then 8 more times with single texel shifts and increased depths\u2014effectively replicating the samples on the boundary into the gutters.","At , the hardware-accelerated PRT preprocess  builds a number N of textures to store the transfer coefficients, where N\/4 is the number of basis functions used to represent the radiance transfer.","After initializing the textures, the hardware-accelerated PRT preprocess  iterates over a sampling of directions in a loop -. In one implementation, the sampling of directions are generated as uniformly distributed points on a unit sphere, using a standard mapping from the unit square to the sphere and jittered sampling. These are the directions that are used to perform the numerical integration for the PRT precomputation.","In iterating over the direction in the loop -, the hardware-accelerated PRT preprocess  performs the following basic computations - for radiance transfer with shadow (shadow pass): a texture is computed containing the depth of the object from that texture (a shadow z-buffer essentially) at  so as render the entire object (iterating over position effectively); the contribution for the given direction is computed in a texture; and finally this texture is accumulated into the final results at . The shadow Z buffer is a texture that stores the depth of the object in the direction (e.g., as a 16-bit fixed or floating point format). The shadow pass is fairly straightforward\u2014an orthographic projection matrix is appended to a transformation that sets the view direction (the Z axis) to the current direction being computed. Care should be taken to generate as tight a frustum around the object as possible to maximize the texture's spatial resolution and precision. High precision textures should be used to store the depth (either 16 bit floating point or fixed point should suffice for most objects.)",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 6","FIG. 5"],"b":["600","514","610","611","612","613","614"],"sub":"N "},"In one implementation, the bulk of this shadow pass inner loop can be computed in a pixel shader  (whose assembly language listing  is shown in ) on the GPU. In this pixel shader, simple geometry is drawn that rasterizes the corresponding UV coordinate for each pixel on the screen. A square can be used but a single triangle that encompasses the normalized device coordinates (NDC) is potentially more efficient. The vertex shader just maps from UV coordinates to NDC coordinates and emits the texture coordinates along with position. The transformation used for the pixel shader is identical to the one used in the vertex shader of the shadow pass but appended with a transformation from NDC coordinates to UV coordinates and biases the depth value to minimize \u201cacne\u201d that can occur with shadow depth buffer techniques.","For finally accumulating the contributions of the current direction into the radiance coefficients texture, it is unfortunately not possible to blend into floating point render targets with the current generation of graphics hardware. The hardware-accelerated PRT preprocess  overcomes this limitation in such GPUs by using three sets of buffers: a buffer (4 textures) that represents the most recent direction, a buffer that represents the previous frame's approximation of the integral, and a buffer that is two frames old. The hardware-accelerated PRT preprocess loads a further pixel shader that adds the current contribution into the most recent accumulation buffer, the roles of the accumulation buffers alternate every-frame (e.g., always accumulate into texture buffer (uDir)& and read from (uDir+1)&1.) The pixel shader has two constants that multiply each of the terms\u2014the previously accumulated results are blended with a zero on the first update and a one after, and the current frame is always updated with the normalization factor 4\/uNumDirections, where uNumDirections is a constant that represents the number of directions sampled by the hardware-accelerated PRT preprocess.","4. Final Rendering","When the hardware-accelerated PRT preprocess is finished, the resulting PRT data can be used to render images of the object in a lighting environment as described in the Sloan '533 application. In one implementation, this image rendering with PRT produced by the above-described hardware-accelerated PRT preprocess can use a pixel shader (shown in the assembly code listing  of ) that computes the large dot products for the red, green and blue projection of the lighting environment. The contents of the texture could be transferred to a fixed point texture which can be filtered, such as with GPUs available from ATI Technologies, Inc. Care should be taken to maximize the precision when doing this\u2014each channel can map its largest absolute value to one and then scale the corresponding coefficient of the lighting environment (which is always stored in high precision constant registers) by one over this scale factor. The projection coefficients of the lighting environment have to be rotated into the object space of the object. The sequence of muls\/mads used in the pixel shader shown in listing  scales to larger dot products more efficiently than simply using dp4 instructions.","5. Alternative Implementations","There are several straightforward extensions and improvements that can be made to the hardware-accelerated PRT preprocess detailed above. Multiple directions can be done in a single pass by storing the four shadow z-buffers in the separate color channels of a single texture and having a longer pixel shader. If the directions are coherent, this should have reasonable cache performance, and would cut down on the number of accumulation steps that are necessary. This could also alleviate some of the precision issues associated with the accumulation step.","Further, ID buffers, percentage closer filtering, and angle dependent offsets can be used in the hardware-accelerated PRT preprocess to make the shadow depth buffering phase more accurate.","Finally, the normal texture can be analyzed and slightly more complex geometry can be used based on clustering normals. Only subregions that can have non-zero dot products with the current direction would have to be rasterized. More complex precomputed data structures also can be used to handle regions that can be conservatively classified as either completely shadowed or unshadowed from a given direction.","6. Computing Environment","The above described technique for hardware-acceleration of radiance transfer coefficients computation (such as, the above-detailed hardware-accelerated PRT preprocess  ()) can be implemented on any of a variety of computing devices and environments that include hardware graphics accelerators (e.g., GPUs), including computers of various form factors (personal, workstation, server, handheld, laptop, tablet, or other mobile), distributed computing networks, and Web services, as a few general examples.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 9","b":["900","900"]},"With reference to , the computing environment  includes at least one processing unit  and memory , as well as the graphics processing unit . In , this most basic configuration  is included within a dashed line; The processing unit  executes computer-executable instructions and may be a real or a virtual processor. In a multi-processing system, multiple processing units execute computer-executable instructions to increase processing power. The memory  may be volatile memory (e.g., registers, cache, RAM), non-volatile memory (e.g., ROM, EEPROM, flash memory, etc.), or some combination of the two. The memory  stores software  implementing the hardware-accelerated graphics transfer coefficients computation technique. The graphics processing unit  is a specialized microprocessor that handles high-speed graphics-related processing, such as may be provided on a graphics adapter or integrated into the chip set contained on the motherboard of the computer (e.g., various graphics adapter models currently available from NVIDIA and ATI Technologies, among others). Preferably, the graphics processing unit  is programmable, so as to support executing pixel shaders.","A computing environment may have additional features. For example, the computing environment  includes storage , one or more input devices , one or more output devices ; and one or more communication connections . An interconnection mechanism (not shown) such as a bus, controller, or network interconnects the components of the computing environment . Typically, operating system software (not shown) provides an operating environment for other software executing in the computing environment , and coordinates activities of the components of the computing environment .","The storage  may be removable or non-removable, and includes magnetic disks, magnetic tapes or cassettes, CD-ROMs, CD-RWs, DVDs, or any other medium which can be used to store information and which can be accessed within the computing environment . The storage  stores instructions for the device connectivity and networking software .","The input device(s)  (e.g., for devices operating as a control point in the device connectivity architecture ) may be a touch input device such as a keyboard, mouse, pen, or trackball, a voice input device, a scanning device, or another device that provides input to the computing environment . For audio, the input device(s)  may be a sound card or similar device that accepts audio input in analog or digital form, or a CD-ROM reader that provides audio samples to the computing environment. The output device(s)  may be a display, printer, speaker, CD-writer, or another device that provides output from the computing environment .","The communication connection(s)  enable communication over a communication medium to another computing entity. The communication medium conveys information such as computer-executable instructions, audio\/video or other media information, or other data in a modulated data signal. A modulated data signal is a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media include wired or wireless techniques implemented with an electrical, optical, RF, infrared, acoustic, or other carrier.","The hardware-accelerated radiance transfer coefficients computation techniques herein can be described in the general context of computer-readable media. Computer-readable media are any available media that can be accessed within a computing environment. By way of example, and not limitation, with the computing environment , computer-readable media include memory , storage , communication media, and combinations of any of the above.","The techniques herein can be described in the general context of computer-executable instructions, such as those included in program modules, being executed in a computing environment on a target real or virtual processor. Generally, program modules include routines, programs, libraries, objects, classes, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The functionality of the program modules may be combined or split between program modules as desired in various embodiments. Computer-executable instructions for program modules may be executed within a local or distributed computing environment.","For the sake of presentation, the detailed description uses terms like \u201cdetermine,\u201d \u201cgenerate,\u201d \u201cadjust,\u201d and \u201capply\u201d to describe computer operations in a computing environment. These terms are high-level abstractions for operations performed by a computer, and should not be confused with acts performed by a human being. The actual computer operations corresponding to these terms vary depending on implementation.","In view of the many possible embodiments to which the principles of our invention may be applied, we claim as our invention all such embodiments as may come within the scope and spirit of the following claims and equivalents thereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":["FIG. 5","FIG. 4"]},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 7","FIG. 4"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 9","FIG. 1"]}]},"DETDESC":[{},{}]}
