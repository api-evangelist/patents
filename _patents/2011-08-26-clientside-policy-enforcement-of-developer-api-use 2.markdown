---
title: Client-side policy enforcement of developer API use
abstract: Methods and systems are disclosed that allow automated pre-qualification and qualification of an application. An application description can be generated for an application submitted by a developer, the application description can be automatically examined to determine whether the application complies with rules or guidelines (e.g., policies) of a platform. If the application complies with the rules or guidelines, the application can be pre-qualified and submitted for approval and distribution. If the application does not comply with the rules or guidelines, the application developer can be notified of the errors in the application and the developer can be prevented from uploading the application for approval and distribution.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09619779&OS=09619779&RS=09619779
owner: Apple Inc.
number: 09619779
owner_city: Cupertino
owner_country: US
publication_date: 20110826
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","Example Software Development Process","Example System of Automated Qualification","Example System of Pre-Qualification","Example Pre-Qualification and Qualification Processes","Example System Architecture"],"p":["This subject matter is generally related to software development.","A software development process can include a structure for creating and maintaining a software product. A software development process can include multiple stages. Some example software development stages can include design, implementation, testing, and distribution. Some models of software development processes in existence today include waterfall model, spiral model, agile software development, extreme programming (XP), among others.","Modern software development processes for various data processing systems allow for participation of a vast number of diverse developers for a platform (e.g., a mobile device development platform). Tools for developing software for the platform can include a publicly available software development kit (SDK) and various rules and guidelines. The SDK can include various libraries and an integrated development environment (IDE). Using the SDK, a developer can develop an application program for the platform. The application program can be distributed to data processing systems that are compatible with the platform, for example, through an application store.","Methods and systems are disclosed that allow for client-side policy enforcement of developer application programming interface (API) use. In some implementations, a developer can generate an application description for an application and submit the application description to a server for pre-qualification (e.g., API, configuration and\/or resource validation). If the server determines that the application can be pre-qualified based on the application description, the client can upload the application for approval and distribution. If the server determines that the application cannot be pre-qualified based on application description, the server can send the client a message indicating errors in the pre-qualification process and prevent the client from uploading the application for approval and distribution.","In some implementations, a server can receive an application description for an application, or portion of an application, from a client device and pre-qualify the application based on the application description. Pre-qualification can include validating developer API usage based on the application description. The server can determine which APIs are described in the application description, compare the APIs to API usage policies (e.g., blacklists, whitelists, developer licenses, etc.), generate warnings and errors based on the comparison. Pre-qualification can include validating application metadata (e.g., configuration and\/or resources). The server can compare the metadata to policies that describe allowed and disallowed configurations and resources and generate warnings and errors based on the comparison. The developer can be prevented from uploading the application for approval and distribution when errors are generated. The developer can be allowed to upload the application for approval and distribution when no errors are generated.","Particular embodiments of the subject matter described in this specification can be implemented to realize one or more of the following advantages. Using the automated pre-qualification process, a developer can quickly determine whether the developer's application complies with application approval policies without having to wait for a full application qualification and approval process to be completed. Pre-qualification can be based on the application description alone, without requiring an inspection of the source code of the application program. Thus, a developer need not divulge the source code. If the application description describes system libraries that are beyond the scope of a publicly available SDK, the system can notify the application developer by presenting error and warning messages. Likewise, if the application description includes disallowed configuration data or resources, the application developer can be notified. The system implementing the automated pre-qualification process can detect possible use of deprecated libraries, classes, or functions, and notify the developer that the application program, although working now, may break in a future release of the platform. The developer can thus take cautionary measures (e.g., by using another functionally similar library, class, or function) to make the application program more robust before submitting the full application for final approval.","The details of one or more embodiments of the subject matter described in this specification are set forth in the accompanying drawings and the description below. Other features, aspects, and advantages of the subject matter will become apparent from the description, the drawings, and the claims.","Like reference numbers and designations in the various drawings indicate like elements.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["100","100"]},"The developer can develop () an application. In this specification, any person who engages in any part of developing the application can be a developer. Developing the application can include, for example, gathering requirements, designing the application, writing source code of the application, compiling the source code into binary code, and linking the binary code into executable code.","The application being developed in process  can include any computer instructions that are configured to perform user tasks (e.g., tasks that produce results for a user) or system tasks (e.g., tasks that manage computing resources of a computer) or both. The application can be an application based on a specified platform (e.g., the mobile devices development platform). The platform can include published SDK and libraries. Not all libraries of the platform need to be published. For example, based on various licensing agreements, some system libraries, some classes in a particular library, or some particular functions in a class may not be available to the general public or to a particular developer, depending on a license (e.g., a public license, a preferred license, etc.) held by the developer. Thus, the developer can be prohibited from accessing certain libraries, classes, or functions, even if the libraries, classes, and functions are declared \u201cpublic\u201d (instead of \u201cprivate\u201d or \u201cprotected\u201d) in an object-oriented programming environment. The developer can test () the application, for example, by executing and debugging the executable code.","Once the developer is satisfied with the testing, the developer can submit the application for pre-qualification. Pre-qualification can be performed prior to uploading the entire application to a server for full review and approval. Pre-qualification can provide the developer with feedback faster than if the developer had to wait for completion of the full application review and approval process. Pre-qualification can include API validation, configuration validation and\/or application resource validation.","During prequalification, an application description can be generated for the application (). For example, before uploading the entire application to the server, a software tool can be run on a directory containing the application, or a portion of the application (e.g., library, class, compiled code snippet, etc.), to generate an application description file (e.g., a zip file, archive file, tar file, etc.). The application description can be generated at a client device (e.g., the computer that the developer uses to develop the application). The application description can include executable binary files for the application (e.g., mach-o binary files, executable code, libraries, etc.). The application description can include metadata for the application. For example, application metadata can include application configuration information (e.g., info.plist file information, nib file information, mobile provisioning file information) and\/or selected application resources (e.g., images, icons, etc.).","Once the application description is generated, the application description can be submitted to a server for pre-qualification (). For example, the application description can be transmitted from the client device to a server over a network. The server can compare the application description to policy information to determine if the application description describes an application that complies with the policies specified in the policy information. Policy information (e.g., application development policies) can identify approved and\/or prohibited APIs, configurations and\/or resources for the platform. The policy information can include general policies applied to all developers and\/or policies that are specific to a particular developer (e.g., based on a developer license).","During pre-qualification, the server can automatically determine whether the submitted application description describes libraries, classes, functions, configurations or resources that are prohibited for use by the submitting developer. Pre-qualification can also include automatically determining whether the application program uses deprecated libraries, classes, or functions, such that although the application program can execute properly at the time of the review, the libraries, classes, or functions are scheduled to be change or removed in the future, causing the application program to fail. The server can apply general policies and\/or developer-specific policies that reflect licenses that the developer holds. The server can generate warnings and\/or errors based on the comparison of the application description to the policy information.","In some implementations, the client can wait to receive results of the pre-qualification from the server. For example, the client application that uploaded the application description to the server may use a blocking or synchronous call when sending the application description to the server such that the client will wait to receive the results of the pre-qualification from the server before allowing the developer to upload the application to the server. Once the server has completed its analysis of the application description, the server can send the client a list of warnings and errors resulting from the pre-qualification process. If there are no warnings or errors, the server can send the client an indication that the application description has passed the pre-qualification process. The client can then upload the full application to the server for full review, approval and distribution.","The client can receive pre-qualification warnings and\/or errors (). If the client receives an error (), the developer can be prevented from uploading the application for full review, approval and distribution. The application developer can continue developing () or revising the application to fix the errors and\/or warnings.","If the client receives no errors (e.g., only warnings, no warnings and no errors), the developer can upload the application for full review, approval and distribution (). Alternatively, the developer can skip uploading the application for full review and continue developing the application (). For example, the developer can fix the problems that generated the warning messages and regenerate and resubmit the application description for pre-qualification. For example, the error and warning messages can be presented to the developer using the interfaces described with reference to . In some implementations, pre-qualification can ends at step . For example, the application may still be in development and the developer may not wish to upload the application after the pre-qualification is complete.","Once the application has gone through pre-qualification without error, the developer can submit () the entire application for full review and approval by a system or by a system developer (e.g., a developer responsible for the integrity of the platform). Submitting the application for review can include uploading the source code, the linked binary executable code of the application program, or both, to a server for automatic or manual review. Submitting the application for review can include uploading application resources and configuration information. The review can include a qualification portion and optionally, and additional approval portion. During the qualification portion of the review, a system can automatically determine whether the submitted application, sometimes in compiled and linked binary format only (e.g., without the source code), uses libraries, classes, or functions that are prohibited for use by the submitting developer. The qualification can also include automatically determining whether the application program uses deprecated libraries, classes, or functions, such that although the application program can execute properly at the time of the review, the libraries, classes, or functions are scheduled to be change or removed in the future, causing the application program to fail. The additional approval portion of the review can include, for example, determining that user interface of the application program conforms to guidelines provided with the SDK, or content provided by the application program conforms to local community standards.","The developer can receive () results of the qualification and approval. If the application program is not qualified or approved, a message can be sent to the developer. The message can include a statement that the application program did not pass the review process, a list of one or more errors that occurred, and an explanation for each error. The developer can redesign, reimplement, and retest the application program for submission again.","Upon qualification and approval from the review, the application program can be distributed (). Distributing the application program can include storing the application program in a data store and providing the application program for download by other users (e.g., the general public).","In some implementations, the pre-qualification process can be performed without uploading the full application at step . For example, an application developer may wish to determine whether an application, or a portion of an application, under development will pass pre-qualification (e.g., is using appropriate APIs, configuration, resources, etc.). In this case, the process can include generating a description () of the application, or the portion of an application, submitting the description for prequalification (), and receiving the prequalification warnings and\/or errors () without performing the subsequent steps -.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 2","b":["202","204","204","204","204","205","204","205","204"]},"Application description  can be sent from computing device  to a server through a communication network. The server can include one or more hardware components (e.g., processors and storage devices) and one or more software components. The server can include subsystems that include scanner , classifier , approver , and notifier , among others. Each subsystem can include a hardware component, a software component, or both.","Scanner  can include a subsystem that scans application description  and generates scanned data (e.g., scanned symbols) . Scanner  can include various tools for analyzing application descriptions. An example scanner  can include an object file displaying tool (e.g., \u201cotool\u201d of Apple, Inc. or \u201cnm\u201d tool of Linux). Scanner  can include a subsystem that scans application description  for configuration data that can be used to pre-qualify, or disqualify, application . For example, scanner  can parse an info.plist file included in application description  to determine a name associated with the application. Scanned data  can include the scanned configuration information (e.g., application name).","Scanned data  can include names and version numbers of libraries described by application description , symbols (including indirect symbols that are defined in one source file and referenced in another source file), table of contents for a dynamically linked shared library, reference table of the dynamically linked shared library, module table of the dynamically linked shared library, and other information (e.g., configuration information). Scanned data  can include symbols in their original names (e.g., function \u201cfoo\u201d) or mangled names (e.g., function \u201c_i_xyz_foo_para1_\u201d) or both. In some implementations, scanned data  can include automatically generated identifiers of functions (e.g., selectors). Scanned data  can be in American Standard Code for Information Interchange (ASCII) format, Unicode format, or another textual or binary format (e.g., a compressed archive format).","Classifier  can include a subsystem that generates warnings and errors for application description  based on comparison between scanned data  and application development policy information (e.g., symbol lists, approved\/prohibited configuration data, approved\/prohibited resources) in data store . For example, the warnings and errors can be generated during pre-qualification to give a developer early feedback that the developer's application is not using approved APIs. Data store  can include one or more lists of symbols, configuration data and\/or resources.","Each list of symbols can include symbols with specified characteristics that can be used to determine if application  is using approved or restricted (e.g., prohibited) APIs. For example, a first symbol list in data store  can include symbols that developers using a published SDK are not permitted to access. Some examples of these symbols include names of system libraries, names of classes or methods of a system programming interface (SPI), names of classes that inherit from a system class, etc. A second symbol list in data store  can include names of classes that conflict with system classes, names of dangling classes or functions (e.g., classes or functions that are defined but not referenced), and names of libraries, classes, or functions that are deprecated. Libraries, classes, or functions can be deprecated if the libraries, classes, or functions, or their respective features are superseded or removed in future versions. A third list of symbols can include names of classes or functions that are subject to abuse. Names of classes or functions subject to abuse can include symbols in a published application programming interface (API) that can be used to hide a call to a unpublished API (e.g., an SPI). A fourth list of symbols can include names of classes or functions that are available to a particular application developer. For example, classes or functions that may generally be unavailable to developers may be made available to a particular developer by license agreement. A developer-specific list (e.g., developer specific policy) that identifies symbols that the developer is allowed to use can be stored in data store .","Data store  can also include configuration information and\/or resources that can be compared with scanned data . For example, the configuration information can identify allowed and disallowed configuration data, allowed and disallowed resources, or any other application information.","Classifier  can compare scanned data  with the lists of symbols and metadata (e.g., application development policy data) in data store . For example, comparing the scanned data  with the lists of symbols in data store  can include calculating a match score indicating the likelihood that a symbol in scanned data  matches each of the lists of symbols. In some implementations, a perfect match score (e.g., 1.0) between a scanned symbol and a particular list can indicate that classifier  is certain that a symbol in that list is used in application . A less than perfect match score (e.g., 0.7) can indicate that there is less than one hundred percent likelihood that a symbol in the list is used.","Based on the comparison, classifier  can generate errors and\/or warnings message . For example, classifier  can generate errors for symbols that are described in application description  and that application developers are not permitted to access (e.g., the first symbol list above). Classifier  can generate warnings for symbols that are described in application description  and that are related to deprecated libraries, classes or functions (e.g., the second symbol lists above). Warnings can also be generated when classifier  calculates less than a perfect match score (e.g., below a threshold score, below 0.7) for a symbol that would otherwise generate an error. For example, warnings can indicate to the application developer that the symbols that generated the warnings may be subject to later review and may cause rejection of the developer's application.","In some implementations, classifier  can upgrade or downgrade warnings and errors. For example, if a developer submits application description  having a symbol that is listed in the first symbol list, generally an error is generated. However, if developer has a license to use the symbol (e.g., the symbol is listed in the fourth symbol list associated with the developer) then the error can be downgraded to a warning or the error can be ignored. In some implementations, a warning can be upgraded to an error if a symbol described in application description  is subject to abuse (e.g., listed in the third symbol list above).","Once classifier  has compared scanned data  to the symbol lists, configuration data and\/or resources in data store  and generated warnings and\/or errors message , message  can be sent to computing device . Message  can include information identifying and\/or describing warnings and\/or errors. For example, message  can include only warnings, only errors, a combination of warnings and errors, or no warnings and no errors (e.g., indicating the application passed pre-qualification). When computing device  receives message , computing device can present a user interface for displaying the warnings and\/or errors. For example, computing device  can display the user interface of . If computing device  receives a message  that includes errors, the application developer can be prevented from uploading application . Notifying the application developer of warnings and errors early in the approval process allows the application developer to resolve issues (e.g., API misuse, disallowed configuration, disallowed resources) early in the application approval process without having to wait for completion of the application approval process described below.","If computing device  receives a message  that includes no errors, application  can be sent from computing device  to a server through a communications network. For example, the entire application  can be sent to the server (e.g., rather than just the application description ) once the application description  does not cause classifier  to generate any errors. The full application  can then be scanned by scanner  and classified by classifier .","Scanner  can include a subsystem that scans application  and generates scanned data  (see above). Scanner  can include various tools for analyzing applications. An example scanner  can include an object file displaying tool (e.g., \u201cotool\u201d of Apple, Inc. or \u201cnm\u201d tool of Linux).","Classifier  can include a subsystem that classifies (e.g., categorizes) application  based on comparison between scanned data  and symbol lists in symbol data store . Symbol data store  can include one or more lists of symbols. Each list of symbols can include symbols with specified characteristics that can be used to classify application . For example, a first symbol list in data store  can include symbols that developers using a published SDK are not permitted to access. Some examples of these symbols include names of system libraries, names of classes or methods of a system programming interface (SPI), names of classes that inherit from a system class, etc. A second symbol list in data store  can include names of classes that conflict with system classes, names of dangling classes or functions (e.g., classes or functions that are defined but not referenced), and names of libraries, classes, or functions that are deprecated. Libraries, classes, or functions can be deprecated if the libraries, classes, or functions, or their respective features are superseded or removed in future versions. A third list of symbols can include names of classes or functions that are subject to abuse. Names of classes or functions subject to abuse can include symbols in a published application programming interface (API) that can be used to hide a call to a unpublished API (e.g., an SPI).","Classifier  can compare scanned data  with the lists of symbols in data store . Comparing the scanned data  with the lists of symbols in data store  can include calculating a match score between the scanned data  with each of the lists of symbols. In some implementations, a perfect match score (e.g., 1.0) between a scanned symbol and a particular list can indicate that classifier  is certain that a symbol in that list is used in application . A less than perfect match score (e.g., 0.7) can indicate that there is less than one hundred percent likelihood that a symbol in the list is used.","Based on the comparison, classifier  can classify application  into one of multiple categories (e.g., category one , category two , and category three ). Various actions can be respectively associated with the multiple categories. For example, category one  can be associated with an action of rejection. If application  is classified as category one , application  can be denied further approval and eventual distribution. Category one  applications can be put in a first notification queue.","Notifier  can include a subsystem that can send one or more notifications  to developers based on the classification of the application . For example, when application  is rejected, notifier  can send notification  indicating that application  is rejected and an explanation of reasons of the rejection (e.g., use of an SPI call). Rejected application  can be removed from the first notification queue and from the system.","If application  is classified as category two , application  can be unconditionally qualified. Category two  applications can be sent for approval by approver . Approver  can include a subsystem that approves qualified application . Approver  can include one or more automated processes for determining whether application  complies with various development guidelines that can include, for example, user interfaces specifications, user age requirement, or compliance with local or national community requirements. Once approved by approver , application  can be stored in application store , from where users can access (e.g., purchase for download) application . A reference (e.g., an identifier) of qualified application  can be put in a second notification queue. Notifier  can notify developers of applications in the second notification queue that the developers' applications are qualified. In some implementations, notification  sent by notifier  can include a warning that a symbol scanned from application  is deprecated.","If application  is classified as category three , application  can be conditionally qualified. Category three  applications can be temporarily put on hold before they are sent for approval or distribution, pending developer response to further inquiry. Category three  applications can be put in a third notification queue. Notifier  can send notification  to developers of applications that are in the third notification queue. Notification  for applications in the third notification queue can include the inquiry. The inquiry can seek user explanation, for example, on why a symbol scanned from application  is sufficiently similar to an SPI call. Application  can be sent to approver  if the system receives a satisfactory response from the developer. A satisfactory response can include, for example, an explanation of how the symbol is different from a system symbol even though the symbol is literally similar to the system symbol, or a change to another symbol.","Three example categories , , and  are shown in . In various implementations, more or fewer categories can be used. Furthermore, the categories can be associated with actions other than rejection, conditional qualification, and warning. Other actions are possible.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 3"},"Scanned symbols  can include symbols scanned from the application (e.g., application  of ) or symbols scanned from the application description (e.g., application description  of ). Scanned symbols  can include names of libraries linked into the application. The names can include names of statically linked libraries and dynamically linked libraries. Each library can include a collection of constants, macros, routines, classes, or a combination of two or more of the above. Some libraries can include routines for accessing system functions. For example, a system library for a mobile device platform can include routines for accessing a baseband processor that manages communications functions of the mobile device. Even if every class or function in the system library is declared \u201cpublic\u201d in an object-oriented programming environment, the library may not be provided to the general public for various reasons. Some other libraries not available to the general public can include libraries under testing. The libraries under testing can be made available only to a selected group of developers (e.g., beta testers). To illustrate, a library having the name \u201cabc.lib\u201d as shown in  is a system library or a library under testing and is not to be linked into the application.","Scanned symbols  can include class names and function names. A function can include a global function, a local function, a class method, an instance method, or any other executable routine. In some implementations, names of functions can include mangled (or decorated) names. For example, a mangled function name can include an indicator \u201ci\u201d or \u201cc\u201d that indicates whether the function is an instance method or a class method. The mangled function name can also include a name of the class (e.g., \u201cxyz\u201d). In some implementations, each method can correspond to a unique identifier (e.g., a selector) of the method, in addition to or in place of a mangled name. The selector can include a unique symbol (e.g., an integer) assigned to the method. Scanned symbols  can include text (e.g., ASCII) or binary form of the selector.","Classifier  can compare the scanned symbols  to reference list , which can include a list of known symbols. Reference list  can include library names , class names , and function names . Function names  can include global or local functions, class methods, and instance methods. In some implementations, function names  can include method identifiers (e.g., selectors). In some implementations, reference list  can be a blacklist. If a match between a scanned symbol and a symbol in the list is found, the application from which the symbol is scanned can be automatically rejected.","Classifier  can be a classifier such as classifier  of . Classifier  can include match analyzer  that compares scanned symbols  with symbols in reference list . In some implementations, a match is found if there is an exact match. For example, classifier  can determine that scanned symbols  matches reference list  when a library name (e.g., \u201cabc.lib\u201d) in scanned symbols  literally matches a library name in reference list , or when a selector in scanned symbol  matches a selector in function names  section of reference list .","In some implementations, match analyzer  can identify a match even when an exact match does not exist. Match analyzer  can calculate a match score between a scanned symbol and a symbol in reference list . The match score can indicate a similarity between portions of a first symbol (e.g., the scanned symbol) and a second symbol (e.g., the symbol in reference list ). For example, a first symbol can have mangled name _i_xyz_foo_para1_. The mangled name can indicate that the application includes an instance method (e.g., a method that is associated with an object of a class) \u201cfoo\u201d associated with class \u201cxyz\u201d with parameter \u201cpara1.\u201d This function is not identical, but is similar, to a method name in reference list  having a mangled name _c_xyz_foo_para1_, indicating that the second symbol is a class method (or static method, a method associated with a class \u201cxyz\u201d), as indicated by the \u201cc\u201d prefix. A class method can be treated differently from an instance method, even if they have the same name. In this example, other than the class\/instance distinction, the first symbol and second symbol are identical. The identical portions are indicated in bold type in scanned symbols . Match analyzer  can calculate a match score based on the difference and similarity. Likewise, a first symbol _c_xyz_foo_para2partially match the second symbol _c_xyz_foo_para1_.","In some implementations, match analyzer  can identify a match based on class inheritance. Match analyzer  can identify classes of the scanned symbols  to determine whether a particular class (e.g., \u201csubclass_of_xyz\u201d) is a subclass of a class (e.g., class \u201cxyz\u201d) listed in list .","Classifier  can determine whether the application is classified into a category based on match scores calculated by match analyzer  between scanned symbol  and each reference list . In some implementations, the application is classified into a category (e.g., a \u201crejection\u201d category) if match analyzer  determines that there is an exact match between a scanned symbol (e.g., \u201cabc.lib\u201d) and a symbol (e.g., \u201cabc.lib\u201d) in a list (e.g., a list of unpublished system symbols). In some implementations, the application is classified into a category (e.g., the \u201crejection\u201d category) if, although there are no exact matches, the match score of a scanned symbol satisfies a match threshold, indicating that it is highly likely that the application is using an unpublished library, class, or function. In some implementations, the application is classified into a category (e.g., the \u201crejection\u201d category) if an aggregation of a group of scanned symbols that are similar to the known symbols results in an aggregated match score that satisfied an aggregated match threshold. Aggregating of the group of scanned symbols can include calculating the aggregated match score using a number of scanned symbols that match the known symbols in the list, and the match score of each scanned symbol.","Classifier  can classify the application in a tiered manner. Multiple reference lists  can be used. Each list can correspond to a tier. For example, a tier  list can include unpublished symbols. A tier  list can include a list of symbols that are published, but, if appeared together, can indicate a likelihood of abuse based on historical data, or can be used to hide calls to unpublished SPI functions. A tier  list can include published but deprecated symbols. Each tier can correspond to a different action (e.g., reject, hold, or warn). The system can start by comparing scanned symbols  with tier  lists, tier  lists, and so on, in the order of the tiers.","In addition to or alternative to the tiered lists, classifier  can use characteristics of scanned symbols  to classify the application. For example, classifier  can specify that a threshold number of libraries are required of each application. If a number of linked libraries in scanned symbols  fails to satisfy the threshold number of libraries, classifier  can determine that the application is compiled using an unauthorized compiler or is written to purposefully circumvent unpublished libraries, classes, or functions. Accordingly, classifier  can classify the application such that the application will be rejected or put on hold.","Classifier  can generate warnings and errors during pre-qualification based on match scores calculated by match analyzer  between scanned symbol  and each reference list . For example, errors can be generated when the application description contains information that would cause classifier  to place an application in the rejection category, described above. Warnings can be generated when the application description contains information that would cause classifier  to place an application in a category (e.g., hold) other than rejection or approve.",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 4","b":["404","406"]},"Library scanner  can scan libraries in data store  and applications in data store  to create reference lists , , , and  using rules . Rules  can specify access privileges of each library, class, and function. For example, rules  can specify which library is a published library, which library is an unpublished library, which classes in a particular library have limited access privilege, and which functions in a library or which methods in a class have limited access privilege. In some implementations, rules  can associate the access privileges with various licenses granted to developers. For example, a first license can specify that a developer under the first license can access a first set of libraries, classes, or functions. A second license can specify that a developer under the second license can access a second set of libraries, classes, or functions that are different from the first set. Library scanner can create a set of reference lists to be associated with each license or category of license. When a developer submits an application for qualification, a current license for the user is determined (e.g., based on the user's identification as the user signed up to acquire the SDK), and a corresponding set of references lists is used to qualify, or pre-qualify, the application submitted by the user.","Statistics engine  can monitor the libraries of data store  and existing applications of data store  for patterns of symbol usage. Monitoring can include analyzing the libraries and existing applications to determine a frequency of use of various libraries, classes, and functions. Statistics engine  can submit results of the monitoring to moderator . Moderator  can determine whether a particular symbol is to be moved from a first reference list to a second reference list based on the results. For example, statistics engine  can determine a frequency with which a function is referenced. The statistic engine  can determine that the frequency satisfies a usage threshold. According to current rules , the function is scheduled to be removed in a future release of the SDK. Based on the usage, moderator  can determine that the removal of the function should be delayed to avoid concurrent invalidations of a large number of applications. Moderator  can send a notice of the usage to a system developer and recommend that the function is to be preserved. Upon receiving a response from the system developer indicating that the function is to be preserved, moderator  can modify rule  to specify that the function is not to be deprecated. Additionally or alternatively, moderator  can modify one or more of reference lists , , , and , for example, to remove a symbol of the function from a deprecated function list and insert it into a permissible function list.","Likewise, moderator  can identify which library is used by developers the most, and recommend to the system developer that the most used library can be a first choice of improvement in a next release of the SDK. Moderator  can identify an unpublished library that has caused most rejections of applications, and recommend converting the unpublished library or a modified version of the unpublished library into a published library.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 5","b":"500"},"A developer can create an application on computing device  using an SDK under a license for a platform (e.g., a mobile device development platform). The developer may not knowingly use libraries, classes, or functions to which the developer has no access according to the license. However, the developer links in one or more third party libraries into the executable of the application. The developer can run an application description utility on the application to generate an application description. The developer can send application description  to inspector . Inspector  can include a set of instructions executed on a server that is connected to computing device  through a communications network. The server can be the same server that receives the full application for review, approval and distribution. Inspector  can be a stand-alone application program, a plug-in of an IDE, or a web-based service. Inspector  can include, for example, some or all of components scanner , classifier , and notifier  as described above with respect to .","Inspector  can be coupled to data store , which can store one or more symbol, configuration and resource data reference lists against which the symbol, configuration and resource data scanned from application description  can be compared. For example, a reference list can identify prohibited symbols, configurations, and\/or resources. A reference list can identify allowed symbols, configurations, and\/or resources. A first reference list can be used to modify a second reference list. For example, a developer-specific reference list can identify APIs that the developer is allowed to use (e.g., according to a developer license) even though the APIs may be included on a prohibited API reference list. The reference lists in data store  can be stored remotely (e.g., on a server of the publisher of the SDK or on a server of a third party). The reference lists in data store  can be updated periodically or upon request.","For example, inspector  can scan application description  for symbols and compare the scanned symbols with symbols in the reference lists stored in data store . Inspector  can identify one or more suspicious symbols in the scanned symbols. Each suspicious symbol can be a symbol that matches a symbol in a reference list of symbols that the developer is not permitted to access, a reference list of symbols that are prone to be abused, or a reference list of symbols of libraries, classes, or functions to be removed in the future. Likewise, inspector  can scan application description  for configuration data and\/or resources, compare the scanned configuration data and\/or resources with configuration data and resources in the reference lists stored in data store , and identify suspicious configuration data and\/or resources.","Inspector  can compile a list of warnings and errors associated with the suspicious symbols, configuration data and\/or resources and send notification  to formatter . Formatter  can identify the warnings and errors from notification , associate each warning and error with a reason of suspicion, and format the errors, warnings and the reasons into formatted notification . Formatted notification  can be sent to computing device  for display on a display screen. The developer can modify application  in response, for example, by linking a different library and repeat the pre-qualification process, until application description  no longer generates errors and warnings. The developer can submit the pre-qualified application  for approval once the pre-qualification process produces no errors.","In addition to pre-qualifying an application, system  can qualify other binaries. For example, inspector  can scan and pre-qualify object code (e.g., a compiled section of an application program) or a binary library (e.g., a downloaded third party library). In some implementations, inspector  can use reference lists in data store  to modify warnings and errors (e.g., upgrade to error, downgrade to warning or no error) based on a license associated with an SDK. For example, if a developer acquires a new license that grants the developer more access privileges (e.g., access privileges to a system library that is previously not accessible by the developer), reference lists in data store  can be modified to reflect the terms of the new license and inspector  can upgrade and\/or downgrade warnings and errors according to the modified reference list associated with the developer.",{"@attributes":{"id":"p-0076","num":"0075"},"figref":["FIG. 6","FIG. 5","FIG. 2"],"b":["600","600","514","226","600"]},"Error section  of user interface  can include a display area of user interface  that displays errors. For example, error section  can display a name of an unpublished system library (e.g., \u201cabc.lib\u201d) that is not accessible by the developer under a current license. Error explanation section  can include a display area of user interface  that displays explanation of the errors, as well as suggested change (e.g., \u201cConsider using another library\u201d). When multiple errors are present, error section  can be configured to accept a user input scrolling the errors and selecting a particular error. Explanation section  can display the explanation of the selected error.","Warning section  can include a display area of user interface  that displays warnings. In some implementations, warning section  can display a name of a class (e.g., \u201cxyz\u201d) that is historically subject to abuse. For example, class \u201cxyz\u201d from in the library linked in by the user can include features that are known to be subject to security attack by hackers. Warning section  can also display names of libraries, classes, and functions (e.g., class function \u201cfoo\u201d and instance function \u201cbar\u201d) that will be changed or removed.","Warning explanation section  can include a display area of user interface  that displays explanation of the warnings, as well as suggested change. When multiple warnings are present, warnings section  can be configured to accept a user input scrolling the warnings and selecting a particular warning. Explanation section  can display the explanation of the selected warning.",{"@attributes":{"id":"p-0080","num":"0079"},"figref":"FIG. 7A","b":["700","700","700","702"]},"The system can scan the application description for symbols and metadata (). For example, the system can scan for symbols contained in the executable binary files that represent libraries, classes and functions that are referenced in the executable binary files. The system can scan the metadata for configuration information (e.g., product name, version number, etc.).","The system can compare the symbols and\/or metadata to policy data (). For example, the system can compare the symbols to API policy information that specifies which APIs an application developer can use. The system can compare the symbols and\/or metadata to general policy data (e.g., policies that apply to all developers, reference lists). The system can compare the symbols and\/or metadata to developer-specific policy data (e.g., policy data that reflects the terms of a developer's license).","If the symbols and metadata included in the application description do not comply with the policies defined in the policy data, the system can generate warnings and\/or errors that can be transmitted () to the developer to notify the developer that the application does not comply with the policies. The application developer can be notified that that the application developer will not be able to upload the application for qualification and approval until the errors are resolved.",{"@attributes":{"id":"p-0084","num":"0083"},"figref":"FIG. 7B","b":["750","750","750"]},"The system can scan () an application for first symbols. The application can be an application program submitted by a developer for approval. The first symbols can include at least one of a library name, a class name, and a function name. The function name can include a mangled function name, a function identifier (e.g., a selector), or both. The function can include a global function, a local function name, or a class method or an instance method, or any executable routine.","The system can compare () the scanned first symbols with multiple lists of second symbols. Each of the multiple lists of second symbols can correspond to a specified access privilege of the second symbols in the lists that has been granted to the application. The second symbols can include at least one of a library name, a class name, and a function name. For example, the list of second symbols can include a first list of system symbols, including names of system libraries, classes, or functions. Under a current license of the developer submitting the application, an access from the submitted application to the system libraries, classes, or functions in the first list can be prohibited.","The list of second symbols used in stage  can include a second list of published symbols. Under the current license, access from the application to the published symbols is permitted for an indefinite amount of time. The list of second symbols used in stage  can include a third list of deprecated symbols. The access to the deprecated symbols can be permitted for a limited amount of time (e.g., until a deprecated library, class, or function is removed).","In stage , comparing the scanned first symbols with the multiple lists of second symbols can include calculating a likelihood that the scanned first symbols match one of the lists of the second symbols. Calculating the likelihood can include calculating a match score between each scanned first symbol and each second symbol of a list of second symbols. The match score can measure a probability that a scanned first symbol is equivalent to a second symbol, even when the scanned first symbol literally differs from the second symbol. The system can associate the match score to the scanned first symbol, and calculate the likelihood based on an aggregation of the match scores. In some implementations, calculating the likelihood can include identifying one or more of the scanned first symbols whose associated matching scores exceed a threshold, and calculating the likelihood based on a ratio between the identified one or more of the scanned first symbols and a number of all of the scanned first symbols.","The system can classify () the application at least in part based on the comparing. In some implementations, the system can provide trustworthy users preferred status. The system can determine () a trustworthiness of a user (e.g., the developer submitting the application program currently being qualified) based on the classification of the currently submitted application and a history of classification of application programs submitted by the developer. For example, if the total number of applications submitted by the developer satisfies a threshold number, and a threshold percentage of the submitted applications (e.g., 100%) are qualified, the developer can be designated as a trustworthy developer.","The system can add () an identifier of the user to an expedited process list, such that future submissions of applications by the user are qualified in an expedited manner. Approving an application in the expedited manner can include moving the application to a head of a queue of application waiting to be examined. Approving an application in the expedited manner can include giving more weight to the symbols used in the application when the system determines a frequency of use of the symbols.","In some implementations, process  can optionally include creating the lists of second symbols automatically. Creating the lists of second symbols can include determining a popularity score of a first symbol scanned from historically submitted applications, and adding the first symbol to a list of published symbols the access to which is permitted for an indefinite amount of time based on the popularity score.",{"@attributes":{"id":"p-0092","num":"0091"},"figref":["FIG. 8A","FIG. 7A"],"b":["800","800","708","700","800","800"]},"The system can receive () results of comparison between first symbols scanned from an application description and lists of second symbols. The application description can be submitted by a user (e.g., a developer). Pre-qualifying the application can include performing an action on the user-submitted application description.","The system can make a first determination at stage  on whether to generate an error. The first determination can include determining whether the scanned first symbols include unpublished symbols. The first determination can include determining whether the scanned first symbols include symbols that indicate that the application uses classes inherited from system classes, or classes private to the system developers. The first determination can include determining whether the scanned first symbols include names of system libraries, or libraries private to the system developers. Upon determining that an error should be generated, the system can generate an error ().","Upon determining that an error need not be generated, the system can make a second determination at stage  on whether to generate a warning. The second determination can include determining that the likelihood that at least one of the first symbols scanned from the application uses a system function or a function private to a system developer satisfies a threshold. The likelihood can be calculated based on the match scores associated with the first symbols. For example, the likelihood can be calculated based on an aggregation of the match scores. Upon determining that a warning should be generated, the system can generate the warning ().","The system can make a third determine whether to generate a warning at stage . The third determination can include determining whether a class name in the scanned symbols is identical to a name of a system class or a private class, but the scanned symbols excludes a library containing the system class or private class. This can indicate that the application uses a class definition that conflicts with the system class or private class. The third determination can include determining whether any libraries, classes, or functions are dangling. For example, the system can determine that a class or a function is defined but not referenced. The third determination can include determining whether the scanned first symbols include a deprecated library, class, or function. Upon determining that a warning should be generated at stage , the system can generate the warning ().","In some implementations, at least one of the second determination of stage  and the third determination of stage  can include determining whether the scanned symbols include symbols identified as part of an API that is subject to abuse. An API that is subject to abuse can include a published API that can be used to hide system or private API usage. Additionally or alternatively, at least one of the second determination of stage  and the third determination of stage  can include determining whether a number of libraries linked into the application falls below a threshold. If there are too few linked libraries, the system can determine that an unapproved library is used, which can circumvent system or private API usage.","Moreover, stages ,  and  can include determining whether the scanned symbols include symbols identified as part of an API that the developer has a license to use. For example, if the developer has a license to use an API that generated an error or a warning, the error or warning may be downgraded such that the error or warning is disregarded, no error or warning notification is sent to the developer, and the developer may be allowed to upload the application for review, approval and distribution.","Upon determining that no errors have been generated during pre-qualification (), the system can notify () the developer of any warnings that have been generated and allow the developer to upload the application corresponding to the application description. For example, the system can send a message to the developer that warns the developer that the system has identified a likely call to an unpublished function.","Upon determining that at least one error was generated during pre-qualification, the system can notify () the developer of the reasons for the error and prevent the developer from uploading the full application for approval and distribution. The notification can include a description of the reasons for the errors, or details describing which symbols have caused the errors.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":["FIG. 8B","FIG. 7B"],"b":["850","850","756","750","800","850"]},"The system can receive () results of comparison between first symbols scanned from an application and lists of second symbols. The application can be submitted by a user (e.g., a developer). Classifying the application can include performing an action on the user-submitted application.","The system can make a first determination at stage  on whether to take a rejection action. The first determination can include determining whether the scanned first symbols include unpublished symbols. The first determination can include determining whether the scanned first symbols include symbols that indicate that the application uses classes inherited from system classes, or classes private to the system developers. The first determination can include determining whether the scanned first symbols include names of system libraries, or libraries private to the system developers.","Upon determining that the rejection action is to be taken, the system can automatically reject () the application. Rejecting the application can include discarding the application. The system can notify () the developer reasons for the rejection. The notification can be send as an electronic mail. The electronic mail can include a summary of the reasons for the rejection, or details describing which symbols have caused the rejection.","Upon determining that the rejection action need not be taken, the system can make a second determination at stage  on whether to take a hold action. The second determination can include determining that the likelihood that at least one of the first symbols scanned from the application uses a system function or a function private to a system developer satisfies a threshold. The likelihood can be calculated based on the match scores associated with the first symbols. For example, the likelihood can be calculated based on an aggregation of the match scores.","Upon determining that the hold action is to be taken, the system can hold () the application in an on-hold queue. The system can automatically notify () the developer that the system has identified a likely call to an unpublished function. The notification can include an inquiry for explanation with regard to the symbol. Upon receiving a satisfactory response to the inquiry, the system can move the application from the on-hold queue and send the application for further approval or distribution.","Upon determining that the hold action need not be taken, the system can make a third determination at stage  on whether to take a warn action. The third determination can include determining whether a class name in the scanned symbols is identical to a name of a system class or a private class, but the scanned symbols excludes a library containing the system class or private class. This can indicate that the application uses a class definition that conflicts with the system class or private class. The third determination can include determining whether any libraries, classes, or functions are dangling. For example, the system can determine that a class or a function is defined by not referenced. The third determination can include determining whether the scanned first symbols include a deprecated library, class, or function.","Upon determining that the warn action is to be taken, the system can qualify () the application. The application program can be subject to further approval. The system can warn () the developer by sending a warning message to the developer informing the developer of the determination.","In some implementations, at least one of the second determination of stage  and the third determination of stage  can include determining whether the scanned symbols include symbols identified as part of an API that is subject to abuse. An API that is subject to abuse can include a published API that can be used to hide system or private API usage. Additionally or alternatively, at least one of the second determination of stage  and the third determination of stage  can include determining whether a number of libraries linked into the application falls below a threshold. If there are too few linked libraries, the system can determine that an unapproved library is used, which can circumvent system or private API usage.","Upon determining that the warn action need not be taken, the system can qualify () the submitted application and notify () the developer submitting the application that the application has been qualified.",{"@attributes":{"id":"p-0111","num":"0110"},"figref":["FIG. 9","FIGS. 1-8"],"b":["900","900","902","904","906","908","912","910"]},"The term \u201ccomputer-readable medium\u201d refers to any medium that participates in providing instructions to processor  for execution, including without limitation, non-volatile media (e.g., optical or magnetic disks), volatile media (e.g., memory) and transmission media. Transmission media includes, without limitation, coaxial cables, copper wire and fiber optics.","Computer-readable medium  can further include operating system  (e.g., Mac OS\u00ae server, Windows\u00ae NT server), network communication module , database interface , scanner , classifier , approver , and notifier , as described in reference to . Operating system  can be multi-user, multiprocessing, multitasking, multithreading, real time, etc. Operating system  performs basic tasks, including but not limited to: recognizing input from and providing output to devices , ; keeping track and managing files and directories on computer-readable mediums  (e.g., memory or a storage device); controlling peripheral devices; and managing traffic on the one or more communication channels . Network communications module  includes various components for establishing and maintaining network connections (e.g., software for implementing communication protocols, such as TCP\/IP, HTTP, etc.). Database interface  can include interface to various data stores such as data stores , , and , as described above in reference to  and . Scanner  can include a scanner that corresponds to scanner  as described above with respect to . Classifier  can include a classifier that corresponds to classifier  as described above in reference to  and classifier  as described above with respect to . Approver  can include an approver that corresponds to approver  as described above in reference to . Notifier  can include a notifier such as notifier  as described above in reference to .","Architecture  can be included in any device capable of hosting a database application program. Architecture  can be implemented in a parallel processing or peer-to-peer infrastructure or on a single device with one or more processors. Software can include multiple software components or can be a single body of code.","The described features can be implemented advantageously in one or more computer programs that are executable on a programmable system including at least one programmable processor coupled to receive data and instructions from, and to transmit data and instructions to, a data storage system, at least one input device, and at least one output device. A computer program is a set of instructions that can be used, directly or indirectly, in a computer to perform a certain activity or bring about a certain result. A computer program can be written in any form of programming language (e.g., Objective-C, Java), including compiled or interpreted languages, and it can be deployed in any form, including as a stand-alone program or as a module, component, subroutine, or other unit suitable for use in a computing environment.","Suitable processors for the execution of a program of instructions include, by way of example, both general and special purpose microprocessors, and the sole processor or one of multiple processors or cores, of any kind of computer. Generally, a processor will receive instructions and data from a read-only memory or a random access memory or both. The essential elements of a computer are a processor for executing instructions and one or more memories for storing instructions and data. Generally, a computer will also include, or be operatively coupled to communicate with, one or more mass storage devices for storing data files; such devices include magnetic disks, such as internal hard disks and removable disks; magneto-optical disks; and optical disks. Storage devices suitable for tangibly embodying computer program instructions and data include all forms of non-volatile memory, including by way of example semiconductor memory devices, such as EPROM, EEPROM, and flash memory devices; magnetic disks such as internal hard disks and removable disks; magneto-optical disks; and CD-ROM and DVD-ROM disks. The processor and the memory can be supplemented by, or incorporated in, ASICs (application-specific integrated circuits).","To provide for interaction with a user, the features can be implemented on a computer having a display device such as a CRT (cathode ray tube) or LCD (liquid crystal display) monitor for displaying information to the user and a keyboard and a pointing device such as a mouse or a trackball by which the user can provide input to the computer.","The features can be implemented in a computer system that includes a back-end component, such as a data server, or that includes a middleware component, such as an application server or an Internet server, or that includes a front-end component, such as a client computer having a graphical user interface or an Internet browser, or any combination of them. The components of the system can be connected by any form or medium of digital data communication such as a communication network. Examples of communication networks include, e.g., a LAN, a WAN, and the computers and networks forming the Internet.","The computer system can include clients and servers. A client and server are generally remote from each other and typically interact through a network. The relationship of client and server arises by virtue of computer programs running on the respective computers and having a client-server relationship to each other.","A number of implementations have been described. Nevertheless, it will be understood that various modifications can be made without departing from the spirit and scope of the disclosure. For example, an application is described. In various implementations, binaries other than application programs (e.g., libraries) or application programs other than binaries (e.g., applications written in a script language in plain text) can be automatically qualified. Accordingly, other implementations are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 9","FIGS. 1-8"]}]},"DETDESC":[{},{}]}
