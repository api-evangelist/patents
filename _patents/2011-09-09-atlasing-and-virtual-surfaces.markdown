---
title: Atlasing and virtual surfaces
abstract: Atlasing and virtual surface techniques are described. In one or more implementations, virtual surface functionality is exposed by an operating system for access by one or more applications of the computing device. A virtual surface is created in response to a request from the one or more applications to be used to render visuals for display by a display device. The virtual surface is allocated in memory of the computing device by the exposed virtual surface functionality to have an area that is larger than an area to be used to display the visuals from the one or more applications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09324299&OS=09324299&RS=09324299
owner: MICROSOFT TECHNOLOGY LICENSING, LLC.
number: 09324299
owner_city: Redmond
owner_country: US
publication_date: 20110909
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION","CONCLUSION"],"p":["The variety of computing device configurations continues to increase. From traditional desktop personal computers to mobile phones, game consoles, set-top boxes, tablet computers, and so on, the functionality available from each of these configurations may vary greatly.","Consequently, traditional display techniques that were developed for one configuration may not be as well suited for another configuration. For example, display techniques that were previously utilized for devices having significant memory resources may be ill-suited for devices having fewer resources.","Atlasing and virtual surface techniques are described. In one or more implementations, virtual surface functionality is exposed by an operating system for access by one or more applications of the computing device. A virtual surface is created in response to a request from the one or more applications to be used to render visuals for display by a display device. The virtual surface is allocated in memory of the computing device by the exposed virtual surface functionality to have an area that is larger than an area to be used to display the visuals from the one or more applications.","In one or more implementations, a computing device comprises one or more modules implemented at least partially in hardware and configured to implement an operating system to expose one or more applications programming interfaces for access by one or more applications to update visuals to be rendered for display by a display device. The application programming interfaces (APIs) include a begin draw application programming interface (API) that is configured to accept a size and offset of a portion of a logical surface that is to be updated and a suspend draw application programming interface (API) that is configured to suspend an update that is to be performed for the portion of the logical surface. The application programming interfaces (APIs) also include a resume draw application programming interface (API) that is configured to access the portion of the logical surface from a suspended state to continue an update and an end draw application programming interface (API) that is configured to indicate an end of the update to the operating system.","In one or more implementations, one or more computer-readable storage media comprising instructions stored thereon that, responsive to execution by a computing device, causes the computing device to implement an operating system that comprises an allocator module configured to manage distribution and positioning of logical surfaces inside of an atlas, each the logical surfaces configured to include one or visuals received from an application for rendering, and an update manager module to manage allocation and reconciliation of updates, received from the application, with a surface allocation to be rendered for display by a display device.","This Summary is provided to introduce a selection of concepts in a simplified form that are further described below in the Detailed Description. This Summary is not intended to identify key features or essential features of the claimed subject matter, nor is it intended to be used as an aid in determining the scope of the claimed subject matter.","Overview","Applications traditionally created windowless swap chains that involved a front and back buffer that was associated with each visual, which could result in an inefficient use of resources of a computing device when used alone. For example, an application using these traditional techniques may utilize six different buffers (e.g., texture video memory) to update three different visuals. This inefficiency could be exacerbated in scenarios that could involve significant numbers of visuals that are to animate at once or in response to a user input such as a tile deletion, panning, or zooming scenario. In such scenarios, a start-up cost in terms of computing device resources to create the shared surfaces plus the swap chains may become prohibitive as the number of elements to be animated increases. This could result in slow or delayed animation and lags in response time for the end user.","Atlasing and virtual surface techniques are described herein. In one or more implementations, these techniques may be used to reduce resource usage of a computing device to render visuals. For example, these techniques may be used to reduce memory consumption as well as a number of surfaces created for an application to achieve an animation and composition scenario, which may be accomplished through atlasing. These techniques may also be used to enable applications to break surfaces of content into tiles and render the tiles ahead of time, which may be accomplished through use of virtual surfaces. Further discussion of atlasing and virtual surfaces may be found in relation to the following sections.","In the following discussion, an example environment is first described that is operable to perform the atlasing and virtual surface techniques described herein. Examples procedures are then described, which are operable in the example environment as well as in other environments. Likewise, the example environment is not limited to performance of the example procedures.","Example Environment",{"@attributes":{"id":"p-0022","num":"0021"},"figref":["FIG. 1","FIGS. 7 and 8"],"b":["100","100","102","104","106","108","110","102","102"]},"The computing device  also includes an operating system  that is illustrated as being executed on the processing system  and is storable in memory . The computing device  further includes applications  that are illustrated as being stored in the memory  and are also executable on the processing system . The operating system  is representative of functionality of the computing device  that may abstract underlying hardware and software resources for use by the applications . For example, the operating system  may abstract functionality of how data is displayed on the display device  without the applications  having to \u201cknow\u201d how this display is achieved. A variety of other examples are also contemplated, such as to abstract the processing system  and memory  resources of the computing device , network resources, and so on.","The computing device  is also illustrated as including a composition module . Although illustrated as part of the operating system , the composition module  may be implemented in a variety of ways, such as a stand-alone module, as a separate application, as part of hardware of the computing device  itself (e.g., a SOC or ASIC), and so on. The composition module  may employ a variety of techniques to render visuals, such as to expose functionality via one or more application programming interfaces (APIs)  for use by the applications  to render visuals.","For example, one such technique may be based on an object called a swap chain, which may leverage an array of buffers representing a bitmap. One of the buffers, for instance, may be used to present data on the display device  at any one time and therefore may be called the \u201conscreen buffer\u201d or \u201cfront buffer.\u201d The other buffers are made available to an application  for rasterization off screen and therefore may be referred to as an \u201coff-screen buffer\u201d or \u201cback buffer.\u201d","An application  may make a change to what is displayed on the display device  in a variety of ways. In a first such technique, the application  can redraw one of the back buffers and \u201cflip\u201d the contents, such as by making one of the off-screen buffers the onscreen buffer using a pointer and vice versa.","In a second such technique, buffers of different sizes may also be leveraged. For example, the composition module  may leverage a first buffer as an onscreen buffer. The composition module  may also leverage a second buffer that is smaller than the first buffer as an off-screen buffer. Therefore, when an update is to be made to the content, the update may be rasterized to the second buffer. The update may then be copied to the onscreen buffer, e.g., using a blt. In this way, resources of the computing device  may be conserved.","The composition module  may also be configured to support atlasing and virtual surface techniques. These techniques may be used to assist developers of the applications  to reduce resources of the computing device  that are used to render visuals. This may include atlasing, which may be used to reduce memory  consumption, e.g., by decreasing a number of surfaces created for the application  to achieve an animation and composition scenario. This may also include use of virtual surfaces, thereby enabling applications  to break a surface of visual data into tiles and then render the tiles ahead of time.","Atlasing may be implemented using a variety of functionality, illustrated examples of which include an allocator module , a virtual surface  having one or more logical surfaces , and an update manager module . The allocator module  is representative of functionality to act as an \u201catlas packing mechanism\u201d to manage the distribution and positioning of logical surfaces  inside of an atlas, including memory  compaction and reuse, as well as the creation and destruction of additional atlas surfaces as desired.","A virtual surface may be configured as a collection of one or more logical surfaces . The logical surface  is representative of an individual surface as seen by the application  and may be associated with one or more visuals. The logical surface , for instance, may be configured as tiles having a fixed size and a plurality of which may be arranged in a fixed grid, although it should be readily apparent that a variety of other instances are also contemplated.","A virtual surface  may be built on top of one or more physical atlas surfaces. Additionally, the virtual surface may be used to represent an area that is larger than an area represented by a texture. For example, the application  may specify a size of a virtual texture at creation time. The size establishes the boundaries for the virtual surface. The surface can be associated with one or multiple visuals. In one or more implementations, when a virtual surface is first initialized, it is not backed by actual allocations. In other words, the virtual surface  may not \u201chold bits\u201d upon initialization but may do so at a later point in time.","The update manager module  is representative of functionality of the composition module  to manage allocation of update regions and reconciliation of updates with a final surface allocation. The update manager module , for instance, may be employed to perform synchronous as well as asynchronous updates, further discussion of which may be found in relation to the following figures.","Generally, any of the functions described herein can be implemented using software, firmware, hardware (e.g., fixed logic circuitry), or a combination of these implementations. The terms \u201cmodule,\u201d \u201cfunctionality,\u201d and \u201clogic\u201d as used herein generally represent software, firmware, hardware, or a combination thereof. In the case of a software implementation, the module, functionality, or logic represents program code that performs specified tasks when executed on a processor (e.g., CPU or CPUs). The program code can be stored in one or more computer readable memory devices. The features of the atlasing and virtual surface techniques described below are platform-independent, meaning that the techniques may be implemented on a variety of commercial computing platforms having a variety of processors.","For example, the computing device  may also include an entity (e.g., software) that causes hardware of the computing device  to perform operations, e.g., processors, functional blocks, and so on. For example, the computing device  may include a computer-readable medium that may be configured to maintain instructions that cause the computing device, and more particularly hardware of the computing device  to perform operations. Thus, the instructions function to configure the hardware to perform the operations and in this way result in transformation of the hardware to perform functions. The instructions may be provided by the computer-readable medium to the computing device  through a variety of different configurations.","One such configuration of a computer-readable medium is signal bearing medium and thus is configured to transmit the instructions (e.g., as a carrier wave) to the hardware of the computing device, such as via a network. The computer-readable medium may also be configured as a computer-readable storage medium and thus is not a signal bearing medium. Examples of a computer-readable storage medium include a random-access memory (RAM), read-only memory (ROM), an optical disc, flash memory, hard disk memory, and other memory devices that may use magnetic, optical, and other techniques to store instructions and other data.","In the following discussion, a visual may refer to a basic composition element. For example, a visual may contain a bitmap and associated compositional metadata for processing by the composition module . A visual's bitmap can be associated with a swap chain (e.g., for dynamic content such as video) or an atlas surface (e.g., for semi-dynamic content). The two presentation models may be supported in a single visual tree that is supported by the composition module .","For semi-dynamic content, an atlas serves as the updating model for the visual's bitmap and may refer to an aggregate layer which may include a plurality of layers to be rendered, although a single layer is also contemplated. The visual and its property manipulations (e.g. offset, transform, effect, and so on) as well as the methods to update the visual's atlas-based-bitmaps (BeginDraw, SuspendDraw, ResumDraw, EndDraw) are exposed via application programming interfaces, whereas the atlas layer size, tiles size, packing\/compaction\/management of bitmap updates is completely hidden from the application. This guarantees we can make the appropriate tradeoffs to rich better performance.","A swap chain refers to a series of buffers that may \u201cflip\u201d to the screen on after another, such as by changing pointers. Accordingly, a flip mode is a mode by which a swap chain technique is used to make an off-screen buffer an onscreen buffer, e.g., through the use of swapping points between the off-screen and onscreen buffers. However, a blt mode refers to a technique in which a runtime of the composition module  issues a \u201cblt\u201d (e.g., bit block image transfer) from an off-screen buffer to an onscreen buffer, which may be used to update the onscreen buffer. An example implementation using these terms is now discussed.","Allocator Module ",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 2","FIG. 1"],"b":["200","118","118","118","202","204","202","122","204"]},"Another set of objects involves a dynamic row , which may be defined as a horizontal slice of an atlas . In one or more implementations, the dynamic row  may be configured to contain one or more dynamic blocks  of the same height but may have the same or different widths. Naturally, other implementations are also contemplated in which different heights and the same widths are also contemplated, different heights and widths, and so on.","A further set of objects is illustrated as a dynamic bucket . In one or more implementations, the dynamic bucket  may refer to a collection of dynamic rows  having a matching height. Again, other implementations are also contemplated in which different heights may also be addressed.","Yet another set of objects refers to a dynamic pool . In one or more implementations, a dynamic pool  may refer to a collection of dynamic buckets  and map \u201cone-to-one\u201d to an atlas  surface. Again, other implementations are also contemplated.","In one or more examples, the allocator module  may be configured to break up the atlas  into rows, which may be further broken down into blocks. Accordingly, in this example the blocks in a row have a matching height, which may be used to facilitate compaction and reuse of the memory . Additionally, multiple rows having a matching height may be efficiently managed together, e.g., as it may be efficient to manage compaction across similar rows.","The allocator module  may perform a variety of functions, including allocation, de-allocation, and compaction. In regards to allocation, when a logical surface  is created, the allocator module  may locate an appropriate dynamic row  that \u201chas room\u201d for the corresponding dynamic block . Once located, the allocator module  may mark the memory  as \u201cin use.\u201d If a dynamic row  is not available, the allocator module  may attempt to create a new dynamic row  in an existing atlas . If there is not enough space in the existing atlas , the allocator module  may attempt to create a new atlas.","Regarding de-allocation, when a logical surface  is deleted, the allocator module  may marks respective portions of the memory  as reclaimable. However, reclamation of this portion of memory  may wait until later, e.g., until memory  is desired for use in re-allocation.","Regarding compaction, when there is insufficient space in the memory  for a logical surface  allocation, the allocator module  may attempt to \u201ccompact\u201d current usage of the memory . For example, the allocator module  may attempt to reclaim unused memory  and move existing allocations around (e.g., to different addresses in the memory) in an attempt to free up enough contiguous memory to satisfy the new allocation before allocating a new row or a new atlas.","Logical Surface  Management","The composition module  may expose an object (e.g., \u201cIDCompositionSurface\u201d) as a logical representation of a region on a physical atlas surface. The composition module  may also expose APIs  that are accessible for the application  to create, update, and delete these logical surfaces. Each surface may be associated with one or more visuals.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 3","b":["300","110","114","302","304","306","308"]},"An application , for instance, may update a logical surface  by calling begin draw  and by passing a size and offset of a rectangle on the logical surface that is to be updated. The composition system  may then allocate and enforce a rectangle of the specified size on the physical atlas and return the atlas surface and the corresponding offset to be used to draw\/update to the calling application .","More than one pending update may be involved with the application . In one or more implementations, to support this scenario the application  calls suspend draw  on a first surface. This is performed before calling begin draw  for a second surface or resume draw , e.g., to go back to a suspended surface. End draw , as the name implies, refers to an end of the update. In one or more implementations, suspend draw  is not used to present or discard the content, rather the end draw  operation is used through calling the respective API.","Update Manager Module ","The update manager module  of the composition module  may make a logical distinction between two types of atlases, e.g., an update atlas and a texturing atlas. The update atlas may be used as a scratch surface, e.g., a surface returned to the application  when begin draw  or resume draw  is called to make updates. A texturing atlas, on the other hand, is an atlas from which the composition module  may apply textures.","The update manager module  of the composition module  may process updates using a variety of different techniques. This may be determined by the update module , for instance, by using heuristics. Examples of such techniques include synchronous updates and asynchronous updates as described below.","Synchronous Updates","In this model, changes made to an update atlas are copied to a texturing atlas (e.g., using a blt operation) for consumption by the composition module . The copy may be initiated responsive to a call made to \u201ccommit\u201d by the application . When the application  is done generating the update, the application  may call \u201ccommit.\u201d In response, the composition module  may execute a series of copy operations (e.g., blt's) to copy updated content from the update atlas to the texturing atlas. The composition module  may also issue a \u201cpresent\u201d call at the time of commit to synchronize bitmap updates with visual changes, i.e., transactional synchronization.","Asynchronous Updates","In this model, the composition module  may maintain a hybrid atlas that includes both an update and texture surface. Additionally, the application  and the composition module  may have read\/write access to different regions of the surface at the same time. The composition module  may manage the state of this hybrid atlas, e.g., to ensure an updatable region is not a potential source for texturing.","There are a variety of different scenarios for which an asynchronous update may be used. One such scenario involves whether an update affects a totality of a logical surface area. In this case, the composition module  may give the application  a new logical surface on the texturing atlas such that the update may be made directly to the texturing surface without using a copy operation, e.g., a blt.","Another such scenario involves whether an update affects a majority of a logical surface. For example, the majority may be defined as more than two thirds of an area of a logical surface . In this case, the composition module  may allocate a new logical surface on a texturing atlas and return to the application  a portion (e.g., sub-rectangle) of the new surface that is to be used to make updates. In addition, the composition module  may execute a copy operation (e.g., blt) to copy over unchanged areas from the old surface to the new one.","A further such scenario involves whether an update affects a minor part of a logical surface. In this case, a copy operation (e.g., blt) may be issued except that the portion (e.g., sub-rectangle) returned to the application  may be on the same texturing surface, e.g., depending on a cost of same-surface copy operations.","Virtual Surface ","As previously described, when a virtual surface  is first initialized in one or more implementations, it is not backed by actual allocations. In other words, it does not \u201chold any bits.\u201d The composition module  may perform allocation of tiles (i.e., composition surface objects) once the application  starts updating the surface. Similar to atlasing, the application  can update the virtual surface  via the begin draw , suspend draw , resume draw , and end draw  API calls to respective operations. The mapping may be determined by an internal atlasing algorithm of the composition module  and is not made visible to the application  in one or more implementations.","Additionally, the composition module  may expose functionality via APIs  to enable applications  to resize and trim a virtual surface . For example, a resize operation may be used to change the boundaries of the virtual surface . This means that new updates and\/or allocations are to fall within the boundaries set by the new size. The application  may also use this method to inform the composition module  that a certain region of the virtual surface  is no longer being utilized and thus is available for reclamation. If the resize results in shrinking the area, the application  is no longer be able to make updates to the regions outside of the new boundaries through management by the composition module .",{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 4","b":["400","402","404","404","106","114","110"]},"Additionally, the resize operation may be initiated by the composition module  in response to receipt of indication of the operation in one or more implementations. For example, the composition module  may implement resize updates upon receipt of the indication without waiting for the application to call \u201ccommit.\u201d For example, an application may call \u201cResize(0, 0),\u201d \u201cResize(INT_MAX, INT_MAX),\u201d and \u201cCommit( )\u201d In this example, the application  has caused the content to be discarded on the first resize, so the second resize does not have an effect even though it was called before \u201cCommit( )\u201d In this case, the display device  does not display content as none is available for display.","A trim operation may be used to describe a region of a virtual atlas  to the composition module  that is requested by the application . Thus, the trim operation may be performed without resizing boundaries of the virtual surface . However, it does tell the composition engine  which logical surfaces are to be allocated at present, an example of which is described in relation to the following figure.",{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 5","b":["500","502","504","506","502","504","502","506"]},"As a page that is represented by the virtual surface is scrolled, the application may now cause the last six tiles to be rendered as shown in the second stage . Accordingly, the application  may call \u201ctrim\u201d to indicate that the region defined by the last six tiles is currently being used and thus the rest of the content is not currently being utilized. The composition module  may then choose to recycle the logical surfaces  that originally represented the first 6 tiles.","As described above, the composition module  may support a variety of functionality. For example, an atlasing implementation may be hidden from the application  by the composition module  which may be used to ensure that the application  is to consume less than two times the surface memory for each visual.","The composition module  manages the allocator module  to perform atlas packing and surface allocation and de-allocation. The application  may also specify whether a visual is associated with a swap chain (e.g., for dynamic content such as video) or an atlas surface (e.g., for semi-dynamic content). The two presentation models may be supported in a single visual tree that is supported by the composition module .","The composition module  may also expose APIs  to create and delete logical (i.e., physical) and virtual surfaces as well as to make updates to the individual surfaces. The composition module  may enforce the region to be updated by the application  to avoid extraneous visuals when drawing outside of an updatable area.","Example Procedures","The following discussion describes techniques that may be implemented utilizing the previously described systems and devices. Aspects of each of the procedures may be implemented in hardware, firmware, or software, or a combination thereof. The procedures are shown as a set of blocks that specify operations performed by one or more devices and are not necessarily limited to the orders shown for performing the operations by the respective blocks. In portions of the following discussion, reference will be made to the environment  of  and the systems and example implementations of .",{"@attributes":{"id":"p-0076","num":"0075"},"figref":"FIG. 6","b":["600","602","114"]},"The virtual surface is allocated in memory of the computing device by the exposed virtual surface functionality to have an area that is larger than an area to be used to display the visuals from the one or more applications (block ). As shown in , for instance, an area to be displayed which is represented by the viewport  may be smaller than an area of the virtual surface, which is represented by a plurality of logical surfaces configured as having matching sizes and arranged in a fixed grid in this example. Naturally, other examples are also contemplated.","Example System and Device",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 7","FIG. 1"],"b":["700","102","700"]},"In the example system , multiple devices are interconnected through a central computing device. The central computing device may be local to the multiple devices or may be located remotely from the multiple devices. In one embodiment, the central computing device may be a cloud of one or more server computers that are connected to the multiple devices through a network, the Internet, or other data communication link. In one embodiment, this interconnection architecture enables functionality to be delivered across multiple devices to provide a common and seamless experience to a user of the multiple devices. Each of the multiple devices may have different physical requirements and capabilities, and the central computing device uses a platform to enable the delivery of an experience to the device that is both tailored to the device and yet common to all devices. In one embodiment, a class of target devices is created and experiences are tailored to the generic class of devices. A class of devices may be defined by physical features, types of usage, or other common characteristics of the devices.","In various implementations, the computing device  may assume a variety of different configurations, such as for computer , mobile , and television  uses. Each of these configurations includes devices that may have generally different constructs and capabilities, and thus the computing device  may be configured according to one or more of the different device classes. For instance, the computing device  may be implemented as the computer  class of a device that includes a personal computer, desktop computer, a multi-screen computer, laptop computer, netbook, and so on.","The computing device  may also be implemented as the mobile  class of device that includes mobile devices, such as a mobile phone, portable music player, portable gaming device, a tablet computer, a multi-screen computer, and so on. The computing device  may also be implemented as the television  class of device that includes devices having or connected to generally larger screens in casual viewing environments. These devices include televisions, set-top boxes, gaming consoles, and so on. The techniques described herein may be supported by these various configurations of the computing device  and are not limited to the specific examples the techniques described herein. This is illustrated through inclusion of the composition system  on the computing device , functionality of which may also be distributed \u201cover the cloud\u201d as further detailed below.","The cloud  includes and\/or is representative of a platform  for content services . The platform  abstracts underlying functionality of hardware (e.g., servers) and software resources of the cloud . The content services  may include applications and\/or data that can be utilized while computer processing is executed on servers that are remote from the computing device . Content services  can be provided as a service over the Internet and\/or through a subscriber network, such as a cellular or Wi-Fi network.","The platform  may abstract resources and functions to connect the computing device  with other computing devices. The platform  may also serve to abstract scaling of resources to provide a corresponding level of scale to encountered demand for the content services  that are implemented via the platform . Accordingly, in an interconnected device embodiment, implementation of functionality of the functionality described herein may be distributed throughout the system . For example, the functionality may be implemented in part on the computing device  as well as via the platform  that abstracts the functionality of the cloud .",{"@attributes":{"id":"p-0085","num":"0084"},"figref":["FIG. 8","FIGS. 1, 2, and 7"],"b":["800","800","802","804","804","800","800","806"]},"Device  also includes communication interfaces  that can be implemented as any one or more of a serial and\/or parallel interface, a wireless interface, any type of network interface, a modem, and as any other type of communication interface. The communication interfaces  provide a connection and\/or communication links between device  and a communication network by which other electronic, computing, and communication devices communicate data with device .","Device  includes one or more processors  (e.g., any of microprocessors, controllers, and the like) which process various computer-executable instructions to control the operation of device  and to implement embodiments of the techniques described herein. Alternatively or in addition, device  can be implemented with any one or combination of hardware, firmware, or fixed logic circuitry that is implemented in connection with processing and control circuits which are generally identified at . Although not shown, device  can include a system bus or data transfer system that couples the various components within the device. A system bus can include any one or combination of different bus structures, such as a memory bus or memory controller, a peripheral bus, a universal serial bus, and\/or a processor or local bus that utilizes any of a variety of bus architectures.","Device  also includes computer-readable media , such as one or more memory components, examples of which include random access memory (RAM), non-volatile memory (e.g., any one or more of a read-only memory (ROM), flash memory, EPROM, EEPROM, etc.), and a disk storage device. A disk storage device may be implemented as any type of magnetic or optical storage device, such as a hard disk drive, a recordable and\/or rewriteable compact disc (CD), any type of a digital versatile disc (DVD), and the like. Device  can also include a mass storage media device .","Computer-readable media  provides data storage mechanisms to store the device data , as well as various device applications  and any other types of information and\/or data related to operational aspects of device . For example, an operating system  can be maintained as a computer application with the computer-readable media  and executed on processors . The device applications  can include a device manager (e.g., a control application, software application, signal processing and control module, code that is native to a particular device, a hardware abstraction layer for a particular device, etc.). The device applications  also include any system components or modules to implement embodiments of the techniques described herein. In this example, the device applications  include an interface application  and an input\/output module  that are shown as software modules and\/or computer applications. The input\/output module  is representative of software that is used to provide an interface with a device configured to capture inputs, such as a touchscreen, track pad, camera, microphone, and so on. Alternatively or in addition, the interface application  and the input\/output module  can be implemented as hardware, software, firmware, or any combination thereof. Additionally, the input\/output module  may be configured to support multiple input devices, such as separate devices to capture visual and audio inputs, respectively.","Device  also includes an audio and\/or video input-output system  that provides audio data to an audio system  and\/or provides video data to a display system . The audio system  and\/or the display system  can include any devices that process, display, and\/or otherwise render audio, video, and image data. Video signals and audio signals can be communicated from device  to an audio device and\/or to a display device via an RF (radio frequency) link, S-video link, composite video link, component video link, DVI (digital video interface), analog audio connection, or other similar communication link. In an embodiment, the audio system  and\/or the display system  are implemented as external components to device . Alternatively, the audio system  and\/or the display system  are implemented as integrated components of example device .","Although the invention has been described in language specific to structural features and\/or methodological acts, it is to be understood that the invention defined in the appended claims is not necessarily limited to the specific features or acts described. Rather, the specific features and acts are disclosed as example forms of implementing the claimed invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The detailed description is described with reference to the accompanying figures. In the figures, the left-most digit(s) of a reference number identifies the figure in which the reference number first appears. The use of the same reference numbers in different instances in the description and the figures may indicate similar or identical items.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 3","FIG. 1"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIG. 7","FIG. 1"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 8","FIGS. 1 and 7"]}]},"DETDESC":[{},{}]}
