---
title: Agnostic processing of resource requests to message queues and sequential files
abstract: Embodiments of the present invention provide a method, system and computer program product for agnostic processing of message queues and sequential files. In an embodiment of the invention, a method for agnostic processing of message queues and sequential files can be provided. The method can include receiving an access request for a resource that is uniform for both a message queue and a sequential file and identifying a resource type of the resource. In response to identifying the resource type as a message queue, a corresponding access request specific to a message queue can be invoked in the message queue. Otherwise a corresponding access request specific to a sequential file can be invoked responsive to identifying the resource type as a sequential file.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09495174&OS=09495174&RS=09495174
owner: International Business Machines Corporation
number: 09495174
owner_city: Armonk
owner_country: US
publication_date: 20090102
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["1. Field of the Invention","The present invention relates to the field of message queue and sequential file management and more particularly to the programmatic access to a message queue and also programmatic access to a sequential file.","2. Description of the Related Art","In the field of information technology, a message queue is a software-engineering component used for inter-process communications or inter-thread communications. The component employs a queue into which messages can be placed by a messenger and from which messages can be retrieved by a designated recipient. In this regard, the message queue can be a communicative component enabling asynchronous messaging as between the messenger and the designated recipient. Operationally, the message queue can support multiple messengers and recipients such that asynchronous communications can be achieved for a group of participants.","The asynchronous nature of the message queue provides for an ideal technology coupler for disparate technologies. Specifically, so long as separate technologies can access the message queue, the separate and disparate technologies can engage in message passing thereby enabling communications. In particular, the message queue can expose different method calls through an application programming interface (API) for opening, writing to, reading from, and closing the message queue. Each application in turn can include logic to invoke a sequence of the method calls in order to either place a message into the message queue, or to retrieve a message from the message queue.","In message queue technology, applications share data by putting and getting messages on message queues. Generally, applications put messages to queues programmatically using an API. For example, the following pseudo-code sequence is demonstrative of a process for loading a message queue with messages programmatically through program calls to a message queue API:",{"@attributes":{"id":"p-0008","num":"0007"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OPEN queue"]},{"entry":[{},"\u2003\u2003Loop until all messages generated"]},{"entry":[{},"\u2003\u2003\u2003\u2003Generate message"]},{"entry":[{},"\u2003\u2003\u2003\u2003PUT message to queue"]},{"entry":[{},"\u2003\u2003EndLoop"]},{"entry":[{},"CLOSE queue"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Likewise, applications can retrieve messages from messages queues programmatically using the message queue API. For example, the following pseudo-code sequence is demonstrative of a process for retrieving messages from a message queue programmatically through program calls to a message queue API:",{"@attributes":{"id":"p-0010","num":"0009"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OPEN queue"]},{"entry":[{},"\u2003\u2003Loop until queue-empty"]},{"entry":[{},"\u2003\u2003\u2003\u2003GET message from queue"]},{"entry":[{},"\u2003\u2003\u2003\u2003Process message"]},{"entry":[{},"\u2003\u2003EndLoop"]},{"entry":[{},"CLOSE queue"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In message queue technology, a queue manager manages the storage of message data using internal formats transparent to applications. Queue messages may be maintained in computer memory, or stored on a permanent medium such as on a fixed disk. As such, applications are restricted to accessing discrete message data\u2014that is, data stripped of the internal formats of the queue manager\u2014using the API of the queue manager, typically one message at a time.","By comparison, sequential files support data storage with less complexity than a message queue. With a sequential file, data simply can be inserted within a sequential file at a specified byte position. Likewise, with a sequential file, data can be retrieved from the sequential file at a specified or relative byte position. Accordingly, a suitable API for accessing data within a sequential file could include:",{"@attributes":{"id":"p-0013","num":"0012"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"OPEN sequential file"]},{"entry":[{},"\u2003\u2003Loop until all data generated"]},{"entry":[{},"\u2003\u2003\u2003\u2003Generate record"]},{"entry":[{},"\u2003\u2003\u2003\u2003WRITE record to file"]},{"entry":[{},"\u2003\u2003EndLoop"]},{"entry":[{},"CLOSE sequential file"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},"Embodiments of the present invention address deficiencies of the art in respect to message queue and sequential file management and provide a novel and non-obvious method, system and computer program product for agnostic processing of message queues and sequential files. In an embodiment of the invention, a method for agnostic processing of message queues and sequential files can be provided. The method can include receiving from an application an access request for a resource that is uniform for both a message queue and a sequential file and identifying a resource type of the resource. In response to identifying the resource type as a message queue, a corresponding access request specific to a message queue can be invoked in the message queue independently of the application. Otherwise a corresponding access request specific to a sequential file can be invoked responsive to identifying the resource type as a sequential file independently of the application.","In another embodiment of the invention, an agnostic resource data processing system can be configured for agnostic processing of message queues and sequential files. The system can include a message queue executing in a resource hosting computing system and a sequential file disposed in a resource hosting computing system. The system also can include a unified API to both the message queue and also the sequential file. The unified API can provide program code enabled to invoke independently of a coupled application, an access request in the message queue in response to receiving from the coupled application a uniform resource access request for a resource type corresponding to the message queue. The program code also can be enabled to invoke independently of the coupled application an access request in the sequential file in response to receiving from the coupled application a uniform resource access request for a resource type corresponding to the sequential file.","Additional aspects of the invention will be set forth in part in the description which follows, and in part will be obvious from the description, or may be learned by practice of the invention. The aspects of the invention will be realized and attained by means of the elements and combinations particularly pointed out in the appended claims. It is to be understood that both the foregoing general description and the following detailed description are exemplary and explanatory only and are not restrictive of the invention, as claimed.","Embodiments of the present invention provide a method, system and computer program product for agnostic processing of message queues and sequential files. In accordance with an embodiment of the present invention, a resource request to access data in a resource can be received in association with either a message in a message queue or data in a sequential file in a file system. The resource can be identified as either a message queue, or a sequential file in the file system. Responsive to the identification of the resource as a message queue, the message can be accessed in the message queue to satisfy the resource request. Otherwise, responsive to the identification of the resource as a sequential file in a file system, the data in the sequential file can be accessed in the file system.","In illustration,  is a pictorial illustration of a process for agnostic processing of message queues and sequential files. As shown in , both a message queue A and a sequential file B can be configured for access by a requesting application  through a unified API . The message queue A can include a number of messages  queued therein and further can provide a message queue API  providing program logic for both writing messages A to and retrieving messages A from the message queue A. In contrast, the sequential file B can be stored in a file system (not shown) and can include sequentially arranged data  within the sequential file B. Like the message queue A, the sequential file B can be associated with a file system API providing program logic for both writing data B to and retrieving data B from the sequential file B.","Notably, unified resource request processing logic  can be coupled to the unified API . In operation, the requesting application  can issue a resource request  through a unified API  to access a resource irrespective of whether the resource is the message queue A or the sequential file B. The unified resource request processing logic  can identify the type of resource sought for access by the requesting application . For a message queue A, the unified resource request processing logic  can invoke a counterpart access request for a message A through the message queue API . Otherwise, the unified resource request processing logic  can invoke a counterpart access request for data B in the sequential file B through the file system API .","Of note, the unified resource request processing logic  can be included as part of a run-time environment such that the requesting application  can agnostically process resource requests to access a resource without requiring internal modification of program code. Alternatively, the unified resource request processing logic  can be implemented internally to the requesting application . As yet a further alternative, the unified resource request processing logic  can be implemented as a stand alone library (either static or dynamic) that can be linked at run-time or build-time to the requesting application .","The process described in connection with the unified resource request processing logic  can be implemented within a resource data processing system. In further illustration,  schematically shows a resource data processing system configured for agnostic processing of message queues and sequential files. The system can include one or more resource hosting computing servers ,  hosting both a message queue  of one or more messages and a sequential file  of data. The resource hosting computing servers ,  can be configured for communicative coupling to one or more client computing devices  over a computer communications network , for example, a local area network (LAN) or the global Internet.","Each of the client computing devices  can include an operating system  supporting the operation of a computing application . Further, a unified API  to the message queue  and the sequential file  can be provided in connection with unified resource request processing logic . The unified resource request processing logic  can include program code enabled to process uniform requests for resources from the application  to access a resource irrespective of whether the resource is a message queue  or a sequential file . In this regard, the program code can be enabled to identify a type for a requested resource and, in response to identifying the type of the requested resource, the program code can be enabled to issue a relevant request for access for the requested resource specific to either the message queue  or the sequential file  depending upon whether the resource type is a message queue  or a sequential file .","In further illustration of the operation of the unified resource request processing logic ,  is a flow chart illustrating a process for agnostic processing of message queues and sequential files. Beginning in block , a request to access a resource can be received in the unified API. The requested access can include a read operation, a write operation, an open operation or a close operation, to name only a few. In block , the resource type for the resource can be determined to be either a message queue, or a sequential file. In decision block , if the resource type is determined to be a message queue, in block  a corresponding access request specific to the message queue can be invoked. Otherwise, in block  a corresponding access request specific to the sequential file can be invoked. Finally, in block  the process can end.","Embodiments of the invention can take the form of an entirely hardware embodiment, an entirely software embodiment or an embodiment containing both hardware and software elements. In a preferred embodiment, the invention is implemented in software, which includes but is not limited to firmware, resident software, microcode, and the like. Furthermore, the invention can take the form of a computer program product accessible from a computer-usable or computer-readable medium providing program code for use by or in connection with a computer or any instruction execution system.","For the purposes of this description, a computer-usable or computer readable medium can be any apparatus that can contain, store, communicate, propagate, or transport the program for use by or in connection with the instruction execution system, apparatus, or device. The medium can be an electronic, magnetic, optical, electromagnetic, infrared, or semiconductor system (or apparatus or device) or a propagation medium. Examples of a computer-readable medium include a semiconductor or solid state memory, magnetic tape, a removable computer diskette, a random access memory (RAM), a read-only memory (ROM), a rigid magnetic disk and an optical disk. Current examples of optical disks include compact disk-read only memory (CD-ROM), compact disk-read\/write (CD-R\/W) and DVD.","A data processing system suitable for storing and\/or executing program code will include at least one processor coupled directly or indirectly to memory elements through a system bus. The memory elements can include local memory employed during actual execution of the program code, bulk storage, and cache memories which provide temporary storage of at least some program code in order to reduce the number of times code must be retrieved from bulk storage during execution. Input\/output or I\/O devices (including but not limited to keyboards, displays, pointing devices, etc.) can be coupled to the system either directly or through intervening I\/O controllers. Network adapters may also be coupled to the system to enable the data processing system to become coupled to other data processing systems or remote printers or storage devices through intervening private or public networks. Modems, cable modem and Ethernet cards are just a few of the currently available types of network adapters."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated in and constitute part of this specification, illustrate embodiments of the invention and together with the description, serve to explain the principles of the invention. The embodiments illustrated herein are presently preferred, it being understood, however, that the invention is not limited to the precise arrangements and instrumentalities shown, wherein:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"}]},"DETDESC":[{},{}]}
