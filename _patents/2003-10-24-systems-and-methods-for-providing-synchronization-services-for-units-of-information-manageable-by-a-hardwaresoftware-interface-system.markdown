---
title: Systems and methods for providing synchronization services for units of information manageable by a hardware/software interface system
abstract: Several embodiments of the present invention employ synchronization adapters for synchronizing information between “WinFS” and non-“WinFS” data sources. Examples of adapters include an adapter that synchronizes address book information between a “WinFS” contacts folder and a non-WinFS mailbox. In these instances, adapter developers might use the “WinFS” synchronization core services API described herein for accessing services provided by the “WinFS” synchronization platform in order to develop schema transformation code between the “WinFS” schema and the non-“WinFS” data source schema. Additionally, the adapter developer provides protocol support for communicating changes with the non-“WinFS” data source. A synchronization adapter is invoked and controlled by using the synchronization controller API and reports progress and errors using this API.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07743019&OS=07743019&RS=07743019
owner: Microsoft Corporation
number: 07743019
owner_city: Redmond
owner_country: US
publication_date: 20031024
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS-REFERENCE","FIELD OF THE INVENTION","BACKGROUND","SUMMARY","DETAILED DESCRIPTION","(1) Master Item Search View","(2) Typed Item Search Views","(1) Master Extension Search View","(2) Typed Extension Search Views","(1) Master Relationship Search View","(2) Relationship Instance Search Views","(1) Change Tracking in \u201cMaster\u201d Search Views","(2) Change Tracking in \u201cTyped\u201d Search Views","(1) Item Tombstones","(2) Extension Tombstones","(3) Relationships Tombstone","(4) Tombstone Cleanup","(1) Community Folder\u2014Mappings","(2) Profiles","(3) Schedules","(1) Conflict Detection","(a) Knowledge-Based Conflicts","(b) Constraint-Based Conflicts","(2) Conflict Processing","(a) Automatic Conflict Resolution","(b) Conflict Logging","(c) Conflict Inspection and Resolution","(d) Convergence of Replicas and Propagation of Conflict Resolutions","(1) Change Enumeration","(2) Change Application","(3) Conflict Resolution","IV. CONCLUSION"],"p":["This application is a continuation-in-part of U.S. patent application Ser. No. 10\/646,575, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHODS FOR INTERFACING APPLICATION PROGRAMS WITH AN ITEM-BASED STORAGE PLATFORM\u201d, the entire contents of which are hereby incorporated herein by reference.","This application is related by subject matter to the inventions disclosed in the following commonly assigned applications, the contents of which are hereby incorporated into this present application in their entirety (and partially summarized herein for convenience): U.S. patent application Ser. No. 10\/647,058, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHODS FOR REPRESENTING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM BUT INDEPENDENT OF PHYSICAL REPRESENTATION\u201d; U.S. patent application Ser. No. 10\/646,941, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHODS FOR SEPARATING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM FROM THEIR PHYSICAL ORGANIZATION\u201d; U.S. patent application Ser. No. 10\/646,940, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHODS FOR THE IMPLEMENTATION OF A BASE SCHEMA FOR ORGANIZING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d; U.S. patent application Ser. No. 10\/646,632, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHODS FOR THE IMPLEMENTATION OF A CORE SCHEMA FOR PROVIDING A TOP-LEVEL STRUCTURE FOR ORGANIZING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d; U.S. patent application Ser. No. 10\/646,645, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHOD FOR REPRESENTING RELATIONSHIPS BETWEEN UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d; U.S. patent application Ser. No. 10\/646,646, filed on Aug. 21, 2003, entitled \u201cSTORAGE PLATFORM FOR ORGANIZING, SEARCHING, AND SHARING DATA\u201d; U.S. patent application Ser. No. 10\/646,580, filed on Aug. 21, 2003, entitled \u201cSYSTEMS AND METHODS FOR DATA MODELING IN AN ITEM-BASED STORAGE PLATFORM\u201d; U.S. patent application Ser. No. 10,692,779, filed on even date herewith, entitled \u201cSYSTEMS AND METHODS FOR THE IMPLEMENTATION OF A DIGITAL IMAGES SCHEMA FOR ORGANIZING UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d; U.S. patent application Ser. No. 10,692,508, filed on even date herewith, entitled \u201cSYSTEMS AND METHODS FOR PROVIDING RELATIONAL AND HIERARCHICAL SYNCHRONIZATION SERVICES FOR UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d; U.S. patent application Ser. No. 10,693,362, filed on even date herewith, entitled \u201cSYSTEMS AND METHODS FOR THE IMPLEMENTATION OF A SYNCHRONIZATION SCHEMAS FOR UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d; and U.S. patent application Ser. No. 10,693,574, filed on even date herewith, entitled \u201cSYSTEMS AND METHODS FOR EXTENSIONS AND INHERITANCE FOR UNITS OF INFORMATION MANAGEABLE BY A HARDWARE\/SOFTWARE INTERFACE SYSTEM\u201d.","The present invention relates generally to the field of information storage and retrieval, and, more particularly, to an active storage platform for organizing, searching, and sharing different types of data in a computerized system.","Individual disk capacity has been growing at roughly seventy percent (70%) per year over the last decade. Moore's law accurately predicted the tremendous gains in central processing unit (CPU) power that has occurred over the years. Wired and wireless technologies have provided tremendous connectivity and bandwidth. Presuming current trends continue, within several years the average laptop computer will possess roughly one terabyte (TB) of storage and contain millions of files, and 500 gigabyte (GB) drives will become commonplace.","Consumers use their computers primarily for communication and organizing personal information, whether it is traditional personal information manager (PIM) style data or media such as digital music or photographs. The amount of digital content, and the ability to store the raw bytes, has increased tremendously; however the methods available to consumers for organizing and unifying this data has not kept pace. Knowledge workers spend enormous amounts of time managing and sharing information, and some studies estimate that knowledge workers spend 15-25% of their time on non-productive information related activities. Other studies estimate that a typical knowledge worker spends about 2.5 hours per day searching for information.","Developers and information technology (IT) departments invest significant amounts of time and money in building their own data stores for common storage abstractions to represent such things as people, places, times, and events. Not only does this result in duplicated work, but it also creates islands of common data with no mechanisms for common searching or sharing of that data. Just consider how many address books can exist today on a computer running the Microsoft Windows operating system. Many applications, such as e-mail clients and personal finance programs, keep individual address books, and there is little sharing among applications of the address book data that each such program individually maintains. Consequently, a finance program (like Microsoft Money) does not share addresses for payees with the addresses maintained in an email contact folder (like the one in Microsoft Outlook). Indeed, many users have multiple devices and logically should synchronize their personal data amongst themselves and across a wide variety of additional sources, including cell phones to commercial services such as MSN and AOL; nevertheless, collaboration of shared documents is largely achieved by attaching documents to e-mail messages\u2014that is, manually and inefficiently.","One reason for this lack of collaboration is that traditional approaches to the organization of information in computer systems have centered on the use of file-folder-and-directory-based systems (\u201cfile systems\u201d) to organize pluralities of files into directory hierarchies of folders based on an abstraction of the physical organization of the storage medium used to store the files. The Multics operating system, developed during the 1960s, can be credited with pioneering the use of the files, folders, and directories to manage storable units of data at the operating system level. Specifically, Multics used symbolic addresses within a hierarchy of files (thereby introducing the idea of a file path) where physical addresses of the files were not transparent to the user (applications and end-users). This file system was entirely unconcerned with the file format of any individual file, and the relationships amongst and between files was deemed irrelevant at the operating system level (that is, other than the location of the file within the hierarchy). Since the advent of Multics, storable data has been organized into files, folders, and directories at the operating system level. These files generally include the file hierarchy itself (the \u201cdirectory\u201d) embodied in a special file maintained by the file system. This directory, in turn, maintains a list of entries corresponding to all of the other files in the directory and the nodal location of such files in the hierarchy (herein referred to as the folders). Such has been the state of the art for approximately forty years.","However, while providing a reasonable representation of information residing in the computer's physical storage system, a file system is nevertheless an abstraction of that physical storage system, and therefore utilization of the files requires a level of indirection (interpretation) between what the user manipulates (units having context, features, and relationships to other units) and what the operating system provides (files, folders, and directories). Consequently, users (applications and\/or end-users) have no choice but to force units of information into a file system structure even when doing so is inefficient, inconsistent, or otherwise undesirable. Moreover, existing file systems know little about the structure of data stored in individual files and, because of this, most of the information remains locked up in files that may only be accessed (and comprehensible) to the applications that wrote them. Consequently, this lack of schematic description of information, and mechanisms for managing information, leads to the creation of silos of data with little data sharing among the individual silos. For example, many personal computer (PC) users have more than five distinct stores that contain information about the people they interact with on some level\u2014for example, Outlook Contacts, online account addressees, Windows Address Book, Quicken Payees, and instant messaging (IM) buddy lists\u2014because organizing files presents a significant challenge to these PC users. Because most existing file systems utilize a nested folder metaphor for organizing files and folders, as the number of files increases the effort necessary to maintain an organization scheme that is flexible and efficient becomes quite daunting. In such situations, it would be very useful to have multiple classifications of a single file; however, using hard or soft links in existing file systems is cumbersome and difficult to maintain.","Several unsuccessful attempts to address the shortcomings of file systems have been made in the past. Some of these previous attempts have involved the use of content addressable memory to provide a mechanism whereby data could be accessed by content rather than by physical address. However, these efforts have proven unsuccessful because, while content addressable memory has proven useful for small-scale use by devices such as caches and memory management units, large-scale use for devices such as physical storage media has not yet been possible for a variety of reasons, and thus such a solution simply does not exist. Other attempts using object-oriented database (OODB) systems have been made, but these attempts, while featuring strong database characteristics and good non-file representations, were not effective in handling file representations and could not replicate the speed, efficiency, and simplicity of the file and folder based hierarchical structure at the hardware\/software interface system level. Other efforts, such as those that attempted to use SmallTalk (and other derivatives), proved to be quite effective at handling file and non-file representations but lacked database features necessary to efficiently organize and utilize the relationships that exist between the various data files, and thus the overall efficiency of such systems was unacceptable. Yet other attempts to use BeOS (and other such operating systems research) proved to be inadequate at handling non-file representations\u2014the same core shortcoming of traditional file systems\u2014despite being able to adequately represent files while providing some necessary database features.","Database technology is another area of the art in which similar challenges exits. For example, while the relational database model has been a great commercial success, in truth independent software vendors (ISV) generally exercise a small portion of the functionality available in relational database software products (such as Microsoft SQL Server). Instead, most of an application's interaction with such a product is in the form of simple \u201cgets\u201d and \u201cputs\u201d. While there are a number of readily apparent reasons for this\u2014such as being platform or database agnostic\u2014one key reason that often goes unnoticed is that the database does not necessarily provide the exact abstractions that a major business application vendor really needs. For example, while the real world has the notion of \u201citems\u201d, such as \u201ccustomers\u201d or \u201corders\u201d (along with an order's embedded \u201cline items\u201d as items in and of themselves), relational databases only talk in terms of tables and rows. Consequently, while the application may desire to have aspects of consistency, locking, security, and\/or triggers at the item level (to name a few), generally databases provide these features only at the table\/row level. While this may work fine if each item gets mapped to a single row in some table in the database, in the case of an order with multiple line items there may be reasons why an item actually gets mapped to multiple tables and, when that is the case, the simple relational database system does not quite provide the right abstractions. Consequently, an application must build logic on top of the database to provide these basic abstractions. In other words, the basic relational model does not provide a sufficient platform for storage of data on which higher-level applications can easily be developed because the basic relational model requires a level of indirection between the application and the storage system\u2014where the semantic structure of the data might only be visible in the application in certain instances. While some database vendors are building higher-level functionality into their products\u2014such as providing object relational capabilities, new organizational models, and the like\u2014none have yet to provide the kind of comprehensive solution needed, where a truly comprehensive solution is one which provides both useful data model abstractions (such as \u201cItems,\u201d \u201cExtensions,\u201d \u201cRelationships,\u201d and so on) for useful domain abstractions (such as \u201cPersons,\u201d \u201cLocations,\u201d \u201cEvents,\u201d etc.).","In view of the foregoing deficiencies in existing data storage and database technologies, there is a need for a new storage platform that provides an improved ability to organize, search, and share all types of data in a computer system\u2014a storage platform that extends and broadens the data platform beyond existing file systems and database systems, and that is designed to be the store for all types of data. The present invention, together with the related inventions incorporated by reference earlier herein, satisfies this need.","The following summary provides an overview of various aspects of the invention described in the context of the related inventions incorporated-by-reference earlier herein (the \u201crelated inventions\u201d). This summary is not intended to provide an exhaustive description of all of the important aspects of the invention, nor to define the scope of the invention. Rather, this summary is intended to serve as an introduction to the detailed description and figures that follow.","The present invention, as well as the related inventions, are collectively directed to a storage platform for organizing, searching, and sharing data. The storage platform of the present invention extends and broadens the concept of data storage beyond existing file systems and database systems, and is designed to be the store for all types of data including structured, non-structured, or semi-structured data.","The storage platform of the present invention comprises a data store implemented on a database engine. The database engine comprises a relational database engine with object relational extensions. The data store implements a data model that supports organization, searching, sharing, synchronization, and security of data. Specific types of data are described in schemas, and the platform provides a mechanism to extend the set of schemas to define new types of data (essentially subtypes of the basic types provides by the schemas). A synchronization capability facilitates the sharing of data among users or systems. File-system-like capabilities are provided that allow interoperability of the data store with existing file systems but without the limitation of such traditional file systems. A change tracking mechanism provides the ability track changes to the data store. The storage platform further comprises a set of application program interfaces that enable applications to access all of the foregoing capabilities of the storage platform and to access the data described in the schemas.","The data model implemented by the data store defines units of data storage in terms of items, elements, and relationships. An item is a unit of data storable in a data store and can comprise one or more elements and relationships. An element is an instance of a type comprising one or more fields (also referred to herein as a property). A relationship is a link between two items. (As used herein, these and other specific terms may be capitalized in order to offset them from other terms used in close proximity; however, there is no intention whatsoever to distinguish between a capitalized term, e.g. \u201cItem\u201d, and the same term when not capitalized, e.g., \u201citem\u201d, and no such distinction should be presumed or implied.)","The computer system further comprises a plurality of Items where each Item constitutes a discrete storable unit of information that can be manipulated by a hardware\/software interface system; a plurality of Item Folders that constitute an organizational structure for said Items; and a hardware\/software interface system for manipulating a plurality of Items and wherein each Item belongs to at least one Item Folder and may belong to more than one Item Folder.","An Item or some of the Item's property values may be computed dynamically as opposed to being derived from a persistent store. In other words, the hardware\/software interface system does not require that the Item be stored, and certain operations are supported such as the ability to enumerate the current set of Items or the ability to retrieve an Item given its identifier (which is more fully described in the sections that describe the application programming interface, or API) of the storage platform\u2014for example, an Item might be the current location of a cell phone or the temperature reading on a temperature sensor. The hardware\/software interface system may manipulate a plurality of Items, and may further comprise Items interconnected by a plurality of Relationships managed by the hardware\/software interface system.","A hardware\/software interface system for the computer system further comprises a core schema to define a set of core Items which said hardware\/software interface system understands and can directly process in a predetermined and predictable way. To manipulate a plurality of Items, the computer system interconnects said Items with a plurality of Relationships and manages said Relationships at the hardware\/software interface system level.","The API of the storage platform provides data classes for each item, item extension, and relationship defined in the set of storage platform schemas. In addition, the application programming interface provides a set of framework classes that define a common set of behaviors for the data classes and that, together with the data classes, provide the basic programming model for the storage platform API. The storage platform API provides a simplified query model that enables application programmers to form queries based on various properties of the items in the data store, in a manner that insulates the application programmer from the details of the query language of the underlying database engine. The storage platform API also collects changes to an item made by an application program and then organizes them into the correct updates required by the database engine (or any kind of storage engine) on which the data store is implemented. This enables application programmers to make changes to an item in memory, while leaving the complexity of data store updates to the API.","Through its common storage foundation and schematized data, the storage platform of the present invention enables more efficient application development for consumers, knowledge workers and enterprises. It offers a rich and extensible application programming interface that not only makes available the capabilities inherent in its data model, but also embraces and extends existing file system and database access methods.","As part of this overarching structure of interrelated inventions (described in detail in Section II of the Detailed Description), the present invention is specifically directed to the Synchronization APIs (described in detail in Section III of the Detailed Description). Other features and advantages of the invention may become apparent from the following detailed description of the invention and accompanying drawings.",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"TABLE OF CONTENTS"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["I.","INTRODUCTION","18"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A.","EXEMPLARY COMPUTING ENVIRONMENT","18"]},{"entry":[{},"B.","TRADITIONAL FILE-BASED STORAGE","22"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["II.","WINFS STORAGE PLATFORM FOR ORGANIZING,","24"]},{"entry":[{},"SEARCHING, AND"]},{"entry":[{},"SHARING DATA"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"A.","GLOSSARY","24"]},{"entry":[{},"B.","STORAGE PLATFORM OVERVIEW","25"]},{"entry":[{},"C.","THE DATA MODEL","26"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"1.","Items","28"]},{"entry":[{},{},"2.","Item Identification","32"]},{"entry":[{},{},"3.","Item Folders and Categories","32"]},{"entry":[{},{},"4.","Schemas","34"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"a)","Base Schema","34"]},{"entry":[{},{},{},"b)","Core Schema","35"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},"5.","Relationships","37"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"a)","Relationship Declaration","38"]},{"entry":[{},{},{},"b)","Holding Relationship","39"]},{"entry":[{},{},{},"c)","Embedding Relationships","40"]},{"entry":[{},{},{},"d)","Reference Relationships","41"]},{"entry":[{},{},{},"e)","Rules and Constraints","42"]},{"entry":[{},{},{},"f)","Ordering of Relationships","42"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},"6.","Extensibility","48"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"a)","Item extensions","49"]},{"entry":[{},{},{},"b)","Extending NestedElement","53"]},{"entry":[{},{},{},{},"types"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"D.","DATABASE ENGINE","55"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"1.","Data Store Implementation","56"]},{"entry":[{},{},{},"Using UDTs"]},{"entry":[{},{},"2.","Item Mapping","57"]},{"entry":[{},{},"3.","Extension Mapping","58"]},{"entry":[{},{},"4.","Nested Element Mapping","58"]},{"entry":[{},{},"5.","Object Identity","58"]},{"entry":[{},{},"6.","SQL Object Naming","58"]},{"entry":[{},{},"7.","Column Naming","59"]},{"entry":[{},{},"8.","Search Views","60"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},{},"a)","Item","61"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},{},"(1)","Master Item","61"]},{"entry":[{},{},{},{},{},"Search View"]},{"entry":[{},{},{},{},"(2)","Typed Item","61"]},{"entry":[{},{},{},{},{},"Search Views"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},{},"b)","Item Extensions","62"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},{},"(1)","Master Extension","62"]},{"entry":[{},{},{},{},{},"Search View"]},{"entry":[{},{},{},{},"(2)","Typed Extension","63"]},{"entry":[{},{},{},{},{},"Search Views"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"c)","Nested Elements","63"]},{"entry":[{},{},{},"d)","Relationships","64"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},{},"(1)","Master Relationship","64"]},{"entry":[{},{},{},{},{},"Search View"]},{"entry":[{},{},{},{},"(2)","Relationship Instance","64"]},{"entry":[{},{},{},{},{},"Search Views"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},{},"e)",{},"65"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"9.","Updates","65"]},{"entry":[{},{},"10.","Change Tracking & Tombstones","66"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},{},"a)","Change Tracking","66"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},{},"(1)","Change Tracking in","66"]},{"entry":[{},{},{},{},{},"\u201cMaster\u201d Search Views"]},{"entry":[{},{},{},{},"(2)","Change Tracking in","67"]},{"entry":[{},{},{},{},{},"\u201cTyped\u201d Search Views"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},{},"b)","Tombstones","68"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},{},"(1)","Item Tombstones","68"]},{"entry":[{},{},{},{},"(2)","Extension Tombstones","69"]},{"entry":[{},{},{},{},"(3)","Relationships Tombstone","69"]},{"entry":[{},{},{},{},"(4)","Tombstone Cleanup","70"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},"11.","Helper APIs and Functions","70"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"a)","Function","70"]},{"entry":[{},{},{},{},"[System.Storage].GetItem"]},{"entry":[{},{},{},"b)","Function","70"]},{"entry":[{},{},{},{},"[System.Storage].GetExtension"]},{"entry":[{},{},{},"c)","Function","71"]},{"entry":[{},{},{},{},"[System.Storage].GetRelationship"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},"12.","Metadata","71"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"a)","Schema Metadata","71"]},{"entry":[{},{},{},"b)","Instance Metadata","71"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"E.","SECURITY","71"]},{"entry":[{},"F.","NOTIFICATIONS AND CHANGE TRACKING","72"]},{"entry":[{},"G.","TRADITIONAL FILE SYSTEM","73"]},{"entry":[{},{},"INTEROPERABILITY"]},{"entry":[{},"H.","STORAGE PLATFORM API","74"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["III.","SYNCHRONIZATION API","80"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"A.","SYNCHRONIZATION OVERVIEW","81"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"1.","Storage-Platform-to-Storage-","81"]},{"entry":[{},{},{},"Platform Synchronization"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},"a)","Synchronization (Sync)","82"]},{"entry":[{},{},{},{},"Controlling Applications"]},{"entry":[{},{},{},"b)","Schema annotation","83"]},{"entry":[{},{},{},"c)","Sync Configuration","84"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},{},"(1)","Community Folder -","85"]},{"entry":[{},{},{},{},{},"Mappings"]},{"entry":[{},{},{},{},"(2)","Profiles","86"]},{"entry":[{},{},{},{},"(3)","Schedules","87"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},{},"d)","Conflict Handling","87"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},{},{},"(1)","Conflict Detection","87"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"8","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},{},{},"(a)","Knowledge-Based","87"]},{"entry":[{},{},{},{},{},{},"Conflicts"]},{"entry":[{},{},{},{},{},"(b)","Constraint-Based","88"]},{"entry":[{},{},{},{},{},{},"Conflicts"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},{},{},"(2)","Conflict Processing","88"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"8"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"8","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},{},{},"(a)","Automatic Conflict","89"]},{"entry":[{},{},{},{},{},{},"Resolution"]},{"entry":[{},{},{},{},{},"(b)","Conflict Logging","89"]},{"entry":[{},{},{},{},{},"(c)","Conflict Inspection","90"]},{"entry":[{},{},{},{},{},{},"and Resolution"]},{"entry":[{},{},{},{},{},"(d)","Convergence of Replicas","90"]},{"entry":[{},{},{},{},{},{},"and Propagation of"]},{"entry":[{},{},{},{},{},{},"Conflict Resolutions"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"2.","Synchronizing to Non-Storage","91"]},{"entry":[{},{},{},"Platform Data Stores"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},{},"a)","Sync Services","91"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"7"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"7","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},{},{},"(1)","Change Enumeration","91"]},{"entry":[{},{},{},{},"(2)","Change Application","92"]},{"entry":[{},{},{},{},"(3)","Conflict Resolution","93"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},{},{},"b)","Adapter Implementation","93"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"3.","Security","94"]},{"entry":[{},{},"4.","Manageability","94"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"B.","SYNCHRONIZATION API OVERVIEW","95"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"1.","General Terminology","95"]},{"entry":[{},{},"2.","Synchronization API Principals","97"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"C.","SYNCHRONIZATION API SERVICES","99"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"140pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{},"1.","Change Enumeration","99"]},{"entry":[{},{},"2.","Change Application","100"]},{"entry":[{},{},"3.","Sample Code","100"]},{"entry":[{},{},"4.","Methods of API Synchronization","104"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"D","ADDITIONAL ASPECTS OF THE SYNC SCHEMA","106"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IV.","CONCLUSION","108"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"The subject matter of the present invention is described with specificity to meet statutory requirements. However, the description itself is not intended to limit the scope of this patent. Rather, the inventors have contemplated that the claimed subject matter might also be embodied in other ways, to include different steps or combinations of steps similar to the ones described in this document, in conjunction with other present or future technologies. Moreover, although the term \u201cstep\u201d may be used herein to connote different elements of methods employed, the term should not be interpreted as implying any particular order among or between various steps herein disclosed unless and except when the order of individual steps is explicitly described.","A. Exemplary Computing Environment","Numerous embodiments of the present invention may execute on a computer.  and the following discussion is intended to provide a brief general description of a suitable computing environment in which the invention may be implemented. Although not required, various aspects of the invention may be described in the general context of computer executable instructions, such as program modules, being executed by a computer, such as a client workstation or a server. Generally, program modules include routines, programs, objects, components, data structures and the like that perform particular tasks or implement particular abstract data types. Moreover, the invention may be practiced with other computer system configurations, including hand held devices, multi processor systems, microprocessor based or programmable consumer electronics, network PCs, minicomputers, mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","As shown in , an exemplary general purpose computing system includes a conventional personal computer  or the like, including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within the personal computer , such as during start up, is stored in ROM . The personal computer  may further include a hard disk drive  for reading from and writing to a hard disk, not shown, a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer readable media provide non volatile storage of computer readable instructions, data structures, program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories (RAMs), read only memories (ROMs) and the like may also be used in the exemplary operating environment. Likewise, the exemplary environment may also include many types of monitoring devices such as heat sensors and security or fire alarm systems, and other sources of information.","A number of program modules may be stored on the hard disk, magnetic disk , optical disk , ROM  or RAM , including an operating system , one or more application programs , other program modules  and program data . A user may enter commands and information into the personal computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite disk, scanner or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , personal computers typically include other peripheral output devices (not shown), such as speakers and printers. The exemplary system of  also includes a host adapter , Small Computer System Interface (SCSI) bus , and an external storage device  connected to the SCSI bus .","The personal computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the personal computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the personal computer  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","As illustrated in the block diagram of , a computer system  can be roughly divided into three component groups: the hardware component , the hardware\/software interface system component , and the applications programs component  (also referred to as the \u201cuser component\u201d or \u201csoftware component\u201d in certain contexts herein).","In various embodiments of a computer system , and referring back to , the hardware component  may comprise the central processing unit (CPU) , the memory (both ROM  and RAM ), the basic input\/output system (BIOS) , and various input\/output (I\/O) devices such as a keyboard , a mouse , a monitor , and\/or a printer (not shown), among other things. The hardware component  comprises the basic physical infrastructure for the computer system .","The applications programs component  comprises various software programs including but not limited to compilers, database systems, word processors, business programs, videogames, and so forth. Application programs provide the means by which computer resources are utilized to solve problems, provide solutions, and process data for various users (machines, other computer systems, and\/or end-users).","The hardware\/software interface system component  comprises (and, in some embodiments, may solely consist of) an operating system that itself comprises, in most cases, a shell and a kernel. An \u201coperating system\u201d (OS) is a special program that acts as an intermediary between application programs and computer hardware. The hardware\/software interface system component  may also comprise a virtual machine manager (VMM), a Common Language Runtime (CLR) or its functional equivalent, a Java Virtual Machine (JVM) or its functional equivalent, or other such software components in the place of or in addition to the operating system in a computer system. The purpose of a hardware\/software interface system is to provide an environment in which a user can execute application programs. The goal of any hardware\/software interface system is to make the computer system convenient to use, as well as utilize the computer hardware in an efficient manner.","The hardware\/software interface system is generally loaded into a computer system at startup and thereafter manages all of the application programs in the computer system. The application programs interact with the hardware\/software interface system by requesting services via an application program interface (API). Some application programs enable end-users to interact with the hardware\/software interface system via a user interface such as a command language or a graphical user interface (GUI).","A hardware\/software interface system traditionally performs a variety of services for applications. In a multitasking hardware\/software interface system where multiple programs may be running at the same time, the hardware\/software interface system determines which applications should run in what order and how much time should be allowed for each application before switching to another application for a turn. The hardware\/software interface system also manages the sharing of internal memory among multiple applications, and handles input and output to and from attached hardware devices such as hard disks, printers, and dial-up ports. The hardware\/software interface system also sends messages to each application (and, in certain case, to the end-user) regarding the status of operations and any errors that may have occurred. The hardware\/software interface system can also offload the management of batch jobs (e.g., printing) so that the initiating application is freed from this work and can resume other processing and\/or operations. On computers that can provide parallel processing, a hardware\/software interface system also manages dividing a program so that it runs on more than one processor at a time.","A hardware\/software interface system shell (simply referred to herein as a \u201cshell\u201d) is an interactive end-user interface to a hardware\/software interface system. (A shell may also be referred to as a \u201ccommand interpreter\u201d or, in an operating system, as an \u201coperating system shell\u201d). A shell is the outer layer of a hardware\/software interface system that is directly accessible by application programs and\/or end-users. In contrast to a shell, a kernel is a hardware\/software interface system's innermost layer that interacts directly with the hardware components.","While it is envisioned that numerous embodiments of the present invention are particularly well-suited for computerized systems, nothing in this document is intended to limit the invention to such embodiments. On the contrary, as used herein the term \u201ccomputer system\u201d is intended to encompass any and all devices capable of storing and processing information and\/or capable of using the stored information to control the behavior or execution of the device itself, regardless of whether such devices are electronic, mechanical, logical, or virtual in nature.","B. Traditional File-based Storage","In most computer systems today, \u201cfiles\u201d are units of storable information that may include the hardware\/software interface system as well as application programs, data sets, and so forth. In all modern hardware\/software interface systems (Windows, Unix, Linux, Mac OS, virtual machine systems, and so forth), files are the basic discrete (storable and retrievable) units of information (e.g., data, programs, and so forth) that can be manipulated by the hardware\/software interface system. Groups of files are generally organized in \u201cfolders.\u201d In Microsoft Windows, the Macintosh OS, and other hardware\/software interface systems, a folder is a collection of files that can be retrieved, moved, and otherwise manipulated as single units of information. These folders, in turn, are organized in a tree-based hierarchical arrangement called a \u201cdirectory\u201d (discussed in more detail herein below). In certain other hardware\/software interface systems, such as DOS, z\/OS and most Unix-based operating systems, the terms \u201cdirectory\u201d and\/or \u201cfolder\u201d are interchangeable, and early Apple computer systems (e.g., the Apple IIe) used the term \u201ccatalog\u201d instead of directory; however, as used herein, all of these terms are deemed to be synonymous and interchangeable and are intended to further include all other equivalent terms for and references to hierarchical information storage structures and their folder and file components.","Traditionally, a directory (a.k.a. a directory of folders) is a tree-based hierarchical structure wherein files are grouped into folders and folder, in turn, are arranged according to relative nodal locations that comprise the directory tree. For example, as illustrated in , a DOS-based file system base folder (or \u201croot directory\u201d)  may comprise a plurality of folders , each of which may further comprise additional folders (as \u201csubfolders\u201d of that particular folder) , and each of these may also comprise additional folders  ad infinitum. Each of these folders may have one or more files  although, at the hardware\/software interface system level, the individual files in a folder have nothing in common other than their location in the tree hierarchy. Not surprisingly, this approach of organizing files into folder hierarchies indirectly reflects the physical organization of typical storage media used to store these files (e.g., hard disks, floppy disks, CD-ROMs, etc.).","In addition to the foregoing, each folder is a container for its subfolders and its files\u2014that is, each folder owns its subfolders and files. For example, when a folder is deleted by the hardware\/software interface system, that folder's subfolders and files are also deleted (which, in the case of each subfolder, further includes its own subfolders and files recursively). Likewise, each file is generally owned by only one folder and, although a file can be copied and the copy located in a different folder, a copy of a file is itself a distinct and separate unit that has no direct connection to the original (e.g., changes to the original file are not mirrored in the copy file at the hardware\/software interface system level). In this regard, files and folders are therefore characteristically \u201cphysical\u201d in nature because folders are the treated like physical containers, and files are treated as discrete and separate physical elements inside these containers.","II. Winfs Storage Platform for Organizing, Searching, and Sharing Data","The present invention, in combination with the related inventions incorporated by reference as discussed earlier herein, is directed to a storage platform for organizing, searching, and sharing data. The storage platform of the present invention extends and broadens the data platform beyond the kinds of existing file systems and database systems discussed above, and is designed to be the store for all types of data, including a new form of data called Items.","A. Glossary","As used herein and in the claims, the following terms have the following meanings:\n\n","B. Storage Platform Overview","Referring to , a storage platform  comprises a data store  implemented on a database engine . In one embodiment, the database engine comprises a relational database engine with object relational extensions. In one embodiment, the relational database engine  comprises the Microsoft SQL Server relational database engine. The data store  implements a data model  that supports the organization, searching, sharing, synchronization, and security of data. Specific types of data are described in schemas, such as schemas , and the storage platform  provides tools  for deploying those schemas as well as for extending those schemas, as described more fully below.","A change tracking mechanism  implemented within the data store  provides the ability track changes to the data store. The data store  also provides security capabilities  and a promotion\/demotion capability , both of which are discussed more fully below. The data store  also provides a set of application programming interfaces  to expose the capabilities of the data store  to other storage platform components and application programs (e.g., application programs , , and ) that utilize the storage platform. The storage platform of the present invention still further comprises an application programming interfaces (API) , which enables application programs, such as application programs , , and , to access all of the foregoing capabilities of the storage platform and to access the data described in the schemas. The storage platform API  may be used by application programs in combination with other APIs, such as the OLE DB API  and the Microsoft Windows Win32 API .","The storage platform  of the present invention may provide a variety of services  to application programs, including a synchronization service  that facilitates the sharing of data among users or systems. For example, the synchronization service  may enable interoperability with other data stores  having the same format as data store , as well as access to data stores  having other formats. The storage platform  also provides file system capabilities that allow interoperability of the data store  with existing file systems, such as the Windows NTFS files system . In at least some embodiments, the storage platform  may also provide application programs with additional capabilities for enabling data to be acted upon and for enabling interaction with other systems. These capabilities may be embodied in the form of additional services , such as an Info Agent service  and a notification service , as well as in the form of other utilities .","In at least some embodiments, the storage platform is embodied in, or forms an integral part of, the hardware\/software interface system of a computer system. For example, and without limitation, the storage platform of the present invention may be embodied in, or form an integral part of, an operating system, a virtual machine manager (VMM), a Common Language Runtime (CLR) or its functional equivalent, or a Java Virtual Machine (JVM) or its functional equivalent. Through its common storage foundation, and schematized data, the storage platform of the present invention enables more efficient application development for consumers, knowledge workers and enterprises. It offers a rich and extensible programming surface area that not only makes available the capabilities inherent in its data model, but also embraces and extends existing file system and database access methods.","In the following description, and in various ones of the figures, the storage platform  of the present invention may be referred to as \u201cWinFS.\u201d However, use of this name to refer to the storage platform is solely for convenience of description and is not intended to be limiting in any way.","C. The Data Model","The data store  of the storage platform  of the present invention implements a data model that supports the organization, searching, sharing, synchronization, and security of data that resides in the store. In the data model of the present invention, an \u201cItem\u201d is the fundamental unit of storage information. The data model provides a mechanism for declaring Items and Item extensions and for establishing relationships between Items and for organizing Items in Item Folders and in Categories, as described more fully below.","The data model relies on two primitive mechanisms, Types and Relationships. Types are structures which provide a format which governs the form of an instance of the Type. The format is expressed as an ordered set of Properties. A Property is a name for a value or set of values of a given Type. For example a USPostalAddress type might have the properties Street, City, Zip, State in which Street, City and State are of type String and Zip is of Type Int32. Street may be multi-valued (i.e. a set of values) allowing the address to have more than one value for the Street property. The system defines certain primitive types that can be used in the construction of other types\u2014these include String, Binary, Boolean, Int16, Int32, Int64, Single, Double, Byte, DateTime, Decimal and GUID. The Properties of a Type may be defined using any of the primitive types or (with some restrictions noted below) any of the constructed types. For example a Location Type might be defined that had Properties Coordinate and Address where the Address Property is of Type USPostalAddress as described above. Properties may also be required or optional.","Relationships can be declared and represent a mapping between the sets of instances of two types. For example there may be a Relationship declared between the Person Type and the Location Type called LivesAt which defines which people live at which locations. The Relationship has a name, two endpoints, namely a source endpoint and a target endpoint. Relationships may also have an ordered set of properties. Both the Source and Target endpoints have a Name and a Type. For example the LivesAt Relationship has a Source called Occupant of Type Person and a Target called Dwelling of Type Location and in addition has properties StartDate and EndDate indicating the period of time for which the occupant lived at the dwelling. Note that a Person may live at multiple dwellings over time and a dwelling may have multiple occupants so the most likely place to put the StartDate and EndDate information is on the relationship itself.","Relationships define a mapping between instances that is constrained by the types given as the endpoint types. For example the LivesAt relationship cannot be a relationship in which an Automobile is the Occupant because an Automobile is not a Person.","The data model does allow the definition of a subtype-supertype relationship between types. The subtype-supertype relationship also known as the BaseType relationship is defined in such a way that if Type A is a BaseType for Type B it must be the case that every instance of B is also an instance of A. Another way of expressing this is that every instance that conforms to B must also conform to A. If, for example A has a property Name of Type String while B has a property Age of Type Int16, it follows that any instance of B must have both a Name and an Age. The type hierarchy may be envisaged as an tree with a single supertype at the root. The branches from the root provide the first level subtypes, the branches at this level provide the second level subtypes and so on to the leaf-most subtypes which themselves do not have any subtypes. The tree is not constrained to be of a uniform depth but cannot contain any cycles. A given Type may have zero or many subtypes and zero or one super type. A given instance may conform to at most one type together with that type's super types. To put it another way, for a given instance at any level in the tree the instance may conform to at most one subtype at that level. A type is said to be Abstract if instances of the type must also be an instance of a subtype of the type.","1. Items","An Item is a unit of storable information that, unlike a simple file, is an object having a basic set of properties that are commonly supported across all objects exposed to an end-user or application program by the storage platform. Items also have properties and relationships that are commonly supported across all Item types including features that allow new properties and relationships to be introduced, as discussed below.","Items are the objects for common operations such as copy, delete, move, open, print, backup, restore, replicate, and so forth. Items are the units that can be stored and retrieved, and all forms of storable information manipulated by the storage platform exist as Items, properties of Items, or Relationships between Items, each of which is discussed in greater detail herein below.","Items are intended to represent real-world and readily-understandable units of data like Contacts, People, Services, Locations, Documents (of all various sorts), and so on.  is a block diagram illustrating the structure of an Item. The unqualified name of the Item is \u201cLocation\u201d. The qualified name of the Item is \u201cCore.Location\u201d which indicates that this Item structure is defined as a specific type of Item in the Core Schema. (The Core Schema is discussed in more detail later herein.)","The Location Item has a plurality of properties including EAddresses, MetropolitanRegion, Neighborhood, and PostalAddresses. The specific type of property for each is indicated immediately following the property name and is separated from the property name by a colon (\u201c:\u201d). To the right of the type name, the number of values permitted for that property type is indicated between brackets (\u201c[ ]\u201d) wherein an asterisk (\u201c*\u201d) to the right of the colon (\u201c:\u201d) indicates an unspecified and\/or unlimited number (\u201cmany\u201d). A \u201c1\u201d to the right of the colon indicates that there can be at most one value. A zero (\u201c0\u201d) to the left of the colon indicates that the property is optional (there may be no value at all). A \u201c1\u201d to the left of the colon indicates that there must be at least one value (the property is required). Neighborhood and MetropolitanRegion are both of type \u201cnvarchar\u201d (or equivalent) which is a predefined data type or \u201csimple type\u201d (and denoted herein by the lack of capitalization). EAddresses and PostalAddresses, however, are properties of defined types or \u201ccomplex types\u201d (as denoted herein by capitalization) of types EAddress and PostalAddress respectively. A complex type is type that is derived from one or more simple data types and\/or from other complex types. The complex types for the properties of an Item also constitute \u201cnested elements\u201d since the details of the complex type are nested into the immediate Item to define its properties, and the information pertaining to these complex types is maintained with the Item that has these properties (within the Item's boundary, as discussed later herein). These concepts of typing are well known and readily appreciated by those of skill in the art.",{"@attributes":{"id":"p-0113","num":"0115"},"figref":["FIG. 5B","FIG. 5C","FIG. 5C","FIG. 5A"]},"Similar to but distinct from properties and their property types, Items inherently represent their own Item Types that can also be the subject of subtyping. In other words, the storage platform in several embodiments of the present invention allows an Item to be a subtype of another Item (whereby the one Item inherits the properties of the other, parent Item). Moreover, for various embodiments of the present invention, every Item is a subtype of the \u201cItem\u201d Item type which is the first and foundational Item type found in the Base Schema. (The Base Schema will also be discussed in detail later herein.)  illustrates an Item, the Location Item in this Instance, as being a subtype of the Item Item type found in the Base Schema. In this drawing, the arrow indicates that the Location Item (like all other Items) is a subtype of the Item Item type. The Item Item type, as the foundational Item from which all other Items are derived, has a number of important properties such as ItemId and various timestamps, and thereby defines the standard properties of all Items in an operating system. In the present figure, these properties of the Item Item type are inherited by Location and thereby become properties of Location.","Another way to represent the properties in the Location Item inherited from the Item Item type is to draw Location with the individual properties of each property type from the parent Item listed therein.  is a block diagram illustrating the Location Item wherein its inherited types described in addition to its immediate properties. It should be noted and understood that this Item is the same Item illustrated in , although in the present figure Location is illustrated with all of its properties, both immediate\u2014shown in both this figure and FIG. A\u2014and inherited\u2014shown in this figure but not  (whereas in  these properties are referenced by showing with an arrow that the Location Item is a subtype of the Item Item type).","Items are stand-alone objects; thus, if you delete an Item, all of the Items immediate and inherited properties are also deleted. Similarly, when retrieving an Item, what is received is the Item and all of its immediate and inherited properties (including the information pertaining to its complex property types). Certain embodiments of the present invention may enable one to request a subset of properties when retrieving a specific Item; however, the default for many such embodiments is to provide the Item with all of its immediate and inherited properties when retrieved. Moreover, the properties of Items can also be extended by adding new properties to the existing properties of that Item's type. These \u201cextensions\u201d are thereafter bona fide properties of the Item and subtypes of that Item type may automatically include the extension properties.","The \u201cboundary\u201d of the Item is represented by its properties (including complex property types, extensions, and so forth). An Item's boundary also represents the limit of an operation performed on an Item such as copy, delete, move, create, and so on. For example, in several embodiments of the present invention, when an Item is copied, everything within that Item's boundary is also copied. For each Item, the boundary encompasses the following:\n\n","2. Item Identification","Items are uniquely identified within the global items space with an ItemD. The Base.Item type defines a field ItemID of type GUID that stores the identity for the Item. An Item must have exactly one identity in the data store .","An item reference is a data structure that contains information to locate and identify an Item. In the data model, an abstract type is defined named ItemReference from which all item reference types derive. The ItemReference type defines a virtual method named Resolve. The Resolve method resolves the ItemReference and returns an Item. This method is overridden by the concrete subtypes of ItemReference, which implement a function that retrieves an Item given a reference. The Resolve method is invoked as part of the storage platform API .","ItemIDReference is a subtype of ItemReference. It defines a Locator and an ItemID field. The Locator field names (i.e. identifies) an item domain. It is processed by a locator resolution method that can resolve the value of the Locator to an item domain. The ItemID field is of type ItemID","ItemPathReference is a specialization of ItemReference that defines a Locator and a Path field. The Locator field identifies an item domain. It is processed by a locator resolution method that can resolve the value of the Locator to an item domain. The Path field contains a (relative) path in the storage platform namespace rooted at the item domain provided by the Locator.","This type of reference cannot be used in a set operation. The reference must generally be resolved through a path resolution process. The Resolve method of the storage platform API  provides this functionality.","The reference forms discussed above are represented through the reference type hierarchy illustrated in . Additional reference types that inherit from these types can be defined in the schemas. They can be used in a relationship declaration as type of the target field.","3. Item Folders and Categories","As discussed more fully below, groups of Items can are organized into special Items called Item Folders (which are not to be confused with file folders). Unlike in most file systems, however, an Item can belong to more than one Item Folder, such that when an Item is accessed in one Item Folder and revised, this revised Item can then be accessed directly from another Item folder. In essence, although access to an Item may occur from different Item Folders, what is actually being accessed is in fact the very same Item. However, an Item Folder does not necessarily own all of its member Items, or may simply co-own Items in conjunction with other folders, such that the deletion of an Item Folder does not necessarily result in the deletion of the Item. Nevertheless, in several embodiments of the present invention, an Item must belong to at least one Item Folder so that if the sole Item Folder for a particular Item is deleted then, for some embodiments, the Item is automatically deleted or, in alternative embodiments, the Item automatically becomes a member of a default Item Folder (e.g., a \u201cTrash Can\u201d Item Folder conceptually similar to similarly-named folders used in various file-and-folder-based systems).","As also discussed more fully below, Items may also belong to Categories based on common described characteristic such as (a) an Item Type (or Types), (b) a specific immediate or inherited property (or properties), or (c) a specific value (or values) corresponding to an Item property. For example, a Item comprising specific properties for personal contact information might automatically belong to a Contact Category, and any Item having contact information properties would likewise automatically belong to this Category. Likewise, any Item having a location property with a value of \u201cNew York City\u201d might automatically belong to a NewYorkCity Category.","Categories are conceptually different form Item Folders in that, whereas Item Folders may comprise Items that are not interrelated (i.e., without a common described characteristic), each Item in a Category has a common type, property, or value (a \u201ccommonality\u201d) that is described for that Category, and it is this commonality that forms the basis for its relationship to and among the other Items in the Category. Moreover, whereas an Item's membership in a particular Folder is not compulsory based on any particular aspect of that Item, for certain embodiments all Items having a commonality categorically related to a Category might automatically become a member of the Category at the hardware\/software interface system level. Conceptually, Categories can also be thought of as virtual Item Folders whose membership is based on the results of a specific query (such as in the context of a database), and Items that meet the conditions of this query (defined by the commonalities of the Category) would thus comprise the Category's membership.",{"@attributes":{"id":"p-0129","num":"0134"},"figref":"FIG. 4","b":["402","404","406","408","410","412","414","416","418","420","422","424","426","428","430","402","422","424","402","404","406","408","410","412","432","434","436","414","416","418","420"]},"In contrast to files, folders, and directories, the Items, Item Folders, and Categories of the present invention are not characteristically \u201cphysical\u201d in nature because they do not have conceptual equivalents of physical containers, and therefore Items may exist in more than one such location. The ability for Items to exist in more than one Item Folder location as well as being organized into Categories provides an enhanced and enriched degree of data manipulation and storage structure capabilities at the hardware\/software interface level, beyond that currently available in the art.","4. Schemas","a) Base Schema","To provide a universal foundation for the creation and use of Items, various embodiments of the storage platform of the present invention comprise a Base Schema that establishes a conceptual framework for creating and organizing Items and properties. The Base Schema defines certain special types of Items and properties, and the features of these special foundational types from which subtypes can be further derived. The use of this Base Schema allows a programmer to conceptually distinguish Items (and their respective types) from properties (and their respective types). Moreover, the Base Schema sets forth the foundational set of properties that all Items may possess as all Items (and their corresponding Item Types) are derived from this foundational Item in the Base Schema (and its corresponding Item Type).","As illustrated in , and in regard to several embodiments of the present invention, the Base Schema defines three top-level types: Item, Extension, and PropertyBase. As shown, the Item type is defined by the properties of this foundational \u201cItem\u201d Item type. In contrast, the top level property type \u201cPropertyBase\u201d has no predefined properties and is merely the anchor from which all other property types are derived and through which all derived property types are interrelated (being commonly derived from the single property type). The Extension type properties define which Item the extension extends as well as identification to distinguish one extension from another as an Item may have multiple extensions.","ItemFolder is a subtype of the Item Item type that, in addition to the properties inherited from Item, features a Relationship for establishing links to its members (if any), whereas both IdentityKey and Property are subtypes of PropertyBase. CategoryRef, in turn, is a subtype of IdentityKey.","b) Core Schema","Various embodiments of the storage platform of the present invention further comprise a Core Schema that provides a conceptual framework for top-level Items type structures.  is a block diagram illustrating Items in the Core Schema, and  is a block diagram illustrating the property types in the Core Schema. The distinction made between files with different extensions (*.com, *.exe, *.bat, *.sys, etc.) and other such criteria in file-and-folder-based systems is analogous to the function of the Core Schema. In the Item-based hardware\/software interface system, the Core Schema defines a set of core Item types that, directly (by Item type) or indirectly (by Item subtype), characterize all Items into one or more Core Schema Item types which the Item-based hardware\/software interface system understands and can directly process in a predetermined and predictable way. The predefined Item types reflect the most common Items in the Item-based hardware\/software interface system and thus a level of efficiency is gained by the Item-based hardware\/software interface system understanding these predefined Item types that comprise the Core Schema.","In certain embodiments, the Core Schema is not extendable\u2014that is, no additional Item types can be subtyped directly from the Item type in the Base Schema except for the specific predefined derived Item types that are part of the Core Schema. By preventing extensions to the Core Schema (that is, by preventing the addition of new Items to the Core Schema), the storage platform mandates the use of the Core Schema Item types since every subsequent Item type is necessarily a subtype of a Core Schema Item type. This structure enables a reasonable degree of flexibility in defining additional Item types while also preserving the benefits of having a predefined set of core Item types.","For various embodiments of the present invention, and in reference to , the specific Item types supported by the Core Schema may include one or more of the following:\n\n","Likewise, and in reference to , the specific property types supported by the Core Schema may include one or more of the following:\n\n","5. Relationships","Relationships are binary relationships where one Item is designated as source and the other Item as target. The source Item and the target Item are related by the relationship. The source Item generally controls the life-time of the relationship. That is, when the source Item is deleted, the relationship between the Items is also deleted.","Relationships are classified into: Containment and Reference relationships. The containment relationships control the life-time of the target Items, while the reference relationships do not provide any life-time management semantics.  illustrates the manner in which relationships are classified.","The Containment relationship types are further classified into Holding and Embedding relationships. When all holding relationships to an Item are removed, the Item is deleted. A holding relationship controls the life-time of the target through a reference counting mechanism. The embedding relationships enable modeling of compound Items and can be thought of as exclusive holding relationships. An Item can be a target of one or more holding relationships; but an Item can be target of exactly one embedding relationship. An Item that is a target of an embedding relationship can not be a target of any other holding or embedding relationships.","Reference relationships do not control the lifetime of the target Item. They may be dangling\u2014the target Item may not exist. Reference relationships can be used to model references to Items anywhere in the global Item name space (i.e. including remote data stores).","Fetching an Item does not automatically fetch its relationships. Applications must explicitly request the relationships of an Item. In addition, modifying a relationship does not modify the source or the target Item; similarly, adding a relationship does not affect the source\/target Item.","a) Relationship Declaration","The explicit relationship types are defined with the following elements:\n\n","The source Item is the owner of the relationship. While an Item designated as owner controls the life time of the relationship, the relationship itself is separate from the Items it relates. The storage platform API  provides mechanisms for exposing relationships associated with an Item.","Here is an example of a relationship declaration:",{"@attributes":{"id":"p-0151","num":"0181"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"<Relationship Name=\u201cEmployment\u201d BaseType=\u201cReference\u201d >"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Source Name=\u201cEmployee\u201d ItemType=\u201cContact.Person\u201d\/>"]},{"entry":[{},"<Target Name=\u201cEmployer\u201d ItemType=\u201cContact.Organization\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ReferenceType=\u201cItemIDReference\u201d\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Property Name=\u201cStartDate\u201d Type=\u201cthe storage"]},{"entry":[{},"platformTypes.DateTime\u201d\/>"]},{"entry":[{},"<Property Name=\u201cEndDate\u201d Type=\u201cthe storage"]},{"entry":[{},"platformTypes.DateTime\u201d\/>"]},{"entry":[{},"<Property Name=\u201cOffice\u201d Type=\u201cthe storage"]},{"entry":[{},"platformTypes.DateTime\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<\/Relationship>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"This is an example of a Reference relationship. The relationship can not be created if the person Item that is referenced by the source reference does not exist. Also, if the person Item is deleted, the relationship instances between the person and organization are deleted. However, if the Organization Item is deleted, the relationship is not deleted and it is dangling.","b) Holding Relationship","Holding relationships are used to model reference count based life-time management of the target Items.","An Item can be a source endpoint for zero or more relationships to Items. An Item that is not an embedded Item can be a target of in one or more holding relationships.","The target endpoint reference type must be ItemIDReference and it must reference an Item in the same store as the relationship instance.","Holding relationships enforce lifetime management of the target endpoint. The creation of a holding relationship instance and the Item that it is targeting is an atomic operation. Additional holding relationship instances can be created that are targeting the same Item. When the last holding relationship instance with a given Item as target endpoint is deleted the target Item is also deleted.","The types of the endpoint Items specified in the relationship declaration will generally be enforced when an instance of the relationship is created. The types of the endpoint Items can not be changed after the relationship is established.","Holding relationships play a key role in forming the Item namespace. They contain the \u201cName\u201d property that defines the name of the target Item relative to the source Item. This relative name is unique for all the holding relationships sourced from a given Item. The ordered list of this relative names starting from the root Item to a given Item forms the full name to the Item.","The holding relationships form a directed acyclic graph (DAG). When a holding relationship is created the system ensures that a cycle is not created, thus ensuring that the Item namespace forms a DAG.","While the holding relationship controls the life time of the target Item, it does not control the operational consistency of the target endpoint Item. The target Item is operationally independent from the Item that owns it through a holding relationship. Copy, Move, Backup and other operations on an Item that is a source of a holding relationship do not affect the Item that is a target of the same relationship\u2014for example that is, backing up a Folder Item does not automatically backup all the Items in the folder (targets of the FolderMember relationship).","The following is an example of a holding relationship:",{"@attributes":{"id":"p-0163","num":"0193"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Relationship Name=\u2033FolderMembers\u2033 BaseType=\u2033Holding\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Source Name=\u2033Folder\u2033 ItemType=\u2033Base.Folder\u2033\/>"]},{"entry":[{},"<Target Name=\u2033Item\u2033 ItemType=\u2033Base.Item\u2033"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ReferenceType=\u2033ItemIDReference\u2033\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/Relationship>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The FolderMembers relationship enables the concept of a Folder as a generic collection of Items.","c) Embedding Relationships","Embedding relationships model the concept of exclusive control of the lifetime of the target Item. They enable the concept of compound Items.","The creation of an embedding relationship instance and the Item that it is targeting is an atomic operation. An Item can be a source of zero or more embedding relationship. However, an Item can be a target of one and only one embedding relationship. An Item that is a target of an embedding relationship can not be a target of a holding relationship.","The target endpoint reference type must be ItemIDReference and it must reference an Item in the same data store as the relationship instance.","The types of the endpoint Items specified in the relationship declaration will generally be enforced when an instance of the relationship is created. The types of the endpoint Items can not be changed after the relationship is established.","Embedding relationships control the operational consistency of the target endpoint. For example the operation of serializing of an Item may include serialization of all the embedding relationships that source from that Item as well as all of their targets; copying an Item also copies all its embedded Items.","The following is an example declaration:",{"@attributes":{"id":"p-0172","num":"0202"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"<Relationship Name=\u2033ArchiveMembers\u2033 BaseType=\u2033Embedding\u201d>"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Source Name=\u2033Archive\u2033 ItemType=\u2033Zip.Archive\u2033\/>"]},{"entry":[{},"<Target Name=\u2033Member\u2033 ItemType=\u2033Base.Item \u2033"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ReferenceType=\u2033ItemIDReference\u2033\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Property Name=\u2033ZipSize\u2033 Type=\u2033the storage"]},{"entry":[{},"platformTypes.bigint\u2033\/>"]},{"entry":[{},"<Property Name=\u2033SizeReduction\u2033 Type=\u2033the storage"]},{"entry":[{},"platformTypes.float\u2033\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<\/Relationship>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"d) Reference Relationships","The reference relationship does not control life time of the Item it references. Even more, the reference relationships do not guarantee the existence of the target, nor do they guarantee the type of the target as specified in the relationship declaration. This means that the reference relationships can be dangling. Also, the reference relationship can reference Items in other data stores. Reference relationships can be thought of as a concept similar to links in web pages.","An example of reference relationship declaration is the following:",{"@attributes":{"id":"p-0176","num":"0206"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Relationship Name=\u201cDocumentAuthor\u201d BaseType=\u201cReference\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Sourc ItemType=\u201cDocument\u201d"]},{"entry":[{},"ItemType=\u201cBase.Document\u201d\/>"]},{"entry":[{},"<Target ItemType=\u201cAuthor\u201d ItemType=\u201cBase.Author\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ReferenceType=\u201cItemIDReference\u201d\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Property Type=\u201cRole\u201d Type=\u201cCore.CategoryRef\u201d\/>"]},{"entry":[{},"<Property Type=\u201cDisplayName\u201d Type=\u201cthe storage"]},{"entry":[{},"platformTypes.nvarchar(256)\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/Relationship>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Any reference type is allowed in the target endpoint. The Items that participate in a reference relationship can be of any Item type.","Reference relationships are used to model most non-lifetime management relationships between Items. Since the existence of the target is not enforced, the reference relationship is convenient to model loosely-coupled relationships. The reference relationship can be used to target Items in other data stores including stores on other computers.","e) Rules and Constraints","The following additional rules and constraints apply for relationships:\n\n","f) Ordering of Relationships","In at least one embodiment, the storage platform of the present invention supports ordering of relationships. The ordering is achieved through a property named \u201cOrder\u201d in the base relationship definition. There is no uniqueness constraint on the Order field. The order of the relationships with the same \u201corder\u201d property value is not guaranteed, however it is guaranteed that they may be ordered after relationships with lower \u201corder\u201d value and before relationships with higher \u201corder\u201d field value.","Applications can get the relationships in the default order by ordering on the combination (SourceltemID, RelationshipID, Order). All relationship instances sourced from a given Item are ordered as a single collection regardless of the type of the relationships in the collection. This however guarantees that all relationships of a given type (e.g., FolderMembers) are an ordered subset of the relationship collection for a given Item.","The data store API  for manipulating relationships implement a set of operations that support ordering of relationships. The following terms are introduced to help explain the operations:\n\n","The operations include but are not limited to:\n\n","As previously mentioned, every Item must be a member of an Item Folder. In terms of Relationships, every Item must have a relationship with an Item Folder. In several embodiments of the present invention, certain relationships are represented by Relationships existing between the Items.","As implemented for various embodiments of the present invention, a Relationship provides a directed binary relationship that is \u201cextended\u201d by one Item (the source) to another Item (the target). A Relationship is owned by the source Item (the Item that extended it), and thus the Relationship is removed if the source is removed (e.g., the Relationship is deleted when the source Item is deleted). Moreover, in certain instances, a Relationship may share ownership of (co-own) the target Item, and such ownership might be reflected in the IsOwned property (or its equivalent) of the Relationship (as shown in  for the Relationship property type). In these embodiments, creation of a new IsOwned Relationship automatically increments a reference count on the target Item, and deletion of such a Relationship may decrement the reference count on the target Item. For these specific embodiments, Items continue to exist if they have a reference count greater than zero, and are automatically deleted if and when the count reaches zero. Again, an Item Folder is an Item that has (or is capable of having) a set of Relationships to other Items, these other Items comprising the membership of the Item Folder. Other actual implementations of Relationships are possible and anticipated by the present invention to achieve the functionality described herein.","Regardless of actual implementation, a Relationship is a selectable connection from one object to another. The ability for an Item to belong to more than one Item Folder, as well as to one or more Categories, and whether these Items, Folders, and Categories are public or private, is determined by the meanings given to the existence (or lack thereof) in an Item-based structure. These logical Relationships are the meanings assigned to a set of Relationships, regardless of physical implementation, which are specifically employed to achieve the functionality described herein. Logical Relationships are established between the Item and its Item Folder(s) or Categories (and vice versa) because, in essence, Item Folders and Categories are each a special type of Item. Consequently, Item Folders and Categories can be acted upon the same way as any other Item\u2014copied, added to an email message, embedded in a document, and so and so forth without limitation\u2014and Item Folders and Categories can be serialized and de-serialized (imported and exported) using the same mechanisms as for other Items. (For example, in XML all Items might have a serialization format, and this format applies equally to Item Folders, Categories, and Items.)","The aforementioned Relationships, which represent the relationship between an Item and it Item Folder(s) can logically extend from the Item to the Item Folder, from the Item Folder to the Item, or both. A Relationship that logically extends from an Item to an Item Folder denotes that the Item Folder is public to that Item and shares its membership information with that Item; conversely, the lack of a logical Relationship from an Item to an Item Folder denotes that the Item Folder is private to that Item and does not share its membership information with that Item. Similarly, a Relationship that logically extends from an Item Folder to an Item denotes that the Item is public and sharable to that Item Folder, whereas the lack of a logical Relationship from the Item Folder to the Item denotes that the Item is private and non-sharable. Consequently, when an Item Folder is exported to another system, it is the \u201cpublic\u201d Items that are shared in the new context, and when an Item searches its Items Folders for other, sharable Items, it is the \u201cpublic\u201d Item Folders that provide the Item with information regarding sharable Items that belong thereto.",{"@attributes":{"id":"p-0190","num":"0236"},"figref":"FIG. 9","b":["900","902","904","906","900","912","902","902","900","904","906","900","902","900","900","902","902","904","924","900","900","904","900","904","904","900","902","906","900","902","904","900","916","906","906","926","900","906","900","902","904","900","900","906"]},"As previously discussed, the Items in an Item Folder do not need to share a commonality because Item Folders are not \u201cdescribed.\u201d Categories, on the other hand, are described by a commonality that is common to all of its member Items. Consequently the membership of a Category is inherently limited to Items having the described commonality and, in certain embodiments, all Items meeting the description of a Category are automatically made members of the Category. Thus, whereas Item Folders allow trivial type structures to be represented by their membership, Categories allow membership based on the defined commonality.","Of course Category descriptions are logical in nature, and therefore a Category may be described by any logical representation of types, properties, and\/or values. For example, a logical representation for a Category may be its membership to comprise Items have one of two properties or both. If these described properties for the Category are \u201cA\u201d and \u201cB\u201d, then the Categories membership may comprise Items having property A but not B, Items having property B but not A, and Items having both properties A and B. This logical representation of properties is described by the logical operator \u201cOR\u201d where the set of members described by the Category are Items having property A OR B. Similar logical operands (including without limitation \u201cAND\u201d, \u201cXOR\u201d, and \u201cNOT\u201d alone or in combination) can also be used describe a category as will be appreciated by those of skill in the art.","Despite the distinction between Item Folders (not described) and Categories (described), Categories Relationship to Items and Items Relationship to Categories essentially the same way as disclosed herein above for Item Folders and Items in many embodiments of the present invention.",{"@attributes":{"id":"p-0194","num":"0240"},"figref":"FIG. 10","b":["1000","1002","1004","1006","1008","1008","1000","1000","1012","1002","1002","1000","1004","1006","1000","1002","1000","1000","1002","1002","1004","1024","1000","1000","1004","1000","1004","1004","1000","1002","1006","1000","1002","1004","1000","1016","1006","1006","1026","1000","1006","1000","1002","1004","1000","1000","1006"]},"Finally, because Categories and Item Folders are themselves Items, and Items may Relationship to each other, Categories may Relationship to Item Folders and vice versa, and Categories, Item Folders, and Items can Relationship to other Categories, Item Folders, and Item respectively in certain alternative embodiments. However, in various embodiments, Item Folder structures and\/or Category structures are prohibited, at the hardware\/software interface system level, from containing cycles. Where Item Folder and Category structures are akin to directed graphs, the embodiments that prohibit cycles are akin to directed acyclic graphs (DAGs) which, by mathematical definition in the art of graph theory, are directed graphs wherein no path starts and ends at the same vertex.","6. Extensibility","The storage platform is intended to be provided with an initial set of schemas , as described above. In addition, however, in at least some embodiments, the storage platform allows customers, including independent software vendor (ISVs), to create new schemas  (i.e. new Item and Nested Element types). This section addresses the mechanism for creating such schemas by extending the Item types and Nested Element types (or simply \u201cElement\u201d types) defined in the initial set of schemas .","Preferably, extension of the initial set of Item and Nested Element types is constrained as follows:\n\n","Since an Item type or Nested Element type defined by the initial set of storage platform schemas may not exactly match an ISV application's need, it is necessary to allow ISVs to customize the type. This is allowed with the notion of Extensions. Extensions are strongly typed instances but (a) they cannot exist independently and (b) they must be attached to an Item or Nested Element.","In addition to addressing the need for schema extensibility, Extensions are also intended to address the \u201cmulti-typing\u201d issue. Since, in some embodiments, the storage platform may not support multiple inheritance or overlapping subtypes, applications can use Extensions as a way to model overlapping type instances (e.g. Document is a legal document as well a secure document).","a) Item Extensions","To provide Item extensibility, the data model further defines an abstract type named Base.Extension. This is a root type for the hierarchy of extension types. Applications can subtype Base.Extension to create specific extension types.","The Base.Extension type is defined in the Base schema as follows:",{"@attributes":{"id":"p-0204","num":"0254"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Type Name=\u201cBase.Extension\u201d IsAbstract=\u201cTrue\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Propety Name=\u201cItemID\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type=\u201cthe storage platformTypes.uniqueidentified\u201d"]},{"entry":[{},"Nullable=\u201cfalse\u201d"]},{"entry":[{},"MultiValued=\u201cfalse\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Property Name=\u201cExtensionID\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type=\u201cthe storage platformTypes.uniqueidentified\u201d"]},{"entry":[{},"Nullable=\u201cfalse\u201d"]},{"entry":[{},"MultiValued=\u201cfalse\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/Type>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The ItemID field contains the ItemID of the item that the extension is associated with. An Item with this ItemID must exist. The extension can not be created if the item with the given ItemID does not exist. When the Item is deleted all the extensions with the same ItemID are deleted. The tuple (ItemID,ExtensionID) uniquely identifies an extension instance.","The structure of an extension type is similar to that of an item type:\n\n","The following restrictions apply for extension types\n\n","There are no constraints on the types of extensions that can be associated with a given Item type. Any extension type is allowed to extend any item type. When multiple extension instances are attached to an item, they are independent from each other in both structure and behavior.","The extension instances are stored and accessed separately from the item. All extension type instances are accessible from a global extension view. An efficient query can be composed that will return all the instances of a given type of extension regardless of what type of item they are associated with. The storage platform APIs provides a programming model that can store, retrieve and modify extensions on items.","The extension types can be type sub-typed using the storage platform single inheritance model. Deriving from an extension type creates a new extension type. The structure or the behavior of an extension cannot override or replace the structure or behaviors of the item type hierarchy. Similar to Item types, Extension type instances can be directly accessed through the view associated with the extension type. The ItemID of the extension indicates which item they belong to and can be used to retrieve the corresponding Item object from the global Item view. The extensions are considered part of the item for the purposes of operational consistency. The Copy\/Move, Backup\/Restore and other common operations that the storage platform defines may operate on the extensions as part of the item.","Consider the following example. A Contact type is defined in the Windows Type set.",{"@attributes":{"id":"p-0212","num":"0268"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Type Name=\u2033Contact\u2033 BaseType=\u201cBase.Item\u201d >"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Property Name=\u2033Name\u2033"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type=\u2033String\u2033"]},{"entry":[{},"Nullable=\u2033false\u2033"]},{"entry":[{},"MultiValued=\u2033false\u2033\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Property Name=\u2033Address\u2033"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type=\u2033Address\u2033"]},{"entry":[{},"Nullable=\u2033true\u2033"]},{"entry":[{},"MultiValued=\u2033false\u2033\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/Type>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"A CRM application developer would like to attach a CRM application extension to the contacts stored in the storage platform. The application developer would define a CRM extension that would contain the additional data structure that the application can manipulate.",{"@attributes":{"id":"p-0214","num":"0270"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Type Name=\u201cCRMExtension\u201d BaseType=\u201cBase.Extension\u201d >"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Property Name=\u201cCustomerID\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type=\u201cString\u201d"]},{"entry":[{},"Nullable=\u201cfalse\u201d"]},{"entry":[{},"MultiValued=\u201cfalse\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/Type>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"An HR application developer may want to also attach additional data with the Contact. This data is independent from the CRM application data. Again the application developer can create an extension",{"@attributes":{"id":"p-0216","num":"0272"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Type Name=\u201cHRExtension\u201d EBaseType=\u201cBase.Extension\u201d >"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Property Name=\u201cEmployeeID\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type=\u201cString\u201d"]},{"entry":[{},"Nullable=\u201cfalse\u201d"]},{"entry":[{},"MultiValued=\u201cfalse\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/Type>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"CRMExtension and HRExtension are two independent extensions that can be attached to Contact items. They are created and accessed independently of each other.","In the above example, the fields and methods of the CRMExtension type cannot override fields or methods of the Contact hierarchy. It should be noted that instances of the CRMExtension type can be attached to Item types other than Contact.","When the Contact item is retrieved, its item extensions are not automatically retrieved. Given a Contact item, its related item extensions can be accessed by querying the global extension view for extensions with the same Itemld.","All CRMExtension extensions in the system can be accessed through the CRMExtension type view, regardless of which item they belong to. All item extension of an item share the same item id. In the above example, the Contact item instance and the attached CRMExtension and HRExtension instances the same ItemID.","The following table summarizes the similarities and differences between Item, Extension and NestedElement types:",{"@attributes":{"id":"p-0222","num":"0278"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Item vs. Item Extension vs NestedElement"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Item","Item Extension","NestedElement"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"63pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Item ID","Has its own item id","Shares the item id","Does not have its"]},{"entry":[{},{},"of the item","own item id. Nested"]},{"entry":[{},{},{},"element is part of"]},{"entry":[{},{},{},"the item"]},{"entry":["Storage","Item hierarchy is","Item extension","Stored with item"]},{"entry":[{},"stored in its own","hierarchy is stored"]},{"entry":[{},"tables","in its own tables"]},{"entry":["Query\/Search","Can query item","Can query item","Can generally be"]},{"entry":[{},"tables","extension tables","queried only within"]},{"entry":[{},{},{},"the containing"]},{"entry":[{},{},{},"item context"]},{"entry":["Query\/Search","Can search across","Can search across","Can generally only"]},{"entry":["scope","all instances of an","all instances of an","search within nested"]},{"entry":[{},"item type","item extension type","element type"]},{"entry":[{},{},{},"instances of a singe"]},{"entry":[{},{},{},"(containing) item"]},{"entry":["Relationship","Can have Rela-","No Relation-","No Relationships to"]},{"entry":["semantics","tionships to","ships to item","nested elements"]},{"entry":[{},"items","extensions"]},{"entry":["Association","Can be related to","Can generally only","Related to item via"]},{"entry":["to items","other items via","be related via","fields. Nested"]},{"entry":[{},"holding, embedded","extensions. The","elements are part of"]},{"entry":[{},"and soft","extension semantics","the item"]},{"entry":[{},"Relationships","is similar to"]},{"entry":[{},{},"embedded item"]},{"entry":[{},{},"semantics"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"b) Extending NestedElement Types","Nested Element types are not extended with the same mechanism as the Item types. Extensions of nested elements are stored and accessed with the same mechanisms as fields of nested element types.","The data model defines a root for nested element types named Element:",{"@attributes":{"id":"p-0226","num":"0282"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Type Name=\u201cElement\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"IsAbstract=\u201cTrue\u201d>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Property Name=\u201cElementID\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type=\u201cthe storage platformTypes.uniqueidentifier\u201d"]},{"entry":[{},"Nullable=\u201cfalse\u201d"]},{"entry":[{},"MultiValued=\u201cfalse\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/Type>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The NestedElement type inherits from this type. The NestedElement element type additionally defines a field that is a multi-set of Elements.",{"@attributes":{"id":"p-0228","num":"0284"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Type Name=\u201cNestedElement\u201d BaseType=\u201cBase.Element\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IsAbstract=\u201cTrue\u201d>"]},{"entry":[{},"<Property Name=\u201cExtensions\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Type=\u201cBase.Element\u201d"]},{"entry":[{},"Nullable=\u201cfalse\u201d"]},{"entry":[{},"MultiValued=\u201ctrue\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/Type>"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"The NestedElement extensions are,different from item extensions in the following ways:\n\n","The following table summarizes and compares Item Extensions and NestedElement extensions.",{"@attributes":{"id":"p-0231","num":"0291"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Item extensions vs NestedElement extensions"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Item Extension","NestedElement Extension"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Storage","Item extension","Stored like"]},{"entry":[{},"hierarchy is","nested elements"]},{"entry":[{},"stored in its"]},{"entry":[{},"own tables"]},{"entry":["Query\/Search","Can query item","Can generally only be"]},{"entry":[{},"extension","queried within the"]},{"entry":[{},"tables","containing item context"]},{"entry":["Query\/Search","Can search across all","Can generally only search"]},{"entry":["scope","instances of an item","within nested element type"]},{"entry":[{},"extension type","instances of a singe"]},{"entry":[{},{},"(containing) item"]},{"entry":["Programmability","Need special extension","NestedElement extensions"]},{"entry":[{},"APIs and special","are like any other multi-"]},{"entry":[{},"querying on","valued field of nested"]},{"entry":[{},"extension tables","element; normal nested"]},{"entry":[{},{},"element type APIs are used"]},{"entry":["Behavior","Can associate behavior","No behavior permitted (?)"]},{"entry":["Relationship","No Relationships","No Relationships to"]},{"entry":["semantics","to item extensions","NestedElement extensions"]},{"entry":["Item ID","Shares the item","Does not have its own item"]},{"entry":[{},"id of the item","id. NestedElement"]},{"entry":[{},{},"extension is part of the"]},{"entry":[{},{},"item"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"D. Database Engine","As mentioned above, the data store is implemented on a database engine. In the present embodiment, the database engine comprises a relational database engine that implements the SQL query language, such as the Microsoft SQL Server engine, with object relational extensions. This section describes the mapping of the data model that the data store implements to the relational store and provides information on the logical API consumed by storage platform clients, in accordance with the present embodiment. It is understood, however, that a different mapping may be employed when a different database engine is employed. Indeed, in addition to implementing the storage platform conceptual data model on a relational database engine, it can also be implemented on other types of databases, e.g. object-oriented and XML databases.","An object-oriented (OO) database system provides persistence and transactions for programming language objects (e.g. C++, Java). The storage platform notion of an \u201citem\u201d maps well to an \u201cObject\u201d in object-oriented systems, though embedded collections would have to be added to Objects. Other storage platform type concepts, like inheritance and nested element types, also map object-oriented type systems. Object-oriented systems typically already support object identity; hence, item identity can be mapped to object identity. The item behaviors (operations) map well to object methods. However, object-oriented systems typically lack organizational capabilities and are poor in searching. Also, object-oriented systems to do not provide support for unstructured and semi-structured data. To support the complete storage platform data model described herein, concepts like relationships, folders, and extensions would need to be added to the object data model. In addition, mechanisms like promotions, synchronization, notifications, and security would need to be implemented.","Similar to object-oriented systems, XML databases, based on XSD (XML Schema Definition), support a single-inheritance based type system. The item type system of the present invention could be mapped to the XSD type model. XSDs also do not provide support for behaviors. The XSDs for items would have to be augmented with item behaviors. XML databases deal with single XSD documents and lack organization and broad search capabilities. As with object-oriented databases, to support the data model described herein, other concepts like relationships, and folders would need to be incorporated into such XML databases; also, mechanisms like synchronization, notifications and security would need to be implemented.","In regard to the following subsections, a few illustrations are provided to facilitate the general information disclosed:  is a diagram illustrating a notification mechanism.  is a diagram illustrating an example in which two transactions are both inserting a new record into the same B-Tree.  illustrates a data change detection process.  illustrates an exemplary directory tree.  shows an example in which an existing folder of a directory-based file system is moved into the storage platform data store.","1. Data Store Implementation Using UDTs","In the present embodiment, the relational database engine , which in one embodiment comprises the Microsoft SQL Server engine, supports built-in scalar types. Built-in scalar types are \u201cnative\u201d and \u201csimple\u201d. They are native in the sense that the user cannot define their own types and they are simple in that they cannot encapsulate a complex structure. User-defined types (hereinafter: UDTs) provide a mechanism for type extensibility above and beyond the native scalar type system by enabling users to extend the type system by defining complex, structured types. Once defined by a user, a UDT can be used anywhere in the type system that a built-in scalar type might be used","In accordance with an aspect of the present invention, the storage platform schemas are mapped to UDT classes in the database engine store. Data store Items are mapped to UDT classes deriving from the Base.Item type. Like Items, Extensions are also mapped to UDT classes and make use of inheritance. The root Extension type is Base.Extension, from which all Extension types are derived.","A UDT is a CLR class\u2014it has state (i.e., data fields) and behavior (i.e., routines). UDTs are defined using any of the managed languages\u2014C#, VB.NET, etc. UDT methods and operators can be invoked in T-SQL against an instance of that type. A UDT can be: the type of a column in a row, the type of a parameter of a routine in T-SQL, or the type of a variable in T-SQL","The mapping of storage platform schemas to UDT classes is fairly straightforward at a high level. Generally, a storage platform Schema is mapped to a CLR namespace. A storage platform Type is mapped to a CLR class. The CLR class inheritance mirrors the storage platform Type inheritance, and a storage platform Property is mapped to a CLR class property.","2. Item Mapping","Given the desirability for Items to be globally searchable, and the support in the relational database of the present embodiment for inheritance and type substitutability, one possible implementation for Item storage in the database store would be to store all Items in a single table with a column of type Base.Item. Using type substitutability, Items of all types could be stored, and searches could be filtered by Item type and sub-type using Yukon's \u201cis of (Type)\u201d operator.","However, due to concerns about the overhead associated with such an approach, in the present embodiment, the Items are divided by top-level type, such that Items of each type \u201cfamily\u201d are stored in a separate table. Under this partitioning scheme, a table is created for each Item type inheriting directly from Base.Item. Types inheriting below these are stored in the appropriate type family table using type substitutability, as described above. Only the first level of inheritance from Base.Item is treated specially.","A \u201cshadow\u201d table is used to store copies of globally searchable properties for all Items. This table may be maintained by the Update( ) method of the storage platform API, through which all data changes are made. Unlike the type family tables, this global Item table contains only the top-level scalar properties of the Item, not the full UDT Item object. The global Item table allows navigation to the Item object stored in a type family table by exposing an ItemID and a TypeID. The ItemID will generally uniquely identify the Item within the data store. The TypeID may be mapped using metadata, which is not described here, to a type name and the view containing the Item. Since finding an Item by its ItemID may be a common operation, both in the context of the global Item table and otherwise, a GetItem( ) function is provided to retrieve an Item object given an Item's ItemID.","For convenient access and to hide implementation details to the extent possible, all queries of Items might be against views built on the Item tables described above. Specifically, views may be created for each Item type against the appropriate type family table. These type views may select all Items of the associated type, including sub-types. For convenience, in addition to the UDT object, the views may expose columns for all of the top-level fields of that type, including inherited fields.","3. Extension Mapping","Extensions are very similar to Items and have some of the same requirements. As another root type supporting inheritance, Extensions are subject to many of the same considerations and trade-offs in storage. Because of this, a similar type family mapping is applied to Extensions, rather than a single table approach. Of course, in other embodiments, a single table approach could be used. In the present embodiment, an Extension is associated with exactly one Item by ItemID, and contains an ExtensionID) that is unique in the context of the Item. As with Items, a function might be provided to retrieve an Extension given its identity, which consists of an ItemID and ExtensionID pair. A View is created for each Extension type, similar to the Item type views.","4. Nested Element Mapping","Nested Elements are types that can be embedded in Items, Extensions, Relationships, or other Nested Elements to form deeply nested structures. Like Items and Extensions, Nested Elements are implemented as UDT's, but they are stored within an Items and Extensions. Therefore, Nested Elements have no storage mapping beyond that of their Item and Extension containers. In other words, there are no tables in the system which directly store instances of NestedElement types, and there are no views dedicated specifically to Nested Elements.","5. Object Identity","Each entity in the data model, i.e., each Item, Extension and Relationship, has a unique key value. An Item is uniquely identified by its Itemld. An Extension is uniquely identified by a composite key of (Itemld, ExtensionID). A Relationship is identified by a composite key (Itemld, RelationshipID). Itemld, ExtensionID and RelationshipID are GUID values.","6. SQL Object Naming","All objects created in the data store can be stored in a SQL schema name derived from the storage platform schema name. For example, the storage platform Base schema (often called \u201cBase\u201d) may produce types in the \u201c[System.Storage]\u201d SQL schema such as \u201c[System.Storage].Item\u201d. Generated names are prefixed by a qualifier to eliminate naming conflicts. Where appropriate, an exclamation character (!) is used as a separator for each logical part of the name. The table below outlines the naming convention used for objects in the data store. Each schema element (Item, Extension, Relationship and View), is listed along with the decorated naming convention used to access instances in the data store.",{"@attributes":{"id":"p-0255","num":"0315"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":["Object","Name Decoration","Description","Example"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Master Item","Master!Item","Provides a","[System.Storage]."]},{"entry":["Search View",{},"summary of items","[Master!Item]"]},{"entry":[{},{},"in the current"]},{"entry":[{},{},"item domain."]},{"entry":["Typed Item","ItemType","Provides all","[AcmeCorp.Doc]."]},{"entry":["search view",{},"property data","[OfficeDoc]"]},{"entry":[{},{},"from item and any"]},{"entry":[{},{},"parent type(s)."]},{"entry":["Master","Master!Extension","Provides a","[System.Storage]."]},{"entry":["Extension",{},"summary of all","[Master!Extension]"]},{"entry":["Search View",{},"extensions in the"]},{"entry":[{},{},"current item"]},{"entry":[{},{},"domain."]},{"entry":["Typed","Extension!extensionType","Provides all","[AcmeCorp.Doc]."]},{"entry":["extension",{},"property data for","[Extension!StickyNote]"]},{"entry":["search view",{},"extension."]},{"entry":["Master","Master!Relationship","Provides a","[System.Storage]."]},{"entry":["Relationship",{},"summary of all","[Master!Relationship]"]},{"entry":["View",{},"relationships in"]},{"entry":[{},{},"the current item"]},{"entry":[{},{},"domain."]},{"entry":["Relationship","Relationship!relationship","Provides all data","[AcmeCorp.Doc]."]},{"entry":["view","Name","associated with a","[Relationship!AuthorsFrom"]},{"entry":[{},{},"given relationship","Document]"]},{"entry":["View","View!viewName","Provides the","[AcmeCorp.Doc]."]},{"entry":[{},{},"columns\/types","[View!DocumentTitles]"]},{"entry":[{},{},"based on the"]},{"entry":[{},{},"schema view"]},{"entry":[{},{},"definition."]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}}}},"7. Column Naming","When mapping any object model into a store, the possibility of naming collisions occur due to additional information stored along with an application object. In order to avoid naming collisions, all non-type specific columns (columns which do not map directly to a named Property in a type declaration) is be prefixed with an underscore (_) character. In the present embodiment, underscore (_) characters are disallowed as the beginning character of any identifier property. Further, in order to unify naming between CLR and the data store, all properties of a storage platform types or schema element (relationship, etc.) should have a capitalized first character.","8. Search Views","Views are provided by the storage platform for searching stored content. A SQL view is provided for each Item and Extension type. Further, views are provided to support Relationships and Views (as defined by the Data Model). All SQL views and underlying tables in the storage platform are read-only. Data may be stored or changed using the Update( ) method of the storage platform API, as described more fully below.","Each view explicitly defined in a storage platform schema (defined by the schema designer, and not automatically generated by the storage platform) is accessible by the named SQL view [<schema-name>].[View!<view-name>]. For example, a view named \u201cBookSales\u201d in the schema \u201cAcmePublisher.Books\u201d would be accessible using the name \u201c[AcmePublisher.Books].[View!BookSales]\u201d. Since the output format of a view is custom on a per-view basis (defined by an arbitrary query provided by the party defining the view), the columns are directly mapped based on the schema view definition.","All SQL search views in the storage platform data store use the following ordering convention for columns:\n\n","Members of each type family are searchable using a series of Item views, with there being one view per Item type in the data store.  is a diagram illustrating the concept of an Item search view.","a) Item","Each Item search view contains a row for each instance of an Item of the specific type or its subtypes. For example, the view for Document could return instances of Document, LegalDocument and ReviewDocument. Given this example, the Item views can be conceptualized as shown in .","Each instance of a storage platform data store defines a special Item view called the Master Item View. This view provides summary information on each Item in the data store. The view provides one column per Item type property, a column which described the type of the Item and several columns which are used to provide change tracking and synchronization information. The master item view is identified in a data store using the name \u201c[System.Storage]. [Master!Item]\u201d.",{"@attributes":{"id":"p-0266","num":"0331"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Column","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ItemId","ItemId","The storage platform identity"]},{"entry":[{},{},{},"of the Item"]},{"entry":[{},"_TypeId","TypeId","The TypeId of the Item - identifies"]},{"entry":[{},{},{},"the exact type of the Item and can"]},{"entry":[{},{},{},"be used to retrieve information on"]},{"entry":[{},{},{},"the type using a Metadata catalog."]},{"entry":[{},"_RootItemId","ItemId","The ItemId of the first"]},{"entry":[{},{},{},"non-embedded ancestor that controls"]},{"entry":[{},{},{},"the lifetime of this item."]},{"entry":[{},"<global",". . .","Global change tracking"]},{"entry":[{},"change",{},"information"]},{"entry":[{},"tracking>"]},{"entry":[{},"<Item","n\/a","One column per Item type"]},{"entry":[{},"props>",{},"property"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"Each Item type also has a search view. While similar to the root Item view, this view also provides access to the Item object via the \u201c_Item\u201d column. Each typed item search view is identified in a data store using the name [schemaName].[itemTypeName]. For example [AcmeCorp.Doc]. [OfficeDoc].",{"@attributes":{"id":"p-0268","num":"0333"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemId","The storage platform"]},{"entry":[{},{},"identity of the Item"]},{"entry":["<type change",". . .","Type change tracking"]},{"entry":["tracking>",{},"information"]},{"entry":["<parent props>","<property","One column per parent"]},{"entry":[{},"specific>","property"]},{"entry":["<item props>","<property","One column per exclusive"]},{"entry":[{},"specific>","property of this type"]},{"entry":["_Item","CLR type of Item","CLR object - type of"]},{"entry":[{},{},"declared Item"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"b) Item Extensions","All Item Extensions in a WinFS Store are also accessible using search views.","Each instance of a data store defines a special Extension view called the Master Extension View. This view provides summary information on each Extension in the data store. The view has a column per Extension property, a column which describes the type of the Extension and several columns which are used to provide change tracking and synchronization information. The master extension view is identified in a data store using the name \u201c[System.Storage]. [Master!Extension]\u201d.",{"@attributes":{"id":"p-0272","num":"0337"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemId","The storage platform identity"]},{"entry":[{},{},"of the Item with which"]},{"entry":[{},{},"this extension is associated"]},{"entry":["ExtensionId","ExtensionId","Id of this extension instance"]},{"entry":[{},"(GUID)"]},{"entry":["_TypeId","TypeId","The TypeId of the Extension -"]},{"entry":[{},{},"identifies the exact type of"]},{"entry":[{},{},"the extension and can be used"]},{"entry":[{},{},"to retrieve information on"]},{"entry":[{},{},"the extension using the"]},{"entry":[{},{},"Metadata catalog."]},{"entry":["<global change",". . .","Global change tracking"]},{"entry":["tracking>",{},"information"]},{"entry":["<ext properties>","<property","One column per Extension"]},{"entry":[{},"specific>","type property"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Each Extension type also has a search view. While similar to the master extension view, this view also provides access to the Item object via the _Extension column. Each typed extension search view is identified in a data store using the name [schemaName].[Extension!extensionTypeName]. For example [AcmeCorp.Doc]. [Extension!OfficeDocExt].",{"@attributes":{"id":"p-0274","num":"0339"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"105pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]},{"entry":[{},"Column","Type","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ItemId","ItemId","The storage platform identity"]},{"entry":[{},{},{},"of the Item with which this"]},{"entry":[{},{},{},"extension is associated"]},{"entry":[{},"ExtensionId","ExtensionId","Id of this extension instance"]},{"entry":[{},{},"(GUID)"]},{"entry":[{},"<type change",". . .","Type change tracking"]},{"entry":[{},"tracking>",{},"information"]},{"entry":[{},"<parent","<property","One column per parent"]},{"entry":[{},"props>","specific>","property"]},{"entry":[{},"<ext props>","<property","One column per exclusive"]},{"entry":[{},{},"specific>","property of this type"]},{"entry":[{},"_Extension","CLR type of","CLR object - type of"]},{"entry":[{},{},"Extension","declared Extension"]},{"entry":[{},{},"instance"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"c) Nested Elements","All nested elements are stored within Items, Extensions or Relationships instances. As such, they are accessed by querying the appropriate Item, Extension, or Relationship search view.","d) Relationships","As discussed above, Relationships form the fundamental unit of linking between Items in a storage platform data store.","Each data store provides a Master Relationship View. This view provides information on all relationship instances in the data store. The master relationship view is identified in a data store using the name \u201c[System.Storage].[Master!Relationship]\u201d.",{"@attributes":{"id":"p-0280","num":"0345"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemId","Identity of source"]},{"entry":[{},{},"endpoint (ItemId)"]},{"entry":["RelationshipId","RelationshipId","The id of the"]},{"entry":[{},"(GUID)","relationship instance"]},{"entry":["_RelTypeId","RelationshipTypeId","The RelTypeId of"]},{"entry":[{},{},"the Relationship -"]},{"entry":[{},{},"identifies the type"]},{"entry":[{},{},"of the relationship"]},{"entry":[{},{},"instance using the"]},{"entry":[{},{},"Metadata catalog."]},{"entry":["<global change",". . .","Global change"]},{"entry":["tracking>",{},"tracking information."]},{"entry":["TargetItemReference","ItemReference","Identity of target"]},{"entry":[{},{},"endpoint"]},{"entry":["_Relationship","Relationship","Instance of the"]},{"entry":[{},{},"Relationship object"]},{"entry":[{},{},"for this instance"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Each declared Relationship also has a search view which returns all instances of the particular relationship. While similar to the master relationship view, this view also provides named columns for each property of the relationship data. Each relationship instance search view is identified in a data store using the name [schemaName].[Relationship!relationshipName]. For example [AcmeCorp.Doc].[Relationship!DocumentAuthor].",{"@attributes":{"id":"p-0282","num":"0347"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemId","Identify of source"]},{"entry":[{},{},"endpoint (ItemId)"]},{"entry":["RelationshipId","RelationshipId","The id of the"]},{"entry":[{},"(GUID)","relationship"]},{"entry":[{},{},"instance"]},{"entry":["<type change",". . .","Type change"]},{"entry":["tracking>",{},"tracking information"]},{"entry":["TargetItemReference","ItemReference","Identity of target"]},{"entry":[{},{},"endpoint"]},{"entry":["<source name>","ItemId","Named property of"]},{"entry":[{},{},"source endpoint"]},{"entry":[{},{},"identity"]},{"entry":[{},{},"(alias for ItemId)"]},{"entry":["<target name>","ItemReference or","Named property of"]},{"entry":[{},"derived class","target endpoint"]},{"entry":[{},{},"identity"]},{"entry":[{},{},"(alias and cast for"]},{"entry":[{},{},"TargetItemReference)"]},{"entry":["<rel property>","<property","One column per"]},{"entry":[{},"specific>","property of the"]},{"entry":[{},{},"relationship definition"]},{"entry":["_Relationship","CLR type of","CLR object - type of"]},{"entry":[{},"Relationship","declare Relationship"]},{"entry":[{},"instance"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"e)","9. Updates","All views in the storage platform data store are read-only. In order to create a new instance of a data model element (item, extension or relationship), or to update an existing instance, the ProcessOperation or ProcessUpdategram methods of the storage platform API must be used. The ProcessOperation method is a single stored procedure defined by the data store which consumes an \u201coperation\u201d that details an action to be performed. The ProcessUpdategram method is a stored procedure which takes an ordered set of operations, known as an \u201cupdategram\u201d, which collectively detail a set of actions to be performed.","The operation format is extensible and provides various operations over the schema elements. Some common operations include:\n\n","10. Change Tracking & Tombstones","Change tracking and tombstone services are provided by the data store, as discussed more fully below. This section provides an outline of the change tracking information exposed in a data store.","a) Change Tracking","Each search view provided by the data store contains columns used to provide change tracking information; the columns are common across all Item, Extension and Relationship views. Storage platform Schema Views, defined explicitly by schema designers, do not automatically provide change tracking information\u2014such information is provided indirectly through the search views on which the view itself is built.","For each element in the data store, change tracking information is available from two places\u2014the \u201cmaster\u201d element view and the \u201ctyped\u201d element view. For example, change tracking information on the AcmeCorp.Document.Document Item type is available from the Master Item View \u201c[System.Storage].[Master!Item]\u201d and typed Item search view [AcmeCorp.Document]. [Document].","Change tracking information in the master search views provides information on the creation and update versions of an element, information on which sync partner created the element, which sync partner last updated the element and the version numbers from each partner for creation and update. Partners in sync relationships (described below) are identified by partner key. A single UDT object named_ChangeTrackinglnfo of type [System.Storage.Store].ChangeTrackingInfo contains all this information. The type is defined in the System.Storage schema._ChangeTrackinglnfo is available in all global search views for Item, Extension and Relationship. The type definition of ChangeTrackingInfo is:",{"@attributes":{"id":"p-0293","num":"0369"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"<Type Name=\u201cChangeTrackingInfo\u201d BaseType=\u201cBase.NestedElement\u201d>"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<FieldProperty Name=\u201cCreationLocalTS\u201d"]},{"entry":[{},"Type=\u201cSqlTypes.SqlInt64\u201d"]},{"entry":[{},"Nullable=\u201cFalse\u201d \/>"]},{"entry":[{},"<FieldProperty Name=\u201cCreatingPartnerKey\u201d"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Type=\u201cSqlTypes.SqlInt32\u201d","Nullable=\u201cFalse\u201d \/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<FieldProperty Name=\u201cCreatingPartnerTS\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Type=\u201cSqlTypes.SqlInt64\u201d","Nullable=\u201cFalse\u201d \/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<FieldProperty Name=\u201cLastUpdateLocalTS\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Type=\u201cSqlTypes.SqlInt64\u201d","Nullable=\u201cFalse\u201d \/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<FieldProperty Name=\u201cLastUpdatingPartnerKey\u201d"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Type=\u201cSqlTypes.SqlInt32\u201d","Nullable=\u201cFalse\u201d \/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<FieldProperty Name=\u201cLastUpdatingPartnerTS\u201d"]},{"entry":[{},"Type=\u201cSqlTypes.SqlInt64\u201d"]},{"entry":[{},"Nullable=\u201cFalse\u201d \/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<\/Type>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0294","num":"0370"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Column","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"_CreationLocalTS","Creation time stamp by the"]},{"entry":[{},{},"local machine"]},{"entry":[{},"_CreatingPartnerKey","PartnerKey of the partner who"]},{"entry":[{},{},"created this entity. If the entity"]},{"entry":[{},{},"was locally created, this is the"]},{"entry":[{},{},"local machine's PartnerKey."]},{"entry":[{},"_CreatingPartnerTS","Timestamp of the time at which"]},{"entry":[{},{},"this entity was created at the"]},{"entry":[{},{},"partner corresponding to"]},{"entry":[{},{},"_CreatingPartnerKey."]},{"entry":[{},"_LastUpdateLocalTS","Local timestamp corresponding"]},{"entry":[{},{},"to the update time"]},{"entry":[{},{},"at the local machine"]},{"entry":[{},"_LastUpdatingPartnerKey","PartnerKey of the partner who last"]},{"entry":[{},{},"updated this entity. If the last"]},{"entry":[{},{},"update to the entity was done"]},{"entry":[{},{},"locally, this is the local"]},{"entry":[{},{},"machine's PartnerKey."]},{"entry":[{},"_LastUpdatingPartnerTS","Timestamp of the time at which"]},{"entry":[{},{},"this entity was updated at the"]},{"entry":[{},{},"partner corresponding to"]},{"entry":[{},{},"_LastUpdatingPartnerKey."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In addition to providing the same information as the global search view, each typed search view provides additional information recording the sync state of each element in the sync topology.",{"@attributes":{"id":"p-0296","num":"0372"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["<global change",". . .","Information from global change"]},{"entry":["tracking>",{},"tracking"]},{"entry":["_ChangeUnitVersions","MultiSet<ChangeUnitVersion>","Description of version numbers"]},{"entry":[{},{},"of the change units within the"]},{"entry":[{},{},"particular element"]},{"entry":["_ElementSyncMetadata","ElementSyncMetadata","Additional version-independent"]},{"entry":[{},{},"metadata about this item that"]},{"entry":[{},{},"is only of interest to the"]},{"entry":[{},{},"Synchronization runtime."]},{"entry":["_VersionSyncMetadata","VersionSyncMetadata","Additional version-specific"]},{"entry":[{},{},"metadata about this version that"]},{"entry":[{},{},"is only of interest to the"]},{"entry":[{},{},"Synchronization runtime"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"b) Tombstones","The data store provides tombstone information for Items, Extensions and Relationships. The tombstone views provide information about both live and tombstoned entities (items, extensions and relationships) in one place. The item and extension tombstone views do not provide access to the corresponding object, while the relationship tombstone view provides access to the relationship object (the relationship object is NULL in the case of a tombstoned relationship).","Item tombstones are retrieved from the system via the view [System.Storage].[Tombstone!Item].",{"@attributes":{"id":"p-0300","num":"0376"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemId","ItemID","Identity of the Item"]},{"entry":["_TypeID","TypeId","Type of the Item"]},{"entry":["<Item properties>",". . .","Properties defined"]},{"entry":[{},{},"for all items"]},{"entry":["_RootItemId","ItemID","ItemID of the first"]},{"entry":[{},{},"non-embedding item"]},{"entry":[{},{},"which contains"]},{"entry":[{},{},"this item."]},{"entry":["_ChangeTrackingInfo","CLR instance of","Change tracking"]},{"entry":[{},"type","information for"]},{"entry":[{},"ChangeTrackingInfo","this item"]},{"entry":["_IsDeleted","BIT","This is a flag that"]},{"entry":[{},{},"is 0 for live items,"]},{"entry":[{},{},"and 1 for tombstoned"]},{"entry":[{},{},"items."]},{"entry":["_DeletionWallclock","UTCDATETIME","The UTC wall clock"]},{"entry":[{},{},"date time accord-"]},{"entry":[{},{},"ing to the partner"]},{"entry":[{},{},"which deleted the"]},{"entry":[{},{},"item. It is NULL if"]},{"entry":[{},{},"the Item is live."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Extension tombstones are retrieved from the system using the view [System.Storage].[Tombstone!Extension]. Extension change tracking information is similar to that provided for Items with the addition of the ExtensionID property.",{"@attributes":{"id":"p-0302","num":"0378"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemID","ItemID","Identity of the Item"]},{"entry":[{},{},"which owns the Extension"]},{"entry":["ExtensionId","ExtensionId","Extension Id of"]},{"entry":[{},{},"the Extension"]},{"entry":["_TypeID","TypeId","Type of the extension"]},{"entry":["_ChangeTrackingInfo","CLR instance of","Change tracking infor-"]},{"entry":[{},"type","mation for this extension"]},{"entry":[{},"ChangeTrackingInfo"]},{"entry":["_IsDeleted","BIT","This is a flag that is 0"]},{"entry":[{},{},"for live items, and 1 for"]},{"entry":[{},{},"tombstoned extensions."]},{"entry":["_DeletionWallclock","UTCDATETIME","The UTC wall clock date"]},{"entry":[{},{},"time according to the"]},{"entry":[{},{},"partner which deleted"]},{"entry":[{},{},"the extension. It is NULL"]},{"entry":[{},{},"if the extension is live."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Relationship tombstones are retrieved from the system via the view [System.Storage].[Tombstone!Relationship]. Relationships tombstone information is similar to that provided for Extensions. However, additional information is provided on the target ItemRef of the relationship instance. In addition, the relationship object is also selected.",{"@attributes":{"id":"p-0304","num":"0380"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Column","Type","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ItemID","ItemID","Identity of the Item"]},{"entry":[{},{},"which owned the rela-"]},{"entry":[{},{},"tionship (identity of"]},{"entry":[{},{},"relationship source"]},{"entry":[{},{},"endpoint)"]},{"entry":["RelationshipId","RelationshipId","RelationshipId"]},{"entry":[{},{},"of the relationship"]},{"entry":["_TypeID","TypeId","Type of the"]},{"entry":[{},{},"relationship"]},{"entry":["_ChangeTrackingInfo","CLR instance of","Change tracking"]},{"entry":[{},"type","information for"]},{"entry":[{},"ChangeTrackingInfo","this relationship"]},{"entry":["_IsDeleted","BIT","This is a flag that is 0"]},{"entry":[{},{},"for live items, and 1 for"]},{"entry":[{},{},"tombstoned extensions."]},{"entry":["_DeletionWallclock","UTCDATETIME","The UTC wall clock date"]},{"entry":[{},{},"time according to the"]},{"entry":[{},{},"partner which deleted"]},{"entry":[{},{},"the relationship."]},{"entry":[{},{},"It is NULL if the"]},{"entry":[{},{},"relationship is live."]},{"entry":["_Relationship","CLR instance of a","This is the relationship"]},{"entry":[{},"Relationship","object for live rela-"]},{"entry":[{},{},"tionship. It is NULL for"]},{"entry":[{},{},"tombstoned relationships."]},{"entry":["TargetItemReference","ItemReference","Identity of"]},{"entry":[{},{},"target endpoint"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"In order to prevent unbounded growth of tombstone information, the data store provides a tombstone cleanup task. This task determines when tombstone information may be discarded. The task computes a bound on the local create\/update version and then truncates the tombstone information by discarding all earlier tombstone versions.","11. Helper APIs and Functions","The Base mapping also provides a number of helper functions. These functions are supplied to aid common operations over the data model.","a) Function [System.Storage].GetItem",{"@attributes":{"id":"p-0309","num":"0385"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Returns an Item object given an ItemId"]},{"entry":[{},"\/\/"]},{"entry":[{},"Item GetItem (ItemId ItemId)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"b) Function [System.Storage].GetExtension",{"@attributes":{"id":"p-0311","num":"0387"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Returns an extension object given an ItemId and ExtensionId"]},{"entry":[{},"\/\/"]},{"entry":[{},"Extension GetExtension (ItemId ItemId, ExtensionId ExtensionId)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"c) Function [System.Storage].GetRelationship",{"@attributes":{"id":"p-0313","num":"0389"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Returns an relationship object given an ItemId and RelationshipId"},{"entry":"\/\/"},{"entry":"Relationship GetRelationship (ItemId ItemId, RelationshipId"},{"entry":"RelationshipId)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"12. Metadata","There are two types of metadata represented in the Store: instance metadata (the type of an Item, etc), and type metadata.","a) Schema Metadata","Schema metadata is stored in the data store as instances of Item types from the Meta schema.","b) Instance Metadata","Instance metadata is used by an application to query for the type of an Item and finds the extensions associated with an Item. Given the Itemld for an Item, an application can query the global item view to return the type of the Item and use this value to query the Meta.Type view to return information on the declared type of the Item. For example,",{"@attributes":{"id":"p-0320","num":"0396"},"tables":{"@attributes":{"id":"TABLE-US-00030","num":"00030"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Return metadata Item object for given Item instance"]},{"entry":[{},"\/\/"]},{"entry":[{},"SELECT m._Item AS metadataInfoObj"]},{"entry":[{},"FROM [System.Storage].[Item] i INNER JOIN"]},{"entry":[{},"[Meta].[Type] m ON i._TypeId = m.ItemId"]},{"entry":[{},"WHERE i.ItemId = @ItemId"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"E. Security","In general, all securable objects arrange their access rights using the access mask format shown in the . In this format, the low-order 16 bits are for object-specific access rights, the next 7 bits are for standard access rights, which apply to most types of objects, and the 4 high-order bits are used to specify generic access rights that each object type can map to a set of standard and object-specific rights. The ACCESS_SYSTEM_SECURITY bit corresponds to the right to access the object's SACL.","In the access mask structure of , item specific rights are placed in the Object Specific Rights section (low order 16-bits). Because in the present embodiment, the storage platform exposes two sets of APIs to administer security\u2014Win32 and the storage platform API, the file system object specific rights must be considered in order to motivate the design of the storage platform object specific rights.","The security model for the storage platform of the present invention is fully described in the related applications incorporated by reference earlier herein. In this regard,  (parts a, b, and c) depicts a new identically protected security region being carved out of an existing security region, in accordance with one embodiment of a security model.","F. Notifications and Change Tracking","According to another aspect of the present invention, the storage platform provides a notifications capability that allows applications to track data changes. This feature is primarily intended for applications which maintain volatile state or execute business logic on data change events. Applications register for notifications on items, item extensions and item relationships. Notifications are delivered asynchronously after data changes have been committed. Applications may filter notifications by item, extension and relationship type as well as type of operation.","According to one embodiment, the storage platform API  provides two kinds of interfaces for notifications. First, applications register for simple data change events triggered by changes to items, item extensions and item relationships. Second, applications create \u201cwatcher\u201d objects to monitor sets of items, item extensions and relationships between items. The state of a watcher object can be saved and re-created after a system failure or after a system has gone off-line for an extended period of time. A single notification may reflect multiple updates.","Additional details regarding this functionality can be found in the related applications incorporated by reference earlier herein.","G. Traditional File System Interoperability","As mentioned above, the storage platform of the present invention is, in at least some embodiments, intended to be embodied as an integral part of the hardware\/software interface system of a computer system. For example, the storage platform of the present invention may be embodied as an integral part of an operating system, such as the Microsoft Windows family of operating systems. In that capacity, the storage platform API becomes a part of the operating system APIs through which application programs interact with the operating system. Thus, the storage platform becomes the means through which application programs store information on the operating system, and the Item based data model of the storage platform therefore replaces the traditional files system of such an operating system. For example, as embodied in the Microsoft Windows family of operating systems, the storage platform might replace the NTFS file system implemented in that operating system. Presently, application programs access the services of the NTFS file system through the Win32 APIs exposed by the Windows family of operating systems.","Recognizing, however, that completely replacing the NTFS file system with the storage platform of the present invention would require recoding of existing Win32-based application programs and that such recoding may be undesirable, it would be beneficial for the storage platform of the present invention to provide some interoperability with existing file systems, such as NTFS. In one embodiment of the present invention, therefore, the storage platform enables application programs which rely on the Win32 programming model to access the contents of both the data store of the storage platform as well as the traditional NTFS file system. To this end, the storage platform uses a naming convention that is a superset of the Win32 naming conventions to facilitate easy interoperability. Further, the storage platform supports accessing files and directories stored in a storage platform volume through the Win32 API.","Additional details regarding this functionality can be found in the related applications incorporated by reference earlier herein.","H. Storage Platform API","The storage platform comprises an API that enables application programs to access the features and capabilities of the storage platform discussed above and to access items stored in the data store. This section describes one embodiment of a storage platform API of the storage platform of the present invention. Details regarding this functionality can be found in the related applications incorporated by reference earlier herein, with some of this information summarized below for convenience.","Referring to , a Containment Folder is an item which contains holding Relationships to other Items and is the equivalent of the common concept of a file system folder. Each Item is \u201ccontained\u201d within at least one containment folder.",{"@attributes":{"id":"p-0336","num":"0412"},"figref":"FIG. 19","b":["1900","302","1900","340","302","340","322","332","350","350","350","322"],"i":["a","b","c"]},{"@attributes":{"id":"p-0337","num":"0413"},"figref":"FIG. 20","b":["2002","2004","2006","2008"]},"The hierarchy of classes resulting from a given schema directly reflects the hierarchy of types in that schema. As an example, consider the Item types defined in the Contacts schema as shown in  and .",{"@attributes":{"id":"p-0339","num":"0415"},"figref":"FIG. 22","ul":{"@attributes":{"id":"ul0032","list-style":"none"},"li":{"@attributes":{"id":"ul0032-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0033","list-style":"none"},"li":["1. An application , , or binds to an item in the storage platform.","2. The framework  creates an ItemContext object  corresponding to the bound item and returns it to the application.","3. The application submits a Find on this ItemContext to get a collection of Items; the returned collection is conceptually an object graph  (due to relationships).","4. The application changes, deletes, and inserts data.","5. The application saves the changes by calling the Update( ) method."]}}}},{"@attributes":{"id":"p-0340","num":"0421"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0341","num":"0422"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0342","num":"0423"},"figref":["FIG. 25","FIG. 25"]},"In regard to APIs, a programming interface (or more simply, interface) may be viewed as any mechanism, process, protocol for enabling one or more segment(s) of code to communicate with or access the functionality provided by one or more other segment(s) of code. Alternatively, a programming interface may be viewed as one or more mechanism(s), method(s), function call(s), module(s), object(s), etc. of a component of a system capable of communicative coupling to one or more mechanism(s), method(s), function call(s), module(s), etc. of other component(s). The term \u201csegment of code\u201d in the preceding sentence is intended to include one or more instructions or lines of code, and includes, e.g., code modules, objects, subroutines, functions, and so on, regardless of the terminology applied or whether the code segments are separately compiled, or whether the code segments are provided as source, intermediate, or object code, whether the code segments are utilized in a runtime system or process, or whether they are located on the same or different machines or distributed across multiple machines, or whether the functionality represented by the segments of code are implemented wholly in software, wholly in hardware, or a combination of hardware and software.","Notionally, a programming interface may be viewed generically, as shown in  or .  illustrates an interface Interfacel as a conduit through which first and second code segments communicate.  illustrates an interface as comprising interface objects I and I (which may or may not be part of the first and second code segments), which enable first and second code segments of a system to communicate via medium M. In the view of , one may consider interface objects I and I as separate interfaces of the same system and one may also consider that objects I and I plus medium M comprise the interface. Although  show bi-directional flow and interfaces on each side of the flow, certain implementations may only have information flow in one direction (or no information flow as described below) or may only have an interface object on one side. By way of example, and not limitation, terms such as application programming interface (API), entry point, method, function, subroutine, remote procedure call, and component object model (COM) interface, are encompassed within the definition of programming interface.","Aspects of such a programming interface may include the method whereby the first code segment transmits information (where \u201cinformation\u201d is used in its broadest sense and includes data, commands, requests, etc.) to the second code segment; the method whereby the second code segment receives the information; and the structure, sequence, syntax, organization, schema, timing and content of the information. In this regard, the underlying transport medium itself may be unimportant to the operation of the interface, whether the medium be wired or wireless, or a combination of both, as long as the information is transported in the manner defined by the interface. In certain situations, information may not be passed in one or both directions in the conventional sense, as the information transfer may be either via another mechanism (e.g. information placed in a buffer, file, etc. separate from information flow between the code segments) or non-existent, as when one code segment simply accesses functionality performed by a second code segment. Any or all of these aspects may be important in a given situation, e.g., depending on whether the code segments are part of a system in a loosely coupled or tightly coupled configuration, and so this list should be considered illustrative and non-limiting.","This notion of a programming interface is known to those skilled in the art and is clear from the foregoing detailed description of the invention. There are, however, other ways to implement a programming interface, and, unless expressly excluded, these too are intended to be encompassed by the claims set forth at the end of this specification. Such other ways may appear to be more sophisticated or complex than the simplistic view of , but they nonetheless perform a similar function to accomplish the same overall result. We will now briefly describe some illustrative alternative implementations of a programming interface.","Factoring: A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in . As shown, some interfaces can be described in terms of divisible sets of functionality. Thus, the interface functionality of  may be factored to achieve the same result, just as one may mathematically provide 24, or 2 times 2 time 3 times 2. Accordingly, as illustrated in , the function provided by interface Interfacel may be subdivided to convert the communications of the interface into multiple interfaces InterfaceA, Interface B, Interface C, etc. while achieving the same result. As illustrated in , the function provided by interface I may be subdivided into multiple interfaces I, I, I, etc. while achieving the same result. Similarly, interface I of the second code segment which receives information from the first code segment may be factored into multiple interfaces I, I, I, etc. When factoring, the number of interfaces included with the 1st code segment need not match the number of interfaces included with the 2nd code segment. In either of the cases of , the functional spirit of interfaces Interface and I remain the same as with , respectively. The factoring of interfaces may also follow associative, commutative, and other mathematical properties such that the factoring may be difficult to recognize. For instance, ordering of operations may be unimportant, and consequently, a function carried out by an interface may be carried out well in advance of reaching the interface, by another piece of code or interface, or performed by a separate component of the system. Moreover, one of ordinary skill in the programming arts can appreciate that there are a variety of ways of making different function calls that achieve the same result.","Redefinition: In some cases, it may be possible to ignore, add or redefine certain aspects (e.g., parameters) of a programming interface while still accomplishing the intended result. This is illustrated in . For example, assume interface Interfacel of  includes a function call Square(input, precision, output), a call that includes three parameters, input, precision and output, and which is issued from the 1st Code Segment to the 2nd Code Segment. If the middle parameter precision is of no concern in a given scenario, as shown in , it could just as well be ignored or even replaced with a meaningless (in this situation) parameter. One may also add an additional parameter of no concern. In either event, the functionality of square can be achieved, so long as output is returned after input is squared by the second code segment. Precision may very well be a meaningful parameter to some downstream or other portion of the computing system; however, once it is recognized that precision is not necessary for the narrow purpose of calculating the square, it may be replaced or ignored. For example, instead of passing a valid precision value, a meaningless value such as a birth date could be passed without adversely affecting the result. Similarly, as shown in , interface I is replaced by interface I\u2032, redefined to ignore or add parameters to the interface. Interface I may similarly be redefined as interface I\u2032, redefined to ignore unnecessary parameters, or parameters that may be processed elsewhere. The point here is that in some cases a programming interface may include aspects, such as parameters, that are not needed for some purpose, and so they may be ignored or redefined, or processed elsewhere for other purposes.","Inline Coding: It may also be feasible to merge some or all of the functionality of two separate code modules such that the \u201cinterface\u201d between them changes form. For example, the functionality of  may be converted to the functionality of  and 33B, respectively. In , the previous 1st and 2nd Code Segments of  are merged into a module containing both of them. In this case, the code segments may still be communicating with each other but the interface may be adapted to a form which is more suitable to the single module. Thus, for example, formal Call and Return statements may no longer be necessary, but similar processing or response(s) pursuant to interface Interfacel may still be in effect. Similarly, shown in , part (or all) of interface I from  may be written inline into interface I to form interface I\u2033. As illustrated, interface I is divided into Iand I, and interface portion Ihas been coded in-line with interface I to form interface I\u2033. For a concrete example, consider that the interface I from  performs a function call square (input, output), which is received by interface I, which after processing the value passed with input (to square it) by the second code segment, passes back the squared result with output. In such a case, the processing performed by the second code segment (squaring input) can be performed by the first code segment without a call to the interface.","Divorce: A communication from one code segment to another may be accomplished indirectly by breaking the communication into multiple discrete communications. This is depicted schematically in . As shown in , one or more piece(s) of middleware (Divorce Interface(s), since they divorce functionality and\/or interface functions from the original interface) are provided to convert the communications on the first interface, Interface, to conform them to a different interface, in this case interfaces InterfaceA, InterfaceB and InterfaceC. This might be done, e.g., where there is an installed base of applications designed to communicate with, say, an operating system in accordance with an Interfacel protocol, but then the operating system is changed to use a different interface, in this case interfaces InterfaceA, InterfaceB and InterfaceC. The point is that the original interface used by the 2nd Code Segment is changed such that it is no longer compatible with the interface used by the 1st Code Segment, and so an intermediary is used to make the old and new interfaces compatible. Similarly, as shown in , a third code segment can be introduced with divorce interface DI to receive the communications from interface I and with divorce interface DI to transmit the interface functionality to, for example, interfaces Iand I, redesigned to work with DI, but to provide the same functional result. Similarly, DI and DI may work together to translate the functionality of interfaces I and I of  to a new operating system, while providing the same or similar functional result.","Rewriting: Yet another possible variant is to dynamically rewrite the code to replace the interface functionality with something else but which achieves the same overall result. For example, there may be a system in which a code segment presented in an intermediate language (e.g. Microsoft IL, Java ByteCode, etc.) is provided to a Just-in-Time (JIT) compiler or interpreter in an execution environment (such as that provided by the Net framework, the Java runtime environment, or other similar runtime type environments). The JIT compiler may be written so as to dynamically convert the communications from the 1st Code Segment to the 2nd Code Segment, i.e., to conform them to a different interface as may be required by the 2nd Code Segment (either the original or a different 2nd Code Segment). This is depicted in . As can be seen in , this approach is similar to the Divorce scenario described above. It might be done, e.g., where an installed base of applications are designed to communicate with an operating system in accordance with an Interface  protocol, but then the operating system is changed to use a different interface. The JIT Compiler could be used to conform the communications on the fly from the installed-base applications to the new interface of the operating system. As depicted in , this approach of dynamically rewriting the interface(s) may be applied to dynamically factor, or otherwise alter the interface(s) as well.","It should also be noted that the above-described scenarios for achieving the same or similar result as an interface via alternative embodiments may also be combined in various ways, serially and\/or in parallel, or with other intervening code. Thus, the alternative embodiments presented above are not mutually exclusive and may be mixed, matched and combined to produce the same or equivalent scenarios to the generic scenarios presented in . It is also noted that, as with most programming constructs, there are other similar ways of achieving the same or similar functionality of an interface which may not be described herein, but nonetheless are represented by the spirit and scope of the invention, i.e., it is noted that it is at least partly the functionality represented by, and the advantageous results enabled by, an interface that underlie the value of an interface.","III. Synchronization API","Several approaches to synchronization are possible in an Item-based hardware\/software interface system. Section A discloses several embodiments of the present invention, while Section B focuses on various embodiments of an API for synchronization.","A. Synchronization Overview","For several embodiments of the present invention, and in regard to , the storage platform provides a synchronization service  that (i) allows multiple instances of the storage platform (each with its own data store ) to synchronize parts of their content according to a flexible set of rules, and (ii) provides an infrastructure for third parties to synchronize the data store of the storage platform of the present invention with other data sources that implement proprietary protocols.","Storage-platform-to-storage-platform synchronization occurs among a group of participating \u201creplicas.\u201d For example, with reference to , it may be desirable to provide synchronization between the data store  of the storage platform  with another remote data store  under the control of another instance of the storage platform, perhaps running on a different computer system. The total membership of this group is not necessarily known to any given replica at any given time.","Different replicas can make the changes independently (i.e., concurrently). The process of synchronization is defined as making every replica aware of the changes made by other replicas. This synchronization capability is inherently multi-master.","The synchronization capability of the present invention allows replicas to:\n\n","1. Storage-Platform-to-Storage-Platform Synchronization","The primary application of the synchronization service  of the storage platform of the present invention is to synchronize multiple instances of the storage platform (each with its own data store). The synchronization service operates at the level of the storage platform schemas (rather than the underlying tables of the database engine ). Thus, for example, \u201cScopes\u201d are used to define synchronization sets as discussed below.","The synchronization service operates on the principle of \u201cnet changes\u201d. Rather than recording and sending individual operations (such as with transactional replication), the synchronization service sends the end-result of those operations, thus often consolidating the results of multiple operations into a single resulting change.","The synchronization service does not in general respect transaction boundaries. In other words, if two changes are made to a storage platform data store in a single transaction, there is no guarantee that these changes are applied at all other replicas atomically\u2014one may show up without the other. The exception to this principle is that if two changes are made to the same Item in the same transaction, then these changes are guaranteed to be sent and applied to other replicas atomically. Thus, Items are the consistency units of the synchronization service.","a) Synchronization (Sync) Controlling Applications","Any application can connect to the synchronization service and initiate a sync operation. Such an application provides all of the parameters needed to perform synchronization (see sync profile below). Such applications are referred to herein as Sync Controlling Applications (SCAs).","When synchronizing two storage platform instances, sync is initiated on one side by an SCA. That SCA informs the local synchronization service to synchronize with the remote partner. On the other side, the synchronization service is awoken by the messages sent by the synchronization service from the originating machine. It responds based on the persistent configuration information (see mappings below) present on the destination machine. The synchronization service can be run on schedule or in response to events. In these cases, the synchronization service implementing the schedule becomes the SCA.","To enable synchronization, two steps need to be taken. First, the schema designer must annotate the storage platform schema with appropriate sync semantics (designating Change Units as described below). Second, synchronization must be properly configured on all of the machines having an instance of the storage platform that is to participate in the synchronization (as described below).","b) Schema Annotation","A fundamental concept of the synchronization service is that of a Change Unit. A Change Unit is a smallest piece of schema that is individually tracked by the storage platform. For every Change Unit, the synchronization service may be able to determine whether it changed or did not change since the last sync.","Designating Change Units in the schema serves several purposes. First, it determines how chatty the synchronization service is on the wire. When a change is made inside a Change Unit, the entire Change Unit is sent to the other replicas, since the synchronization service does not know which part of the Change Unit was changed. Second, it determines the granularity of conflict detection. When two concurrent changes (these terms are defined in detail in subsequent sections) are made to the same Change Unit, the synchronization service raises a conflict; on the other hand, if concurrent changes are made to different Change Units, then no conflict is raised and the changes are automatically merged. Third, it strongly affects the amount of metadata kept by the system. Much of the synchronization service metadata is kept per-Change Unit; thus, making Change Units smaller increases the overhead of sync.","Defining Change Units requires finding the right trade-offs. For that reason, the synchronization service allows schema designers to participate in the process.","In one embodiment, the synchronization service does not support Change Units that are larger than an element. However, it does support the ability for schema designers to specify smaller Change Units than an element\u2014namely, grouping multiple attributes of an element into a separate Change Unit. In that embodiment, this is accomplished using the following syntax:",{"@attributes":{"id":"p-0372","num":"0460"},"tables":{"@attributes":{"id":"TABLE-US-00031","num":"00031"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"<Type Name=\u2033Appointment\u2033 MajorVersion=\u20331\u2033 MinorVersion=\u20330\u2033"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ExtendsType=\u2033Base.Item\u2033","Extends Version=\u20331\u2033>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Field Name=\u2033MeetingStatus\u201c Type=\u2033the storage"]},{"entry":[{},"platformTypes.uniqueidentifier"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Nullable=\u2033False\u2033\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Field Name=\u2033OrganizerName\u201c Type=\u2033the storage"]},{"entry":[{},"platformTypes.nvarchar(512)\u2033"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Nullable=\u2033False\u2033\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Field Name=\u2033OrganizerEmail\u201c Type=\u2033the storage"]},{"entry":[{},"platformTypes.nvarchar(512)\u2033"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"TypeMajorVersion=\u20331\u201c","MultiValued=\u2033True\u2033\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"..."]},{"entry":[{},"<ChangeUnit Name=\u201dCU_Status\u201d>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<Field Name=\u201dMeetingStatus\u201d\/>"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/ChangeUnit>"]},{"entry":[{},"<ChangeUnit Name=\u201dCU_Organizer\u201d\/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<Field Name=\u201dOrganizerName\u201d \/>"]},{"entry":[{},"<Field Name=\u201dOrganizerEmail\u201d \/>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"<\/ChangeUnit>"]},{"entry":[{},"..."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"<\/Type>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"c) Sync Configuration","A group of storage platform partners that wish to keep certain parts of their data in sync are referred to as a sync community. While the members of the community want to stay in sync, they do not necessarily represent the data in exactly the same way; in other words, sync partners may transform the data they are synchronizing.","In a peer-to-peer scenario, it is impractical for peers to maintain transformation mappings for all of their partners. Instead, the synchronization service takes the approach of defining \u201cCommunity Folders\u201d. A community folder is an abstraction that represents a hypothetical \u201cshared folder\u201d that all community members are synchronizing with.","This notion is best illustrated by an example. If Joe wants to keep My Documents folders of his several computers in sync, Joe defines a community folder called, say, JoesDocuments. Then, on every computer, Joe configures a mapping between the hypothetical JoesDocuments folder and the local My Documents folder. From this point on, when Joe's computers synchronize with each other, they talk in terms of documents in JoesDocuments, rather than their local items. This way, all Joe's computers understand each other without having to know who the others are\u2014the Community Folder becomes the lingua franca of the sync community.","Configuring the synchronization service consists of three steps: (1) defining mappings between local folders and community folders; (2) defining sync profiles that determine what gets synchronized (e.g. whom to sync with and which subsets should be sent and which received); and (3) defining the schedules on which different sync profiles should run, or running them manually.","Community Folder mappings are stored as XML configuration files on individual machines. Each mapping has the following schema:","\/mappings\/communityFolder","This element names the community folder that this mapping is for. The name follows the syntax rules of Folders.","\/mappings\/localFolder","This element names the local folder that the mapping transforms into. The name follows the syntax rules of Folders. The folder must already exist for the mapping to be valid. The items within this folder are considered for synchronization per this mapping.","\/mappings\/transformations","This element defines how to transform items from the community folder to the local folder and back. If absent or empty, no transformations are performed. In particular, this means that no IDs are mapped. This configuration is primarily useful for creating a cache of a Folder.","\/mappings\/transformations\/mapIDs","This element requests that newly generated local IDs be assigned to all of the items mapped from the community folder, rather than reusing community IDs. The Sync Runtime will maintain ID mappings to convert items back and forth.","\/mappings\/transformations\/localRoot","This element requests that all root items in the community folder be made children of the specified root.","\/mappings\/runAs","This element controls under whose authority requests against this mapping are processed. If absent, sender is assumed.","\/mappings\/runAs\/sender","The presence of this element indicates that the sender of messages to this mapping must be impersonated, and requests processed under his credentials.","A Sync Profile is a total set of parameters needed to kick off synchronization. It is supplied by an SCA to the Sync Runtime to initiate sync. Sync profiles for storage platform-to-storage platform synchronization contain the following information:\n\n","The synchronization service provides a runtime CLR class that allows simple building of Sync Profiles. Profiles can also be serialized to and from XML files for easy storage (often alongside schedules). However, there is no standard place in the storage platform where all the profiles are stored; SCAs are welcome to construct a profile on the spot without ever persisting it. Note that there is no need to have a local mapping to initiate sync. All sync information can be specified in the profile. The mapping is, however, required in order to respond to sync requests initiated by the remote side.","In one embodiment, the synchronization service does not provide its own scheduling infrastructure. Instead, it relies on another component to peform this task\u2014the Windows Scheduler available with the Microsoft Windows operating system. The synchronization service includes a command-line utility that acts as an SCA and triggers synchronization based on a sync profile saved in an XML file. This utility makes it very easy to configure the Windows Scheduler to run synchronization either on schedule, or in response to events such as user logon or logoff.","d) Conflict Handling","Conflict handling in the synchronization service is divided into three stages: (1) conflict detection, which occurs at change application time\u2014this step determines if a change can be safely applied; (2) automatic conflict resolution and logging\u2014during this step (that takes place immediately after the conflict is detected) automatic conflict resolvers are consulted to see if the conflict can be resolved\u2014if not, the conflict can be optionally logged; and (3) conflict inspection and resolution\u2014this step takes place if some conflicts have been logged, and occurs outside of the context of the sync session\u2014at this time, logged conflicts can be resolved and removed from the log.","In the present embodiment, the synchronization service detects two types of conflicts: knowledge-based and constraint-based.","A knowledge-based conflict occurs when two replicas make independent changes to the same Change Unit. Two changes are called independent if they are made without knowledge of each other\u2014in other words, the version of the first is not covered by the knowledge of the second and vice versa. The synchronization service automatically detects all such conflicts based on the replicas' knowledge as described above.","It is sometimes helpful to think of conflicts as forks in the version history of a Change Unit. If no conflicts occur in the life of a Change Unit, its version history is a simple chain\u2014each change occurring after the previous one. In the case of a knowledge-based conflict, two changes occur in parallel, causing the chain to split and become a version tree.","There are cases where independent changes violate an integrity constraint when applied together. For instance, two replicas creating a file with the same name in the same directory could cause such a conflict to occur.","A constraint-based conflict involves two independent changes (just like a knowledge-based one), but they do not affect the same Change Unit. Rather, they affect different Change Units but with a constraint existing between them.","The synchronization service detects constraint violations at change application time and raises constraint-based conflicts automatically. Resolving constraint-based conflicts usually requires custom code that modifies the changes in such as way as to not violate the constraint; The synchronization service does not provide a general-purpose mechanism for doing so.","When a conflict is detected, the synchronization service can take one of three actions (selected by the sync initiator in the Sync Profile): (1) reject the change, returning it back to sender; (2) log a conflict into a conflict log; or (3) resolve the conflict automatically.","If the change is rejected, the synchronization service acts as if the change did not arrive at the replica. A negative acknowledgement is sent back to the originator. This resolution policy is primarily useful on head-less replicas (such as file servers) where logging conflicts is not feasible. Instead, such replicas force the others to deal with the conflicts by rejecting them.","Sync initiators configure conflict resolution in their Sync Profiles. The synchronization service supports combining multiple conflict resolvers in a single profile in the following ways\u2014first, by specifying a list of conflict resolvers to be tried one after another, until one of them succeeds; and second, by associating conflict resolvers with conflict types, e.g. directing update-update knowledge-based conflicts to one resolver, but all the other conflicts to the log.","The synchronization service provides a number of default conflict resolvers. This list includes:\n\n","In addition, ISVs can implement and install their own conflict resolvers. Custom conflict resolvers may accept configuration parameters; such parameters must be specified by the SCA in the Conflict Resolution section of the Sync Profile.","When a conflict resolver handles a conflict, it returns the list of operations that need to be performed (in lieu of the conflicting change) back to the runtime. The synchronization service then applies these operations, having properly adjusted remote knowledge to include what the conflict handler has considered.","It is possible that another conflict is detected while applying the resolution. In such a case, the new conflict must be resolved before the original processing resumes.","When thinking of conflicts as branches in the version history of an item, conflict resolutions can be viewed as joins\u2014combining two branches to form a single point. Thus, conflict resolutions turn version histories into DAGs.","A very particular kind of a conflict resolver is the Conflict Logger. The synchronization service logs conflicts as Items of type ConflictRecord. These records are related back to the items that are in conflict (unless the items themselves have been deleted). Each conflict record contains: the incoming change that caused the conflict; the type of the conflict: update-update, update-delete, delete-update, insert-insert, or constraint; and the version of the incoming change and the knowledge of the replica sending it. Logged conflicts are available for inspection and resolution as described below.","The synchronization service provides an API for applications to examine the conflict log and to suggest resolutions of the conflicts in it. The API allows application to enumerate all conflicts, or conflicts related to a given Item. It also allows such applications to resolve logged conflicts in one of three ways: (1) remote wins\u2014accepting the logged change and overwriting the conflicting local change; (2) local wins\u2014ignoring conflicting parts of the logged change; and (3) suggest new change\u2014where the application proposes a merge that, in its opinion, resolves the conflict. Once conflicts are resolved by an application, the synchronization service removes them from the log.","In complex synchronization scenarios, the same conflict can be detected at multiple replicas. If this occurs, several things can happen: (1) the conflict can be resolved on one replica, and the resolution be sent to the other; (2) the conflict is resolved on both replicas automatically; or (3) the conflict is resolved on both replicas manually (through the conflict inspection API).","To ensure convergence, the synchronization service forwards conflict resolutions to other replicas. When a change that resolves a conflict arrives at a replica, the synchronization service automatically finds any conflict records in the log that are resolved by this update and eliminates them. In this sense, a conflict resolution at one replica is binding on all the other replicas.","If different winners are chosen by different replicas for the same conflict, the synchronization service applies the principle of binding conflict resolution and picks one of the two resolutions to win over the other automatically. The winner is picked in a deterministic fashion that is guaranteed to produce the same results at all times (one embodiment uses replica ID lexicographic comparisons).","If different \u201cnew changes\u201d are suggested by different replicas for the same conflict, the synchronization service treats this new conflict as a special conflict and uses the Conflict Logger to prevent it from propagating to other replicas. Such situation commonly arises with manual conflict resolution.","2. Synchronizing to Non-Storage Platform Data Stores","According to another aspect of the storage platform of the present invention, the storage platform provides an architecture for ISVs to implement Sync Adapters that allow the storage platform to synchronize to legacy systems such as Microsoft Exchange, AD, Hotmail, etc. Sync Adapters benefit from the many Sync Service provided by the synchronization service, as described below.","Despite the name, Sync Adapters do not need to be implemented as plug-ins into some storage platform architecture. If desired, a \u201csync adapter\u201d can simply be any application that utilizes the synchronization service runtime interfaces to obtain services such as change enumeration and application.","In order to make it simpler for others to configure and run synchronization to a given backend, Sync Adapter writers are encouraged to expose the standard Sync Adapter interface, which runs sync given the Sync Profile as described above. The profile provides configuration information to the adapter, some of which adapters pass to the Sync Runtime to control runtime services (e.g. the Folder to synchronize).","a) Sync Services","The synchronization service provides a number of sync services to adapter writers. For the rest of this section, it is convenient to refer to the machine on which the storage platform is doing synchronization as the \u201cclient\u201d and the non-storage platform backend that the adapter is talking to as the \u201cserver\u201d.","Based on the change-tracking data maintained by the synchronization service, Change Enumeration allows sync adapters to easily enumerate the changes that have occurred to a data store Folder since the last time synchronization with this partner was attempted.","Changes are enumerated based on the concept of an \u201canchor\u201d \u2014an opaque structure that represents information about the last synchronization. The anchor takes the form of the storage platform Knowledge, as described in the proceeding sections. Sync adapters utilizing change enumeration services fall into two broad categories: those using \u201cstored anchors\u201d vs. those using \u201csupplied anchors\u201d.","The distinction is based on where the information about the last sync is stored\u2014on the client, or on the server. It is often easier for adapters to store this information on the Client\u2014the backend is often not capable of conveniently storing this information. On the other hand, if multiple clients synchronize to the same backend, storing this information on the client is inefficient and in some cases incorrect\u2014it makes one client unaware of the changes that the other client has already pushed up to the server. If an adapter wants to use a server-stored anchor, the adapter needs to supply it back to the storage platform at the time of change enumeration.","In order for the storage platform to maintain the anchor (either for local or remote storage), the storage platform needs to be made aware of the changes that were successfully applied at the server. These and only these changes can be included in the anchor. During change enumeration, Sync Adapters use an Acknowledgement interface to report which changes were successfully applied. At the end of synchronization, adapters using supplied anchors must read the new anchor (which incorporates all of the successfully-applied changes) and send it to their backend.","Often, Adapters need to store adapter-specific data along with the items they insert into the storage platform data store. Common examples of such data are remote IDs and remote versions (timestamps). The synchronization service provides a mechanism for storing this data, and Change Enumeration provides a mechanism to receive this extra data along with the changes being returned. This eliminates the need for adapters to re-query the database in most cases.","Change Application allows Sync Adapters to apply changes received from their backend to the local storage platform. Adapters are expected to transform the changes to the storage platform schema.  illustrates the process by which storage platform API classes are generated from the storage platform Schema.","The primary function of change application is to automatically detect conflicts. As in the case of Storage Platform-to-Storage Platform sync, a conflict is defined as two overlapping changes being made without knowledge of each other. When adapters use Change Application, they must specify the anchor with respect to which conflict detection is performed. Change Application raises a conflict if an overlapping local change that is not covered by the adapter's knowledge is detected. Similar to Change Enumeration, adapters may use either stored or supplied anchors. Change Application supports efficient storage of adapter-specific metadata. Such data may be attached by the adapter to the changes being applied, and might be stored by the synchronization service. The data might be returned on next change enumeration.","The Conflict Resolution mechanisms described above (logging and automatic resolution options) are available to sync adapters as well. Sync adapters may specify the policy for conflict resolution when applying changes. If specified, conflicts may be passed on to the specified conflict handler and resolved (if possible). Conflicts can also be logged. It is possible that the adapter may detect a conflict when attempting to apply a local change to the backend. In such a case, the adapter may still pass the conflict on to the Sync Runtime to be resolved according to policy. In addition, Sync Adapters may request that any conflicts detected by the synchronization service be sent back to them for processing. This is particularly convenient in the case where the backend is capable of storing or resolving conflicts.","b) Adapter Implementation","While some \u201cadapters\u201d are simply applications utilizing runtime interfaces, adapters are encouraged to implement the standard adapter interfaces. These interfaces allow Sync Controlling Applications to: request that the adapter perform synchronization according to a given Sync Profile; cancel on-going synchronization; and receive progress reporting (percentage complete) on an ongoing sync.","3. Security","The synchronization service strives to introduce as little as possible into the security model implemented by the storage platform. Rather than defining new rights for synchronization, existing rights are used. Specifically,\n\n","The synchronization service does not maintain secure authorship information. When a change is made at replica A by user U and forwarded to replica B, the fact that the change was originally made at A (or by U) is lost. If B forwards this change to replica C, this is done under B's authority, not that of A. This leads to the following limitation: if a replica is not trusted to make its own changes to an item, it cannot forward changes made by others.","When the synchronization service is initiated, it is done by a Sync Controlling Application. The synchronization service impersonates the identity of the SCA and performs all operations (both locally and remotely) under that identity. To illustrate, observe that user U cannot cause the local synchronization service to retrieve changes from a remote storage platform for items that user U does not have read access.","4. Manageability","Monitoring a distributed community of replicas is a complex problem. The synchronization service may use a \u201csweep\u201d algorithm to collect and distribute information about the status of the replicas. The properties of the sweep algorithm ensure that information about all configured replicas is eventually collected and that failing (non-responsive) replicas are detected.","This community-wide monitoring information is made available at every replica. Monitoring tools can be run at an arbitrarily-chosen replica to examine this monitoring information and make administrative decisions. Any configuration changes must be made directly at the affected replicas.","B. Synchronization API Overview","In an increasingly distributed, digital world, individuals and workgroups often store information and data in a variety of different devices and locations. This has fueled the development of data synchronization services that can keep the information in these separate, often disparate, data stores synchronized at all times, with minimal user intervention.","The synchronization platform of the present invention, which is part of the rich storage platform described in Section II herein (a.k.a., \u201cWinFS\u201d), addresses three main objectives:\n\n","1. General Terminology","Herein below are some further refined definitions and key concepts relevant to later discussions herein this Section III.B:","Sync Replica: Most applications are only interested in tracking, enumerating and synchronizing changes for a given subset of items within the WinFS store. The set of items that take part in a synchronization operation is termed as a Synchronization Replica. A Replica is defined in terms of items contained within a given WinFS containment hierarchy (usually rooted at a Folder item). All synchronization services are carried out within the context of a given replica. WinFS Sync provides a mechanism to define, manage and cleanup replicas. Every replica has a GulID identifier that uniquely identifies it within a given WinFS store.","Sync Partner: A sync partner is defined as an entity capable of affecting changes on WinFS items, extensions and relationships. Thus, every WinFS store can be termed as a sync partner. When synchronizing with a non-WinFS store, the external data source (EDS) is also termed as a sync partner. Every partner has a GUID identifier that uniquely identifies it.","Sync Community: A synchronization community is defined as a collection of replicas that are kept in sync by means of peer-to-peer synchronization operations. These replicas may all be in the same WinFS store, different WinFS stores, or even manifest themselves as virtual replicas on non-WinFS stores. WinFS sync does not prescribe or mandate any specific topology for the community, especially if the only sync operations in the community are through the WinFS Sync service (WinFS adapter). Synchronization adapters (defined below) may introduce their own topology restrictions.","Change Tracking, Change Units and Versions: Every WinFS store tracks changes to all local WinFS Items, Extensions and Relationships. Changes are tracked at the level of change unit granularity defined in the schema. The top-level fields of any Item, Extension and Relationship type can be sub-divided by the schema designer into change units, with the smallest granularity being one top-level field. For change tracking purposes, every change unit is assigned a Version, where a version is a pair of sync partner id and a version number (the version number is a partner-specific monotonically increasing number). Versions are updated as changes happen in the store locally or as they are obtained from other replicas.","Sync Knowledge: Knowledge represents the state of a given sync replica at any time, i.e. it encapsulates meta-data about all the changes a given replica is aware of, either local or from other replicas. WinFS sync maintains and updates knowledge for sync replicas across sync operations. Important thing to note is that the Knowledge representation allows it to be interpreted with respect to the entire community and not just relative to the particular replica where the Knowledge is stored.","Sync Adapters: A synchronization adapter is a managed code application that accesses WinFS Sync services through the Sync Runtime API and enables synchronization of WinFS data to a non-WinFS data store. Depending on the requirements of the scenario, it's upto the adapter developer as to which subset of WinFS data and what WinFS data types to synchronize. The adapter is responsible for communication with the EDS, transforming WinFS schemas to and from EDS supported schemas and defining and managing its own configuration and metadata. Adapters are strongly encouraged to implement the WinFS Sync Adapter API to take advantage of the common configuration and control infrastructure for adapters provided by the WinFS Sync team. For more details, please refer to the WinFS Sync Adapter API spec [SADP] and the WinFS Sync Controller API [SCTRL] spec.","For adapters that synchronize WinFS data to external non-WinFS stores and cannot produce or maintain knowledge in WinFS format, WinFS Sync provides services to obtain remote knowledge that can be used for subsequent change enumeration or application operations. Depending on the capabilities of the backend store, the adapter may wish to store this remote knowledge on the backend or on the local WinFS store.","For simplicity, a synchronization \u201creplica\u201d is a structure that represents a set of data in a \u201cWinFS\u201d store that exists in a single logical location, whereas data on a non-\u201cWinFS\u201d store is called a \u201cdata source\u201d and generally requires the use of a adapter.","Remote Knowledge: When a given sync replica wishes to obtain changes from another replica it provides it's own knowledge as a baseline against which the other replica enumerates changes. Similarly, when a given replica wishes to send changes to another replica, it provides it's own knowledge as a baseline which can be used by the remote replica for detecting conflicts. This knowledge about the other replica that's provided during sync change enumeration and application is termed a Remote Knowledge.","2. Synchronization API Principals","For certain embodiments, the synchronization API separates into two parts: the synchronization configuration API and the synchronization controller API. The synchronization Configuration API enables applications to configure synchronization and to specify parameters for a particular synchronization session between two replicas. For a given synchronization session, configuration parameters include the set of Items to be synchronized, the type of synchronization (one-way or two-way), information about the remote data source, and the conflict resolution policy. The synchronization controller API initiates a synchronization session, cancels synchronization, and receives progress and error information about the on-going synchronization. Moreover, for specific embodiments where synchronization needs to be performed on a pre-determined schedule, such systems may include scheduling mechanism to customize scheduling.","Several embodiments of the present invention employ synchronization adapters for synchronizing information between \u201cWinFS\u201d and non-\u201cWinFS\u201d data sources. Examples of adapters include an adapter that synchronizes address book information between a \u201cWinFS\u201d contacts folder and a non-WinFS mailbox. In these instances, adapter developers might use the \u201cWinFS\u201d synchronization core services API described herein for accessing services provided by the \u201cWinFS\u201d synchronization platform in order to develop schema transformation code between the \u201cWinFS\u201d schema and the non-\u201cWinFS\u201d data source schema. Additionally, the adapter developer provides protocol support for communicating changes with the non-\u201cWinFS\u201d data source. A synchronization adapter is invoked and controlled by using the synchronization controller API and reports progress and errors using this API.","However, for certain embodiments of the present invention, when synchronizing \u201cWinFS\u201d data store with another \u201cWinFS\u201d data store, a synchronization adapter may be unnecessary if \u201cWinFS\u201d to \u201cWinFS\u201d synchronization services are integrated within the hardware\/software interface system. In any event, several such embodiments provides a set of synchronization services for both \u201cWinFS\u201d to \u201cWinFS\u201d and synchronization adapter solutions that include:\n\n","Referring to , which illustrates a three instances of a common data store and the components for synchronizing them. A first system  has a WinFS data store  comprising a WinFS-to-WinFS Sync services  and Core Sync Services , for WinFS-to-nonWinFS synchronization, which exposes  a Sync API  for utilization. Similar to the first system , a second system  has a WinFS data store  comprising a WinFS-to-WinFS Sync services  and Core Sync Services , for WinFS-to-nonWinFS synchronization, which exposes  a Sync API  for utilization. The first system  and the second system  synchronize  via their respective WinFS-to-WinFS Sync services  and . A third system , which is not a WinFS system, has an application for using WinFS Sync  to maintain a data source in a sync community with WinFS replicas. This application can utilize either a WinFS Sync Config\/Control service  to directly interface with the WinFS data store  via the WinFS to WinFS synch services  (if it is so capable of virtualizing itself as a WinFS data store) or via a Sync Adapter  that interfaces  with the Sync API .","As illustrated in this figure, the first system  is aware of and directly synchronizes with both the second system  and third system . However, neither the second system  nor the third system  are aware of each other and, thus, do not synchronize their changes directly with each other but, instead, changes that occur on one system must propogate through the first system .","C. Synchronization API Services","Several embodiments of the present invention are directed to synchronization services comprising two foundational services: change enumeration and change application.","1. Change Enumeration","As previously discussed earlier herein, Change Enumeration allows sync adapters to easily enumerate the changes that have occurred to a data store Folder since the last time synchronization with this partner was attempted based on the change-tracking data maintained by the synchronization service. In regard to change enumeration, several embodiments of the present invention are directed to:\n\n","2. Change Application","As discussed earlier herein, change application allows Sync Adapters to apply changes received from their backend to the local storage platform since the adapters are expected to transform the changes to the storage platform schema. In regard to change application, several embodiments of the present invention are directed to:\n\n","3. Sample Code","The following is a code sample for how a FOO Sync adapter might interact with Sync Runtime (where all adapter specific functions are prefixed with FOO):",{"@attributes":{"id":"p-0462","num":"0584"},"tables":{"@attributes":{"id":"TABLE-US-00032","num":"00032"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"ItemContext ctx = new ItemContext"},{"entry":"( \u201c\\.\\System\\UserData\\dshah\\My Contacts\u201d,"},{"entry":"true );"},{"entry":"\/\/ Get the replica item id and remote partner id from the profile."},{"entry":"\/\/ Most adapters would get this information from the sync profile"},{"entry":"Guid replicaItemId = FOO_GetReplicaId( );"},{"entry":"Guid remotePartnerId = FOO_Get_RemotePartnerId( );"},{"entry":"\/\/"},{"entry":"\/\/ Lookup stored knowledge in the store using storedKnowledgeId"},{"entry":"like above."},{"entry":"\/\/"},{"entry":"ReplicaKnowledge remoteKnowledge = ...;"},{"entry":"\/\/"},{"entry":"\/\/ Initialize ReplicaSynchronizer"},{"entry":"\/\/"},{"entry":"ctx.ReplicaSynchronizer = new ReplicaSynchronizer( replicaItemId,"},{"entry":"remotePartnerId );"},{"entry":"ctx.ReplicaSynchronizer.RemoteKnowledge = remoteKnowledge;"},{"entry":"ChangeReader reader = ctx.ReplicaSynchronizer.GetChangeReader( );"},{"entry":"\/\/"},{"entry":"\/\/ Enumerate changes and process them"},{"entry":"\/\/"},{"entry":"bool bChangesToRead = true;"},{"entry":"while ( bChangesToRead )"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ChangeCollection<object> changes = null;"]},{"entry":[{},"bChangesToRead = reader.ReadChanges( 10, out changes );"]},{"entry":[{},"foreach (object change in changes)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Process enumerated object, adapter does it's own"]},{"entry":[{},"schema transform"]},{"entry":[{},"\/\/ and ID mapping. It may even retrieve additional"]},{"entry":[{},"objects from the"]},{"entry":[{},"\/\/ Ctx for this purpose and modify adapter metadata"]},{"entry":[{},"after change"]},{"entry":[{},"\/\/ has been applied to remote store"]},{"entry":[{},"ChangeStatus status ="]},{"entry":[{},"FOOProcessAndApplyToRemoteStore(change);"]},{"entry":[{},"\/\/ Update learned knowledge with status"]},{"entry":[{},"reader.AcknowledgeChange ( changeStatus );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"}"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"remoteKnowledge ="},{"entry":"ctx.ReplicaSynchronizer.GetUpdatedRemoteKnowledge( );"},{"entry":"reader.Close( );"},{"entry":"\/\/"},{"entry":"\/\/ Save updated knowledge and adapter metadata, if any"},{"entry":"\/\/"},{"entry":"ctx.Update( );"},{"entry":"\/\/"},{"entry":"\/\/ Sample for change application, first initialize remote knowledge"},{"entry":"using"},{"entry":"\/\/ storedKnowledgeId as before."},{"entry":"\/\/"},{"entry":"remoteKnowledge = ...;"},{"entry":"ctx.ReplicaSynchronizer.ConflictPolicy = conflictPolicy;"},{"entry":"ctx.ReplicaSynchronizer.RemotePartnerId = remotePartnerId;"},{"entry":"ctx.ReplicaSynchronizer.RemoteKnowledge = remoteKnowledge;"},{"entry":"ctx.ReplicaSynchronizer.ChangeStatusEvent +="},{"entry":"FOO_OnChangeStatusEvent;"},{"entry":"\/\/"},{"entry":"\/\/ Obtain changes from remote store. Adapter is responsible for"},{"entry":"retrieving"},{"entry":"\/\/ it's backend specific metadata from the store. This can be an"},{"entry":"extension"},{"entry":"\/\/ on the replica."},{"entry":"\/\/"},{"entry":"object remoteAnchor = FOO_GetRemoteAnchorFromStore( );"},{"entry":"FOO_RemoteChangeCollection remoteChanges ="},{"entry":"FOO_GetRemoteChanges("},{"entry":"remoteAnchor );"},{"entry":"\/\/"},{"entry":"\/\/ Fill in the change collection"},{"entry":"\/\/"},{"entry":"foreach( FOO_RemoteChange change in remoteChanges )"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\/\/ Adapter responsible for doing ID mapping"]},{"entry":[{},"Guid localId = FOO_MapRemoteId ( change );"]},{"entry":[{},"\/\/ Let's say we're syncing Person objects"]},{"entry":[{},"ItemSearcher searcher = Person.GetSearcher( ctx );"]},{"entry":[{},"searcher.Filters.Add( \u201cPersonId=@localId\u201d );"]},{"entry":[{},"searcher.Parameters[\u201cPersonId\u201d] = localId;"]},{"entry":[{},"Person person = searcher.FindOne( );"]},{"entry":[{},"\/\/"]},{"entry":[{},"\/\/ Adapter transforms remote changes to modifications on"]},{"entry":[{},"Person object"]},{"entry":[{},"\/\/ As part of this adapter may even make changes to"]},{"entry":[{},"item-level backend-"]},{"entry":[{},"\/\/ specific metadata for the remote object."]},{"entry":[{},"\/\/"]},{"entry":[{},"FOO_TransformRemoteToLocal ( remoteChange, person );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":"ctx.Update( );"},{"entry":"\/\/"},{"entry":"\/\/ Save the new remote anchor (this can be an extension on"},{"entry":"the replica)"},{"entry":"\/\/"},{"entry":"FOO_SaveRemoteAnchor( );"},{"entry":"\/\/"},{"entry":"\/\/ This is a regular WinFS API save since remote knowledge"},{"entry":"is not synced."},{"entry":"\/\/"},{"entry":"remoteKnowledge ="},{"entry":"ctx.ReplicaSynchronizer.GetUpdatedRemoteKnowledge( );"},{"entry":"ctx.Update( );"},{"entry":"ctx.Close( );"},{"entry":"\/\/"},{"entry":"\/\/ Adapter callback for processing application status callbacks"},{"entry":"\/\/"},{"entry":"void FOO_OnEntitySaved( object sender, ChangeStatusEventArgs"},{"entry":"args )"},{"entry":"{"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"remoteAnchor.AcceptChange( args.ChangeStatus );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"4. Methods of API Synchronization","In one embodiment of the present invention, synchronization between a WinFS store and a non-WinFS store is accomplished is possible via the Synchronization APIs exposed by the WinFS-based hardware\/software interface system.","In one embodiment, all synchronization adapters are required to implement the synchronization adapter API, a common language runtime (CLR) managed API, so that they can be consistently deployed, initialized, and controlled. The adapter API provides:\n\n","There are two potential process models for adapters, depending on the requirements of the scenario. The adapter can execute in the same process space as the application invoking it or in a separate process all by itself. To execute in its own separate process, the adapter defines its own factory class, which is used to instantiate the adapter. The factory can return an instance of the adapter in the same process as the invoking application, or return a remote instance of the adapter in a different Microsoft common language runtime application domain or process. A default factory implementation is provided which instantiates the adapter in the same process. In practice, many adapters will run in the same process as the invoking application. The out of process model is usually required for one or both of the following reasons:\n\n","Referring to , one embodiment of the present invention presumes a simple adapter that is unaware of how state is calculated or it associated metadata is exchanged. In this embodiment, synchronization is achieved by the replica, in regard to the data source with which it wants to synchronize, by first, at step , determining which changes have occurred since it last synchronized with said data source, and the replica then transmits the incremental changes that have occurred since this last synchronization based on its present state information, and this present state information and incremental changes are to the data source via the adapter. At step , the adapter, upon receiving the change data from the replica in the previous step, implements as many changes to the data source as possible, tracks which changes are successful and which fail, and transmits the success-and-failure info back to WinFS (of the replica). The hardware\/software interface system of the replica (WinFS), at step , upon receiving the success-and-failure info from the replica, then calculates the new state information for the data source, stores this information for future use by its replica, and transmits this new state info back to the data source, that is, to the adapter for storage and subsequent use by the adapter.","D. Additional Aspects of the SYNC Schema","The following are additional (or more specific) aspects of the synchronization schema for various embodiments of the present invention.\n\n","As the foregoing illustrates, the present invention is directed to a storage platform for organizing, searching, and sharing data. The storage platform of the present invention extends and broadens the concept of data storage beyond existing file systems and database systems, and is designed to be the store for all types of data, including structured, non-structured, or semi-structured data, such as relational (tabular) data, XML, and a new form of data called Items. Through its common storage foundation and schematized data, the storage platform of the present invention enables more efficient application development for consumers, knowledge workers and enterprises. It offers a rich and extensible application programming interface that not only makes available the capabilities inherent in its data model, but also embraces and extends existing file system and database access methods. It is understood that changes may be made to the embodiments described above without departing from the broad inventive concepts thereof. Accordingly, the present invention is not limited to the particular embodiments disclosed, but is intended to cover all modifications that are within the spirit and scope of the invention as defined by the appended claims.","As is apparent from the above, all or portions of the various systems, methods, and aspects of the present invention may be embodied in the form of program code (i.e., instructions). This program code may be stored on a computer-readable medium, such as a magnetic, electrical, or optical storage medium, including without limitation a floppy diskette, CD-ROM, CD-RW, DVD-ROM, DVD-RAM, magnetic tape, flash memory, hard disk drive, or any other machine-readable storage medium, wherein, when the program code is loaded into and executed by a machine, such as a computer or server, the machine becomes an apparatus for practicing the invention. The present invention may also be embodied in the form of program code that is transmitted over some transmission medium, such as over electrical wiring or cabling, through fiber optics, over a network, including the Internet or an intranet, or via any other form of transmission, wherein, when the program code is received and loaded into and executed by a machine, such as a computer, the machine becomes an apparatus for practicing the invention. When implemented on a general-purpose processor, the program code combines with the processor to provide a unique apparatus that operates analogously to specific logic circuits."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing summary, as well as the following detailed description of the invention, is better understood when read in conjunction with the appended drawings. For the purpose of illustrating the invention, there is shown in the drawings exemplary embodiments of various aspects of the invention; however, the invention is not limited to the specific methods and instrumentalities disclosed. In the drawings:",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 5A"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 5B","FIG. 5A"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 5C"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 6B","FIG. 6A"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 21A"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 21B","FIG. 21A"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 28"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 29"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 30A"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 30B","b":["1","2"]},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 31A","b":["1","1","1"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 31B","b":["1","1","1","1"],"i":["a","b","c; "]},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 32A"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 32B"},{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 33A"},{"@attributes":{"id":"p-0066","num":"0065"},"figref":"FIG. 33B"},{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 34A"},{"@attributes":{"id":"p-0068","num":"0067"},"figref":"FIG. 34B"},{"@attributes":{"id":"p-0069","num":"0068"},"figref":"FIG. 35A"},{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 35B"},{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 36"},{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 37"}]},"DETDESC":[{},{}]}
