---
title: Instrument-based distributed computing systems
abstract: An instrument-based distributed computing system is disclosed that accelerates the measurement, analysis, verification and validation of data in a distributed computing environment. A large computing work can be performed in a distributed fashion using the instrument-based distributed system. The instrument-based distributed system may include a client that creates a job. The job may include one or more tasks. The client may distribute a portion of the job to one or more remote workers on a network. The client may reside in an instrument. One or more workers may also reside in instruments. The workers execute the received portion of the job and may return execution results to the client. As such, the present invention allows the use of instrument-based distributed system on a network to conduct the job and facilitate decreasing the time for executing the job.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07908313&OS=07908313&RS=07908313
owner: The MathWorks, Inc.
number: 07908313
owner_city: Natick
owner_country: US
publication_date: 20051212
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND INFORMATION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention generally relates to a distributed computing environment and more particularly to methods, systems and mediums for providing an instrument-based distributed computing system that accelerates the measurement, analysis, verification and validation of data in the distributed computing environment.","MATLAB\u00ae is a product of The MathWorks, Inc. of Natick, Mass., which provides engineers, scientists, mathematicians, and educators across a diverse range of industries with an environment for technical computing applications. MATLAB\u00ae is an intuitive high performance language and technical computing environment that provides mathematical and graphical tools for mathematical computation, data analysis, visualization and algorithm development. MATLAB\u00ae integrates numerical analysis, matrix computation, signal processing, and graphics in an easy-to-use environment where problems and solutions are expressed in familiar mathematical notation, without traditional programming. MATLAB\u00ae is used to solve complex engineering and scientific problems by developing mathematical models that simulate the problem. A model is prototyped, tested and analyzed by running the model under multiple boundary conditions, data parameters, or just a number of initial guesses. In MATLAB\u00ae, one can easily modify the model, plot a new variable or reformulate the problem in a rapid interactive fashion that is typically not feasible in a non-interpreted programming such as Fortran or C.","As a desktop application, MATLAB\u00ae allows scientists and engineers to interactively perform complex analysis and modeling in their familiar workstation environment. With many engineering and scientific problems requiring larger and more complex modeling, computations accordingly become more resource intensive and time-consuming. However, a single workstation can be limiting to the size of the problem that can be solved, because of the relationship of the computing power of the workstation to the computing power necessary to execute computing intensive iterative processing of complex problems in a reasonable time. For example, a simulation of a large complex aircraft model may take a reasonable time to run with a single computation with a specified set of parameters. However, the analysis of the problem may also require the model be computed multiple times with a different set of parameters, e.g., at one-hundred different altitude levels and fifty different aircraft weights, to understand the behavior of the model under varied conditions. This would require five-thousand computations to analyze the problem as desired and the single computer would take an unreasonable or undesirable amount of time to perform these simulations. Therefore, it is desirable to perform a computation in a distributed manner when the computation becomes so large and complex that it cannot be completed in a reasonable amount of time on a single computer. In particular, since some instruments are provided on a PC-based platform and have capacities to run additional software, it is also desirable to use the instruments for performing a large computation in a distributed manner.","The present invention provides an instrument-based distributed computing system that accelerates the measurement, analysis, verification and validation of data in a distributed computing environment. In the present invention, a large computational job can be performed in a distributed fashion using the instrument-based distributed system. The instrument-based distributed system may include a client that creates a job. The job may include one or more tasks. The client may distribute a portion of the job to one or more remote workers for the distributed execution of the job. The client may reside in an instrument. The workers may also reside in instruments. The workers execute the received portion of the job and may return execution results to the client. As such, the present invention allows the use of instrument-based distributed system on a network to conduct the job and facilitate decreasing the time for executing the job.","In one aspect of the present invention, a method is provided for executing a job in a distributed fashion. The method includes the step of installing a computing client for providing a computing environment in an instrument. The method also includes the step of enabling the client to generate a job in the computing environment, wherein the job includes one or more tasks. The method further includes the step of distributing the job to remote computing workers for the distributed execution of the job.","In another aspect of the present invention, a method is provided for executing a job in a distributed fashion. The method includes the step of installing a computing worker for providing a computing environment in the instrument. The method also includes the step of receiving a portion of a job generated by a remote client, wherein the job includes one or more tasks. The method further includes the steps of enabling the computing worker to execute the received portion of the job, and returning execution result to the remote client.","In another aspect of the present invention, a system is provided for executing a job in a distributed fashion in a computing environment. The system includes a first instrument for generating a job, wherein the job includes one or more tasks. The system also includes a second instrument for receiving a portion of the job and executing the received portion of the job to obtain execution results, wherein the second instrument returns the execution results to the first instrument.","In another aspect of the present invention, a medium holding instructions executable in an instrument is provided for a method of executing a job in a distributed fashion. The method includes the step of installing a computing client for providing a computing environment in the instrument. The method also includes the step of enabling the client to generate a job in the computing environment, wherein the job includes one or more tasks. The method further includes the step of distributing the job to remote computing workers for the distributed execution of the job.","In another aspect of the present invention, a medium holding instructions executable in an instrument is provided for a method of executing a job in a distributed fashion. The method includes the step of installing a computing worker for providing a computing environment in the instrument. The method also includes the step of receiving a portion of a job generated by a remote client, wherein the job includes one or more tasks. The method further includes the steps of enabling the computing worker to execute the received portion of the job, and returning execution result to the remote client.","The details of various embodiments of the invention are set forth in the accompanying drawings and the description below. Other features and advantages of the invention will become apparent from the description, the drawings and the claims.","Certain embodiments of the present invention are described below. It is, however, expressly noted that the present invention is not limited to these embodiments, but rather the intention is that additions and modifications to what is expressly described herein also are included within the scope of the invention. Moreover, it is to be understood that the features of the various embodiments described herein are not mutually exclusive and can exist in various combinations and permutations, even if such combinations or permutations are not made express herein, without departing from the spirit and scope of the invention.","The illustrative embodiment of the present invention provides a distributed computing environment that enables a user to execute a job in a distributed fashion. In particular, the illustrative embodiment of the present invention provides an instrument-based distributed computing system that uses the one or more instruments for the distributed execution of the job. The instrument-based distributed computing system may include a client for creating the job. The client may distribute a portion of the job to one or more remote workers for the distributed execution of the job. The client may reside in an instrument. The workers may also reside in instruments. The remote workers execute a portion of the job and return the execution results to the client. The instruments running the workers may have the capability to accelerate the execution of the job. For example, the instrument may include hardware components, such as FPGA, ASIC, DSP and CPU, to perform fast calculations, such as FFT calculations. As such, the illustrative embodiment of the present invention executes the job in a distributed fashion using the instrument-based distributed computing system. The illustrative embodiment of the present invention utilizes a technical computing client and a technical computing worker for the distributed execution of the job, which will be described below in more detail.","A. Technical Computing Client and Technical Computing Worker","The illustrative embodiment of the present invention provides for the dynamic distribution of technical computing tasks from a technical computing client to remote technical computing workers for execution of the tasks on multiple computers systems. Tasks can be declared on a technical computing client and additionally organized into jobs. A job is a logical unit of activities, or tasks that are processed and\/or managed collectively. A task defines a technical computing command, such as a MATLAB\u00ae command, to be executed, and the number of arguments and any input data to the arguments. A job is a group of one or more tasks. The task can be directly distributed by the technical computing client to one or more technical computing workers. A technical computing worker performs technical computing on a task and may return a result to the technical computing client.","Additionally, a task or a group of tasks, in a job, can be submitted to an automatic task distribution mechanism to distribute the one or more tasks automatically to one or more technical computing workers providing technical computing services. The technical computing client does not need to specify or have knowledge of the technical computing workers in order for the task to be distributed to and computed by a technical computing worker. The automatic task distribution mechanism can distribute tasks to technical computing workers that are anonymous to any technical computing clients. The technical computing workers perform the task and may return as a result the output data generated from the execution of the task. The result may be returned to the automatic task distribution mechanism, which, in turn, may provide the result to the technical computing client.","Furthermore, the illustrative embodiment provides for an object-oriented interface in a technical computing environment to dynamically distribute tasks or jobs directly or indirectly, via the automatic task distribution mechanism, to one or more technical computing workers. The object-oriented interface provides a programming interface for a technical computing client to distribute tasks for processing by technical computer workers.","The illustrative embodiment will be described solely for illustrative purposes relative to a MATLAB\u00ae-based distributed technical computing environment. Although the illustrative embodiment will be described relative to a MATLAB\u00ae-based application, one of ordinary skill in the art will appreciate that the present invention may be applied to distributing the processing of technical computing tasks with other technical computing environments, such as technical computing environments using software products of LabVIEW\u00ae or MATRIXx from National Instruments, Inc., or Mathematica\u00ae from Wolfram Research, Inc., or Mathcad of Mathsoft Engineering & Education Inc., or Maple\u2122 from Maplesoft, a division of Waterloo Maple Inc.","The illustrative embodiment of the present invention provides for conducting a test in a distributed fashion tasks from a technical computing client to remote technical computing workers for execution of the tasks on multiple computers systems. Tasks can be declared on a technical computing client and additionally organized into jobs. A job is a logical unit of activities, or tasks that are processed and\/or managed collectively. A task defines a technical computing command, such as a MATLAB\u00ae command, to be executed, and the number of arguments and any input data to the arguments. A job is a group of one or more tasks. The task can be directly distributed by the technical computing client to one or more technical computing workers. A technical computing worker performs technical computing on a task and may return a result to the technical computing client.","Additionally, a task or a group of tasks, in a job, can be submitted to an automatic task distribution mechanism to distribute the one or more tasks automatically to one or more technical computing workers providing technical computing services. The technical computing client does not need to specify or have knowledge of the technical computing workers in order for the task to be distributed to and computed by a technical computing worker. The automatic task distribution mechanism can distribute tasks to technical computing workers that are anonymous to any technical computing clients. The technical computing workers perform the task and may return as a result the output data generated from the execution of the task. The result may be returned to the automatic task distribution mechanism, which, in turn, may provide the result to the technical computing client.","Furthermore, the illustrative embodiment provides for an object-oriented interface in a technical computing environment to dynamically distribute tasks or jobs directly or indirectly, via the automatic task distribution mechanism, to one or more technical computing workers. The object-oriented interface provides a programming interface for a technical computing client to distribute tasks for processing by technical computer workers.",{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 1A","b":["102","106","104","106","106","106","102","114","102","110","112","110","112","114","102","102","116","120","102","108","120","120"]},"Additionally, the computing device  may include a network interface  to interface to a Local Area Network (LAN), Wide Area Network (WAN) or the Internet through a variety of connections including, but not limited to, standard telephone lines, LAN or WAN links (e.g., 802.11, T1, T3, 56 kb, X.25), broadband connections (e.g., ISDN, Frame Relay, ATM), wireless connections, or some combination of any or all of the above. The network interface  may comprise a built-in network adapter, network interface card, PCMCIA network card, card bus network adapter, wireless network adapter, USB network adapter, modem or any other device suitable for interfacing the computing device  to any type of network capable of communication and performing the operations described herein. Moreover, the computing device  may be any computer system such as a workstation, desktop computer, server, laptop, handheld computer or other form of computing or telecommunications device that is capable of communication and that has sufficient processor power and memory capacity to perform the operations described herein.",{"@attributes":{"id":"p-0052","num":"0051"},"figref":["FIG. 1A","FIG. 1B"],"b":["120","102","120","102","102","102","100","100","150","102","130","160","102","140","130","102","140","150","160","170","130","140","140","150","160","170","102","102","102"]},"In one embodiment, each of the client , server  and workstation  are configured to and capable of running at least a portion of the present invention of the MATLAB\u00ae-based distributed computing application . As a distributed software application, the MATLAB\u00ae-based distributed computing application has one or more software components that run on each of the client , server  and workstation , respectively, and work in communication and in collaboration with each other to meet the functionality of the overall application. For example, the client  may hold a graphical modeling environment that is capable of specifying block diagram models and technical computing tasks to analyze the model. The client  may have software components configured to and capable of submitting the tasks to the server . The server  may have software components configured to and capable of receiving the tasks submitted by the client  and for determining a workstation  to assign the task for technical computing. The workstation  may hold software components capable of providing a technical computing environment to perform technical computing of the tasks assigned from the server  and submitted by the client . In summary, the technical computing environment and software components of the MATLAB\u00ae-based distributed computing application  may be deployed across one or more different computing devices in various network topologies and configurations.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 2A","b":["120","200","120","250","150","270","170","250","270","130","140"]},"The technical computing client  can be a technical computing software application that provides a technical computing and graphical modeling environment for generating block diagram models and to define mathematical algorithms for simulating models. The technical computing client  can be a MATLAB\u00ae-based client, which may include all or a portion of the functionality provided by the standalone desktop application of MATLAB\u00ae. Additionally, the technical computing client  can be any of the software programs available in the MATLAB\u00ae product family. Furthermore, the technical computing client  can be a custom software program or other software that accesses MATLAB\u00ae functionality via an interface, such as an application programming interface, or by other means. One ordinarily skilled in the art will appreciate the various combinations of client types that may access the functionality of the system.","With an application programming interface and\/or programming language of the technical computing client , functions can be defined representing a technical computing task to be executed by either a technical computing environment local to the client computer , or remote on the workstation . The local technical computing environment may be part of the technical computing client , or a technical computing worker running on the client computer . The programming language includes mechanisms, described below in more detail, to define a task to be distributed to a technical computing environment and to communicate the task to the technical computing worker  on the workstation , or alternatively, on the client . For example, the technical computing client  may declare a function to generate a random set of ten numbers and further delegate that the technical computing worker  running on the workstation  execute the function. Also, the application programming interface and programming language of the MATLAB\u00ae-based client  includes mechanisms, described in more detail below, to receive a result from the execution of technical computing of the task from another technical computing environment. For example, the technical computing client  may declare a variable to hold a result returned from the technical computing worker  performing technical computing of the random generation function.","The distributed functionality features of the programming languages of the MATLAB\u00ae-based client  allows the technical computing client  to use the computing resources that may be available from a technical computing worker  on the workstation  to perform technical computing of the task. This frees up the technical computing client  to perform other tasks, or the client computer  to execute other software applications.","The technical computing worker  of the system  can be a technical computing software application that provides a technical computing environment for performing technical computing of tasks, such as those tasks defined or created by the technical computing client . The technical computing worker  can be a MATLAB\u00ae-based worker application, module, service, software component, or a session, which includes support for technical computing of functions defined in the programming language of MATLAB\u00ae. A session is an instance of a running technical computing worker  by which a technical computing client can connect and access its functionality. The technical computing worker  can include all the functionality and software components of the technical computing client , or it can just include those software components it may need to perform technical computing of tasks it receives for execution. The technical computing worker  may be configured to and capable of running any of the modules, libraries or software components of the MATLAB\u00ae product family. As such, the technical computing worker  may have all or a portion of the software components of MATLAB\u00ae installed on the workstation , or alternatively, accessible on another system in the network . The technical computing worker  has mechanisms, described in detail later, to receive a task distributed from the technical computing client . The technical computing worker  is capable of performing technical computing of the task as if the technical computing client  was performing the technical computing in its own technical computing environment. The technical computing worker  also has mechanisms, to return a result generated by the technical computing of the task to the technical computing client .","The technical computing worker  can be available on an as needed basis to the technical computing client . When not performing technical computing of tasks from the technical computing client , the workstation  of the technical computing worker  can be executing other software programs, or the technical computing worker  can perform technical computing of tasks from other technical computing clients.",{"@attributes":{"id":"p-0060","num":"0059"},"figref":["FIG. 2B","FIG. 2B"],"b":["205","250","150","130","160","140","160","260","265","265","260","160","260","130","140","270","170"]},"The automatic task distribution mechanism  comprises one or more application software components to provide for the automatic distribution of tasks from the technical computing client  to the technical computing worker . The automatic task distribution mechanism  allows the technical computing client  to delegate the management of task distribution to the automatic task distribution mechanism . For example, with the programming language of MATLAB\u00ae, a task can be defined and submitted to the automatic task distribution mechanism  without specifying which technical computing worker  is to perform the technical computing of the task. The technical computing client  does not need to know the specifics of the technical computing worker . The technical computing client can define a function to submit the task to the automatic task distribution mechanism , and get a result of the task from the automatic task distribution mechanism . As such, the automatic task distribution mechanism provides a level of indirection between the technical computing client  and the technical computing worker .","This eases the distributed programming and integration burden on the technical computing client . The technical computing client  does not need to have prior knowledge of the availability of the technical computing worker . For multiple task submissions from the technical computing client , the automatic task distribution mechanism  can manage and handle the delegations of the tasks to the same technical computing worker , or to other technical computing workers and hold the results of the tasks on behalf of the technical computing client  for retrieval after the completion of technical computing of all the distributed tasks.","As part of the software components of the MATLAB\u00ae-based distributed computing environment, a job manager module , or \u201cjob manager\u201d, is included as an interface to the task and result management functionality of the automatic task distribution mechanism . The job manager  can comprise an object-oriented interface to provide control of delegating tasks and obtaining results in the multi-tiered distributed system . The job manager  provides a level of programming and integration abstraction above the details of inter-process communications and workflow between the automatic task distribution mechanism  and the technical computing worker . The job manager  also provides an interface for managing a group of tasks collectively as a single unit called a job, and on behalf of a technical computing client , submitting those tasks making up the job, and obtaining the results of each of the tasks until the job is completed. Alternatively, the automatic task distribution mechanism  can include the functionality and object-oriented interface of the job manager , or the automatic task distribution mechanism  and the job manager  can be combined into a single application, or software component. In an exemplary embodiment, the job manager  comprises both the functionality of the job manager  and the automatic task distribution mechanism . One ordinarily skilled in the art will recognize the functions and operations of the job manager  and the automatic task distribution mechanism  can be combined in various software components, applications and interfaces.","Referring now to , an exemplary embodiment of the present invention is shown with multiple technical computing workers A-N hosted on a plurality of workstations A-N. The technical computing client  may be in communication through the network communication channel  on the network  with one, some or all of the technical computing workers A-N. In a similar manner, the automatic task distribution mechanism  may be in communication through the network communication channel  on the network  with one, some or all of the technical computing workers A-N. As such, the technical computing client  and\/or the automatic task distribution mechanism  can distribute tasks to multiple technical computing workers A-N to scale the distributed system and increase computation time of tasks. As also shown in , the technical computing workers A-B can be hosted on the same workstation A, or a single technical computing worker C can have a dedicated workstation B. Alternatively, one or more of the technical computing workers A-N can be hosted on either the client  or the server .","The computing devices (, \u2032, \u2033, \u2032\u2033) depicted in  can be running any operating system such as any of the versions of the Microsoft\u00ae Windows operating systems, the different releases of the Unix and Linux operating systems, any version of the MacOS\u00ae for Macintosh computers, any embedded operating system, any real-time operating system, any open source operating system, any proprietary operating system, any operating systems for mobile computing devices, or any other operating system capable of running on the computing device and performing the operations described herein. Furthermore, the software components of MATLAB\u00ae-based distributed computing environment can be capable of and configured to operate on the operating system that may be running on any of the computing device (e.g., , \u2032, \u2033, \u2032\u2033). Additionally, each of the client , the server  and the workstation  can be running the same or different operating systems. For example, the client  can running Microsoft\u00ae Windows, the server  can be running a version of Unix, and the workstation a version of Linux. Or each of the client , the server  and the workstation  can be running Microsoft\u00ae Windows. Additionally, the software components of the MATLAB\u00ae-based distributed computing environment can be capable of and configured to operate on and take advantage of different processors of any of the computing device (e.g., , \u2032, \u2033, \u2032\u2033). For example, the software components of the MATLAB\u00ae-based distributed computing environment can run on a 32 bit processor of one computing device  and a 64 bit processor of another computing device \u2032. In a distributed system, such as the system depicted in , MATLAB\u00ae-based distributed computing application can operate on computing devices (, \u2032, \u2033, \u2032\u2033) that can be running on different processor architectures in addition to different operating systems. One ordinarily skilled in the art will recognize the various combinations of operating systems and processors that can be running on any of the computing devices (, \u2032, \u2033, and \u2032\u2033).","Although the present invention is discussed above in terms of distributing software components of the MATLAB\u00ae-based distributed computing application across the computing devices of a client , server  and workstation , any other system and\/or deployment architecture that combines and\/or distributes one or more of the technical computing client , job manager , automatic task distribution mechanism  and technical computing worker  across any other computing devices and operating systems available in the network  may be used. Alternatively, all the software components of the MATLAB\u00ae-based distributed computing application can run on a single computing device , such as the client , server  or the workstation .","The MATLAB\u00ae-based distributed computing application of an embodiment of the present invention provides flexibility in methods of task distribution with multiple modes of operation. In , B and C, three modes of task distribution of the MATLAB\u00ae-based distributed computing environment are shown.  depicts a direct distribution mode, , an automated distribution mode and , a batch mode of automated distribution. Additionally,  depicts an exemplary embodiment of the batch mode of automated distribution.","The direct distribution system  of  is intended for those users who desire a high level of control over which technical computing worker A-N executes a particular task. In brief overview of the direct distribution system , the technical computing client  is in communications with a plurality of technical computing workers, A-N, each running on their own workstation A-N. In an alternative embodiment, one or more of these technical computing workers A-N can be running on the same computing device, e.g., workstation A, or on the client  or the server . This direct distribution system  allows a task to be sent to a particular technical computing worker, e.g., technical computing worker A of a plurality of technical computing workers A-N. Then, the technical computing client  can continue with other work while the specified technical computing worker, e.g., technical computing worker A, is performing technical computing of the submitted task. Some time after submitting the task to the technical computing worker A, the technical computing client  can then obtain the result of the task from the technical computing worker A. Furthermore, each technical computing worker N can process multiple tasks, e.g., TaskN-M, and for each task produce a result, e.g., ResultN-M. Alternatively, the technical computing worker A may perform technical computing of a task without returning a result, or may return information acknowledging completion of the task. This mode of task distribution is useful for a computer network with a relatively small number of known workstations A-N and technical computing workers A-N. A task can be delegated to a specified technical computing worker running A on a workstation A that has a higher speed configuration than the other workstations B-N. For example, a longer task could be executed on such a workstation A in order to speed the overall computation time.","As further depicted in , the technical computing client  of the direct distribution system  can submit multiple tasks (e.g., TaskN-M) to each of the multiple technical computing workers A-N. For example, the technical computing client  submits task  to technical computing worker A, submits task  to technical computing worker B, and submits task N to technical computing worker N. The technical computing client  can submit task, task and taskN-M one immediately after another or within a certain time between each other. As such, the technical computing workers A-N can be performing technical computing of their respective tasks independently and in parallel to each other. Alternatively, the technical computing workers A-N may perform technical computing of their respective task while the other technical computing workers are idle.","In another embodiment, the technical computing workers A-N may include interfaces and communication channels to interact with each other as depicted by the phantom arrowed lines between the technical computing workers A-N in . In such an embodiment, technical computing worker A may perform a portion of technical computing on task, and then submit task, and optionally, any generated result or other data, for further technical computing by technical computing worker B. Also, the technical computing worker A may also submit the result of its technical computing of task to the technical computing client , before or after, submitting the task to technical computing worker B for further processing. Technical computing worker B may in turn perform technical computing of task, and subsequently submit task for further processing by technical computing worker N. For additional configurability, the technical computing workers A-N can obtain information with the task about the identification of other technical computing workers A-N in the system. This information would be used to communicate and interact with another technical computing worker. Alternatively, a technical computing worker A may find another technical computing worker B-N by making a function or system call, or a method call to a service provider on the network . In such a configuration, technical computing workers A-N can either execute tasks independently and in parallel to each other, or also execute tasks serially and subsequent to each other.","Referring now to , the automated task distribution mode embodied in system  is intended to provide a configuration where the user does not want to control which technical computing worker A-N executes a particular task. In brief overview of the automated distribution mode of system , a technical computing client  is in communication with the automatic task distribution mechanism  running on the server . The automatic task distribution mechanism  is in communications with a plurality of technical computing workers A-N. Under this mode of operation, the technical computing client  is not required to have any specific knowledge of the technical computing workers A-N, e.g., the name of the workstation running a technical computing worker A-N, or the availability of the technical computing worker A-N to perform technical computing of a task. In alternative embodiments, it may have prior knowledge of all or a portion of the technical computing workers A-N available on the network. Even with knowledge of the name or availability of technical computing workers A-N on the network , the technical computing client  can choose not to specify the name of a particular technical computing worker to perform the task, and let the automated distribution mechanism distribute the task to any available technical computing worker A-N.","In , the technical computing client  submits one or more tasks (Task-TaskN-M) to the automatic task distribution mechanism . These tasks can be submitted sequentially or in an order and frequency as specified by the technical computing client . The automatic task distribution mechanism  obtains the tasks (Task-TaskN-M) to make then available for distribution to any of the technical computing workers A-N. A technical computing worker A-N takes a task from the automatic task distribution mechanism  for technical computing of the task, computes a result for the task and provides the result to the automatic task distribution mechanism . For example, technical computing worker A takes task  from the automatic task distribution mechanism , computes a result, Result , for task , and submits Result  to the automatic task distribution mechanism . The automatic task distribution mechanism  makes the results (Result-ResultN-M) available to the technical computing client  as they get submitted from the technical computing worker A-N generating and submitting the respective result. At a time or method determined by the technical computing client , the technical computing client  obtains the results of the computed tasks from the automatic task distribution mechanism . For example, the technical computing client  may obtain all the results (Result-ResultN-M) at the same time after all the results have been computed, or each result may be obtained after it becomes available in the automatic task distribution mechanism . Accordingly, the technical computing client  can determine the order and frequency of obtaining one or more of the results. As with the direct distribution mode, the technical computing workers A-N can also communicate and interact with each other, as depicted by the phantom arrowed lines between the technical computing workers A-N in , to execute tasks both serially and in parallel by submitting a task to another technical computing worker A-N.","The batch mode of automated task distribution embodied in system  of  is intended to provide a configuration where the user can specify a group of related tasks as a job and provide the batch of tasks, or the job, to the automatic task distribution mechanism . In brief overview of the batch mode of the automatic distribution system , a technical computing client  is in communication with the job manager  on the server . The job manager  interfaces and communicates with the automatic task distribution mechanism  running on the same server . Each of the technical computing workers A-N is in communication with the automatic task distribution mechanism . A job manager  interfaces with and is associated with one automatic task distribution mechanism . Alternatively, the job manager  and the automatic task distribution mechanism could be on different servers . Additionally, a plurality of job managers and automatic task distribution mechanisms could be running on a single server  or each on their own servers. Each of the plurality of job managers interface with and are associated with one of the plurality of automatic distribution mechanisms. This allows the distributed system to scale the number of instances of the job manager  and the automatic distribution mechanism  to handle additional multiple technical computing clients  distributing tasks.","In batch mode as depicted in , the technical computing client  defines the job. The technical computing client  has a programming language environment by which it can declare tasks, declare a job and associate the tasks with the job. Instead of submitting each task separately as depicted in , the technical computing client  submits the job containing all the associated tasks to the job manager . The job manager  is a software component that provides an object-oriented interface to the automatic task distribution mechanism . The job manager  obtains the tasks from the job and provides the tasks to the automatic task distribution mechanism  for technical computing workers A-N to take and compute results. For example, technical computing client  defines a job, Job, with a set of three tasks: Task, Task and TaskN-M. The technical computing client  then submits Job to the job manager . The job manager  obtains Job and obtains each of the tasks, Task-TaskN-M from Job . Then, according to the configured logic of the job manager , described in more detail below, the job manager  submits each of the tasks to the automatic task distribution mechanism  for technical computing by a technical computing worker A-N. Technical computing worker A may take Task from the automatic task distribution mechanism , compute a Result for Task and provide the Result to the automatic task distribution mechanism . Technical computing worker B and technical computing worker N, in a similar fashion, compute and provide results for Task and TaskN-M respectively. The job manager  then obtains the set of results for the completed job of Job and provides the results of each of the tasks to the technical computing client .","The job manager  further comprises a queue  for arranging and handling submitted jobs. For example, the job manager  may handle jobs in a first-in first-out (FIFO) manner. In this case, the job manager  does not process the next job until all the tasks from the current job have been processed by the automatic task distribution mechanism . Additionally, the job manager  using the queue  supports handling multiple job submissions and task distribution from multiple technical computing clients . If a first technical computing client  submits a job, Job, the job manager  places that job first in the queue . If a second technical computing client submits a second Job, for example, Job , the job manager places the job in the queue behind the Job from the first client. In this manner, all technical computing clients  accessing the services of the job manager  get serviced for task distribution. One ordinarily skilled in the art will recognize that the job manager  could implement a variety of algorithms for processing jobs in a job queue  and for handling multiple technical computing clients . For example, a user may be able to specify a priority level for a specified job, or the logic of the job manager  may make task distributing and processing decisions based on the configuration and availability of technical computing workers A-B to determine a preferred or optimal selection of technical computing of jobs and tasks.","As with the other distribution modes of  and , the technical computing workers A-N in batch mode can also communicate and interact with each other as shown by the phantom arrowed lines between technical computing workers A-N in . This allows the technical computing workers A-N to execute tasks both serially and in parallel by submitting a task to another technical computing worker. As part of the information associated with the task obtained by a technical computing worker or by other means, such as a system or function call, or a method call to a service, a technical computing worker A can obtain information about the other technical computing workers B-N assigned to or working on tasks associated with a specific job, or available on the network .","The exemplary embodiment of the batch mode of automated task distribution system  of  depicts a configuration where the job manager  contains the automatic task distribution mechanism . In brief overview of system , a technical computing client  is in communication with the job manager  on the server . The job manager  comprises a task distribution mechanism  running as part of the job manager  on the same server . The job manager  further comprises a queue  for arranging and handling submitted jobs. The technical computing workers A-N are in communication with the job manager  to receive tasks from the automatic task distribution mechanism  of the job manager .","In batch mode operation as depicted in , the technical computing client  defines the job comprised of related tasks. Instead of submitting each task separately as depicted in , the technical computing client  submits the job containing all the related tasks to the job manager . The job manager  obtains the tasks from the job and submits the tasks, via an automatic task distribution mechanism , to the technical computing workers A-N to perform technical computing. For example, technical computing client  defines a job, Job, with a set of three tasks: Task, Task and TaskN-M. The technical computing client  then submits Job to the job manager . The job manager  obtains Job and obtains each of the tasks, Task-TaskN-M, from Job . Then, the automatic task distribution mechanism  of the job manager  submits each of the tasks to a technical computing worker A-N for technical computing. For example, the job manager  may submit Task  to technical computing worker A to compute and produce a Result for Task. Technical computing worker A provides the Result to the job manager . In a similar fashion, the job manager  may submit Task and TaskN-M to technical computing worker B and technical computing worker N with each technical computing worker A and B providing the results for Task and TaskN-M respectively to the job manager . When all the results from each of the tasks of Job are received, the job manager  then provides the results of each of the tasks of Job  to the technical computing client .","In the batch mode of operation of depicted in , the job manager  or automatic task distribution mechanism  can be configured to define the minimum and maximum numbers of technical computing workers A-N to perform the tasks associated with a job. This feature can be configured on a job by job basis. Alternatively, it may be configured for a portion or all of the jobs. The configuration of these settings can be facilitated through parameters associated with a submitted job, such as in one or more properties of a job object, or in one or more fields of a data structure representing a job. Alternatively, these settings may be facilitated through any interface of the job manager  or automatic task distribution mechanism , such as in a configuration file, graphical user interface, command or message or any other means by which values for these settings may be set.","The system (e.g.  or ) can compare the number of technical computing workers A-N registered, or otherwise available, with the job manager  or automatic task distribution mechanism  against the configured setting of the minimum number of technical computing workers parameter. The system may not start a job unless there is a minimum number of technical computing workers A-N registered or available to work on the job. In a similar manner, the system can check the number of available or registered technical computing workers A-N against the setting of the maximum number of technical computing workers parameter. As the system distributes tasks of a job, it can make sure not to distribute tasks to more than the defined number of technical computing workers A-N. In some embodiments, the minimum number of technical computing workers will be set to a value equal to the setting of the maximum number of technical computing workers. In such a case, the system may only start the job if the minimum number of technical computing workers A-A are available or registered to start the job, and may not use any more technical computing workers A-N than the minimum setting. This is useful for cases where the user wants to configure a job to have each task be assigned to and run on separate technical computing workers A-N. For example, a job may have 5 tasks and the minimum and maximum technical computing worker settings may be set to 5.","Additionally, in any of the embodiments depicted in , the system can determine or select the technical computer worker A-N to work on a task by operational and\/or performance characteristics of the technical computing worker A-N and\/or workstation A-N. For example, a technical computing worker A may work on a task based on the version of the MATLAB\u00ae-based distributed computing application that is installed on the workstation A or that the technical computing worker A is capable of running. Additionally, the technical computing worker A-N and workstation A-N may have a specification or profile, such as a benchmark comparison results file, which provides a description of any operational and performance characteristics of the version of the MATLAB\u00ae-based distributed computing application running on that specific computing device  of the workstation A. This profile can be in comparison to known benchmarks of operational and performance characteristics of the MATLAB\u00ae-based distributed computing application running on certain computing devices (, \u2032, \u2033, \u2032\u2033), with specified versions of the MATLAB\u00ae-based distributed computing application, operating systems and other related software, or any other system component or attribute that may impact the operation or performance of the MATLAB\u00ae-based distributed computing application. This profile may be described in a file accessible over the network or retrievable through an interface mechanism of the technical computing worker A-N. Furthermore, the system may determine the technical computing worker A-N to work on a task by any configuration or properties set on the technical computing worker A-N or workstation A-N. For determining a technical computing worker A-N to work on a task, the system may discover any configuration, properties, and operational and performance characteristics of the MATLAB\u00ae-based distributed computing application of a technical computing worker A-N running on a workstation A-N through any interface of the technical computing worker A-N or workstation A-N, such as, for example, in a file, graphical user interface, command or message.","The MATLAB\u00ae-based distributed computing application of an embodiment of the present invention also provides additional flexibility in that the multiple modes of task distribution can be performed concurrently in the distributed system.  is an illustrative embodiment of the present invention showing the distributed application performing, concurrently, the combination of the modes of operation depicted in . Additionally, the distributed system  is depicted supporting multiple clients A-N communicating with multiple job managers A-N and multiple automatic task distribution mechanisms A-N. With these multiple modes of operation, any technical computing client A-N can distribute tasks directly to a technical computing worker A-N, submit tasks to the automatic task distribution mechanism , or submit a job to the job manager . In the depicted multi-client distributed system , a plurality of technical computing clients A-N are in communication with one or more job managers A-N. The job manager A can be a separate component interfacing to the automatic task distribution mechanism A, or the job manager N can be a single application comprising the functionality of the automatic task distribution mechanism N. The one or more technical computing workers A-B are in communication with the one or more job managers N or the one or more automatic task distribution mechanisms A. The distributed architecture of the present invention allows for a scalable and flexible distributed technical computing environment supporting a variety of deployments and network topologies.","For example, as shown in , a technical computing client A can operate in both the direct distribution mode and the batch automated distribution mode. As such, technical computing client A can submit a task to and receive a result from the automatic task distribution mechanism A without using the job manager A. In another instance, technical computing client A can submit a job, Job, to the job manager A for task distribution by the automatic task distribution mechanism A to receive results from the job, such as JobResults. In another example of , technical computing client B can operate in batch automated distribution mode but submit jobs separately to a first job manager A running on a first server A and a second job manager N running on a second server N. In yet another example, technical computing client N operates in both the automated distribution and direct distribution modes. Technical computing client N submits a task, Task, to automatic task distribution mechanism N and receives a result, TaskResult, from computing by a technical computing worker A-N assigned by the system . Technical computing client N also directly submits a task to technical computing worker N and receives a computed result directly from the technical computing worker N. One ordinarily skilled in the art will appreciate the various combinations of deployments that can occur with such a distributed system  with multiple modes of operation. As such, the present invention offers scalability and flexibility for distributed processing of complex technical computing requirements.","In another aspect, the present invention relates to methods for distributing tasks to technical computing workers A-N for processing, either directly, or indirectly and automatically, as described above in reference to the embodiments depicted in . , B and C each show a flow diagram of the methods of the three modes of task distribution of the MATLAB\u00ae-based distributed computing application.  depicts the method of direct distribution, , the method of an automated distribution, and , a batch mode method of automated distribution.","Referring now to , one embodiment of the method  to distribute a task from a technical computing client  to a technical computing worker  is illustrated. Method  is practiced with the direct distribution embodiment of the invention depicted in . The technical computing client  defines a task comprising an operation for technical computing (step ). The task defines a function, command or operation, such as may be available in the programming language of MATLAB\u00ae, and the number of arguments and input data of the arguments. The technical computing client  then submits the task (step ) to the technical computing worker . The technical computing worker  receives the task (step ) and performs the requested technical computing as defined by the task (step ). In performing the technical computing on the task, an associated result may be generated (step ). In alternative embodiments, either no result is generated, or no result is required to be returned to the technical computing client . After generating the result from computing the task, the technical computing worker  provides the result (step ) to the technical computing client , and the technical computing client  obtains the result from the technical computing worker  (step ).","Referring now to , an embodiment of the method  to distribute a task from a technical computing client  to a technical computing worker  in automated task distribution mode is illustrated. Method  is practiced with the automatic task distribution embodiment of the invention depicted in . A technical computing worker  registers to receive notification of one or more tasks (step ) becoming available, or appearing, in the automatic task distribution mechanism . The technical computing client  defines a task comprising an operation for technical computing (step ). The technical computing client  then submits the task (step ) to the automatic task distribution mechanism . The automatic task distribution mechanism  receives the task and makes the task available for distribution (step ) to a technical computing worker . The technical computing client registers (step ) with the automatic task distribution mechanism  to receive notification when a result associated with the task submitted in step  is available, or appears, in the automatic task distribution mechanism . The automatic task distribution mechanism  registers the technical computing client  for notification when the result appears (step ). The automatic task distribution mechanism  provides notification (step ) to the technical computing worker  of the availability of the task. In response to receiving the notification (step ), the technical computing worker obtains (step ) the task provided (step ) from the automatic task distribution mechanism . The technical computing worker  performs the requested technical computing on the function or command as defined by the task (step ). In performing the technical computing on the task, an associated result may be generated (step ). In alternative embodiments, either no result is generated or the result is not required to be returned to the technical computing client . After generating the result from computing the task (step ), the technical computing worker  provides the result (step ) to the automatic task distribution mechanism . After obtaining the result from the technical computing worker  (step ), the automatic task distribution mechanism  notifies (step ) the technical computing client  that the result is available. The technical computing client  obtains (step ) the result provided (step ) by the automatic task distribution mechanism .","Referring now to , one embodiment of the method  to distribute a task from a technical computing client  to a technical computing worker  in a batch mode of operation is illustrated. Method  is practiced with the batch mode of the automatic task distribution system (e.g.  or ). A technical computing worker  registers to receive notification of one or more tasks (step ) becoming available, or appearing, in the automatic task distribution mechanism . In an exemplary embodiment, the technical computing worker registers to receive a task from the job manager  or automatic task distribution mechanism  as notification to perform computing on the task. The technical computing client  defines one or mores tasks (step ), with one or more of the tasks comprising an operation or function for technical computing. The technical computing client  groups one or more tasks of the tasks into a job (step ). The technical computing client  then submits the job (step ) to the job manager . The job manager  obtains the job (step ) from the technical computing client  and provides the one or more tasks of the job (step ) to the automatic task distribution mechanism , which makes the one or more tasks available for distribution (step ) to one or more technical computing workers A-N. In an exemplary embodiment, the job manager  or the automatic task distribution mechanism  may submit the one or more tasks to the one or more technical computing workers A-N. In another embodiment, the technical computing worker  may take the task from the job manager  or the automatic task distribution mechanism .","The technical computing client  registers (step ) a callback function with the job manager . The technical computing client  may setup and\/or register other callback functions based on changes in the state of processing of a task or job, or changes in the state of the job manager, or other events available to trigger the calling of a function. The job manager  calls this function when the job is completed, i.e., when each of the one or more tasks of the job have been completed. In turn, the job manager  may register (step ) with the automatic task distribution mechanism  to receive notification of the results of the submitted tasks appearing in the automatic task distribution mechanism , or being received from the technical computing worker A-N. In one embodiment, the automatic task distribution mechanism  registers the notification request of the job manager (step ). Then, the automatic task distribution mechanism  provides notification to the technical computing worker  of the availability of the task (step ). In an exemplary embodiment, the task is sent, by the job manager  to the technical computing worker  as notification to perform the task. In response to receiving the notification or the task (step ), the technical computing worker  obtains (step ) the task provided (step ) from the automatic task distribution mechanism  or the job manager . The technical computing worker  performs the requested technical computing on the operation as defined by the task (step ). In performing the technical computing on the task, an associated result may be generated (step ). In alternative embodiments, either no result is generated or the result is not required to be returned to the technical computing client . After generating the result from computing the task (step ), the technical computing worker  provides the result (step ) to the automatic task distribution mechanism  or the job manager . After obtaining the result from the technical computing worker  (step ), the automatic task distribution mechanism  notifies (step ) the job manager  that the result is available. In an exemplary embodiment, the job manager  receives the results from the technical computing worker . In response to receiving the notification or the result (step ), the job manager  obtains the result (step ) provided by (step ) the automatic task distribution mechanism . If the job manager  received the last result of the job, the job manager  will notify the technical computing client  that the job is completed via the registered callback function (step ). After triggering the completed job callback function (step ), the technical computing client  obtains (step ) the result provided (step ) by the job manager .","With the methods of task distribution described above (methods , , and ) in view of the embodiment of the concurrent multiple distribution modes of operation depicted in system  of , one ordinarily skilled in the art will recognize the application of the above methods to the multiple modes of operation for each technical computing client A-N in .",{"@attributes":{"id":"p-0090","num":"0089"},"figref":"FIG. 6A","b":["250","270","260","260","662"]},"The JavaSpace technology views an application as a collection of processes cooperating via a flow of objects into and out of an object exchange repository , known as a space. It does not rely on passing messages directly between processes or invoking methods directly on remote objects. A key feature is that spaces are shared. Many remote processes, such as technical computing workers and job managers of the present invention, can interact with the network accessible object storage of a space. Spaces are also persistent and therefore, provide reliable storage. Spaces are also associative in that objects in the space can be located by associative lookup rather than by memory location or identifier, e.g., in a shared memory solution. Additionally, a space has a few key operations to perform on the object repository to handle the exchanging of objects. A write operation writes an object, such as a task object, to the space. A take operation takes an object, such as result object, from the space. A take is the equivalent of a read and removes the object from the space. A read operation obtains a copy of the object from the space and leaves the object intact in the space. Other operations allow remote processes, such as technical computing workers, technical computing clients and job managers to register for event notification when a certain object appears in the space. An object appears in the space when a process writes the object to the space. The remote process listens for the appearance of objects in the space and the space notifies the registered remote process when the object appears.","In an alternative embodiment of the present invention, an object exchange repository such as one implemented with JavaSpace technology is used to provide a level of indirection between the technical computing client  and the technical computing worker  with regards to task and result objects. By the automatic communication features described above, the technical computing client  does not need to specify a named technical computing worker  to perform technical computing. The automatic task distribution mechanism  comprising the object exchange repository  handles task distribution to technical computing workers A-N registered with the automatic task distribution mechanism . To distribute tasks and results, the technical computing client  and technical computing worker  read and write task and result objects to the object exchange repository .","Referring now to , a technical computing client  executes a write transaction to write a task object to the object exchange repository  of the automatic task distribution mechanism . The task object defines a task for technical computing by a technical computing worker  who obtains the task object from the object exchange repository . The technical computing client  registers with the object exchange repository  to be notified when a result object associated with the submitted task object is available in the object exchange repository . In this way, the technical computing client  can listen for the appearance of results for tasks submitted for technical computing processing. A technical computing worker  registers with the object exchange repository  to be notified when a task object appears in the object exchange repository . After the technical computing client  writes the task object, the object exchange repository  sends a notification to the technical computing worker  informing of the task object being available in the object exchange repository . The technical computing worker , in response to the notification, performs a take operation on the object exchange repository  to retrieve the submitted task object. The take operation removes the task from the object exchange repository . In the alternative, a read operation can be performed to get a copy of the task object without removing it from the object exchange repository .","The technical computing work  obtains the name and arguments of the function to compute from the data structure of the task object. Then the technical computing worker  provides the result from the computation by performing a write operation to write a result object to the object exchange repository . The result object defines within its data structure a result of the computation of the function defined in the task object and performed by the technical computing worker . The write of the result object to the object exchange repository  triggers the notification event registered by the technical computing client . The technical computing client  listening for the result to appear in the object exchange repository , in response to the notification, performs a take operation, or alternatively a read operation, to obtain the result object associated with the submitted task. The technical computing client  then obtains the result information defined within the data structure of the retrieved result object.",{"@attributes":{"id":"p-0095","num":"0094"},"figref":["FIG. 6B","FIG. 6B"],"b":["260","265","265","260","662","265","250","265","270","265","250","250","265","267","267","265","267","265","267","267","1","2","1","265","267","2","267","1","265","2","1","662"]},"Still referring to , the technical computing client  submits a job to the job manager  and specifies a callback function with the job manager . The job manager  is to call the callback function when the job is completed. The job manager receives the job, e.g., job, and places the job into a job queue . The job manager  then obtains the one or more tasks from the first job submitted to the job queue. In the embodiment of a JavaSpace implementation of the object exchange repository , the job manager  writes the task object to the object exchange repository . The job manager  registers with the object exchange repository  to receive a notification when a result object associated with the task appears in the object exchange repository , also known as a space. The job manager  listens and waits for the result to appear in the object exchange repository .","A technical computing worker  registers with the object exchange repository  to receive a notification when a task object appears in the object exchange repository . Then the technical computing worker  listens for the appearance of task objects. When the task is submitted to the object exchange repository  by the job manager , the technical computing worker  receives a notification and takes the task from the object exchange repository  by performing a take operation. The technical computing worker  obtains the function to be executed from the definition of the function in data structure of the task object, performs the function and generates a result of the function for the task. Then the technical computing worker  submits a result object representing a result of the task to the object exchange repository by performing a write operation. The job manager  waiting for the result to appear in the object exchange repository  receives a notification from the object exchange repository  that the result is available. The job manager  checks to see if this is the last result to be obtained from the object exchange repository  for the job currently being processed. If the result is the last result, the job manager  then notifies the technical computing client  that the job is completed by calling the registered callback function. In response to executing the callback function, the technical computing client  then interfaces with the job manager  to retrieve the results from the job manager , which the job manager  retrieves from the object exchange repository  by performing a take operation.",{"@attributes":{"id":"p-0098","num":"0097"},"figref":"FIG. 6C","b":["265","260","250","265","270","267","260","667","668","669","265"]},"The worker pool  contains a list of technical computing workers A-N that are available to work on a task. These technical computing workers A-N may on startup register with a job manager . The name of the job manager  the technical computing worker A-N is associated with may be configurable by an interface of the technical computing worker A-N, or by a command line startup parameter, or an external configuration or registration file. The worker pool  may keep a list of \u201cgood\u201d technical computing workers A-N, or those workers to which the job manager  can communicate with and can determine has such a status to be available for processing tasks. The job manager  can update the worker pool  by going through the list of technical computing workers A-N registered in the worker pool  and sending communications to each of the technical computing workers A-N to determine their status and if they are available. Accordingly, the worker pool  can be updated to determine the current set of technical computing workers  available, or otherwise able to receive tasks from the job manager .","The job runner  is responsible for determining the next task to work on and for submitting the task to a technical computing worker A-N. The job runner  works with the job queue  and takes the next task for processing from a job in the job queue . The job runner  obtains from the worker pool  a name of or reference to a technical computing worker A-N and submits the task for processing to the obtained technical computing worker A-N. The job runner  may be configured to have business rule logic to determine the next task to take from the job queue either in a FIFO manner supported by the job queue  or any other manner based on priority, availability, task and job option settings, user configuration, etc. The job runner  in conjunction with the worker pool  and the job queue  can form a portion of or all of the functionality of the automatic task distribution mechanism . The job runner  can have such logic to determine from the worker pool  which technical computing worker A-N should be assigned and sent a task from the job queue . Alternatively, a separate automatic task distribution mechanism  can be responsible for determining the technical computing worker A-N to be assigned a task and to send the task to the assigned technical computing worker A-N. In any of these embodiments, the technical computing worker  does not need to know the identity, such as via a hostname or an internet protocol address, of the technical computing worker A-N assigned to perform technical computing on a task.","The job manager  also has a database  for storing and retrieving job manager, job and task objects and data, or other objects and data to support the operations described herein. For example, jobs in the job queue , the list of workers of the worker pool , the tasks of any jobs in the job queue , the properties of any of the task, job or job manager objects may be stored in the database . The database  can be a relational database, or an object-oriented database, such as database software or applications from Oracle\u00ae or SQL Server from Microsoft\u00ae, or any other database capable of storing the type of data and objects supporting the operations described herein. The database  can be an in process database  of the job manager  or it can be a remote database  available on another computing device \u2032 or another server \u2032. Furthermore, each instance of the job manager A-N could use a different database and operating system than other instances of the job manager A-N, or be using a local database while another job manager A-N uses a remote database on another server \u2032. One ordinarily skilled in the art will appreciate the various deployments of local or remote database access for each of the one or more job managers A-N.","The job manager  can be configured to execute certain functions based on changes of the state of a job in the queue . For example, the technical computing client  can setup functions to be called when a job is created in a job queue , when the job is queued, when a job is running or when a job is finished. The job manager  is to call these functions when the appropriate change in the state of job occurs. In a similar manner, the task and job can be configured to call specified functions based on changes in state of the task or job. For example, a job may be configured to call a function when a job is added to the queue, when a task is created, when a task is completed, or when a task starts running. A task may be configured to call a function when the task is started, or running.","Referring still to , the technical computing client  submits a job, Job, comprised of one or more tasks, such as Task  and Task, to the job manager . The job manager receives the job, e.g., job, and places the job into a job queue . The job runner  then obtains the one or more tasks from the first job submitted to the job queue . A technical computing worker  registers with the job manager  and is listed in the worker pool  of the job manager . From the worker pool , the job runner  determines a technical computing worker A-N to submit the task for processing. The technical computing worker A-N obtains the function to be executed from the definition of the function in data structure of the task object, performs the function and generates a result of the function for the task. Then the technical computing worker  updates the task object to provide a result of the task. For example, the task object may have a field representing the output arguments from the execution of the function defined by the task. The output arguments may contain one or more arrays of data as allowed by the programming language of MATLAB\u00ae. Additionally, the task object may contain an error field to which the technical computing worker A-N updated to indicate any error conditions in performing the task or executing the function of the task. The job manager  checks to see if this is the last result to be obtained from a technical computing worker A-N for the job currently being processed. If the result is the last result, the job manager  can provide the set of task results for the completed job to the technical computing client .","Although the invention is generally discussed in terms of a job manager , automatic task distribution mechanism  and technical computing worker  as distributed software components available on various computing devices in the network, these software components can be operated as services in a service oriented distributed architecture. One embodiment of a service oriented technology approach is the use of Jini network technology from Sun Microsystems, Inc. Jini network technology, which includes JavaSpaces Technology and Jini extensible remote invocation, is an open architecture that enables the creation of network-centric services. Jini technology provides a method of distributed computing by having services advertise the availability of their provided service over a network for others to discover. Clients and other software components can discover the advertised services and then make remote method calls to the discovered services to access the functionality provided by the service. As such, the software components of the MATLAB\u00ae-based distributed computing application can be implemented as services which can be discovered and looked-up via advertising.","Referring now to , an exemplary embodiment of the invention is shown implementing a service oriented approach with Jini network technology. In broad overview of the system , the technical computing client , technical computing workers A-N, job managers A-N, automatic task distribution mechanisms A-N are in communication over the network  via network communication channels . Additionally there is a network server  in communication with the network  through the network communication channel . The network server  hosts a code base server . In an exemplary embodiment, the code base server  is an ftp server. In other embodiments, the code base server  is a web server, such as Java web server, or an http server. The code base server  is capable of and configured to upload files, including class or interface files. In an exemplary embodiment, the code base server  may upload JAR files. The code base server  may be available on the network  to Jini based services to obtain class files as a service on the network  may need, or it may be available to a technical computing client  to determine the interface to a service on the network .","In support of implementing software components of the present invention as Jini services, one or more of the following Jini services are available on the network server  on the network : Reggie , Mahalo , Fiddler  and Norm . These services are part of the Sun Technology Jini network technology implementation. Reggie  is a Jini service that provides service registration and discovery. This allows clients of a service to find the service on the network  without knowing the name of the computing device the service is running on. Mahalo  is a transaction manager service that provides fault tolerant transactions between services and clients of the service accessing the service. Fiddler  is a lookup discovery service. A Jini based service needs to register itself with an instance of Reggie in order to be discoverable on the network . The lookup discovery service of Fiddler  allows the service to find new Reggie services and register with them while inactive. Norm  is a lease renewal service. Services registered with Reggie are leased. When the lease on a registration expires, the service becomes unavailable from the instance of Reggie. Norm allows a Jini service to keep leases from expiring while the service is inactive. The services of Reggie, Mahalo, Fiddler and Norm can be run on any computing device  on the network  capable of running these services and can be run on a single java virtual machine (JVM).","Referring again to , the technical computing workers A-N, which provide MATLAB\u00ae sessions, are made available as Jini Services to support the direct task distribution mode of operation of the invention. The technical computing workers A-N register with a lookup service such as Reggie . This allows the technical computing workers A-N to be discoverable on the network  by a technical computing client  without the technical computing client  knowing information like the host name of the workstations A-N the technical computing workers A-N are running on, or the port number to which a specific technical computing worker A-N service is listening on, or a worker name associated with a technical computing worker A-N.","The technical computing workers A-N also support service activation with an activation daemon A-N software component. Activation allows a technical computing worker service A-N to register with an activation daemon A-B to exit and become inactive, but still be available to a technical computing client . In all three distribution modes of operation as embodied in , the MATLAB\u00ae-based technical computing workers A-N can be activated by an activation daemon A-N. This means that an activation daemon A-N starts and stops the technical computing worker A-N. For example, the technical computing worker A service registers with the activation daemon A on workstation A. The technical computing worker A includes the activation states of active, inactive and destroyed. In the active state, the technical computing worker A is started and is available for remote method calls from a technical computing client . The starting of the service and its availability for remote method calls, or an instance of a running of the service, may be referred to a session. In the inactive state, the technical computing client  is not started, but is still available for remote method calls from a technical computing client . If a remote method call to the technical computing worker service A is made by the technical computing client , the technical computing worker service A will be started by the activation daemon A, and the method call will be executed by the technical computing worker service A. In the destroyed state, the technical computing worker service A is not running and is not registered with the activation daemon A. In this state, the technical computing worker service A is not available for remote calls from a technical computing client . As such, the activation daemons A-N provide persistence and maintain the state of the technical computing worker services A-N.","The activation feature of technical computing worker services A-N saves computing resources on workstations hosting the technical computing worker, and also increases service reliability. For example, if the technical computing worker service A terminates abruptly, the activation daemon A will automatically restart the next time a call is made to it. The activation daemon A-N also provides for the graceful termination of the technical computing worker service A-N. If an inactivate command is sent to a technical computing worker service A-N, the technical computing worker service A-N can complete the processing of outstanding method calls before terminating. Alternatively, a command can be sent to the technical computing worker A-N to force immediate termination in the middle of processing a task. Additionally, in one embodiment, a technical computing worker A can be configured and controlled to shutdown after the completion of processing of a task. If the technical computing worker A is not shutdown, it can be further configured to keep the state of the technical computing environment, including any calculation or other workspace information, intact for the next task that may be processed.","In another embodiment of the technical computer worker service, the technical computing worker services A-N can default to a non-debug mode when the technical computing worker service A-N is started, either by the activation daemon A-N or by other conventional means. Alternatively, the activation daemon A-N and\/or the technical computing worker service A-N can be configured to start in debug mode, giving access to command line interface of the technical computing worker A-N.","In a manner similar to technical computing worker services A-N, the job managers A-N and automatic task distribution mechanisms A-N as depicted in  can also be implemented as services. As such, the job managers A-N and automatic task distribution mechanisms A-N can support lookup registration and discovery so that a technical computing client A can find the service without knowing the associated name of the service, the host name of the server  running the service, or the port name the service is listening on. Additionally, the job manager A-N and automatic task distribution mechanism services A-N can be supported by activation daemons as with the technical computing worker services A-N.","In another aspect of the invention, the services of the technical computing worker A-N, job manager A-N and the automatic task distribution mechanism A-N, can also have administration functions in addition to the operational functions discussed above. Administration functions may include such functionality as determining the current status of the service, or calling debug functions on the service, or manually calling specific methods available from the service. As depicted in , the technical computing workers A-N may each include a technical computing worker administration software component A-B, the job managers A-N may each include a job manager administration software component A-B, and the automatic task distribution mechanisms A-N may also each include an administration software component A-N. Any and each of these administration software components may be part of the respective service, or a separate software component, or another service in itself. Additionally, these administration software components may include a graphical user interface for easier administration of the service. From the graphical user interface, a user may be able to exercise a portion or all of the functionality provided by the administration component and\/or the methods provided by the service. Any of these administration functions may be not be available to users of the technical computing client , and may be configured to only be available to system administrators or to those users with certain access rights to such functionality.","For example, the administration component A of the automatic task distribution mechanism A may provide a graphical view showing the tasks and results currently in the automatic task distribution mechanism. It may further show the movement of tasks and results in and out of the automatic task distribution mechanism along with the source and destinations of such tasks and results. Additionally, the graphical user interface may allow the user to set any of the properties and execute any of the methods described in the object-oriented interface to the object exchange repository , or space, as described in the user defined data classes below.","In another example, the job manager administration component A may provide a graphical view of all the jobs in the job queue  of the job manager . It may further show the status of the job and the state of execution of each of the tasks comprising the job. The graphical user interface may allow the user to control the jobs by adding, modifying or deleting jobs, or arranging the order of the job in the queue . Additionally, the graphical user interface may allow the user to set any of the properties and execute any of the methods described in the object-oriented interface to the job manager  as described in the user defined data classes below.","A graphical user interface to the technical computing worker administration component A-N may provide a user the ability to change the activation state, stop and start, or debug the technical computing worker service A-N. Additionally, the graphical user interface may allow the user to set any of the properties and execute any of the methods described in the object-oriented interface to the technical computer worker A-N as described in the user defined data classes below.","Another aspect of this invention is the use of objects to perform object-oriented user interaction with the task and job management functionality of the distributed system.  depicts one embodiment of using user defined data classes as part of the MATLAB\u00ae programming language. In the object-oriented distributed system  embodiment of the present invention, the system  makes use of task objects , result objects , job objects  and jobresults objects  These objects present a lower level user interaction mechanism to interact with the task distribution functionality of the system .","In the object-oriented distributed system  of , the technical computing client  creates or declares a task object . The task object  is a user defined data class containing a MATLAB\u00ae command, input data and number of arguments. The technical computing client  submits the task object, in the automated mode of operation, to the automatic task distribution mechanism , which stores the task object  in the object exchange repository . A technical computing worker  listening and waiting for a task object  to appear in the object exchange repository , takes the task object  to perform technical computing of the task. The technical computing worker  obtains the MATLAB\u00ae command and arguments from the properties of the task object  and performs technical computing on the task in accordance with the command. The technical computing worker  then creates or specifies a result object , which is a user defined data object containing the output data resulting from the execution of a task represented by a task object . The technical computing worker  then writes the result object  to the object exchange repository . The technical computing client  listens and waits for the appearance of the result object  in the object exchange repository . After the result object  appears in the object exchange repository, the technical computing client  takes the result object  from the object exchange repository and retrieves result information from the properties of the result object .","Referring still to , in batch mode, the technical computing client  creates or declares a job object , which is a user defined data object containing an array of task objects . The technical computing client  then submits the job object  to the job manager  for processing. The job manager  then submits the one or more task objects  defined in the job object  to the object exchange repository  for processing by a technical computing worker . The technical computing worker  listening for the appearance of the task objects , takes the task objects  and performs technical computing on the function as defined by each task object. The technical computing worker  then generates results and creates or specifies the result objects  representing the output generated for each function of each of the task objects  of the job object . The technical computing worker  then writes the result objects  to the object exchange repository . The job manager  listening for the appearance of the result objects  takes the result objects from the object exchange repository . The job manager  then creates or specifies the jobresults object , which in an object that provides an array of result objects  for each task object defined in a job object . The job manager then provides the jobresults object  to the technical computing client . One ordinarily skilled in the art will recognize the various combinations of uses of each of these objects in performing the operation of the multiple modes of distribution as depicted in .","In an embodiment of the invention as depicted in  and by way of example, the following functions and properties are available in the programming language of MATLAB\u00ae via toolbox functionality of MATLAB\u00ae for task distribution management functionality:","Task",{"@attributes":{"id":"p-0120","num":"0119"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Property Name","Property Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["TaskID","unique task identifier"]},{"entry":["JobID","non-null if this task is part of a job"]},{"entry":["FunctionNameAndParameters","name of function and parameters of"]},{"entry":[{},"function"]},{"entry":["NumberOfOutputArguments","number of output arguments of function"]},{"entry":["StartTime","startTime"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0121","num":"0120"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Methods"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Method Name","Method Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"evaluate","evaluates function and returns Result"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0122","num":"0121"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Property Name","Property Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["TaskID","unique identifier given to corresponding task object"]},{"entry":["JobID","non-null if this result is part of a job"]},{"entry":["OutputArguments","output arguments"]},{"entry":["StartTime","start time"]},{"entry":["EndTime","end time"]},{"entry":["WorkerName","name of work performing function"]},{"entry":["ErrorMessage","error message, if any"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0123","num":"0122"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Property Name","Property Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Name","assigned name of worker service"]},{"entry":["MachineName","name of computer worker service is running on"]},{"entry":["TaskCompletedFcn","called whenever the worker finishes a directly"]},{"entry":[{},"evaluated task"]},{"entry":["Admin","instance of WorkerAdmin class"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0124","num":"0123"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Methods"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Method Name","Method Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["evaluateTask","evaluate the function defined by instance of Task class"]},{"entry":["getResult","get instance of Result class generated by evaluatetask"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0125","num":"0124"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"105pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Property Name","Property Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Worker","instance of Worker class"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0126","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Methods"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Method Name","Method Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["destroy","removes all traces of the MATLAB service"]},{"entry":["stop","unregisters the service but maintains files on disk"]},{"entry":["deactivate","stops the MATLAB process, but does not"]},{"entry":[{},"unregister service"]},{"entry":["activate","starts the MATLAB process"]},{"entry":["isActive","returns true if the MATLAB process is running"]},{"entry":["isBusy","returns true if MATLAB is processing task or"]},{"entry":[{},"otherwise busy"]},{"entry":["isProcessingTask","returns true if MATLAB is processing task"]},{"entry":["currentTask","returns the task being processed if idle, returns"]},{"entry":[{},"null"]},{"entry":["dbstop","basic debugging commands"]},{"entry":["dbstep","basic debugging commands"]},{"entry":["dbcont","basic debugging commands"]},{"entry":["break","sends Ctrl-C"]},{"entry":["isLogging","returns true if logging is turned on"]},{"entry":["log","L = 0 turns off logging L = 1 turns on logging"]},{"entry":["getStats","output arg format (return argument contents not"]},{"entry":[{},"yet determined)"]},{"entry":["clearResults","makes uncollected results available for garbage"]},{"entry":[{},"collection"]},{"entry":["listen","listen to the space for the appearance of task"]},{"entry":[{},"objects"]},{"entry":["getMachineProperties","return a structure of machine specific information"]},{"entry":[{},"(system load, processor speed, amount of"]},{"entry":[{},"memory, number of processors, etc)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0127","num":"0126"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Property Name","Property Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Name","name of space"]},{"entry":["MachineNme","host name of computer running the space"]},{"entry":["RsultAvailableFcn","name of function to call"]},{"entry":["SpaceAdmin","returns an instance of the SpaceAdmin class"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0128","num":"0127"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Methods"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Method Name","Method Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["putTask","the task will be written to the space"]},{"entry":["getTask","a task will be taken from the space. This will block"]},{"entry":[{},"until a task is found. If passed a null, a task with any"]},{"entry":[{},"TaskID will be returned."]},{"entry":["getTaskIfAvailable","will return null if no task is immediately available"]},{"entry":["putResult","will place a result into the JavaSpace"]},{"entry":["getResult","works the same as gettask, except a result will be"]},{"entry":[{},"taken rather than a task."]},{"entry":["getResultIfAvailable","will return null if no result with the corresponding"]},{"entry":[{},"TaskID is available"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0129","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Property Name","Property Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Space","name of space"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0130","num":"0129"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Methods"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Method Name","Method Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["destroy","destroy the space"]},{"entry":["clearSpace","removes all entries in this space"]},{"entry":["cancelTask","removes the task or result matching TaskID from the"]},{"entry":[{},"space"]},{"entry":["numTasks","returns the number of tasks currently in the space"]},{"entry":["numTesults","returns the number of results currently in the space"]},{"entry":["workers","list MATLAB workers listening to space"]},{"entry":["clearWorkers","unregister all listening workers"]},{"entry":["addWorker","add a MATLAB worker as a listener"]},{"entry":["removeWorker","remove the given MATLAB worker"]},{"entry":["setEvalAttempts","set the number of times a task will be attempted"]},{"entry":["isLogging","returns true if logging is turned on"]},{"entry":["log","L = 0 turns off logging L = 1 turns on logging"]},{"entry":["getStats","output arg format (return argument contents not yet"]},{"entry":[{},"determined"]},{"entry":["getTasks","removes and returns all tasks in the space in a cell"]},{"entry":[{},"array"]},{"entry":["getResults","removes and returns all results in the space in a cell"]},{"entry":[{},"array"]},{"entry":["readTasks","non-destructively returns all tasks in the space in a cell"]},{"entry":[{},"array"]},{"entry":["readResults","non-destructively returns all results in a cell array"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0131","num":"0130"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Property Name","Property Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["JobID","unique identifier for this job"]},{"entry":["Name","name of job"]},{"entry":["Tasks","cell array of task objects"]},{"entry":["UserName","name of user who creates job (user login name)"]},{"entry":["JobCompletedFcn","callback to execute when this job is finished"]},{"entry":["StartTime","start time of job"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0132","num":"0131"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Methods"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Method Name","Method Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["addTask","can add either a single task or a cell array of tasks"]},{"entry":["removeTask","can remove either a single task or a cell array of tasks"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0133","num":"0132"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Property Name","Property Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"JobID","unique identifier for job"]},{"entry":[{},"Name","name of job"]},{"entry":[{},"Username","name of user who created job"]},{"entry":[{},"Results","cell array of result objects"]},{"entry":[{},"StartTime","start time of job"]},{"entry":[{},"EndTime","end time of job"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},{"@attributes":{"id":"p-0134","num":"0133"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Methods"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Method Name","Method Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["submitJob","submits a Job object to the job manager"]},{"entry":["getResults","returns a JobResults object. Will block until job is"]},{"entry":[{},"finished"]},{"entry":["getResultsIfAvailable","returns a JobResults object or null. Will return"]},{"entry":[{},"immediately"]},{"entry":["getResult","gets a result of instance of a task"]},{"entry":["getResultIfAvailable","get a result of instance of a task if result is"]},{"entry":[{},"available"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{}},{"@attributes":{"id":"p-0135","num":"0134"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Property Name","Property Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"JobManager","instance of JobManager class"]},{"entry":[{},"Space","the space associated with this job manager"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0136","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Methods"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Method Name","Method Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["clearJobs","clears the job queue"]},{"entry":["promote","promotes the specified job"]},{"entry":["demote","demotes the specified job"]},{"entry":["promoteFirst","promote the job to the top of the queue"]},{"entry":["demoteLast","demote the job to the bottom of the queue"]},{"entry":["cancelJob","removes the job from the queue"]},{"entry":["getStatus","returns \u2018executing\u2019, \u2018completed\u2019,\u2019"]},{"entry":["getInfo","gets information for all waiting jobs except for the"]},{"entry":[{},"task objects"]},{"entry":["readJobs","non-destructively returns all jobs in the queue"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The following methods are generally available methods in a package of the MATLAB programming environment, which in this exemplary embodiment have not been implemented as user defined data classes:",{"@attributes":{"id":"p-0138","num":"0137"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Package scope methods (not part of any class)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["findWorkers","finds MATLAB workers available on the network."]},{"entry":[{},"Returns a cell array of worker objects."]},{"entry":["findSpaces","finds spaces available on the network. Returns a cell"]},{"entry":[{},"array of space objects."]},{"entry":["findJobManagers","finds jobmanagers available on the network. Returns"]},{"entry":[{},"a cell array of JobManager objects."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["270","270","260","260","265","265","250","270","270","260","260","265","265","250","140"],"figref":"FIG. 7"},"In an embodiment of the present invention, the programming language of MATLAB\u00ae may support the three modes of operation as described with . By way of example, the following program instructions show a programming usage of the above described user defined data classes for each of these modes of operation:","Direct Distribution Usage Example",{"@attributes":{"id":"p-0140","num":"0139"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"% Find worker"]},{"entry":[{},"w = distcomp.Worker(\u2018MachineName\u2019)"]},{"entry":[{},"% Create task"]},{"entry":[{},"t = distcomp.Task({\u2018rand\u2019,10},1);"]},{"entry":[{},"% (Optional) register completed callback for worker"]},{"entry":[{},"w.TaskCompletedFcn = \u2018completedFcn\u2019;"]},{"entry":[{},"% (Optional) set task timeout value"]},{"entry":[{},"t.Timeout = 10;"]},{"entry":[{},"% Send task to worker"]},{"entry":[{},"w.evaluateTask(t);"]},{"entry":[{},"% Get result (could take place inside completed callback function)"]},{"entry":[{},"r = w.getResult(t);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0141","num":"0140"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"% Find space"]},{"entry":[{},"s = distcomp.Space(\u2018spacename\u2019)"]},{"entry":[{},"% Create task"]},{"entry":[{},"t = distcomp.Task({\u2018rand\u2019,10},1)"]},{"entry":[{},"% (Optional) Register completed callback for space"]},{"entry":[{},"s.TaskCompletedFcn = \u2018completedFcn\u2019;"]},{"entry":[{},"% (Optional) set task timeout value"]},{"entry":[{},"t.timeout = 10;"]},{"entry":[{},"% Put task in space"]},{"entry":[{},"s.putTask(t);"]},{"entry":[{},"% Get result from space (could be inside result listener)"]},{"entry":[{},"r = s.getResult(t);"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0142","num":"0141"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"% Find Job Manager"]},{"entry":[{},"jm = distcomp.JobManager(\u2018managername\u2019)"]},{"entry":[{},"% Create job"]},{"entry":[{},"j = distcomp.Job(\u2018username\u2019,\u2018jobname\u2019)"]},{"entry":[{},"% (optional) register callback for job completion"]},{"entry":[{},"j.JobCompletedFcn = \u2018callbackFcn\u2019;"]},{"entry":[{},"% Add tasks to job"]},{"entry":[{},"for(i=1:10)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"t = distcomp.Task({\u2018rand\u2019,10},1);"]},{"entry":[{},"% (optional) register completed callback for task"]},{"entry":[{},"t.CompletedFcn = \u2018callbackFcn\u2019;"]},{"entry":[{},"% (optional) set task timeout value"]},{"entry":[{},"t.Timeout = 10;"]},{"entry":[{},"j.addTask(t);"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end"]},{"entry":[{},"jm.submit(j)"]},{"entry":[{},"% Get results from job manager"]},{"entry":[{},"for(i=1:10)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"r = jm.getResult(j.Tasks{i});"]},{"entry":[{},"% insert code to process result here"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In addition to the object-oriented interface to task and job management functionality of the distributed system, the programming language of MATLAB\u00ae may also support task distribution via high-level functional procedure calls. The MATLAB\u00ae programming language includes procedural function calls such as eval( ) and feval( ) that provide a quick and powerful procedure to execute functions. Also, the MATLAB\u00ae programming enables you to write a series of MATLAB\u00ae statements into a file, referred to as an M-File, and then execute the statements in the file with a single command. M-files can be scripts that simply execute a series of MATLAB\u00ae statements, or they can be functions that also accept input arguments and produce output. Additionally, the MATLAB\u00ae programming language supports anonymous functions and function handles. Function handles are useful when you want to pass your function in a call to some other function when that function call will execute in a different workspace context than when it was created. Anonymous functions give you a quick means of creating simple functions without having to create M-files each time and can be viewed as a special subset of function handles. An anonymous function can be created either at the MATLAB\u00ae command line or in any M-file function or script. Anonymous functions also provide access to any MATLAB\u00ae function. The @ sign is the MATLAB\u00ae operator that constructs a function handle or an anonymous function, which gives you a means of invoking the function. Furthermore, the MATLAB\u00ae programming language enables the association of a callback function with a specific event by setting the value of the appropriate callback property. A variable name, function handle, cell array or string can be specified as the value of the callback property. The callback properties for objects associated with the MATLAB\u00ae-based distributed computing application are designed to accept any of the above described configurations as the value of the callback property, and may accept any other command, function or input parameter value that are or may become available in the MATLAB\u00ae programming language. This allows users of the MATLAB\u00ae programming language to use the function calls they are familiar with, without learning the object-oriented mechanism, and take advantage of the distributed processing of tasks offered by the MATLAB\u00ae-based distributed computing application of the present invention.","In the exemplary object-oriented distributed system  of , the technical computing client  creates or declares a job object  residing in the job manager . The job object comprises one or more task objects A-N. The job object  further defines properties associated with the job, such as those job properties described in further detail below. For example, a timeout property to specify the time limit for completion of a job. Additionally, the minimum and maximum number of technical computing workers to perform the tasks of the job can be set. The task object A-N is an object that defines a function to be executed by a technical computing worker . The function contains a MATLAB\u00ae command, input data and number of arguments. The task object A-N defines additional task properties, such as those defined below. For example, the task object A-N may have a state property to indicate the current state of the task. Additionally, the technical computing client  may interface with the job manager  through a job manager object  residing on the job manager . In a similar manner to the job object  and task objects A-N, the job manager object  may have properties to define configuration and other details about the job manager  as described below. For example, the job manager object  may have a hostname property to indicate the name of the computer where a job queue exists, or a hostaddress property to indicate the internet protocol address of the computer. For any of the job manager object , job object  or task objects A-N, the technical computing client may not instantiate a local object but may just have a proxy or facade object to reference the object existing in the job manager .","Still referring to , the technical computing client  submits the job to the job manager  via the job object . The job manager  obtains each of the task objects A-N from the job object . The job manager puts the job of the job object  into the job queue . The job runner  obtains the one or more task objects A-N from the job object . The job runner  with the worker pool  determines a technical computing worker  to process a task. The job runner  then submits a task, via a task object A-N to an assigned technical computing worker . The technical computing worker  obtains the function to execute from the properties of the task object A-N and performs technical computing of the task in accordance with the function. The technical computing worker  then obtains the results of the function and updates one or more properties of the task object A-N with information about the results. In the case of any errors, the technical computing worker  may update any error properties of the task object A-N. In a similar manner as the technical computing client , the technical computing worker  may use proxy or facade objects to interface with the job , job manager  or task A-N objects residing in the job manager . The job manager  then updates the job object  with updated task objects A-N containing the results of each task. The job manager  may also update other properties of the job object , such as start and finish times of the job, to reflect other information or status of the job. The job manager  then provides the updated job object  to the technical computing client . The technical computing client  then can retrieve the results of each task from the updated job object . One ordinarily skilled in the art will recognize the various combinations of uses of the properties and functions of these objects in performing the operations described herein and in support of any of the multiple modes of distribution as depicted in .","In an exemplary embodiment of the invention as depicted in  and by way of example, the following functions and properties may be available in the programming language of MATLAB\u00ae for creating and handling objects related to the task distribution and management functionality of the present invention:","Function Reference","createJob","Purpose",{"@attributes":{"id":"p-0147","num":"0000"},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["Create a job object\n\nSyntax\n","obj=createJob(jobmanager)","obj=createJob( . . . , \u2018p1\u2019, v1, \u2018p2\u2019, v2, . . . )\n\nArguments\n","obj The job object.","jobmanager The job manager object representing the job manager service that will execute the job.","p1, p2 Object properties configured at object creation.","v1, v2 Initial values for corresponding object properties.\n\nDescription\n","obj=createJob(jobmanager) creates a job object at the specified remote location. In this case, future modifications to the job object result in a remote call to the job manager.","obj=createJob( . . . , \u2018p1\u2019, v1, \u2018p2\u2019, v2, . . . ) creates a job object with the specified property values. If an invalid property name or property value is specified, the object will not be created.","Note that the property value pairs can be in any format supported by the set function, i.e., param-value string pairs, structures, and param-value cell array pairs.\n\nExample\n","% construct a job object.","jm=findResource(\u2018jobmanager\u2019);","obj=createjob(jm), \u2018Name\u2019, \u2018testjob\u2019);","% add tasks to the job.","for i=1:10","createTask(obj, \u2018rand\u2019, {10});","end","% run the job.","submit(obj);","% retrieve job results.","out=getAllOutputArguments(obj);","% display the random matrix.","disp(out {1} {1});","% destroy the job.","destroy(obj);\n\ncreateTask\n\nPurpose\n","Create a new task in a job\n\nSyntax\n","obj=createTask(j, functionhandle, numoutputargs, inputargs)","obj=createTask( . . . , \u2018p1\u2019,v1,\u2018p2\u2019, v2, . . . )\n\nArguments\n","j The job that the task object is created in.","functionhandle A handle to the function that is called when the task is evaluated.","numoutputargs The number of output arguments to be returned from execution of the task function.","inputargs A row cell array specifying the input arguments to be passed to the function functionhandle. Each element in the cell array will be passed as a separate input argument.","p1, p2 Task object properties configured at object creation.","v1, v2 Initial values for corresponding task object properties.\n\nDescription\n","obj=createTask(j, functionhandle, numoutputargs, inputargs)","creates a new task object in job j, and returns a reference, obj, to the added task object.","obj=createTask( . . . , \u2018p1\u2019,v1,\u2018p2\u2019,v2, . . . ) adds a task object with the specified property values. If an invalid property name or property value is specified, the object will not be created.","Note that the property value pairs can be in any format supported by the set function, i.e., param-value string pairs, structures, and param-value cell array pairs.\n\nExample\n","% create a job object.","jm=findResource(\u2018jobmanager\u2019);","j=createJob(jm);","% add a task object to be evaluated that generates a 10\u00d710 random matrix.","obj=createTask(j, @rand, {10,10});","% run the job.","submits(j);","% get the output from the task evaluation.","taskoutput=get(obj, \u2018OutputArguments\u2019);","% show the 10\u00d710 random matrix.","disp(taskoutput {1});\n\ndestroy\n\nPurpose\n","Remove a job or task object from its parent and from memory\n\nSyntax\n","Destroy(obj)\n\nArguments\n","obj Job or task object deleted from memory.\n\nDescription\n","destroy(obj) removes the job object reference or task object reference obj from the local session, and removes the object from the job manager memory. When obj is destroyed, it becomes an invalid object. An invalid object should be removed from the workspace with the clear command. If multiple references to an object exist in the workspace, destroying one reference to that object invalidates the remaining references to it. These remaining references should be cleared from the workspace with the clear command. The task objects contained in a job will also be destroyed when a job object is destroyed. This means that any references to those task objects will also be invalid. If obj is an array of job objects and one of the objects cannot be destroyed, the remaining objects in the array will be destroyed and a warning will be returned.\n\nRemarks\n","Because its data is lost when you destroy an object, destroy should be used after output data has been retrieved from a job object.\n\nExample\n","% destroy a job and its tasks.","jm=findResource(\u2018jobmanager\u2019);","j=createJob(jm, \u2018Name\u2019, \u2018myjob\u2019);","t=createTask(j, @grand, {10});","destroys);","clear j","Note that task t is also destroyed as part of job j.\n\ndestroyAllTasks\n\nPurpose\n","Remove all of a job's tasks from the job object and from memory\n\nSyntax\n","destroyAllTasks(obj)\n\nArguments\n","obj Job object whose tasks are deleted.\n\nDescription\n","destroyAllTasks(obj) removes all tasks from the job object obj. The job itself remains, and you can add more tasks to it. (By comparison, using destroy on the job removes the job object entirely.)\n\nfindJob\n\nPurpose\n","Find job objects stored in a job manager\n\nSyntax\n","findJob(jm)","out=findJob(jm)","[pending queued running finished]=findJob(jm)","out=findJob(jm, \u2018p1\u2019, v1, \u2018p2\u2019, v2, . . . )\n\nArguments\n","jm Job manager object in which to find the job.","pending Array of jobs in job manager jm whose State is pending.","queued Array of jobs in job manager jm whose State is queued.","running Array of jobs in job manager jm whose State is running.","finished Array of jobs in job manager jm whose State is finished.","out Array of jobs found in job manager jm.","p1, p2 Job object properties to match.","v1, v2 Values for corresponding object properties.\n\nDescription\n","findJob(jm) prints a list of all of the job objects stored in the job manager jm. Job objects will be categorized by their State property and job objects in the \u2018queued\u2019 state will be displayed in the order in which they are queued, with the next job to execute at the top (first). out=findJob(jm) returns an array, out, of all job objects stored in the job manager jm. Jobs in the array will be ordered by State in the following order: \u2018pending\u2019, \u2018queued\u2019, \u2018running\u2019, \u2018finished\u2019; within the \u2018queued\u2019 state, jobs are listed in the order in which they are queued.","[pending queued running finished]=findJob(jq) returns arrays of all job objects stored in the job manager jm, by state. Jobs in the array queued will be in the order in which they are queued, with the job at queued() being the next to execute. out=findjob(jm, \u2018p1\u2019, v1, \u2018p2\u2019, v2, . . . ) returns an array, out, of job objects whose property names and property values match those passed as parameter-value pairs, p1, v1, p2, v2.","Note that the property value pairs can be in any format supported by the get function, i.e., param-value string pairs, structures, and param-value cell arraypairs. If a structure is used, the structure field names are job object property names and the field values are the requested property values. Jobs in the queued state are returned in the same order as they appear in the job queue service. When a property value is specified, it must use the same format that the get function returns. For example, if get returns the Name property value as MyJob, then findJob will not find that object while searching for a Name property value of myjob.\n\nfindResource\n\nPurpose\n","Find available MATLAB\u00ae-based application resources\n\nSyntax\n","findResource(\u2018type\u2019)","out=findResource(\u2018type\u2019)","out=findResource(\u2018type\u2019, \u2018p1\u2019, v1, \u2018p2\u2019, v2, . . . )\n\nArguments\n","out Object or array of objects returned.","p1, p2 Object properties to match.","v1, v2 Values for corresponding object properties.\n\nDescription\n","findResource(\u2018type\u2019) displays a list of all the available MATLAB\u00ae-based distributed computing application resources of type given by the string type, that have the ability to run a job. Possible types include \u2018jobmanager\u2019, localsession\u2019, \u2018mlworker\u2019. out=findResource(\u2018type\u2019) returns an array, out, containing objects representing all available MATLAB\u00ae-based distributed computing application resources of the given type. out=findResource(\u2018type\u2019,\u2018p1\u2019, v1, \u2018p2\u2019, v2, . . . ) returns an array, out, of resources of the given type whose property names and property values match those passed as parameter-value pairs, p1, v1, p2, v2. Note that the property value pairs can be in any format supported by the get function, i.e., param-value string pairs, structures, and param-value cell array pairs. If a structure is used, the structure field names are object property names and the field values are the requested property values. When a property value is specified, it must use the same format that the get function returns. For example, if get returns the Name property value as MyJobManager, then findResource will not find that object while searching for a Name property value of myjobmanager.\n\nRemarks\n","The only supported types of resources is jobmanager. Note that some parameter-value pairs are queried on the local machine, while others require a call directly to the job manager to query. The parameter-value pairs that require a call to the job manager will take longer to query than those \u2018type\u2019 Type of resource to find that can be queried locally. The properties that are known locally are: Type, Name, HostName, and Address. Note that it is permissible to use parameter-value string pairs, structures, and parameter-value cell array pairs in the same call to findResource.\n\nExample\n","jm1=findResource(\u2018jobmanager\u2019, \u2018Name\u2019, \u2018jobmanager1name\u2019);","jm2=findResource(\u2018jobmanager\u2019, \u2018Name\u2019, \u2018jobmanager2name\u2019);\n\nfindTask\n\nPurpose\n","Get the task objects belonging to a job object\n\nSyntax\n","tasks=findTask(obj)","tasks=findTask(obj, range)","tasks=findTask(obj, \u2018p1\u2019, v1, \u2018p2\u2019, v2, . . . )\n\nArguments\n","obj Job object.","range A scalar or vector list of indexes specifying which tasks to return.\n        \n        ","p1, p2 Task object properties to match.","v1, v2 Values for corresponding object properties.\n\nDescription\n","tasks=findTask(obj) and tasks=findTask(obj, range) get tasks belonging to a job object obj, where range is a scalar or vector list of indexes specifying which tasks to return. tasks=findTask(obj, \u2018p1\u2019, v1, \u2018p2\u2019, v2, . . . ) gets a 1\u00d7N array of task objects belonging to a job object obj. The returned task objects will be only those having the specified property-value pairs. Note that the property value pairs can be in any format supported by the get function, i.e., param-value string pairs, structures, and param-value cell array pairs. If a structure is used, the structure field names are object property names and the field values are the requested property values. When a property value is specified, it must use the same format that the get function returns. For example, if get returns the Name property value as MyTask, then findTask will not find that object while searching for a Name property value of mytask.\n\nRemarks\n","If obj is contained in a remote service, findTask will result in a call to the remote service. This could result in findTask taking a long time to complete, depending on the number of tasks retrieved and the network speed. Also, if the remote service is no longer available, an error will be thrown.","If obj is contained in a remote service, you can issue a ^C (Control-C) while findTask is blocking. This returns control to MATLAB. In this case, another remote call will be necessary to get the data.\n\nExample\n","% create a job object.","jm=findResource(\u2018jobmanager\u2019);","obj=createJob(jm);","% add a task to the job object.","createTask(obj, @rand, {10})","% assign to t the task we just added to obj.","t=findTask(obj, 1)\n\ngetAllOutputArguments\n\nPurpose\n","Retrieve output arguments from evaluation of all tasks in a job object\n\nSyntax\n","data=getAllOutputArguments(obj)\n\nArguments\n","obj Job object whose tasks generate output arguments.","data Cell array of job results.\n\nDescription\n","data=getAllOutputArguments(obj) returns data, the output data contained in the tasks of a finished job. Each element of the 1\u00d7N cell array data contains the output arguments for the corresponding task in the job, that is, each element is a cell array. If no output data is returned for a task, then that element will contain an empty cell array as a placeholder. The order of the elements in data will be the same as the order of the tasks contained in the job.\n\nRemarks\n","Because getAllOutputArguments results in a call to a remote service, it could take a long time to complete, depending on the amount of data being retrieved and the network speed. Also, if the remote service is no longer available, an error will be thrown. You can issue a ^C (control-C) while getAllOutputArguments is blocking. This does not stop the data retrieval, but returns control to MATLAB. In this case, another remote call is necessary to get the data. Note that issuing a call to getAllOutputArguments will not remove the output data from the location where it is stored. To remove the output data, use the destroy function to remove either the task or its parent job object, or use destroyAllTasks.\n\nExample\n","jm=findResource(\u2018jobmanager\u2019);","j=createJob(jm, \u2018Name\u2019, \u2018myjob\u2019);","t=createTask(j, @rand, {10});","submit(j);","data=getAllOutputArguments(t);","% display a 10\u00d710 random matrix","disp(data {1});","destroy(j);\n\nsubmit\n\nPurpose\n","Queue a job in a job queue service\n\nSyntax\n","submit(obj)\n\nArguments\n","obj Job object to be queued.\n\nDescription\n","submit(obj) queues the job object, obj, in the resource where it currently resides. The resource where a job queue resides is determined by how the job was created. A job may reside in the local MATLAB session, in a remote job manager service, or in a remote MATLAB worker service. If submit is called with no output arguments, then it is called asynchronously, that is, the call to submit returns before the job is finished. An exception to this rule is if the job resides in the local MATLAB session, in which case the submit always executes synchronously.\n\nRemarks\n","When a job contained in a job manager is submitted, the job's State property is set to queued, and the job is added to the list of jobs waiting to be executed by the job queue service. The jobs in the waiting list will be executed in a first in, first out manner, that is, the order in which they were submitted.\n\nExample\n","% find a job manager service named jobmanager1.","jm1=findResource(\u2018jobmanager\u2019, \u2018Name\u2019, \u2018jobmanager1\u2019);","% create a job object.","j1=createJob(jm1);","% add a task object to be evaluated for the job.","t1=createTask(j1, @myfunction, {10, 10});","% queue the job object in the job manager.","submits(j1);\n\nProperty Reference\n"]}}}},{"@attributes":{"id":"p-0148","num":"0284"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Job Manager Object Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Property Name","Property Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["HostName","Indicate name of the machine where a job queue exists"]},{"entry":["HostAddress","Indicate the IP address of the host machine where a job"]},{"entry":[{},"queue exists"]},{"entry":["ID","Indicate a job manager object's identifier"]},{"entry":["JobCreatedFcn","Specify the M file function to execute when a job is"]},{"entry":[{},"created in a job queue"]},{"entry":["JobFinishedFcn","Specify the M file function to execute when jobs finish"]},{"entry":[{},"in a job queue"]},{"entry":["JobQueuedFcn","Specify the M file function to execute when jobs are"]},{"entry":[{},"queued"]},{"entry":["JobRunningFcn","Specify the M file function to execute when job are run"]},{"entry":[{},"in a job queue"]},{"entry":["Jobs","Indicate the jobs contained in a job manager"]},{"entry":["Name","Indicate the name of the job manager"]},{"entry":["State","Indicate the current state of the job manager"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0149","num":"0285"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Job Object Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Property Name","Property Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["FinishedFcn","Specify the callback to execute when a job"]},{"entry":[{},"finishes running"]},{"entry":["FinishTime","Indicate when a job finished"]},{"entry":["ID","Indicate a job object's identifier"]},{"entry":["MaximumNumberOfWorkers","Specify maximum number of workers to"]},{"entry":[{},"perform the tasks of a job"]},{"entry":["MinimumNumberOfWorkers","Specify minimum number of workers to"]},{"entry":[{},"perform the tasks of a job"]},{"entry":["Name","Specify a name for a job object"]},{"entry":["QueuedFcn","Specify M file function to execute when"]},{"entry":[{},"job added to queue"]},{"entry":["RestartWorker","Specify whether to restart MATLAB on a"]},{"entry":[{},"worker before it evaluates a task"]},{"entry":["RunningFcn","Specify the M file function to execute"]},{"entry":[{},"when a job or task starts running"]},{"entry":["StartTime","Indicate when a job started running"]},{"entry":["State","Indicate the current state of a job object"]},{"entry":["TaskCreatedFcn","Specify the M file function to execute"]},{"entry":[{},"when a task is created"]},{"entry":["TaskFinishedFcn","Specify the M file function to execute"]},{"entry":[{},"when tasks finish in job queue"]},{"entry":["TaskRunningFcn","Specify M file function to execute"]},{"entry":[{},"when a task is run"]},{"entry":["Tasks","Indicate the tasks contained in a job object"]},{"entry":["Timeout","Specify time limit for completion of a job"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0150","num":"0286"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Task Object Properties"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Property Name","Property Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["CaptureCommandWindowOutput","Specify whether to return command"]},{"entry":[{},"window output"]},{"entry":["CommandWindowOutput","Indicate text produced by execution"]},{"entry":[{},"of task object's function"]},{"entry":["ErrorID","Indicate task error identifier"]},{"entry":["ErrorMessage","Indicate output message from task"]},{"entry":[{},"error"]},{"entry":["FinishedFcn","Specify the callback to execute when"]},{"entry":[{},"a task finishes running"]},{"entry":["FinishTime","Indicate when a task finished"]},{"entry":["Function","Indicate the function called when"]},{"entry":[{},"evaluating a task"]},{"entry":["ID","Indicate a task object's identifier"]},{"entry":["InputArguments","Indicate the input arguments to the"]},{"entry":[{},"task object"]},{"entry":["NumberOfOutputArguments","Indicate the number of arguments"]},{"entry":[{},"returned by the task function"]},{"entry":["OutputArguments","The data returned from the execution"]},{"entry":[{},"of the task"]},{"entry":["RunningFcn","Specify the M file function to execute"]},{"entry":[{},"when a job or task starts running"]},{"entry":["State","Indicate the current state of a task"]},{"entry":[{},"object"]},{"entry":["StartTime","Indicate when a task started running"]},{"entry":["Timeout","Specify time limit for completion of"]},{"entry":[{},"a task"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"In alternative embodiments, the object-oriented interfaces and\/or functional procedures available in the MATLAB\u00ae programming language, may be available in one or more application programming interfaces, and may be available in one or more libraries, software components, scripting languages or other forms of software allowing for the operation of such object-oriented interfaces and functional procedures. One ordinarily skilled in the art will appreciate the various alternative embodiments of the above class definitions, class method and properties, package scope methods, functional procedures and programming instructions that may be applied to manage the distribution of tasks and jobs for distributed technical computing processing of the present invention.","From an overall perspective and in view of the structure, functions and operation of MATLAB\u00ae as described herein, the current invention presents many advantages for distributed, streaming and parallel technical computing processing systems as depicted in . The MATLAB\u00ae-based distributed computing system can handle a wide variety of user configurations from a standalone system to a network of two machines to a network of hundreds of machines, and from a small task granularity to an extremely large task granularity of parallel, and parallel and serial technical computing.","Referring to , the distributed system  supports the delegation of tasks from a technical computing client  to remote technical computing workers A-N leveraging the processing capability of each of the workstations A-N hosting each of the technical computing workers A-N. The tasks are executed independently of each other and do not require the technical computing workers A-B to communicate with each other.","Still referring to , the streaming, or serial, processing system  allows serial processing to occur via multiple technical computing workers A-N on multiple workstations A-N. A technical computing client A submits a job requiring a task to be processed serially from technical computing worker A to technical computing worker B then to technical computing worker N. When technical computing worker A completes its technical computing of the task, technical computing worker A submits the task to technical computing worker B for further processing. In a similar fashion, the task can be submitted to additional technical computing workers N for further processing until the task is complete in accordance with its task definition. The last technical computing worker N to perform technical computing on the task submits the result to the technical computing client .","The streaming processing system  can take advantage of specific workstations A-N that may have faster processors for performing processor intensive portions of technical computing of the task or take advantage of technical computing workers A-N with access to specific data sets or external control instrumentation as required for computation of the task.","In , a parallel system  is depicted which combines the distributed and streaming configuration of the systems ( and ) in . In brief overview, technical computing workers A and B and N can be executing a set of tasks independently of each other. Additionally, these technical computing workers can then submit tasks to other technical computing workers to perform technical computing of a task in a streaming fashion. For example, technical computing worker A can submit a task for further processing to technical computing worker B, and in turn, technical computing worker B can submit the task for further processing by technical computing worker N. The technical computing worker N when it completes processing may return a result back to the automatic task distribution mechanism  or the technical computing client . This configuration provides for great flexibility in determining how to best distribute technical computing tasks for processing based on many factors such as the types and availability of computing devices, network topology, and the nature and complexity of the technical computing problem being solved.","B. Instrument-Based Distributed Computing System","The illustrative embodiment of the present invention provides an instrument-based distributed computing system using the technical computing client and the technical computing worker. The instrument-based distributed computing system includes one or more instruments connected through a network. The instruments may be provided on a PC-based platform or other platform and have capacities to run additional software product, such as the technical computing client and the technical computing worker. The instrument-based distributed computing system may operate in a test environment for testing a unit under test. One of ordinary skill in the art will appreciate that the instrument is illustrative test equipment and the present invention may apply to other test equipment or components, such as a virtual instrument that includes an industry-standard computer or workstation equipped with application software, hardware such as plug-in boards, and driver software, which together perform the functions of traditional instruments.","In the instrument-based distributed computing system, the technical computing client may reside in an instrument or a client device to create a job. The technical computing client then distributes the job to one or more remote technical compute workers for the distributed execution of the job. The technical computing workers may reside in other instruments or workstations on a network. The workers running on the instruments and\/or workstations are available to the technical computing client so that the technical computing client can distribute the job to the workstations and the instruments. The technical computing workers execute the received portion of the job and return the execution results to the technical computing client. As such, the illustrative of the present invention executes a job or a test in a distributed fashion using the instruments and\/or workstations on the network.",{"@attributes":{"id":"p-0160","num":"0296"},"figref":["FIG. 10","FIGS. 1A-9B","FIGS. 12A-12C"],"b":["1000","1000","150","160","170","180","140","150","160","250","260","180","250","1000","150","160","170","180","1000","150","160","170","180"]},"In the illustrative embodiment of , the client , server , workstation  and instrument  are coupled to the network . The client  or instrument  may communicate directly with the workstation  or other instruments  as described above with reference to . The client  or instrument  may communicate with the workstation  or other instruments  via the server , which runs the automatic task distribution mechanism , as described above with reference to . The workstations  or instruments  may or may not communicate with each other depending on the communication topology of the distributed computing system , as described above with reference to .",{"@attributes":{"id":"p-0162","num":"0298"},"figref":"FIG. 11","b":["180","1110","250","270","1120","118","1110","180"]},"The technical computing client  and the technical computing worker  installed on the instrument  may include the MATLAB\u00ae-based distributed computing application  as described above with reference to . The technical computing client  creates a job including one or more tasks. The technical computing client  distributes the job to the technical computing workers for the distributed execution of the job. The technical computing worker  performs technical computing tasks defined by the client . The instrument  may include the technical computing client  and\/or the technical computing worker . If the instrument  is installed with the technical computing client , the instrument  may operate to generate a job and distribute the job to workstations  and\/or other instruments , as the client  does. If the instrument  is installed with the technical computing worker , the instrument  may operate to receive and execute the tasks, as the workstations  do.","The instrument  may include an operating system  that enables users to install their own applications, such as the technical computing client  and the technical computing worker . The operating system  enables the applications to run on the instrument . The instrument  may have, for example, a standard Windows\u00ae operating system so that the users can install their own applications on the instrument . The Windows operating system is an exemplary operating system that can be included in the instrument  and the operating system  may include any other operating systems described above with reference to .","The instrument  may communicate with the client , server , workstation  or other instruments  via the network interface . The network interface  may include any network interfaces described above with reference to . The network interface  may include a bus interface, such as a general purpose interface bus (GPIB) interface. The network interface  may also include any other bus interfaces, such as Universal Serial Bus (USB), Myrinet, Peripheral Component Interconnect (PCI), PCI extended (PCI-X), etc. In particular, the network interface  may include an LXI (LAN extension for instrumentation) interface, which is based on industry standard Ethernet technology.","The instrument  running the workers may have the capability of accelerating the execution of tasks. For example, the instrument may include hardware components, such as FPGA (Field Programmable Gate Array), ASIC (Application Specific Integrated Circuit), DSP (Digital Signal Processor) and CPU (Central Processing Unit), to perform fast calculations of the tasks, such as FFT calculations. In particular, the instrument  may have multiple processors or CPUs to run the workers.","The instrument  may support a GPGPU (General-purpose Computing on Graphics Processing Units) process that uses the GPU (Graphics Processing Units) to perform the computations rather than the CPU. GPU is the mocroprocessor of a graphics card or graphics accelerator) for a computer or game console. GPU is efficient at manipulating and displaying computer graphics, and its parallel structure makes the GPU more effective than typical CPU for a range of complex algorithms. The GPU can also be used for general purposes in non-graphics areas, such as cryptography, data based operations, FFT, neural networks. One of skill in the art will appreciate that the workstations running the workers may support the GPGPU process.",{"@attributes":{"id":"p-0168","num":"0304"},"figref":["FIG. 12A","FIG. 10"],"b":["150","170","180","140","250","150","270","170","180","250","270","170","180","270","170","180","250","150"]},{"@attributes":{"id":"p-0169","num":"0305"},"figref":["FIG. 12B","FIG. 10"],"b":["170","180","140","250","180","270","170","180","250","270","150","180","270","170","180","150"]},{"@attributes":{"id":"p-0170","num":"0306"},"figref":"FIG. 12C","b":["150","170","180","140","190","140","190","190","250","150","180","250","190","190","250","150","180","190","190"]},"The instrument-based distributed computing system can be used in a test environment in the illustrative embodiment. The instrument that contains a computing capability, such as the technical computing client  and the technical computing worker , can perform a test. The computing capability of the instrument is used for processing data to perform a portion of the test defined by a client. The test environment utilizes the computing power of the instrument on a network to conduct a distributed execution of the test. In the description of the illustrative embodiment, a \u201ctest\u201d refers to an action or group of actions that are performed on one or more units under test to verify their parameters and characteristics. The unit under test refers to an entity that can be tested which may range from a single component to a complete system. The unit under test may include software product and\/or hardware devices.",{"@attributes":{"id":"p-0172","num":"0308"},"figref":"FIG. 13","b":["1200","1200","1210","1230","1210","1200","1220","1220","1240","1230","1200","1240","1220","1210","1230","1230","1230","1220"]},"The illustrative embodiment of the present invention may provide a test environment in which the users (or developers) of software tools are able to conduct a test for testing various types of units under test . The test may include one or more test steps, such as a test step for testing a textual program, a test step for testing a graphical program, a test step for testing a function provided in a software tool, a test step for testing a hardware device, etc. As an example, the test includes a MATLAB\u00ae step in which MATLAB\u00ae expressions can be executed. The MATLAB\u00ae step communicates with MATLAB\u00ae installed locally or in a remote computational device to run the expression and returns the result to the test manager . The test steps may also include a Simulink\u00ae step to interact with models, and an Instrument Control (one of MATLAB\u00ae Toolboxes) step to interact with external hardware. Furthermore, a Statistics Toolbox (one of MATLAB\u00ae Toolboxes) step may provide statistical analysis for data procured by other steps. The test steps in the test include discrete actions that are executed during the execution of the test. The test step and test step properties may be deemed a Java function call that generates M-code, and the function call arguments, respectively.",{"@attributes":{"id":"p-0174","num":"0310"},"figref":["FIG. 14","FIGS. 5B-5D","FIGS. 6A-9B"],"b":["150","1302","150","1304","180","170","270","150","170","180","270","1306","1308","1310","150","170","180","1312","150","150","170","180","1314"]},"One of ordinary skill in the art will appreciate that the instrument  may be used as a technical computing client and\/or worker and as an instrumentation tool. In one illustrative embodiment, the instrument  may be used as an instrumentation tool performing part of the test that acts on the information collected by the instrument . In another embodiment, the instrument  may be used as a pure technical computing client or worker utilizing the technical computing functionality of the instrument . In still another embodiment, the instrument  may be used as both a technical computing client\/worker and an instrumentation tool. In this embodiment, the instrument  is used as a traditional instrumentation tool when it is needed to make a measurement, and also used as a technical computing client\/worker when it is needed to compute at least a portion of the test.","In some embodiments, if the instrument  is used as both a technical computing client\/worker and an instrumentation tool, the technical computing functionality and the instrumentation functionality of the instrument  may need to be compromised depending on the capability of the instrument  to support for both of the functionalities concurrently. One exemplary way to compromise these functionalities is to pause\/stop the technical computing functionality when the instrument  is needed to make a measurement. When the measurement is completed, the instrument  can continue to perform the technical computing functionality. One of ordinary skill in the art will appreciate that this is an exemplary way to compromise the functionalities and the functionalities can be compromised in other ways in different embodiments. The technical computing capability of the instrument  can allow users to utilize the additional computational power in the instrument  to perform a fast result calculation of a test in the test environment.","Furthermore, the illustrative embodiment provides for technical programming language constructs to develop program instructions of the jobs and tests to be executed in parallel in multiple technical computing workers. These technical programming language constructs have built-in keywords of the programming language reserved for their functionality. One of these constructs is a distributed array element for technical computing operations executing across multiple technical computing workers. The technical programming language of the parallel technical computing worker of MATLAB\u00ae provides reserved key words and built-in language statements to support distributed arrays to check the current process id of the worker.","In order to provide distributed arrays in a technical computing programming language, an iterator is decomposed into separate iterators for each node or worker that will be processing the distributed array. Each worker is identified by a process id or pid between 1 and the total number of pids, or nproc. For each pid of a worker out of a total numbers of pids, a portion of the distributed array may be processed separately and independently. For example, take the following iterators:\n\n","function [startp,finp]=djays(start,delta,fin,pid,nprocs)","ratio=floor((fin-start)\/delta+1)\/nprocs;","startp=start+ceil((pid\u22121)*ratio)*delta;","finp=start+(ceil(pid*ratio)\u22121)*delta;","For example, with nproc=4 workers, the iterator j=1:10 is decomposed to the following:","j=1:3 on pid=1","j=4:5 on pid=2","j=6:8 on pid=3","j=9:10 on pid=4","In alternative embodiments, other algorithms can be used to determine the decomposition of iterators and the length of iterators to be applied per pid for processing distributed arrays across multiple workers. For example, the decomposition of the iterator may be determined by estimated processing times for each of the pids for its respective portion of the iterator. Or it may be determined by which workers  are not currently executing a program or which workers  are idle or have not previously executed a program. In another example, only two pids may be used for the iteration although several pids may be available. In yet another example, each iterator may be assigned to a specific worker. In other cases, the decomposition of the iterator can be based on one or more operational characteristics of the worker, or of the computing device  running the worker. One ordinarily skilled in the art will appreciate the various permutations and combinations that can occur in decomposing an iterator to process portions of a distributed array in multiple workers.","In the parallel technical computing environment of MATLAB\u00ae, distributed arrays are denoted with the new keyword darray and in case of distributed random arrays, the new keyword drand. Various alternative names for these keywords, or reserved words could be applied. As keywords or reserved words of the programming language of the parallel technical computing environment, they have special meaning as determined by the worker and therefore are built into the language. As such, these keywords are not available as variable or function names.","Distributed arrays are distributed by applying the decomposition algorithm to the last dimension of the array. For example, a 1000-by-1000 array is distributed across 10 processors, or workers, by storing the first 100 columns on the first worker, the second 100 columns on the second worker and so forth. The content of a distributed array on a particular worker is the local portion of the array. For example, if A is a distributed array, then A.loc refers to the portion of A on each worker. For example, with nproc=16, the statement","A=drand(,) % create a distributed random array becomes","A=darray(,)","A.loc=rand(,)","Different random submatrices, or arrays, are generated on each one of the sixteen (16) workers. In another embodiment and for the case of a distributed array representing RGB color coding for images with dimensions of m-by-n-by-3, the decomposition and the distribution of the array occurs along the second dimension so that each worker has a full color strip form the overall image to work on in its local portion. Although the distribution of the distributed array is discussed in terms of column based distribution, various alternative methods can be used to distribute portions of the distributed array among multiple workers. For example, the distributed array can be distributed by rows or a portion of rows and columns. In another example, a portion could be distributed based on a subset of the data having all dimensions of the array. Any type of arbitrary mapping can be applied to map a portion of the distributed array to each of the workers. As such, one ordinarily skilled in the art will recognize the various permutation of distributing portions of a distributed array to each worker.","In another aspect, a distributed array may be cached. That is, an worker may store its portion of the distributed array, e.g., A.loc, but prior to performing operations on the local portion, the worker may still have read access to the other portions of the distributed array. For example, a first worker may be assigned column  of a three column distributed array with other two workers assigned columns  and . The first Worker may have read access to columns  and  prior to performing operations on column  of the array, i.e., read and write access. However, once the first worker performs an operation on its local portion of the distributed array, it may no longer have any access to the other portions of the distributed array. For example, once the first worker performs an operation on column , it no longer will have read access to columns  and  of the distributed array.","For basic element-wise operations like array addition, each worker may perform the operation on its local portion, e.g., A.loc. No communication between the workers is necessary for the processing of the local portion of the distributed array. More complicated operations, such as matrix transpose, matrix multiplication, and various matrix decompositions, may require communications between the workers. These communications can follow a paradigm that iterates over the workers:",{"@attributes":{"id":"p-0196","num":"0336"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"for p = 1:nprocs"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if p =\u2009= pid"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"processor p is in charge of this step"]},{"entry":[{},"send data to other processors"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"do local computation"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"maybe receive data from other processors"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"receive data from p"]},{"entry":[{},"do local computation"]},{"entry":[{},"maybe send data back to p"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"end"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In one aspect, the present invention relates to methods for programmatically providing for distributed array processing as depicted in . In the flow diagram of , method  depicts the processing of a distributed array in execution in multiple workers. At step , a worker is executing a program flow of a program (job or test) invoked for execution. At some point during the program flow, the worker  at step  interprets a distributed array construct in a program statement, such as a program statement comprising the keyword darray. At step , the worker  evaluates the distributed array construct to determine the portion of the distributed array to store locally. As discussed above, the distributed array may be decomposed in a variety of ways. For example, the worker  may store a specific column of the array to perform local processing. After determining and storing the portion of the distributed array, the worker  may perform an operation on this portion of the array. For example, it may perform basic array operations such as addition. After handling the distributed array statement, the program flow continues to other program statements of the program. In another embodiment, prior to performing an operation on the local portion of the array, the worker  may access or obtain data values of other portions of the array that have been cached. Although method  is discussed with regards to one worker, the same flow diagram will apply to multiple workers  running the same program so that at steps ,  and  the worker interpreting the distributed array determines what portion of the array to store and process locally.","Many alterations and modifications may be made by those having ordinary skill in the art without departing from the spirit and scope of the invention. Therefore, it must be expressly understood that the illustrated embodiments have been shown only for the purposes of example and should not be taken as limiting the invention, which is defined by the following claims. These claims are to be read as including what they set forth literally and also those equivalent elements which are insubstantially different, even though not identical in other respects to what is shown and described in the above illustrations."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The foregoing and other objects, aspects, features, and advantages of the invention will become more apparent and may be better understood by referring to the following description taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 2C"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3D"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":["FIG. 5A","FIG. 3A"]},{"@attributes":{"id":"p-0024","num":"0023"},"figref":["FIG. 5B","FIG. 3B"]},{"@attributes":{"id":"p-0025","num":"0024"},"figref":["FIG. 5C","FIG. 5D"]},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6A"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 6B"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 6C"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 8B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIGS. 12A-12C"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":["FIG. 14","FIG. 13"]},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
