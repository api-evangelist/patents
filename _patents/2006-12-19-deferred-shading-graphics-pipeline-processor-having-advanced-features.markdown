---
title: Deferred shading graphics pipeline processor having advanced features
abstract: A deferred shading graphics pipeline processor and method are provided encompassing numerous substructures. Embodiments of the processor and method may include one or more of deferred shading, a tiled frame buffer, and multiple?stage hidden surface removal processing. In the deferred shading graphics pipeline, hidden surface removal is completed before pixel coloring is done. The pipeline processor comprises a command fetch and decode unit, a geometry unit, a mode extraction unit, a sort unit, a setup unit, a cull unit, a mode injection unit, a fragment unit, a texture unit, a Phong lighting unit, a pixel unit, and a backend unit.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07808503&OS=07808503&RS=07808503
owner: Apple Inc.
number: 07808503
owner_city: Cupertino
owner_country: US
publication_date: 20061219
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY","DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION","I. Overview of Deferred Shading Graphics Processor (DSGP) ","II. Deferred Shading Graphics Processor Functional Blocks and Communication and Interaction with Fucntional Blocks and External Devices and Systems","III. Detailed Description of the Command Fetch & Decode Functional Block (CFD) Overview","IV. Detailed Description of the Mode Extraction (MEX) and Mode Injection (MIJ) Functional Blocks","Detailed Description","Alternate Embodiments","V. Detailed Description of the Sort Functional Block (SRT)","VI. Detailed Description of the Setup Functional Block (STP)","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF PREFERRED EMBODIMENTS","VII. Detailed Description of the Cull Functional Block (CUL)","Embodiments","Cull Block Overview","VIII. Detailed Description of the Fragment Functional Block (FRG) Overview","IX. Detailed Description of the Texture Functional Block (TEX)","X. Detailed Description of the Phong Functional Block (PHG)","Embodiments","XI. Detailed Description of the Backend Functional Block (BKE)","XII. Detailed Description of the Geometry Functional Block (GEO)","XIII. Detailed Description of the Pixel Functional Block (PIX)"],"p":["This application is a continuation patent application of U.S. patent application Ser. No. 10\/458,493, filed Jun. 9, 2003 and entitled \u201cDeferred Shading Graphics Pipeline Processor Having Advanced Features\u201d; which is a continuation patent application of U.S. patent application Ser. No. 09\/377,503, filed Aug. 20, 1999 and entitled \u201cDeferred Shading Graphics Pipeline Processor Having Advanced Features\u201d; which claims the benefit under 35 U.S.C. 119(e) of U.S. Provisional Patent Application Ser. No. 60\/097,336, filed Aug. 20, 1998 and entitled GRAPHICS PROCESSOR WITH DEFERRED SHADING; \u201cGraphics Processor With Deferred Shading\u201d; the disclosures of which are hereby incorporated herein in their entireties, and claims the benefit under 35 USC 120 of U.S. patent application Ser. No. 09\/213,990 filed 17 Dec. 1998 entitled HOW TO DO TANGENT SPACE LIGHTING IN A DEFERRED SHADING ARCHITECTURE; each of which is hereby incorporated by reference.","This application is also related to the following U.S. patent applications, each of which are incorporated herein by reference:","Ser. No. 09\/213,990, filed 17 Dec. 1998, entitled HOW TO DO TANGENT SPACE LIGHTING IN A DEFERRED SHADING ARCHITECTURE;","Ser. No. 09\/378,598, filed 20 Aug. 1999, entitled APPARATUS AND METHOD FOR PERFORMING SETUP OPERATIONS IN A 3-D GRAPHICS PIPELINE USING UNIFIED PRIMITIVE DESCRIPTORS;","Ser. No. 09\/378,633, filed 20 Aug. 1999, now U.S. Pat. No. 6,552,723 entitled SYSTEM, APPARATUS AND METHOD FOR SPATIALLY SORTING IMAGE DATA IN A THREE-DIMENSIONAL GRAPHICS PIPELINE;","Ser. No. 09\/378,439, filed 20 Aug. 1999, entitled GRAPHICS PROCESSOR WITH PIPELINE STATE STORAGE AND RETRIEVAL, now U.S. Pat. No. 6,525,737;","Ser. No. 09\/378,408, filed 20 Aug. 1999, entitled METHOD AND APPARATUS FOR GENERATING TEXTURE, now U.S. Pat. No. 6,288,730;","Ser. No. 09\/379,144, filed 20 Aug. 1999, entitled APPARATUS AND METHOD FOR GEOMETRY OPERATIONS IN A 3D GRAPHICS PIPELINE;","Ser. No. 09\/372,137, filed 20 Aug. 1999, entitled APPARATUS AND METHOD FOR FRAGMENT OPERATIONS IN A 3D GRAPHICS PIPELINE;","Ser. No. 09\/378,391, filed 20 Aug. 1999, entitled Method And Apparatus For Performing Conservative Hidden Surface Removal In A Graphics Processor With Deferred Shading, now U.S. Pat. No. 6,476,807;","Ser. No. 09\/378,299, filed 20 Aug. 1999, entitled DEFERRED SHADING GRAPHICS PIPELINE PROCESSOR, now U.S. Pat. No. 6,229,553; and","Ser. No. 10\/358,134, filed 3 Feb. 2003, entitled GRAPHICS PROCESSOR WITH DEFERRED SHADING, hereby incorporated by reference, which is a continuation of Ser. No. 09\/378,637, filed 20 Aug. 1999, entitled DEFERRED SHADING GRAPHICS PIPELINE PROCESSOR, hereby incorporated by reference, which claims the benefit of the filing date of U.S. Provisional Application Ser. No. 60\/097,336, filed 20 Aug. 1999.","This invention relates to computing systems generally, to three-dimensional computer graphics, more particularly, and more most particularly to structure and method for a three-dimensional graphics processor implementing differed shading and other enhanced features.","The Background of the Invention is divided for convenience into several sections which address particular aspects conventional or traditional methods and structures for processing and rendering graphical information. The section headers which appear throughout this description are provided for the convenience of the reader only, as information concerning the invention and the background of the invention are provided throughout the specification.","Three-Dimensional Computer Graphics","Computer graphics is the art and science of generating pictures, images, or other graphical or pictorial information with a computer. Generation of pictures or images, is commonly called rendering. Generally, in three-dimensional (3D) computer graphics, geometry that represents surfaces (or volumes) of objects in a scene is translated into pixels (pasture elements) stored in a frame buffer, and then displayed on a display device. Real-time display devices, such as CRTs used as computer monitors, refresh the display by continuously displaying the image over and over. This refresh usually occurs row-by-row, where each row is called a raster line or scan line. In this document, raster lines are generally numbered from bottom to top, but are displayed in order from top to bottom.","In a 3D animation, a sequence of images is displayed, giving the illusion of motion in three-dimensional space. Interactive 3D computer graphics allows a user to change his viewpoint or change the geometry in real-time, thereby requiring the rendering system to create new images on-the-fly in real-time.","In 3D computer graphics, each renderable object generally has its own local object coordinate system, and therefore needs to be translated (or transformed) from object coordinates to pixel display coordinates. Conceptually, this is a 4-step process: 1) translation (including scaling for size enlargement or shrink) from object coordinates to world coordinates, which is the coordinate system for the entire scene; 2) translation from world coordinates to eye coordinates, based on the viewing point of the scene; 3) translation from eye coordinates to perspective translated eye coordinates, where perspective scaling (farther objects appear smaller) has been performed; and 4) translation from perspective translated eye coordinates to pixel coordinates, also called screen coordinates. Screen coordinates are points in three-dimensional space, and can be in either screen-precision (i.e., pixels) or object-precision (high precision numbers, usually floating-point), as described later. These translation steps can be compressed into one or two steps by precomputing appropriate translation matrices before any translation occurs. Once the geometry is in screen coordinates, it is broken into a set of pixel color values (that is \u201crasterized\u201d) that are stored into the frame buffer. Many techniques are used for generating pixel color values, including Gouraud shading, Phong shading, and texture mapping.","A summary of the prior art rendering process can be found in: \u201cFundamentals of Three-dimensional Computer Graphics\u201d, by Watt, Chapter 5: The Rendering Process, pages 97 to 113, published by Addison-Wesley Publishing Company, Reading, Mass., 1989, reprinted 1991, ISBN 0-201-15442-0 (hereinafter referred to as the Watt Reference), and herein incorporated by reference.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","sub":["obj","obj","obj","eye","eye","eye","screen","screen","screen","screen "]},"Because many different portions of geometry can affect the same pixel, the geometry representing the surfaces closest to the scene viewing point must be determined. Thus, for each pixel, the visible surfaces within the volume subtended by the pixel's area determine the pixel color value, while hidden surfaces are prevented from affecting the pixel. Non-opaque surfaces closer to the viewing point than the closest opaque surface (or surfaces, if an edge of geometry crosses the pixel area) affect the pixel color value, while all other non-opaque surfaces are discarded. In this document, the term \u201coccluded\u201d is used to describe geometry which is hidden by other non-opaque geometry.","Many techniques have been developed to perform visible surface determination, and a survey of these techniques are incorporated herein by reference to: \u201cComputer Graphics: Principles and Practice\u201d, by Foley, van Dam, Feiner, and Hughes, Chapter 15: Visible-Surface Determination, pages 649 to 720, 2nd edition published by Addison-Wesley Publishing Company, Reading, Mass., 1990, reprinted with corrections 1991, ISBN0-201-12110-7 (hereinafter referred to as the Foley Reference). In the Foley Reference, on page 650, the terms \u201cimage-precision\u201d and \u201cobject-precision\u201d are defined: \u201cImage-precision algorithms are typically performed at the resolution of the display device, and determine the visibility at each pixel. Object-precision algorithms are performed at the precision with which each object is defined, and determine the visibility of each object.\u201d","As a rendering process proceeds, most prior art renderers must compute the color value of a given screen pixel multiple times because multiple surfaces intersect the volume subtended by the pixel. The average number of times a pixel needs to be rendered, for a particular scene, is called the depth complexity of the scene. Simple scenes have a depth complexity near unity, while complex scenes can have a depth complexity of ten or twenty. As scene models become more and more complicated, renderers will be required to process scenes of ever increasing depth complexity. Thus, for most renders, the depth complexity of a scene is a measure of the wasted processing. For example, for a scene with a depth complexity of ten, 90% of the computation is wasted on hidden pixels. This wasted computation is typical of hardware renderers that use the simple Z-buffer technique (discussed later herein), generally chosen because it is easily built in hardware. Methods more complicated than the Z Buffer technique have heretofore generally been too complex to build in a cost-effective manner. An important feature of the method and apparatus invention presented here is the avoidance of this wasted computation by eliminating hidden portions of geometry before they are rasterized, while still being simple enough to build in cost-effective hardware.","When a point on a surface (frequently a polygon vertex) is translated to screen coordinates, the point has three coordinates: (1) the x-coordinate in pixel units (generally including a fraction); (2) the y-coordinate in pixel units (generally including a fraction); and (3) the z-coordinate of the point in either eye coordinates, distance from the virtual screen, or some other coordinate system which preserves the relative distance of surfaces from the viewing point. In this document, positive z-coordinate values are used for the \u201clook direction\u201d from the viewing point, and smaller values indicate a position closer to the viewing point.","When a surface is approximated by a set of planar polygons, the vertices of each polygon are translated to screen coordinates. For points in or on the polygon (other than the vertices), the screen coordinates are interpolated from the coordinates of vertices, typically by the processes of edge walking and span interpolation. Thus, a z-coordinate value is generally included in each pixel value (along with the color value) as geometry is rendered.","Generic 3D Graphics Pipeline","Many hardware renderers have been developed, and an example is incorporated herein by reference: \u201cLeo: A System for Cost Effective 3D Shaded Graphics\u201d, by Deering and Nelson, pages 101 to 108 of SIGGRAPH93 Proceedings, 1-6 Aug. 1993, Computer Graphics Proceedings, Annual Conference Series, published by ACM SIGGRAPH, New York, 1993, Soft-cover ISBN 0-201-58889-7 and CD-ROM ISBN 0-201-56997-3, herein incorporated by references and referred to as the Deering Reference). The Deering Reference includes a diagram of a generic 3D graphics pipeline (i.e., a renderer, or a rendering system) which is reproduced here as .","As seen in , the first step within the floating-point intensive functions of the generic 3D graphics pipeline after the data input (Step ) is the transformation step (Step ). The transformation step is also the first step in the outer loop of the flow diagram, and also includes \u201cget next polygon\u201d. The second step, the clip test, checks the polygon to see if it is at least partially contained in the view volume (sometimes shaped as a frustum) (Step ). If the polygon is not in the view volume, it is discarded; otherwise processing continues. The third step is face determination, where polygons facing away from the viewing point are discarded (Step ). Generally, face determination is applied only to objects that are closed volumes. The fourth step, lighting computation, generally includes the set up for Gouraud shading and\/or texture mapping with multiple light sources of various types, but could also be set up for Phong shading or one of many other choices (Step ). The fifth step, clipping, deletes any portion of the polygon that is outside of the view volume because that portion would not project within the rectangular area of the viewing plane (Step ). Generally, polygon clipping is done by splitting the polygon into two smaller polygons that both project within the area of the viewing plane. Polygon clipping is computationally expensive. The sixth step, perspective divide, does perspective correction for the projection of objects onto the viewing plane (Step ). At this point, the points representing vertices of polygons are converted to pixel space coordinates by step seven, the screen space conversion step (Step ). The eighth step (Step ), set up for incremental render, computes the various begin, end, and increment values needed for edge walking and span interpolation (e.g.: x, y, and z-coordinates; RGB color; texture map space u- and v-coordinates; and the like).","Within the drawing intensive functions, edge walking (Step ) incrementally generates horizontal spans for each raster line of the display device by incrementing values from the previously generated span (in the same polygon), thereby \u201cwalking\u201d vertically along opposite edges of the polygon. Similarly, span interpolation (Step ) \u201cwalks\u201d horizontally along a span to generate pixel values, including a z-coordinate value indicating the pixel's distance from the viewing point. Finally, the z-buffered blending also referred to as Testing and Blending (Step ) generates a final pixel color value. The pixel values also include color values, which can be generated by simple Gouraud shading (i.e., interpolation of vertex color values) or by more computationally expensive techniques such as texture mapping (possibly using multiple texture maps blended together), Phong shading (i.e., per-fragment lighting), and\/or bump mapping (perturbing the interpolated surface normal). After drawing intensive functions are completed, a double-buffered MUX output look-up table operation is performed (Step ). In this figure the blocks with rounded corners typically represent functions or process operations, while sharp cornered rectangles typically represent stored data or memory.","By comparing the generated z-coordinate value to the corresponding value stored in the Z Buffer, the z-buffered blend either keeps the new pixel values (if it is closer to the viewing point than previously stored value for that pixel location) by writing it into the frame buffer, or discards the new pixel values (if it is farther). At this step, antialiasing methods can blend the new pixel color with the old pixel color. The z-buffered blend generally includes most of the per-fragment operations, described below.","The generic 3D graphics pipeline includes a double buffered frame buffer, so a double buffered MUX is also included. An output lookup table is included for translating color map values. Finally, digital to analog conversion makes an analog signal for input to the display device.","A major drawback to the generic 3D graphics pipeline is its drawing intensive functions are not deterministic at the pixel level given a fixed number of polygons. That is, given a fixed number of polygons, more pixel-level computation is required as the average polygon size increases. However, the floating-point intensive functions are proportional to the number of polygons, and independent of the average polygon size. Therefore, it is difficult to balance the amount of computational power between the floating-point intensive functions and the drawing intensive functions because this balance depends on the average polygon size.","Prior art Z buffers are based on conventional Random Access Memory (RAM or DRAM), Video RAM (VRAM), or special purpose DRAMs. One example of a special purpose DRAM is presented in \u201cFBRAM: A new Form of Memory Optimized for 3D Graphics\u201d, by Deering, Schlapp, and Lavelle, pages 167 to 174 of SIGGRAPH94 Proceedings, 24-29 Jul. 1994, Computer Graphics Proceedings, Annual Conference Series, published by ACM SIGGRAPH, New York, 1994, Soft-cover ISBN 0201607956, and herein incorporated by reference.","Pipeline State","OpenGL is a software interface to graphics hardware which consists of several hundred functions and procedures that allow a programmer to specify objects and operations to produce graphical images. The objects and operations include appropriate characteristics to produce color images of three-dimensional objects. Most of OpenGL (Version 1.2) assumes or requires a that the graphics hardware include a frame buffer even though the object may be a point, line, polygon, or bitmap, and the operation may be an operation on that object. The general features of OpenGL (just one example of a graphical interface) are described in the reference. \u201cThe OpenGL\u00ae Graphics System: A Specification (Version 1.2) edited by Mark Segal and Kurt Akeley, Version 1.2, March 1998; and hereby incorporated by reference. Although reference is made to OpenGL, the invention is not limited to structures, procedures, or methods which are compatible or consistent with OpenGL, or with any other standard or non-standard graphical interface. Desirably, the inventive structure and method may be implemented in a manner that is consistent with the OpenGL, or other standard graphical interface, so that a data set prepared for one of the standard interfaces may be processed by the inventive structure and method without modification. However, the inventive structure and method provides some features not provided by OpenGL, and even when such generic input\/output is provided, the implementation is provided in a different manner.","The phrase \u201cpipeline state\u201d does not have a single definition in the prior-art. The OpenGL specification, for example, sets forth the type and amount of the graphics rendering machine or pipeline state in terms of items of state and the number of bits and bytes required to store that state information. In the OpenGL definition, pipeline state tends to include object vertex pertinent information including for example, the vertices themselves the vertex normals, and color as well as \u201cnon-vertex\u201d information.","When information is sent into a graphics renderer, at least some object geometry information is provided to describe the scene. Typically, the object or objects are specified in terms of vertex information, where an object is modeled, defined, or otherwise specified by points, lines, or polygons (object primitives) made up of one or more vertices. In simple terms, a vertex is a location in space and may be specified for example by a three-space (x,y,z) coordinate relative to some reference origin. Associated with each vertex is other information, such as a surface normal, color, texture, transparency, and the like information pertaining to the characteristics of the vertex. This information is essentially \u201cper-verte\u201d information. Unfortunately, forcing a one-to-one relationship between incoming information and vertices as a requirement for per-vertex information is unnecessarily restrictive. For example, a color value may be specified in the data stream for a particular vertex and then not respecified in the data stream until the color changes for a subsequent vertex. The color value may still be characterized as per-vertex data even though a color value is not explicitly included in the incoming data stream for each vertex.","Texture mapping presents an interesting example of information or data which could be considered as either per-vertex information or pipeline state information. For each object, one or more texture maps may be specified, each texture map being identified in some manner, such as with a texture coordinate or coordinates. One may consider the texture map to which one is pointing with the texture coordinate as part of the pipeline state while others might argue that it is per-vertex information.","Other information, not related on a one-to-one basis to the geometry object primitives, used by the renderer such as lighting location and intensity, material settings, reflective properties, and other overall rules on which the renderer is operating may more accurately be referred to as pipeline state. One may consider that everything that does not or may not change on a per-vertex basis is pipeline state, but for the reasons described, this is not an entirely unambiguous definition. For example, one may define a particular depth test to be applied to certain objects to be rendered, for example the depth test may require that the z-value be strictly \u201cgreater-than\u201d for some objects and \u201cgreater-than-or-equal-to\u201d for other objects. These particular depth tests which change from time to time, may be considered to be pipeline state at that time. Parameters considered to be renderer (pipeline) state in OpenGL are identified in Section 6.2 of the afore referenced OpenGL Specification (Version 1.2, at pages 193-217).","Essentially then, there are two types of data or information used by the renderer: (1) primitive data which may be thought of as per-vertex data, and (ii) pipeline state data (or simply pipeline state) which is everything else. This distinction should be thought of as a guideline rather than as a specific rule, as there are ways of implementing a graphics renderer treating certain information items as either pipeline state or non-pipeline state.","Per-Fragment Operations","In the generic 3D graphics pipeline, the \u201cz-buffered blend\u201d step actually incorporates many smaller \u201cper-fragment\u201d operational steps. Application Program Interfaces (APIs), such as OpenGL (Open Graphics Library) and D3D, define a set of per-fragment operations (See Chapter 4 of Version 1.2 OpenGL Specification). We briefly review some exemplary OpenGL per-fragment operations so that any generic similarities and differences between the inventive structure and method and conventional structures and procedures can be more readily appreciated.","Under OpenGL, a frame buffer stores a set of pixels as a two-dimensional array. Each picture-element or pixel stored in the frame buffer is simply a set of some number of bits. The number of bits per pixel may vary depending on the particular GL implementation or context.","Corresponding bits from each pixel in the frame buffer are grouped together into a bit plane; each bit plane containing a single bit from each pixel. The bit planes are grouped into several logical buffers referred to as the color, depth, stencil, and accumulation buffers. The color buffer in turn includes what is referred to under OpenGL as the front left buffer, the front right buffer, the back left buffer, the back right buffer, and some additional auxiliary buffers. The values stored in the front buffers are the values typically displayed on a display monitor while the contents of the back buffers and auxiliary buffers are invisible and not displayed. Stereoscopic contexts display both the front left and the front right buffers, while monoscopic contexts display only the front left buffer. In general, the color buffers must have the same number of bit planes, but particular implementations of context may not provide right buffers, back buffers, or auxiliary buffers at all, and an implementation or context may additionally provide or not provide stencil, depth, or accumulation buffers.","Under OpenGL, the color buffers consist of either unsigned integer color indices or R, G, B, and, optionally, a number \u201cA\u201d of unsigned integer values; and the number of bit planes in each of the color buffers, the depth buffer (if provided), the stencil buffer (if provided), and the accumulation buffer (if provided), is fixed and window dependent. If an accumulation buffer is provided, it should have at least as many bit planes per R, G, and B color component as do the color buffers.","A fragment produced by rasterization with window coordinates of (x, y) modifies the pixel in the frame buffer at that location based on a number of tests, parameters, and conditions. Noteworthy among the several tests that are typically performed sequentially beginning with a fragment and its associated data and finishing with the final output stream to the frame buffer are in the order performed (and with some variation among APIs): 1) pixel ownership test; 2) scissor test; 3) alpha test; 4) Color Test; 5) stencil test; 6) depth test; 7) blending; 8) dithering; and 9) logicop. Note that the OpenGL does not provide for an explicit \u201ccolor test\u201d between the alpha test and stencil test. Per-Fragment operations under OpenGL are applied after all the color computations.","In one aspect the invention provides structure and method for a deferred graphics pipeline processor. The pipeline processor advantageously includes one or more of a command fetch and decode unit, geometry unit, a mode extraction unit and a polygon memory, a sort unit and a sort memory, setup unit, a cull unit, a mode injection unit, a fragment unit, a texture unit, a Phong lighting unit, a pixel unit, and backend unit coupled to a frame buffer. Each of these units may also be used independently in connection with other processing schemes and\/or for processing data other than graphical or image data.","In another aspect the invention provides a command fetch and decode unit communicating inputs of data and\/or command from an external computer via a communication channel and converting the inputs into a series of packets, the packets including information items selected from the group consisting of colors, surface normals, texture coordinates, rendering information, lighting, blending modes, and buffer functions.","In still another aspect, the invention provides structure and method for a geometry unit receiving the packets and performing coordinate transformations, decomposition of all polygons into actual or degenerate triangles, viewing volume clipping, and optionally per-vertex lighting and color calculations needed for Gouraud shading.","In still another aspect, the invention provides structure and method for a mode extraction unit and a polygon memory associated with the polygon unit, the mode extraction unit receiving a data stream from the geometry unit and separating the data stream into vertices data which are communicated to a sort unit and non-vertices data which is sent to the polygon memory for storage.","In still another aspect, the invention provides structure and method for a sort unit and a sort memory associated with the sort unit, the sort unit receiving vertices from the mode extraction unit and sorts the resulting points, lines, and triangles by tile, and communicating the sorted geometry by means of a sort block output packet representing a complete primitive in tile-by-tile order, to a setup unit.","In still another aspect, the invention provides structure and method for a setup unit receiving the sort block output packets and calculating spatial derivatives for lines and triangles on a tile-by-tile basis one primitive at a time, and communicating the spatial derivatives in packet form to a cull unit.","In still another aspect, the invention provides structure and method for a cull unit receiving one tile worth of data at a time and having a Magnitude Comparison Content Addressable Memory (MCCAM) Cull sub-unit and a Subpixel Cull sub-unit, the MCCAM Cull sub-unit being operable to discard primitives that are hidden completely by previously processed geometry, and the Subpixel Cull sub-unit processing the remaining primitives which are partly or entirely visible, and determines the visible fragments of those remaining primitives, the Subpixel Cull sub-unit outputting one stamp worth of fragments at a time.","In still another aspect, the invention provides structure and method for a mode injection unit receiving inputs from the cull unit and retrieving mode information including colors and material properties from the Polygon Memory and communicating the mode information to one or more of a fragment unit, a texture unit, a Phong unit, a pixel unit, and a backend unit; at least some of the fragment unit, the texture unit, the Phong unit, the pixel unit, or the backend unit including a mode cache for cache recently used mode information; the mode injection unit maintaining status information identifying the information that is already cached and not sending information that is already cached, thereby reducing communication bandwidth.","In still another aspect, the invention provides structure and method for a fragment unit for interpolating color values for Gouraud shading, interpolating surface normals for Phong shading and texture coordinates for texture mapping, and interpolating surface tangents if bump maps representing texture as a height field gradient are in use; the fragment unit performing perspective corrected interpolation using barycentric coefficients.","In still another aspect, the invention provides structure and method for a texture unit and a texture memory associated with the texture unit; the texture unit applying texture maps stored in the texture memory, to pixel fragments; the textures being MIP-mapped and comprising a series of texture maps at different levels of detail, each map representing the appearance of the texture at a given distance from an eye point; the texture unit performing tri-linear interpolation from the texture maps to produce a texture value for a given pixel fragment that approximate the correct level of detail; the texture unit communicating interpolated texture values to the Phong unit on a per-fragment basis.","In still another aspect, the invention provides structure and method for a Phong lighting unit for performing Phong shading for each pixel fragment using material and lighting information supplied by the mode injection unit, the texture colors from the texture unit, and the surface normal generated by the fragment unit to determine the fragment's apparent color; the Phong block optionally using the interpolated height field gradient from the texture unit to perturb the fragment's surface normal before shading if bump mapping is in use.","In still another aspect, the invention provides structure and method for a pixel unit receiving one stamp worth of fragments at a time, referred to as a Visible Stamp Portion, where each fragment has an independent color value, and performing pixel ownership test, scissor test, alpha test, stencil operations, depth test, blending, dithering and logic operations on each sample in each pixel, and after accumulating a tile worth of finished pixels, blending the samples within each pixel to antialiasthe pixels, and communicating the antialiased pixels to a Backend unit.","In still another aspect, the invention provides structure and method for backend unit coupled to the pixel unit for receiving a tile's worth of pixels at a time from the pixel unit, and storing the pixels into a frame buffer.","Overview of Aspects of the Invention\u2014Top Level Summary","Computer graphics is the art and science of generating pictures or images with a computer. This picture generation is commonly referred to as rendering. The appearance of motion, for example in a 3-Dimensional animation is achieved by displaying a sequence of images. Interactive 3-Dimensional (3D) computer graphics allows a user to change his or her viewpoint or to change the geometry in real-time, thereby requiring the rendering system to create new images on-the-fly in real-time. Therefore, real-time performance in color, with high quality imagery is becoming increasingly important.","The invention is directed to a new graphics processor and method and encompasses numerous substructures including specialized subsystems, subprocessors, devices, architectures, and corresponding procedures. Embodiments of the invention may include one or more of deferred shading, a tiled frame buffer, and multiple-stage hidden surface removal processing, as well as other structures and\/or procedures. In this document, this graphics processor is hereinafter referred to as the DSGP (for Deferred Shading Graphics Processor), or the DSGP pipeline, but is sometimes referred to as the pipeline.","This present invention includes numerous embodiments of the DSGP pipeline. Embodiments of the present invention are designed to provide high-performance 3D graphics with Phong shading, subpixel anti-aliasing, and texture- and bump-mapping in hardware. The DSGP pipeline provides these sophisticated features without sacrificing performance.","The DSGP pipeline can be connected to a computer via a variety of possible interfaces, including but not limited to for example, an Advanced Graphics Port (AGP) and\/or a PCI bus interface, amongst the possible interface choices. VGA and video output are generally also included. Embodiments of the invention supports both OpenGL and Direct3D APIs. The OpenGL specification, entitled \u201cThe OpenGL Graphics System: A Specification (Version 1.2)\u201d by Mark Segal and Kurt Akeley, edited by Jon Leech, is included incorporated by reference.","Several exemplary embodiments or versions of a Deferred Shading Graphics Pipeline are now described.","Versions of the Deferred Shading Graphics Pipeline","Several versions or embodiments of the Deferred Shading Graphics Pipeline are described here, and embodiments having various combinations of features may be implemented. Furthermore, features of the invention may be implemented independently of other features. Most of the important features described above can be applied to all versions of the DSGP pipeline.","Tiles, Stamps, Samples, and Fragments","Each frame (also called a scene or user frame) of 3D graphics primitives is rendered into a 3D window on the display screen. A window consists of a rectangular grid of pixels, and the window is divided into tiles (hereinafter tiles are assumed to be 16\u00d716 pixels, but could be any size). If tiles are not used, then the window is considered to be one tile. Each tile is further divided into stamps (hereinafter stamps are assumed to be 2\u00d72 pixels, thereby resulting in 64 stamps per tile, but stamps could be any size within a tile). Each pixel includes one or more of samples, where each sample has its own color values and z-value (hereinafter, pixels are assumed to include four samples, but any number could be used). A fragment is the collection of samples covered by a primitive within a particular pixel. The term \u201cfragment\u201d is also used to describe the collection of visible samples within a particular primitive and a particular pixel.","Deferred Shading","In ordinary Z-buffer rendering, the renderer calculates the color value (RGB or RGBA) and z value for each pixel of each primitive, then compares the z value of the new pixel with the current z value in the Z-buffer. If the z value comparison indicates the new pixel is \u201cin front of\u201d the existing pixel in the frame buffer, the new pixel overwrites the old one; otherwise, the new pixel is thrown away.","Z-buffer rendering works well and requires no elaborate hardware. However, it typically results in a great deal of wasted processing effort if the scene contains many hidden surfaces. In complex scenes, the renderer may calculate color values for ten or twenty times as many pixels as are visible in the final picture. This means the computational cost of any per-pixel operation\u2014such as Phong shading or texture-mapping\u2014is multiplied by ten or twenty. The number of surfaces per pixel, averaged over an entire frame, is called the depth complexity of the frame. In conventional z-buffered renderers, the depth complexity is a measure of the renderer's inefficiency when rendering a particular frame.","In a pipeline that performs deferred shading, hidden surface removal (HSR) is completed before any pixel coloring is done. The objective of a deferred shading pipeline is to generate pixel colors for only those primitives that appear in the final image (i.e., exact HSR). Deferred shading generally requires the primitives to be accumulated before HSR can begin. For a frame with only opaque primitives, the HSR process determines the single visible primitive at each sample within all the pixels. Once the visible primitive is determined for a sample, then the primitive's color at that sample location is determined. Additional efficiency can be achieved by determining a single per-pixel color for all the samples within the same pixel, rather than computing per-sample colors.","For a frame with at least some alpha blending (as defined in the afore referenced OpenGL specification) of primitives (generally due to transparency), there are some samples that are colored by two or more primitives. This means the HSR process must determine a set of visible primitives per sample.","In some APIs, such as OpenGL, the HSR process can be complicated by other operations (that is by operation other than depth test) that can discard primitives. These other operations include: pixel ownership test, scissor test, alpha test, color test, and stencil test (as described elsewhere in this specification). Some of these operations discard a primitive based on its color (such as alpha test), which is not determined in a deferred shading pipeline until after the HSR process (this is because alpha values are often generated by the texturing process, included in pixel fragment coloring). For example, a primitive that would normally obscure a more distant primitive (generally at a greater z-value) can be discarded by alpha test, thereby causing it to not obscure the more distant primitive. A HSR process that does not take alpha test into account could mistakenly discard the more distant primitive. Hence, there may be an inconsistency between deferred shading and alpha test (similarly, with color test and stencil test); that is, pixel coloring is postponed until after hidden surface removal, but hidden surface removal can depend on pixel colors. Simple solutions to this problem include: 1) eliminating non-depth-dependent tests from the API, such as alpha test, color test, and stencil test, but this potential solution might prevent existing programs from executing properly on the deferred shading pipeline: and 2) having the HSR process do some color generation, only when needed, but this potential solution would complicate the data flow considerably. Therefore, neither of these choices is attractive. A third alternative, called conservative hidden surface removal (CHSR), is one of the important innovations provided by the inventive structure and method. CHSR is described in great detail in subsequent sections of the specification.","Another complication in many APIs is their ability to change the depth test. The standard way of thinking about 3D rendering assumes visible objects are closer than obscured objects (i.e., at lesser z-values), and this is accomplished by selecting a less-than\u201d depth test (i.e., an object is visible if its z-value is \u201cless-than\u201d other geometry). However, most APIs support other depth tests such as: greater-than, less-than, greater-than-or-equal-to, equal, less-than-or-equal-to, less-than, not-equal, and the like algebraic, magnitude, and logical relationships. This essentially \u201cchanges the rules\u201d for what is visible. This complication is compounded by an API allowing the application program to change the depth test within a frame. Different geometry may be subject to drastically different rules for visibility. Hence, the time order of primitives with different rendering rules must be taken into account. For example, in the embodiment illustrated in , three primitives are shown with their respective depth test (only the z dimension is shown in the figure, so this may be considered the case for one sample). If they are rendered in the order A, B, then C, primitive B will be the final visible surface. However, if the primitives are rendered in the order C, B, then A, primitive A will be the final visible surface. This illustrates how a deferred shading pipeline must preserve the time ordering of primitives, and correct pipeline state (for example, the depth test) must be associated with each primitive.","Deferred Shading Graphics Pipeline, First Embodiment (Version 1)","A conventional 3D graphics pipeline is illustrated in . We now describe a first embodiment of the inventive 3D Deferred Shading Graphics Pipeline Version 1 (hereinafter \u201cDSGPv1\u201d), relative to . It will be observed that the inventive pipeline () has been obtained from the generic conventional pipeline () by replacing the drawing intensive functions  with: (1) a scene memory  for storing the pipeline state and primitive data describing each primitive, called scene memory in the figure; (2) an exact hidden surface removal process ; (3) a fragment coloring process ; and (4) a blending process .","The scene memory  stores the primitive data for a frame, along with their attributes, and also stores the various settings of pipeline state throughout the frame. Primitive data includes vertex coordinates, texture coordinates, vertex colors, vertex normals, and the like In DSGPv1, primitive data also includes the data generated by the setup for incremental render, which includes spatial, color, and edge derivatives.","When all the primitives in a frame have been processed by the floating-point intensive functions  and stored into the scene memory , then the HSR process commences. The scene memory  can be double buffered, thereby allowing the HSR process to perform computations on one frame while the floating-point intensive functions perform computations on the next frame. The scene memory can also be triple buffered. The scene memory could also be a scratchpad for the HSR process, storing intermediate results for the HSR process, allowing the HSR process to start before all primitive have been stored into the scene memory.","In the scene memory, every primitive is associated with the pipeline state information that was valid when the primitive was input to the pipeline. The simplest way to associate the pipeline state with each primitive is to include the entire pipeline state within each primitive. However, this would introduce a very large amount of redundant information because much of the pipeline state does not change between most primitives (especially when the primitives are in the same object). The preferred way to store information in the scene memory is to keep separate lists: one list for pipeline state settings and one list for primitives. Furthermore, the pipeline state information can be split into a multiplicity of sub-lists, and additions to each sub-list occurs only when part of the sub-list changes. The preferred way to store primitives is done by storing a series of vertices, along with the connectivity information to re-create the primitives. This preferred way of storing primitives eliminates redundant vertices that would otherwise occur in polygon meshes and line strips.","The HSR process described relative to DSGPv1 is required to be an exact hidden surface removal (EHSR) because it is the only place in the DSGPv1 where hidden surface removal is done. The exact hidden surface removal (EHSR) process  determines precisely which primitives affect the final color of the pixels in the frame buffer. This process accounts for changes in the pipeline state, which introduces various complexities into the process. Most of these complications stem from the per-fragment operations (ownership test, scissor test, alpha test, and the like), as described above. These complications are solved by the innovative conservative hidden surface removal (CHSR) process, described later, so that exact hidden surface removal is not required.","The fragment coloring process generates colors for each sample or group of samples within a pixel. This can include: Gouraud shading, texture mapping, Phong shading, and various other techniques for generating pixel colors. This process is different from edged walk  and span interpolation  because this process must be able to efficiently generate colors for subsections of primitives. That is, a primitive may be partially visible, and therefore, colors need to be generated for only some of its pixels, and edge walk and span interpolation assume the entire primitive must be colored. Furthermore, the HSR process may generate a multiplicity of visible subsections of a primitive, and these may be interspersed in time amongst visible subsections of other primitives. Hence, the fragment coloring process  should be capable of generating color values at random locations within a primitive without needing to do incremental computations along primitive edges or along the x-axis or y-axis.","The blending process  of the inventive embodiment combines the fragment colors together to generate a single color per pixel. In contrast to the conventional z-buffered blend process , this blending process  does not include z-buffer operations because the exact hidden surface removal process  as already determined which primitives are visible at each sample. The blending process  may keep separate color values for each sample, or sample colors may be blended together to make a single color for the entire pixel. If separate color values are kept per sample and are stored separately into the Frame buffer , then final pixel colors are generated from sample colors during the scan out process as data is sent to the digital to analog converter .","Deferred Shading Graphics Pipeline, Second Embodiment (Version 2)","As described above for DSGPv1, the scene memory  stores: (1) primitive data; and (2) pipeline state. In a second embodiment of the Deferred Shading Graphics Pipeline  (Version 2) (DSGPv2), illustrated in , this scene memory  is split into two parts: a spatial memory  part and polygon memory  part. The split of the data is not simply into primitive data and pipeline state data.","In DSGPv2, the part of the pipeline state data needed for HSR is stored into spatial memory , while the rest is stored into polygon memory . Examples of pipeline state needed for HSR include (as defined, for example, in the OpenGL Specification) are DepthFunc, DepthMask, StencilEnable, etc. Examples of pipeline state not needed for HSR include: BlendEquation, BlendFunc, stipple pattern, etc. While the choice or identification of a particular blending function (for example, choosing R=RA+R(1\u2212A)) is not needed for HSR, the HSR process must account for whether the primitive is subject to blending, which generally means the primitive is treated as not being able to fully occlude prior geometry. Similarly, the HSR process must account for whether the primitive is subject to scissor test, alpha test, color test, stencil test, and other per-fragment operations.","Primitive data is also split. The part of the primitive data needed for HSR is stored into spatial memory , and the rest of the primitive data is stored into polygon memory . The part of primitive data needed for HSR includes vertex locations and spatial derivatives (i.e., \u03b4z\/\u03b4x, \u03b4z\/\u03b4y, dx\/dy for edges, etc.). The part of primitive data not needed for HSR includes vertex colors, texture coordinates, color derivatives, etc. If per-fragment lighting is performed in the pipeline, the entire lighting equation is applied to every fragment. But in a deferred shading pipeline, only visible fragments require lighting calculations. In this case, the polygon memory may also include vertex normals, vertex eye coordinates, vertex surface tangents, vertex binormals, spatial derivatives of all these attributes, and other per-primitive lighting information.","During the HSR process, a primitive's spatial attributes are accessed repeatedly, especially if the HSR process is done on a per-tile basis. Splitting the scene memory  into spatial memory  and polygon memory  has the advantage of reducing total memory bandwidth.","The output from setup for incremental render  is input to the spatial data separation process , which stores all the data needed for HSR into spatial memory  and the rest of the data into polygon memory . The EHSR process  receives primitive spatial data (e.g., vertex screen coordinates, spatial derivatives, etc.) and the part of the pipeline state needed for HSR (including all control bits for the per-fragment testing operations).","When visible fragments are output from the EHSR , the data matching process  matches the vertex state and pipeline state with visible fragments, and tile information is stored in tile buffers . The remainder of the pipeline is primarily concerned with the scan out process including sample to\/from pixel conversion , reading and writing to the frame buffer, double buffered MUX output look-up, and digital to analog (D\/A) conversion of the data stored in the frame buffer to the actual analog display device signal values.","Deferred Shading Graphics Pipeline, Third Embodiment (Version 3)","In a third embodiment of the Deferred Shading Graphics Pipeline (Version 3) (DSGPv3), illustrated in , the scene memory  is still split into two parts (a spatial memory  and polygon memory ) and in addition the setup for incremental render  is replaced by a spatial setup which occurs after data separation and prior to exact hidden surface removal. The remainder of the pipeline structure and processes are unchanged from those already described relative to the first embodiment.","Deferred Shading Graphics Pipeline, Fourth Embodiment (Version 4)","In a fourth embodiment of the Deferred Shading Graphics Pipeline (Version 4) (DSGPv4), illustrated in , the exact hidden surface removal of the third embodiment () is replace by a conservative hidden surface removal structure and procedure and a down-stream z-buffered blend replaces the blending procedure.","Deferred Shading Graphics Pipeline, Fifth Embodiment (Version 5)","In a fifth embodiment of the Deferred Shading Graphics Pipeline (Version 5) (DSGPv5), illustrated in , exact hidden surface removal is used as in the third embodiment, however, the tiling is added, and a tile sorting procedure is added after data separation, and the read is by tile prior to spatial setup. In addition, the polygon memory of the first three embodiments is replaced with a state memory.","Deferred Shading Graphics Pipeline, Sixth Embodiment (Version 6)","In a sixth embodiment of the Deferred Shading Graphics Pipeline (Version 6) (DSGPv6), illustrated in , the exact hidden surface removal of the fifth embodiment () is replaced with a conservative hidden surface removal, and the downstream blending of the fifth embodiment is replaced with a z-buffered blending (Testing & Blending). This sixth embodiment is preferred because it incorporates several of the beneficial features provided by the inventive structure and method including: a two-part scene memory, primitive data splitting or separation, spatial setup, tiling and per tile processing, conservative hidden surface removal, and z-buffered blending (Testing & Blending), to name a few features.","Other Possible Embodiments (Versions)","It should be noted that although several exemplary embodiments of the inventive Graphics Pipeline have been shown and described relative to , those workers having ordinary skill in the art in light of the description provided here will readily appreciate that the inventive structures and procedures may be implemented in different combinations and permutations to provide other embodiments of the invention, and that the invention is not limited to the particular combinations specifically identified here.","Overviews of Important Innovations","The pipeline renders primitives, and the invention is described relative to a set of renderable primitives that include: 1) triangles, 2) lines, and 3) points. Polygons with more than three vertices are divided into triangles in the Geometry block, but the DSGP pipeline could be easily modified to render quadrilaterals or polygons with more sides. Therefore, since the pipeline can render any polygon once it is broken up into triangles, the inventive renderer effectively renders any polygon primitive.","To identify what part of a 3D window on the display screen a given primitive may affect, the pipeline divides the 3D window being drawn into a series of smaller regions, called tiles and stamps. The pipeline performs deferred shading, in which pixel colors are not determined until after hidden-surface removal. The use of a Magnitude Comparison Content Addressable Memory (MCCAM) allows the pipeline to perform hidden geometry culling efficiently.","Conservative Deferred Shading","One of the central ideas or inventive concepts provided by the invention pertains to Conservative Hidden Surface Removal (CHSR). The CHSR processes each primitive in time order and, for each sample that a primitive touches, makes conservative decision based on the various API state variables, such at depth test and alpha test. One of the important features of the CHSR process is that color computation does not need to be done during hidden surface removal even though non-depth-dependent tests from the API, such as alpha test, color test, and stencil test can be performed by the DSGP pipeline. The CHSR process can be considered a finite state machine (FSM) per sample. Hereinafter, each per-sample FSM is called a sample finite state machine (SFSM). Each SFSM maintains per-sample data including: (1) z-coordinate information; (2) primitive information (any information needed to generate the primitive's color at that sample or pixel); and (3) one or more sample state bits (for example, these bits could designate the z-value or z-values to be accurate or conservative). While multiple z-values per sample can be easily used, multiple sets of primitive information per sample would be expensive. Hereinafter, it is assumed that the SFSM maintains primitive information for one primitive. The SFSM may also maintain transparency information, which is used for sorted transparencies, described in the next section.","CHSR and Alpha Test","As an example of the CHSR process dealing with alpha test, consider the diagrammatic illustration of , particularly . This diagram illustrates the rendering of six primitives (Primitives A, B, C, D, E, and F) at different z-coordinate locations for a particular sample, rendered in the following order (starting with a \u201cdepth clear\u201d and with \u201cdepth test\u201d set to less-than): primitives A, B, and C (with \u201calpha test\u201d disabled); primitive D (with \u201calpha test\u201d enabled); and primitives E and F (with \u201calpha test\u201d disabled). We note from the illustration that Z>Z>Z>Z>Z>Z, such that primitive A is at the greatest z-coordinate distance. We also note that alpha test is enabled for primitive D, but disabled for each of the other primitives.","Recall from the earlier description of CHSR, that the CHSR process may be considered to be a sample finite state machine (SFSM). The steps for rendering these six primitives under the conservative hidden surface removal process with alpha test are as follows:","Step 1: The depth clear causes the following result in each sample finite state machine (SFSM): 1) z-values are initialized to the maximum value; 2) primitive information is cleared; and 3) sample state bits are set to indicate the z-value is accurate.","Step 2: When primitive A is processed by the SFSM, the primitive is kept (i.e., it becomes the current best guess for the visible surface), and this causes the SFSM to store: 1) the z-value zas the \u201cnear\u201d z-value; 2) primitive information needed to color primitive A; and 3) the z-value (z) is labeled as accurate.","Step 3: When primitive B is processed by the SFSM, the primitive is kept (its z-value is less-than that of primitive A), and this causes the SFSM to store: 1) the z-value zas the \u201cnear\u201d z-value (zis discarded); 2) primitive information needed to color primitive B (primitive A's information is discarded); and 3) the z-value (z) is labeled as accurate.","Step 4: When primitive C is processed by the SFSM the primitive is discarded (i.e., it is obscured by the current best guess for the visible surface, primitive B), and the SFSM data is not changed.","Step 5: When primitive D (which has alpha test enabled) is processed by the SFSM, the primitive's visibility can not be determined because it is closer than primitive B and because its alpha value is unknown at the time the SFSM operates. Because a decision can not be made as to which primitive would end up being visible (either primitive B or primitive D) primitive B is sent down the pipeline (to have its colors generated) and primitive D is kept. Hereinafter, this is called \u201cearly dispatch\u201d of primitive B. When processing of primitive D has been completed, the SFSM stores: 1) the \u201cnear\u201d z-value is zand the \u201cfar\u201d z-value is z; 2) primitive information needed to color primitive D (primitive B's information has undergone early dispatch); and 3) the z-values are labeled as conservative (because both a near and far are being maintained). In this condition, the SFSM can determine that a piece of geometry closer than zobscures previous geometry, geometry farther than zis obscured, and geometry between zand zis indeterminate and must be assumed to be visible (hence a conservative assumption is made). When an SFSM is in the conservative state and it contains valid primitive information, the SFSM method considers the depth value of the stored primitive information to be the near depth value.","Step 6: When primitive E (which has alpha test disabled) is processed by the SFSM, the primitive's visibility can not be determined because it is between the near and far z-values (i.e., between zand z. However, primitive E is not sent down the pipeline at this time because it could result in the primitives reaching the z-buffered blend (later described as part of the Pixel Block in the preferred embodiment) out of correct time order. Therefore, primitive D is sent down the pipeline to preserve the time ordering. When processing of primitive E has been completed, the SFSM stores: 1) the \u201cnear\u201d z-value is zand the \u201cfar\u201d z-value is z(note these have not changed, and zis not kept); 2) primitive information needed to color primitive E (primitive D's information has undergone early dispatch); and 3) the z-values are labeled as conservative (because both a near and far are being maintained).","Step 7: When primitive F is processed by the SFSM, the primitive is kept (its z-value is less-than that of the near z-value), and this causes the SFSM to store: 1) the z-value zas the \u201cnear\u201d z-value (zand zare discarded); 2) primitive information needed to color primitive F (primitive E's information is discarded); and 3) the z-value (z) is labeled as accurate.","Step 8: When all the geometry that touches the tile has been processed (or, in the case there are no tiles, when all the geometry in the frame has been processed), any valid primitive information is sent down the pipeline. In this case, primitive F's information is sent. This is the end-of-tile (or end-of-frame) dispatch, and not an early dispatch.","In summary of this exemplary CHSR process, primitives A through F have been processed, and primitives B, D, and F have been sent down the pipeline. To resolve the visibility of B, D, and F, a z-buffered blend (in the Pixel Block in the preferred embodiment) is included near the end of the pipeline. In this example, only the color primitive F is used for the sample.","CHSR and Stencil Test","In the preferred embodiment of the CHSR process, all stencil operations are done near the end of the pipeline (in the z-buffered blend, called the Pixel Block in the preferred embodiment), and therefore, stencil values are not available to the CSHR method (that takes place in the Cull Block of the preferred embodiment) because they are kept in the frame buffer. While it is possible for the stencil values to be transmitted from the frame buffer for use in the CHSR process, this would generally require a long latency path that would reduce performance. The stencil values can not be accurately maintained within the CHSR process because, in APIs such as OpenGL, the stencil test is performed after alpha test, and the results of alpha test are not known to the CHSR process, which means input to the stencil test can not be accurately modeled. Furthermore, renderers maintain stencil values over many frames (as opposed to depth values that are generally cleared at the start of each frame), and these stencil values are stored in the frame buffer. Because of all this, the CHSR process utilizes a conservative approach to dealing with stencil operations. If a primitive can affect the stencil values in the frame buffer, then the primitive is always sent down the pipeline (hereinafter, this is called a \u201cCullFlushOverlap\u201d, and is indicated by the assertion of the signal CullFlushOverlap in the Cull Block) because stencil operations occur before the depth test (see OpenGL specification). A CuliFlushOverlap condition sets the SFSM to its most conservative state.","As another possibility, if the stencil reference value (see OpenGL specification) is changed and the stencil test is enabled and configured to discard sample values based on the stencil values in the frame buffer, then all the valid primitive information in the SFSMs are sent down the pipeline (hereinafter, this is called a \u201cCullFlushAll\u201d, and is indicated by the assertion of the signal CullFlushAll in the Cull Block) and the z-values are set to their maximum value. This \u201cflushing\u201d is needed because changing the stencil reference value effectively changes the \u201cvisibility rules\u201d in the z-buffered blend (or Pixel Block)","As an example of the CHSR process dealing with stencil test (see OpenGL specification), consider the diagrammatic illustration of , which has two primitives (primitives A and C) covering four particular samples (with corresponding SFSMs, labeled SFSM through SFSM) and an additional primitive (primitive B) covering two of those four samples. The three primitives are rendered in the following order (starting with a depth clear and with depth test set to less-than): primitive A (with stencil test disabled); primitive B (with stencil test enabled and StencilOp set to \u201cREPLACE\u201d, see OpenGL specification); and primitive C (with stencil test disabled). The steps are as follows:","Step 1: The depth clear causes the following in each of the four SFSMs in this example: 1) z-values are initialized to the maximum value; 2) primitive information is cleared; and 3) sample state bits are set to indicate the z-value is accurate.","Step 2: When primitive A is processed by each SFSM, the primitive is kept (i.e., it becomes the current best guess for the visible surface), and this causes the four SFSMs to store: 1) their corresponding z-values (either z, z, z, or zrespectively) as the \u201cnear\u201d z-value; 2) primitive information needed to color primitive A; and 3) the z-values in each SFSM are labeled as accurate.","Step 3: When primitive B is processed by the SFSMs, only samples  and  are affected, causing SFSM and SFSM to be unaffected and causing SFSM and SFSM to be updated as follows: 1) the far z-values are set to the maximum value and the near z-values are set to the minimum value; 2) primitive information for primitives A and B are sent down the pipeline; and 3) sample state bits are set to indicate the z-values are conservative.","Step 4: When primitive C is processed by each SFSM, the primitive is kept, but the SFSMs do not all handle the primitive the same way. In SFSM and SFSM, the state is updated as: 1) zand zbecome the \u201cnear\u201d z-values (zand zare discarded); 2) primitive information needed to color primitive C (primitive A's information is discarded); and 3) the z-values are labeled as accurate. In SFSM and SFSM, the state is updated as: 1) zand zbecome the \u201cfar\u201d z-values (the near z-values are kept); 2) primitive information needed to color primitive C; and 3) the z-values remain labeled as conservative.","In summary of this example CHSR process, primitives A through C have been processed, and all the primitives were sent down the pipeline, but not in all the samples. To resolve the visibility, a z-buffered blend (in the Pixel Block in the preferred embodiment) is included near the end of the pipeline. Multiple samples were shown in this example to illustrate that CullFlushOverlap \u201cflushes\u201d selected samples while leaving others unaffected.","CHSR and Alpha Blending","Alpha blending is used to combine the colors of two primitives into one color. However, the primitives are still subject to the depth test for the updating of the z-values.","As an example of the CHSR process dealing with alpha blending, consider , which has four primitives (primitives A, B, C, and D) for a particular sample, rendered in the following order (starting with a depth clear and with depth test set to less-than): primitive A (with alpha blending disabled); primitives B and C (with alpha blending enabled); and primitive D (with alpha blending disabled). The steps are as follows:","Step 1: The depth clear causes the following in each CHSR SFSM: 1) z-values are initialized to the maximum value; 2) primitive information is cleared; and 3) sample state bits are set to indicate the z-value is accurate.","Step 2: When primitive A is processed by the SFSM, the primitive is kept (i.e., it becomes the current best guess for the visible surface), and this causes the SFSM to store: 1) the z-value zas the \u201cnear\u201d z-value; 2) primitive information needed to color primitive A; and 3) the z-value is labeled as accurate.","Step 3: When primitive B is processed by the SFSM, the primitive is kept (because its z-value is less-than that of primitive A), and this causes the SFSM to store: 1) the z-value zas the \u201cnear\u201d z-value (zis discarded); 2) primitive information needed to color primitive B (primitive A's information is sent down the pipeline); and 3) the z-value (z) is labeled as accurate. Primitive A is sent down the pipeline because, at this point in the rendering process, the color of primitive B is to be blended with primitive A. This preserves the time order of the primitives as they are sent down the pipeline.","Step 4: When primitive C is processed by the SFSM, the primitive is discarded (i.e., it is obscured by the current best guess for the visible surface, primitive B), and the SFSM data is not changed. Note that if primitives B and C need to be rendered as transparent surfaces, then primitive C should not be hidden by primitive B. This could be accomplished by turning off the depth mask while primitive B is being rendered, but for transparency blending to be correct, the surfaces should be blended in either front-to-back or back-to-front order.","If the depth mask (see OpenGL specification) is disabled, writing to the depth buffer (i.e., saving z-values) is not performed; however, the depth test is still performed. In this example, if the depth mask is disabled for primitive B, then the value zis not saved in the SFSM. Subsequently, primitive C would then be considered visible because its z-value would be compared to z.","In summary of this example CHSR process, primitives A through D have been processed, and all the primitives were sent down the pipeline, but not in all the samples. To resolve the visibility, a z-buffered blend (in the Pixel Block in the preferred embodiment) is included near the end of the pipeline. Multiple samples were shown in this example to illustrate that CullFlushOverlap \u201cflushes\u201d selected samples while leaving others unaffected.","CHSR and Greater-than Depth Test","Implementation of the Conservative Hidden Surface Removal procedure, advantageously maintains compatibility with other standard APIs, such as OpenGL. Recall that one complication of many APIs is their ability to change the depth test. Recall that the standard way of thinking about 3D rendering assumes visible objects are closer than obscured objects (i.e., at lesser z-values), and this is accomplished by selecting a \u201cless-than\u201d depth test (i.e., an object is visible if its z-value is \u201cless-than\u201d other geometry). Recall also, however, that most APIs support other depth tests, which may change within a frame, such as: greater-than, less-than, greater-than-or-equal-to, equal, less-than-or-equal-to, less-than, not-equal, and the like algebraic, magnitude, and logical relationships. This essentially dynamically \u201cchanges the rules\u201d for what is visible, and as a result, the time order of primitives with different rendering rules must be taken into account.","In the case of the inventive conservative hidden surface removal, different or additional procedures are advantageously implemented for reasons described below, to maintain compatibility with other standard APIs when a \u201cgreater-than\u201d depth test is used. Those workers having ordinary skill in the art will also realize that analogous changes may advantageously be employed if the depth test is greater-than-or-equal-to, or other functional relationship that would otherwise result in the anomalies described.","We note further that with a conventional non-deferred shader, one executes a sequence of rules for every geometry item and then look to see the final rendered result. By comparison, in embodiments of the inventive deferred shader, that conventional paradigm is broken. The inventive structure and method anticipate or predict what geometry will actually affect the final values in the frame buffer without having to make or generate all the colors for every pixel inside of every piece of geometry. In principle, the spatial position of the geometry is examined, and a determination is made for any particular sample, the one geometry item that affects the final color in the z-buffer, and then generate only that color.","Additional Considerations for the CHSR Process","Samples are done in parallel, and generally all the samples in all the pixels within a stamp are done in parallel. Hence, if one stamp can be processed per clock cycle (and there are 4 pixels per stamp and 4 samples per pixel), then 16 samples are processed per clock cycle. A \u201cstamp\u201d defines the number of pixels and samples processed at one time. This per-stamp processing is generally pipelined, with pipeline stalls injected if a stamp needs to be processed again before the same stamp (from a previous primitive) has completed (that is, unless out-of-order stamp processing can be handled).","If there are no early dispatches are needed, then only end-of-tile dispatches are needed. This is the case when all the geometry in a tile is opaque and there are no stencil tests or operations and there are no alpha tested primitives that could be visible.","The primitive information in each SFSM can be replaced by a pointer into a memory where all the primitive information is stored. As described in later in the preferred embodiment, the Color Pointer is used to point to a primitive's information in Polygon Memory.","As an alternative, only the far z-value could be kept (the near z-value is not kept), thereby reducing data storage, but requiring the sample state bits to remain \u201cconservative\u201d after primitive F and also causing primitive E to be sent down the pipeline because it would not be known whether primitive E is in front or behind primitive F.","As an alternative to maintaining both a near z-value and a far z-value, only the far z-value could be kept, thereby reducing data storage, but requiring the sample state bits to remain \u201cconservative\u201d when they could have been labeled \u201caccurate\u201d, and also causing additional samples to be dispatched down the pipeline. In the first CHSR example above (the one including alpha test), the sample state bits would remain \u201cconservative\u201d after primitive F, and also, primitive E would be sent down the pipeline because it would not be known whether primitive E is in front or behind primitive F due to the lack of the near z-value.","Processing stamps has greater efficiency than simply allowing for SFSMs to operate in parallel on a stamp-by-stamp basis. Stamps are also used to reduce the number of data packets transmitted down the pipeline. That is, when one sample within a stamp is dispatched (either early dispatch or end-of-tile dispatch), other samples within the same stamp and the same primitive are also dispatched (such a joint dispatch is hereinafter called a Visible Stamp Portion, or VSP). In the second CHSR example above (the one including stencil test), if all four samples were in the same stamp, then the early dispatching of samples  and  would cause early dispatching of samples  and . While this causes more samples to be sent down the pipeline and appear to increase the amount of color computation, it does not (in general) cause a net increase, but rather a net decrease in color computation. This is due to the spatial coherence within a pixel (i.e., samples within the same pixel tend to be either visible together or hidden together) and a tendency for the edges of polygons with alpha test, color test, stencil test, and\/or alpha blending to potentially split otherwise spatially coherent stamps. That is, sending additional samples down the pipeline when they do not appreciably increase the computational load is more than offset by reducing the total number of VSPs that need to be sent. In the second CHSR example above, if all the samples are in the same stamp, then the same number of VSPs would be generated.","In the case of alpha test, if alpha values for a primitive arise only from the alpha values at the vertices (not from other places such as texturing), then a simplified alpha test can be done for entire primitives. That is, the vertex processing block (called GEO in later sections) can determine when any interpolation of the vertex alpha values would be guaranteed to pass the alpha test, and for that primitive, disable the alpha test. This can not be done if the alpha values can not be determined before CHSR is performed.","If a frame does not start with depth clear, then the SFSMs are set to their most conservative state (with near z-values at the minimum and far z-values at the maximum).","In the preferred embodiment, the CHSR process is performed in the Cull Block.","Hardware Sorting by Tile, including Pipeline State Information","In the inventive structure and method, we note that time-order is preserved within each tile, including preserving time-order of pipeline state information. Clear packets are also used. In embodiments of the invention, the sorting is performed in hardware and RAMBUS memories advantageously permit dualoct storage of one vertex. For sorted transparency mode, guaranteed opaque geometry (that is, geometry that is known to obscure more distant geometry) is read out of Sort Memory in the first pass. In subsequent passes, the rest of the geometry is read once in each subsequent pass. In the preferred embodiment, the tile sorting method is performed in the Sort Block.","All vertices and relevant mode packets or state information packets are stored as a time order linear list. For each tile that's touched by a primitive, a pointer is added to the vertex in that linear list that completes the primitive. For example, a triangle primitive is defined by 3 vertices, and a pointer would be added to the (third) vertex in the linear list to complete the triangle primitive. Other schemes that use the first vertex rather than the third vertex may alternatively be implemented.","In essence, a pointer is used to point to one of the vertices in the primitive, with adequate information for finding the other vertices in the primitive. When it's time to read these primitives out, the entire primitive can be reconstructed from the vertices and pointers. Each tile is a list of pointers that point to vertices and permit recreation of the primitive from the list. This approach permits all of the primitives to be stored, even those sharing a vertex with another primitive, yet only storing each vertex once.","In one embodiment of the inventive procedure, one list per tile is maintained. We do not store the primitive in the list, but instead the list stores pointers to the primitives. These pointers are actually pointing to one of the primitives, and is a pointer into one of the vertices in the primitive, and the pointer also includes information adequate to find the other vertices in the same primitive. This sorting structure is advantageously implemented in hardware using the structure comprising three storage structures, a data storage, a tile pointer storage, and a mode pointer storage. For a given tile, the goal is to recreate the time-order sequence of primitives that touch the particular tile being processed, but ignore the primitives that don't touch the tile. We earlier extracted the modes and stored them separately, now we want to inject the mode packets into this stream of primitives at the right place. We note further that it is not enough to simply extract the mode packet at one stage and then reinject it at another stage, because the mode packet will be needed for processing the primitive, which may overly more than one tile. Therefore, the mode packets must be reassociated with all of the relevant tiles at the appropriate times.","One simple approach would be to write a pointer to the mode packet into every tile list. During subsequent reads of this list, it would be easy to access the mode packet address and read the appropriate mode data. However, this approach is disadvantageous because of the cost associated with writing the pointer to all or the tiles. In the inventive procedure, during processing of each tile, we read an entry from the appropriate tile pointer list and if we have read (fetched) the mode data for that vertex and sent it along, we merely retrieve the vertex from the data storage and send it down the pipeline; however, in the even that the mode data has changed between the last vertex retrieved and the next sequential vertex in the tile pointer list, then the mode data is fetched from the data storage and sent down the pipeline before the next vertex is sent so that the appropriate mode data is available when the vertex arrives. We note that entries in the mode pointer list identify at which vertex the mode changes. In one embodiment, entries in the mode pointer store the first vertex for which the mode data pertains, however, alternative procedures, such as storing the last vertex for which the mode data applies could be used so long as consistent rules are followed.","Two Modes of DSGP Operation","The DSGP can operate in two distinct modes: 1) Time Order Mode, and 2) Sorted Transparency Mode. Time Order Mode is described above, and is designed to preserve, within any particular tile, the same temporal sequence of primitives. The Sorted Transparency mode is described immediately below. In the preferred embodiment, the control of the pipeline operating mode is done in the Sort Block.","The Sort Block is located in the pipeline between a Mode Extraction Unit (MEX) and Setup (STP) unit. Sort Block operates primarily to take geometry scattered around the display window and sort it into tiles. Sort Block also manages the Sort Memory, which stores all the geometry from the entire scene before it is rasterized, along with some mode information. Sort memory comprises a double-buffered list of vertices and modes. One page collects a scene's geometry (vertex by vertex and mode by mode), while the other page is sending its geometry (primitive by primitive and mode by mode) down the rest of the pipeline.","When a page in sort memory is being written, vertices and modes are written sequentially into the sort memory as they are received by the sort block. When a page is read from sort memory, the read is done on a tile-by-tile basis, and the read process operates in two modes: (1) time order mode, and (2) sorted transparency mode.","Time-Ordered Mode","In time ordered mode, time order of vertices and modes are preserved within each tile, where a tile is a portion of the display window bounded horizontally and vertically. By time order preserved, we mean that for a given tile, vertices and modes are read in the same order as they are written.","Sorted Transparency Mode","In sorted transparency mode, reading of each tile is divided into multiple passes, where, in the first pass, guaranteed opaque geometry is output from the sort block, and in subsequent passes, potentially transparent geometry is output from the sort block. Within each sorted transparency mode pass, the time ordering is preserved, and mode date is inserted in its correct time-order location. Sorted transparency mode by be performed in either back-to-front or front-to-back order. In the preferred embodiment, the sorted transparency method is performed jointly by the Sort Block and the Cull Block.","Multiple-Step Hidden Surface Removal","Conventionally hidden surfaces are removed using either an \u201cexact\u201d hidden surface removal procedure, or using z-buffers. In one embodiment of the inventive structure and method, a two-step approach is implemented wherein a (i) \u201cconservative\u201d hidden surface removal is followed by (ii) a z-buffer based procedure. In a different embodiment, a three-step approach is implemented: (i) a particular spatial Cull procedure, (ii) conservative hidden surface removal, and (iii) z-buffer. Various embodiments of conservative hidden surface removal (CHSR) has already been described elsewhere in this disclosure.","Pipeline State Preservation and Caching","Each vertex includes a color pointer, and as vertices are received, the vertices including the color pointer are stored in sort memory data storage. The color pointer is a pointer to a location in the polygon memory vertex storage that includes a color portion of the vertex data. Associated with all of the vertices, of either a strip or a fan, is an Material-Lighting-Mode (MLM) pointer set. MLM includes six main pointers plus two other pointers as described below. Each of the six main pointers comprises an address to the polygon memory state storage, which is a sequential storage of all of the state that has changed in the pipeline, for example, changes in the texture, the pixel, lighting and so forth, so that as a need arises any time in the future, one can recreate the state needed to render a vertex (or the object formed from one or more vertices) from the MLM pointer associated with the vertex, by looking up the MLM pointers and going back into the polygon memory state storage and finding the state that existed at the time.","The Mode Extraction Block (MEX) is a logic block between Geometry and Sort that collects temporally ordered state change data, stores the state in Polygon memory, and attaches appropriate pointers to the vertex data it passes to Sort Memory. In the normal OpenGL pipeline, and in embodiments of the inventive pipeline up to the Sort block, geometry and state data is processed in the order in which it was sent down the pipeline. State changes for material type, lighting, texture, modes, and stipple affect the primitives that follow them. For example, each new object will be preceded by a state change to set the material parameters for that object.","In the inventive pipeline, on the other hand, fragments are sent down the pipeline in Tile order after the Cull block. The Mode Injection Block figures out how to preserve state in the portion of the pipeline that processes data in spatial (Tile) order instead of time order. In addition to geometry data, Mode Extraction Block sends a subset of the Mode data (cull_mode) down the pipeline for use by Cull. cull_mode packets are produced in Geometry Block. Mode Extraction Block inserts the appropriate color pointer in the Geometry packets.","Pipeline state is broken down into several categories to minimize storage as follows: (1) Spatial pipeline state includes data headed for Sort that changes every vertex; (2) cull_mode state includes data headed for Cull (via Sort) that changes infrequently; (3) Color includes data headed for Polygon memory that changes every vertex; (4) Material includes data that changes for each object; (5) TextureA includes a first set of state for the Texture Block for textures  & ; (6) TextureB includes a second set of state for the Texture Block for textures  through ; (7) Mode includes data that hardly ever changes; (8) Light includes data for Phong; (9) Stipple includes data for polygon stipple patterns. Material, Texture, Mode, Light, and Stipple data are collectively referred to as MLM data (for Material, Light and Mode). We are particularly concerned with the MLM pointers fir state preservation.","State change information is accumulated in the MEX until a primitive (Spatial and Color packets) appears. At that time, any MLM data that has changed since the last primitive, is written to Polygon Memory. The Color data, along with the appropriate pointers to MLM data, is also written to Polygon Memory. The spatial data is sent to Sort, along with a pointer into Polygon Memory (the color pointer). Color and MLM data are all stored in Polygon memory. Allocation of space for these records can be optimized in the micro-architecture definition to improve performance.","All of these records are accessed via pointers. Each primitive entry in Sort Memory contains a Color Pointer to the corresponding Color entry in Polygon Memory. The Color Pointer includes a Color Address, Color Offset and Color Type that allows us to construct a point, line, or triangle and locate the MLM pointers. The Color Address points to the final vertex in the primitive. Vertices are stored in order, so the vertices in a primitive are adjacent, except in the case of triangle fans. The Color Offset points back from the Color Address to the first dualoct for this vertex list. (We will refer to a point list, line strip, triangle strip, or triangle fan as a vertex list.) This first dualoct contains pointers to the MLM data for the points, lines, strip, or fan in the vertex list. The subsequent dualocts in the vertex list contain Color data entries. For triangle fans, the three vertices for the triangle are at Color Address, (Color Address\u22121), and (Color Address\u2014Color Offset+1). Note that this is not quite the same as the way pointers are stored in Sort memory.","State is a time varying entity, and MEX accumulates changes in state so that state can be recreated for any vertex or set of vertices. The MIJ block is responsible for matching state with vertices down stream. Whenever a vertex comes into MEX and certain indicator bits are set, then a subset of the pipeline state information needs to be saved. Only the states that have changed are stored, not all states, since the complete state can be created from the cumulative changes to state. The six MLM pointers for Material, TextureA, TextureB, Mode, Light, and Stipple identify address locations where the most recent changes to the respective state information is stored. Each change in one of these state is identified by an additional entry at the end of a sequentially ordered state storage list stored in a memory. Effectively, all state changes are stored and when particular state corresponding to a point in time (or receipt of a vertex) is needed, the state is reconstructed from the pointers.","This packet of mode that are saved are referred to as mode packets, although the phrase is used to refer to the mode data changes that are stored, as well as to larger sets of mode data that are retrieved or reconstructed by MIJ prior to rendering.","We particularly note that the entire state can be recreated from the information kept in the relatively small color pointer.","Polygon memory vertex storage stores just the color portion. Polygon memory stores the part of pipeline stat that is not needed for hidden surface removal, and it also stores the part of the vertex data which is not needed for hidden surface removal (predominantly the items needed to make colors.)","Texel Reuse Detection and Tile Based Processing","The inventive structure and method may advantageously make use of trilinear mapping of multiple layers (resolutions) of texture maps.","Texture maps are stored in a Texture Memory which may generally comprise a single-buffered memory loaded from the host computer's memory using the AGP interface. In the exemplary embodiment, a single polygon can use up to four textures. Textures are MIP-mapped. That is, each texture comprises a series of texture maps at different levels of detail or resolution, each map representing the appearance of the texture at a given distance from the eye point. To produce a texture value for a given pixel fragment, the Texture block performs tri-linear interpolation from the texture maps, to approximate the correct level of detail. The Texture block can alternatively performs other interpolation methods, such as anisotropic interpolation.","The Texture block supplies interpolated texture values (generally as RGBA color values) to the Phong block on a per-fragment basis. Bump maps represent a special kind of texture map. Instead of a color, each texel of a bump map contains a height field gradient.","The multiple layers are MIP layers, and interpolation is within and between the MIP layers. The first interpolation ii within each layer, then you interpolate between the two adjacent layers, one nominally having resolution greater than required and the other layer having less resolution than required, so that it is done 3-dimensionally to generate an optimum resolution.","The inventive pipeline includes a texture memory which includes a texture cache really a textured reuse register because the structure and operation are different from conventional caches. The host also includes storage for texture, which may typically be very large, but in order to render a texture, it must be loaded into the texture cache which is also referred to as texture memory. Associated with each VSP are S and T's. In order to perform trilinear MIP mapping, we necessarily blend eight (8) samples, so the inventive structure provides a set of eight content addressable (memory) caches running in parallel. In one embodiment, the cache identifier is one of the content addressable tags, and that's the reason the tag part of the cache and the data part of the cache is located are located separate from the tag or index. Conventionally, the tag and data are co-located so that a query on the tag gives the data. In the inventive structure and method, the tags and data are split up and indices are sent down the pipeline.","The data and tags are stored in different blocks and the content addressable lookup is a lookup or query of an address, and even the \u201cdata\u201d stored at that address in itself and index that references the actual data which is stored in a different block. The indices are determined, and sent down the pipeline so that the data referenced by the index can be determined. In other words, the tag is in one location, the texture data is in a second location, and the indices provide a link between the two storage structures.","In one embodiment of the invention Texel Reuse Detection Registers (TRDR) comprise a multiplicity of associate memories, generally located on the same integrated circuit as the texel interpolator. In the preferred embodiment, the texel reuse detection method is performed in the Texture Block.","In conventional 3-D graphics pipelines, an object in some orientation in space is rendered. The object has a texture map on it, and its represented by many triangle primitives. The procedure implemented in software, will instruct the hardware to load the particular object texture into a DRAM. Then all of the triangles that are common to the particular object and therefore have the same texture map are fed into the unit and texture interpolation is performed to generate all of the colored pixels need to represent that particular object. When that object has been colored, the texture map in DRAM can be destroyed since the object has been rendered. If there are more than one object that have the same texture map, such as a plurality of identical objects (possibly at different orientations or locations), then all of that type of object may desirably be textured before the texture map in DRAM is discarded. Different geometry may be fed in, but the same texture map could be used for all, thereby eliminating any need to repeatedly retrieve the texture map from host memory and place it temporarily in one or more pipeline structures.","In more sophisticated conventional schemes, more than one texture map may be retrieved and stored in the memory, for example two or several maps may be stored depending on the available memory, the size of the texture maps, the need to store or retain multiple texture maps, and the sophistication of the management scheme. Each of these conventional texture mapping schemes, spatial object coherence is of primary importance. At least for an entire single object, and typically for groups of objects using the same texture map, all of the triangles making up the object are processed together. The phrase spatial coherency is applied to such a scheme because the triangles form the object and are connected in space, and therefore spatially coherent.","In the inventive deferred shader structure and method we do not necessarily rely on or derive appreciable benefit from this type of spatial object coherence. Embodiments of the inventive deferred shader operate on tiles instead. Any given tile might have an entire object, a plurality of objects, some entire objects, or portions of several objects, so that spatial object coherence over the entire tile is typically absent.","Well we break that conventional concept completely because the inventive structure and method are directed to a deferred shader. Even if a tile should happen to have an entire object there will typically be different background, and the inventive Cull Block and Cull procedure will typically generate and send VSPs in a completely jumbled and spatially incoherent order, even if the tile might support some degree of spatial coherency. As a result, the pipeline and texture block are advantageously capable of changing the texture map on the fly in real-time and in response to the texture required for the object primitive (e.g. triangle) received. Any requirement to repeatedly retrieve the texture map from the host to process the particular object primitive (for example, single triangle) just received and then dispose of that texture when the next different object primitive needing a different texture map would be problematic to say the least and would preclude fast operation.","In the inventive structure and method, a sizable memory is supported on the card. In one implementation 128 megabytes are provided, but more or fewer megabytes may be provided. For example, 34 Mb, 64 Mb, 256 Mb, 512 Mb, or more may be provided, depending upon the needs of the user, the real estate available on the card for memory, and the density of memory available.","Rather that reading the 8 textels for every visible fragment, using them, and throwing them away so that the 8 textels for the next fragment can be retrieved and stored, the inventive structure and method stores and reuses them when there is a reasonable chance they will be needed again.","It would be impractical to read and throw away the eight textels every time a visible fragment is received. Rather, it is desirable to make reuse of these textels, because if you're marching along in tile space, your pixel grid within the tile (typically processed along sequential rows in the rectangular tile pixel grid) could come such that while the same texture map is not needed for sequential pixels, the same texture map might be needed for several pixels clustered in a n area of the tile, and hence needed only a few process steps after the first use. Desirably, the invention uses the textels that have been read over and over, so when we need one, we read it, and we know that chances are good that once we have seem one fragment requiring a particular texture map, chances are good that for some period of time afterward while we are in the same tile, we will encounter another fragment from the same object that will need the same texture. So we save those things in this cache, and then on the fly we look up from the cache (texture reuse register) which ones we need. If there is a cache miss, for example, when a fragment and texture map are encountered for the first time, that texture map is retrieved and stored in the cache.","Texture Map retrieval latency is another concern, but is handled through the use of First-In-First-Out (FIFO) data structures and a look-ahead or predictive retrieval procedure. The FIFO's are large and work in association with the CAM. When an item is needed, a determination is made as to whether it is already stored, and a designator is also placed in the FIFO so that if there is a cache miss, it is still possible to go out to the relatively slow memory to retrieve the information and store it. In either event, that is if the data was in the cache or it was retrieved from the host memory, it is placed in the unit memory (and also into the cache if newly retrieved).","Effectively, the FIFO acts as a sort of delay so that once the need for the texture is identified-(prior to its actual use) the data can be retrieved and reassociated, before it is needed, such that the retrieval does not typically slow down the processing. The FIFO queues provide and take up the slack in the pipeline so that it always predicts and looks ahead. By examining the FIFO, non-cached texture can be identified, retrieved from host memory, placed in the cache and in a special unit memory, so that it is ready for use when a read is executed.","The FIFO and other structures that provide the look-ahead and predictive retrieval are provided in some sense to get around the problem created when the spatial object coherence typically used in per-object processing is lost in our per-tile processing. One also notes that the inventive structure and method makes use of any spatial coherence within an object, so that if all the pixels in one object are done sequentially, the invention does take advantage of the fact that there's temporal and spatial coherence.","Packetized Data Transfer Protocol","The inventive structure and method advantageously transfer information (such as data and control) from block to block in packets. We refer to this packetized communication as packetized data transfer and the format and\/or content of the packetized data as the packetized data transfer protocol (PDTP). The protocol includes a header portion and a data portion.","One benefit of the PDTP is that all of the data can be sent over one bus from block to block thereby alleviating any need for separate busses for different data types. Another advantage of PDTP is that packetizing the information assists in keeping the ordering, which is important for proper rendering. Recall that rendering is sensitive to changes in pipeline state and the like so that maintaining the time order sequence is important generally, and with respect to the MIJ cache for example, management of the flow of packets down the pipeline is especially important.","The transfer of packets is sequential, since the bus is effectively a sequential link wherein packets arrive sequentially in some time order. If for example, a \u201cfill packet\u201d arrives in a block, it goes into the block's FIFO, and if a VSP arrives, it also goes into the block's FIFO. Each processor block waits for packets to arrive at its input, and when a packet arrives looks at the packet header to determine what action to take if any. The action may be to send the packet to the output (that is just pass it on without any other action or processing) or to do something with it. The packetized data structure and use of the packetized data structure alone and in conjunction with a bus, FIFO or other buffer or register scheme have applications broader than 3D graphics systems and may be applied to any pipeline structure where a plurality of functional or processing blocks or units are interconnected and communicate with each other. Use of packetized transfer is particularly beneficial where maintain sequential or time order is important.","In one embodiment of the PDTP each packet has a packet identifier or ID and other information. There are many different types of packets, and every different packet type has a standard length, and includes a header that identifies the type of packet. The different packets have different forms and variable lengths, but each particular packet type has a standard length.","Advantageously, each block includes a FIFO at the input, and the packets flow through the FIFOs where relevant information is accumulated in the FIFO by the block. The packet continues to flow through other or all of the blocks so that information relevant to that blocks function may be extracted.","In one embodiment of the inventive structure and method, the storage cells or registers within the FIFO's has some predetermined width such that small packets may require only one FIFO register and bigger packets require a larger number of registers, for example 2, 3, 5, 10, 20, 50 or more registers. The variable packet length and the possibility that a single packet may consume several FIFO storage registers do not present any problem as the first portion of the packet identifies the type of packet and either directly, or indirectly by virtue of knowing the packet type, the size of the packet and the number of FIFO entries it consumes. The inventive structure and method provide and support numerous packet types which are described in other sections of this document.","Fragment Coloring","Fragment coloring is performed for two-dimensional display space and involves an interpolation of the color from for example the three vertices of a triangle primitive, to the sampled coordinate of the displayed pixel. Essentially, fragment coloring involves applying an interpolation function to the colors at the three fragment vertices to determine a color for a location spatially located between or among the three vertices. Typically, but optionally, some account will be taken of the perspective correctness in performing the interpolation. The interpolation coefficients are cached as are the perspective correction coefficients.","Interpolation of Normals","Various compromises have conventionally be accepted relative to the computation of surface normals, particularly a surface normal that is interpolated between or among other surface normals, in the 3D graphics environment. The compromises have typically traded-off accuracy for computational ease or efficiency. Ideally, surface normals should be interpolated angularly, that is based on the actual angular differences in the angles of the surface normals on which the interpolation is based. In fact such angular computation is not well suited to 3D graphics applications.","Therefore, more typically, surface normals are interpolated based on linear interpolation of the two input normals. For low to moderate quality rendering, linear interpolation of the composite surface normals may provide adequate accuracy; however, considering a two-dimensional interpolation example, when one vector (surface normal) has for example a larger magnitude that the other vector, but comparable angular change to the first vector, the resultant vector will be overly influenced by the larger magnitude vector in spite of the comparable angular difference between the two vectors. This may result in objectionable error, for example, some surface shading or lighting calculation may provide an anomalous result and detract from the output scene.","While some of these problems could be minimized even if a linear interpolation was performed on a normalized set of vectors, this is not always practical, because some APIs support non-normalized vectors and various interpolation schemes, including, for example, three-coordinate interpolation, independent x, y, and z interpolations, and other schemes.","In the inventive structure and method the magnitude is interpolated separately from the direction or angle. The interpolated magnitude are computed then the direction vectors which are equal size. The separately interpreted magnitudes and directions are then recombined, and the direction is normalized.","While the ideal angular interpretation would provide the greatest accuracy, however, the interpolation involves three points on the surface of a sphere and various great-circle calculations. This sort of mathematical complexity is not well suited for real-time fast pipeline processing. The single step linear interpolation is much easier but is susceptible to greater error. In comparison to each of these procedures, the inventive surface normal interpolation procedure has greater accuracy than conventional linear interpolation, and lower computational complexity that conventional angular interpolation.","Spatial Setup","In a preferred embodiment of the invention, spatial setup is performed in the Setup Block (STP). The Setup (STP) block receives a stream of packets from the Sort (SRT) block. These packets have spatial information about the primitives to be rendered. The output of the STP block goes to the Cull (CUL) block. The primitives received from SRT can be filled triangles, line triangles, lines, stippled lines, and points. Each of these primitives can be rendered in aliased or anti-aliased mode. The SRT block sends primitives to STP (and other pipeline stages downstream) in tile order. Within each tile the data is organized in time order or in sorted transparency order. The CUL block receives data from the STP block in tile order (in fact in the order that STP receives primitives from SRT), and culls out parts of the primitives that definitely do not contribute to the rendered images. This is accomplished in two stages. The first stage allows detection of those elements in a rectangular memory array whose content is greater than a given value. The second stage refines on this search by doing a sample by sample content comparison. The STP block prepares the incoming primitives for processing by the CUL block. STP produces a tight bounding box and minimum depth value Zmin for the part of the primitive intersecting the tile for first stage culling, which marks the stamps in the bounding box that may contain depth values less than Zmin. The Z cull stage takes these candidate stamps, and if they are a part of the primitive, computes the actual depth value for samples in that stamp. This more accurate depth value is then used for comparison and possible discard on a sample by sample basis. In addition to the bounding box and Zmin for first stage culling, STP also computes the depth gradients, line slopes, and other reference parameters such as depth and primitive intersection points with the tile edge for the Z cull stage. The CUL unit produces the VSPs used by the other pipeline stages.","In the preferred embodiment of the invention, the spatial setup procedure is performed in the Setup Block. Important aspects of the inventive spatial setup structure and method include: (1) support for and generation of a unified primitive, (2) procedure for calculating a Zwithin a tile for a primitive, (3) the use of tile-relative y-values and screen-relative x-values, and (4) performing a edge hop (actually performed in the Cull Block) in addition to a conventional edge walk which also simplifies the down-stream hardware,","Under the rubric of a unified primitive, we consider a line primitive to be a rectangle and a triangle to be a degenerate rectangle, and each is represented mathematically as such. Setup converts the line segments into parallelograms which consists of four vertices. A triangle has three vertices. Setup describes the each primitive with a set of four points. Note that not all values are needed for all primitives. For a triangle, Setup uses top, bottom, and either left or right corner, depending on the triangle's orientation. A line segment is treated as a parallelogram, so Setup uses all four points. Note that while the triangle's vertices are the same as the original vertices, Setup generates new vertices to represent the lines as quads. The unified representation of primitives uses primitive descriptors which are assigned to the original set of vertices in the window coordinates. In addition, there are flags which indicate which descriptors have valid and meaningful values.","For triangles, VtxYmin, VtxYmax, VtxLeftC, VtxRightC, LeftCorner, RightCorner descriptors are obtained by sorting the triangle vertices by their y coordinates. For line segments these descriptors are assigned when the line quad vertices are generated. VtxYmin is the vertex with the minimum y value. VtxYmax is the vertex with the maximum y value. VtxLeftC is the vertex that lies to the left of the long y-edge (the edge of the triangle formed by joining the vertices VtxYmin and VtxYmax) in the case of a triangle, and to the left of the diagonal formed by joining the vertices VtxYmin and VtxYmax for parallelograms. If the triangle is such that the long y-edge is also the left edge, then the flag LeftCorner is FALSE (0) indicating that the VtxLeftC is invalid. Similarly, VtxRightC is the vertex that lies to the right of the long y-edge in the case of a triangle, and to the right of the diagonal formed by joining the vertices VtxYmin and VtxYmax for parallelograms. If the triangle is such that the long edge is also the right edge, then the flag RightCorner is FALSE () indicating that the VtxRightC is invalid. These descriptors are used for clipping of primitives on top and bottom tile edge. Note that in practice VtxYmin, VtxYmax, VtxLeftC, and VtxRightC are indices into the original primitive vertices.","For triangles, VtxXmin, VtxXmax, VtxTopC, VtxBotC, TopCorner, BottomCorner descriptors are obtained by sorting the triangle vertices by their x coordinates. For line segments these descriptors are assigned when the line quad vertices are generated. VtxXmin is the vertex with the minimum x value. VtxXmax is the vertex with the maximum x value. VtxTopC is the vertex that lies above the long xedge (edge joining vertices VtxXmin and VtxXmax) in the case of a triangle, and above the diagonal formed by joining the vertices VtxXmin and VtxXmax for parallelograms. If the triangle is such that the long x-edge is also the top edge, then the flag TopCorner is FALSE (O) indicating that the VtxTopC is invalid. Similarly, VtxBotC is the vertex that lies below the long x-axis in the case of a triangle, and below the diagonal formed by joining the vertices VtxXmin and VtxXmax for parallelograms. If the triangle is such that the long x-edge is also the bottom edge, then the flag BottomCorner is FALSE () indicating that the VtxBotC is invalid. These descriptors are used for clipping of primitives on the left and right tile edges. Note that in practice VtxXmin, VtxXmax, VtxTopC, and VtxBotC are indices into the original primitive vertices. In addition, we use the slopes (\u2202x\/\u2202y) of the four polygon edges and the inverse of slopes (\u2202xy\u2202x).","All of these descriptors have valid values for quadrilateral primitives, but all of them may not be valid for triangles. Initially, it seems like a lot of descriptors to describe simple primitives like triangles and quadrilaterals. However, as we shall see later, they can be obtained fairly easily, and they provide a nice uniform way to setup primitives.","Treating lines as rectangles (or equivalently interpreting rectangles as lines) involves specifying two end points in space and a width. Treating triangles as rectangles involves specifying four points, one of which typically y-left or y-right in one particular embodiment, is degenerate and not specified. The goal is to find Zmin inside the tile. The x-values can range over the entire window width while the y-values are tile relative, so that bits are saved in the calculations by making the y-values tile relative coordinates.","Object Tags","A directed acyclical graph representation of 3D scenes typically assigns an identifier to each node in the scene graph. This identifier (the object tag) can be useful in graphical operations such as picking an object in the scene, visibility determination, collision detection, and generation of other statistical parameters for rendering. The pixel pipeline in rendering permits a number of pixel tests such as alpha test, color test, stencil test, and depth test. Alpha and color test are useful in determining if an object has transparent pixels and discarding those values. Stencil test can be used for various special effects and for determination of object intersections in CSG. Depth test is typically used for hidden surface removal.","In this document, a method of tagging objects in the scene and getting feedback about which objects passed the predetermined set of visibility criteria is described.","A two level object assignment scheme is utilized. The object identifier consists if two parts a group (g) and a member tag (t). The group \u201cg\u201d is a 4 bit identifier (but, more bits could be used), and can be used to encode scene graph branch, node level, or any other parameter that may be used grouping the objects. The member tag (t) is a 5 bit value (once again, more bits could be used). In this scheme, each group can thus have up to 32 members. A 32-bit status word is used for each group. The bits of this status word indicate the member that passed the test criteria. The state thus consists of: Object group; Object Tag; and TagTestID {DepthTest, AlphaTest, ColorTest, StencilTest}. The object tags are passed down the pipeline, and are used in the z-buffered blend (or Pixel Block in the preferred embodiment). It the sample is visible, then the object tag is used to set a particular bit in a particular CPU-readable register. This allows objects to be fed into the pipeline and, once rendering is completed, the host CPU (that CPU or CPUs which are running the application program) can determine which objects were at least partially visible.","As an alternative, only the member tag (t) could be used, implying only one group.","Object tags can be used for picking, transparency determination, early object discard, and collision detection. For early object discard, an object can be tested for visibility by having its bounding volume input into the rendering pipeline and tested for \u201cvisibility\u201d as described above. However, to prevent the bounding volume from being rendered into the frame buffer, the color, depth, and stencil masks should be cleared (see OpenGL specification for a description of these mask bits).","Single Visibility Bit","As an alternative to the object tags described above, a single bit can be used as feedback to the host CPU. In this method, the object being tested for \u201cvisibility\u201d (i.e., for picking, transparency determination, early object discard, collision detection, etc) is isolated in its own frame. Then, if anything in the frame is visible, the single \u201cvisibility bit\u201d is set, otherwise it is cleared. This bit is readable by the host CPU. The advantage of this method is its simplicity. The disadvantage is the need to use individual frames for each separate object (or set of objects) that needs to be tested, thereby possibly introducing latency into the \u201cvisibility\u201d determination.","Supertile Hop Sequence","When rendering 3D images, there is often a \u201chorizon effect\u201d where a horizontal swath through the picture has much more complexity than the rest of the image. An example is a city skyline in the distance with a simple grass plane in the foreground and the sky above. The grass and sky have very few polygons (possibly one each) while the city has lots of polygons and a large depth complexity. Such horizon effects can also occur along non-horizontal swaths through a scene. If tiles are processed in a simple top-to-bottom and left-to-right order, then the complex tiles will be encountered back-to-back, resulting in a possible load imbalance within the pipeline. Therefore, it would be better to randomly \u201chop\u201d around the screen when going from tile to tile. However, this would result in a reduction in spatial coherency (because adjacent tiles are not processed sequentially), reducing the efficiency of the caches within the pipeline and reducing performance. As a compromise between spatially sequential tile processing and a totally random pattern, tiles are organized into \u201cSuperTiles\u201d, where each SuperTile is a multiplicity of spatially adjacent tiles, and a random patter of SuperTiles is then processed. Thus, spatial coherency is preserved within a SuperTile, and the horizon effect is avoided. In the preferred embodiment, the SuperTile hop sequence method is performed in the Sort Block","Normalization During Scanout","Normalization during output is an inventive procedure in which either consideration is taken of the prior processing history to determine the values in the frame buffer, or the values in the frame buffer are otherwise determined, and the range of values in the screen are scaled or normalized to that the range of values can be displayed and provide the desired viewing characteristic. Linear and non-linear scalings may be applied, and clipping may also be permitted so that dynamic range is not unduly taken up by a few relatively bright or dark pixels, and the dynamic range fits the conversion range of the digital-to-analog converter.","Some knowledge of the manner in which output pixel values are generated provides greater insight into the advantages of this approach. Sometimes the output pixel values are referred to as intensity or brightness, since they ultimately are displayed in a manner to simulate or represent scene brightness or intensity in the real world.","Advantageously, pixel colors are represented by floating point number so that they can span a very large dynamic range. Integer values though suitable once scaled to the display may not provide sufficient range given the manner the output intensities are computed to permit resealing afterward. We note that under the standard APIs, including OpenGL, that the lights are represented as floating point values, as are the coordinate distances. Therefore, with conventional representations it is relatively easy for a scene to come out all black (dark) or all white (light) or skewed toward a particular brightness range with usable display dynamic range thrown away or wasted.","Under the inventive normalization procedure, the computations are desirable maintained in floating point representations throughout, and the final scene is mapped using some scaling routine to bring the pixel intensity values in line with the output display and D\/A converter capability. Such scaling or normalization to the display device may involve operations such as an offset or shift of a range of values to a different range of values without compression or expansion of the range, a linear compress or expansion, a logarithmic compression, an exponential or power expansion, other algebraic or polynomial mapping functions, or combinations of these. Alternatively, a look-up table having arbitrary mapping transfer function may be implemented to perform the output value intensity transformation. When it's time to buffer swap in order to display the picture when it's done, one logarithmically (or otherwise) scale during scanout.","Desirably, the transformation is performed automatically under a set of predetermined rules. For example, a rule specifying pixel histogram based normalization may be implemented, or a rule specifying a Gaussian distribution of pixels, or a rule that linearly scales the output intensities with or without some optional intensity clipping. The variety of mapping functions provided here are merely examples, of the many input\/output pixel intensity transformations known in the computer graphics and digital image processing arts.","This approach would also permit somewhat greater leeway in specifying lighting, object color, and the like and still render a final output that was visible. Even if the final result was not esthetically perfect, it would provide a basis for tuning the final mapping, and some interactive adjustment may desirably but optionally be provided as a debugging, fine-tuning, or set-up operation.","Stamp-Based z-Value Description","When a VSP is dispatched, it corresponds to a single primitive, and the z-buffered blend (i.e., the Pixel Block) needs separate z-values for every sample in the VSP. As an improvement over sending all the per-sample z-values within a VSP (which would take considerable bandwidth), the VSP could include a z-reference-value and the partial derivatives of z with respect to x and y (mathematically, a plane equation for the z-values of the primitive). Then, this information is used in the z-buffered blend (i.e., the Pixel Block) to reconstruct the per-sample z-values, thereby saving bandwidth. Care must be taken so that z-values computed for the CHSR process are the same as those computer in the z-buffered blend (i.e., the Pixel Block) because inconsistencies could cause rendering errors.","In the preferred embodiment, the stamp-based z-value description method is performed in the Cull Block, and per-sample z-values are generated from this description in the Pixel Block.","Object-Based Processor Resource Allocation in Phong Block","The Phong Lighting Block advantageously includes a plurality of processors or processing elements. During fragment color generation a lot of state is needed, fragments from a common object use the same state, and therefore desirably for at least reasons of efficiency a minimizing caching requirements, fragments from the same object should be processed by the same processor.","In the inventive structure and method, all fragments that originate from the same object are sent to the same processors (or if there is sever loading to the same plurality of processors). This reduces state caching in the Phong block.","Recall that preferred embodiments of the inventive structure and method implement per-tile processing, and that a single time may include multiple objects. The Phong block cache will therefore typically store state for more than one object, and send appropriate state to the processor which is handling fragments from a common object. Once state for a fragment from a particular object is sent to a particular processor, it is desirable that all other fragments from that object also be directed to that processor.","In this connection, the Mode Injection Unit (MIJ) assigns an object or material, and MIJ allocates cache in all down stream blocks. The Phong unit keeps track of which object data has been cached in which Phong unit processor, and attempts to funnel all fragments belonging that same object to the same processor. The only optional exception to this occurs if there is a local imbalance, in which case the fragments will be allocated to another processor.","This object-tag-based resource allocation (alternatively referred to as material-tag-based resource allocation in other portions of the description) occurs relative to the fragment processors or fragment engines in the Phong unit.","Dynamic Microcode Generation as Pipeline State","The Phong unit is responsible for performing texture environment calculations and for selecting a particular processing element for processing fragments from an object. As described earlier, attempts are made to direct fragments from a common object to the same phong processor or engine. Independent of the particular texture to be applied, properties of the surfaces, colors, or the like, there are a number of choices and as a result changes in the processing environment. While dynamic microcode generation is described here relative to the texture environment and lighting, the incentive structure and procedure may more widely be applied to other types of microcode, machine state, and processing generally.","In the inventive structure and method, each time processing of a triangle strip is initiated, a change material parameters occurs, or a change almost anything that touches the texture environment happens, a microcode engine in the phong unit generates microcode and this microcode is treats as a component of pipeline state. The microcode component of state is an attribute that gets cached just like other pipeline state. Treatment of microcode generated in this manner as machine state generally, and as pipeline state in a 3D graphics processor particularly, as substantial advantages.","For example, the Phong unit includes multiple processors or fragment engines. (Note that the term fragment engines here describes components in the Phong unit responsible for texture processing of the fragments, a different process than the interpolation occurring in the Fragment Block.) The microcode is downloaded into the fragment engines so that any other fragment that would come into the fragment engine and needs the same microcode (state) has it when needed.","Although embodiments of each of the fragment engines in the Phong Block are generically the same, the presence of the downloadable microcode provides a degree of specialization. Different microcode may be downloaded into each one dependent on how the MIJ caching mechanism is operating. Dynamic microcode generation is therefore provided for texture environment and lighting","Variable Scale Bump Maps","Generating variable scale bump maps involves one or both of two separate procedures: automatic basis generation and automatic gradient field generation. Consider a gray scale image and its derivative in intensity space. Automatic gradient filed takes a derivative, relative to gray scale intensity, of a gray scale image, and uses that derivative as a surface normal perturbation to generate a bump for a bump map. Automatic basis generation saves computation, memory storage in polygon memory, and input bandwidth in the process.","For each triangle vertex, an s,t and surface normal are specified. But the s and t aren't color, rather they are two-dimensional surface normal perturbations to the texture map, and therefore a texture bump map. The s and t are used to specify the directions in which to perturb the surface normals in order to create a usable bump map. The s,t give us an implied coordinate system and reference from which we can specify perturbation direction. Use of the s,t coordinate system at each pixel eliminates any need to specify the surface tangent and the bi-normal at the pixel location. As a result, the inventive structure and method save computation, memory storage and input bandwidth.","Tile Buffer and Pixel Buffers","A set of per-pixel tile staging buffers exists between the PixelOut and the BKE block. Each of these buffers has three state bits Empty, BkeDoneForPix, and PixcDoneForBke associated with it. These bits regulate (or simulate) the handshake between the PixelOut and Backend for the usage of these buffer. Both the backend and the PixelOut unit maintain current InputBuffer and OutputBuffer pointers which indicate the staging buffer that the unit is reading from or writing to.","For preparing the tiles for rendering by PIX, the BKE block takes the next Empty buffer and reads in the data from the frame buffer memory (if needed, as determined by the RGBAClearMask, DepthMask, and StencilMask\u2014if a set of bit planes is not cleared it is read into). After Backend is done with reading in the tile, it sets the BkeDoneForPix bit. PixelOut looks at the BkeDoneForPix bit of the InputTile. If this bit is not set, then pixelout stalls, else it clears the BkeDoneForPix bit, and the color, depth, and\/or stencil bit planes (as needed) in the pixel tile buffer and transfers it to the tile sample buffers appropriately.","On output, the PixelOut unit resolves the samples in the rendered tile into pixels in the pixel tile buffers. The backend unit (BKE) block transfers these buffers to the frame buffer memory. The Pixel buffers are traversed in order by the PixelOut unit. PixelOut emits the rendered sample tile to the same pixel buffer that it came from. After the tile output to the pixel tile buffer is completed, the PixelOut unit sets the PixDoneForBke bit. The BKE block can then take the pixel tile buffer with PixDoneForBke set, clears that bit and transfer it to the frame buffer memory. After the transfer is complete, the Empty bit is set on the buffer.","Windowed Pixel Zooming During Scanout","The Backend Unit is responsible for sending data and or signals to the CRT or other display device and includes a Digital-to-Analog (D\/A) converter for converting the digital information to analog signals suitable for driving the display. The backend also includes a bilinear interpolator, so that pixels from the frame buffer can be interpolated to change the spatial scale of the pixels as they are sent to the CRT display. The pixel zooming during scanout does not involve rerendering it just scales or zooms (in or out) resolution on the fly. In one embodiment, the pixel zooming is performed selectively on a per window basis, where a window is a portion of the overall desktop or display area.","Virtual Block Transfer (VBLT) During Scanout","Conventional structures and methods provide an on-screen memory storage and an off-screen memory storage, each having for example, a color buffer, a z-buffer, and some stencil. The 3D rendering process renders to these off-screen buffers. The one screen memory corresponds to the data that is shown on the display. When the rendering has completed to the off-screen memory, the content of the off-screen memory is copied to the on-screen memory in what is referred to as a block transfer (BLT).","In order to save memory bandwidth and realize other benefits described elsewhere in this description, the inventive structure and method perform a \u201cvirtual\u201d block transfer or virtual BLT by splicing the data in or reading the data from an alternate location.","Token Insertion for Vertex Lists","A token in this context is an information item interposed between other items fed down the pipeline that tell the pipeline what the entries that follow correspond to. For example, if the x,y,z coordinates of a vertex are fed into the pipeline and they are 32-bit quantities, the tokens are inserted to inform the pipeline that the numbers that follow are vertex x,y,z values since there are no extra bits in the entry itself for identification. The tokens that tell the pipeline hardware how to interpret the data that's being sent in.","This description is divided into several parts for the convenience of the reader and to assist in understanding the constituent elements, including optional elements, as well as the inventive pipeline structure and method as a whole. We begin with a description of an embodiment of the overall deferred shading graphical processor or graphics engine, then describe numerous inter-block interfaces and signals, where it is understood that in at least one embodiment of the invention, at least some signals communicated between functional blocks and within functional blocks advantageously use packetized communications (packets). Having described inter-block communication, we then describe structure, operation, and method of individual functional blocks.","Am embodiment of the inventive Deferred Shading Graphics Processor (DSGP)  is illustrated in FIG. A and described in detail hereinafter. An alternative embodiment of the invention is illustrated in FIG. A. The detailed description which follows is with reference to  and FIG. A, without further specific reference. Computer graphics is the art and science of generating pictures or images with a computer. This picture generation is commonly referred to as rendering. The appearance of motion, for example in a 3-Dimensional animation is achieved by displaying a sequence of images. Interactive 3-Dimensional (3D) computer graphics allows a user to change his or her viewpoint or to change the geometry in real-time, thereby requiring the rendering system to create new images on-the-fly in real-time. Therefore, real-time performance in color, with high quality imagery is becoming increasingly important.","The invention is directed to a new graphics processor and method and encompasses numerous substructures including specialized subsystems, subprocessors, devices, architectures, and corresponding procedures. Embodiments of the invention may include one or more of deferred shading, a tiled frame buffer, and multiple-stage hidden surface removal processing, as well as other structures and\/or procedures. In this document, this graphics processor is hereinafter referred to as the DSGP (for Deferred Shading Graphics Processor), or the DSGP pipeline, but is sometimes referred to as the pipeline.","This present invention includes numerous embodiments of the DSGP pipeline. Embodiments of the present invention are designed to provide high-performance 3D graphics with Phong shading, subpixel anti-aliasing, and texture- and bump-mapping in hardware. The DSGP pipeline provides these sophisticated features without sacrificing performance.","The DSGP pipeline can be connected to a computer via a variety of possible interfaces, including but not limited to for example, an Advanced Graphics Port (AGP) and\/or a PCI bus interface, amongst the possible interface choices. VGA and video output are generally also included. Embodiments of the invention supports both OpenGL and Direct 3D APIs. The OpenGL specification, entitled \u201cThe OpenGL Graphics System: A Specification (Version 1.2)\u201d by Mark Segal and Kurt Akeley, edited by Jon Leech, is included incorporated by reference.","The inventive structure and method provided for packetized communication between the functional blocks of the pipeline.","The term \u201cInformation\u201d as used in this description means data and\/or commands, and further includes any and all protocol handshaking, headers, address, or the like. Information may be in the form of a single bit, a plurality of bits, a byte, a plurality of bytes, packets, or any other form. Data also used synonymously with information in this application. The phase \u201cinformation items\u201d is used to refer to one or more bits, bytes, packets, signal states, addresses, or the like. Distinctions are made between information, data, and commands only when it is important to make a distinction for the particular structure or procedure being described. Advantageously, embodiments of the inventive processor provides unique physical addresses for the host, and supports packetized communication between blocks.","Host Processor (HOST)","The host, not an element of the inventive graphics processor (except at the system level) but providing data and commands to it in a system, may be any general purpose computer, workstation, specialized processor, or the like, capable of sending commands and data to the Deferred Shading Graphics Processor. The AGP bus connects the Host to the AGI which communicates with the AGP bus. AGI implements AGP protocols which are known in the art and not described in detail here.","CFD communicates with AGI to tell it to get more data when more data can be handled, and sometimes CFD will receive a command that will stimulate it to go out and get additional commands and data from the host, that is it may stimulate AGI to fetch additional Graphics Hardware Commands (GHC).","Advanced Graphics Interface (AGI)","The AGI block is responsible for implementing all the functionality mandated by the AGP and\/or PCI specifications in order to send and receive data to host memory or the CPU. This block should completely encapsulate the asynchronous boundary between the AGP bus and the rest of the chip. The AGI block should implement the optional Fast Write capability in the AGP 2.0 specification in order to allow fast transfer of commands. The AGI block is connected to the Read\/Write Controller, the DMA Controller and the Interrupt Control Registers on CFD.","Command Fetch & Decode (CFD) ","Command Fetch and Decode (CFD)  handles communication with the host computer through the AGI I\/O bus also referred to as the AGP bus. CFD is the unit between the AGP\/AGI interface and the hardware that actually draws pictures, and receives an input consisting of Graphics Hardware Commands (GHC) from Advanced Graphics Interface (AGI) and converts this input into other steams of data, usually in the form of a series of packets, which it passes to the Geometry (GEO) block , to the 2-Dimensional Graphics Engine block (TDG) , and to Backend (BKE) . In one embodiment, each of the AGI, TDG, GEO, and CFD are co-located on a common integrated circuit chip. The Deferred Shading Graphics Processor (DSGP)  (also referred to as the \u201cgraphics pipeline\u201d or simply as \u201cpipeline\u201d in this document) is largely, though not exclusively, packet communication based. Most of what the CFD does is to route data for other blocks. A stream of data is received from the host via AGI and this stream may be considered to be simply a steam of bits which includes command and control (including addresses) and any data associated with the commands or control. At this stage, these bits have not been categorized by the pipeline nor packetized, a task for which CFD is primarily responsible. The commands and data come across the AGP bus and are routed by CFD to the blocks which consume them. CFD also does some decoding and unpacking of received commands, manages the AGP interface, and gets involved in Direct Memory Access (DMA) transfers and retains some state for context switches. Context switches (in the form of a command token) include may be received by CFD and in simple terms identify a pipeline state switching event so that the pipeline (or portions thereof) can grab the current (old) state and be ready to receive new state information. CFD identifies and consumes the context switch command token.","Most of the input stream comprises commands and data. This data includes geometrical object data. The descriptions of these geometrical objects can include colors, surface normals, texture coordinates, as well as other descriptors as described in greater detail below. The input stream also contains rendering information, such as lighting, blending modes, and buffer functions. Data routed to 2DG can include texture and image data.","In this description, it will be realized that certain signals or packets are generated in a unit, other signals or packets are consumed by a unit (that is the unit is the final destination of the packet), other signals or packets are merely passed through a unit unchanged, while still others are modified in some way. The modification may for example include a change in format, a splitting of a packet into other packets, a combining of packets, a rearrangement of packets, or derivation of related information from one or more packets to form a new packet. In general, this description identifies the packet or signal generator block and the signal or packet consuming block, and for simplicity of description may not describe signals or packets that merely pass through or are propagated through blocks from the generating unit to the consuming unit. Finally, it will be appreciated that in at least one embodiment of the invention, the functional blocks are distributed among a plurality of chips (three chips in the preferred embodiment exclusive of memory) and that some signal or packet communication paths are followed via paths that attempt to get a signal or packet onto or off of a particular chip as quickly as possible or via an available port or pin, even though that path does not pass down the pipeline in \u201clinear\u201d manner. These are implementation specific architectural features, which are advantageous for the particular embodiments described, but are not features or limitations of the invention as a whole. For example, in a single chip architecture, alternate paths may be provided.","We now describe the CFD-TDG Interface  in terms of information communicated (sent and\/or received) over the interface with respect to the list of information items identified in Table 1. CFD-TDG Interface  includes a 32-bit (31:0) command bus and a sixty-four bit (63:0) data bus. (The data bus may alternatively be a 32-bit bus and sequential write operations used to communicate the data when required.) The command bus communicates commands atomically written to the AGI from the host (or written using a DMA write operation). Data associated with a command will or may come in later write operations over the data bus. The command and the data associated with the command (if any) are identified in the table as \u201ccommand bus\u201d and \u201cdata bus\u201d respectively, and sometimes as a \u201cheader bus\u201d. Unless otherwise indicated relative to particular signals or packets, command, data, and header are separately communicated between blocks as an implementation decision or because there is an advantage to having the command or header information arrive separately or be directed to a separate sub-block within a pipeline unit. These details are described in the detailed description of the particular pipeline blocks in the related applications.","CFD sends packets to GEO. A Vertex_ packet is output to GEO when a vertex is read by CFD and GEO is operating in full performance vertex mode, a Vertex_ packet is output when GEO is operating in one-half performance vertex mode, a Vertex_ packet is output when GEO is operating in one-third performance vertex mode. These performance modes are described in greater detail relative to GEO below. Reference to an action, process, or step in a major functional block, such as in CFD, is a reference to such action, process, or step either in that major block as a whole or within a portion of that major block. Propagated Mode refers to propagation of signals through a block. Consumed Mode refers to signals or packets that are consumed by the receiving unit. The Geometry Mode Packet (GMD) is sent whenever a Mode Change command is read by CFD. The Geometry Material Packet (MAT) is sent whenever a Material Command is detected by CFD. The ViewPort Packet (VP) is sent whenever a ViewPort Offset is detected by CFD. The Bump Packet (BMP) and Matrix Packet (MTX) are also sent by CFD. The Light Color Packet (LITC) is sent whenever a Light Color Command is read by CFD. The Light State Packet (LITS) is sent whenever a Light State Command is read by CFD.","There is also a communication path between CFD and BKE. The stream of bits arriving at CFD from AGI are either processed by CFD or directed unprocessed to 2DG based on the address arriving with the input. This may be thought of as an almost direct communication path or link between AGI and 2DG as the amount of handling by CFD for 2DG bound signals or packets is minimal and without interpretation.","More generally, in at least one embodiment of the invention, the host can send values to or retrieve values from any unit in the pipeline based on a source or destination address. Furthermore, each pipeline unit has some registers or memory areas that can be read from or written to by the host. In particular the host can retrieve data or values from BKE. The backend bus (BKE bus) is driven to a large extent by 2DG which can push or pull data. Register reads and writes may also be accomplished via the multi-chip communication loop.",{"@attributes":{"id":"p-0495","num":"0494"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"301pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CFD->GEO Interface"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"280pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Ref.#"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["2002","Vertex_1 Command Bus","Full performance vertex cmd."]},{"entry":["2003","Vertex_1 Data Bus","Full performance vertex data"]},{"entry":["2004","Vertex_2 Command Bus","Half performance vertex cmd."]},{"entry":["2005","Vertex_2 Data Bus","Half performance vertex data"]},{"entry":["2006","Vertex_3 Command Bus","Third performance vertex cmd."]},{"entry":["2007","Vertex_3 Data Bus","Third performance vertex data"]},{"entry":["2008","Consumed Mode - Geometry Mode (GMD) Command Bus","Mode Change cmd."]},{"entry":["2009","Consumed Mode - Geometry Mode (GMD) Data Bus"]},{"entry":["2010","Consumed Mode - Material Packet (MAT) Command Bus","Material cmd."]},{"entry":["2011","Consumed Mode - Material Packet (MAT) Data Bus","Material data"]},{"entry":["2012","Consumed Mode - ViewPort Packet (VP) Command Bus"]},{"entry":["2013","Consumed Mode - ViewPort Packet (VP) Data Bus"]},{"entry":["2014","Consumed Mode - Bump Packet (BMP) Command Bus"]},{"entry":["2015","Consumed Mode - Bump Packet (BMP) Data Bus"]},{"entry":["2016","Consumed Mode - Light Color Packet (LITC) Command Bus"]},{"entry":["2017","Consumed Mode - Light Color Packet (LITC) Data Bus"]},{"entry":["2018","Consumed Mode - Light State Packet (LITS) Command Bus"]},{"entry":["2019","Consumed Mode - Light State Packet (LITS) Data Bus"]},{"entry":["2020","Consumed Mode - Matrix Packet (MTX) Command Bus"]},{"entry":["2021","Consumed Mode - Matrix Packet (MTX) Data Bus"]},{"entry":["2022","Propagated Mode Command Bus"]},{"entry":["2023","Propagated Mode Data Bus"]},{"entry":["2024","Propagated Vertex Command Bus"]},{"entry":["2025","Propagated Vertex Data Bus"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":"3000"},"The Geometry block (GEO)  is the first computation unit at the front end of DSGP and receives inputs primarily from CFD over the CFD-GEO Interface . GEO handles four major tasks: transformation of vertex coordinates and normals; assembly of vertices into triangles, lines, and points; clipping; and per-vertex lighting calculations needed for Gouraud shading. First, the Geometry block transforms incoming graphics primitives into a uniform coordinate space, the so called \u201cworld space\u201d. Then it clips the primitives to the viewing volume, or frustum. In addition to the six planes that define the viewing volume (left, right, top, bottom, front, and back), DSGP  provides six user-definable clipping planes. After clipping, the GEO breaks polygons with more than three vertices into sets of triangles, to simplify processing. Finally, if there is any Gouraud shading in the frame, GEO calculates the vertex colors that the FRG  uses to perform the shading.","DSGP can operate in maximum performance mode when only a certain subset of its operational features are in use. In performance mode (P-mode), GEO carries out only a subset of all possible operations for each primitive. As more operational features are selectively enabled, the pipeline moves through a series of lower-performance modes, such as half-performance (\u00bdP-mode), one-third performance (\u2153P-mode), one-fourth performance (\u00bcP-mode), and the like. GEO is organized to provide so that each of a plurality of GEO computational elements may be used for required computations. GEO reuses the available computational elements to process primitives at a slower rate for the non-performance mode settings.","The DSGP front end (primarily AGI and CFD) deals with fetching and decoding the Graphics Hardware Commands (GHC), and GEO receives from CFD and loads the necessary transform matrices (Matrix Packet (MTX), material and light parameters (e.g. Geometry Material Packet (MAT), Bump Packet (BMP), Light Color Packet (LITC), Light State Packet (LITS)) and other mode settings (e.g. GeomettyMode (GMD), ViewPort Packet (VP)) into GEO input registers.","At its output, GEO sends transformed vertex coordinates (e.g. Spatial Packet), normals, generated and\/or transformed texture coordinates (e.g. TextureA, TextureB Packets), and per-vertex colors, including generated or propagated vertex (e.g. Color Full, Color Half, Color Third, Color Other, Spatial), to the Mode Extraction block (MEX)  and to the Sort block (SRT) . MEX stores the color data (which actually includes more than just color) and modes in the Polygon memory (PMEM) . SRT organizes the per-vertex \u201cspatial\u201d data by tile and writes it into the Sort Memory (SMEM) . Certain of these signals are fixed length while others are variable length and are identified in the GEO-MEX Interface  in Table 2.","GEO operates on vertices that define geometric primitives:points, lines, triangles, quadralaterals, and polygons. It performs coordinate transformations and shading operations on a per-vertex basis. Only during a primitive assembly procedural phase does GEO group vertices together into lines and triangles (in the process, it breaks down quadrilaterals and polygons into sets of triangles). It performs clipping and surface tangent generation for each primitive.","For the Begin Frame, End Frame, Clear, Cull Modes, Spatial Modes, Texture A FrontBack, Texture B FrontBack, Material FrontBack, Light, PixelModes, and Stipple packets indicated as being Propagated Mode from CFD to GEO to MEX, these packets are propagated from CFD to GEO to MEX. Spatial Packet, Begin Frame, End Frame, Clear, and Cull Modes are also communicated from MEX to SRT. The bits that will form the packets arrive over the AGP, CFD interprets them and forms them into packets. GEO receives them from CFD and passes them on (propagates them) to MEX. MEX stores them into memory PMEM  for subsequent use. The Color Full, Color Half, Color Third, and Color Other identify what the object or primitive looks like and are created by GEO from the received Vertex_, Vertex_, or Vertex_. The Spatial Packet identifies the location of the primitive or object. Table 2 identifies signals and packets communicated over the MEX-PMEM-MIJ Interface. Table 3 identifies signals and packets communicated over the GEO->MEX Interface.",{"@attributes":{"id":"p-0502","num":"0501"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"MEX-PMEM-MIJ Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Color Full","Generated or propagated vertex"]},{"entry":[{},"Color Half","Generated or propagated vertex"]},{"entry":[{},"Color Third","Generated or propagated vertex"]},{"entry":[{},"Color Other","Generated or propagated vertex"]},{"entry":[{},"Spatial Modes","Propagated Mode from CFD"]},{"entry":[{},"Texture A","Propagated Mode from CFD (variable Length)"]},{"entry":[{},"Texture B","Propagated Mode from CFD (variable Length)"]},{"entry":[{},"Material","Propagated Mode from CFD (variable Length)"]},{"entry":[{},"Light","Propagated Mode from CFD (variable Length)"]},{"entry":[{},"PixelModes","Propagated Mode from CFD (variable Length)"]},{"entry":[{},"Stipple","Propagated Mode from CFD (variable Length)"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0503","num":"0502"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 3"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"GEO->MEX Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Color Full","Generated by GEO - Generated or propagated vertex"]},{"entry":["Color Half","Generated by GEO - Generated or propagated vertex"]},{"entry":["Color Third","Generated by GEO - Generated or propagated vertex"]},{"entry":["Color Other","Generated by GEO - Generated or propagated vertex"]},{"entry":["Spatial Packet","Generated by GEO - Generated or propagated vertex"]},{"entry":["Begin Frame","Propagated Mode from CFD to GEO to MEX"]},{"entry":["End Frame","Propagated Mode from CFD to GEO to MEX"]},{"entry":["Clear","Propagated Mode from CFD to GEO to MEX"]},{"entry":["Cull Modes","Propagated Mode from CFD to GEO to MEX"]},{"entry":["Spatial Modes","Propagated Mode from CFD to GEO to MEX"]},{"entry":["Texture A Front\/Back","Propagated Mode from CFD to GEO to MEX (variable Length)"]},{"entry":["Texture B Front\/Back","Propagated Mode from CFD to GEO to MEX (variable Length)"]},{"entry":["Material Front\/Back","Propagated Mode from CFD to GEO to MEX (variable Length)"]},{"entry":["Light","Propagated Mode from CFD to GEO to MEX (variable Length)"]},{"entry":["PixelModes","Propagated Mode from CFD to GEO to MEX (variable Length)"]},{"entry":["Stipple","Propagated Mode from CFD to GEO to MEX (variable Length)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["4000","5000"]},"The Mode Extraction block  receives an input information stream from GEO as a sequence of packets. The input information stream includes several information items from GEO, including Color Full, Color Half, Color Third, Color Other, Spatial, Begin Frame, End Frame, Clear, Spatial Modes, Cull Modes, Texture A FrontBack, Texture B Front\/Back, Material FrontBack, Light, PixelModes, and Stipple, as already described in Table 2 for the GEO-MEX Interface . The Color Full, Color Half, Color Third, Color Other packets are collectively referred to as Color Vertices or Color Vertex.","MEX separates the input stream into two parts: (i) spatial information, and (ii) shading information. Spatial information consist of the Spatial Packet, Begin Frame, End Frame, Clear, Cull Modes packets, and are sent to SRT . Shading information includes lights (e.g. Light Packet), colors (e.g. Color Full, Color Haff, Color Third, Color Other packets), texture modes (e.g. Texture A Front\/Back, Texture B Front\/Back packets), and other signals and packets (e.g. Spatial Modes, Material Front\/Back, PixelModes, and Stipple packets), and is stored in a special buffer called the Polygon Memory (PMEM) , where it can be retrieved by Mode Injection (MIJ) block . PMEM is desirably double buffered, so MIJ can read data for one frame, while the MEX is storing data for the next frame.","The mode data (e.g. PixelMode, Spatial Mode) stored in PMEM conceptually may be placed into three major categories: per-frame data (such as lighting and including the Light packet), per-primitive data (such as material properties and including the Material FrontBack, Stipple, Texture A Front\/Back, and Texture B FrontBack packets) and per-vertex data (such as color and including the Color Full, Color Half, Color Third, Color Other packets). In fact, in the preferred embodiment, MEX makes no actual distinction between these categories as although some types of mode data has a greater likelihood of changing frequently (or less frequently), in reality any mode data can change at any time.","For each spatial packet MEX receives, it repackages it with a set of pointers into PMEM. The set of pointers includes a color Address, a colorOffset, and a colorType which are used to retrieve shading information from PMEM. The Spatial Packet also contains fields indicating whether the vertex represents a point, the endpoint of a line, or the corner of a triangle. The Spatial Packet also specifies whether the current vertex forms the last one in a given object primitive (i.e., \u201ccompletes\u201d the primitive). In the case of triangle \u201cstrips\u201d or \u201cfans\u201d, and line \u201cstrips\u201d or \u201cloops\u201d, the vertices are shared between adjacent primitives. In this case, the packets indicate how to identify the other vertices in each primitive.","MEX, in conjunction with the MIJ, is responsible for the management of shaded graphics state information. In a traditional graphics pipeline the state changes are typically incremental; that is, the value of a state parameter remains in effect until it is explicitly changed. Therefore, the applications only need to update the parameters that change. Furthermore, the rendering of primitives is typically in the order received. Points, lines, triangle strips, triangle fans, polygons, quads, and quad strips are examples of graphical primitives. Thus, state changes are accumulated until the spatial information for a primitive is received, and those accumulated states are in effect during the rendering of that primitive.","In DSGP, most rendering is deferred until after hidden surface removal. Visibility determination may not be deferred in all instances. GEO receives the primitives in order, performs all vertex operations (transformations, vertex lighting, clipping, and primitive assembly), and sends the data down the pipeline. SRT receives the time ordered data and bins it by the tiles it touches. (Within each tile, the list is in time order.) The Cull (CUL) block  receives the data from SRT in tile order, and culls out parts of the primitives that definftely (conservative culling) do not contribute to the rendered images. CUL generates Visible Stamp Portions (VSPs), where a VSP corresponds to the visible portion of a polygon on the stamp as described in greater detail relative to CUL. The Texture (TEX) block  and the Phong Shading (PHG) block  receive the VSPs and are respectively responsible for texturing and lighting fragments. The Pixel (PIX) block  consumes the VSPs and the fragment colors to generate the final picture.","A primitive may touch many tiles and therefore, unlike traditional rendering pipelines, may be visited many times (once for each tile it touches) during the course of rendering the frame. The pipeline must remember the graphics state in effect at the time the primitive entered the pipeline (rather than what may be referred to as the current state for a primitive now entering the pipeline), and recall that state every time it is visited by the pipeline stages downstream from SRT. MEX is a logic block between GEO and SRT that collects and saves the temporally ordered state change data, and attaches appropriate pointers to the primitive vertices in order to associate the correct state with the primitive when it is rendered. MIJ is responsible for the retrieval of the state and any other information associated with the state pointer (referred to here as the MLM Pointer, or MLMP) when it is needed. MIJ is also responsible for the repackaging of the information as appropriate. An example of the repackaging occurs when the vertex data in PMEM is retrieved and bundled into triangle input packets for FRG.","The graphics shading state affects the appearance of the rendered primitives. Different parts of the DSGP pipeline use different state information. Here, we are only concerned with the pipeline stages downstream from GEO. DSGP breaks up the graphics state into several categories based on how that state information is used by the various pipeline stages. The proper partitioning of the state is important. It can affect the performance (by becoming bandwidth and access limited), size of the chips (larger caches and\/or logic complications), and the chip pin count.","MEX block is responsible for the following functionality: (a) receiving data packets from GEO; (b) performing any reprocessing needed on those data packets; (c) appropriately saving the information needed by the shading portion of the pipeline in PMEM for retrieval later by MIJ; (d) attaching state pointers to primitives sent to SRT, so that MIJ knows the state associated with this primitive; (d) sending the information needed by SRT, Setup (STP), and CUL to SRT, SRT acting as an intermediate stage and propagating the information down the pipeline; and (e) handling PMEM and SMEM overflow. The state saved in PMEM is partitioned and used by the functional blocks downstream from MIJ, for example by FRG, TEX, PHG, and PIX. This state is partitioned as described elsewhere in this description.","The SRT-STP-CUL part of the pipeline converts the primitives into VSPs. These VSPs are then textured and lit by the FRG-TEX-PHG part of the pipeline. The VSPs output from CUL to MIJ are not necessarily ordered by primitives. In most cases, they will be in the VSP scan order on the tile, i.e. the VSPs for different primitives may be interleaved. The FRG-TEX-PHG part of the pipeline needs to know which primitive a particular VSP belongs to. MIJ decodes the color pointer, and retrieves needed information from the PMEM. The color pointer consists of three parts, the colorAddress, colorOffset, and colorType.","MEX thus accumulates any state changes that have happened since the last state save. and keeps a state vector on chip. The state changes become effective as soon as a vertex is encountered. MEX attaches a colorPointer (or color address), a colorOffset, and a colorType with every primitive vertex sent to SRT. The colorPointer points to a vertex entry in PMEM. The colorOffset is the number of vertices separating the vertex at the colorPointer to the dual-oct that is used to store the MLMP applicable to this primitive.","The colorType tells the MIJ how to retrieve the complete primitive from the PMEM. Vertices are stored in order, so the vertices in a primitive are adjacent, except in the case of triangle fans. For points, we only need the vertex pointed to by the colorpointer. For lines we need the vertex pointed to by ColorPointerand the vertex before this. For triangle strips, we need the vertex at colorPointer and two previous vertices. For triangle fans we need the vertex at colorPointer, the vertex before that, and the first vertex after MLMP.","MEX does not generally need to know the contents of most of the packets received by it. It only needs to know their type and size. There are some exceptions to this generalization which are now described.","For certain packets, including colorFull, colorhalf, colorThird, colorOther packets, MEX needs to know the information about the primitive defined by the current vertex. In particular, MEX needs to know its primitive type (point, line, triangle strip, or triangle fan) as identified by the colPrimType field, and if a triangle\u2014whether it is front facing or back facing. This information is used in saving appropriate vertex entries in an on-chip storage to be able to construct the primitive in case of a memory overflow. This information is encapsulated in a packet header sent by GEO to MEX.","MEX accumulates material and texture data for both front and back faces of the triangle. Only one set of state is written to PMEM based on the Front bit or flag indicator contained in the colorFull, colorHalf, colorThird, colorOther, TextureA, TextureB, and Material packets. Note that the front\/back orientation does not change in a triangle strip or triangle fan. The Front bit is used to associate correct TextureA, TextureB parameters and Material parameters with the primitive. If a mesh changes orientation somewhere within the mesh, GEO will break that mesh into two or more meshes such that each new mesh is either entirely front facing or entirely back facing.","Similarly, for the Spatial Modes packet, MEX needs to be able to strip away one of the LineWidth and PointWidth attributes of the Spatial Mode Packet depending on the primitive type. If the vertex defines a point then LineWidth is thrown away and if the vertex defines a line, then PointWidth is thrown away. MEX passes down only one of the line or point width to SRT in the form of a LinePointWidth in the MEX-SRT Spatial Packet.","In the case of Clear control packets, MEX examines to see if SendToPixel flag is set. If this flag is set, then MEX saves the PixelMode data received in the PixelMode Packet from GEO in PMEM (if necessary) and creates an appropriate ColorPointer to attach to the output clear packet so that it may be retrieved by MIJ when needed. Table 4 identifies signals and packets communicated over the MEX-SRT Interface.",{"@attributes":{"id":"p-0521","num":"0520"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 4"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"MEX->SRT Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MEX->SRT Interface - Spatial"]},{"entry":[{},"MEX->SRT Interface - Cull Modes"]},{"entry":[{},"MEX->SRT Interface - Begin Frame"]},{"entry":[{},"MEX->SRT Interface - End Frame"]},{"entry":[{},"MEX->SRT Interface - Clear"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["6000","7000"]},"The Sort (SRT) block  receives several packets from MEX, including Spatial, Cull Modes, EndFrame, BeginFrame, and Clear Packets. For the vertices received from MEX, SRT sorts the resulting points, lines, and triangles by tile. SRT maintains a list of vertices representing the graphic primitives, and a set of Tile Pointer Lists, one list for each tile in the frame, in a desirably double-buffered Sort Memory (SMEM) . SRT determines that a primitive has been completed. When SRT receives a vertex that completes a primitive (such as the third vertex in a triangle), it checks to see which tiles the primitive touches. For each Tile a primitive touches, SRT adds a pointer to the vertex to that tile's Tile Pointer List. When SRT has finished sorting all the geometry in a frame, it sends the primitive data (Primitive Packet) to STP. Each SRT output packet (Primitive Packet) represents a complete primitive. SRT sends its output in: (i) tile-by-tile order: first, all of the primitives that touch a given tile; then, all of the primitives that touch the next tile; and so on; or (ii) in sorted transparency mode order. This means that SRT may send the same primitive many times, once for each tile it touches. SRT also sends to STP CullMode, BeginFrame, EndFrame, BeginTile, and Clear Packets.","SRT is located in the pipeline between MEX and STP. The primary function of SRT is to take in geometry and determine which tiles that geometry covers. SRT manages the SMEM, which stores all the geometry for an entire scene before it is rasterized, along with a small amount of mode information. SMEM is desirably a double buffered list of vertices and modes. One SMEM page collects a scene's geometry (vertex-by-vertex and mode-by-mode), while the other SMEM page is sending its geometry (primitive by primitive and mode by mode) down the rest of the pipeline. SRT includes two processes that operate in parallel: (a) the Sort Write Process; and (b) the Sort Read Process. The Sort Write Process is the \u201cmaster\u201d of the two, because it initiates the Sort Read Process when writing is completed and the read process is idle. This also advantageously keeps SMEM from filling and overflowing as the write process limits the number of reads that may otherwise fill the SMEM buffer. In one embodiment of the invention SMEM is located on a separate chip different from the chip on which SRT is located, however, they may advantageously located on the same chip or substrate. For this reason, the communication paths between SRT and SMEM are not described in detail here, as in at least one embodiment, the communications would be performed within the same functional block (e.g. the Sort block). The manner in which SRT interacts with SMEM are described in the related applications.","An SRT-MIJ interface is provided to propagates Prefetch Begin Frame, Prefetch End Frame, and Prefetch Begin Tile. In fact these packets are destined to BKE via MIJ and PIX, and the provision of this SRT-MIJ-PIX-BKE communication path is used because MIJ represents the last block on the chip on which SRT is located. Prefetch packets go around the pipleline so BKE can do read operations from the Frame Buffer ahead of time, that is earlier than if the same packets were to propagate through the pipeline. MIJ has a convenient communication channel to the chip that contains BKE, and PIX is located on the same chip as BKE, the ultimate consumer of the packet. Therefore, sending the packet to MIJ is an implementation detail rather than a item of architectural design. On the other hand, the use of alternative paths described to facilitate communications between blocks on different physical chips is beneficial to this embodiment. Table 5 identifies signals and packets communicated over the SRT-MIJ-PIX-BKE Interface, and Table 6 identifies signals and packets communicated over the SRT-STP Interface.",{"@attributes":{"id":"p-0525","num":"0524"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 5"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SRT-MIJ-PIX-BKE Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SRT-MIJ Interface - Prefetch Begin Tile"]},{"entry":[{},"SRT-MIJ Interface - Prefetch End Frame"]},{"entry":[{},"SRT-MIJ Interface - Prefetch Begin Frame"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0526","num":"0525"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 6"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"SRT->STP Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"SRT->STP Interface - Primitive Packet"]},{"entry":[{},"SRT->STP Interface - Cull Modes"]},{"entry":[{},"SRT->STP Interface - Begin Frame"]},{"entry":[{},"SRT->STP Interface - End Frame"]},{"entry":[{},"SRT->STP Interface - Begin Tile"]},{"entry":[{},"SRT->STP Interface - Clear"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":"8000"},"The Setup (STP) block  receives a stream of packets (Primitive Packet, Cull Modes, Begin Frame, End Frame, Begin Tile, and Clear Packets) from SRT. These packets have spatial information about the primitives to be rendered. The primitives and can be filled triangles, line triangles, lines, stippled lines, and points. Each of these primitives can be rendered in aliased or anti-aliased mode. STP provides unified primitives descriptions for triangles and line segments, post tile sorting setup and tile relative y-values and screen relative x-values. SRT sends primitives to STP (and other pipeline stages downstream) in tile order. Within each tile the data is organized in either \u201ctime order\u201d or \u201csorted transparency order\u201d. STP processes one tile's worth of data, one primitive at a time. When it's done with a primitive, it sends the data on to CUL in the form of a Primitive Packet. CUL receives data from STP in tile order (in fact in the same order that STP receives primitives from SRT), and culls out or removes parts of the primitives that definitely do not contribute to the rendered images. (It may leave some parts of primitives if it cannot determine for certain that they will not contribute to the rendered image.) STP also breaks stippled lines into separate line segments (each a rectangular region), and computes the minimum z value for each primitive within the tile. Each Primitive Packet output from STP represents one primitive: a triangle, line segment, or point. The other inputs to STP including CullModes, BeginFrame, EndFrame, BeginTile, and Clear. Some packets are not used by STP but are merely propagated or passed through to CUL.","STP prepares the incoming primitives from SRT for processing (culling) by CUL. The CUL culling operation is accomplished in two stages. We briefly describe culling here so that the preparatory processing performed by STP in anticipation of culling may be more readily understood. The first stage, a magnitude comparison content addressable memory based culling operation (M-Cull), allows detection of those elements in a rectangular memory array whose content is greater than a given value. In one embodiment of the invention a magnitude comparison content addressable type memory is used. (By way of example but not limitation, U.S. Pat. No. 4,996,666, by Jerome F. Duluk Jr., entitled \u201cContent-Addressable Memory System Capable of Fully Parallel Magnitude Comparisons\u201d, granted Feb. 26, 1991 herein incorporated by reference describes a structure for a particular magnitude comparison content addressable type memory.) The second stage (S-Cull) refines on this search by doing a sample-by-sample content comparison. STP produces a tight bounding box and minimum depth value Zmin for the part of the primitive intersecting the tile for M-Cull. The M-Cull stage marks the stamps in the bounding box that may contain depth values less than Zmin. The S-Cull stage takes these candidate stamps, and if they are a part of the primitive, computes the actual depth value for samples in that stamp. This more accurate depth value is then used for comparison and possible discard on a sample by sample basis. In addition to the bounding box and Zmin for M-Cull, STP also computes the depth gradients, line slopes, and other reference parameters such as depth and primitive intersection points with the tile edge for the S-Cull stage. CUL produces the VSPs used by the other pipeline stages.","STP is therefore responsible for receiving incoming primitives from SRT in the form of Primitive Packets, and processing these primitives with the aid of information received in the CullModes, BeginFrame, EndFrame, BeginTile, and Clear packets; and outputting primitives (Primitive Packet), as well as CullModes, BeginFrame, EndFrame, BeginTile, and Clear packets. Table 7 identifies signals and packets communicated over the STP-CUL Interface.",{"@attributes":{"id":"p-0530","num":"0529"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 7"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"STP->CUL Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"STP->CUL Interface - Primitive Packet"]},{"entry":[{},"STP->CUL Interface - Cull Modes"]},{"entry":[{},"STP->CUL Interface - Begin Frame"]},{"entry":[{},"STP->CUL Interface - End Frame"]},{"entry":[{},"STP->CUL Interface - Begin Tile"]},{"entry":[{},"STP->CUL Interface - Clear"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":"9000"},"The Cull (CUL) block  performs two main high-level functions. The primary function is to remove geometry that is guaranteed to not affect the final results in the frame buffer (i.e., a conservative form of hidden surface removal). The second function is to break primitives into units of stamp portions, where a stamp portion is the intersection of a particular primitive with a particular stamp. The stamp portion amount is determined by sampling. CUL is one of the more complex blocks in DSGP , and processing within CUL is divided primarily into two steps: magnitude comparison content addressable memory culling (M-Cull), and Subpixel Cull (S-Cull). CUL accepts data one tile's worth at a time. M-Cull discards primitives that are hidden completely by previously processed geometry. S-Cull takes the remaining primitives (which are partly or entirely visible), and determines the visible fragments. S-Cull outputs one stamp's worth of fragments at a time, called a Visible Stamp Portion (VSP), a stamp based geometry entity. In one embodiment, a stamp is a 2\u00d72 pixel area of the image. Note that a Visible Stamp Portion produced by CUL contains fragments from only a single primitive, even if multiple primitives touch the stamp. Colors from multiple touching VSPs are combined later, in the Pixel (PIX) block. Each pixel in a VSP is divided up into a number of samples to determine how much of the pixel is covered by a given fragment. PIX uses this information when it blends the fragments to produce the final color for the pixel.","CUL is responsible for: (a) pre-shading hidden surface removal; and (b) breaking down primitive geometry entities (triangles, lines and points) into stamp based geometry entities (VSPs). In general, CUL performs conservative culling or removal of hidden surfaces. CUL can only conservatively remove hidden surfaces, rather than exactly removing hidden surfaces, because it does not handle some \u201cfragment operations\u201d such as alpha test and stencil test, the results of which may sometimes be required to make such exact determination. CUL's sample z-buffer can hold two depth values, but CUL can only store the attributes of one primitive per sample. Thus, whenever a sample requires blending colors from two pieces of geometry, CUL has to send the first primitive (using time order) down the pipeline, even though there may be later geometry that hides both pieces of the blended geometry.","CUL receives STP Output Primitive Packets that each describe, on a per tile basis, either a triangle, a line or a point. SRT is the unit that bins the incoming geometry entities to tiles. Recall that STP pre-processed the primitives to provide more detailed geometric information in order to permit CUL to do the hidden surface removal. STP pre-calculates the slope value for all the edges, the bounding box of the primitive within the tile, (front most) minimum depth value of the primitive within the tile, and other relevant data, and sends this data to CUL in the form of packets. Recall that prior to SRT, MEX has already extracted the information of color, light, texture and related mode data and placed it in PMEM for later retrieval by MIJ, CUL only gets the mode data that is relevant to CUL and colorPointer (or colorAddress), that points to color, light, and texture data stored in PMEM.","CUL sends one VSP (Vsp Packet) at a time to MIJ, and MIJ reconnects the VSP with its color, light and texture data retrieved from PMEM and sends both the VSP and its associated color, light and texture data in the form of a packet to FRG and later stages in the pipeline. Associated color is stored in PMEM. CUL outputs Vsps to MIJ and included with the Vsps is a pointer into polygon memory (PMEM) so that the associated color, light, and texture data for the Vsp can be retrieved from the memory. Table 8 identifies signals and packets communicated over the CUL-MIJ Interface.",{"@attributes":{"id":"p-0535","num":"0534"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 8"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"CUL->MIJ Interface"},{"entry":"Description"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"CUL-MIJ Interface - Vsp (Visible Stamp Portion)"]},{"entry":[{},"CUL-MIJ Interface - Begin Tile"]},{"entry":[{},"CUL-MIJ Interface - Begin Frame"]},{"entry":[{},"CUL-MIJ Interface - End Frame"]},{"entry":[{},"CUL-MIJ Interface - Clear"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":"10000"},"The Mode injection (MIJ) block  in conjunction with MEX is responsible for the management of graphics state related information. MIJ retrieves mode information\u2014such as colors, material properties, and so on\u2014earlier stored in PMEM by MEX, and injects it into the pipeline to pass downstream as required. To save bandwidth, individual downstream blocks cache recently used mode information so that when cached there is no need use bandwidth to communicated the mode information from MIJ to the destination needing it. MIJ keeps track of what information is cached downstream, and by which block, and only sends information as necessary when the needed information is not cached.","MIJ receives VSP packets from the CUL block. Each VSP packet corresponds to the visible portion of a primitive on the 2\u00d72 pixel stamp. The VSPs output from the Cull block to MIJ block are not necessarily ordered by primitives. In most cases, they will be in the VSP scan order on the tile, that is, the VSPs for different primitives may be interleaved. In order to light, texture and composite the fragments in the VSPs, the pipeline stages downstream from the MIJ block need information about the type of the primitive (i.e. point, line, triangle, line-mode triangle); its geometry such as window and eye coordinates, normal, color, and texture coordinates at the vertices of the primitive; and the rendering state such as the PixelModes, TextureA, TextureB, Light, Material, and Stipple applicable to the primitive. This information is saved in the polygon memory by MEX.","MEX also attaches ColorPointers (ColorAddress, ColorOffset, and ColorType) to each primitive sent to SRT, which is in turn passed on to each of the VSPs of that primitive. MIJ decodes this pointer to retrieve the necessary information from the polygon memory. MIJ starts working on a frame after it receives a BeginFrame packet from CUL. The VSP processing for the frame begins when CUL is done with the first tile in the frame and MIJ receives the first VSP for that tile. The color pointer consists of three parts, the ColorAddress, ColorOffset, and ColorType. The ColorAddress points to the ColorVertex that completes the primitive. ColorOffset provides the number of vertices separating the ColorAddress from the dualoct that contains the MLM_Pointer. The MLM_Pointer (Material Light Mode Pointer) is periodically generated by MEX and stored into PMEM and provides a series of pointers to find the shading modes that are used for a particular primitive. ColorType contains information about the type of the primitive, size of each ColorVertex, and the enabled edges for line mode triangles. The ColorVertices making up the primitive may be 2, 4, 6, or 9 dualocts long. MIJ decodes the ColorPointer to obtain addresses of the dualocts containing the MLM_Pointer, and all the ColorVertices that make up the primitive. The MLM_Pointer (MLMP) contains the dualoct address of the six state packets in polygon memory.","MIJ is responsible for the following: (a) Routing various control packets such as BeginFrame, EndFrame, and BeginTile to FRG and PIX; (b) Routing prefetch packets from SRT to PIX; (c) Determining the ColorPointerfor all the vertices of the primitive corresponding to the VSP; (d) Determining the location of the MLMP in PMEM and retrieving it; (e) Determining the location of various state packets in PMEM; (f) Determining which packets need to be retrieved; (g) Associating the state with each VSP received from CUL; (h) Retrieving the state packets and color vertex packets from PMEM; (i) Depending on the primitive type of the VSP, MIJ retrieves the required vertices and per-vertex data from PMEM and constructs primitives; (j) Keeping track of the contents of the Color, TexA, TexB, Light, and Material caches (for FRG, TEX, and PHG) and PixelMode and Stipple caches (for PIX) and associating the appropriate cache pointer to each cache miss data packet; and (k) Sending data to FRG and PIX.","MIJ may also be responsible for (l) Processing stalls in the pipeline, such as for example stalls caused by lack of PMEM memory space; and (m) Signaling to MEX when done with stored data in PMEM so that the memory space can be released and used for new incoming data. Recall that MEX writes to PMEM and MIJ reads from PMEM. A communication path is provided between MEX and MIJ for memory status and control information relative to PMEM usage and availability. MIJ thus deals with the retrieval of state as well as the per-vertex data needed for computing the final colors for each fragment in the VSP. MIJ is responsible for the retrieval of the state and any other information associated with the state pointer (MLMP) when it is needed. It is also responsible for the repackaging of the information as appropriate. An example of the repackaging occurs when the vertex data in PMEM is retrieved and bundled into primitive input packets for FRG. In at least one embodiment of the invention, the data contained in the VSP communicated from MIJ to FRG may be different than the data in the VSP communicated between MIJ and PIX. The VSP communicated to FRG also includes an identifier added upstream in the pipeline that identifies the type of a Line (VspLin), Point (VspPnt), or Triangle (VspTri). The Begin Tile packet is communicated to both PIX and to FRG from MIJ. Table 9 identifies signals and packets communicated over the MIJ-PIX Interface, and Table 10 identifies signals and packets communicated over the MIJ-FRG Interface.",{"@attributes":{"id":"p-0541","num":"0540"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 9"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"MIJ->PIX Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MIJ-PIX Interface - Vsp"]},{"entry":[{},"MIJ-PIX Interface - Begin Tile"]},{"entry":[{},"MIJ-PIX Interface - Begin Frame"]},{"entry":[{},"MIJ-PIX Interface - End Frame"]},{"entry":[{},"MIJ-PIX Interface - Clear"]},{"entry":[{},"MIJ-PIX Interface - PixelMode Fill"]},{"entry":[{},"MIJ-PIX Interface - Stipple Fill"]},{"entry":[{},"MIJ-PIX Interface - Prefetch Begin Tile"]},{"entry":[{},"MIJ-PIX Interface - Prefetch End Frame"]},{"entry":[{},"MIJ-PIX Interface - Prefetch Begin Frame"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},{"@attributes":{"id":"p-0542","num":"0541"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 10"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"MIJ->FRG Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"MIJ-FRG Interface - Vsp (VspTri, VspLin, VspPnt)"]},{"entry":[{},"MIJ-FRG Interface - Begin Tile"]},{"entry":[{},"MIJ-FRG Interface - Color Cache Fill 0 (CCFill0)"]},{"entry":[{},"MIJ-FRG Interface - Color Cache Fill 1 (CCFill1)"]},{"entry":[{},"MIJ-FRG Interface - Color Cache Fill 2 (CCFill2)"]},{"entry":[{},"MIJ-FRG Interface - TexA Fill Packet"]},{"entry":[{},"MIJ-FRG Interface - TexB Fill Packet"]},{"entry":[{},"MIJ-FRG Interface - Material Fill Packet"]},{"entry":[{},"MIJ-FRG Interface - Light Fill Packet"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":"11000"},"The Fragment (FRG) block  is primarily responsible for interpolation. It interpolates color values for Gouraud shading, surface normals for Phong shading, and texture coordinates for texture mapping. It also interpolates surface tangents for use in the bump mapping algorithm, if bump maps are in use. FRG performs perspective corrected interpolation using barycentric coefficients in at least one embodiment of the invention.","FRG is located after CUL and MIJ and before TEX, and PHG (including BUMP when bump mapping is used). In one embodiment, FRG receives VSPs that contain up to four fragments that need to be shaded. The fragments in a particular VSP always belong to the same primitive, therefore the fragments share the primitive data defined at vertices, including all the mode settings. FRG's main function is the receipt of VSPs (Vsp Packets), and interpolation of the polygon information provided at the vertices for all active fragments in a VSP. For this interpolation task it also utilizes packets received from other blocks.","At the output of FRG we still have VSPs. VSPs contain fragments. FRG can perform the interpolations of a given fragment in parallel, and fragments within a particular VSP can be done in an arbitrary order. Fully interpolated VSPs are forwarded by FRG to the TEX, and PHG in the same order as received by FRG. In addition, part of the data sent to TEX may include Level-of-Detail (LOD or \u03bb) values. In one embodiment, FRG interpolates values using perspective corrected barycentric interpolation.","PHG receives full and not full performance VSP (Vsp-FullPerf, Vsp-NotFullPert), Texture-B Mode Cache Fill Packet (TexBFill), light cache Fill packet (LtFill), Material Cache Fill packet (MtFill), and Begin Tile Packet (BeginTile) from FRG over header and data busses. Note that here, full performance and not-full performance Vsp are communicated. At one level of the pipeline, four types are supported (e.g. full, \u00bd, \u2153, and \u00bc performance), and these are written to PMEM and read back to MIJ. However, in one embodiment, only three types are communicated from MIJ to FRG, and only two types from FRG to PHB. Not full performance here refers to \u00bd performance or less. These determinations are made based on available bandwidth of on-chip communication and off-chip communications and other implementation related factors.","We note that in one embodiment, FRG and TEX are coupled by several busses, a 48-bit (47:0) Header Bus, a 24-bit (23:0) R-Data Interface Bus, a 48-bit (47:0) ST-Data Interface Bus, and a 24-bit (23:0) LOD-Data Interface Bus. VSP data is communicated from FRG to TEX over each of these four busses. A TexA Fill Packet, a TexB Fill Packet, and a Begin Tile Packet are also communicated to TEX over the Header Bus. Multiple busses are conveniently used; however, a single bus, though not preferred, may alternatively be used. Table 11 identifies signals and packets communicated over the FRG-PHG Interface, and Table 12 identifies signals and packets communicated over the FRG-TEX Interface.",{"@attributes":{"id":"p-0548","num":"0547"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 11"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"FRG->PHG Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FRG->PHB Full Performance Vsp"]},{"entry":[{},"FRG->PHB Not Full Performance Vsp (\u00bd, \u2153, etc.)"]},{"entry":[{},"FRG->PHB Begin Tile"]},{"entry":[{},"FRG->PHB Material Fill Packet"]},{"entry":[{},"FRG->PHB Light Fill Packet"]},{"entry":[{},"FRG->PHB TexB Fill Packet"]},{"entry":[{},"FRG->PHB Begin Tile"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0549","num":"0548"},"tables":{"@attributes":{"id":"TABLE-US-00012","num":"00012"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 12"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"FRG->TEX Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FRG->TEX Header Bus - Vsp"]},{"entry":[{},"FRG->TEX ST-Data Bus - Vsp"]},{"entry":[{},"FRG-TEX R-Data Bus -Vsp"]},{"entry":[{},"FRG-TEX LOD-Data Bus - Vsp"]},{"entry":[{},"FRG->TEX Header Bus - Begin Tile"]},{"entry":[{},"FRG->TEX Header Bus - TexA Cache Fill Packet"]},{"entry":[{},"FRG->TEX Header Bus - TexB Cache Fill Packet"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["12000","13000"]},"The Texture block  applies texture maps to the pixel fragments. Texture maps are stored in the Texture Memory (TMEM) . TMEM need only be single-buffered. It is loaded from the host (HOST) computer's memory using the AGP\/AGI interface. A single polygon can use up to four textures. Textures are advantageously mip-mapped, that is, each texture comprises a plurality or series of texture maps at different levels of detail, each texture map representing the appearance of the texture at a given magnification or minification. To produce a texture value for a given pixel fragment, TEX performs tri-linear interpolation (though other interpolation procedures may be used) from the texture maps, to approximate the correct level of detail for the viewing distance. TEX also performs other interpolation methods, such as anisotropic interpolation. TEX supplies interpolated texture values (generally as RGBA color values) in the form of Vsp Packets to the PHG on a per-fragment basis. Bump maps represent a special kind of texture map. Instead of a color, each texel of a bump map contains a height field gradient.","Polygons are used in 3D graphics to define the shape of objects. Texture mapping is a technique for simulating surface textures by coloring polygons with detailed images or patterns. Typically, a single texture map will cover an entire object that consists of many polygons. A texture map consists of one or more nominally rectangular arrays of RGBA color. In one embodiment of the invention, these rectangular arrays are about 2 kB by 2 kB in size. The user supplies coordinates, either manually or automatically in GEO, into the texture map at each vertex. These coordinates are interpolated for each fragment, the texture values are looked up in the texture map and the color assigned to the fragment.","Because objects appear smaller when they're farther from the viewer, texture maps must be scaled so that the texture pattern appears the same size relative to the object being textured. Scaling and filtering a texture image for each fragment is an expensive proposition. Mip-mapping allows the renderer to avoid some of this work at run-time. The user provides a series of texture arrays at successively lower resolutions, each array representing the texture at a specified level of detail (LOD or \u03bb). Recall that FRG calculates a level of detail value for each fragment, based on its distance from the viewer, and TEX interpolates between the two closest mip-map arrays to produce a texture value for the fragment. For example, if a fragment has I=0.5, TEX interpolates between the available arrays representing I=0 and I=1. TEX identifies texture arrays by virtual texture number and LOD.","In addition to the normal path between TMEM and TEX, there is a path from host (HOST) memory to TMEM via AGI, CFD, 2DG to TMEM which may be used for both read and write operations. TMEM stores texture arrays that TEX is currently using. Software or firmware procedures manage TMEM, copying texture arrays from host memory into TMEM. It also maintains a table of texture array addresses in TMEM. TEX sends filtered texels in a VSP packet to PHG and PHG interprets these. Table 13 identifies signals and packets communicated over the TEX-PHG Interface.",{"@attributes":{"id":"p-0554","num":"0553"},"tables":{"@attributes":{"id":"TABLE-US-00013","num":"00013"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 13"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"TEX->PHG Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"TEX->PHB Interface - Vsp"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"14000"},"The Phong (PHG or PHB) block  is located after TEX and before PIX in DSGP  and performs Phong shading for each pixel fragment. Generic forms of Phong shading are known in the art and the theoretical underpinnings of Phong shading are therefore not described here in detail, but rather are described in the related applications. PHG may optionally but desirably include Bump Mapping (BUMP) functionality and structure. TEX sends only texel data contained within Vsp Packets and PHG receives Vsp Packets from TEX, in one embodiment this occurs via a 36-bit (35:0) Textel-Data Interface bus. FRG sends per-fragment data (in VSPs) as well as cache fill packets that are passed through from MIJ. It is noted that in one embodiment, the cache fill packets are stored in RAM within PHG until needed. Fully interpolated stamps are forwarded by FRG to PHG (as well as to TEX and BUMP within PHG) in the same order as received by FRG. Recall that PHG receives full performance VSP (Vsp-FullPerf) and not full performance VSP (Vsp-NotFullPerf) packets as well as Texture-B Mode Cache Fill Packet (TexBFill), Light Cache Fill packet (LtFill), Material Cache Fill packet (MtFill), and Begin Tile Packet (BeginTile) from FRG over header and data busses. Recall also that MIJ keeps track of the contents of the Color, TexA, TexB, Light, and Material caches for PHG (as well as for FRG and TEX) and associates the appropriate cache pointer to each cache miss data packet.","PHG uses the material and lighting information supplied by MIJ, the texture colors from TEX, and the interpolated data generated by FRG, to determine a fragment's apparent color. PHG calculates the color of a fragment by combining the color, material, geometric, and lighting information received from FRG with the texture information received from TEX. The result is a colored fragment, which is forwarded to PIX where it is blended with any color information already residing in the frame buffer (FRM). PHG is primarily geometry based and does not care about the concepts of frames, tiles, or screen-space.","PHG has three internal caches: the light cache (Lt Cache Fill Packet from MIJ), the material cache (Material Cache Fill Packet from MIJ), and the textureB (TexB) cache.","Only the results produced by PHG are sent to PIX. These include a packet that specifies the properties of a fragment (Color Packet), a packet that specifies the properties of a fragment (Depth_Color Packet), a packet that specifies the properties of a fragment (Stencil_Color Packet), a packet that specifies the properties of a fragment (ColorIndex Packet), a packet that specifies the properties of a fragment (Depth_Colorlndex Packet), and a packet that specifies the properties of a fragment (Stencil_ColorIndex Packet). Table 14 identifies signals and packets communicated over the PHG-PIX Interface,",{"@attributes":{"id":"p-0559","num":"0558"},"tables":{"@attributes":{"id":"TABLE-US-00014","num":"00014"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 14"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"PHG->PIX Interface"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"PHB->PIX Interface - Color"]},{"entry":[{},"PHB->PIX Interface - Depth_Color"]},{"entry":[{},"PHB->PIX Interface - Stencil_Color"]},{"entry":[{},"PHB->PIX Interface - ColorIndex"]},{"entry":[{},"PHB->PIX Interface - Depth_ColorIndex"]},{"entry":[{},"PHB->PIX Interface - Stencil_ColorIndex"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":"15000"},"The Pixel (PIX) block  is the last block before BKE in the 3D pipeline and receives VSPs, where each fragment has an independent color value. It is responsible for graphics API per-fragment and other operations including scissor test, alpha test, stencil operations, depth test, blending, dithering, and logic operations on each sample in each pixel (See for example, OpenGL Spec 1.1, Section 4.1, \u201cPer-Fragment Operations,\u201d herein incorporated by reference). The pixel ownership test is a part of the window system (See for example Ch. 4 of the OpenGL 1.1 Specification, herein incorporated by reference) and is done in the Backend. When PIX has accumulated a tile's worth of finished pixels, it blends the samples within each pixel (thereby performing antialiasing of pixels) and sends them to the Backend (BKE) block , to be stored in the frame buffer (FRM) . In addition to this blending, the PIX performs stencil testing, alpha blending, and antialiasing of pixels. When it accumulates a tile's worth of finished pixels, it sends them to BKE to be stored in the frame buffer FRM. In addition to these operations, Pixel performs sample accumulation for antialiasing.","The pipeline stages before PIX convert the primitives into VSPs. SRT collects the primitives for each tile. CUL receives the data from SRT in tile order, and culls out or removes parts of the primitives that definitely do not contribute to the rendered images. CUL generates the VSPs. TEX and PHG also receive the VSPs and are responsible for the texturing and lighting of the fragments respectively.","PIX receives VSPs (Vsp Packet) and mode packets (Begin Tile Packet, BeginFrame Packet, EndFrame Packet, Clear Packet, PixelMode Fill Packet, Stipple Fill Packet, Prefetch Begin Tile Packet, Prefetch End Frame Packet, and Prefetch Begin Frame Packet) from MIJ, while fragment colors (Color Packet, Depth_Color Packet, Stencil_Color Packet, Colorlndex Packet, Depth_Colorlndex Packet, and Stencil_ColorIndex Packet) for the VSPs are received from PHG. PHG can also supply per-fragment z-coordinate and stencil values for VSPs.","Fragment colors (Color Packet, Depth_Color Packet, Stencil_Color Packet, ColorIndex Packet, Depth_ColorIndex Packet, and Stencil_ColorIndex Packet) for the VSPs arrive at PIX in the same order as the VSPs arrive. PIX processes the data for each visible sample according to the applicable mode settings. A pixel output (PixelOut) subunit processes the pixel samples to generate color values, z values, and stencil values for the pixels. When PIX finishes processing all stamps for the current Tile, it signals the pixel out subunit to output the color buffers, z-buffers, and stencil buffers holding their respective values for the Tile to BKE.","BKE prepares the current tile buffers for rendering of geometry (VSPs) by PIX. This may involve loading the existing color values, z values, and stencil values from the frame buffer. BKE includes a RAM (RDRAM) memory controller for the frame buffer.","PIX also receives some packets bound for BKE from MIJ. An input filter appropriately passes these packets on to a BKE Prefetch Queue, where they are processed in the order received. It is noted that several of the functional blocks, including PIX, have an \u201cinput filter\u201d that selectively routes packets or other signals through the unit, and selectively \u201ccaptures\u201d other packets or signals for use within the unit.","Some packets are also sent to a queue in the pixel output subunit. As described herein before, PIX receives inputs from MIJ and PHG. There are two input queues to handle these two inputs. The data packets from MIJ go to the VSP queue and the fragment Color packets and the fragment depth packets from PHG go to the Color queue. PIX may also receive some packets bound for BKE. Some of the packets are also copied into the input queue of the pixel output subunit.","BKE and the pixel output subunit process the data packets in the order received. MIJ places the data packets in a PIX input First-In-First-Out (FIFO) buffer memory. A PIX input filter examines the packet header, and sends the data bound for BKE to BKE, and the data packets needed by PIX to the VSP queue. The majority of the packets received from MIJ are bound for the VSP queue, some go only to BKE, and some are copied into the VSP queue as well as sent to BKE and pixel output subunit of PIX.","Communication between PIX and BKE occurs via control lines and a plurality of tile buffers, in one embodiment the tile buffers comprise eight RAMs. Each tile buffer is a 16\u00d716 buffer which BKE controls. PIX requests tile buffers from BKE via the control lines, and BKE either acquires the requested memory from the Frame buffer (FRM) or allocates it directly when it is available. PIX then informs BKE when it is finished with the tile buffers via the control lines.","Backend (BKE) ","The Backend (BKE)  receives pixels from PIX, and stores them into the frame buffer (FRM) . Communication between BKE and PIX is achieved via the control lines and tile buffers as described above, and not packetized. BKE also (optionally but desirable) sends a tile's worth of pixels back to PIX, because specific Frame Buffer (FRM) values can survive from frame to frame and there is efficiency in reusing them rather than recomputing them. For example, stencil bit values can be constant over many frames, and can be used in all those frames.","In addition to controlling FRM, BKE performs 2D drawing and sends the finished frame to the output devices. It provides the interface between FRM and the Display (or computer monitor) and video output.","BKE mostly interacts with PIX to read and write 3D tiles, and with the 2D graphics engine (TDG)  to perform Blit operations. CFD uses the BKE bus to read display lists from FRM. The BKE Bus (including a BKE Input Bus and a BKE Output Bus) is the interconnect that interfaces BKE with the Two-Dimensional Graphics Engine (TDG) , CFD, and AGI, and is used to read and write into the FRM Memory and BKE registers. AGI reads and writes BKE registers and the Memory Mapped Frame Buffer data. External client units (AGI, CFD and TDG) perform memory read and write through the BKE. The main BKE functions are: (a) 3D Tile read, (b) 3D Tile write using Pixel Ownership, (c) Pixel Ownership for write enables and overlay detection, (d) Scanout using Pixel Ownership, (e) Fixed ratio zooms, (f) 3D Accumulation Buffer, (g) Frame Buffer read and writes, (h) Color key to Windows ID (winid) map, (i) VGA, and (j) RAMDAC.","The 3D pipeline's interaction with BKE is driven by BeginFrame, BeginTile, and EndFrame packets. Prefetch versions of these packets are sent directly from SRT to the BKE so that the tiles can be prefetched into the PIX-BKE pixel buffers.","BKE interfaces with PIX using a pixBus and a prefetch queue. The pixBus is a 64-bit bus at each direction and is used to read and write the pixel buffers. There are up to 8 pixel buffers, each holding 32 bit color or depth values for a single tile. If the window has both color and depth planes enabled then two buffers are allocated. BKE read or writes to a single buffer at a time. BKE first writes the color buffer and then if needed the depth buffer values. PIX receives BeginFrame and BeginTile packets from the prefetch queue. These packets bypass the 3D pipeline units to enable prefetching of the tile buffers. The packets are duplicated for this purpose, the remaining units receiving them ordered with other VSP and mode packets. In addition to BeginFrame and BeginTile packets, BKE receives End of Frame packets that mainly is used to send a programmable interrupt. A pixel ownership unit (POBox) performs all necessary pixel ownership functions. It provides the pixel write mask for 3D tile writes. It also determines if there is an overlay (off-screen) buffer on scan out. It includes the window ID table that holds the parameters of 64 windows. A set of 16 bounding boxes (BB) and an 8-bit WinID map per-pixel mechanisms are used in determining the pixel ownership. Pixel ownership for up to 16 pixels at time can be performed as a single operation. The 2DG and AGI can perform register read and writes using the bkeBus. These registers are typically 3D independent registers. Register updates in synchronizaton with the 3D pipe are performed as mode operations or are set in Begin or End packets. CFD reads Frame Buffer resident compiled display lists and interleaved vertex arrays using the bkeBus. CFD issues read requests of four dualocts (64 Bytes) at a time when reading large lists. TDG reads and writes the Frame Buffer for 2D Blits. The source and destination could be the host memory, the Frame Buffer, the auxiliary ring for the Texture Memory and context switch state for the GEO and CFD.","In one embodiment, the BkeBus is a 72-bit input and 64-bit output bus with few handshaking signals. Arbitration is performed by BKE. Only one unit can own the bus at a time. The bus is fully pipelined and multiple requests can be on the fly at any given cycle. The external client units that perform memory read and write through the BKE are AGI and TDG, and CFD reads from the Frame Buffer via AGI's bkeBus interface. A MemBus is the internal bus used to access the Frame Buffer memory.","BKE effectively owns or controls the Frame Buffer and any other unit that needs to access (read from or write to) the frame buffer must communicate with BKE. PIX communicates with BKE via control signals and tile buffers as already described. BKE communicates with FRM (RAMBUS RDRAM) via conventional memory communication means. The 2DG block communicates with BKE as well, and can push data into the frame buffer and pull data out of the frame buffer and communicate the data to other locations.","Frame Buffer (FRM) ","The Frame Buffer (FRM)  is the memory controlled by BKE that holds all the color and depth values associated with 2D and 3D windows. It includes the screen buffer that is displayed on the monitor by scanning-out the pixel colors at refresh rate. It also holds off-screen overlay and buffers (p-buffers), display lists and vertex arrays, and accumulation buffers. The screen buffer and the 3D p-buffers can be dual buffered. In one embodiment, FRM comprises RAMBUS RD random access memory.","Two-Dimensional Graphics (TDG or 2DG) ","The Two-Dimensional Graphics (TDG or 2DG) Block  is also referred to as the two-dimensional graphics engine, and is responsible for two-dimensional graphics (2D graphics) processing operations. TDG is an optional part of the inventive pipeline, and may even be considered to be a different operational unit for processing two-dimensional data.","The TDG mostly talks to the bus interface AGI unit, the front end CFD unit and the backend BKE unit. In most desired cases (PULL), all 2D drawing commands are passed through from the CFD unit (AGP master or faster write). In low performance cases (PUSH), the commands can be programmed from AGI (in PIO mode from PCI slave). The return data from register or memory read is passed to the AGI. One the other side, to write or read the memory, the TDG passes memory request packets (including the address, data and byte enable) to the BKE or receives the memory read return data from the BKE. To process the auxiliary ring command, TDG also talks to everybody else on the ring.","We first describe certain input packets to BKE. The 2D source request and data return packet received as an input from AGI is used to handle the 2D data pull-in\/push-out from\/to the AGP memory. The PCI packet received as an input from AGI is used to handle all slave mode memory or I\/O read or write accesses. The 2D command packet received as an input from CFD is used to pass formatted commands. The frame buffer write request acknowledge and read return data packet received as an input from BKE is used to pass the DRDRAM data returned from the BKE, in response to an earlier frame buffer read request. The auxiliary ring input packet received as an input from BKE moves uni-directionally from unit to unit. TDG receives it from BKE, takes proper actions and then deliver this packet or a new packet to the next unit AGI.","The 2D AGP data request and data out packet sent to AGI is used to send the AGP master read\/write request to AGI and follow the write request, the data output packet to the AGI. The PCI write acknowledge and read return data packet sent to AGI is used to acknowledge the reception of PCI memory or I\/O write data, and also handles the return of PCI memory or I\/O read data. The auxiliary ring output packet sent to AGI moves uni-directionally from unit to unit; TDG receives it from BKE, takes proper actions and then deliver this packet or a new packet to the next unit AGI. The 2D command acknowledge packet sent to CFD is used to acknowledge the reception of the command data from CFD. The frame buffer read\/write request and read data acknowledge packet sent to BKE passes the frame buffer read or write command to the BKE. For read, both address and byte enable lines are used, and for write command data lines are also meaningful.","In one particular embodiment of the invention, support of a \u201c2D-within-3D\u201d implementation is conveniently provided using pass-thru 2D commands (referred to as \u201cTween\u201d Packets) from BKE unit. The 2D pass-thru command (tween) packet received as an input from BKE is used to pass formatted 2D drawing command packets that is in the 3D pipeline. The 2D command pass-thru (tween) acknowledge packet sent to BKE is used to acknowledge the reception of the command data from BKE.","Display (DIS)","The Display (DIS) may be considered a separate monitor or display device, particularly when the signal conditioning circuitry for generating analog signals from the final digital input are provided in BKE\/FRM.","Multi-Chip Architecture","In one embodiment the inventive structure is disposed on a set of three separate chips (Chip , Chip , and Chip ) plus additional memory chips. Chip  includes AGI, CFD, GEO, PIX, and BKE. Chip  includes MEX, SRT, STP, and CULL. Chip  includes FRG, TEX, and PHG. PMEM, SMEM, TMEM, and FRM are provided on seprate chips. An interchip communication ring is provided to couple the units on the chips for communication. In other embodiments of the invention, all functional blocks are provided on a single chip (common semiconductor substrate) which may also include memory (PMEM, SMEM, TMEM, and the like) or memory may be provided on a separate chip or set of chips.","The CFD block is the unit between the AGP interface and the hardware that actually draws pictures. There is a lot of control and data movement units, with little to no math. Most of what the CFD block does is to route data for other blocks. Commands and textures for the 2D, 3D, Backend, and Ring come across the AGP bus and are routed by the front end to the units which consume them. CFD does some decoding and unpacking of commands, manages the AGP interface, and gets involved in DMA transfers and retains some state for context switches. It is one of the least glamorous, but most essential components of the DSGP system.",{"@attributes":{"id":"p-0585","num":"0584"},"figref":"FIG. 18","b":"2000"},"Sub-Block Descriptions","Read\/Write Control","Once the AGI has completed an AGP or PCI read\/write transaction, it moves the data to the Read\/Write Control . In the case of a write this functional unit uses the address that it receives to multiplex the data into the register or queue corresponding to that physical address (see the Address Space for details). In the case of a read, the decoder multiplexes data from the appropriate register to the AGI Block so that the read transaction can be completed.","The Read\/Write Control can read or write into all the visible registers in the CFD address space, can write into the 2D and 3D Command Queues ,  and can also transfer reads and writes across the Backend Input Bus .","If the Read\/Write Decoder receives a write for a register that is read only or does not exist, it must send a message to the Interrupt Generator  which requests that it trigger an access violation interrupt. It has no further responsibilities for that write, but should continue to accept further reads and writes.","If the Read\/Write Decoder receives a read for a register which is write only or does not exist, it must gracefully cancel the read transaction. It should then send a message to the Interrupt Generator to request an access violation interrupt be generated. It has no further responsibilities for that read, but should continue to accept reads and writes.","2D Command Queue","Because commands for the DSGP graphics hardware have variable latencies and are delivered in bursts from the host, several kilobytes of buffering are required between AGI and 2D. This buffer can be several times smaller than the command buffer for 3D. It should be sized such that it smooths out inequalities between command delivery rate across AGI and performance mode command execution rate by 2D.","This queue is flow controlled in order to avoid overruns. A 2D High water mark register exists which is programmed by the host with the number of entries to allow in the queue. When this number of entries is met or exceeded, a 2D high water interrupt is generated. As soon as the host gets this interrupt, it disables the high water interrupt and enables the low water interrupt. When there are fewer entries in the queue than are in the 2D low water mark register, a low water interrupt is generated. From the time that the high water interrupt is received to the time that the low water is received, the driver is responsible for preventing writes from occurring to the command buffer which is nearly full.","3D Command Queue","Several kilobytes of buffering are also required between AGI and 3D Command Decode . It should be sized such that it smooths out inequalities between command delivery rate across AGI and performance mode command execution rate by the GEO block.","This queue is flow controlled in order to avoid overruns. A 3D High water mark register exists which is programmed by the host with the number of entries to allow in the queue. When this number of entries is met or exceeded, a 3D high water interrupt is generated. As soon as the host gets this interrupt, it disables the high water interrupt and enables the low water interrupt. When there are fewer entries in the queue than are in the 3D low water mark register, a low water interrupt is generated. From the time that the high water interrupt is received to the time that the low water is received, the driver is responsible for preventing writes from occurring to the command buffer which is nearly full.","3D Command Decode","The command decoder  is responsible for reading and interpreting commands from the 3D Cmd Queue  and 3D Response Queue  and sending them as reformatted packets to the GEO block. The decoder performs data conversions for \u201cfast\u201d commands prior to feeding them to the GEO block or shadowing the state they change. The 3D Command Decode must be able to perform format conversions. The input data formats include all those allowed by the API (generally, al those allowed in the C language, or other programming language). The output formats from the 3D Command Decode are limited to those that can be processed by the hardware, and are generally either floating point or \u201ccolor\u201d formats. The exact bit definition of the color data format depends on how colors are represented through the rest of the pipeline.","The Command Decode starts at power up reading from the 3D Command Queue. When a DMA command is detected, the command decoder sends the command and data to the DMA controller . The DMA controller will begin transferring the data requested into the 3D response queue. The 3D Command Decoder then reads as many bytes as are specified in the DMA command from the 3D Response Queue, interpreting the data in the response queue as a normal command stream. When it has read the number of bytes specified in the DMA command, it switches back to reading from the regular command queue. While reading from the 3D Response Queue, all DMA commands are considered invalid commands.","This 3D command decoder is responsible for detecting invalid commands. Any invalid command should result in the generation of an Invalid Command Interrupt (see Interrupt Control for more details).","The 3D Command Decode also interprets and saves the current state vector required to send a vertex packet when a vertex command is detected in the queue. It also remembers the last 3 completed vertices inside the current \u201cbegin\u201d (see OpenGL specification) and their associated states, as well as the kind of \u201cbegin\u201d which was last encountered. When a context switch occurs, the 3D Command Decode must make these shadowed values available to the host for readout, so that the host can \u201cre-prime the pipe\u201d restarting the context later.","DMA Controller","The CFD DMA Controller  is responsible for starting and maintaining all DMA transactions to or from the DSGP card. DSGP is always the master of any DMA transfer, there is no need for the DMA controller to be a slave. The 2D Engine and the 3D Command Decode contend to be master of the DMA Controller. Both DMA writes and DMA reads are supported, although only the 2D block can initiate a DMA write. DSGP is always master of a DMA.","A DMA transfer is initiated as follows. A DMA command, along with the physical address of the starting location, and the number of bytes to transfer is written into either the 2D or 3D command queue. When that command is read by the 3D Command Decoder or 2D unit, a DMA request with the data is sent to the DMA Controller. In the case of a DMA write by 2D, the 2D unit begins to put data in the Write To Host Queue . Once the DMA controller finishes up any previous DMA, it acknowledges the DMA request and begins transferring data. If the DMA is a DMA write, the controller moves data from the Write To Host Queue either through AGI to system memory or through the Backend Input Bus to the framebuffer. If the DMA is a DMA read, the controller pulls data either from system memory through AGI or from the backend through the Backend Output Bus  into either the 2D Response Queue or 3D Response Queue. Once the controller has transferred the required number of bytes, it releases the DMA request, allowing the requesting unit to read the next command out of its Command Queue.","The DMA Controller should try to maximize the performance of the AGP Logic by doing non-cache line aligned read\/write to start the transaction (if necessary) followed by cache line transfers until the remainder of the transfer is less than a cache line (as recommended by the Maximizing AGP Performance white paper).","2D Response Queue","The 2D Response queue is the repository for data from a DMA read initiated by the 2D block. After the DMA request is sent, the 2D Engine reads from the 2D Response Queue, treating the contents the same as commands in the 2D Command Queue. The only restriction is if a DMA command is encountered in the response queue, it must be treated as an invalid command. After the number of bytes specified in the current DMA command are read from the response queue, the 2D Engine returns to reading commands from the 2D Command Queue.","3D Response Queue","The 3D Response queue is the repository for data from a DMA read initiated by 3D Command Decode. After the DMA request is sent, the command decode reads from the 3D Response Queue, treating the contents the same as commands in the 3D Command Queue. The only restriction is if a DMA command is encountered in the response queue, it must be treated as an invalid command. After the number of bytes specified in the current DMA command are read from the response queue, the 3D Command Decode returns to reading commands from the 3D Command Queue.","Write to Host Queue","The write to host queue contains data which 2D wants to write to the host through DMA. After 2D requests a DMA transfer that is to go out to system memory, it fills the host queue with the data, which may come from the ring or Backend. Having this small buffer allows the DMA engine to achieve peak AGP performance moving the data.","Interrupt Generator","An important part of the communication between the host and the DSGP board is done by interrupts. Interrupts are generally used to indicate infrequently occurring events and exceptions to normal operation. There are two Interrupt Cause Registers on the board that allow the host to read the registers and determine which interrupt(s) caused the interrupt to be generated. One of the Cause Registers is reserved for dedicated interrupts like retrace, and the other is for generic interrupts that are allocated by the kernel. For each of these, there are two physical addresses that the host can read in order to access the register. The first address is for polling, and does not affect the data in the Interrupt Cause Register. The second address is for servicing of interrupts and atomically clears the interrupt when it is read. The host is then responsible for servicing all the interrupts that that read returns as being on. For each of the Interrupt Cause Registers, there is an Interrupt Mask Register which determines whether an interrupt is generated when that bit in the Cause makes a 0 \u03a6  transition.","DSGP supports up to 64 different causes for an interrupt, a few of which are fixed, and a few of which are generic. Listed below are brief descriptions of each.","Retrace","The retrace interrupt happens approximately 85-120 times per second and is raised by the Backend hardware at some point in the vertical blanking period of the monitor. The precise timing is programmed into the Backend unit via register writes over the Backend Input Bus.","3D FIFO High Water","The 3D FIFO high water interrupt rarely happens when the pipe is running in performance mode but may occur frequently when the 3D pipeline is running at lower performance. The kernel mode driver programs the 3D High Water Entries register that indicates the number of entries which are allowed in the 3D Cmd Buffer. Whenever there are more entries than this are in the buffer, the high water interrupt is triggered. The kernel mode driver is then required to field the interrupt and prevent writes from occurring which might overflow the 3D buffer. In the interrupt handler, the kernel will check to see whether the pipe is close to draining below the high water mark. If it is not, it will disable the high water interrupt and enable the low water interrupt.","3D FIFO Low Water","When the 3D FIFO low water interrupt is enabled, an interrupt is generated if the number of entries in the 3D FIFO is less than the number in the 3D Low Water Entries register. This signals to the kernel that the 3D FIFO has cleared out enough that it is safe to allow programs to write to the 3D FIFO again.","2D FIFO High Water","This is exactly analogous to the 3D FIFO high water interrupt except that it monitors the 2D FIFO. The 2D FIFO high water interrupt rarely happens when the pipe is running in performance mode but may occur frequently when the 2D pipeline is running at lower performance. The kernel mode driver programs the 2D High Water Entries register that indicates the number of entries which are allowed in the 2D Cmd Buffer. Whenever there are more entries than this are in the buffer, the high water interrupt is triggered. The kernel mode driver is then required to field the interrupt and prevent writes from occurring which might overflow the 2D buffer. In the interrupt handler, the kernel will check to see whether the pipe is close to draining below the high water mark. If it is not, it will disable the high water interrupt and enable the low water interrupt.","2D FIFO Low Water","When the 2D FIFO low water interrupt is enabled, an interrupt is generated if the number of entries in the 2D FIFO is less than the number in the 2D Low Water Entries register. This signals to the kernel that the 2D FIFO has cleared out enough that it is safe to allow programs to write to the 2D FIFO again.","Access Violation","This should be triggered whenever there is a write or read to a nonexistent register.","Invalid Command","This should be triggered whenever a garbage command is detected in a FIFO (if possible) or if a privileged command is written into a FIFO by a user program. The kernel should field this interrupt and kill the offending task.","Texture Miss","This interrupt is generated when the texture unit tries to access a texture that is not loaded into texture memory. The texture unit sends the write to the Interrupt Cause Register across the ring, and precedes this write with a ring write to the Texture Miss ID register. The kernel fields the interrupt and reads the Texture Miss ID register to determine which texture is missing, sets up a texture DMA to download the texture and update the texture TLB, and then clears the interrupt.","Generic Interrupts","The rest of the interrupts in the Interrupt Cause register are generic. Generic interrupts are triggered by software sending a command which, upon completion, sends a message to the interrupt generator turning on that interrupt number. All of these interrupts are generated by a given command reaching the bottom of the Backend unit, having come from either the 2D or 3D pipeline. Backend sends a write through dedicated wires to the Interrupt Cause Register (it is on the same chip, so using the ring would be overkill).","Provisional U.S. patent application Ser. No. 60\/097,336, hereby incorporated by reference, assigned to Raycer, Inc. pertains to a novel graphics processor. In that patent application, it is described that pipeline state data (also called \u201cmode\u201d data) is extracted and later injected, in order to provide a highly efficient pipeline process and architecture. That patent application describes a novel graphics processor in which hidden surfaces may be removed prior to the rasterization process, thereby allowing significantly increased performance in that computationally expensive per-pixel calculations are not performed on pixels which have already been determined to not affect the final rendered image.","System Overview","In a traditional graphics pipeline, the state changes are incremental; that is, the value of a state parameter remains in effect until it is changed, and changes simply overwrite the older value because they are no longer needed. Furthermore, the rendering is linear; that is, primitives are completely rendered (including rasterization down to final pixel colors) in the order received, utilizing the pipeline state in effect at the time each primitive is received. Points, lines, triangles, and quadrilaterals are examples of graphical primitives. Primitives can be input into a graphics pipeline as individual points, independent lines, independent triangles, triangle strips, triangle fans, polygons, quads, independent quads, or quad strips, to name the most common examples. Thus, state changes are accumulated until the spatial information for a primitive (i.e., the completing vertex) is received, and those accumulated states are in effect during the rendering of that primitive.","In contrast to the traditional graphics pipeline, the pipeline of the present invention defers rasterization (the system is sometimes called a deferred shader) until after hidden surface removal. Because many primitives are sent into the graphics pipeline, each corresponding to a particular setting of the pipeline state, multiple copies of pipeline state information must be stored until used by the rasterization process. The innovations of the present invention are an efficient method and apparatus for storing, retrieving, and managing the multiple copies of pipeline state information. One important innovation of the present invention is the splitting and subsequent merging of the data flow of the pipeline, as shown in FIG. B. The separation is done by the MEX step in the data flow, and this allows for independently storing the state information and the spatial information in their corresponding memories. The merging is done in the MIJ step, thereby allowing visible (i.e., not guaranteed hidden) portions of polygons to be sent down the pipeline accompanied by only the necessary portions of state information. In the alternative embodiment of FIG. B, additional steps for sorting by tile and reading by tile are added. As described later, a simplistic separation of state and spatial information is not optimal, and a more optimal separation is described with respect to another alternative embodiment of this invention.","An embodiment of the invention will now be described. Referring to FIG. B, the GEO (i.e., \u201cgeometry\u201d) block is the first computation unit at the front of the graphical pipeline. The GEO block receives the primitives in order, performs vertex operations (e.g., transformations, vertex lighting, clipping, and primitive assembly), and sends the data down the pipeline. The Front End, composed of the AGI (i.e., \u201cadvanced graphics interface\u201d) and CFD (i.e., \u201ccommand fetch and decode\u201d) blocks deals with fetching (typically by PIO, programmed input\/output, or DMA, direct memory access) and decoding the graphics hardware commands. The Front End loads the necessary transform matrices, material and light parameters and other pipeline state settings into the input registers of the GEO block. The GEO block sends a wide variety of data down the pipeline, such as transformed vertex coordinates, normals, generated and\/or pass-through texture coordinates, per-vertex colors, material setting, light positions and parameters, and other shading parameters and operators. It is to be understood that FIG. B is one embodiment only, and other embodiments are also envisioned. For example, the CFD and GEO can be replaced with operations taking place in the software driver, application program, or operating system.","The MEX (i.e., \u201cmode extraction\u201d) block is between the GEO and SRT blocks. The MEX block is responsible for saving sets of pipeline state settings and associating them with corresponding primitives. The Mode Injection (MIJ) block is responsible for the retrieval of the state and any other information associated with a primitive (via various pointers, hereinafter, generally called Color Pointers and material, light and mode (MLM) Pointers) when needed. MIJ is also responsible for the repackaging of the information as appropriate. An example of the repackaging occurs when the vertex data in Polygon Memory is retrieved and bundled into triangle input packets for the FRG block","The MEX block receives data from the GEO block and separates the data stream into two parts: 1) spatial data, including vertices and any information needed for hidden surface removal (shown as V, S, and Sin FIG. B); and 2) everything else (shown as V and S in FIG. B). Spatial data are sent to the SRT (i.e., \u201csort\u201d) block, which stores the spatial data into a special buffer called Sort Memory. The \u201ceverything else\u201d\u2014light positions and parameters and other shading parameters and operators, colors, texture coordinates, and so on\u2014is stored in another special buffer called Polygon Memory, where it can be retrieved by the MIJ (i.e., \u201cmode injection\u201d) block. In one embodiment, Polygon Memory is multi buffered, so the MIJ block can read data for one frame, while the MEX block is storing data for another frame. The data stored in Polygon Memory falls into three major categories: 1) per-frame data (such as lighting, which generally changes a few times during a frame), 2) per-object data (such as material properties, which is generally different for each object in the scene); and 3) per-vertex data (such as color, surface normal, and texture coordinates, which generally have different values for each vertex in the frame). If desired, the MEX and MIJ blocks further divide these categories to optimize efficiency. An architecture may be more efficient if it minimizes memory use or alternatively if it minimizes data transmission. The categories chosen will affect these goods.","For each vertex, the MEX block sends the SRT block a Sort packet containing spatial data and a pointer into the Polygon Memory. (The pointer is called the Color Pointer, which is somewhat misleading, since it is used to retrieve information in addition to color.) The Sort packet also contains fields indicating whether the vertex represents a point, the endpoint of a line, or the corner of a triangle. To comply with order-dependent APIs (Application Program Interfaces), such as OpenGL and D3D, the vertices are sent in a strict time sequential order, the same order in which they were fed into the pipeline. (For an order independent API, the time sequential order could be perturbed.) The packet also specifies whether the current vertex is the last vertex in a given primitive (i.e., \u201ccompletes\u201d the primitive). In the case of triangle strips or fans, and line strips or loops, the vertices are shared between adjacent primitives. In this case, the packets indicate how to identify the other vertices in each primitive.","The SRT block receives vertices from the MEX block and sorts the resulting points, lines, and triangles by tile (i.e., by region within the screen). In multi-buffered Sort Memory, the SRT block maintains a list of vertices representing the graphic primitives, and a set of Tile Pointer Lists, one list for each tile in the frame. When SRT receives a vertex that completes a primitive (such as the third vertex in a triangle), it checks to see which tiles the primitive touches. For each tile a primitive touches, the SRT block adds a pointer to the vertex to that tile's Tile Pointer List. When the SRT block has finished sorting all the geometry in a frame (i.e. the frame is complete), it sends the data to the STP (i.e., \u201csetup\u201d) block. For simplicity, each primitive output from the SRT block is contained in a single output packet, but an alternative would be to send one packet per vertex. SRT sends its output in tile-by-tile order: all of the primitives that touch a given tile, then all of the primitives that touch the next tile, and so on. Note that this means that SRT may send the same primitive many times, once for each tile it touches.","The MIJ block retrieves pipeline state information\u2014such as colors, material properties, and so on\u2014from the Polygon Memory and passes it downstream as required. To save bandwidth, the individual downstream blocks cache recently used pipeline state information. The MIJ block keeps track of what information is cached downstream, and only sends information as necessary. The MEX block in conjunction with the MIJ block is responsible for the management of graphics state related information.","The SRT block receives the time ordered data and bins it by tile. (Within each tile, the list is in time order.) The CUL (i.e., cull) block receives the data from the SRT block in tile order, and performs a hidden surface removal method (i.e., \u201cculls\u201d out parts of the primitives that definitely do not contribute to the final rendered image). The CUL block outputs packets that describe the portions of primitives that are visible (or potentially visible) in the final image. The FRG (i.e., fragment) block performs interpolation of primitive vertex values (for example, generating a surface normal vector for a location within a triangle from the three surface normal values located at the triangle vertices). The TEX block (i.e., texture) block and PHB (i.e., Phong and Bump) block receive the portions of primitives that are visible (or potentially visible) and are responsible for generating texture values and generating final fragment color values, respectively. The last block, the PIX (i.e., Pixel) block, consumes the final fragment colors to generate the final picture.","In one embodiment, the CUL block generates VSPs, where a VSP (Visible Stamp Portion) corresponds to the visible (or potentially visible) portion of a polygon on a stamp, where a \u201cstamp\u201d is a plurality of adjacent pixels. An example stamp configuration is a block of four adjacent pixels in a 2\u00d72 pixel subarray. In one embodiment, a stamp is configured such that the CUL block is capable of processing, in a pipelined manner, a hidden surface removal method on a stamp with the throughput of one stamp per clock cycle.","A primitive may touch many tiles and therefore, unlike traditional rendering pipelines, may be visited many times during the course of rendering the frame. The pipeline must remember the graphics state in effect at the time the primitive entered the pipeline, and recall it every time it is visited by the pipeline stages downstream from SRT.","The blocks downstream from MIJ (i.e., FRG, TEX, PHB, and PIX) each have one or more data caches that are managed by MIJ. MIJ includes a multiplicity of tag RAMs corresponding to these data caches, and these tag RAMs are generally implemented as fully associative memories (i.e., content addressable memories). The tag RAMs store the address in Polygon Memory (or other unique identifier, such as a unique part of the address bits) for each piece of information that is cached downstream. When a VSP is output from CUL to MIJ, the MIJ block determines the addresses of the state information needed to generate the final color values for the pixels in that VSP, then feeds these addresses into the tag RAMs, thereby identifying the pieces of state information that already reside in the data caches, and therefore, by process of elimination, determines which pieces of state information are missing from the data caches. The missing state information is read from Polygon Memory and sent down the pipeline, ahead of the corresponding VSP, and written into the data caches. As VSPs are sent from MIJ, indices into the data caches (i.e., the addresses into the caches) are added, allowing the downstream blocks to locate the state information in their data caches. When the VSP reaches the downstream blocks, the needed state information is guaranteed to reside in the data caches at the time it is needed, and is found using the supplied indices. Hence, the data caches are always \u201chit\u201d.","FIG. B shows the GEO to FRG part of the pipeline, and illustrates state information and vertex information flow (other information flow, such as BeginFrame packets, EndFrame packets, and Clear packets are not shown) through one embodiment of this invention. Vertex information is received from a system processor or from a Host Memory (FIG. B) by the CFD block. CFD obtains and performs any needed format conversions on the vertex information and passes it to the GEO block. Similarly, state information, generally generated by the application software, is received by CFD and passed to GEO. State information is divided into three general types:","S. State information which is consumed in GEO. This type of state information typically comprises transform matrices and lighting and material information that is only used for vertex-based lighting (e.g. Gouraud shading).","S. State information which is needed for hidden surface removal (HSR), which in turn consists of two sub-types:\n\n","S. State information which is needed for rasterization (per Pixel processing) which is stored in Polygon Memory. This type of state typically comprises the per-frame data and per-object data, and generally includes pipeline mode selection (e.g., sorted transparency mode selection), lighting parameter setting for a multiplicity of lights, and material properties and other shading properties. MEX stores state information S in Polygon Memory for future use.","Note that the typical division between state information Sand Sis implementation dependent, and any particular state parameter could be moved from one sub-type to the other. This division may also be tuned to a particular application.","As shown in FIG. B, GEO processes vertex information and passes the resultant vertex information V to MEX. The resultant vertex information V is separated by GEO into two groups:","V. Any per-vertex information that is needed for hidden surface removal, including screen coordinate vertex locations. This information is passed to SRT, where it is stored, combined with state information S, in Sort Memory for later use.","V. Per-vertex state information that is not needed for hidden surface removal, generally including texture coordinates, the vertex location in eye coordinates, surface normals, and vertex colors and shading parameters. This information is stored into Polygon Memory for later use.","Other packets that get sent into the pipeline include: the BeginFrame packet, that indicates the start of a block of data to be processed and stored into Sort Memory and Polygon Memory; the EndFrame packet, that indicates the end of the block of data; and the Clear packet, that indicates one or more buffer clear operations are to be performed.","An alternate embodiment is shown in FIG. B, where the STP step occurs before the SRT step. This has the advantage of reducing total computation because, in the embodiment of FIG. B, the STP step would be performed on the same primitive multiple times (once for each time it is read from Sort Memory). However, the embodiment of FIG. B has the disadvantage of requiring a larger amount of Sort Memory because more data will be stored there.","In one embodiment, MEX and MIJ share a common memory interface to Polygon Memory RAM, as shown in FIG. B, while SRT has a dedicated memory interface to Sort memory. As an alternative, MEX, SRT, and MIJ can share the same memory interface, as shown in FIG. B. This has the advantage of making more efficient use of memory, but requires the memory interface to arbitrate between the three units. The RAM shown in FIG. B and FIG. B would generally be dynamic memory (DRAM) that is external to the integrated circuits with the MEX, SRT, and MIJ functions; however imbedded DRAM could be used. In the preferred embodiment, RAMBUS DRAM (RDRAM) is used, and more specifically, Direct RAMBUS DRAM (DRDRAM) is used.","System Details\u2014Mode Extraction (MEX) Block","The MEX block is responsible for the following: (1) Receiving packets from GEO; (2) Performing any reprocessing needed on those data packets; (3) Appropriately saving the information needed by the shading portion of the pipeline (for retrieval later by MIJ) in Polygon Memory; (4) Attaching state pointers to primitives sent to SRT, so that MIJ knows the state associated with this primitive; (5) Sending the information needed by SRT, STP, and CUL to the SRT block; and (6) Handling Polygon Memory and Sort Memory overflow.","The SRT-STP-CUL part of the pipeline determines which portions of primitives are not guaranteed to be hidden, and sends these portions down the pipeline (each of these portions are hereinafter called a VSP). VSPs are composed of one or more pixels which need further processing, and pixels within a VSP are from the same primitive. The pixels (or samples) within these VSPs are then shaded by the FRG-TEX-PHB part of the pipeline. (Hereinafter, \u201cshade\u201d will mean any operations needed to generate color and depth values for pixels, and generally includes texturing and lighting.) The VSPs output from the CUL block to MIJ block are not necessarily ordered by primitive. If CUL outputs VSPs in spatial order, the VSPs will be in scan order on the tile (i.e., the VSPs for different primitives may be interleaved because they are output across rows within a tile). The FRG-TEX-PHB part of the pipeline needs to know which primitive a particular VSP belongs to; as well as the graphics state at the time that primitive was first introduced. MEX associates a Color Pointer with each vertex as the vertex is sent to SRT, thereby creating a link between the vertex information V and the corresponding vertex information V. Color Pointers are passed along through the SRT-STP-CUL part of the pipeline, and are included in VSPs. This linkage allows MIJ to retrieve, from Polygon Memory, the vertex information V that is needed to shade the pixels in any particular VSP. MIJ also locates in Polygon Memory, via the MLM Pointers, the pipeline state information S that is also needed for shading of VSPs, and sends this information down the pipeline.","MEX thus needs to accumulate any state changes that have occurred since the last state save. The state changes become effective as soon as a vertex or in a general pipeline a command that indicates a \u201cdraw\u201d command (in a Sort packet) is encountered. MEX keeps the MEX State Vector in on-chip memory or registers. In one embodiment, MEX needs more than 1 k bytes of on-chip memory to store the MEX State Vector. This is a significant amount of information needed for every vertex, given the large number of vertices passing down the pipeline. In accordance with one aspect of the present invention, therefore, state data is partitioned and stored in Polygon Memory such that a particular setting for a partition is stored once and recalled a minimal number of times as needed for all vertices to which it pertains.","System Details\u2014MIJ (Mode Injection) Block","The Mode Injection block resides between the CUL block and the rest of the downstream 3D pipeline. MIJ receives the control and VSP packets from the CUL block. On the output side, MIJ interfaces with the FRG and PIX blocks.","The MIJ block is responsible for the following: (1) Routing various control packets such as BeginFrame, EndFrame, and BeginTile to FRG and PIX units. (2) Routing prefetch packets from SRT to PIX. (3) Using Color Pointers to locate (generally this means generating an address) vertex information V for all the vertices of the primitive corresponding to the VSP and to also locate the MLM Pointers associated with the primitive. (4) Determining whether MLM Pointers need to be read from Polygon Memory and reading them when necessary. (5) Keeping track of the contents of the State Caches. In one embodiment, these state caches are: Color, TexA, TexB, Light, and Material caches (for the FRGt, TEX, and PHB blocks) and PixelMode and Stipple caches (for the PIX block) and associating the appropriate cache pointer to each cache miss data packet. (6) Determining which packets (vertex information V and\/or pipeline state information S) need to be retrieved from Polygon Memory by determining when cache misses occur, and then retrieving the packets. (7) Constructing cache fill packets from the packets retrieved from Polygon Memory and sending them down the pipeline to data caches. (In one embodiment, the data caches are in the FRG, TEX, PHB, and PIX blocks.). (8) Sending data to the fragment and pixel blocks. (10) Processing stalls in the pipeline. (11) Signaling to MEX when the frame is done. (12) Associating the state with each VSP received from the CUL block.","MIJ thus deals with the retrieval of state as well as the per-vertex data needed for computing the final colors for each fragment in the VSP. The entire state can be recreated from the information kept in the relatively small Color Pointer.","MIJ receives VSP packets from the CUL block. The VSPs output from the CUL block to MIJ are not necessarily ordered by primitives. In most cases, they will be in the VSP scan order on the tile, i.e. the VSPs for different primitives may be interleaved. In order to light, texture and composite the fragments in the VSPs, the pipeline stages downstream from the MIJ block need information about the type of the primitive (e.g., point, line, triangle, line-mode triangle); its vertex information V (such as window and eye coordinates, normal, color, and texture coordinates at the vertices of the primitive); and the state information S that was active when the primitive was received by MEX. State information S is not needed downstream of MIJ.","MIJ starts working on a frame after it receives a BeginFrame packet from CUL. The VSP processing for the frame begins when CUL outputs the first VSP for the frame.","The MEX State Vector","For state information S, MEX receives the relevant state packets and maintains a copy of the most recently received state information S in the MEX State Vector. The MEX State Vector is divided into a multiplicity of state partitions. FIG. B shows the partitioning used in one embodiment, which uses nine partitions for state information S. FIG. B depicts the names the various state packets that update state information S in the MEX State Vector. These packets are: MatFront packet, describing shading properties and operations of the front face of a primitive; MatBack packet, describing shading properties and operations of the back face of a primitive; TexAFront packet, describing the properties of the first two textures of the front face of a primitive; TexABack packet, describing the properties and operations of the first two textures of the back face of a primitive; TexBFront packet, describing the properties and operations of the rest of the textures of the front face of a primitive; TexBBack packet, describing the properties and operations of the rest of the textures of the back face of a primitive; Light packet, describing the light setting and operations; PixMode packet, describing the per-fragment operation parameters and operations done in the PIX block; and Stipple packet, describing the stipple parameters and operations. When a partition within the MEX State Vector has changed, and may need to be saved for later use, its corresponding one of Dirty Flag D through D is, in one embodiment, asserted, indicating a change in that partition has occurred. FIG. B shows the partitions within the MEX State Vector that have Dirty Flags.","The Light partition of the MEX State Vector contains information for a multiplicity of lights used in fragment lighting computations as well as the global state affecting the lighting of a fragment such as the fog parameters and other shading parameters and operations, etc. The Light packet generally includes the following per-light information: light type, attenuation constants, spotlight parameters, light positional information, and light color information (including ambient, diffuse, and specular colors). In this embodiment, the light cache packet also includes the following global lighting information: global ambient lighting, fog parameters, and number of lights in use.","When the Light packet describes eight lights, the Light packet is about 300 bytes, (approximately 300 bits for each of the eight lights plus 120 bits of global light modes). In one embodiment, the Light packet is generated by the driver or application software and sent to MEX via the GEO block. The GEO block does not use any of this information.","Rather than storing the lighting state as one big block of data, an alternative is to store per-light data, so that each light can be managed separately. This would allow less data to be transmitted down the pipeline when there is a light parameter cache miss in MIJ. Thus, application programs would be provided \u201clighter weight\u201d switching of lighting parameters when a single light is changed.","For state information S, MEX maintains two partitions, one for state information Sand one for state information S. State information S(received in VrtxMode packets) is always saved into Sort Memory with every vertex, so it does not need a Dirty Flag. State information S(received in CullMode packets) is only saved into Sort Memory when it has been changed and a new vertex is received, thus it requires a Dirty Flag (D). The information in CullMode and VrtxMode packets is sent to the Sort-Setup-Cull part of the pipeline.","The packets described do not need to update the entire corresponding partition of the MEX State Vector, but could, for example, update a single parameter within the partition. This would make the packets smaller, but the packet would need to indicate which parameters are being updated.","When MEX receives a Sort packet containing vertex information V (specifying a vertex location), the state associated with that vertex is the copy of the most recently received state (i.e., the current values of vertex information V and state information S, S, and S). Vertex information V (in Color packets) is received before vertex information V (received in Sort packets). The Sort packet consists of the information needed for sorting and culling of primitives, such as the window coordinates of the vertex (generally clipped to the window area) and primitive type. The Color packet consists of per-vertex information needed for lighting, texturing, and shading of primitives such as the vertex eye-coordinates, vertex normals, texture coordinates, etc. and is saved in Polygon Memory to be retrieved later. Because the amount of per-vertex information varies with the visual complexity of the 3D object (e.g., there is a variable number of texture coordinates, and the need for eye coordinate vertex locations depends on whether local lights or local viewer is used), one embodiment allows Color packets to vary in length. The Color Pointer that is stored with every vertex indicates the location of the corresponding Color packet in Polygon Memory. Some shading data and operators change frequently, others less frequently, these may be saved in different structures or may be saved in one structure.","In one embodiment, in MEX, there is no default reset of state vectors. It is the responsibility of the driver\/software to make sure that all state is initialized appropriately. To simplify addressing, all vertices in a mesh are the same size.","Dirty Flags and MLM Pointer Generation","MEX keeps a Dirty Flag and a pointer (into Polygon Memory) for each partition in the state information S and some of the partitions in state information S. Thus, in the embodiment of FIG. B, there are 10 Dirty Flags and 9 mode pointers, since CullMode does not get saved in the Polygon Memory and therefore does not require a pointer. Every time MEX receives an input packet containing pipeline state, it updates the corresponding portions of the MEX State Vector. For each state partition that is updated, MEX also sets the Dirty Flag corresponding to that partition.","When MEX receives a Sort packet (i.e. vertex information V), it examines the Dirty Flags to see if any part of the state information S has been updated since the last save. All state partitions that have been updated (indicated by their Dirty Flags being set) and are relevant (i.e., the correct face) to the rendering of the current primitive are saved to the Polygon Memory, their pointers updated, and their Dirty Flags are cleared. Note that some partitions of the MEX State Vector come in a back-front pair (e.g., MatBack and MatFront), which means only one of the two of more in the set are relevant for a particular primitive. For example, if the Dirty Bits for both TexABack and TexAFront are set, and the primitive completed by a Sort packet is deemed to be front facing, then TexAFront is saved to Polygon Memory, the FrontTextureAPtr is copied to the TextureAPtr pointer within the set of six MLM Pointers that get written to Polygon Memory, and the Dirty Flag for TexAFront is cleared. In this example, the Dirty Flag for TexABack is unaffected and remains set. This selection process is shown schematically in FIG. B by the \u201cmux\u201d (i.e., multiplexor) operators.","Each MLM Pointer points to the location of a partition of the MEX State Vector that has been stored into Polygon Memory. If each stored partition has a size that is a multiple of some smaller memory block (e.g. each partition is a multiple of a sixteen byte memory block), then each MLM Pointer is the block number in Polygon Memory, thereby saving bits in each MLM Pointer. For example, if a page of Polygon Memory is 32 MB (i.e. 2bytes), and each block is 16 bytes, then each MLM Pointer is 21 bits. All pointers into Polygon Memory and Sort Memory can take advantage of the memory block size to save address bits.","In one embodiment, Polygon Memory is implemented using Rambus Memory, and in particular, Direct Rambus Dynamic Random Access Memory (DRDRAM). For DRDRAM, the most easily accessible memory block size is a \u201cdualoct\u201d, which is sixteen nine-bit bytes, or a total of 144 bits, which is also eighteen eight-bit bytes. With a set of six MLM Pointer stored in one 144-bit dualoct, each MLM Pointer can be 24 bits. With 24-bit values for an MLM Pointer, a page of Polygon Memory can be 256 MB. In the following examples, MLM Pointers are assumed to be 24-bit numbers.","MLM Pointers are used because state information S can be shared amongst many primitives. However, storing a set of six MLM Pointers could require about 16 bytes, which would be a very large storage overhead to be included in each vertex. Therefore, a set of six MLM Pointers is shared amongst a multiplicity of vertices, but this can only be done if the vertices share the exact same state information S (that is, the vertices would have the same set of six MLM Pointers). Fortunately, 3D application programs generally render many vertices with the same state information S. If fact, most APIs require the state information S to be constant for all the vertices in a polygon mesh (or, line strips, triangle strips, etc.). In the case of the OpenGL API, state information S must remain unchanged between\u201cglBegin\u201d and \u201cglEnd\u201d statements.","Color Pointer Generation","There are many possible variations to design the Color Pointer function, so only one embodiment will be described. FIG. B shows an example triangle strip with four triangles, composed of six vertices. Also shown in the example of FIG. B is the six corresponding vertex entries in Sort Memory, each entry including four fields within each Color Pointer: ColorAddress; ColorOffset; ColorType; and ColorSize. As described earlier, the Color Pointer is used to locate the vertex information V within Polygon Memory, and the ColorAddress field indicates the first memory block (in this example, a memory block is sixteen bytes). Also shown in FIG. B is the Sort Primitive Type parameter in each Sort Memory entry; this parameter describes how the vertices are joined by SRT to create primitives, where the possible choices include: tri_strip (triangle strip); tri_fan (triangle fan); line_loop; line_strip; point; etc. In operation, many parameters in a Sort Memory entry are not needed if the corresponding vertex does not complete a primitive. In FIG. B, these unneeded parameters are in V, and V, and the unused parameters are: Sort Primitive Type; state information S; and all parameters within the Color Pointer. FIG. B continues the example in FIG. B and shows two sets of MLM Pointers and eight sets of vertex information V in Polygon Memory.","The address of vertex information V in Polygon Memory is found by multiplying the ColorAddress by the memory block size. As an example, let us consider Vas described in FIG. B and FIG. B. Its ColorAddress, 0x00141, is multiplied by 0x10 to get the address of 0x0010410. This computed address is the location of the first byte in the vertex information V for that vertex. The amount of data in the vertex information V for this vertex is indicated by the ColorSize parameter; and, in the example, ColorSize equals 0x02, indicating two memory blocks are used, for a total of 32 bytes. The ColorOffest and ColorSize parameters are used to locate the MLM Pointers by the formula (where B is the memory block size):\n\n(Address of Pointers)=(ColorAddress*)\u2212(ColorSize*ColorOffset+1)*\n\nThe ColorType parameter indicates the type of primitive (triangle, line, point, etc.) and whether the primitive is part of a triangle mesh, line loop, line strip, list of points, etc. The ColorType is needed to find the vertex information V for all the vertices of the primitive.\n","The Color Pointer included in a VSP is the Color Pointer of the corresponding primitive's completing vertex. That is, the last vertex in the primitive, which is the 3vertex for a triangle, 2for a line, etc.","In the preceding discussion, the ColorSize parameter was described as binary coded number. However, a more optimal implementation would have this parameter as a descriptor, or index, into a table of sizes. Hence, in one embodiment, a 3-bit parameter specifies eight sizes of entries in Polygon Memory, ranging, for example, from one to fourteen memory blocks.","The maximum number of vertices in a mesh (in MEX) depends on the number of bits in the ColorOffset parameter in the Color Pointer. For example, if the ColorOffset is eight bits, then the maximum number of vertices in a mesh is 256. Whenever an application program specifies a mesh with more than the maximum number of vertices that MEX can handle, the software driver must split the mesh into smaller meshes. In one alternative embodiment, MEX does this splitting of meshes automatically, although it is noted that the complexity is not generally justified because most application programs do not use large meshes.","Clear Packets and Clear Operations","In addition to the packets described above, Clear Packets are also sent down the pipeline. These packets specify buffer clear operations that set some portion of the depth values, color values, and\/or stencil values to a specific set of values. For use in CUL, Clear Packets include the depth clear value. Note that Clear packets are also processed similarly, with MEX treating buffer clear operations as a \u201cprimitive\u201d because they are associated with pipeline state information stored in Polygon Memory. Therefore, the Clear Packet stored into Sort Memory includes a Color Pointer, and therefore is associated with a set of MLM Pointers; and, if Dirty Flags are set in MEX, then state information S is written to Polygon Memory.","In one embodiment, which provides improved efficiency for Clear Packets, all the needed state information S needed for buffer clears is completely contained within a single partition within the MEX State Vector (in one embodiment, this is the PixMode partition of the MEX State Vector). This allows the Color Pointer in the Clear Packet to be replaced by a single MLM Pointer (the PixModePtr). This, in turn, means that only the Dirty Flag for the PixMode partition needs to be examined, and only that partition is conditionally written into Polygon Memory. Other Dirty Flags are left unaffected by Clear Packets.","In another embodiment, Clear Packets take advantage of circumstances where none of the data in the MEX State Vector is needed. This is accomplished with a special bit, called \u201cSendToPixel\u201d, included in the Clear packet. If this bit is asserted, then the clear operation is known to uniformly affect all the values in one or more buffers (i.e., one or more of: depth buffer, color buffer, and\/or the stencil buffer) for a particular display screen (i.e., window). Specifically, this clear operation is not affected by scissor operations or any bit masking. If SendToPixel is asserted, and no geometry has been sent down the pipeline yet for a given tile, then the clear operation can be incorporated into the Begin Tile packet (not send along as a separate packet from SRT), thereby avoiding frame buffer read operations usually performed by BKE.","Polygon Memory Management","For the page of Polygon Memory being written, MEX maintains pointers for the current write locations: one for vertex information V; and one for state information S. The VertexPointer is the pointer to the current vertex entry in Polygon Memory. VertexCount is the number of vertices saved in Polygon Memory since the last state change. VertexCount is assigned to the ColorOffset. VertexPointer is assigned to the ColorPointer for the Sort primitives. Previous vertices are used during handling of memory overflow. MIJ uses the ColorPointer, ColorOffset and the vertex size information (encoded in the ColorType received from GEO) to retrieve the MLM Pointers and the primitive vertices from the Polygon Memory.","In one embodiment, CUL outputs VSPs in primitive order, rather than spatial order. That is, all the VSPs corresponding to a particular primitive are output before VSPs from another primitive. However, if CUL processes data tile-by-tile, then VSPs from the same primitive are still interleaved with VSPs from other primitives. Outputting VSPs in primitive order helps with caching data downstream of MIJ.","In an alternate embodiment, the entire MEX State Vector is treated as a single memory, and state packets received by MEX update random locations in the memory. This requires only a single type of packet to update the MEX State Vector, and that packet includes an address into the memory and the data to place there. In one version of this embodiment, the data is of variable width, with the packet having a size parameter.","In another alternate embodiment, the PHB and\/or TEX blocks are microcoded processors, and one or more of the partitions of the MEX State Vector include microcode. For example, in one embodiment, the TexAFront TexABack, TexBFront, and TexBBack packets contain the microcode. Thus, in this example, a 3D object has its own microcode that describes how its shading is to be done. This provides a mechanism for more complex lighting models as well as user-coded shaders. Hence, in a deferred shader, the microcode is executed only for pixels (or samples) that affect the final picture.","In one embodiment of this invention, pipeline state information is only input to the pipeline when it has changed. Specifically, an application program may use API (Application Program Interface) calls to repeatedly set the pipeline state to substantially the same values, thereby requiring (for minimal Polygon Memory usage) the driver software to determine which state parameters have changed, and then send only the changed parameters into the pipeline. This simplifies the hardware because the simple Dirty Flag mechanism can be used to determine whether to store data into Polygon Memory. Thus, when a software driver performs state change checking, the software driver maintains the state in shadow registers in host memory. When the software driver detects that the new state is the same as the immediately previous state, the software driver does not send any state information to the hardware, and the hardware continues to use the same state information. Conversely, if the software driver detects that there has been a change in state, the new state information is stored into the shadow registers in the host, and new state information is sent to hardware, so that the hardware may operate under the new state information.","In an alternate embodiment, MEX receives incoming pipeline state information and compares it to values in the MEX State Vector. For any incoming values are different than the corresponding values in the MEX State Vector, appropriate Dirty Flags are set. Incoming values that are not different are discarded and do not cause any changes in Dirty Flags. This embodiment requires additional hardware (mostly in the form of comparitors), but reduces the work required of the driver software because the driver does not need to perform comparisons.","In another embodiment of this invention, MEX checks for certain types of state changes, while the software driver checks for certain other types of hardware state changes. The advantage of this hybrid approach is that hardware dedicated to detecting state change can be minimized and used only for those commonly occurring types of state change, thereby providing high speed operation, while still allowing all types of state changes to be detected, since the software driver detects any type of state change not detected by the hardware. In this manner, the dedicated hardware is simplified and high speed operation is achieved for the vast majority of types of state changes, while no state change can go unnoticed, since software checking determines the other types of state changes not detected by the dedicated hardware.","In another alternative embodiment, MEX first determines if the updated state partitions to be stored in Polygon Memory already exist in Polygon Memory from some previous operation and, if so, sets pointers to point to the already existing state partitions stored in Polygon Memory. This method maintains a list of previously saved state, which is searched sequentially (in general, this would be slower), or which is searched in parallel with an associative cache (i.e., a content addressable memory) at the cost of additional hardware. These costs may be offset by the saving of significant amounts of Polygon Memory.","In yet another alternative embodiment, the application program is tasked with the requirement that it attach labels to each state, and causes color vertices to refer to the labeled state. In this embodiment, labeled states are loaded into Polygon Memory either on an as needed basis, or in the form of a pre-fetch operation, where a number of labeled states are loaded into Polygon Memory for future use. This provides a mechanism for state vectors to be used for multiple rendering frames, thereby reducing the amount of data fed into the pipeline.","In one embodiment of this invention, the pipeline state includes not just bits located within bit locations defining particular aspects of state, but pipeline state also includes software (hereinafter, called microcode) that is executed by processors within the pipeline. This is particularly important in the PHB block because it performs the lighting and shading operation; hence, a programmable shader within a 3D graphics pipeline that does deferred shading greatly benefits from this innovation. This benefit is due to eliminating (via the hidden surface removal process, or CUL block) computationally expensive shading of pixels (or pixel fragments) that would be shaded in a conventional 3D renderer. Like all state information, this microcode is sent to the appropriate processing units, where it is executed in order to effect the final picture. Just as state information is saved in Polygon Memory for possible future use, this microcode is also saved as part of state information S. In one embodiment, the software driver program generates this microcode on the fly (via linking pre-generated pieces of code) based on parameters sent from the application program. In a simpler embodiment, the driver software keeps a pre-compiled version of microcode for all possible choices of parameters, and simply sends appropriate versions of microcode (or pointers thereto) into the pipeline as state information is needed. In another alternative embodiment, the application program supplies the microcode.","As an alternative, more pointers are included in the set of MLM Pointers. This could be done to make smaller partitions of the MEX State Vector, in the hopes of reducing the amount of Polygon Memory required. Or, this is done to provide pointers for partitions for both front-facing and back-facing parameters, thereby avoiding the breaking of meshes when the flip from front-facing to back-facing or visa versa.","In Sort Memory, vertex locations are either clipped to the window (i.e., display screen) or not clipped. If they are not clipped, high precision numbers (for example, floating point) are stored in Sort Memory. If they are clipped, reduced precision can be used (fixed-point is generally sufficient), but, in prior art renderers, all the vertex attributes (surface normals, texture coordinates, etc.) must also be clipped, which is a computationally expensive operation. As an optional part of the innovation of this invention, clipped vertex locations are stored in Sort Memory, but unclipped attributes are stored in Polygon Memory (along with unclipped vertex locations).  shows a display screen with a triangle strip composed of six vertices; these vertices, along with their attributes, are stored into Polygon Memory.  shown the clipped triangles that are stored into Sort Memory. Note, for example, that triangle V-V-Vis represented by two on-display triangles: V-V-Vand V-V-V, where Vand Vare the vertices created by the clipping process. In one embodiment, Front Facing can be clipped or unclipped attributes, or if the \u201con display\u201d vertices are correctly ordered \u201cfacing\u201d can be computed.","A useful alternative provides two ColorOffset parameters in the Color Pointer, one being used to find the MLM Pointers; the other being used to find the first vertex in the mesh. This makes it possible for consecutive triangle fans to share a single set of MLM Pointers.","For a low-cost alternative, the GEO function of the present invention is performed on the host processor, in which case CFD, or host computer, feeds directly into MEX.","As a high-performance alternative, multiple pipelines are run in parallel. Or, parts of the pipeline that are a bottleneck for a particular type of 3D data base are further paralyzed. For example, in one embodiment, two CUL blocks are used, each working on different contiguous or non-contiguous regions of the screen. As another example, subsequent images can be run on parallel pipelines or portions thereof.","In one embodiment, multiple MEX units are provided so as to have one for each process on the host processor that was doing rendering or each graphics Context. This results on \u201czero overhead\u201d context switches possible.","Example of MEX Operation","In order to understand the details of what MEX needs to accomplish and how it is done, let us consider an example shown in FIG. B, FIG. B, and FIG. B. These figures show an example sequence of packets (FIG. B) for an entire frame of data, sent from GEO to MEX, numbered in time-order from 1 through 55, along with the corresponding entries in Sort Memory (FIG. B) and Polygon Memory (FIG. B). For simplicity, FIG. B does not show the tile pointer lists and mode pointer list that SRT also writes into Sort Memory. Also, in one preferred embodiment, vertex information V is written into Polygon Memory starting at the lowest address and moving sequentially to higher addresses (within a page of Polygon Memory); while state information S is written into Polygon Memory starting at the highest address and moving sequentially to lower addresses. Polygon Memory is full when these addresses are too low to write additional data.","Referring to the embodiment of FIG. B, the frame begins with a BeginFrame packet that is a demarcation at the beginning of frames, and supplies parameters that are constant for the entire frame, and can include: source and target window IDs, framebuffer pixel format, window offsets, target buffers, etc. Next, the frame generally includes packets that affect the MEX State Vector, are saved in MEX, and set their corresponding Dirty Flags; in the example shown in the figures, this is packets  through . Packet  is a Clear packet, which is generally supplied by an application program near the beginning of every frame. This Clear packet causes the CullMode data to be written to Sort Memory (starting at address 0x0000000) and PixMode data to be written to Polygon Memory (other MEX State Vector partitions have their Dirty Flags set, but Clear packets are not affected by other Dirty Bits). Packets  and  affect the MEX State Vector, but overwrite values that were already labeled as dirty. Therefore, any overwritten data from packets  and  is not used in the frame and is discarded. This is an example of how the invention tends to minimize the amount of data saved into memories.","Packet , a Color packet, contains the vertex information V (normals, texture coordinates, etc.), and is held in MEX until vertex information V is received by MEX. Depending on the implementation, the equivalent of packet  could alternatively be composed of a multiplicity of packets. Packet , a Sort packet, contains vertex information V for the first vertex in the frame, V. When MEX receives a Sort Packet, Dirty Flags are examined, and partitions of the MEX State Vector that are needed by the vertex in the Sort Packet are written to Polygon Memory, along with the vertex information V. In this example, at the moment packet  is received, the following partitions have their Dirty Flags set: MatFront, MatBack, TexAFront, TexABack, TexBFront, TexBBack, Light, and Stipple. But, because this vertex is part of a front-facing polygon (determined in GEO), only the following partitions get written to Polygon Memory: MatFront, TexAFront, TexBFront, Light, and Stipple (shown in FIG. B as occupying addresses 0xFFFFF00 to 0xFFFFFEF). The Dirty Flags for MatBack, TexABack, and TexBBack remain set, and the corresponding data is not yet written to Polygon Memory. Packets  through  are Color and Sort Packets, and these complete a triangle strip that has two triangles. For these Sort Packets (packets , , and ), the Dirty Flags are examined, but none of the relevant Dirty Flags are set, which means they do not cause writing of any state information S into Polygon Memory.","Packets  and  are MatFront and TexAFront packets. Their data is stored in MEX, and their corresponding Dirty Flags are set. Packet  is the Color packet for vertex V. When MEX receives packet , the MatFront and TexAFront Dirty Flags are set, causing data to be written into Polygon Memory at addresses 0xFFFFED0 through 0xFFFFEFF. Packets  through  describe Vand V, thereby completing the triangle V-V-V.",". . . Packet  is a color packet that completes the vertex information V for the triangle V-V-V, but that triangle is clipped by a clipping plane (e.g. the edge of the display screen). GEO generates the vertices Vand V, and these are sent in Sort packets  and . As far as SRT is concerned, triangle V-V-Vdoes not exist; that triangle is replaced with a triangle fan composed of V-V-Vand V-V-V. Similarly, packets  through  complete V-V-Vfor Polygon Memory and describe a triangle fan of V-V-Vand V-V-Vfor Sort Memory. Note that, for example, the Sort Memory entry for V(starting at address 0x00000B0) has a Sort Primitive Type of tri_fan, but the ColorOffset parameter in the Color Pointer is set to tri_strip.","Packets  through  set values within the MEX State Vector, and packets  through  describe a triangle fan. However, the triangles in this fan are backfacing (backface culling is assumed to be disabled), so the receipt of packet  triggers the writing into Polygon Memory of the MatBack, TexABack, and TexBBack partitions of the MEX State Vector because their Dirty Flags were set (values for these partitions were input earlier in the frame, but no geometry needed them). The Light partition also has its Dirty Flag set, so it is also written to Polygon Memory, and CullMode is written to Sort Memory.","The End Frame packet (packet ) designates the completion of the frame. Hence, SRT can mark this page of Sort Memory as complete, thereby handing it off to the read process in the SRT block. Note that the information in packets  and  was not written to Polygon Memory because no geometry needed this information (these packets pertain to front-facing geometry, and only back-facing geometry was input before the End Frame packet).","Memory Multi-Buffering and Overflow","In some rare cases, Polygon Memory can overflow. Polygon memory and\/or Sort Memory will overflow if a single user frame contains too much information. The overflow point depends on the size of Polygon Memory; the frequency of state information S changes in the frame; the way the state is encapsulated and represented; and the primitive features used (which determines the amount of vertex information V is needed per vertex). When memory fills up, all primitives are flushed down the pipe and the user frame finished with another fill of the Polygon Memory buffer (hereinafter called a \u201cframe break\u201d). Note that in an embodiment where SRT and MEX have dedicated memory, Sort Memory overflow triggers the same overflow mechanism. Polygon Memory and Sort Memory buffers must be kept consistent. Any skid in one memory due to overflow in the other must be backed out (or, better yet, avoided). Thus in MEX, a frame break due to overflow may result due to a signal from SRT that a Sort memory overflow occurred or due to memory overflow in MEX itself. A Sort Memory overflow signal in MEX is handled in the same way as an overflow in MEX Polygon Memory itself.","Note that the Polygon Memory overflow can be quite expensive. In one embodiment, the Polygon Memory, like Sort Memory, is double buffered. Thus MEX will be writing to one buffer, while MIJ is reading from the other. This situation causes a delay in processing of frames, since MEX needs to wait for MIJ to be done with the frame before it can move on to the next (third) frame. Note that MEX and SRT are reasonably well synchronized. However, CUL needs (in general) to have processed a tile's worth of data before MIJ can start reading the frame that MEX is done with. Thus, for each frame, there is a possible delay or stall. The situation can become much worse if there is memory overflow. In a typical overflow situation, the first frame is likely to have a lot of data and the second frame very little data. The elapsed time before MEX can start processing the next frame in the sequence is (time taken by MEX for the full frame+CUL tile latency+MIJ frame processing for the full frame) and not (time taken by MEX for the full frame+time taken by MEX for the overflow frame). Note that the elapsed time is nearly twice the time for a normal frame. In one embodiment, this cost is reduced by minimizing or avoiding overflow by having software get an estimate of the scene size, and break the frame in two or more roughly equally complex frames. In another embodiment, the hardware implements a policy where overflows occur when one or more memories are exhausted.","In an alternative embodiment, Polygon Memory and Sort Memory are each multi-buffered, meaning that there are more than two frames available. In this embodiment, MEX has available additional buffering and thus need not wait for MIJ to be done with its frame before MEX can move on to its next (third) frame.","In various alternative embodiments, with Polygon Memory and Sort Memory multi-buffered, the size of Polygon Memory and Sort Memory is allocated dynamically from a number of relatively small memory pages. This has advantages that, given memory size, containing a number of memory pages, it is easy to allocate memory to plurality of windows being processed in a multi-tasking mode (i.e., multiple processes running on a single host processor or on a set of processors), with the appropriate amount of memory being allocated to each of the tasks. For very simple scenes, for example, significantly less memory may be needed than for complex scenes being rendered in greater detail by another process in a multi-tasking mode.","MEX needs to store the triangle (and its state) that caused the overflow in the next pages of Sort Memory and Polygon Memory. Depending on where we are in the vertex list we may need to send vertices to the next buffer that have already been written to the current buffer. This can be done by reading back the vertices or by retaining a few vertices. Note that quadrilaterals require three previous vertices, lines will need only one previous vertex while points are not paired with other vertices at all. MIJ sends a signal to MEX when MIJ is done with a page of Polygon Memory. Since STP and CUL can start processing the primitives on a tile only after MEX and SRT are done, MIJ may stall waiting for the VSPs to start arriving.","MLM Pointer and Mode Packet Caching","Like the color packets, MIJ also keeps a cache of MLM pointers. Since the address of the MLM pointer in Polygon Memory uniquely identifies the MLM pointer, it is also used as the tag for the cache entries in the MLM pointer cache. The Color Pointer is decoded to obtain the address of the MLM pointer.","MIJ checks to see if the MLM pointer is in the cache. If a cache miss is detected, then the MLM pointer is retrieved from the Polygon Memory. If a hit is detected, then it is read from the cache. The MLM pointer is in turn decoded to obtain the addresses of the six state packets, namely, in this embodiment, light, material, textureA, textureB, pixel mode, and stipple. For each of these, MIJ determines the packets that need to be retrieved from the Polygon Memory. For each state address that has its valid bit set, MIJ examines the corresponding cache tags for the presence of the tag equal to the current address of that state packet. If a hit is detected, then the corresponding cache index is used, if not then the data is retrieved from the Polygon Memory and the cache tags updated. The data is dispatched to FRG or PXL block as appropriate, along with the cache index to be replaced.","Guardband Clipping","The example of MEX operation, described above, assumed the inclusion of the optional feature of clipping primitives for storing into Sort Memory and not clipping those same primitives's attributes for storage into Polygon Memory. FIG. B shows an alternate method that includes a Clipping Guardband surrounding the display screen. In this embodiment, one of the following clipping rules is applied: a) do not clip any primitive that is completely within the bounds of the Clipping Guardband; b) discard any primitive that is completely outside the display screen; and c) clip all other primitives. The clipping in the last rule can be done using either the display screen (the preferred choice) or the Clipping Guardband; FIG. B assumes the former. In this embodiment it may also be done in other units, such as the HostCPU. The decision on which rule to apply, as well as the clipping, is done in GEO.","Some Parameter Details","Given the texture id, its (s, t, r, q) coordinates, and the mipmap level, the TEX block is responsible for retrieving the texels, unpacking and filtering the texel data as needed. FRG block sends texture id, s, t, r, L.O.D., level, as well as the texture mode information to TEX. Note that s, t, and r (and possibly the mip level) coming from FRG are floating point values. For each texture, TEX outputs one texel value (e.g., RGB, RGBA, normal perturbation, intensity, etc.) to PHG. TEX does not combine the fragment and texture colors; that happens in the PHB'block. TEX needs the texture parameters and the texture coordinates. Texture parameters are obtained from the two texture parameter caches in the TEX block. FRG uses the texture width and height parameters in the L.O.D. computation. FRG may use the TextureDimension field (a parameter in the MEX State Vector) to determine the texture dimension and if it is enabled and TexCoordSet (a parameter in the MEX State Vector) to associate a coordinate set with it.","Similarly, for CullModes, MEX may strip away one of the LineWidth and PointWidth attributes, depending on the primitive type. If the vertex defines a point, then LineWidth is thrown away and if the vertex defines a line, then PointWidth is thrown away. Mex passes down only one of the line or point width to the SRT.","Processor Allocation in PHB Block","As tiles are processed, there are generally a multiplicity of different 3D object visible within any given tile. The PHB block data cache will therefore typically store state information and microcode corresponding to more than one object. But, the PHB is composed of a multiplicity of processing units, so state information from the data cache may be temporarily copied into the processing units as needed. Once state information for a fragment from a particular object is sent to a particular processor, it is desirable that all other fragments from that object also be directed to that processor. PHB keeps track of which object's state information has been cached in which processing unit within the block, and attempts to funnel all fragments belonging that same object to the same processor. Optionally, an exception to this occurs if there is a load imbalance between the processors or engines in the PHB unit, in which case the fragments are allocated to another processor. This object-tag-based resource allocation occurs relative to the fragment processors or fragment engines in the PHG.","Data Cache Management in Downstream Blocks","The MIJ block is responsible for making sure that the FRG, TEX, PHB, and PIX blocks have all the information they need for processing the pixel fragments in a VSP, before the VSP arrives at that stage. In other words, the vertex information V of the primitive (i.e., of all its vertices), as well as the six MEX State Vector partitions pointed to by the pointers in the MLM Pointer, need to be resident in their respective blocks, before the VSP fragments can be processed. If MIJ was to retrieve the MLM Pointer, the state packets, and ColorVertices for each of the VSPs, it will amount to nearly 1 KB of data per VSP. For 125M VSPs per second, this would require 125 GB\/sec of Polygon Memory bandwidth for reading the data, and as much for sending the data down the pipeline. It is not desirable to retrieve all the data for each VSP, some form of caching is desirable.","It is reasonable to think that there will be some coherence in VSPs and the primitives; i.e. we are likely to get a sequence of VSPs corresponding to the same primitive. We could use this coherence to reduce the amount of data read from Polygon Memory and transferred to Fragment and Pixel blocks. If the current VSP originates from the same primitive as the preceding VSP, we do not need to do any data retrieval. As pointed out earlier, the VSPs do not arrive at MIJ in primitive order. Instead, they are in the VSP scan order on the tile, i.e. the VSPs for different primitives crossing the scan-line may be interleaved. Because of this reason, the caching scheme based on the current and previous VSP alone will cut down the bandwidth by approximately 80% only.","In accordance with this invention, a method and structure is taught that takes advantage of primitive coherence on the entire region, such as a tile or quad-tile. (A 50 pixel triangle on average will touch 3 tiles, if the tile size is 16\u00d716. For a 32\u00d732 tile, the same triangle will touch 1.7 tiles. Therefore, considering primitive coherence on the region will significantly reduce the bandwidth requirement.) This is accomplished by keeping caches for MLM Pointers, each of state partitions, and the color primitives in MIJ. The size of each of the caches is chosen by their frequency of incidence on the tile. Note that while this scheme can solve the problem for retrieving the data from the Polygon Memory, we still need to deal with data transfer from MIJ to FRG and PXL blocks every time the data changes. We resolve this in the following way.","Decoupling of Cached Data and Tags","The data retrieved by MIJ is consumed by other blocks. Therefore, we store the cache data within those blocks. As depicted in FIG. B, each of the FRG, TEX, PHB, and PIX blocks have a set of caches, each having a size determined independently from the others based upon the expected number of different entries to avoid capacity misses within one tile (or, if the caches can be made larger, to avoid capacity misses within a set tiles, for example a set of four tiles). These caches hold the actual data that goes in their cache-line entries. Since MIJ is responsible for retrieving the relevant data for each of the units from Polygon Memory and sending it down to the units, it needs to know the current state of each of the caches in the four aforementioned units. This is accomplished by keeping the tags for each of the caches in MIJ and having MIJ to do all the cache management. Thus data resides in the block that needs it and the tags reside in MIJ for each of the caches. With MIJ aware of the state of each of the processing units, when MIJ receives a packet to be sent to one of those units, MIJ determines whether the processing unit has the necessary state to process the new packet. If not, MIJ first sends to that processing unit packets containing the necessary state information, followed by the packet to be processed. In this way, there is never a cache miss within any processing unit at the time it receives a data packet to be to be processed. A flow chart of this mode injection operation is shown in FIG. B.","MIJ manages multiple data caches\u2014one for FRG (ColorCache) and two each for the TEX (TexA, TexB), PHG (Light, Material, Shading), and PIX (PixMode and Stipple) blocks. For each of these caches the tags are cached in MIJ and the data is cached in the corresponding block. MIJ also maintains the index of the data entry along with the tag. In addition to these seven caches, MIJ also maintains two caches internally for efficiency, one is the Color dualoct cache and the other is the MLM Pointer cache; for these, both the tag and data reside in MIJ. In this embodiment, each of these nine tag caches are fully associative and use CAMs for cache tag lookup, allowing a lookup in a single clock cycle.","In one embodiment, these caches are listed in the table below.",{"@attributes":{"id":"p-0708","num":"0709"},"tables":{"@attributes":{"id":"TABLE-US-00015","num":"00015"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}},{"entry":[{},"Cache","Block","# entries"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"91pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Color dualoct","MIJ","32"]},{"entry":[{},"Mlm_ptr","MIJ","32"]},{"entry":[{},"ColorData","FRG","128"]},{"entry":[{},"TextureA","TEX","32"]},{"entry":[{},"TextureB","TEX","16"]},{"entry":[{},"Material","PHG","32"]},{"entry":[{},"Light","PHG","8"]},{"entry":[{},"PixelMode","PIX","16"]},{"entry":[{},"Stipple","PIX","4"]},{"entry":{"@attributes":{"namest":"1","nameend":"4","align":"center","rowsep":"1"}}}]}}]}}},"In one embodiment, cache replacement policy is based on the First In First Out (FIFO) logic for all caches in MIJ.","Color Caching in FRG","\u201cColor\u201d caching is used to cache color packet. Depending on the extent of the processing features enabled, a color packet may be 2, 4, 5, or 9 dualocts long in the Polygon Memory. Furthermore, a primitive may require one, two or three color vertices depending on if it is a point, a line, or a filled triangle, respectively. Unlike other caches, color caching needs to deal with the problem of variable data sizes in addition to the usual problems of cache lookup and replacement. The color cache holds data for the primitive and not individual vertices.","In one embodiment, the color cache in FRG block can hold 128 full performance color primitives. The TagRam in MIJ has a 1-to-1 correspondence with the Color data cache in the FRG block. A ColorAddress uniquely identifies a Color primitive. In one embodiment the 24 bit Color Address is used as the tag for the color cache.","The color caching is implemented as a two step process. On encountering a VSP, MIJ first checks to see if the color primitive is in the color cache. If a cache hit is detected, then the color cache index (CCIX) is the index of the corresponding cache entry. If a color cache miss is detected, then MIJ uses the color address and color type to determine the dualocts to be retrieved for the color primitives. We expect a substantial number of \u201ccolor\u201d primitives to be a part of the strip or fans. There is an opportunity to exploit the coherence in colorVertex retrieval patterns here. This is done via \u201cColor Dualoct\u201d caching. MIJ keeps a cache of 32 most recently retrieved dualocts from the color vertex data. For each dualoct, MIJ keeps a cache of 32 most recently retrieved dualocts from the color vertex data. For each dualoct, MIJ checks the color dualoct cache in the MIJ block to see if the data already exists. RDRAM fetch requests are generated for the missing dualocts. Each retrieved dualoct updates the dualoct cache.","Once all the data (dualocts) corresponding to the color primitive have been obtained, MIJ generates the color cache index (CCIX) using the FIFO or other load balancing algorithm. The color primitive data is packaged and sent to the Fragment block and the CCIX is incorporated in the VSP going out to the Fragment block.","MIJ sends three kinds of color cache fill packets to the FRG block. The Color Cache Fill  packets correspond to the primitives rendered at full performance and require one cache line in the color cache. The Color Cache Fill  packets correspond to the primitives rendered in half performance mode and fill two cache lines in the color cache. The third type of the color cache fill packets correspond to various other performance modes and occupy 4 cache lines in the fragment block color cache. Assigning four entries to all other performance modes makes cache maintenance a lot simpler than if we were to use three color cache entries for the one third rate primitives.","While the present invention has been described with reference to a few specific embodiments, the description is illustrative of the invention and is not to be construed as liming the invention. Various modifications may occur to those skilled in the art without departing from the true spirit and scope of the invention as defined by the appended claims.","The invention will now be described in detail by way of illustrations and examples for purposes of clarity and understanding. It will be readily apparent to those of ordinary skill in the art in light of the teachings of this invention that certain changes and modifications may be made thereto without departing from the spirit or scope of the appended claims. We first provide a top-level system architectural description. Section headings are provided for convenience and are not to be construed as limiting the disclosure, as all various aspects of the invention are described in the several sections that were specifically labeled as such in a heading.","Overview","The present invention sorts objects\/primitives in the middle of a graphics pipeline, after they have been transformed into a common coordinate system, that is, from object coordinates to eye coordinates and then to screen coordinates. This is beneficial because it eliminates the need for a software application executing on a host computer to sort primitives at the beginning of a graphics pipeline before they have been transformed. In this manner, the present invention does not increase the bandwidth requirements of graphics pipeline.","Additionally, the present invention spatially sorts image data before the end of the pipeline and sends only those image data that represent the visible portions of a window to subsequent processing stages of the graphics pipeline, while discarding those image data, or fictional image data that do not contribute to the visible portions of the window.","The present invention provides a computer structure and method for efficiently managing finite memory resources in a graphics pipeline, such that a previous stage of a graphics pipeline is given an indication that certain image data will not fit into a memory without overflowing the memory's storage capacity.","The present invention provides a structure and method for overcoming effects of scene complexity and horizon complexity in subsequent stages of a 3-D graphics pipeline, by sending image data to subsequent stages of the graphics pipeline in a manner that statistically balances the image data across the subsequent rendering resources.","Referring to FIG. C, there is shown one embodiment of a system  for spatially sorting image data in a graphics pipeline, illustrating how various software and hardware elements cooperate with each other. For purposes of the present invention, spatial sorting refers to sorting image data with respect to multiple regions of a 2-D window. System , utilizes a programmed general-purpose computer , and 3-D graphics processor . Computer  is generally conventional in design, comprising: (a) one or more data processing units (\u201cCCPUs\u201d) ; (b) memory , and , such as fast primary memory , cache memory , and slower secondary memory , for mass storage, or any combination of these three types of memory; (c) optional user interface , including display monitor , keyboard , and pointing device ; (d) graphics port , for example, an advanced graphics port (\u201cAGP\u201d), providing an interface to specialized graphics hardware; (e) 3-D graphics processor  coupled to graphics port  across I\/O bus , for providing high-performance 3-D graphics processing; and (e) one or more communication busses , for interconnecting CPU , memory , specialized graphics hardware , 3-D graphics processor , and optional user interface .","I\/O bus  can be any type of peripheral bus including but not limited to an advanced graphics port bus, a Peripheral Component Interconnect (PCI) bus, Industry Standard Architecture (ISA) bus, Extended Industry Standard Architecture (EISA) bus, Microchannel Architecture, SCSI Bus, and the like. In a preferred embodiment, I\/O bus  is an advanced graphics port pro.","The present invention also contemplates that one embodiment of computer  may have a command buffer (not shown) on the other side of graphics port , for queuing graphics hardware I\/O directed to graphics processor .","Memory typically includes operating system  and one or more application programs , or processes, each of which typically occupies a separate address space in memory  at runtime. Operating system  typically provides basic system services, including, for example, support for an Application Program Interface (\u201cAPI\u201d) for accessing 3-D graphics. API's such as Graphics Device Interface, DirectDraw\/Direct 3-D and OpenGLR. DirectDraw\/Direct 3-D, and OpenGLR are all well-known APIs, and for that reason are not discussed in greater detail herein. The application programs  may, for example, include user level programs for viewing and manipulating images.","It will be understood that a laptop dedicated game console, or other type of portable computer, can also be used in connection with the present invention, for sorting image data in a graphics pipeline. In addition, a workstation on a local area network connected to a server can be used instead of computer  for sorting image data in a graphics pipeline. Accordingly, it should be apparent that the details of computer  are not particularly relevant to the present invention. Personal computer  simply serves as a convenient interface for receiving and transmitting messages to 3-D graphics processor .","Referring to FIG. C, there is shown an exemplary embodiment of 3-D graphics processor , which may be provided as a separate PC Board within computer , as a processor integrated onto the motherboard of computer , or as a stand-alone processor, coupled to graphics port  across I\/O bus , or other communication link.","Spatial sorting stage , hereinafter, often referred to as \u201csort ,\u201d is implemented as one processing stage of multiple processing stages in graphics processor . Sort  is connected to other processing stages  across internal bus  and signal line . Sort  is connected to other processing stages  across internal bus  and signal line .","The image data and signals sent respectively across internal bus  and signal line  between sort  and a previous stage of graphics pipeline  are described in great detail below in reference to the interface between spatial sorting  and mode extraction . The image data and signals sent respectively across internal bus  and signal line  between sort  and a subsequent stage of graphics pipeline  are described in great detail below in reference to interface between spatial sorting  and setup .","Internal bus  and internal bus  can be any type of peripheral bus including but not limited to a Peripheral Component Interconnect (PCI) bus, Industry Standard Architecture (ISA) bus, Extended Industry Standard Architecture (EISA) bus, Microchannel Architecture, SCSI Bus, and the like.","Other Processing Stages ","In one embodiment of the present invention, other processing stages  (see FIG. C) can include, for example, any other graphics processing stages as long as a stage previous to sort  provides sort  with spatial data.","Referring to FIG. C, there is shown an example of a preferred embodiment of other processing stages , including, command fetch and decode , geometry , and mode extraction . We will now briefly discuss each of these other processing stages .","Cmd Fetch\/Decode , or \u201cCFD \u201d handles communications with host computer  through graphics port . CFD  sends 2-D screen based data, such as bitmap blit window operations, directly to backend  (see FIG. C, backend ), because 2-D data of this type does not typically need to be processed further with respect to the other processing stage in other processing stages  or other processing stages . All 3-D operation data (e.g., necessary transform matrices, material and light parameters and other mode settings) are sent by CFD  to the geometry .","Geometry  performs calculations that pertain to displaying frame geometric primitives, hereinafter, often referred to as \u201cprimitives,\u201d such as points, line segments, and triangles, in a 3-D model. These calculations include transformations, vertex lighting, clipping, and primitive assembly. Geometry  sends \u201cproperly oriented\u201d geometry primitives to mode extraction .","Mode extraction  (\u201cMEX\u201d) separates the input data stream from geometry  into two parts: (1) spatial data, such as frame geometry coordinates, and any other information needed for hidden surface removal; and, (2) non-spatial data, such as color, texture, and lighting information. Spatial data are sent to sort . The non-spatial data are stored into polygon memory (not shown). (Mode injection  (see FIG. C) later retrieves the non-spatial data and re-associates it with graphics pipeline ).","The details of processing stages  is not necessary to practice the present invention, and for that reason other processing stages  are not discussed in further detail here.","Spatial Sorting ","Sort 's I\/O subsystem architecture is designed around the need to spatially sort image data according to which of multiple, equally sized regions that define the limits of a 2-D window are touched by polygons identified by the image data. Sort  is additionally designed around a need to efficiently send the spatially sorted image data in a tile-by-tile manner across I\/O bus  to a next stage in graphics pipeline , or pipeline .","Top Level Architecture","Referring to FIG. C, there is shown an example of a preferred embodiment of sort , for illustrating an exemplary structure as well as data storage and data flow relationships. To accomplish the above discussed goals, sort  utilizes two basic control units, write control  and read control , that are designed to operate in parallel. The basic idea is that write control  spatially sorts image data received from a previous page of the graphics pipeline into sort memory , and subsequently notifies read control  to send the sorted spatial data from sort memory  to a next stage in the graphics pipeline. For a greater detailed description of write control  and read control , refer respectively to .","The present invention overcomes the shortcomings of the state of the art by providing structure and method to send only those image data that represent the visible portions of a window down stages of a graphics pipeline, while discarding those image data, or fictional image data that do not contribute to the visible portions of the window. This embodiment is described in greater detail below in reference to read control  and scissor windows.","In yet another preferred embodiment of the present invention, write control  performs a guaranteed conservative memory estimate to determine whether there is enough sort memory  left to sort image data from a previous process in graphics pipeline  into sort memory , or whether a potential sort memory  buffer overflow condition exists. The guaranteed conservative memory estimate is discussed in greater detail below in reference to .","In yet another preferred embodiment of the present invention, read control  sends the spatially sorted image data to a next to process (see FIG. C) in graphics pipeline  in a balanced manner, such that the rendering resources of subsequent status of graphics pipeline  are efficiently utilized, meaning that one stage of pipeline  is not overloaded with data while another stage of pipeline  is starved for data. Instead, this preferred embodiment, the odds are increased that data flow across multiple subsequent stages will be balanced. This process is discussed in greater detail below in reference to the tile hop sequence, an example of which is illustrated in FIG. C.","Interface between Spatial Sorting  and Mode Extraction ","We will now describe various packets sent to sort  from a previous stage of pipeline , for example, mode extraction . For each packet type, a table of all the parameters in the packet is shown. For each parameter, the number of bits is shown.","Referring to table 1, there is shown an example of spatial packet . The majority of the input to sort  from a previous stage of pipeline  are spatial packets that include, for example, a sequence of vertices that are grouped into sort primitives. Vertices describe points in 3-D space, and contain additional information for assembling primitives. Each spatial packet  causes one sort memory vertex packet to be written into data storage by write control  to an input buffer in sort memory  buffer, for example, buffer .","Spatial packet  includes, for example, the following elements: transparent , line flags , window X , window Y , window Z , primitive type , vertex reuse , and LinePointWidth . Each of these elements are discussed in greater detail below as they are utilized in by either write control  or read control .","LinePointWidth element  identifies the width of the geometry primitive if the primitive is a line or a point.","Primitive type  is used to determine if the vertex completes a triangle, a line, a point, or does not complete the primitive. Table 7 lists the allowed values  for each respective primitive type , each value's  corresponding implied primitive type , and the number of vertices  associated with each respective implied primitive type. Values  of three (\u201c3\u201d) are used to indicate a vertex that does not complete a primitive. An example of this is the first two vertices in a triangle; only the third vertex completes the triangle primitive. Values  other than three indicate that the vertex is a completing vertex. Primitive type  \u201c0\u201d is used for points. Primitive type  \u201c1\u201d is used for lines. And, Primitive type  \u201c2\u201d is used for triangles, even if they are to be rendered as lines, or line mode triangles.","Referring to Table 2, there is shown an example of a began frame packet . The beginning of a user frame of image data is designated by reception of such a begin frame packet  by sort . A user frame is all of the data necessary to draw one complete image, whereas an animation consist of many sequential images. Begin frame packets  are passed down pipeline  to sort  by a previous processing stage of pipeline , for example, mode extraction  (see FIG. C).","PixelsVert  and PixelsHoriz  are used by write control  to determine the size of the 2-D window, or user frame. In a preferred embodiment of the present invention, SuperTileSize , and SuperTileStep  elements are used by read control  to output the spatially sorted image data in an inventive manner, called a \u201cSuperTile Hop Sequence\u201d to a subsequent stage of graphics pipeline , for example setup . The SuperTile Hop Sequence is discussed in greater detail below in reference to FIG. C, and read control .","Sort transparent mode element  is used by read control , as discussed in greater detail below in reference to read control  and output modes used to determine an order that spatially sorted image data are output to a subsequent stage of pipeline , for example, setup ","Sort  does not store begin frame packet  into sort memory , but rather sort  saves the frame data into frame state buffer  (see FIG. C). Such frame data includes, for example, screen size (X, Y) Tile hop value (M) buffers enabled (front, back, left, and right), and transparency mode.","Referring to Table 3, there is shown an example of end frame packet , for designating either: (a) an end of a user frame of image data; (b) a forced end of user frame instantiated by an application program executing in, for example, memory of computer ; or, (c) for designating an end of a frame of image data caused by a need to split a frame of image data into multiple frames because of a memory overflow.","When a forced end of user frame is sent by an application program, end frame packet  will have the SoftEndFrame  element set to \u201c1.\u201d A forced end of user frame indication is simply a request instantiated by an application executing on, for example, computer  (see FIG. C), for the current image frame to end.","BufferOverflow Occurred  is used by write control  to indicate that this end of frame packet  is being received as a result of a memory buffer overflow event. For more information regarding sort memory  overflow, refer to write control , FIG. C, step .","Referring to table 4, there is shown an example of a clear packet  and a cull mode packet . Hereinafter, a clear packet  and\/or a cull mode packet  are often referred to in combination or separately as \u201cmode packets.\u201d Mode packets typically contain information that effects multiple vertices. Receipt of mode packets,  or , by sort  results in each respective mode packet being written into sort memory .","A graphics application, during the course or rendering a frame, can clear one or more buffers, including, for example, a color buffer, a depth buffer, and\/or a stencil buffer. Color buffers, depth buffers, and stencil buffers are known, and for this reason are not discussed in greater detail herein. An application typically only performs a buffer clear at the very beginning of a frame rendering process. That is, before any primitives are rendered. Such buffer clears are indicated by receipt by sort  of clear packets  (see Table 4). Clear packets  are not used by sort , but are accumulated into sort memory  in-time order, as they are received, and output during read control .","Sort  also receives cull packet  from a previous stage in pipeline , such as, for example, mode extraction  (see FIG. C). A scissor window is a rectangular portion of the 2-D window. SortScissorEnable , if set to \u201c1\u201d indicates that a scissor window is enabled with respect to the 2-D window. The scissor window coordinates are givent by the following elements in cull packet : SortScissorXmin , SortScissorXmax , SortScissorYmin  and SortScissorYmax . In one embodiment of the present invention, scissor windows are used both by write control  (see FIG. C, step ) and read control  (see FIG. C, step ).","Interface Signals","Referring to table 15, there are shown interface signals sent between sort  and mode extraction . The interface from sort  to mode extraction  is a simple handshake mechanism across internal data bus . Mode extraction  waits until sort  sends a ready to send signal, srtOD_ok2Send , indicating that sort  is ready to receive another input packet. After receiving the sort okay to send signal from sort , mode extraction  places a new packet onto internal input bus  and indicates via a data ready signal, mexOB_dataReady , that the data on is a valid packet.","In response to receiving the data ready signal, if the last packet sent by mode extraction  will not fit into sort memory , sort  sends mode extraction  a sort buffer overflow signal, srtOD_srtOverflow , over signal line  (see FIG. C) to indicate that the last input packet to sort  from mode extraction  could cause sort memory overflow. Receipt of a sort buffer overflow signal indicates to mode extraction  that it needs to swap sort memory  buffers. Swapping simply means only that \u201cwrites\u201d are to be directed only at the memory previously designated for \u201creads,\u201d and vice versa. The process of swapping sort memory  buffers is discussed in greater detail below with reference to write control , as illustrated in , step .","If the last data packet sent by mode extraction  will fit into sort memory , sort  sends two signals to mode extraction . The first signal, a will fit into memory signal, or srtOD_lastVertexOK , indicates that the last packet sent by mode extraction  will fit into sort memory . The second signal, the sort okay to send signal, indicates that sort  is ready to receive another packet from mode extraction .","It can be appreciated that the specific values selected to represent each of the above signals are not necessary to practice the present invention. It is only important that each signal has such a unique value with respect to another signal that each signal can be differentiated from each other signal by sort  and mode extraction .","Sort Memory Structure and Organization","Sort Memory  is comprised of a field upgradable block of memory, such as PC RAM. In one embodiment of the present invention, sort memory is single buffered, and write control  spatially sorts image data into the single buffer until either sort memory  overflows, sort  receives an indication from an application executing on, for example, computer  (see ) to stop writing data into memory, or write control  receives an end of frame packet  from a previous processing stage in pipeline  (see Table 3). Memory overflow occurs when either sort memory  or another memory (not shown), such as, for example, polygon memory (not shown) fills up.","In such a situation, write control  will signal read control  across signal line  indicating that read control  can begin to read the spatially sorted image data from sort memory , and send the spatially sorted image data across I\/O bus  to a next stage in graphics pipeline .","In a preferred embodiment of the present invention, sort memory  is double buffered, including a first buffer, buffer , and a second buffer, buffer , to provide simultaneous write access to write control , and read access to read control . In this preferred embodiment, write control  and read control  communicate across signal line , and utilize information stored in various queues in sort memory , frame state  and tail memory , to allow their respective execution units to operate asynchronously, in parallel, and independently.","Either of the two buffers,  or , may at times operate as the input or output buffer. Each buffer  and  occupies a separate address space in sort memory . The particular buffer (one of either of the two buffers) that, at any one time, is being written into by write control , is considered to be the input buffer. The particular buffer (the other one of two buffers) where data is being read out of it by read control , is considered to be the output buffer.","To illustrate this preferred embodiment, consider the following example, where write control  spatially sorts image data into one of the two buffers in sort memory , for example, buffer . When buffer  fills, or in response to write control  receiving of end frame packet  (see Table 3) from a previous stage of graphics pipeline , write control  will swap sort memory  buffer  with sort memory  buffer , such that read control  can begin reading spatially sorted image data out of sort memory  buffer  to a next stage of graphics pipeline , while, in parallel, write control  continues to spatially sort unsorted image data received from a previous processing stage in graphics pipeline , into empty sort memory  buffer .","Sort  receives image data corresponding to triangles after they have been transformed, culled and clipped from a previous date in pipeline . For greater detailed description of the transformed, culled and clipped image data that sort  receives, refer above to \u201cother processing stages .\u201d","To spatially sort image data, sort  organizes the image data into a predetermined memory architecture. Image data, includes, for example, polygon coordinates (vertices), mode information (see Table 4, clear packet  and cull packet ), etc. . . . In a preferred embodiment of the present invention, the memory architecture includes, for example, the following data structures mirrored across each memory buffer, for example, buffer  and buffer : (a) a data storage, for example, data storage ; (b) a set of tile pointer lists, for example, title pointers lists ; and, (c) a mode pointer list, for example, mode pointer list .","For each frame of image data that sort  receives from a previous stage of pipeline , sort  stores three types of packets in the order that the packets are received (hereinafter, this order is referred to as \u201cin-time order\u201d) into data storage , including: (1) sort memory vertex packets  (see Table 8), which contain only per-vertex information; (2) sort memory clear packets  (see Table 4), which causes buffer clears; and (3) sort memory cull packets  (see Table 4), which contain scissor window draw buffer selections).","These three packet types fall into two categories: (1) vertex packets, including vertex packet type  packets, for describing points in 3-D space; and, (2) mode packets, including sort memory clear buffer  packets and sort memory cull packets . We will now discuss how these three packet types and other related information are stored by sort  into sort memory .","Referring to Table 5, there are shown examples of sort  pointers, including vertex pointer , clear mode packet pointer , cull mode packet pointer , and link address packet .","Vertex pointers  point to vertex packets , and are stored by sort  into respective tile pointer lists (see, for example, FIG. C, tile pointer list ), in-time order, as vertex packets  are received and stored into data storage (see, for example, FIG. C, data storage ). Packet address pointer  points to the address in data storage of the last vertex packet  of a primitive that covers part of a corresponding tile.","As discussed above, the last vertex completes the primitive (hereinafter, such a vertex is referred to as a \u201ccompleting vertex\u201d). Packet address pointer  in combination with offset  are used by write control  and read control  in certain situations to determine any other coordinates (vertices) for the primitive (such situations are described in greater detail below in reference to write control  and read control ). We will now describe a procedure to determine the coordinates of a primitive from its corresponding vertex pointer .","Offset  is used to identify each of the particular primitives other vertices, if any. If offset  is \u201c0,\u201d the primitive isa point. If offset  is \u201c1\u201d, the primitive is a line, and the other vertex of the line is always the vertex at the immediately preceding address of packet address pointer . If offset  is 2 or more, then the primitive is a triangle, the corresponding vertex packet  (pointed to by packet address pointer ) contains the coordinates for the triangle's completing vertex, the second vertex is always the immediately prior address to packet address pointer , and the first vertex is determined by subtracting the offset from the address of packet address pointer .","Transparent flag  corresponds to the value of transparent element  contained in spatial packet .","Clear mode packet pointer  points to clear mode packet's stored by a sort  in time order, as they are received, into data storage . Clear mode packet pointers  are stored by sort  in-time order, as they are received, into mode pointer list .","For each mode packet received by sort , a mode pointer (see Table 5000, depending on the type of mode packet, either a clear mode packet pointer  or a cull mode packet pointer ) is added to a mode pointer list (see FIG. C). These pointers, either  or , also contain an address, either  or , where the mode packet is stored, plus bits, either  or , to tell read control  the particular mode packets type (clear  or cull ), and an indication, either  or , of whether the mode packet could cause a sub-frame break in sorted transparency mode (described greater detail below with respect to read control ).","Write control  stores pointers to the polygon information stored in data storage  into a set of tile pointer lists  according to the tiles, that are intersected by a respective polygon, for example, a triangle, line segment, or point. (A triangle is formed by the vertex that is the target of the pointer along with the two previous vertices in data storage .) This is accomplished by building a linked list of pointers per tile, wherein each pointer in a respective tile pointer list , corresponds to the last vertex packet for a primitive that covers part of the corresponding tile.","To illustrate storage of image data into memory, refer to FIG. C, and in particular into a tile pointer list , consider the following example. If a triangle touches four tiles, for example, tile  , tile  tile  , and tile N , a vertex pointer  to the third vertex, or the last vertex of the triangle is added to each tile pointer list  corresponding to each of those four touched tiles. In other words, a vertex pointer  referencing the last vertex of the triangle is added to each of the following tile pointer lists : (a) tile  tile pointer list ; tile  tile pointer list ; tile  tile pointer list ; and, (d) tile three tile pointless to ; and, (e) tile N tile pointer list .","Line segments are similarly sorted into a tile pointer list, for example tile pointer list , according to the tiles that the line segment intersects. It can be appreciated that lines, line mode trianges, and points have an associated width. To illustrate this, consider that a point, if situated at the intersection of 4 tiles, could touch all four tiles.","As a further illustration, refer to FIG. C, where there is shown spatial data and mode data organized into a sort memory  buffer, for example buffer  (see, FIG. C), with respect to eight geometry primitives , , , , , , , and , each of which is shown in FIG. C. In this example, one tile pointer list , , , ,  or , is constructed for each respective tile A, B, C, D, E, and F, in a 2-D window as illustrated in . For the purposes of this example, each data storage  entry - includes an address, for example, address  and a type of data indication, for example, type of data indication . The first image data packet, a mode packet (either a clear packet  or a cull packet ) received by write control  is stored at address  .","Each vertex pointer - references vertex packets -, -, and - (see Table 8, vertex packet ) that contain a completing vertex to a corresponding primitive that covers part of the tile represented by a respective tile pointer list -.","In a preferred embodiment of the present invention only vertex pointers X to vertex packets  that contain a completing vertex are stored by write control  into a tile pointer lists.","With further reference to FIG. C, line segment , including vertices  and , touches tiles A and C, and is completed by vertex . As a matter of convention, for complex polygons, those having more than one vertex, the last vertex in the pipeline is considered to be the completing vertex. However, the present invention also contemplates that another ordering is possible, for example, where the first vertex in the pipeline is the completing vertex.","Write control  writes first pointer  and first pointer  (see FIG. C), each referencing the packet  (containing completing vertex ), into corresponding tile pointer lists  and , that represent tiles A and C respectively.","Triangle , identified by vertices , , and , touches tiles B and D, and is completed by vertex  write control  writes first pointers  and  (see FIG. C), referencing packet  (containing completing vertex ), into the corresponding tile pointer lists  and , that represent tiles B and D respectively.","Triangle , identified by vertices , , and , touches tiles B and D, and is completed by vertex .write control  writes first pointers  and , referencing packet  (containing completing vertex ), into the corresponding Tile Pointer Lists  and , that represent tiles B and D respectively.","Triangle , identfied by vertices , , and , touches tiles D and F, and is completed by vertex .write control  writes first pointers  and , referencing packet  (containing completing vertex ), into the corresponding Tile Pointer Lists  and , that represent tiles D and F respectively.","Triangle , identified by vertices ,  and , touches tiles C and E, and is completed by vertex . Write control  writes first pointers  and , referencing packet  (containing completing vertex ), into the corresponding Tile Pointer Lists  and , that represent tiles C and E respectively.","Each of the remaining geometry primitives in 2-D window , including triangles  and , as well as point , are sorted according to the same algorithm discussed in detail above with respect to the sorted line segment , and triangles , ,  and .","In one embodiment of the present invention, as Mode Packets  and\/or , for example, packets , ,  and , are received by write control  they are stored in-time order into an input buffer in data storage. For each mode packet  and\/or  that is received, a corresponding mode pointer (depending on the type of mode packet, clear mode packet pointer  or cull mode packet pointer ), for example pointers , ,  and , is written into a mode pointer list .","In yet another embodiment of the present invention, if a geometry primitive is a line mode triangle, it is sorted according to the tiles its edges touch, and a line mode triangle having multiple edges in the same tile only causes one entry per tile.","Frame State","As frames of image data are written into sort memory  by write control , and subsequently read out of sort memory  by read control , to keep track of the various frame state information, frame state information is kept stored at numerous different levels in frame state register . Such information includes, for example, a number of regions that horizontally and the vertically divide the 2-D display window, and whether the data in the frame buffer is in \u201ctime order mode\u201d or \u201csorted transparency mode\u201d (both of these modes are discussed in detail below in reference to read control , and FIG. C).","In one embodiment of the present invention frame state register buffer  comprises a single set of registers . However, in a preferred embodiment of the present invention frame state register  comprises two sets of registers, including, one set of input registers, either  or , and one set of output registers, either  or . Either of the two sets of state registers,  or , may at times operate as the input or output register. The particular register (one of either of the two registers) that, at any one time, is being written into by write control , is considered to be the input register. The particular register (the other one of two registers) where data is being read out of it by read control , is considered to be the output register.","When sort memory  buffer  is swapped with buffer , frame state register buffer  is also copied into with frame state  register.","We will now discuss the particular information stored by write control into the various registers that are used to store frame state information in frame state registers .","Input buffer frame state register, either one of  or , depending on which is the input register at the time, is loaded with the frame state from the begin frame packet . Signals are used by write control  to determine and set the operating mode of the write pipeline. Such operating modes include, for example, in-time order operating mode and sorted transparency operating mode, both of which are described in greater detail below in reference to write control .","Input buffer frame state  register EndFrame register (not shown) is loaded from end of frame packet . Data that is included in EndFrame register includes, for example, soft overflow indication.","Input buffer frame state  register FrameHasClears register (not shown) is set by write control  for use by read control . Write control  sets this register in response to receiving a clear packet  for the application. As will be described below in greater detail in reference to read control , and FIG. C, read control  will immediately discard tiles that do not have any geometry in frames having no clears (e.g. clear packets  associated with the geometry).","MaxMem register (not shown) is loaded by write control  during initialization of sort , and is used for pointer initialization at the beginning of the frame. For example, it is typically initialized to the size of sort memory buffer .","Tail Memory ","In a preferred embodiment of the present invention, certain data structures in sort memory  are implemented as linked list data structures, for example, tile pointer lists (for example, referring to FIG. C, tile  tile pointer list , tile  tile pointer list , tile  tile pointer list , and tile N tile pointer list ) and mode pointer lists (for example, mode pointer list ). Linked list data structures, and the operation of linked list data structures (adding and deleting elements from a linked list data structure) are known, for this reason the details of linked list data structures are not described further herein.","Typically, adding elements to a linked list data structure, results in a read\/modify write operation. For example, if adding an element to the end of a linked list, the last element's next pointer in the linked list must be read, and then modified to equal the address of a newly added element. Performing a single read\/modify write takes processor  (see FIG. C) bandwidth. Performing enough read\/modify writes in a row can take away a significant amount of processor  bandwidth. While sorting primitives into sorts memory , write control  is adding elements to link lists, for example, tile pointer lists, and mode pointer lists (see FIG. C). It is desirable to minimize the number of read\/modify write operations so that processor bandwidth can be used for other graphic pipeline  operations, such as, for example, setup  and cull  (see FIG. C). What is needed is a structure and method for reducing the number of read\/modify rights and thereby increase processor bandwidth.","A preferred embodiment of the present invention reduces the number of read\/modify writes that write control  must perform to add elements to a linked list data structure. Referring to FIG. C, there is shown tail memory , used by write control  and read control  to reduces the number of read\/modify writes. Referring to Table 6, there is shown in example of an entry  in tail memory , including: (a) addr head , for pointing to be beginning of a link list data structure; (b) addr tail , for pointing to the end of the linked list data structure; and, (c) no. entries , for indicating the number of entries in the linked list data structure.","In a preferred embodiment of the present invention, each linked list data structure in sort memory  has an associated entry  in tail memory . This preferred embodiment will allocate two memory locations each time that it allocates memory to add an element to a linked list data structure. At this time, the \u201cnext element\u201d pointer (not shown) in the current last element in the link list data structure is updated to equal the address of the first allocated element's memory location. Next, the first allocated element's \u201cnext element\u201d pointer (not shown) is updated to equal the second allocated element's memory location. In this manner, the number of read\/modify writes that write control  must perform to add an element to a link data list is reduced to \u201cwrites\u201d.","When write control  has completed spatially sorting image data into sort memory , read control  will use tail memory  to identify those tiles that do not have any of a frame's geometry sorted into them. This procedure is described in greater detail below in reference to read control  and FIG. C.","In one embodiment of sort , tail memory  comprises one buffer, for example, buffer . In a preferred embodiment of the present invention, tail memory  includes one input buffer  and one output buffer  (inpuvoutput is hereinafter referred to as \u201ci\/o\u201d). Either of the two buffers,  or , may at times operate as the input or output buffer. Each buffer,  or , occupies a separate address space in tail memory  The particular buffer (one of either of the two buffers) that, at any one time, is being written into by write control , is considered to be the input buffer. The particular buffer (the other one of two buffers) where data is being read out of it by read control , is considered to be the output buffer. When write control  swaps sorted memory , buffer  is also swapped with buffer . Swapping sort memory  is discussed in greater detail below with respect to write control , step , FIG. C.","In yet another preferred embodiment of the present invention, after read control  finishes reading all of the geometry corresponding to a tile for the last time, ADDR HEAD  is set to equal the start address of its respective linked list and ADDR TAIL  is set to equal ADDR HEAD  (see table 6).","Write Control ","In one embodiment of the present invention, write control  performs a number of tasks, including, for example: (a) fetching image data from a previous stage of graphics pipeline , for example, mode extraction ; (b) sorting image data with respect to regions in a 2-D-Window; (c) storing the spatial relationships and other information facilitating the spatial sort into sort memory .","In a preferred embodiment of the present invention, write control, in addition to performing the above tasks, provides a previous stage of graphics pipeline , for example, mode extraction , a guaranteed conservative memory estimate of whether enough memory in a sort memory  buffer is left to spatially sort the image data into sort memory . In this preferred embodiment, write control  also cooperates with the previous stage of pipeline  to manage new frames of image data and memory overflows as well, by sequencing sort memory  buffer swaps with read control . We will now discuss each of these various embodiments in detail.","To illustrate write control , please refer to the exemplary structure in FIG. C and the exemplary embodiment of the inventive procedure of write control  in FIG. C. At step , sort  initializes tail memory  to contain an entry  (see Table 6) for each linked list data structure in sort memory , such that Addr head  equals Addr tail  which equals the address of the beginning of each respective linked list data structure, and number of entries  is set to equal zero.","Write control  procedure continues at step , where it fetches image data from a previous stage and pipeline , for example, mode extraction . Image data includes those packets that respectively designate either the beginning of a user frame, or the end of a \u201cuser frame\u201d (including, begin frame packet  (see Table 2) and end frame packet t  (see Table 3), hereinafter, often collectively referred to as a \u201cframe control packets\u201d), mode packets (including clear packets  and cull packets  (see Table 4)), and spatial packets  (see Table 6).","At step , write control  procedure determines whether a begin frame packet  was received (step ).","If write control  received a begin frame packet  (step ), it means that a new frame of image data packets are going to follow. In light of this, frame state parameters are stored into input I\/O buffer, for example, buffer  or buffer , in frame state  (see FIG. C). Such frame parameters are discussed in greater detail above.","Write control procedure  continues at step , where it is determined whether or not read control  is busy sending previously spatially sorted image data to a next stage in graphics pipeline . Write control  and read control  accomplish this by sending simple handshake signals over signal line  (see FIG. C). If read control  is busy, then write control procedure  will continue waiting until read control  has completed.","At step , if read control  is idle, write control procedure  swaps the following: (a) buffers  and  in sort memory ; (c) frames state registers  and ; and, (c) buffers  and  in tail memory . After execution of step , read control  can begin reading the spatially sorted image data out of, what was the input buffer, but is now the output buffer, while in parallel, and write control  can begin to spatially sort new image data into, what was the output buffer, but is now the input buffer. (In one embodiment of the present invention, read control  will zero-out the contents of the buffer that it has finished using.)","In a preferred embodiment of the present invention, memory is swapped by exchanging pointer addresses respectively to read and write memory buffers. For example, in one embodimant, write control  sets a first pointer that references a read memory buffer (for example, buffer  (see FIG. C)) to equal a start address of a first memory buffer that write control  was last sorting image data into (for example, buffer  (see FIG. C)); and, (b) write control  sets a second pointer that references a write memory buffer (in this example, buffer ) to equal a start address of a second memory buffer that read control  was last reading sorted image data from to a subsequent stage of pipeline  (in this example, buffer ).","Step , write control process  retrieves another packet of image data from a previous processing stage in pipeline , for example, mode extraction . (As discussed above with respect to step , if the previously fetched image packet was not a begin frame packet  (step ), write control procedure  also continues here, at step ).","At step , it is determined whether the packet is an end of frame packet  (see Table 3), for designating and end of frame of image data. This end of frame packet  may have been sent as the result of a natural end of frame of image data (SoftEndFrame ), a forced end of frame, or as a result of a memory buffer overflow (BufferOverflowOccurred ), known as a split frame of image data.","In line with this, if the end of image frame was not a soft end of frame or user end of frame, write control  procedure continues at step , it is determined whether the packet is an end of user frame. An end of user frame means that the application has finished an image. An end of user frame is different from a \u201coverflow\u201d end of frame (or soft end of frame), because in an overflow frame the next frame will need to \u2018composite\u2019 with this frame (this is accomploshed in a subsequent stage of pipeline ). In light of this, write control  procedure continues at step  where another image packet is fetched from a previous stage of pipeline , because there is more spatial data in this user frame.","At step , it is determined if read control  is busy sending image data that was already spatially sorted by write control  to a next stage in graphics pipeline . If read control  is busy, then write control  procedure will continue waiting until read control  has completed.","At step , if read control  is idle (not sending spatially sorted image data from an output sort memory  buffer to a subsequent stage and pipeline ), write control  procedure swaps input memory buffers with output memory buffers, and input data registers with output the registers, including, for example, the following: (a) buffers  and  in sort memory ; (c) frames state registers  and ; and, (c) buffers  and  in tail memory .","After execution of step , read control  can: (a) begin reading the spatially sorted image data out of, what was the input buffer, but is now the output buffer; (b) determine the output frame of image data's state from what was the input set of frame state registers, but is now the output set of frame state registers; and, (c) manage the output memory buffers linked list data structures from what was the input tail memory buffer, but is now the output tail memory buffer. While, in parallel, and write control  continues at step , where it can begin to spatially sort new image data into, what was the output sort memory  buffer, but is now the input buffer.","At step  (the image packet received from the previous stage of pipeline  was not an end of frame packet , see step ), write control  uses a guaranteed conservative memory estimate procedure to approximate whether there is enough sort memory  to store the image data packet received from the previous stage of the pipeline, along with any other necessary information (step ), for example, vertex pointers , or mode pointers  or . Guaranteed conservative memory estimate procedure  is described in greater detail below in reference to FIG. CII. Using this procedure , write control  avoids any problems that may have been caused by backing up pipeline  due to sort memory  overflows, such as, for example, loss of data.","If there's not enough memory (step ) for write control  to spatially sort the image data, at step , write control  signals the previous stage of pipeline  over signal line  (see FIG. C or FIG. C) to temporarily stop sending image data to write control  due to a buffer overflow condition. An example of a buffer overflow signal (srtOD_srtOverflow ) used by write control  is described in greater detail above in table 15 and in reference to section interface signals and the interface between sort  and mode extraction .","The previous stage of pipeline  may respond to the buffer overflow indication (step ) with an end frame packet  (see FIG. C) that denotes that the current user frame is being split into multiple frames. In one embodiment of present invention, this is accomplished by setting BufferOverflowed  to \u201c1\u201d","Sort  responds to this indication by: swapping sort memory  I\/O buffers, for example, buffer  and buffer  (see FIG. C); (b) frame state registers, for example, frame state registers  and frame state registers ; and, (c) tail memory buffers, for example, tail memory buffer  and tail memory buffer .","In yet another embodiment of the present invention, where sort  is single buffered, it is the responsibility of a software application executing on, for example, computer  (see ) to cause an end-of-frame to occur in the input data stream, preferably before sort memory  fills (step ). In such a situation, write control  depends on receiving a hint from the software application, the hint indicating that sort  should empty its input buffer.","If there is enough memory to spatially sort the image data (step ), write control performs the following steps to store the image data as illustrated at step , in FIG. C. Referring to FIG. C, at step  it determined whether the packet is a spatial packet  (see Table 8), and if it is not, at step , the packet must be a mode packet (either clear packet  or cull packet , see Table 4), the mode packet is stored into data storage input buffer, for example, data storage . At step , a pointer referencing the location of the mode packet in data storage is stored into mode pointer list input buffer, for example, mode pointer list .","If the packet was a spatial packet (step ), at step , a vertex packet  (see Table 8) is generated from the information in spatial packet  (see Table 1). The value of each element in vertex packet  correlates with the value of a similar element in spatial packet . At step , the vertex packet  is stored into a data storage input buffer, for example, data storage .","At step , it is determined whether the spatial packet  (step ) contains a completing vertex (the last vertex in the primitive). If the spatial packet  contains a completing vertex (step ), at step , to minimize bandwidth, write control  does a tight, but always conservative, computation of which tiles of the 2-D window are touched by the primitive by calculating the dimensions of a bounding box that circumscribes the primitive. The benefits of step  in this preferred embodiment, become evident in the next step, step . Bounding boxes are described below in greater detail in reference to FIG. C.","At step , write control  performs touched tile calculations to identify those tiles identified by the bounding box (step ) that are actually intersected by the primitive. Utilizing a bounding box to limit the number of tiles used in the touched tile calculations is beneficial as compared to the existing art, where touched tile calculations are performed for each tile in the 2-D window.","Not taking into consideration the notion of using a trivial reject and\/or a trivial accept of tiles prior to the use of the touched tile calculations (use of a bounding box) (step ), the notion of touched tile calculations per se are known in the art, and one particular set of touched tile calculations are included in Appendix A for purposes of completeness, and out of an abundance of caution to provide an enabling disclosure. These conventional touched tile procedures may be used in conjunction with the inventive structure and method of the present invention.","At step , for each tile that was intersected by the primitive (step ), a vertex pointer  (see Table 5) pointing to the vertex packet  stored into data storage (step ) is stored into each input buffer tile pointer list that corresponds to each tile that was intersected by the primitive (determined in step ), for example, tile pointer list buffer , and tile  tile pointer list , and tile  tile pointer list . A greater detailed description of the procedures used to store packets and any associated pointers into sort memory  is given above in reference to section sort memory structure and organization, and FIG. C.","Bounding Box Calculation","The present invention utilizes bounding boxes to provide faster tile computation processing (see step , FIG. C) and to further provide memory use estimates to a previous processing stage of pipeline  (memory use it estimates are discussed in greater detail below in reference to guaranteed conservative memory estimate procedure.). We will now describe a procedure to build a bounding box that circumscribes a primitive, wherein the bounding box comprises at least one tile of a 2-D window divided into equally sized tiles.","To illustrate the idea of a bounding box, please refer to FIG. C, where there is shown a 2-D window  with a bounding box  circumscribing a triangle . In this example, the 2-D window  is divided horizontally and vertically into six tiles , , , , , and . The bounding box  has dimensions including (Xmin, Ymin) , and (Xmax, Ymax) , that are used by write control  to determine a group of tiles in 2-D window  that may be touched by the triangle .","In this example, bounding box  includes, or \u201ctouches\u201d four tiles , , , and  of the six tiles , , , ,  and , because the triangle  lies on, or within each of the tiles , , , and . Bounding box  provides a conservative estimate of the tiles that primitive  intersects, because, as is shown in this example, the dimensions of bounding box  includes a tile (in this example, tile ) that is not \u201ctouched\u201d by geometry primitive , even though tile  is part of bounding box .","Referring to Table 5, and in particular to vertex pointer , we will now determine the coordinates of a primitive from its corresponding vertex pointer , and second, determining dimensions of bounding box  from the coordinates of the primitive. A procedure for determining the coordinates of a primitive from its corresponding vertex pointer  is described in greater detail above with respect to vertex pointer , and Table 5.","Having determined the coordinates (vertices) of the primitive, the magnitude of the vertices are used to define the dimensions of a bounding box circumscribing the primitive. To accomplish this, write control  compares the magnitudes of the primitive's vertices to identify bounding box's  (Xmin and Ymin)  and (Xmax and Ymax) .","The use of a bounding box is beneficial for several reasons, including, for example, it over estimates the memory requirements, but it takes less computation then it would to calculate which tiles a primitive actually intersects.","Lines, line mode triangles, and points have a width that may cause a primitive to touch adjacent tiles and thus have an affect on bounding box calculations. For example, a single point can touch as many as four tiles. In a preferred embodiment of the present invention, before determining dimensions of bounding box , one-half of the primitive's stated line width, as given by LinePointWidth  (see Table 1), is added to the primitive's dimensions to more clearly approximate the tiles that the primitive may touch.","Guaranteed Conservative Memory Estimate","Guaranteed is used because we know an upper bound on the number of tiles, and we know how much memory a primitive requires for storing respective pointers and vertex data. Hereinafter, guaranteed conservative estimate procedure  is referred to as \u201cGCE .\u201d","GCE  is desirable because sort memory  is allocated by write control  as image data is received from a previous stage of pipeline , for example, mode extraction stage . Because sort memory  is an arbitrary but fixed size, it is conceivable that sort memory  could overflow while storing image data.","Referring to FIG. C, there is shown a block diagram of an exemplary memory estimate data structure (\u201cMEDS\u201d) , that in one embodiment of the present invention, provides data elements that GCE  uses in its estimating procedure. MEDS can be stored in sort memory , or other memory (not shown). Packet pointer element  references a first insertion point into a memory, the memory in this example is sort memory , to store a first incoming data element, in this example the incoming data element is either a vertex packet  or a mode packet  or  from mode extraction . Pointer pointer element  keeps track of a second insertion point into the memory to store any other incoming data elements, in this example, the other incoming data elements are vertex pointers , or mode pointers  that may be associated with the vertex packet  or mode packet  or .","Maximum per tile estimate element  represents a value that corresponds to a \u201cworst case,\u201d or maximum number of memory locations necessary to store the largest primitive that could occupy the 2-D window. This largest primitive would touch every tile in the 2-D window. Memory left element  represents the actual amount of sort memory  that remains for use by write control .","In yet another embodiment of the present invention, write control  uses memory estimate data structure  to provide the information to respond to inquiries from a software application procedure, such as a 3-D graphics processing application procedure, concerning current memory status information, such as pointer write addresses.","Referring to FIG. C, there is shown an embodiment of GCE . At step , the actual amount of sort memory  that remains for use by write control  is calculated. We will now describe how this is accomplished. In one embodiment of the present invention, any pointers that may be associated with image data, such as vertex pointers , are inserted into sort memory  at a first insertion point, or first address, that grows from the bottom up as new pointers are added to sort memory . Also, in this embodiment, packets associated with the image data, such as mode packets  or , and\/or vertex packets , are inserted into sort memory  at a second insertion point, or second address, that decreases from the top down as packets are added to sort memory , or vice versa.","The difference between the magnitudes of the first address and the second address identifies how much sort memory  remains. Hereinafter, the result of this calculation is referred to as memory left .","In this example, at step , GCE  determines if the input data packet is a mode packet  or , and if so, at step , GCE  identifies the amount of sort memory  that is necessary to store a mode packet  or  into an input buffer of data storage (see FIG. C), and an associated mode pointer (depending on the type of mode packet, either a clear mode packet pointer  or a cull mode packet pointer ), into an input buffer mode pointer list, this amount is referred to as \u201cmemory needed.\u201d In one embodiment, memory needed is equivalent to the number of bytes of the packet, in this example, the packet is either a clear mode packet  or a cull mode packet , plus to number of bytes required to store and associated pointer, in this example a mode pointer (see Table 5, depending on the type of mode packet, either a clear mode packet pointer  or a cull mode packet pointer ), into sort memory . (Sizes of packets and pointers are given in their respective tables. See Table 8 for vertex packets, Table 4 for mode packets, and Table 5 for each pointer type.)","Referring back to FIG. C, at step , GCE  compares memory needed to Memory Left , and if memory needed is greater than memory left , at step , GCE  returns a not enough memory indication, for example, a boolean value of \u201cfalse,\u201d so that the write control  can, for example, send a buffer overflow indication (see interface signals above) to a previous stage of the graphics pipeline, such as mode extraction . Otherwise, at step , GCE  sets an enough memory indication for the write control , for example, returning a boolean value of \u201ctrue\u201d.","If the image data was not a mode packet  or  (step ), then GCE  continues at step , as illustrated in FIG. C. Referring to FIG. C, at step , GCE  determines if the image data is a spatial packet  that contains a completing vertex. To illustrate a Spatial Packet, please refer to Table 1, where there is shown an example of a Spatial Packet .","If spatial packet  contains a completing vertex (step ), at step , GCE  determines the value of the maximum memory locations  as discussed in greater detail above. At step , if it is determined that memory left  is greater than, or equal to maximum memory locations , then the GCE  continues at F, as illustrated in FIG. C, where at step , GCE  sets an indication that there is for certain enough memory for the write control  to store the image data and any associated pointers into sort memory .","Otherwise, at step  (FIG. C), GCE  performs an approximation of the amount of sort memory  that may be required to process the input data packet  by determining the dimensions of a bounding box circumscribing the geometry primitive. A greater detailed description of bounding boxes is provided above in references to section Bounding Boxes.","At step , GCE  determines Maximum Per Tile Estimate  as discussed in greater detail above. At step , the Maximum Per Tile Estimate  is multiplied by the group of tiles identified by the bounding box , to determine an estimate of the \u201cmemory needed\u201d for write control  to store the spatial data and associated pointers for the geometry primitive. In an embodiment of the present invention, memory needed, with respect to this example, is equal to the number of bytes in a Vertex Packet  plus the number of bytes in a corresponding Vertex pointer . Next, GCE  continues at E, as illustrated in FIG. C, where at step , if memory needed is less than or equal to Memory Left , then at step  an \u201cenough memory\u201d indication is returned to the calling procedure, for example, write control  procedure (see ). The indication shows that there is for certain enough memory for write control  to store the spatial data and associated pointers into sort memory . As discussed above, this indication can be as simple as returning a boolean value of \u201ctrue\u201d. Otherwise, at step , if memory needed is greater than memory left , at step , an indication is set showing that sort memory  could possibly overflow while storing the spatial data and associated pointers corresponding to this geometry primitive.","Other Processing Stages ","In one embodiment of the present invention, other processing stages  (see FIG. C) includes, for example, any other graphics processing stages as long as a next other processing stage  can receive image data that sorted with respect to regions of a 2-D window on a region-by-region basis.","Referring to FIG. C, there is shown an example of a preferred embodiment of other processing stages , including, setup , cull , mode injection , fragment , texture , Phong Lighting , pixel , and backend . The details of each of the processing stages in other processing stages  is not necessary to practice the present invention. However, for purposes of completeness, we will now briefly discuss each of these processing stages.","Setup  receives sorted spatial data and mode data, on a region-by region basis from sort . Setup  calculates spatial derivatives for lines and triangles one region and one primitive at a time.","Cull  receives data from a previous stage in the graphics pipeline, such as setup , in region-by-region order, and discards any primitives, or parts of primitives that definitely do not contribute to the rendered image. Cull  outputs spatial data that are not hidden by previously processed geometry.","Mode injection  retrieves mode information (e.g., colors, material properties, etc. . . . ) from polygon memory, such as other memory , and passes it to a next stage in graphics pipeline , such as fragment , as required. Fragment  interprets color values for Gouraud shading, surface normals for Phong shading, texture coordinates for texture mapping, and interpolates surface tangents for use in a bump mapping algorithm (if required).","Texture  applies texture maps, stored in a texture memory, to pixel fragments. Phong  uses the material and lighting information supplied by mode injection  to perform Phong shading for each pixel fragment. Pixel  receives visible surface portions and the fragment colors and generates the final picture. And, backend  receives a tile's worth of data at a time from pixel  and stores the data into a frame display buffer.","In a preferred embodiment of the present invention, sort  is situated between mode extraction  (see FIG. C) and setup  (see FIG. C).","Interface between Spatial Sorting  and Setup ","Referring to Table 13, there is shown an example of primitive packet . The majority of output from sort  to a subsequent stage of pipeline , is a sequence of primitive packets  that contain sets of 1, 2, or 3 vertices.","Sort  also sends clear packets  to a subsequent stage in pipeline . Clear packets  is described in greater detail above in reference to the interface between sort  and mode extraction .","Referring to Table 11, there is shown in example of an output cull packet . Read control  send all cull packet down stream unless its after the last vertex packet  or clear packet  in the tile.","Referring to Table 9, there is shown in example of begin tile packet . Read control  may make multiple passes with regard to the image data corresponding to a particular tile because of: (a) multiple target draw buffers\u2014for example front as well as back or left as well as right in a stereo frame buffer, and\/or, (b) it may contain transparent geometry while pipeline  is operating in sorted transparency mode. Sorted transparency mode is discussed in greater detail below in reference to read control  procedure.","Sort  outputs this packet type for every tile in the 2-D window that has some activity, meaning that this packet type is output for every 2-D window that either has an associated buffer clear (see Table 4, clear packet ), or rendered primitives.","Referring to Table 10, there is shown an example of an end tile packet  for designating that all of the image data corresponding to a particular tile has been sent.","Interface Signals","Referring to Table 18, there is shown interface signals and packets between sort  and setup , including srtOD_writeData signal , indicating that data on mode extraction  data out bus  is a valid packet.","StpOD_stall signal  indicates that setup 's input queue is full, and that sort  should stop sending data to setup . Signal stpOD_transEnd  indicates that sort  should stop re-sending a transparency sub-tile in sorted transparency mode. Setup  sends the signal because a downstage culling unit of pipeline  has determined that it has finished with all transparent primitives in the tile. Sorted transparency mode is described in greater detail below with regard to read control .","It can be appreciated that the specific values selected to represent each of the immediately above discussed signals are not necessary to practice the present invention. It is only important that each signal has such a unique value with respect to another signal that each signal can be differentiated from each other signal by sort  and setup .","Read Control ","At this point, write control  has processed either an entire frame, or a split frame, of spatial and mode data, and spatially sorted that image data, vertex by vertex and mode by mode, on a tile-by-tile basis, in time-order, into sort memory . We will now discuss a number of embodiments of read control , used by sort  to output the spatially sorted image data to a subsequent process of pipeline . We will first discuss how read control  balances the effects of scene and horizon complexity, such that loads across the subsequent stages of pipeline  are more evenly balanced, resulting in more efficient pipeline  processing. This pipeline  load balancing discussion will introduce several new concepts, including, for example, the concepts of \u201cSuperTile tile organization\u201d and a \u201cSuperTile Hop Sequence\u201d.","Next, we will describe how a preferred embodiment of read control  builds primitive packets  from the spatially sorted image data in sort memory . Next, we will discuss a number of different modes that the spatially sorted image data can be sent down pipeline  according to the teachings of the present invention, for example, in-time order mode and sorted transparency mode. Finally, we will discuss an embodiment of a read control  procedure used to send the image data to a subsequent stage of pipeline .","Graphics Pipeline Load Balancing","As discussed above in reference to the background, significant problems are presented by outputting image data to a next stage of a graphic pipeline using a first-in first-out (FIFO), row-by-row, or column-by-column strategy. Outputting image data in such a manner does not take into account how scene complexity and\/or horizon complexity across different portions of an image may place differing loads on subsequent stages of a graphics pipeline, possibly resulting in bottlenecks in the pipeline, and therefore, less efficient pipeline processing of the image data. It is desirable to balance these scene and horizon complexity effects across the subsequent rendering resources of pipeline , (for example, see FIG. C).","To accomplish the goal of balancing rendering resources across pipeline , a preferred embodiment of read control : (a) organizes the tiles of the 2-D window (according to which write control  spatially sorted the image data) into a SuperTile based tile organization; and, (2) sends the SuperTiles to a subsequent stage in pipeline  in a spatially staggered sequence, called the \u201cSuperTile Hop Sequence.\u201d Such load balancing also has an additional benefit of permitting a subsequent texture stage of pipeline , for example, texture  (see FIG. C), to utilize a degree of texture cache reuse optimization.","SuperTiles","To illustrate the idea of a SuperTile, refer to FIG. C, where there is shown an example of a SuperTile, and in particular, a block diagram of a 2\u00d72 SuperTile  composed of four tiles. A SuperTile  can be one tile, or any number of tiles. The number of SuperTiles  in a SuperTile row  in an array of SuperTiles , need not be the same as the number of tiles in a SuperTile column .","In one embodiment of the present invention, the number of tiles per SuperTile  is selectable, and the number of tiles in a SuperTile  may be selected to be either a 1\u00d71, a 2\u00d72, or a 4\u00d74 group of tiles. The number of tiles in a SuperTile  is selected by either a graphics device driver or application, for example, a 3-D graphics application executing on computer  (see FIG. C). The number of tiles in a SuperTile  can also be preselected to match typical demands of a target application space.","In a preferred embodiment the number of tiles in a SuperTile is 2\u00d72. For example, the present invention contemplates that the number of tiles in a SuperTile is selected such that the complexity of an image is balanced. Depending on the particular image, or target application space, if SuperTiles contain too many tiles they will contain simple as well as complex regions of the image. If a SuperTile size does not contain enough tiles, the setup cost for rendering a tile is not amortized by subsequent stages of pipeline . Such amortization includes, for example, texture map reuse and pixel blending concerns.","SuperTile Hop Sequence","In a preferred embodiment of the present invention, read control  reads SuperTiles  out of sort memory  is a spatially staggered sequence, hereinafter referred to as the \u201cSuper Tile Hop Sequence,\u201d or \u201cSHS,\u201d to better balance the complexity of sub-sequences of tiles being sent to subsequent stages of pipeline . In other words, in this embodiment, read control  does not send image data from sort memory  to a subsequent stage in pipeline  in such a manner that SuperTiles  fall in a straight line across the computer display window, as illustrated by tile order, on either a row-by-row or a column-by-column basis. The exact order in the spatially staggered sequence is not important, as long as it balances scene and horizon complexity.","Referring to FIG. C, SuperTile array  is a 9 row\u00d77 column array of 2\u00d72 tile SuperTiles. Because, in this example, the SuperTile size is 2\u00d72 tiles, SuperTile array  contains 63 SuperTiles, or an 18\u00d714 array of tiles, or 1605 tiles. Read control  converts SuperTile array  into a linear list  by numbering the SuperTiles  in a row-by-row manner starting in a corner of the 2-D window of tiles, for example, the lower left or the upper left of the SuperTile matrix . In a preferred embodiment, the numbering starts in the upper left of a 2-D window of SuperTiles.","Next, read control  defines the sequence of SuperTile processing as:\n\nT=0,\n\n=mod(),\n","The requirement of \u201cM\u201d is that it be relatively prime with respect to N. It is not required that M be less than N. In this example, \u201cM\u201d is 13, because it a relatively prime number with respect to N in this example, or 63. Where N=number of SuperTiles in a window, M=the SuperTile step, and Tn=nth SuperTile to be processed, where 0<=n<=N\u22121. In this example N=63 (length & width), and M=13. This results in the sequence: T=0, T=13, T=26, T=39, T=52, T=2, T=15, as illustrated in tile order , which shows the resulting SuperTile Hop Sequence.","This algorithm, the SuperTile Hop Sequence, creates a pseudo-random sequence of tiles, whereas scene and horizon complexity tends towards the focal point of the image, or the horizon.","This iterative SuperTile Hop Sequence procedure will hit every SuperTile  in a 2-D window as long as N and M are relatively prime (that is, their greatest common factor is 1). Neither N nor M need to be prime numbers, but if M is always selected to be a prime number, then every Super Tile will be hit. When one or both of N or M are not prime, then portions of the scene would never be rendered by subsequent stages of pipeline . For example, if \u201cN\u201d were set equal to 10 and \u201cM\u201d were set to equal 12, no odd numbered SuperTiles would be rendered.","In a preferred embodiment, a SuperTiles array is larger than needed to cover an entire 2-D window, and is assumed to be 2\u00d72=2, where \u201ca\u201d and \u201cb\u201d are positive integers, and where \u201ca\u201d can equal \u201cb\u201d, thus guaranteeing the total number of SuperTiles in the SuperTile array to be an integer power of two. Having the total number of SuperTiles be an integer power of two simplifies implementation of the Modulus operation in a finite hardware architecture where numbers are represented in base 2.","This makes it possible to do \u201cmod\u201d calculation simply by throwing away high order bits. Using this approach, nonexistent, or fictitious SuperTiles  will be included in the SHS and, in a preferred embodiment of the invention, they are detected and skipped during Read control , because there is no frame geometry within the tiles. Detecting such non-existent, or fictitious SuperTiles  can be done through the use of scissor windows where the dimensions of the scissor window equals the actual dimensions of the 2-D window. In such a situation read control , discussed in greater detail below, does not output those tiles, or SuperTiles that fall completely outside the scissor window.","Referring to FIG. C, there is shown an illustration of an exemplary read control  circuit, for reading data out of sort memory . Read control  may be configured to include the following circuits: (a) Tile Generator Circuit , for grouping tiles into SuperTiles and determining a SuperTile Hop Sequence order that the SuperTiles should be sent out to a next stage in the graphics pipeline, such as setup ; (b) Pointer Traversal Circuit , for traversing a 2-D windows' mode pointer lists and tail pointer lists to populate read cache  on a tile-by-tile basis, wherein each tiles' spatial data is stored in time-order; and (c) geometry assembly circuit , for constructing output primitive packets  (see Table 13), and accumulating clear mode packets  (see Table 4) before sending the spatial and mode data, on a tile-by-tile basis to the next stage in graphics pipeline , the functionality of each of these circuits , ,  and  are discussed in greater detail below with reference to FIG. C.","Read Control Procedure","In operation, read control : (a) selects the next tile to be sent to a subsequent processing stage of pipeline ; (b) reads the final vertex pointer  address from current tail memory  for the chosen tile; (c) tests the final vertex pointer  and mode pointer X to determine if the tile can be discarded except; (d) if the tile is not discarded, read control  proceeds to traverse the current tile pointer list to find the addresses of the vertices of the primitives that touch the tile; (e) the vertex data are read as needed, and primitives are assembled into primitive  (see Table 13) packets and passed to a subsequent processing stage of pipeline . In a preferred embodiment of the present invention, the subsequent processing stage is setup  (see FIG. C).","In one embodiment of the present invention, image data corresponding to tiles are re-sent to a subsequent stage of pipeline  if primitives are rendered to both front and back buffers, such as, for example, when the user or 3-D graphics application executing on, for example, computer  (see FIG. C), requests this.","In a preferred embodiment of the present invention, image data corresponding to tiles are re-sent to a subsequent processing stage of pipeline , under some circumstances, for example, when pipeline  is in sorted transparency mode. Sorted transparency mode is discussed in greater detail below.","In yet another embodiment of the present invention, read control  performs two primary optimizations. The first, tiles that are not intersected by any primitive or clear packet  are not sent to the subsequent stage of pipeline . Second, the address of the current vertex is compared to the address of the current mode packet to determine if the mode packet should be merged into the output stream, in this manner, clear buffer events that occur before any geometry are compressed where possible. This is beneficial because it reduces the bandwidth of image data to subsequent stages of pipeline .","In yet another preferred embodiment if the present invention, read control  starts reading spatially sorted image data from a buffer in sort memory  that was immediately prior to read control 's step of beginning to read, designated for writes by write cotnrol .","Referring to , we will now describe an example of read control  procedure. At step , the array of tiles representing the spatial area of the 2-D window are grouped into an array of SuperTiles . Supertiles  are discussed in greater detail above in reference to . At step , the SuperTile Hop Sequence order for sending out the SuperTiles to a next stage in graphics pipeline  is determined. The Supertile Hop Sequence is described in greater detail above in reference to .","At step , read control  (1) orders packets (vertex packets X and mode packets  and ), on a tile-by-tile basis, in an in-time order manner, from sort memory ; and, (2) writes them, into a queue, read cache .","To order the packets in an output sort memory buffer, for example, buffer  (see ), the following must be taken into consideration. A single mode packet  or  may affect multiple tiles, as well as multiple primitives within any one particular tile. Any one buffer in sort memory , for example, buffer  or buffer  (see FIG. C), contains a single mode pointer list, for example, mode pointer list . Mode packets X are not sorted by write control  into sort memory  on a tile-by-tile basis, but only in an in-time order into an input data storage buffer, for example, data storage  (see FIG. C). Thus, a single mode packet X may affect multiple tiles, as well as multiple primitives within any one particular tile. It is desirable that read control  map each particular mode packet X to those tiles that it effects, and that read control  only output a mode packet that effects the primitives in a particular tile, only once per that particular tile, as compared to outputting a mode packet that effects the primitives in a tile once per primitive per tile.","To achieve this goal and to populate read cache  (step ), read control  compares the address of each vertex pointer  (in each input buffer tile pointer list) to the address of each mode pointer  or  in the single input buffer mode pointer list. (Referring to FIG. C, the input buffer tile pointer lists could be, for example, tile  tile pointer list , tile  tile pointer list , tile  tile pointer list , and tile N tile pointer list . The input buffer mode pointer list could be, for example, mode pointer list ). If the address of a mode pointer  or  is greater than the address of a vertex pointer , the mode pointer  or  came before vertex pointer . If the address of a vertex pointer  is greater than the address of a mode pointer  or , the vertex pointer  came before the mode pointer  or . Whichever pointer was written into sort memory  first, indicates that the pointer's corresponding packet in the input data storage buffer (for example, see FIG. C, data storage ), either a vertex packet  or mode packet  or , should be sent out of read control  to a subsequent processing stage of pipeline  before the packet that was determined to have been written into the input data storage buffer subsequent. Using this procedure, each mode packet  or  that affects a tile is output only one time, for the tile that it effects.","This explanation assumes that pointers are written by write control  into sort memory  from the bottom of sort memory  towards the top of sort memory  pointers are written by write control  from the top-down, the reverse of the above explanation applies.","In a preferred embodiment of the present invention, to write the packets into read cache , in preferred embodiment of the present invention, read control  will try to minimize the amount of extraneous data sent to subsequent stages of pipeline  by not sending out tiles that are empty of primitives. To accomplish this, read control  uses the output tail memory  buffer, either  or  (see FIG. C), to identify those tiles in the 2-D window that do not contain primitives. For example, if an address of an output buffer tile pointer list (see ADDR HEAD , FIG. C), equals the address of a corresponding tail address X (see ADDR TAIL , Table 6) in tail memory , then that particular tile does not have any primitives sorted into it by write control  (it is empty of any frame geometry). Therefore, read control  will not any data for that particular tile to subsequent stages of pipeline .","In yet another preferred embodiment of the present invention, read control  will minimize the amount of extraneous data set to subsequent stages of pipeline  by not sending our fictitious files. A fictitious tile is a tile that is empty of frame geometry that was previously created by read control  during SuperTile tile organization discussed in great detail above, wherein the number of tiles and the 2-D window may be have been increased by power of two.","To accomplish this goal, read control  will create a scissor window having the actual coordinates of the 2-D window. Referring to Table 14, there is shown in example of a scissor window data structure, for storing the coordinates of the scissor window.","Enable  designates whether read control  should the scissor window. Enable  set to equal \u201c1\u201d designates that read control  should use the scissor window defined therein. Xmin , Xmax , Ymin , and Ymax  are used to define the minimum and maximum coordinates defining the dimensions of the scissor window. In a preferred embodiment of the present invention, scissor window data structure  is stored in, for example, sort memory  (see FIG. C), or other memory (not shown).","In yet another preferred embodiment of the present invention, read control  will minimize the amount of extraneous data set to subsequent stages of pipeline  by not sending out fictitious files. A fictitious tile is a tile that is empty of frame geometry that was previously created by read control  during SuperTile tile organization discussed in great detail above, wherein the number of tiles and the 2-D window may have been increased by power of two.","To accomplish this goal, read control  will create a scissor window having the actual coordinates of the 2-D window. Referring to table. 14, there is shown in example of a scissor window data structure, for storing the coordinates of the scissor window.","Enable  designates whether read control  should the scissor window. Enable  set to equal \u201c1\u201d designates that read control  should use the scissor window defined therein. Xmin . Xmax , Ymin , and Y max  are used to define the minimum and maximum coordinates defining the dimensions of the scissor window. In a preferred embodiment of the present invention, scissor window data structure  is stored in, for example, sort memory  (see FIG. C), or other memory (not shown).","In this preferred embodiment, read control  will discard any tiles that lie completely outside of this scissor window. Those tiles that are situated partially inside and outside of the scissor window are not discarded.","In yet another embodiment of the present invention, scissor window data structure  includes link , for pointing to a next scissor window data structure . In this embodiment, read control  utilizes a singly linked list of scissor window data structures  to define multiple scissor windows. Linked list data structures and the operation of linked list in structures are known, and for that reason are not discussed in greater detail herein.","Is contemplated that these multiple scissor windows are utilized to discern which tiles comprising the 2-D window need to be rendered and which do not, thereby enabling the present invention to send only those image data that represent the visible portions of a window down stages of a graphics pipeline, while discarding those image data, or fictional image data that do not contribute to the visible portions of the window.","When read control  determines that the vertex data corresponding to vertex pointer  should be stored into read cache , read control  generates pointer references to any vertex packets  in Data Storage that may be necessary to assemble the complete geometry primitive, and stores the pointer references into read cache . The procedure for identifying each of a primitive's remaining vertices, if any, from vertex pointer  is described in greater detail above in reference to vertex pointers  and Table 5.","In light of that procedure, read control  generates pointer references to store into read cache  according to the following rules, if offset  represents a point, no additional vertices are needed to describe the primitive, thus read control  only writes the address of a single vertex pointer  into read cache . If the offset  represents a line segment, another vertex is needed to describe the line segment and read control  first writes vertex pointer  with the address of vertex pointer  minus 1 into read cache , then writes the address of vertex pointer  into read cache  If the offset  represents a triangle, two more vertices are needed to describe the triangle, and read control  first writes the following pointers into read cache , in this order (1) the address of vertex pointer  minus the value of the offset; (2) the address of vertex pointer  minus 1; and, (3) the address of vertex pointer .","As read control  populates read cache  with each tiles' respective image data, the order that each primitive in the tile is read into Read Cache  is governed according to whether read control  is operating in either \u201cTime Order Mode,\u201d or \u201cSorted Transparency Mode.\u201d In Time Order Mode (the default mode for one embodiment of the present invention), Read control  preserves the time order of receipt of the vertices and modes within each tile as the data is stored. That is, for a given tile, vertices and modes are read into Read Cache  in the same order as they were written into sort memory  by write control .","Sorted Transparency Mode","In sorted transparency mode, read control  reads each tile's data in multiple passes into read cache . In the first pass, read control  outputs \u201cguaranteed opaque\u201d geometry. In this context, guaranteed opaque means that the geometry primitive completely obscures more distant geometry that occupies the same area in the window. In subsequent passes, read control  outputs potentially transparent geometry. Potentially transparent geometry is any geometry that is not guaranteed opaque. As discussed above, within each pass, the geometry's time-ordering is preserved and mode data (contained in the mode packets) are inserted into their correct time-order location.","In one embodiment of the present invention, each vertex pointer  includes the transparent element  (see Table X). Transparent element  is a single bit, where \u201c0\u201d represents that the primitive is guaranteed to be opaque, and where \u201c1\u201d, represents that the corresponding primitive is treated as possibly transparent.","Clear packet  includes an indication, SortTransparentMode  (see Table 4), of whether the read control  will operate in time order mode, or sorted transparency mode. In one embodiment of the present invention, if SortTransparentMode  is set to equal \u201c1\u201d, then read control  will operate in time order mode. In this embodiment, if SortTransparentMode  is set to \u201c0\u201d, then read control  will operate in sorted transparency mode.","Referring to FIG. C, at step , read control  uses each vertex pointer  and each mode pointer (depending on the type of mode packet, either a clear mode packet pointer  or a cull mode packet pointer ) stored in read cache  to access each particular pointer's respectively referenced packet in data storage.","In the process of reading the pointers out of read cache , read control  accumulates each clear packet  that it encounters. The process of accumulating clear mode packets  is advantageous because it reduces the image data bandwidth to subsequent stages of pipeline , such as, for example, those operations stages identified in FIG. C. Clear packets  are accumulated until either a vertex pointer  referencing a completing vertex is read from read cache , or a particular clear packet  includes a \u201csend now\u201d field (SendToPixel ) that is set to, for example, \u201c1,\u201d and indicates that particular packet needs to be sent immediately. When read control  encounters either one of these two situations, read control  sends any accumulated clear packets  to a next stage in the graphics pipeline, for example setup .","In one embodiment of the present invention, multiple adjacent sort output cull packets  (see table 11) are compressed into one sort output cull packet by a cull register (not shown). In essence, the cull register logically ors each CullFlushAll bits  from the multiple output cull packets , and uses the last packets for all other parameters. This is beneficial because it allows a subsequent stage of pipeline , for example cull  to be turned off for some geometry without affecting the subsequent status process with respect to tiles that do not contain the geometry.","Referring to Table 13, there is shown an example of an exemplary output primitive packet , for sending to a next stage in the graphics pipeline. For each vertex pointer  read out of read cache , read control  generates an output primitive packet . To accomplish this, read control  will accumulate each primitive's vertices, where each vertex is stored in a corresponding vertex packet , in data storage, into a respective output primitive packet . As discussed above, each vertex pointer  that contains a completing vertex, is written as the last vertex pointer  into the read cache . The procedures for assembling each of a primitive's vertices from a vertex pointer  is discussed in greater detail above with respect to Table 5 and vertex pointer .","At step , read control  sends the packets to the next stage in the graphics pipeline, such as setup , on a tile-by-tile basis. At the beginning of outputting each tile's respective image data, an output begin tile packet  is output including all per-tile parameters needed by downstream blocks in a graphics pipeline. Referring to Table 9, there is shown an example of an output begin tile packet  that includes per-tile parameters, such as the location (in pixels) within the 2-D window of the lower left hand corner of the given tile. Referring to Table 9.5, there is shown an example of an output end tile packet . Read control  includes the following packets with every tile that is output to the next stage in the graphics pipeline: (1) output cull mode packet ; (2) any accumulated clear packets ; and, (3) each of the given tile's output primitive packets ; and (4) an Output End Tile packet .","Optional Enhancements and Alternative Embodiments","Line Mode Flags","Recall that each spatial packet  has a LineFlags element . This element  indicates whether a line segment has already been rendered, and thus, does not need to be rendered again. This is particularly important for rendering line mode triangles with shared edges.","Referring to FIG. C, where there is shown a window  with six tiles A, B, C, D, E and F, and eight geometry primitives , , , , , ,  and . In this example, a triangle fan includes triangles , , and . Triangle , identified by vertices , , and , share a line segment identified by vertices  and  with triangle , identified by vertices ,  and . In this alternate embodiment, if the LineFlag element  is set, such shared line segments will only be rendered once.","Sort Memory: Triple Buffered","With only two pages of sort memory , read control  and write control  are in lockstep and either one of these processes. For example, when the write control  is sorting image data for frames that alternate from having complex geometry to having sparse geometry, the read control  and write control  may operate on significantly different quantities of image data at any one time. Recall that sort memory  is swapped when either a complete frame's worth of image data has been processed, a sort memory  buffer overflow error occurs, or on a forced end of frame indication sent by an application. Therefore, a process, for example either write control  or read control , that completes first, has to wait until the other process is complete before it can begin processing a next frame of image data.","Sort Memory: Dynamic Memory Management","In an alternative embodiment of the present invention, sort memory  is at least triple buffered. A first, or front buffer is for collecting a scene's geometry. A second, or back buffer is for sending the sorted geometry down the graphics pipeline. A third, or overflow buffer is for storing a frame's geometry when the front buffer has overflowed, or for holding the holds a complete series of spatially sorted image data until the back buffer has has finished being emptied. Such an implementation would enable both the read and write process to work relatively independently of one another. For example, frame size stalls on the input side will be isolated from the output side; the only reason write process  would stall is if it ran out of memory or data.","In another embodiment, sort memory  is managed with a dynamic memory management system, for allocating and deallocating pages of sort memory on an as needed basis. Dynamic memory management systems are known in the art on all non-dedicated hardware platforms. The present invention contemplates use of a dynamic memory manager operating in a processing stage, for example, sort , on a dedicated 3-D processor, for example, 3-D processor  (see ).","In one embodiment of the present invention, sort  allocates memory blocks from a memory pool, for example, sort memory , on an as needed basis. To illustrate this, consider the following example: write control  allocates a first memory buffer to sort a frame of image data into. Either at: (a) the end of the image frame; (b) upon receipt, by write control , of a forced end of frame indication from a software application executing on, for example, computer  (see FIG. C); or, (c) upon an indication from guaranteed conservative memory estimate  (see, FIG. C) of a possible memory buffer overflow, write control  signals read control  to begin reading the sorted image data out of the first memory buffer.","At this point, write control  allocates a second memory buffer to sort a frame of image data into. Upon happening of any of the above listed events (a), (b), or (c), write control  checks to see if read control  has completed reading the sorted image data to a subsequent stage pipeline . If read control  has not finished, write control  allocates a third memory buffer to begin sorting a next frame of image data into. Write control  additionally, signals read control  that the second memory buffer is available for read control  to begin reading the sorted image data out of as soon as read control  finishes with its current buffer, the first memory buffer.","Upon completion, read control  releases the first memory buffer, and returns the memory resource to the memory pool. Additionally, at this point, read control  begins to read sorted image data from the second memory buffer. In this manner, write control  and read control  are able to work relatively independently of one another. Frame size stalls on the input side will be isolated from the output side. Although this example only uses three memory buffers, is contemplated that more than memory buffers can be used.","A Computer Program Product","The present invention can be implemented as a computer program product that includes a computer program mechanism embedded in a computer readable storage medium. For instance, the computer program product would contain the write process and read control program modules shown in . These program modules may be stored on a CD-ROM, magnetic disk storage product, or any other computer readable data or program storage product. The software modules in the computer program product may also be distributed electronically, via the Internet or otherwise, by transmission of a computer data signal (in which the software modules are embedded) on a carrier wave.","A tiled architecture is a graphic pipeline architecture that associates image data, and in particular geometry primitives, with regions in a 2-D window, where the 2-D window is divided into multiple equally size regions. Tiled architectures are beneficial because they allow a graphics pipeline to efficiently operate on smaller amounts of image data. In other words, a tiled graphics pipeline architecture presents an opportunity to utilize specialized, higher performance graphics hardware into the graphic pipeline.","Those graphics pipelines that do have tiled architectures do not perform mid-pipeline sorting of the image data with respect to the regions of the 2-D window. Conventional graphics pipelines typically sort image data either, in software at the beginning of a graphics pipelines, before any image data transformations have taken place, or in hardware the very end of the graphics pipeline, after rendering the image into a 2-D grid of pixels.","Significant problems are presented by sorting image data at the very beginning of the graphics pipelines. For example, sorting image data at the very beginning of the graphics pipelines, typically involves dividing intersecting primitives into smaller primitives where the primitives intersect, and thereby, creating more vertices. It is necessary for each of these vertices to be transformed into an appropriate coordinate space. Typically this is done by subsequent stage of the graphics pipeline.","Vertex transformation is computationally intensive. Because none of these vertices have yet been transformed into an appropriate coordinate space, each of these vertices will need to be transformed by a subsequent vertex transformation stage of the graphics pipeline into the appropriate coordinates space. Coordinate spaces are known. As noted above, vertex transformation is computationally intensive. Increasing the number of vertices by subdividing primitives before transformation, slows down the already slow vertex transformation process.","Significant problems are also presented by spatially sorting image data at the end of a graphics pipeline (in hardware). For example, sorting image data at the end of a graphic pipeline typically slows image processing down, because such an implementation typically \u201ctexture maps\u201d and rasterizes image data that will never be displayed. To illustrate this, consider the following example, where a first piece of geometry is spatially located behind a second piece of opaque geometry. In this illustration, the first piece of geometry will never be displayed.","Removing primitives or parts of primitives that will not be visible in a displayed image frame because, for example, the primitive may be completely or partially hidden behind another primitive is beneficial because it optimizes a graphic pipeline by processing only those image data that will be visible. The process of removing hidden image data is called culling.","Those tiled graphics pipelines that do have tiled architectures do not perform culling operations. Because, as discussed in greater detail above, it is desirable to sort image data mid-pipeline, after image data coordinate transformations have taken place, and before the image data has been texture mapped and\/or rasterized, it is also desirable to remove hidden pixels from the image data before the image data has been texture mapped and\/or rasterized. Therefore, what is also needed is a tiled graphics pipeline architecture that performs not only, mid-pipeline sorting, but mid-pipeline culling.","In a tile based graphics pipeline architecture, it is desireable to provide a culling unit with accurate image data information on a tile relative basis. Such image data information includes, for example, providing the culling unit those vertices defining the intersection of a primitive with a tile's edges. To accomplish this, the image data must be clipped to a tile. This information should be sent to the mid-pipeline culling unit. Therefore, because a mid-pipeline cull unit is novel and its input requirements are unique, what is also needed, is a structure and method for a mid-pipeline host file sorting setup unit for setting up image data information for the mid pipeline culling unit.","It is desireable that the logic in a mid-pipeline culling unit in a tiled graphics pipeline architecture be as high performance and streamlined as possible. The logic in a culling unit can be optimized for high performance by reducing the number of branches in its logical operations. For example, conventional culling operations typically include logic, or algorithms to determine which of a primitive's vertices lie within a tile, hereinafter referred to as a vertices\/tile intersection algorithm. Conventional culling operations typically implement a number of different vertices\/tile intersection algorithms to accomplish this, one algorithm for each primitive type.","A culling unit having only one such algorithm to determine whether a line segments or a triangles vertices lie within a tile, as compared to a culling unit having two such algorithms, one for each primitive type, would have fewer branches in its logical operations. In other words, it would be advantageous if, for example, triangles and lines were described using a common set of primitive descriptors. That way, a cull operation could share one algorithm\/set of equations\/set of hardware to determine whether vertices of triangles and line segments lie within a tile.","A common set of primitive descriptors would allow for the reduction of the number of such vertices\/tile intersection algorithms needed to be supported by a culling unit. Such a common set of primitive descriptors would also benefit other stages of a graphic pipeline. For example, a stage setting up indicate information for the culling unit if using a unified primitive description of triangles and lines could also share the same algorithms\/set of equations\/set of hardware for calculating a primitives minimum depth values and other information. Therefore, what is needed is a unified set of primitive descriptors for describing different primitive types, such that algorithms\/sets of equations\/sets of hardware may be shared within a stage of the graphics pipeline.","In conventional tile based graphics pipeline architectures, geometry primitive vertices, or x-coordinates and y-coordinates, are typically stored in screen based values. This means that, each vertices' x-coordinates and y-coordinates are typically stored as fixed point numbers with a limited number of fractional bits (sub pixel bits). Usually the representation has to be integer with a certain number of fractional bits.","Because it is desirable to architect a tile based graphics pipeline architecture to be as streamlined as possible, it would be beneficial to represent x-coordinates and y-coordinates in a smaller amount of memory. Therefore, what is needed is a structure and method for representing x-coordinates and y coordinates in a tile based graphics pipeline architecture, such that memory requirements are reduced.","Heretofore, graphics pipeline architectures have been limited by sorting image data either prior to the graphics pipeline or in hardware at the end of the graphics pipeline, no tile based graphics pipeline architecture culling units, no mid-pipeline post tile sorting setup units for culling operations, and larger vertices memory storage requirements.","The present invention overcomes the limitations of the state-of-the-art by providing structure and method in a tile based graphics pipeline architecture for: (a) a mid-pipeline post tile sorting setup unit, where the setup unit supplies a mid-pipeline cull unit with tile relative image data information; (b) a unified primitive descriptor language for representing triangles and line segments as quadrilaterals and thereby reducing the edge walking logic architectural requirements of a mid-pipeline culling unit; and, (c) reducing the amount of memory required to accurately, and efficiently represent a primitive's vertices by representing each of a primitive's vertices in tile relative y-values and screen relative x-values.to","The invention will now be described in detail by way of illustrations and examples for purposes of clarity and understanding. Occasionally pseudocode examples are presented to illustrate procedures of the present invention. The pseudocode used is, essentially, a computer language using universal computer language conventions. While the pseudocode employed in this description has been invented solely for the purposes of this description, it is designed to be easily understandable by any computer programmer skilled in the art.","It will be readily apparent to those of ordinary skill in the art in light of the teachings of this invention that certain changes and modifications may be made thereto without departing from the spirit or scope of the appended claims. We first provide a top-level system architectural description. Section headings are provided for convenience and are not to be construed as limiting the disclosure, as all various aspects of the invention are described in the several sections that were specifically labeled as such in a heading.","For purposes of explanation, the numerical precision of the calculations of the present invention is\/are based on the precision requirements of previous and subsequent stages of the graphics pipeline. The numerical precision selected depends on a number of factors. Such factors include, for example, the order of operations, the number of operations, the screen size, tile size, buffer depth, sub pixel precision, and precision of the data. Numerical precision issues are known, and for this reason will not be described in greater detail herein.","5.1 System Overview","Important aspects of the structure and method of the present invention include: (1) a mid-pipeline post tile sorting setup\u2014this is beneficial because it supports a mid-pipeline sorting unit and supports a mid-pipeline culling unit; (2) a unified primitive representation for uniformly representing line segments and triangles\u2014this is beneficial because it allows different types of primitives to share common algorithms and hardware elements in subsequent stages of the graphics pipeline; and, (3) tile-relative y-values and screen-relative x-values\u2014this is beneficial because it allows representing spatial data on a region by region bases that is efficient and feasible for a tiled architecture.","Referring to FIG. D, there is shown an embodiment of system , for performing setup operations in a 3-D graphics pipeline using unified primitive descriptors, post tile sorting setup, tile relative x-values, and screen relative y-values. In particular, FIG. D illustrates how various software and hardware elements cooperate with each other. System , utilizes a programmed general-purpose computer , and 3-D graphics processor . Computer  is generally conventional in design, comprising: (a) one or more data processing units (\u201cCPUs\u201d) ; (b) memory , and , such as fast primary memory , cache memory , and slower secondary memory , for mass storage, or any combination of these three types of memory; (c) optional user interface , including display monitor , keyboard , and pointing device ; (d) graphics port , for example, an advanced graphics port (\u201cAGP\u201d), providing an interface to specialized graphics hardware; (e) 3-D graphics processor  coupled to graphics port  across I\/O bus , for providing high-performance 3-D graphics processing; and (e) one or more communication busses , for interconnecting CPU , memory , specialized graphics hardware , 3-D graphics processor , and optional user interface .","I\/O bus  can be any type of peripheral bus including but not limited to an advanced graphics port bus, a Peripheral Component Interconnect (PCI) bus, Industry Standard Architecture (ISA) bus, Extended Industry Standard Architecture (EISA) bus, Microchannel Architecture, SCSI Bus, and the like. In a preferred embodiment, I\/O bus  is an advanced graphics port pro.","The present invention also contemplates that one embodiment of computer  may have a command buffer (not shown) on the other side of graphics port , for queuing graphics hardware I\/O directed to graphics processor .","Memory typically includes operating system  and one or more application programs , or processes, each of which typically occupies a separate address space in memory  at runtime. Operating system  typically provides basic system services, including, for example, support for an Application Program Interface (\u201cAPI\u201d) for accessing 3-D graphics API's such as Graphics Device Interface, DirectDraw\/Direct 3-D and OpenGL. DirectDraw\/Direct 3-D, and OpenGL are all well-known APIs, and for that reason are not discussed in greater detail herein. The application programs  may, for example, include user level programs for viewing and manipulating images.","It will be understood that a laptop or other type of portable computer, can also be used in connection with the present invention, for sorting image data in a graphics pipeline. In addition, a workstation on a local area network connected to a server can be used instead of computer  for sorting image data in a graphics pipeline. Accordingly, it should be apparent that the details of computer  are not particularly relevant to the present invention. Personal computer  simply serves as a convenient interface for receiving and transmitting messages to 3-D graphics processor .","Referring to FIG. D, there is shown an exemplary embodiment of 3-D graphics processor , which may be provided as a separate PC Board within computer , as a processor integrated onto the motherboard of computer , or as a stand-alone processor, coupled to graphics port  across I\/O bus , or other communication link.","Setup  is implemented as one processing stage of multiple processing stages in graphics processor . (Setup  correlates with \u201csetup stage ,\u201d as illustrated in U.S. Provisional Patent Application Ser. No. 60\/097,336).","Setup  is connected to other processing stages  across internal bus  and signal line . Setup  is connected to other processing stages  across internal bus  and signal line .","Internal bus  and internal bus  can be any type of peripheral bus including but not limited to a Peripheral Component Interconnect (PCI) bus, Industry Standard Architecture (ISA) bus, Extended Industry Standard Architecture (EISA) bus, Microchannel Architecture, SCSI Bus, and the like. In a preferred embodiment, internal bus  is a dedicated on-chip bus.","5.1.1 Other Processing Stages ","Referring to FIG. D, there is shown an example of a preferred embodiment of other processing stages , including, command fetch and decode , geometry , mode extraction , and sort . We will now briefly discuss each of these other processing stages .","Cmd Fetch\/Decode , or \u201cCFD \u201d handles communications with host computer  through graphics port . CFD  sends 2-D screen based data, such as bitmap blit window operations, directly to backend  (see FIG. D), because 2-D data of this type does not typically need to be processed further with respect to the other processing stage in other processing stages  or other processing stages . All 3-D operation data (e.g., necessary transform matrices, material and light parameters and other mode settings) are sent by CFD  to the geometry .","Geometry  performs calculations that pertain to displaying frame geometric primitives, hereinafter, often referred to as \u201cprimitives,\u201d such as points, line segments, and triangles, in a 3-D model. These calculations include transformations, vertex lighting, clipping, and primitive assembly. Geometry  sends \u201cproperly oriented\u201d geometry primitives to mode extraction .","Mode extraction  separates the input data stream from geometry  into two parts: (1) spatial data, such as frame geometry coordinates, and any other information needed for hidden surface removal; and, (2) non-spatial data, such as color, texture, and lighting information. Spatial data are sent to setup . The non-spatial data are stored into polygon memory (not shown). (Mode injection  (see FIG. D) with pipeline ).","Sort  sorts vertices and mode information with respect multiple regions in a 2-D window. Source  outputs the spatially sorted vertices and mode information on a region-by-region basis to setup .","The details of processing stages  are not necessary to practice the present invention, and for that reason other processing stages  are not discussed in further detail here.","5.1.2 Other Processing Stages ","Referring to FIG. D, there is shown an example of a preferred embodiment of other processing stages , including, cull , mode injection , fragment , texture , Phong Lighting , pixel , and backend . The details of each of the processing stages in other processing stages  is not necessary to practice the present invention. However, for purposes of completeness, we will now briefly discuss each of these processing stages.","Cull  receives data from a previous stage in the graphics pipeline, such as setup , in region-by-region order, and discards any primitives, or parts of primitives that definitely do not contribute to the rendered image. Cull  outputs spatial data that are not hidden by previously processed geometry.","Mode injection  retrieves mode information (e.g., colors, material properties, etc. . . . ) from polygon memory, such as other memory , and passes it to a next stage in graphics pipeline , such as fragment , as required. Fragment  interprets color values for Gouraud shading, surface normals for Phong shading, texture coordinates for texture mapping, and interpolates surface tangents for use in a bump mapping algorithm (if required).","Texture  applies texture maps, stored in a texture memory, to pixel fragments. Phong  uses the material and lighting information supplied by mode injection  to perform Phong shading for each pixel fragment. Pixel  receives visible surface portions and the fragment colors and generates the final picture. And, backend  receives a tile's worth of data at a time from pixel  and stores the data into a frame display buffer.","5.2 Setup  Overview","Setup  receives a stream of image data from a previous processing stage of pipeline  In a preferred embodiment of the present invention the previous processing stage is sort  (see FIG. D). These image data include spatial information about geometric primitives to be rendered by pipeline . The primitives received from sort  can be filled triangles, line triangles, lines, stippled lines, and points. These image data also include mode information.","Mode information is information that does not necessarily apply to any one particular primitive, but rather, probably applies to multiple primitives. For example, a 3-D graphics application executing on, for example, computer  (see FIG. D), during the course or rendering a frame, can clear one or more buffers, including, for example, a color buffer, a depth buffer, and\/or a stencil buffer. Color buffers, depth buffers, and stencil buffers are known, and for this reason are not discussed in greater detail herein. An application typically only performs a buffer clear at the very beginning of a frame rendering process. To indicate such buffer clear mode information, a previous stage of pipeline  will send the mode information down pipeline .","By the time that setup  receives the primitives sent by Sort , the primitives have already been sorted, by sort , on an image frame-by-image frame basis, spatially with respect to multiple regions in a 2-D window. Setup  receives each primitive and any corresponding mode information from sort  on a region-by-region basis. That is to say, that setup  receives all primitives that touch a respective region of a frame of a 2-D window, along with any corresponding mode information, before receiving all of the primitives that touch a different respective region of the 2-D window, along with any of that different respective regions corresponding mode information. In a preferred embodiment of the present invention, each region of the 2-D window is a rectangular tile.","Within each region, the image data is organized in \u201ctime order\u201d or in \u201csorted transparency order.\u201d In time order, the time order of receipt by all previous processing stages of pipeline  of the vertices and modes within each tile is preserved. That is, for a given tile, vertices and modes are read out of previous stages of pipeline  just as they were received, with the exception of when sort  is in sorted transparency mode.","In sorted transparency mode, \u201cguaranteed opaque\u201d primitives are received by setup  first, before setup  receives potentially transparent geometry. In this context, guaranteed opaque means that a primitive completely obscures more distant primitives that occupies the same spatial area in a window. Potentially transparent geometry is any geometry that is not guaranteed opaque.","Setup  prepares the incoming image data for processing by cull . Cull  produces the visible stamp portions, or \u201cVSPs\u201d used by subsequent processing stages in pipeline . For purposes of explanation, a stamp is a region two pixels by two pixels in dimension. One pixel contains four sample points. One tile has 16 stamps (8\u00d78). We briefly describe culling here so that the preparatory processing performed by setup  in anticipation that culling may be more readily understood.","Cull  receives image data from setup  in region order (in fact in the order that setup  receives the image data from sort ), and culls out those primitives and parts of primitives that definitely do not contribute to a rendered image. Cull  accomplishes this in two stages, the MCCAM cull  stage and the Z cull  stage. MCCAM cull , allows detection of those memory elements in a rectangular, spatially addressable memory array whose \u201ccontent\u201d (depth values) are greater than a given value. Spatially addressable memory is known.","Z cull  refines the work performed by MCCAM cull , by doing a sample-by-sample content comparison. A sample-by-sample content comparison means that for each possibly visible stamp, a z-value (depth value), is calculated at each sample within that stamp. The sample-by-sample content comparison refines the work performed by the first stage because busy value at each sample point that is covered by the primitive is compared to a Z-buffer memory to determine which sample points are visible. Z-buffer memory holds the nearest depth value for each sample point and is updated accordingly.","To prepare the incoming image data for processing by MCCAM cull, setup , for each primitive: (a) determines the dimensions of a tight bounding box around that part of the primitive that intersects the tile; and, (b) computes a minimum depth value \u201cZmin,\u201d for that part of the primitive that intersects the tile. This is beneficial because MCCAM cull  uses the dimensions of the bounding box and the minimum depth value to determine which of multiple \u201cstamps,\u201d each stamp lying within the dimensions of the bounding box, may contain depth values less than Zmin. The procedures for determining the dimensions of a bounding box and the procedures for producing a minimum depth value are described in greater detail below.","For purposes of simplifying the description, those stamps that lie within the dimensions of the bounding box are hereinafter referred to as \u201ccandidate stamps.\u201d","Z cull  refines the process of determining which samples are visible by taking these candidates stamps, and if they are part of the primitive, computing the actual depth value for samples in that stamp. This more accurate depth value is then compared, on a sample-by-sample basis, to the z-values stored in the z-buffer memory in cull  to determine if the sample is visible. A sample-by-sample basis simply means that each sample is compared individually, as compared to the step where a whole bounding box is compared at once.","Setup  also computes depth gradients, line slopes, other reference parameters, and primitive intersection points with respect to a tile edge for cull . As discussed above, the minimum depth value and a bounding box are utilized by MCCAM cull . The zref and depth gradients are used by Z-cull . Line (edge) slopes, intersections, and corners (top and bottom) are used by Z-cull  for edge walking.","For those primitives that are lines and triangles, setup  calculates spatial derivatives. A spatial derivative is a partial derivative of the depth value. Spatial derivatives are also known as Z-slopes, or depth gradients.","5.2.1 Interface I\/O with other Processing Stages of the Pipeline","Setup  interfaces with a previous stage of pipeline , for example, sort  (see ), and a subsequent stage of pipeline , for example, cull  (see FIG. D). We now discuss sort  output packets.","5.2.1.1 Sort  Setup  Interface","Referring to table 1, there is shown a begin frame packet , for delimiting the beginning of a frame of image data. Begin frame packet  is received by setup  from sort . Referring to table 2, there is shown an example of a begin tile packet , for delimiting the beginning of that particular tile's worth of image data.","Referring to table 4, there a shown an example of a clear packet , for indicating a buffer clear event. Referring to table 5, there is shown an example of a cull packet , for indicating, among other things the packet type . Referring to table 6, there is shown an example of an end frame packet , for indicating by sort , the end of a frame of image data. Referring to table 7, there is shown an example of a primitive packet , for identifying information with respect to a primitive. Sort  sends one primitive packet  to setup  for each primitive.","5.2.1.2 Setup  Cull  Interface","Referring to table 8, there is shown an example of setup output primitive packet , for indicating to a subsequent stage of pipeline , for example, cull , a primitive's information as determined by setup . Such information is discussed in greater detail below.","5.2.2 Setup Primitives","To set the context of the present invention, we briefly describe setup primitives, including, for example, polygons, lines, and points.","5.2.2.1 Polygons","Polygons arriving at setup  are essentially triangles, either filled triangles or line mode triangles. A filled triangle is expressed as three vertices. Whereas, a line mode triangle is treated by setup  as three individual line segments. Setup  receives window coordinates (x, y, z) defining three triangle vertices for both line mode triangles and for filled triangles. Note that the aliased state of the polygon (either aliased or anti-aliased) does not alter the manner in which filled polygon setup is performed by setup . Line mode triangles are discussed in greater detail below.","5.2.2.2 Lines","Setup  converts lines into quadralaterals, or \u201cquads.\u201d FIG. D shows example of quadrilaterals generated for line segments.Note that the quadrilaterals are generated differently for aliased and anti-aliased lines. For aliased lines a quadrilateral's vertices also depend on whether the line is x-major or y-major. Setup  does not modify the incoming line widths. (See, primitive packet , table 6). Quadrilateral generation is discussed in greater detail below in reference to the quadrilateral generation functional unit.","In a preferred embodiment of the present invention, a line's width is determined prior to setup . For example, it can be determined on a 3-D graphics processing application executing on computer  (see FIG. D).","5.2.2.3 Points","Pipeline  renders anti-aliased points as circles and aliased points as squares. Both circles and squares have a width. In a preferred embodiment of the present invention, the determination of a point's size and position are determined in a previous processing stage of pipeline , for example, geometry .","5.3 Unified Primitive Description","Under the rubric of a unified primitive, we consider a line primitive to be a rectangle and a triangle to be a degenerate rectangle, and each is represented mathematically as such. In other words, setup  describes each primitive with a set of four vertices. Note that not all vertex values are needed to describe all primitives. A line segment is treated as a parallelogram, so setup  uses all four vertices. To describe a triangle, setup  uses a triangle's top vertex, bottom vertex, and either left corner vertex or right corner vertex, depending on the triangle's orientation.","For example, referring to FIG. D, where there is shown an example of vertex assignments according to the unified primitive description of the present invention. (FIG. D correlates with FIG. 47 in U.S. Provisional Patent Application Ser. No. 60\/097,336) Triangle  is described by setup  using the triangle's  top vertex (X-Top , Y-Top ), bottom vertex (X-Bottom , Y-Bottom ), and right corner vertex (X-Right drive , Y-Right ). Triangle  is described by setup  using the triangle's  top vertex (X-Top , Y-Top ), bottom vertex (X-Bottom , Y-Bottom ,), and left corner vertex (X-Left , Y-Left ).","For purposes of simplifying the disclosure, the following naming convention is adopted: (a) \u201cVT\u201d represents (X-TOP,Y-TOP); (b) \u201cVM\u201d represents (X-MIDDLE, Y-MIDDLE) where X-MIDDLE is either X-RIGHT or X-LEFT, depending on the orientation of the triangle (discussed in greater detail above), and Y-MIDDLE is either Y-RIGHT or Y-LEFT, depending on the orientation of the triangle; and, (c) \u201cVB\u201d represents (X-BOTTOM,Y-BOTTOM).","For purposes of illustrating this convention, the vertices of triangle  are mapped to this convention. In this example, VT represents (X-TOP ,Y-TOP ); \u201cVM\u201d represents (X-RIGHT , Y-RIGHT ) (VtxLeftC in this example is degenerate); and, \u201cVB\u201d represents (X-BOTTOM , Y-BOTTOM ).","A line segment, is treated as a parallelogram, so setup  uses all four vertices to describe a line segment. Note also that while a triangle's vertices are the same as its original vertices, setup  generates new vertices to represent a line segment as a parallelogram.","The unified representation of primitives uses two sets of descriptors to represent a primitive. The first set includes vertex descriptors, each of which are assigned to the original set of vertices in window coordinates. Vertex descriptors include, VtxYMin, VtxYmax, VtxXmin and VtxXmax. The second set of descriptors are flag descriptors, or corner flags, used by setup  to indicate which vertex descriptors have valid and meaningful values. Flag descriptors include, VtxLeftC, VtxRightC, LeftCorner, RightCorner, VtxTopC, VtxBotC, TopCorner, and BottomCorner. FIG. D illustrates aspects of unified primitive descriptor assignments, including corner flags.","All of these descriptors have valid values for quadrilateral primitives, but all of them may not be valid for triangles. Treating triangles as rectangles according to the teachings of the present invention, involves specifying four vertices, one of which (typically y-left or y-right in one particular embodiment) is degenerate and not specified. To illustrate this, refer to FIG. D, and triangle , where a left corner vertex is degenerate, or not defined. With respect to triangle , a right corner vertex is degenerate. Using primitive descriptors according to the teachings of the present invention to describe triangles and line segments as rectangles provides a nice, uniform way to setup primitives, because the same (or similar) algorithms\/equations\/calculations\/hardware can be used to operate on different primitives, thus allowing an efficient implementation. We now describe the primitive descriptors and how they are used.","We will now described how VtxYmin, VtxYmax, VtxLeftC, VtxRightC, LeftCorner, RightCorner descriptors are obtained. For line segments these descriptors are assigned when the line quad vertices are generated. However, for triangles, setup  sorts the triangle's vertices according to their y coordinates. VtxYmin is the vertex with the minimum y value. VtxYmax is the vertex with the maximum y value. VtxLeftC is the vertex that lies to the left of the edge of the triangle formed by joining the vertices VtxYmin and VtxYmax (hereinafter, also referred to as the \u201clong y-edge\u201d) in the case of a triangle, and to the left of the diagonal formed by joining the vertices VtxYmin and VtxYmax for parallelograms.","If the triangle is such that the long y-edge is also the left edge, then the flag LeftCorner is FALSE (\u201c0\u201d) indicating that the VtxLeftC is degenerate, or not defined. VtxRightC is the vertex that lies to the right of the long y-edge in the case of a triangle, and to the right of the diagonal formed by joining the vertices VtxYmin and VtxYmax for parallelograms. If the triangle is such that the long edge is also the right edge, then the flag RightCorner is FALSE (\u201c0\u201d) indicating that the VtxRightC is degenerate, or not defined. A triangle, has exactly two edges that share a top most vertex (VtxYmax). Of these two edges, the one edge with an end point furthest left is the left edge. Analogous to this, the one edge with an end point furthest to the right is the right edge.","Note that in practice VtxYmin, VtxYmax, VtxLeftC, and VtxRightC are indices into the original primitive vertices. Setup  uses VtxYMin, VtxYmax, VtxLeftC, VtxRightC, LeftCorner, and RightCorner to clip a primitive with respect to the top and bottom edges of the tile.","We now describe how VtxXmin, VtxXmax, VtxTopC, VtxBotC, TopCorner, BottomCorner descriptors are obtained. For line segments these descriptors are assigned when the line quad vertices are generated. VtxXmin is the vertex with the minimum x value. VtxXmax is the vertex with the maximum x value. VtxTopC is the vertex that lies above the edge joining vertices VtxXmin and VtxXmax (hereinafter, this edge is often referred to as the \u201clong x-edge\u201d) in the case of a triangle, and above the diagonal formed by joining the vertices VtxXmin and VtxXmax for parallelograms.","If the triangle is such that the long x-edge is also the \u201ctop edge,\u201d then the flag TopCorner is FALSE (\u201c0\u201d) indicating that the VtxTopC is not defined. Similarly, VtxBotC is the vertex that lies below the long x-axis in the case of a triangle, and below the diagonal formed by joining the vertices VtxXmin and VtxXmax for parallelograms. The top edge is a triangle has to edges that share the maximum x-vertex (VtxXmax). The topmost of these two edges is the \u201ctop edge.\u201d analogous to disk, the bottom most of these two edges is the \u201cbottom edge.\u201d","If the triangle is such that the long x-edge is also the \u201cbottom edge,\u201d then the flag BottomCorner is FALSE (\u201c0\u201d) indicating that the VtxBotC is not defined. Referring to FIG. D, there is shown aspects of mapping long x-edge, long y-edge, top edge, bottom edge, right edge, and left edge.","Note, that in practice VtxXmin, VtxXmax, VtxTopC, and VtxBotC are indices into the original triangle primitive. Setup  uses VtxXmin, VtxXmax, VtxTopC, VtxBotC, TopCorner, and BottomCorner to clip a primitive with respect to the left and right edges of a tile. Clipping will be described in greater detail below.","To illustrate the use of the unified primitive descriptors of the present invention, refer to , where there is shown an illustration of multiple triangles and line segments described using vertex descriptors and flag descriptors according to a preferred embodiment of the unified primitive description of the present invention.","5.4 High Level Functional Unit Architecture","Setup's  I\/O subsytem architecture is designed around the need to process primitive and mode information received from sort  (see FIG. D) in a manner that is optimal for processing by cull  (see FIG. D). Such primitives include, filled triangles, line triangles, anti-aliased solid lines, aliased solid lines, stippled lines, and aliased and anti-aliased points.","To accomplish this task, setup  performs a number of procedures to prepare information about a primitive with respect to a corresponding tile for cull . As illustrated in , an examination of these procedures yields the following functional units which implement the corresponding procedures of the present invention: (a) triangle preprocessor , for generating unified primitive descriptors, calculating line slopes and reciprocal slopes of the three edges, and determining if a triangle has a left or right corner; (b) line preprocessor , for determining the orientation of a line, calculating the slope of the line and the reciprocal, identifying left and right slopes and reciprocal slopes, and discarding end-on lines; (c) point preprocessor , for calculating a set of spatial information required by a subsequent culling stage of pipeline ; (d) trigonometric unit , for calculating the half widths of a line, and trigonometric unit for processing anti-aliased lines by increasing a specified width to improved image quality; (d) quadrilateral generation unit , for converting lines into quadrilaterals centered around the line, and for converting aliased points into a square of appropriate width; (d) clipping unit , for clipping a primitive (triangle or quadrilateral) to a file, and for generating the vertices of the new clipped polygon; (e) bounding box unit , for determining the smallest box that will enclose the new clipped polygon; (e depth gradient and depth offset unit , for calculating depth gradients (dz\/dx & dz\/dy) of lines or triangles\u2014for triangles, for also determining the depth offset; and, (g) Zmin and Zref unit , for determining miimum depth values by selecting a vertex with the smallest Z value, and for calculating a stamp center closest to the Zmin location.","In a preferred embodiment of the present invention triangle preprocessor unit and line preprocessor unit are the same unit.","In one embodiment of the present invention, input buffer  comprises a queue and a holding buffer. In a preferred embodiment of the present invention, the queue is approximately 32 entries deep by approximately 140 bytes wide. Input data packets from a subsequent process in pipeline , for example, sort , requiring more bits then the queue is widewill be split into two groups and occupy two entries in the queue. The queue is used to balance the different data rates between sort  (see FIG. D) and setup . The present invention contemplates that sort  and setup  cooperate if input queue  reaches capacity. The holding buffer holds vertex information read from a triangle primitive embrace the triangle into the visible edges for line mode triangles.","Output buffer  is used by setup  to queue image data processed by setup  for delivery to a subsequent stage of pipeline , for example, cull .","FIG. D also illustrates the data flow between the functional units that implement the procedures of the present invention.","The following subsections detail the architecture of each of these functional units.","5.4.1 Triangle Preprocessing","For triangles, Setup starts with a set of vertices, (x, y, z), and (x, y, z), (x, y, z). Setup  assumes that the vertices of a filled triangle fall within a valid range of window coordinates, that is to say, that a triangle's coordinates have been clipped to the boundaries of the window. This procedure can be performed by a previous processing stage of pipeline , for example, geometry  (see FIG. D).","The triangle preprocessor: (1) sorts the three vertices in the y direction, to determine the top-most vertex (VtxYmax), middle vertex (either, VtxRightC or VtxLeftC), and bottom-most vertex (VtxYmin); (2) calculates the slopes and reciprocal slopes of the triangles three edges; (3) determines if the y-sorted triangle has a left corner (LeftCorner) or a right corner (RightCorner); (5) sorts the three vertices in the x-direction, to determine the right-most vertex (VtxXmax), middle vertex, and left-most vertex (VtxXmin); and, (6) identifies the slopes that correspond to x-sorted Top (VtxTopC), Bottom (VtxBotC), or Left.","5.4.1.1 Sort with Respect to the Y Axis","The present invention sorts the filled triangles vertices in the y-direction using, for example, the following three equations.\n\n=()|((10) & (10))\n\n=()|((21) & (21))\n\n=()|((02) & (02))\n","With respect to the immediately above three equations: (a) \u201cGe\u201d represents a greater than or equal to relationship; (b) the \u201c|\u201d symbol represents a logical \u201cor\u201d; and, (c) the \u201c&\u201d symbol represents a logical \u201cand.\u201d","YGeY, YGeY, and YGeY are Boolean values.","The time ordered vertices are V, V, and V, where V is the oldest vertex, and V is the nose vertex. Pointers are used by setup  to identify which time-ordered vertex corresponds to which Y-sorted vertex, including, top (VtxYmax), middle (VtxLeftC or VtxRightC), and bottom (VtxYmin). For example,\n\nYsortTopSrc={YGeY& !YGeY, YGeY& !YGeY, !YGeY& YGeY}\n\nYsortTopSrc={YGeY\u212b!YGeY, YGeY\u2295!YGeY, !YGeY\u2295YGeY}\n\nYsortTopSrc={!YGeY& YGeY, !YGeY& YGeY, YGeY&!YGeY}\n","YsortTopSrc represents three bit encoding to identify which of the time ordered vertices is VtxYmax. YsortMidSrc represents three bit encoding to identify which of the time ordered vertices is VtxYmid. YsortBotSrc represents three bit encoding to identify which of the time ordered vertices is VtxYmin.","Next, pointers to identify the destination of time ordered data to y-sorted order are calculated. This is done because these pointers are needed to map information back and forth from y-sorted to time ordered, time ordered to y-sorted, and the like. Analogous equations are used to identify the destination of time ordered data to x-sorted order.\n\nYsort0dest={!YGeY& YGeY, !YGeY\u2295YGeY, YGeY& !YGeY}\n\nYsort1dest={YGeY& !YGeY, YGeY\u2295!YGeY, !YGeY& YGeY}\n\nYsort2dest={YGeY& !YGeY, YGeY\u2295!YGeY, !YGeY& YGeY}\n","The symbol \u201c!\u201d represents a logical \u201cnot.\u201d Ysortdest represents a pointer that identifies that V corresponds to which y-sorted vertex.Ysort dest represents a pointer that identifies that V corresponds to which y-sorted vertex. Ysortdest represents a pointer that identifies that V corresponds to which y-sorted vertex.","Call the de-referenced sorted vertices: V=(X, Y, Z), V=(X, Y, Z), and V=(X, Y, Z), where Vhas the largest Y and Vhas the smallest Y. The word de-referencing is used to emphasize that pointers are kept. Vis VtxYmax, Vis VtxYmin, and Vis VtxYmid.","Reciprocal slopes (described in greater detail below) need to be mapped to labels corresponding to the y-sorted order, because V, V and V part-time ordered vertices. S, S, and S are slopes of edges respectively between: (a) V and V; (b) V and V; and, (c) V and V. So after sorting the vertices with respect to y, we will have slopes between Vand V, Vand V, and Vabd V. In light of this, pointers are determined accordingly.","A preferred embodiment of the present invention maps the reciprocal slopes to the following labels: (a) YsortSTMSrc represents STM (Vand V) corresponds to which time ordered slope; (b) YsortSTBSrc represents STB (Vand V) corresponds to which time ordered slope; and, (c) YsortSMBSrc represents SMB (Vand V) corresponds to which time ordered slope.\n\n",{"@attributes":{"id":"p-1018","num":"1022"},"tables":{"@attributes":{"id":"TABLE-US-00016","num":"00016"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"YsortSTMSrc = {\u2003\u2003\u2003!Ysort1dest[0] & !Ysort2dest[0],"]},{"entry":[{},"\u2003\u2003!Ysort0dest[0] & !Ysort1dest[0],"]},{"entry":[{},"\u2003\u2003!Ysort2dest[0] & !Ysort0dest[0] }"]},{"entry":[{},"YsortSTBSrc = {\u2003\u2003\u2003!Ysort1dest[1] & !Ysort2dest[1],"]},{"entry":[{},"\u2003\u2003!Ysort0dest[1] & !Ysort1dest[1],"]},{"entry":[{},"\u2003\u2003!Ysort2dest[1] & !Ysort0dest[1] }"]},{"entry":[{},"YsortSMBSrc = {\u2003\u2003\u2003!Ysort1dest[2] & !Ysort2dest[2],"]},{"entry":[{},"\u2003\u2003!Ysort0dest[2] & !Ysort1dest[2],"]},{"entry":[{},"\u2003\u2003!Ysort2dest[2] & !Ysort0dest[2] }"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The indices refer to which bit is being referenced.","Whether the middle vertex is on the left or the right is determined by comparing the slopes dx\/dy of line formed by vertices v[i] and v[i], and dx\/dy of the line formed by vertices v[i] and v[i]. If (dx\/dy>dx\/dy) then the middle vertex is to the right of the long edge else it is to the left of the long edge. The computed values are then assigned to the primitive descriptors. Assigning the x descriptors is similar. We thus have the edge slopes and vertex descriptors we need for the processing of triangles.","5.4.1.2 Slope Determination","The indices sorted in ascending y-order are used to compute a set of (dx\/dy) derivatives. And the indices sorted in ascending x-order used to compute the (dy\/dx) derivatives for the edges. The steps are (1) calculate time ordered slopes S, S, and, S; (2) map to y-sorted slope STM, SMB, and STB; and, (3) do a slope comparison to map slopes to SLEFT, SRIGHT, and SBOTTOM.","The slopes are calculated for the vertices in time order. That is, (X, Y) represents the first vertex, or \u201cV\u201d received by setup , (X, Y) represents the second vertex, or \u201cV\u201d received by setup , and (X, Y) represents the third vertex, or V received by setup .",{"@attributes":{"id":"p-1023","num":"1027"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mi":"S","mn":"01"},"mo":"=","mrow":{"msub":{"mrow":{"mo":["[","]"],"mfrac":{"mrow":[{"mo":"\u2146","mi":"y"},{"mo":"\u2146","mi":"x"}]}},"mn":"01"},"mo":"=","mfrac":{"mrow":[{"msub":[{"mi":"y","mn":"1"},{"mi":"y","mn":"0"}],"mo":"-"},{"msub":[{"mi":"x","mn":"1"},{"mi":"x","mn":"0"}],"mo":"-"}]}}}},{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mi":["Slope","between","V","and","V"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":["1","0."]}},"mo":"."}}]},{"mtd":[{"mrow":{"msub":{"mi":"S","mn":"12"},"mo":"=","mrow":{"msub":{"mrow":{"mo":["[","]"],"mfrac":{"mrow":[{"mo":"\u2146","mi":"y"},{"mo":"\u2146","mi":"x"}]}},"mn":"12"},"mo":"=","mfrac":{"mrow":[{"msub":[{"mi":"y","mn":"2"},{"mi":"y","mn":"1"}],"mo":"-"},{"msub":[{"mi":"x","mn":"2"},{"mi":"x","mn":"1"}],"mo":"-"}]}}}},{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mi":["Slope","between","V","and","V"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":["2","1."]}},"mo":"."}}]},{"mtd":[{"mrow":{"msub":{"mi":"S","mn":"20"},"mo":"=","mrow":{"msub":{"mrow":{"mo":["[","]"],"mfrac":{"mrow":[{"mo":"\u2146","mi":"y"},{"mo":"\u2146","mi":"x"}]}},"mn":"20"},"mo":"=","mfrac":{"mrow":[{"msub":[{"mi":"y","mn":"0"},{"mi":"y","mn":"2"}],"mo":"-"},{"msub":[{"mi":"x","mn":"0"},{"mi":"x","mn":"2"}],"mo":"-"}]}}}},{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mi":["Slope","between","V","and","V"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":["0","2."]}},"mo":"."}}]}]}}}},"In other processing stages  in pipeline , the reciprocals of the slopes are also required, to calculate intercept points in clipping unit  (see FIG. D). In light of this, the following equations are used by a preferred embodiment of the present invention, to calculate the reciprocals of slopes, S, S, and S:",{"@attributes":{"id":"p-1025","num":"1029"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"msub":{"mi":"SN","mn":"01"},"mo":"=","mrow":{"msub":{"mrow":{"mo":["[","]"],"mfrac":{"mrow":[{"mo":"\u2146","mi":"x"},{"mo":"\u2146","mi":"y"}]}},"mn":"01"},"mo":"=","mfrac":{"mrow":[{"msub":[{"mi":"x","mn":"1"},{"mi":"x","mn":"0"}],"mo":"-"},{"msub":[{"mi":"y","mn":"1"},{"mi":"y","mn":"0"}],"mo":"-"}]}}}},{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mi":["Reciprocal","slope","between","V","and","V"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":["1","0."]}},"mo":"."}}]},{"mtd":[{"mrow":{"msub":{"mi":"SN","mn":"12"},"mo":"=","mrow":{"msub":{"mrow":{"mo":["[","]"],"mfrac":{"mrow":[{"mo":"\u2146","mi":"x"},{"mo":"\u2146","mi":"y"}]}},"mn":"12"},"mo":"=","mfrac":{"mrow":[{"msub":[{"mi":"x","mn":"2"},{"mi":"x","mn":"1"}],"mo":"-"},{"msub":[{"mi":"y","mn":"2"},{"mi":"y","mn":"1"}],"mo":"-"}]}}}},{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mi":["Reciprocal","slope","between","V","and","V"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":["2","1."]}},"mo":"."}}]},{"mtd":[{"mrow":{"msub":{"mi":"SN","mn":"01"},"mo":"=","mrow":{"msub":{"mrow":{"mo":["[","]"],"mfrac":{"mrow":[{"mo":"\u2146","mi":"x"},{"mo":"\u2146","mi":"y"}]}},"mn":"01"},"mo":"=","mfrac":{"mrow":[{"msub":[{"mi":"x","mn":"1"},{"mi":"x","mn":"0"}],"mo":"-"},{"msub":[{"mi":"y","mn":"1"},{"mi":"y","mn":"0"}],"mo":"-"}]}}}},{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mi":["Reciprocal","slope","between","V","and","V"],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":["0","2."]}},"mo":"."}}]}]}}}},"Referring to FIG. D, there are shown examples of triangle slope assignments. A left slope is defined as slope of dy\/dx where \u201cleft edge\u201d is defined earlier. A right slope is defined as slope of dy\/dx where \u201cright edge\u201d is defined earlier. A bottom slope is defined as the slope of dy\/dx where the y-sorted \u201cbottom edge\u201d is defined earlier. (There is also an x-sorted bottom edge.)","5.4.1.3 Determine Y-sorted Left Corner or Right Corner","Call the de-referenced reciprocal slopes SNTM (reciprocal slope between VT and VM), SNTB (reciprocal slope between VT and VB) and SNMB (reciprocal slope between VM and VB). These de-referenced reciprocal slopes are significant because they represent the y-sorted slopes. That is to say that they identify slopes between y-sorted vertices.","Referring to FIG. D, there is shown yet another illustration of slope assignments according to one embodiment of the present invention for triangles and line segments. We will now describe a slope naming convention for purposes of simplifying this detailed description.","For example, consider slope \u201cSIStrtEnd,\u201d \u201cSl\u201d is for slope, \u201cStrt\u201d is first vertex identifier and \u201cEnd\u201d is the second vertex identifier of the edge. Thus, SlYmaxLeft represents the slope of the left edge\u2014connecting the VtxYMax and VtxLeftC. If leftC is not valid then, SlYmaxLeft is the slope of the long edge. The letter r in front indicates that the slope is reciprocal. A reciprocal slope represents (y\/x) instead of (x\/y).","Therefore, in this embodiment, the slopes are represented as {SlYmaxLeft, SlYmaxRight, SlLeftYmin, SlRightYmin} and the inverse of slopes (y\/x) {rSlXminTop, rSlXminBot, rSlTopXmax, rSlBotXmax}.","In a preferred embodiment of the present invention, setup  compares the reciprocal slopes to determine the LeftC or RightC of a triangle. For example, if YsortSNTM is greater than or equal to YsortSNTB, then the triangle has a left corner, or \u201cLeftC\u201d and the following assignments can be made: (a) set LeftC equal to true (\u201c1\u201d); (b) set RightC equal to false (\u201c0\u201d); (c) set YsortSNLSrc equal to YsortSNTMSrc (identify pointer for left slope); (d) set YsortSNRSrc equal to YsortSNTBSrc (identify pointer for right slope); and, (e) set YsortSNBSrc equal to YsortSNMBSrc (identify pointer bottom slope).","However, if YsortSNTM is less than YsortSNTB, then the triangle has a right corner, or \u201cRightC\u201d and the following assignments can be made: (a) set LeftC equal to false (\u201c0\u201d); (b) RightC equal to true (\u201c1\u201d); (c) YsortSNLSrc equal to YsortSNTBSrc (identify pointer for left slope); (d) sortSNRSrc equal to YsortSNTMSrc (identify pointer for right slope); and, (e) set YsortSNBSrc equal to YsortSNMBSrc (identify pointer bottom slope).","5.4.1.4 Sort Coordinates with Respect to the X Axis","The calculations for sorting a triangle's vertices with respect to \u201cy\u201d also need to be repeated for the triangles vertices with respect to \u201cx,\u201d because an algorithm used in the clipping unit  (see FIG. D) needs to know the sorted order of the vertices in the x direction. The procedure for sorting a triangle's vertices with respect to \u201cx\u201d is analogous to the procedure's used above for sorting a triangle's vertices with respect to \u201cy,\u201d with the exception, of course, that the vertices are sorted with respect to \u201cx,\u201d not \u201cy.\u201d however for purposes of completeness and out of an abundance of caution to provide an enabling disclosure the equations for sorting a triangles vertices with respect to \u201cx\u201d are provided below.","For the sort, do six comparisons, including, for example:\n\n=()|((10) & (10))\n\n=()|((21) & (21))\n\n=()|((X02) & (02))\n","The results of these comparisons are used to determine the sorted order of the vertices. Pointers are used to identify which time-ordered vertex corresponds to which Y-sorted vertex. In particular, pointers are used to identify the source (from the time-ordered (V, V and V) to X-sorted (\u201cdestination\u201d vertices VL, VR, and VM)).\n\nXsortRhtSrc={XGeX& !XGeX, XGeX& !XGeX, !XGeX& XGeX}\n\nXsortMidSrc={XGeX\u212b !XGeX, XGeX\u2295!XGeX, !XGeX\u2295XGeX}\n\nXsortLftSrc={!XGeX& XGeX, !XGeX& XGeX, XGeX& !XGeX}\n","Next, setup  identifies pointers to each destination (time-ordered to X-sorted).\n\nXsort0dest={!X1GeX0 & X0GeX2, !X1GeX0 X0GeX2, X1GeX0 & !X0GeX2}.\n\nXsort1dest={X1GeX0 & !X2GeX1, X1GeX0 !X2GeX1, !X1GeX0 & X2GeX1}.\n\nXsort2dest={X2GeX1 & !X0GeX2, X2GeX1 !X0GeX2, !X2GeX0 & X0GeX2}.\n","Call the de-referenced sorted vertices VR=(XR, YR, ZR), VL=(XL, YL, ZL), and VM=(XM, YM, ZM), where VR has the largest X and VL has the smallest X. Note that X sorted data has no ordering information available with respect to Y or Z. Note also, that X, Y, and Z are coordinates, \u201cR\u201d equals \u201cright,\u201d \u201cL\u201d=\u201cleft,\u201d and \u201cM\u201d equals \u201cmiddle.\u201d Context is important y-sorted VM is different from x-sorted VM.","The slopes calculated above, need to be mapped to labels corresponding to the x-sorted order, so that we can identify which slopes correspond to which x-sorted edges. To accomplish this, one monument of the present invention determines pointers to identify the source of the slopes (from time ordered to x-sorted). For example, consider the following equations:\n\nXsortSRMSrc={!Xsort1dest[0] & !Xsort2dest[0], !Xsort0dest[0] & !Xsort1dest[0], !Xsort2dest[0] & !Xsort0dest[0]};\n\nXsortSRLSrc={!Xsort1dest[1] & !Xsort2dest[1], !Xsort0dest[1] & !Xsort1dest[1], !Xsort2dest[1] & !Xsort0dest[1]}; and,\n\nXsortSMLSrc={!Xsort1dest[2] & !Xsort2dest[2], !Xsort0dest[2] & !Xsort1dest[2], !Xsort2dest[2] & !Xsort0dest[2]},\n\nwhere, XsortSRMSrc represents the source (V, V, and V) for SRM slope between VR and VM; XsortSRLSrc representsthe source for SRL slope, and XsortSMLSrc represents the source for SML slope.\n","Call the de-referenced slopes XsortSRM (slope between VR and VM), XsortSRL (slope between VR and VL) and XsortSML (slope between VM and VL).","5.4.1.5 Determine X Sorted Top Corner or Bottom Corner and Identify Slopes","Setup  compares the slopes to determine the bottom corner (BotC or BottomCorner) or top corner (TopC or TopCorner) of the x-sorted triangle. To illustrate this, consider the following example, where SRM represents the slope between x-sorted VR and VM, and SRL represents the slope coming x-sorted VR and VL. If SRM is greater than or equal to SRL, then the triangle has a BotC and the following assignments can be made: (a) set BotC equal to true (\u201c1\u201d); (b) set TopC equal to false (\u201c0\u201d); (c) set XsortSBSrc equal to XsortSRMSrc (identify x-sorted bot slope); (d) set XsortSTSrc equal to XsortSRLSrc (identify x-sorted top slope); and, (e) set XsortSLSrc equal to XsortSMLSrc (identify x-sorted left slope).","However, if SRM is less than SRL, then the triangle has a top corner (TopCorner or TopC) and the following assignments can be made: (a) set BotC equal to false; (b) set TopC equal to true; (c) set XsortSBSrc equal to XsortSRLSrc (identify x-sorted bot slope); (d) set XsortSTSrc equal to XsortSRMSrc (identify x-sorted top slope); and, (e) set XsortSLSrc equal to XsortSMLSrc (identify x-sorted left slope).","V, V, and V are time ordered vertices. S, S, and S are time ordered slopes. X-sorted VR, VL, and VM are x-sorted right, left and middle vertices. X-sorted SRL, SRM, and SLM are slopes between the x-sorted vertices. X-sorted ST, SB, and SL are x-sorted top, bottom, and left vertices. \u201cSource\u201d simply emphasizes that these are pointers to the data. BotC, if true means that there is a bottom corner, likewise for TopC and top corner.","5.4.2 Line Segment Preprocessing","The object of line preprocessing unit  (see FIG. D) is to: (1) determine orientation of the line segment (a line segment's orientation includes, for example, the following: (a) a determination of whether the line is X-major or Y-major; (b) a determination of whether the line segment is pointed right or left (Xcnt); and, (c) a determination of whether the line segment is pointing up or down (Ycnt).), this is beneficial because Xcnt and Ycnt represent the direction of the line, which is needed for processing stippled line segments; and (2) calculating the slope of the line and reciprocal slope, this is beneficial because the slopes are used to calculate the tile intersection pointed also passed to cull  (see FIG. D). We will now discuss how this sub unit of the present invention determines a line segment's orientation with respect to a corresponding tile of the 2-D window.","5.4.2.1 Line Orientation","Referring to FIG. D, there is shown an example of aspects of line orientation according to one embodiment of the present invention. We now discuss an exemplary procedure used by setup  for determining whether a line segment pointing to the right or pointing to the left.\n\n0110.\n","If DX is greater than zero, then setup  sets XCnt equal to \u201cup,\u201d meaning that the line segment is pointing to the right. In a preferred embodiment of the present invention, \u201cup\u201d is represented by a \u201c1,\u201d and down is represented by a \u201c0.\u201d Otherwise, if DX is less than or equal to zero, setup  sets XCnt equal to down, that is to say that the line segment is pointing down. DX is the difference between X and X.","Determine if the line pointing up or down?\n\n0110.\n\nIf DY01>0\n","Then Ycnt=up, that is to say that the line is pointing up.","Else Ycnt=dn, that is to say that the line is pointing down.","\/\/Determine Major=X or Y (Is line Xmajor or Ymajor?)\n\nIf |0101|\n","Then Major=X","Else Major=Y","5.4.2.2 Line Slopes","Calculation of line's slope is beneficial because both slopes and reciprocal slopes are used in calculating intercept points to a tile edge in clipping unit . The following equation is used by setup  to determine a line's slope.",{"@attributes":{"id":"p-1051","num":"1055"},"maths":{"@attributes":{"id":"MATH-US-00003","num":"00003"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":"S","mn":"01"},"mo":"=","mrow":{"msub":{"mrow":{"mo":["[","]"],"mfrac":{"mrow":[{"mo":"\u2146","mi":"y"},{"mo":"\u2146","mi":"x"}]}},"mn":"01"},"mo":"=","mfrac":{"mrow":[{"msub":[{"mi":"y","mn":"1"},{"mi":"y","mn":"0"}],"mo":"-"},{"msub":[{"mi":"x","mn":"1"},{"mi":"x","mn":"0"}],"mo":"-"}]}}}}}},"The following equation is used by setup  to determine a line's reciprocal slope.",{"@attributes":{"id":"p-1053","num":"1057"},"maths":{"@attributes":{"id":"MATH-US-00004","num":"00004"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":"SN","mn":"01"},"mo":"=","mrow":{"msub":{"mrow":{"mo":["[","]"],"mfrac":{"mrow":[{"mo":"\u2146","mi":"x"},{"mo":"\u2146","mi":"y"}]}},"mn":"01"},"mo":"=","mfrac":{"mrow":[{"msub":[{"mi":"x","mn":"1"},{"mi":"x","mn":"0"}],"mo":"-"},{"msub":[{"mi":"y","mn":"1"},{"mi":"y","mn":"0"}],"mo":"-"}]}}}}}},"FIG. D illustrates aspects of line segment slopes. Setup  now labels a line's slope according to the sign of the slope (S) and based on whether the line is aliased or not. For non-antialiased lines, setup  sets the slope of the ends of the lines to zero. (Infinite dx\/dy is discussed in greater detail below).","If Sis greater than or equal to 0: (a) the slope of the line's left edge (S) is set to equal S; (b) the reciprocal slope of the left edge (SN) is set to equal SN; (c) if the line is anti-aliased, setup  sets the slope of the line's right edge (S) to equal \u2212SN, and setup  sets the reciprocal slope of the right edge (SN) to equal \u2212S; (d) if the line is not antialiased, the slope of the lines right edge, and the reciprocal slope of right edge is set to equal zero (infinite dx\/dy); (e) LeftCorner, or LeftC is set to equal true (\u201c1\u201d); and, (f) RightCorner, or RightC is set to equal true.","However, if Sless than 0: (a) the slope of the line's right edge (S) is set to equal S; (b) the reciprocal slope of the right edge (SN) is set to equal \u2212SN; (c) if the line is anti-aliased, setup  sets the slope of the line's left edge (S) to equal \u2212SN, and setup  sets the reciprocal slope of the left edge (SN) to equal \u2212S; (d) if the line is not antialiased, the slope of the lines left edge, and the reciprocal slope of left edge is set to equal zero; (e) LeftCorner, or LeftC is set to equal true (\u201c1\u201d); and, (f) RightCorner, or RightC is set to equal true.","Note the commonality of data: (a) SR\/SNR; (b) SL\/SNR; (c) SB\/SNB (only for triangles); (d) LeftC\/RightC; and, (e) the like.","To discard end-on lines, or line that are viewed end-on and thus, are not visible, setup  determines whether (y\u2212y=0) and (x\u2212x=0), and if so, the line will be discarded.","5.4.2.3 Line Mode Triangles","For drawing the triangles in line mode, the Setup  unit receives edge flags in addition to window coordinates (x, y, z) for the three triangle vertices. Referring to table 6, there is shown edge flags (LineFlags) , having edge flags. These edge flags  tell setup  which edges are to be drawn. Setup  also receives a \u201cfactor\u201d (see table 6, factor (ApplyOffsetFactor) ) used in the computation of polygon offset. This factor is factor \u201cf\u201d and is used to offset the depth values in a primitive. Effectively, all depth values are to be offset by an amount equal to offset equals max [|Zx|,|Zy ] plus factor. Factor is supplied by user. Zx is equal to dx\/dz. Zy is equal to dy\/dz. The edges that are to be drawn are first offset by the polygon offset and then drawn as ribbons of width w (line attribute). These lines may also be stippled if stippling is enabled.","For each line polygon, setup : (1) computes the partial derivatives of z along x and y. (Note that these z gradients are for the triangle and are needed to compute the z offset for the triangle. These gradients do not need to be computed if >factor=is zero.); (2) computes the polygon offset, if polygon offset computation is enabled, and adds the offset to the z value at each of the three vertices; (3) traverses the edges in order. If the edge is visible, then draws the edge using line attributes such as the width and stipple (setup  processes one triangle edge at a time); (4) draw the line based on line attributes such as anti-aliased or aliased, stipple, width, and the like; and, (5) assign appropriate primitive code to the rectangle depending on which edge of the triangle it represents and send it to CUL. A \u201cpPrimitive code\u201d it is an encoding of the primitive type, for example, 01 equals a triangle, 10 equals a line, and 11 equals a point.","5.4.2.4 Stippled Line Processing","Given a line segment, stippled line processing utilizes \u201cstipple information,\u201d and line orientation information (see section 5.2.5.2.1 Line Orientation) to reduce unnecessary processing by setup  of quads that lie outside of the current tile's boundaries. In particular, stipple preprocessing breaks up a stippled line into multiple individual line segments. Stipple information includes, for example, a stipple pattern (LineStipplePattern)  (see table 6), stipple repeat factor (LineStippleRepeatFactor) r , stipple start bit (StartLineStippleBit and StartLineStippleBit), for example stipple start bit , and stipple repeat start (for example, StartStippleRepeatFactor)  (stplRepeatStart)).","In a preferred embodiment of pipeline , Geometry  is responsible for computing the stipple start bit , and stipple repeat start  offsets at the beginning of each line segment. We assume that quadrilateral vertex generation unit  (see FIG. D) has provided us with the half width displacements.","Stippled Line Preprocessing will break up a stippled line segment into multiple individual line segments, with line lengths corresponding to sequences of 1 bits in a stipple pattern, starting at stplStart bit with a further repeat factor start at stplRepeatStart for the first bit. To illustrate this, consider the following example. If the stplStart is 14, and stplRepeat is 5, and stplRepeatStart is 4, then we shall paint the 14th bit in the stipple pattern once, before moving on to the 15th, i.e. the last bit in the stipple pattern. If both bit  and th are set, and the 0th stipple bit is nor set, then the quad line segment will have a length of 6.","In a preferred embodiment of the present invention, depth gradients, line slopes, depth offsets, x-direction widths (xhw), and y-direction widths (yhw) are common to all stipple quads if a line segment, and therefore need to be generated only once.","Line segments are converted by Trigonometric Functions and Quadrilateral Generation Units, described in greater detail below (see sections 5.2.5.X and 5.2.5.X, respectively) into quadrolaterals, or \u201cquads.\u201d For antialiased lines the quads are rectangles. For non-antialiased lines the quads are parallelograms.","5.4.3 Point Preprocessing","Referring to FIG. D, there is shown an example of an unclipped circle  intersecting parts of a tile , for illustrating the various data to be determined.","CY represents circle's  topmost point, clipped by tile's  top edge, in tile coordinates. CY represents circle's  bottom most point, clipped by tile's  bottom edge, in tile coordinates. Y represents the distance between CY and CY, the bottom of the unclipped circle . X  represents the \u201cx\u201d coordinate of the center  of circle , in window coordinates. This information is required and used by cull  to determine which sample points are covered by the point.","This required information for points is obtained with the following calculations:\n\n=() (the center of the circle and the min);\n\n+width\/2;\n\n\u2212width\/2;\n\n\u2212bot (convert to tile coordinates);\n\n\u2212bot (convert to tile coordinates);\n\nToP=16 (check the msb);\n\nBot=0 (check the sign);\n\nif (ToP) then =tiletop, else ](in tile coordinates);\n\nif (Bot) then =tilebot, else ](in tile coordinates); and,\n\noffset.\n\n5.4.4 Trigonometric Functions Unit\n","As discussed above, setup  converts all lines, including line triangles and points, into quadrilaterals. To accomplish this, the trigonometric function unit calculates a x-direction half-width and a y-direction half-width for each line and point. (Quadrilateral generation for filled triangles is discussed in greater detail above in reference to triangle preprocessing). Their procedures for generating vertices for line in point quadrilaterals are discussed in greater detail below in reference to the quadrilateral generation unit  (see FIG. D).","Before the trigonometric function unit can determine a primitive half-width, it must first calculate the trigonometric functions tan \u03b8, cos \u03b8, sin \u03b8. In a preferred embodiment of the present invention, setup  determines the trigonometric functions cos \u03b8 and sin \u03b8 using the line's slope that was calculated in the line preprocessing functional unit described in great detail above. For example:",{"@attributes":{"id":"p-1071","num":"1075"},"maths":{"@attributes":{"id":"MATH-US-00005","num":"00005"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["tan","\u03b8"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mrow":[{"msub":{"mi":"S","mn":"10"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mi":["sin","\u03b8"]},{"mrow":[{"mrow":{"mo":"\u00b1","mfrac":{"mrow":{"mi":["tan","\u03b8"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},"msqrt":{"mrow":{"mn":"1","mo":"+","mrow":{"msup":{"mi":"tan","mn":"2"},"mo":"\u2062","mi":"\u03b8"}}}}},"mo":["\u2062","\u2062","\u2062"],"mi":["cos","\u03b8"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mo":"\u00b1","mfrac":{"mn":"1","msqrt":{"mrow":{"mn":"1","mo":"+","mrow":{"msup":{"mi":"tan","mn":"2"},"mo":"\u2062","mi":"\u03b8"}}}}}],"mo":"="}],"mo":"="}],"mo":"="}}}},"In yet another embodiment of the present invention the above discussed trigonometric functions are calculated using lookup table and iteration method, similar to rsqrt and other complex math functions. Rsqrt stands for the reciprocal square root.","Referring to FIG. D, there is shown an example of the relationship between the orientation of a line and the sign of the resulting cos \u03b8 and sin \u03b8. As is illustrated, the signs of the resulting cos \u03b8 and sin \u03b8 will depend on the orientation of the line.","We will now describe how setup  uses the above determined cos \u03b8 and sin \u03b8 to calculate a primitive's \u201cx\u201d direction half-width (\u201cHWX\u201d) and a primitive's \u201cy\u201d direction half width (\u201cHWY\u201d). For each line, the line's half width is offset distance in the x and y directions from the center of the line to what will be a quadrilateral's edges. For each point, the half width is equal to one-half of the point's width. These half-width's are magnitudes, meaning that the x-direction half-widths and the y-direction half-width's are always positive.","For purposes of illustration, refer to FIG. D, where there is shown three lines, an antialiased line , a non-aliased x-major line , and a non-aliased y-major line , and their respective associated quadrilaterals, , , and . Each quadrilateral ,  and  has a width (\u201cW\u201d), for example, W , W, and W . In a preferred embodiment of the present invention, this width \u201cW\u201d is contained in a primitive packet  (see table 6). (Also, refer to FIG. D, where there are shown examples of x-major and -major aliased lines in comparison to an anti-aliased line.).","To determine an anti-aliased line's half width, setup  uses the following equations:",{"@attributes":{"id":"p-1077","num":"1081"},"maths":[{"@attributes":{"id":"MATH-US-00006","num":"00006"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"HWX","mo":"=","mrow":{"mfrac":{"mi":"W","mn":"2"},"mo":"\u2062","mrow":{"mo":["\uf603","\uf604"],"mrow":{"mi":["sin","\u03b8"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}}}}},{"@attributes":{"id":"MATH-US-00006-2","num":"00006.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"HWY","mo":"=","mrow":{"mfrac":{"mi":"W","mn":"2"},"mo":"\u2062","mrow":{"mo":["\uf603","\uf604"],"mrow":{"mi":["cos","\u03b8"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}}}}}]},"To determine the half width for an x-majori non-anti-aliased line, setup  uses the following equations:",{"@attributes":{"id":"p-1079","num":"1083"},"maths":[{"@attributes":{"id":"MATH-US-00007","num":"00007"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"HWX","mo":"=","mn":"0"}}},{"@attributes":{"id":"MATH-US-00007-2","num":"00007.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"HWY","mo":"=","mfrac":{"mi":"W","mn":"2"}}}}]},"To determine the half width for a y-major, non-anti-aliased line, setup  uses the following equations:",{"@attributes":{"id":"p-1081","num":"1085"},"maths":[{"@attributes":{"id":"MATH-US-00008","num":"00008"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"HWX","mo":"=","mfrac":{"mi":"W","mn":"2"}}}},{"@attributes":{"id":"MATH-US-00008-2","num":"00008.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"HWY","mo":"=","mn":"0"}}}]},"To determine the half-width for a point, setup  uses the following equations:",{"@attributes":{"id":"p-1083","num":"1087"},"maths":[{"@attributes":{"id":"MATH-US-00009","num":"00009"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"HWX","mo":"=","mfrac":{"mi":"W","mn":"2"}}}},{"@attributes":{"id":"MATH-US-00009-2","num":"00009.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"HWY","mo":"=","mfrac":{"mi":"W","mn":"2"}}}}],"br":{}},"The quadrilateral generation functional unit  (see FIG. D): (1) generates a quadrilateral centered around a line or a point; and, (2) sorts a set of vertices for the quadrilateral with respect to a quadrilateral's top vertex, bottom vertex, left vertex, and right vertex. With respect to quadrilaterals, quadrilateral generation functional unit () converts anti-aliased lines into rectangles; (b) converts non-anti-aliased lines into parallelograms; and, (c) converts aliased points into squares centered around the point. (For filled triangles, the vertices are just passed through to the next functional unit, for example, clipping functional unit  (see FIG. D)). We now discuss an embodiment of a procedure that quadrilateral generation functional unit  takes to generate a quadrilateral for a primitive.","With respect to line segments, a quadrilateral's vertices are generated by taking into consideration: (a) a line segments original vertices (a primitive's original vertices are sent to setup  in a primitive packet , see table 6, WindowX , WindowY , WindowZ , WindowX , WindowY , WindowZ , WindowX , WindowY , and, WindowZ ); (b) a line segment's orientation (line orientation is determined and discussed in greater detail above in section 5.2.5.2.1); and, (c) a line segment's x-direction half-width and y-direction half-width (half-widths are calculated and discussed in greater detail above in section 5.2.5.4). In particular, a quadrilateral vertices are generated by adding, or subtracting, a line segment's half-widths to the line segment's original vertices.","If a line segment is pointing to the right (Xcnt>0) and the line segment is pointing up (Yxnt>0) then setup  performs the following set of equations to determine a set of vertices defining a quadrilateral centered on the line segment:",{"@attributes":{"id":"p-1087","num":"1091"},"maths":{"@attributes":{"id":"MATH-US-00010","num":"00010"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mtable":[{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"QY","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"-","mi":"HWY"}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":"QY","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"+","mi":"HWY"}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":"QY","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"-","mi":"HWY"}],"mo":"="}}},{"mtd":{"mrow":{"mrow":{"mrow":[{"mi":"QY","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"3"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"+","mi":"HWY"}],"mo":"="},"mo":","}}}]},{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"QX","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"+","mi":"HWX"}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":"QX","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"-","mi":"HWX"}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":"QX","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"+","mi":"HWX"}],"mo":"="}}},{"mtd":{"mrow":{"mrow":{"mrow":[{"mi":"QX","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"3"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"-","mi":"HWX"}],"mo":"="},"mo":","}}}]}],"mo":["\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mtext":":"},{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mi":["and","where","QV"],"mn":"0"},{"mi":"VQV","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}],"mo":[",",","]}}},"br":{},"b":["1","2","3"]},"To illustrate this please refer to FIG. D, illustrating aspects of pre-sorted vertex assignments for quadrilaterals according to an embodiment of the present invention. In particular, quadrilateral  delineates a line segment that points right and up, having vertices QV , QV , QV , and QV .","If a line segment is pointing to the left (Xcnt<0) and the line segment is pointing up, then setup  performs the following set of equations to determine set of vertices defining a quadrilateral centered on the line segment:",{"@attributes":{"id":"p-1090","num":"1094"},"maths":[{"@attributes":{"id":"MATH-US-00011","num":"00011"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","Y"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"0"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"+","mi":"HWY"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00011-2","num":"00011.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","Y"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"1"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"-","mi":"HWY"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00011-3","num":"00011.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","Y"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"2"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"+","mi":"HWY"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00011-4","num":"00011.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":["Q","Y"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"3"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"-","mi":"HWY"}],"mo":"="},"mo":",","mi":"and"}}},{"@attributes":{"id":"MATH-US-00011-5","num":"00011.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","X"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"0"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"-","mi":"HWX"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00011-6","num":"00011.6"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","X"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"1"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"+","mi":"HWX"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00011-7","num":"00011.7"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","X"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"2"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"-","mi":"HWX"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00011-8","num":"00011.8"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","X"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"3"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"+","mi":"HWX"}],"mo":"="}}}]},"To illustrate this, consider that quadrilateral  delineates a line segment that points left and up, having vertices QV , QV , QV , and QV .","If a line segment is pointing to the left (Xcnt<0) and the line segment is pointing down (Ycnt<0), then setup  performs the following set of equations to determine a set of vertices defining a quadrilateral centered on the line segment:",{"@attributes":{"id":"p-1093","num":"1097"},"maths":[{"@attributes":{"id":"MATH-US-00012","num":"00012"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","Y"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"0"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"+","mi":"HWY"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00012-2","num":"00012.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","Y"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"1"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"-","mi":"HWY"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00012-3","num":"00012.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","Y"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"2"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"+","mi":"HWY"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00012-4","num":"00012.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":["Q","Y"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"3"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"-","mi":"HWY"}],"mo":"="},"mo":",","mi":"and"}}},{"@attributes":{"id":"MATH-US-00012-5","num":"00012.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","X"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"0"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"+","mi":"HWX"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00012-6","num":"00012.6"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","X"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"1"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"-","mi":"HWX"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00012-7","num":"00012.7"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","X"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"2"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"+","mi":"HWX"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00012-8","num":"00012.8"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","X"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"3"},{"mrow":[{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"HWX","mo":"."}],"mo":"-"}],"mo":"="}}}]},"To illustrate this, consider that quadrilateral  delineates a line segment that points left and down, having vertices QV , QV, QV , and QV .","If a line segment is pointing right and the line segment is pointing down, then setup  performs the following set of equations to determine a set of vertices defining a quadrilateral centered on the line segment:",{"@attributes":{"id":"p-1096","num":"1100"},"maths":[{"@attributes":{"id":"MATH-US-00013","num":"00013"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","Y"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"0"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"-","mi":"HWY"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00013-2","num":"00013.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","Y"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"1"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"+","mi":"HWY"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00013-3","num":"00013.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","Y"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"2"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"-","mi":"HWY"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00013-4","num":"00013.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":["Q","Y"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"3"},{"mrow":{"mi":"Y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"+","mi":"HWY"}],"mo":"="},"mo":",","mi":"and"}}},{"@attributes":{"id":"MATH-US-00013-5","num":"00013.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","X"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"0"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"-","mi":"HWX"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00013-6","num":"00013.6"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","X"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"1"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},"mo":"+","mi":"HWX"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00013-7","num":"00013.7"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","X"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"2"},{"mrow":{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},"mo":"-","mi":"HWX"}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00013-8","num":"00013.8"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":["Q","X"],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}],"mn":"3"},{"mrow":[{"mi":"X","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"HWX","mo":"."}],"mo":"+"}],"mo":"="}}}]},"To illustrate this, consider that quadrilateral  delineates a line segment that points right and down, having vertices QV , QV , QV , and QV .","In a preferred embodiment of the present invention, a vertical line segment is treated as the line segment is pointing to the left and top. A horizontal line segment is treated as if it is pointing right and up. A point is treated as a special case, meaning that it is treated as if it were a vertical line segment.","These vertices, QX, QX, QX, QX, QY, QY, QY, AND QY, for each quadrilateral are now reassigned to top (QXT, QYT, QZT), bottom (QXB, QYB, QZB), left (QXL, QYL, QZL), and right vertices (QXR, QYR, QZR) by quadrilateral generation functional unit  to give the quadrilateral the proper orientation to sort their vertices so as to identify the top list, bottom, left, and right most vertices, where the Z-coordinate of each vertex is the original Z-coordinate of the primitive.","To accomplish this goal, quadrilateral generation functional unit xxx uses the following logic. If a line segment is pointing up, then the top and bottom vertices are assigned according to the following equations: (a) vertices (QXT, QYT, QZT) are set to respectively equal (QX, QY, Z); and, (b) vertices (QXB, QYB, QZB) are set to respectively equal (QX, QY, Z). If a line segment is pointing down, then the top and bottom vertices are assigned according to the following equations: (a) vertices (QXT, QYT, QZT) are set to respectively equal (QX, QY, Z); and, (b) vertices (QXB, QYB, QZB) are set to respectively equal (QX, QY, Z).","If a line segment is pointing right, then the left and right vertices are assigned according to the following equations: (a) vertices (QXL, QYL, QZL) are set to respectively equal (QX, QY, Z); and, vertices (QXR, QYR, QZR) are set to respectively equal (QX, QY, Z). Finally, if a line segment is pointing love, the left and right vertices are assigned according to the following equations: (a) vertices (QXL, QYL, QZL) are set to respectively equal (QX, QY, Z); and, (b) vertices (QXR, QYR, QZR) are set to respectively equal (QX, QY, Z).","5.4.6 Clipping Unit","For purposes of the present invention, clipping a polygon to a tile can be defined as finding the area of intersection between a polygon and a tile. The clip points are the vertices of this area of intersection.","To find a tight bounding box that encloses parts of a primitive that intersect a particular tile, and to facilitate a subsequent determination of the primitive's minimum depth value (Zmin), clipping unit  (see FIG. D), for each edge of a tile: (1) selects a tile edge from a tile (each tile has four edges), to determine which, if any of a quadrilateral's edges, or three triangle edges, cross the tile edge; (b) checks a clip codes (discussed in greater detail below) with respect to the selected edge; (c) computes the two intersection points (if any) of a quad edge or a triangle edge with the selected tile edge; (d) compare computed intersection points to tile boundaries to determine validity and updates the clip points if appropriate.","The \u201ccurrent tile\u201d is the tile currently being set up for cull  by setup . As discussed in greater detail above, a previous stage of pipeline , for example, sort , sorts each primitive in a frame with respect to those regions, or tiles of a window (the window is divided into multiple tiles) that are touched by the primitive. These primitives were sent in a tile-by-tile order to setup . It can be appreciated, that with respect to clipping unit , setup  can select an edge in an arbitrary manner as long as each edge is eventually selected. For example, in one embodiment of clipping unit  can first select a tile's top edge, next the tile's right edge, next the tile's bottom edge, and finally the tiles left edge. In yet another embodiment of clipping unit , the tile edges may be selected in a different order.","Sort  (see FIG. D) provides setup  the x-coordinate for the current tile's left tile edge, and the y-coordinate for the bottom right tile edge via a primitive packet  (see ). These values are respectively labeled tile x and tile y. To identify a coordinate location for each edge of the current tile, clipping unit  sets the left edge of tile equal to tile x, which means that left tile edge x-coordinate is equal to tile x+0. The current tile's right edge is set to equal the tiles left edge plus the width of the tile. The current tile's bottom edges set to equal tile y, which means that this y-coordinate is equal to tile y+0. Finally, the tile's top edge is set to equal and the bottom tile edge plus the height of the tile in pixels.","In a preferred embodiment of the present invention, the width and height of a tile is 16 pixels. However, and yet other embodiments of the present invention, the dimensions of the tile can be any convenient size.","5.4.6.1 Clip Codes","Clip codes are used to determine which edges of a polygon (if any) that touches the current tile (A previous stage of pipeline  has sorted each primitive with respect to those tiles of a 2-D window that each respective primitive touches. In one embodiment of the present invention, clip codes are Boolean values, wherein \u201c0\u201d represents false and \u201c1\u201d represents true. A clip code value of false indicates that a primitive does not need to be clipped with respect to the edge of the current tile that that particular clip code represents. Whereas, a value of true indicates that a primitive does need to be clipped with respect to the edge of the current tile that that particular clip code represents.","To illustrate how one embodiment of the present invention determines clip codes for a primitive with respect to the current tile, consider the following pseudocode, wherein there is shown a procedure for determining clip codes. As noted above, the pseudocode used is, essentially, a computer language using universal computer language conventions. While the pseudocode employed here has been invented solely for the purposes of this description, it is designed to be easily understandable by any computer programmer skilled in the art.","In one embodiment of the present invention, clip codes are obtained as follows for each of a primitives vertices. C[i]=((v[i].y>til_ymax)<<3)\u2225((v[i].x<tile_xmin)<<2)\u2225((v[i].y<tile_ymin)<<1)\u2225(v[i].x>tile_xmax)), where, for each vertex of a primitive: (a) C[i] represents a respective clip code; (b) v[i].y represents a y vertex; (c) tile_max represents the maximum y-coordinate of the current tile; (d) v[i].x represents an x vertex of the primitive; (e) tile_xmin represents the minimum x-coordinate of the current tile; (f) tile_ymin represents the minimum y-coordinates of the current tile; and, (g) file_xmax represents the maximum x-coordinate of the current tile. In this manner, the boolean values corresponding to the clip codes are produced.","In yet another embodiment of the present invention, clip codes are obtained using the following set of equations: (1) in case of quads then use the following mapping, where \u201cQ\u201d represents a quadrilaterals respective coordinates, and TileRht, TileLft, TileTop and TileBot respectively represent the x-coordinate of a right tile edge, the x-coordinate of a left tile edge, the y-coordinate of a top tile edge, and the y-coordinate of a bottom tile edge.\n\n(00)=(Bot, Bot); (11)=(Lft, Lft);\n\n(22)=(Rht, Rht); (33)=(Top, Top);\n\n\/\/left ClpFlag3:0]={(3<=TileLft), ((2<=TileLft), (1<=TileLft), (0<=TileLft)}\n\n\/\/right ClpFlag3:0]={(3>=TileRht), ((2>=TileRht), (1>=TileRht), (0>=TileRht)}\n\n\/\/down ClpFlag3:0]={(3<=TileBot), ((2<=TileBot), (1<=TileBot), (0<=TileBot)}\n\n\/\/up ClpFlag3:0]={(3>=TileTop), ((2>=TileTop), (1>=TileTop), (0>=TileTop)}\n","(ClpFlag[] for triangles is don't care.). ClpFagL[] asserted means that vertex  is clipped by the left edge of the tile (the vertices have already been sorted by the quad generation unit , see FIG. D). ClpFlagR[] asserted means that vertex is clipped by right edge of tile, and the like. Here are \u201cclipped\u201d means that the vertex lies outside of the tile.","5.4.6.2 Clipping Points","After using the clip codes to determine that a primitive intersects the boundaries of the current tile, clipping unit  clips the primitive to the tile by determining the values of nine possible clipping points. A clipping point is a vertex of a new polygon formed by clipping (finding area of intersection) the initial polygon by the boundaries of the current tile. There are nine possible clipping points because there are eight distinct locations were a polygon might intersect a tile's edge. For triangles only, there is an internal clipping point which equals y-sorted VtxMid. Of these nine possible clipping points, at most, eight of them can be valid at any one time.","For purposes of simplifying the discussion of clipping points in this specification, the following acronyms are adopted to represent each respective clipping point: (1) clipping on the top tile edge yields left (PTL) and right (PTR) clip vertices; (b) clipping on the bottom tile edge is performed identically to that on the top tile edge. Bottom edge clipping yields the bottom left (PBL) and bottom right (PBR) clip vertices; (c) clipping vertices sorted with respect to the x-coordinate yields left high\/top (PLT) and left low\/bottom (PLB) vertices; (d) clipping vertices sorted with respect to the y-coordinate yields right high\/top (PRT) and right low\/bottom (PRB); and, (e) vertices that lie inside the tile are assigned to an internal clipping point (PI). Referring to , there is illustrated clipping points for two polygons, a rectangle  and a triangle  intersecting respective tiles  and .","5.4.6.3 Validation of Clipping Points","Clipping unit  (see FIG. D) now validates each of the computed clipping points, making sure that the coordinates of each clipping point are within the coordinate space of the current tile. For example, points that intersect the top tile edge may be such that they are both to the left of the tile. In this case, the intersection points are marked invalid.","In a preferred embodiment of the present invention, each clip point has an x-coordinate, a y-coordinate, and a one bit valid flag. Setting the flag to \u201c0\u201d indicates that the x-coordinate and the y-coordinate are not valid. If the intersection with the edge is such that one or both off a tile's edge corners (such corners were discussed in greater detail above in section are included in the intersection, then newly generated intersection points are valid.","A primitive is discarded if none of its dipping points are found to be valid.","The pseudo-code for an algorithm for determining clipping points according to one embodiment of the present invention, is illustrated below:","Notation Note: P=(X, Y), eg. PT=(XT, YT);","Line(P,P) means the line formed by endpoints P and P;\n\n",{"@attributes":{"id":"p-1120","num":"1127"},"tables":{"@attributes":{"id":"TABLE-US-00017","num":"00017"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"XsortClpFlagR[3:0] = LftC & RhtC ? ClpFlagR[3:0] :"},{"entry":"ClpFlagR[XsortMidSrc,XsortRhtSrc,XsortLftSrc,XsortMidSrc]"},{"entry":"XsortClpFlagD[3:0] = LftC & RhtC ? ClpFlagD[3:0] :"},{"entry":"ClpFlagD[XsortMidSrc,XsortRhtSrc,XsortLftSrc,XsortMidSrc]"},{"entry":"XsortClpFlagU[3:0] = LftC & RhtC ? ClpFlagU[3:0] :"},{"entry":"ClpFlagU[XsortMidSrc,XsortRhtSrc,XsortLftSrc,XsortMidSrc]"},{"entry":"\/\/ Sort the Clip Flags in Y"},{"entry":"YsortClpFlagL[3:0] = LftC & RhtC ? ClpFlagL[3:0] :"},{"entry":"ClpFlagL[YsortTopSrc,YsortMidSrc,YsortMidSrc,YsortBotSrc]"},{"entry":"YsortClpFlagR[3:0] = LftC & RhtC ? ClpFlagR[3:0] :"},{"entry":"ClpFlagR[YsortTopSrc,YsortMidSrc,YsortMidSrc,YsortBotSrc]"},{"entry":"YsortClpFlagD[3:0] = LftC & RhtC ? ClpFlagD[3:0] :"},{"entry":"ClpFlagD[YsortTopSrc,YsortMidSrc,YsortMidSrc,YsortBotSrc]"},{"entry":"YsortClpFlagU[3:0] = LftC & RhtC ? ClpFlagU[3:0] :"},{"entry":"ClpFlagU[YsortTopSrc,YsortMidSrc,YsortMidSrc,YsortBotSrc]"},{"entry":"\/\/ Pass #1 Clip to Left Tile edge using X-sorted primitive"},{"entry":"\/\/ For LeftBottom: check clipping flags, dereference vertices and slopes"},{"entry":"If (XsortClipL[0]) \u2003\u2003\/\/ bot vertex clipped by TileLeft)"},{"entry":"Then"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Pref =","(quad)","? P2"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["BotC","? XsortRhtSrc\u2192mux(P0, P1, P2)"]},{"entry":["TopC","? XsortRhtSrc\u2192mux(P0, P1, P2)"]},{"entry":[{},"Slope = (quad)? SL : \u2003BotC \u2003? XsortSBTopC ? XsortSB"]},{"entry":["Else",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Pref =","(quad)","? P0 :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["BotC","? XsortMidSrc\u2009\u00ae mux(P0, P1, P2)"]},{"entry":["TopC","? XsortRhtSrc"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Slope =","(quad) ? SR :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["BotC","? XsortSL"]},{"entry":["TopC","? XsortSB"]},{"entry":["Endif",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"YLB = Yref + slope * (TileLeft \u2212 Xref)"},{"entry":"\/\/ For LeftBottom: calculate intersection point, clamp, and check validity"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IntYLB = (XsortClpFlgL[1])","?","Yref + slope * (TileLeft \u2212 Xref) :"]},{"entry":[{},{},"XsortLftSrc\u2192mux(Y0, Y1, Y2)"]},{"entry":["ClipYLB = (intYLB < TileBot) ?",{},"TileBot :"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"IntXBL"},{"entry":"ValidYLB = (intYBL <= TileTop)"},{"entry":"\/\/For LeftTop: check clipping flags, dereference vertices and slopes"},{"entry":"If (XsortClpFlagL[3]) \u2003\/\/ Top vertex clipped by TileLeft)"},{"entry":"Then"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Pref =","(quad)","? P2 :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["BotC","? XsortRhtSrc\u2192mux(P0, P1, P2):"]},{"entry":["TopC","? XsortRhtSrc\u2192mux(P0, P1, P2):"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Slope =","(quad)","? SR :"]},{"entry":[{},{},"BotC","? XsortST"]},{"entry":[{},{},"TopC","? XsortST"]},{"entry":["Else",{},{},{}]},{"entry":[{},"Pref =","(quad)","? P3 :"]},{"entry":[{},{},"BotC","? XsortRhtSrc\u2192mux(P0, P1, P2)"]},{"entry":[{},{},"TopC","? XsortMidSrc\u2192mux(P0, P1, P2)"]},{"entry":[{},"Slope =",{},"(quad) ? SL :"]},{"entry":[{},{},"BotC","? XsortST :"]},{"entry":[{},{},"TopC","? XsortSL"]},{"entry":["Endif",{},{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"YLT = Yref + slope * (TileLeft \u2212 Xref)"},{"entry":"\/\/ For LeftTop: calculate intersection point, clamp, and check validity"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IntYLT = (XsortClpFlgL[1])","?","Yref + slope * (TileLeft \u2212 Xref)"]},{"entry":[{},{},"XsortLftSrc\u2192mux(Y0, Y1, Y2)"]},{"entry":["ClipYLT = (intYLT > TileTop) ?",{},"TileTop :"]},{"entry":[{},{},"IntYLT"]},{"entry":["ValidYLT = (intYLT >= TileBot)",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ The X Left coordinate is shared by the YLB and YLT"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ClipXL = (XsortClpFlgl[1])","?","TileLeft :"]},{"entry":[{},{},"XsortLftSrc\u2192mux(X0, X1, X2)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"ValidClipLft = ValidYLB & ValidYLT"},{"entry":"\/\/ Pass #2 Clip to Right Tile edge using X-sorted primitive"},{"entry":"\/\/For RightBot: check clipping flags, dereference vertices and slopes"},{"entry":"If (XsortClpFlagR[0]) \u2003\/\/Bot vertex clipped by TileRight"},{"entry":"Then"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Pref = (quad) ? P0 :"]},{"entry":["BotC","? XsortMidSrc\u2192mux(P0, P1, P2)"]},{"entry":["TopC","? XsortRhtSrc\u2192mux(P0, P1, P2)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Slope =","(quad) ? SR :"]},{"entry":["BotC","? XsortSL",{}]},{"entry":["TopC","? XsortSB",{}]},{"entry":["Else",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Pref =","(quad)","? P2 :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["BotC","? XsortRhtSrc\u2192mux(P0, P1, P2)"]},{"entry":["TopC","? XsortRhtSrc\u2192mux(P0, P1, P2)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Slope =",{},"(quad) ? SL :"]},{"entry":[{},{},"BotC","? XsortSB"]},{"entry":[{},{},"TopC","? XsortSB"]},{"entry":["EndIf",{},{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ For RightBot: calculate intersection point, clamp, and check validity"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["IntYRB = (XsortClpFlgR[2]) ?","Yref + slope * (TileRight \u2212 Xref) :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"XsortRhtSrc\u2192mux(Y0, Y1, Y2)"]},{"entry":["ClipYRB = (intYRB < TileBot) ?","TileBot :"]},{"entry":["IntYRB",{}]},{"entry":["ValidYRB = (intYRB <= TileTop)",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/For RightTop: check clipping flags, dereference vertices and slopes"},{"entry":"If (XsortClpFlagR[3]) \u2003\/\/ Top vertex clipped by TileRight"},{"entry":"Then"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Pref =","(quad)","? P3 :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["BotC","? XsortRhtSrc\u2192mux(P0, P1, P2)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"TopC ?","XsortMidSrc\u2192mux(P0, P1, P2)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Slope =",{},"(quad) ? SL :"]},{"entry":[{},{},"BotC","? XsortST :"]},{"entry":[{},{},"TopC","? XsortSL"]},{"entry":["Else",{},{},{}]},{"entry":[{},"Pref =","(quad)","? P2 :"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["BotC","? XsortRhtSrc\u2192mux(P0, P1, P2)"]},{"entry":["Topc","? XsortRhtSrc\u2192mux(P0, P1, P2)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Slope =","(quad)","? SR :"]},{"entry":[{},{},"BotC","? XsortST"]},{"entry":[{},{},"TopC","? XsortST"]},{"entry":["EndIf",{},{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"YRT = Yref + slope * (TileRight \u2212 Xref)"},{"entry":"\/\/ For RightTop: calculate intersection point, clamp, and check validity"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["IntYRT = (XsortClpFlgR[2]) ?","Yref + slope * (TileRight \u2212 Xref)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"XsortRhtSrc\u2192mux(Y0, Y1, Y2)"]},{"entry":["ClipYRT = (intYRT > TileTop) ?","TileTop :"]},{"entry":[{},"IntYRT"]},{"entry":["Valid YRT = (intYRT >= TileBot)",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ The X right coordinate is shared by the YRB and YRT"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["ClipXR = (XsortClpFlgR[2]) ?","TileRight :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"XsortRhtSrc\u2192mux(X0, X1, X2)"]},{"entry":["ValidClipRht = ValidYRB & ValidYRT",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Pass #3 Clip to Bottom Tile edge using Y-sorted primitive"},{"entry":"\/\/ For BottomLeft: check clipping flags, dereference vertices and slopes"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If (YsortClpFlagD[1])","\/\/ Left vertex clipped by TileBot)"]},{"entry":["Then",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Pref =","(quad)","? P3 :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LeftC","? YsortTopSrc\u2192mux(P0, P1, P2)"]},{"entry":["RhtC","? YsortTopSrc\u2192mux(P0, P1, P2)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Slope =",{},"(quad) ? SNL :"]},{"entry":[{},{},"LeftC","? YsortSNL"]},{"entry":[{},{},"RightC","? YsortSNL"]},{"entry":["Else",{},{},{}]},{"entry":[{},"Pref =","(quad)","? P1 :"]},{"entry":[{},{},"LeftC","? YsortMidSrc\u2192mux(P0, P1, P2)"]},{"entry":[{},{},"RhtC","? YsortTopSrc\u2192mux(P0, P1, P2)"]},{"entry":[{},"Slope =",{},"(quad) ? SNR :"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LeftC","? YsortSNB"]},{"entry":["RightC","? YsortSNL"]},{"entry":["EndIf",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ For BottomLeft: calculate intersection point, clamp, and check validity"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["IntXBL = (YsortClpFlgD[0]) ?","Xref + slope * (TileBot \u2212 Yref) :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"YsortBotSrc\u2192mux(X0, X1, X2)"]},{"entry":["ClipXBL = (intXBL < TileLeft) ?","TileLeft :"]},{"entry":["IntXBL",{}]},{"entry":["ValidXBL = (intXBL <= TileRight)",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/For BotRight: check clipping flags, dereference vertices and slopes"},{"entry":"If (YsortClpFlagD[2]) \u2003\/\/ Right vertex clipped by TileBot)"},{"entry":"Then"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Pref =","(quad)","? P3 :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LeftC","? YsoftTopSrc\u2192mux(P0, P1, P2)"]},{"entry":["RhtC","? YsoftTopSrc\u2192mux(P0, P1, P2)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Slope =","(quad)","? SNR :"]},{"entry":[{},{},"LeftC","? YsortSNR"]},{"entry":[{},{},"RightC","? YsortSNR"]},{"entry":["Else",{},{},{}]},{"entry":[{},"Pref =","(quad)","? P2 :"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LeftC","? YsortTopSrc\u2192mux(P0, P1, P2)"]},{"entry":["RhtC","? YsortMidSrc\u2192mux(P0, P1, P2)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Slope =",{},"(quad) ? SNL :"]},{"entry":[{},{},"LeftC","? YsortSNR :"]},{"entry":[{},{},"RightC","? YsortSNB"]},{"entry":["EndIf",{},{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ For BotRight: calculate intersection point, clamp, and check validity"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["IntXBR = (YsortClpFlgD[0]) ?","Xref + slope * (TileBot \u2212 Yref)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"YsortBotSrc\u2192mux(X0, X1, X2)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["ClipXBR = (intXBR > TileRight) ?","TileRight :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IntXTR"]},{"entry":["ValidXBR = (intXBR >= TileLeft)",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ The Y bot coordinate is shared by the XBL and XBR"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["ClipYB = (YsortClpFlgD[0]) ?","TileBot :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"YsortBotSrc\u2192mux(Y0, Y1, Y2)"]},{"entry":["ValidClipBot = ValidXBL & ValidXBR",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Pass #4 Clip to Top Tile edge using Y-sorted primitive"},{"entry":"\/\/For TopLeft: check clipping flags, dereference vertices and slopes"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If (ClpFlagU[1])","\/\/Left vertex clipped by TileTop"]},{"entry":["Then",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Pref = (quad)","? P1 :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LftC","? YsortMidSrc\u2192mux(P0, P1, P2)"]},{"entry":["RhtC","? YsortTopSrc\u2192mux(P0, P1, P2)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Slope =","(quad) ? SNR :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LeftC","? YsortSNB"]},{"entry":["RightC","? YsortSNL"]},{"entry":["Else",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Pref = (quad)","? P3 :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LftC","? YsortTopSrc\u2192mux(P0, P1, P2)"]},{"entry":["RhtC","? YsortTopSrc\u2192mux(P0, P1, P2)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Slope =",{},"(quad) ? SNL :"]},{"entry":[{},{},"LeftC","? YsortSNL"]},{"entry":[{},{},"RightC","? YsortSNL"]},{"entry":["EndIf",{},{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ For topleft: calculate intersection point, clamp, and check validity"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["IntXTL = (YsortClpFlgU[3]) ?","Xref + slope * (TileTop \u2212 Yref) :"]},{"entry":[{},"YsortTopSrc\u2192mux(X0, X1, X2)"]},{"entry":["ClipXTL = (intXTL < TileLeft) ?","TileLeft :"]},{"entry":["IntXTL",{}]},{"entry":["ValidXTL = (intXTL <= TileRight)",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/For TopRight: check clipping flags, dereference vertices and slopes"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["If (YsortClpFlagU[2])","\/\/ Right vertex clipped by TileTop"]},{"entry":["Then",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Pref =","(quad)","? P2 :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LftC","? YsortTopSrc\u2192mux(P0, P1, P2)"]},{"entry":["RhtC","? YsortMidSrc\u2192mux(P0, P1, P2)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Slope =",{},"(quad) ? SNL :"]},{"entry":[{},{},"LeftC","? YsortSNR :"]},{"entry":[{},{},"RightC","? YsortSNB"]},{"entry":["Else",{},{},{}]},{"entry":[{},"Pref =","(quad)","? P3 :"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"231pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["LftC","? YsoftTopSrc\u2192mux(P0, P1, P2)"]},{"entry":["RhtC","? YsoftTopSrc\u2192mux(P0, P1, P2)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Slope =",{},"(quad) ? SNR :"]},{"entry":[{},{},"LeftC","? YsortSNR :"]},{"entry":[{},{},"RightC","? YsortSNR"]},{"entry":["EndIf",{},{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ For TopRight: calculate intersection point, clamp, and check validity"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["IntXTR = (YsortClpFlgU[3]) ?","Xref + slope * (TileTop \u2212 Yref)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"YsortTopSrc\u2192mux(X0, X1, X2)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["ClipXTR = (intXTR > TileRight) ?","TileRight :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IntXTR"]},{"entry":["Valid XTR = (intXTR >= TileLeft)",{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"\/\/ The Y top coordinate is shared by the XTL and XTR"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["ClipYT = (YsortClpFlgU[3]) ?","TileTop :"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"YsortTopSrc\u2192mux(Y0, Y1, Y2)"]},{"entry":"ValidClipTop = ValidXTL & ValidXTR"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The 8 clipping points identifed so far can identify points clipped by the edge of the tile and also extreme vertices (ie topmost, bottommost, leftmost or rightmost) that are inside of the tile. One more clipping point is needed to identify a vertex that is inside the tile but is not at an extremity of the polygon (ie the vertex called VM)",{"@attributes":{"id":"p-1122","num":"1129"},"tables":{"@attributes":{"id":"TABLE-US-00018","num":"00018"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ Identify Internal Vertex"},{"entry":"(ClipXI, ClipYI) = YsortMidSrc\u2192mux(P0, P1, P2)"},{"entry":"ClipM = XsortMidSrc\u2192mux(Clip0, Clip1, Clip2)"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ValidClipI =",{},"!(ClpFlgL[YsortMidSrc]) & !(ClpFlgR[YsortMidSrc])"]},{"entry":[{},"&","!(ClpFlgD[YsortMidSrc]) & !(ClpFlgU[YsortMidSrc])"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Furthermore, some of the geometric data required by Cull Unit is determined here.","Geometric Data Required by Cull:","CullXTL and CullXTR. These are the X intercepts of the polygon with the line of the top edge of the tile. They are different from the PTL and PTR in that PTL and PTR must be within or at the tile boundaries, while CullXTL and CullXTR may be right or left of the tile boundaries. If YT lies below the top edge of the tile then CullXTL=CullXTR=XT.\n\n",{"@attributes":{"id":"p-1125","num":"1135"},"tables":{"@attributes":{"id":"TABLE-US-00019","num":"00019"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\/\/ CullXTL and CullXTR (clamped to window range)"},{"entry":"CullXTL = (IntXTL < MIN) ?MIN : \u2003\u2003IntXTL"},{"entry":"CullXTR = (IntXTR > MAX) ?MAX :IntXTR"},{"entry":"\/\/ (CullXL, CullYL) and (CullXR, CullYR)"},{"entry":"VtxRht =\u2003\u2003(quad) ?P2 :YsortMidSrc\u2192mux(P0, P1, P2)"},{"entry":"VtxLft = (quad) ?P1 : \u2003YsortMidSrc\u2192mux(P0, P1, P2)"},{"entry":"(CullXL, CullYL)temp = (YsortClipL clipped by TileTop) ?(IntXTL, IntYT) :VtxLft"},{"entry":"(CullXL, CullYL) = (CullXLtemp < MIN) ?\u2003\u2003\u2003(ClipXL, ClipYLB) :CullXLtemp"},{"entry":"(CullXR, CullYR)temp = (YsortClipR clipped by TileTop) ?(IntXTR, IntYT) :VtxRht"},{"entry":"(CullXR, CullYR) = (CullXRtemp > MAX) ?(ClipXR, ClipYRB) :CullXRtemp"},{"entry":"\/\/ Determine Cull Slopes"},{"entry":"CullSR, CullSL, CullSB = cvt (YsortSNR, YsortSNL, YsortSNB)"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{}},"With wide lines on tiles at the edge of the window, it is possible that one or more of the calculated vertices may lie outside of the window range. Setup can handle this by carrying 2 bits of extra coordinate range, one to allow for negative values, one to increase the magnitude range. The range and precision of the data sent to the CUL block (. for x coordinates) is just enough to define the points inside the window range. The data that the CUL block gets from Setup includes the left and right corner points. In cases where a quad vertex falls outside of the window range, Setup will pass the following values to CUL: (1) If tRight.x is right of the window range then clamp to right window edge; (2) If tLeft.x is left of window range then clamp to left window edge; (3) If v[VtxRightCq].x is right of window range then send vertex rLow (that is, lower clip point on the right tile edge as the right corner); and, (4) If v[VtxLeftC].x is left of window range then send ILow (that is, the lower clip point on the left tile edge as the left corner). This is illustrated in FIG. D, where there is shown an example of processing quadrilateral vertices outside of a window. (FIG. D  correlates with FIG. 51 in U.S. Provisional Patent Application Ser. No. 60\/097,336). FIG. D illustrates aspects of clip code vertex assignment.","Note that triangles are clipped to the valid window range by a previous stage of pipeline , for example, geometry . Setup , in the current context, is only concerned with quads generated for wide lines. Cull  (see FIG. D) needs to detect overflow and underflow when it calculates the span end points during the rasterization, because out of range x values may be caused during edge walking. If an overflow or underflow occurs then the x-range should be clamped to within the tile range.","We now have determined a primitive's intersection points (clipping points) with respect to the current tile, and we have determined the clip codes, or valid flags. We can now proceed to computation of bounding box, a minimum depth value (Zmin), and a reference stamp, each of which will be described in greater detail below.","5.4.7 Bounding Box","The bounding box is the smallest box that can be drawn around the clipped polygon. The bounding box of the primitive intersection is determined by examining the clipped vertices (clipped vertices, or clipping points are described in greater detail above). We use these points to compute dimensions for a bounding box.","The dimensions of of the bounding box are identified by BXL (the left most of valid clip points), BXR (the right most of valid clip points), BYT (the top most of valid clip points), BYB (the bottom most of valid clip points) in stamps.here, stamp refers to the resolution we want to determine the bounding box to.","Finally, setup  identifies the smallest Y (the bottom most y-coordinate of a clip polygon). This smallest Y is required by cull  for its edge walking algorithm.","To illustrate a procedure, according to one embodiment of present invention, we now describe pseudocode for determining such dimensions of a bounding box. The valid flags for the clip points are as follows: ValidClipL (needs that clip points PLT and PLB are valid), ValidClipR, ValidClipT, and ValidClipB, correspond to the clip codes described in greater detail above in reference to clipping unit  (see FIG. D). \u201cPLIT\u201d refers to \u201cpoint left, top.\u201d PLT and (ClipXL, ClipyLT) are the same.\n\ntemp=min valid(Clip, Clip);\n\nBXL=ValidClipL ! ClipXL:BXLtemp\n\ntemp=max valid(Clip, Clip);\n\nBXR=ValidClipR ! ClipXR:BXRtemp\n\ntemp=max valid(Clip, Clip);\n\nBYT=ValidClipT ? ClipYT:BYTtemp;\n\ntemp=min valid(Clip, Clip);\n\nBYB=ValidClipB ? ClipYB:BYBtemp;\n\nCull=trunc()subpixels (Cullis the smallest value);\n\n\/\/expressed in subpixels\u20148\u00d78 subpixels=1 pixel; 2\u00d72 pixels=1 stamp.\n","We now have dimensions for a bounding box that circumscribes those parts of a primitive that intersect the current tile. These xmin (BXL), xmax (BXR), ymin (BYB), ymax (BYT) pixel coordinates need to be converted to the stamp coordinates. This can be accomplished by first converting the coordinates to tile relative values and then considering the high three bits only (i.e. shift right by 1 bit). This works; except when xmax (and\/or ymax) is at the edge of the tile. In that case, we decrement the xmax (and\/or ymax) by 1 unit before shifting.","\/\/ The Bounding Box is Expressed in Stamps\n\n=trunc(\u22121 subpixel)stamp;\n\n=trunc()stamp;\n\n=trunc()stamp; and,\n\n=trunc(\u22121 subpixel)stamp.\n\n5.4.8 Depth Gradients and Depth Offset Unit\n","The object of this functional unit is to:","Calculate Depth Gradients Zx=dz\/dx and Zy=dz\/dy","Calculate Depth Offset O, which will be applied in the Zmin & Zref subunit","Determine if triangle is x major or y major","Calculate the ZslopeMjr (z gradient along the major edge)","Determine ZslopeMnr (z gradient along the minor axis)","In case of triangles, the input vertices are the time-ordered triangle vertices (X, Y, Z), (X, Y, Z), (X, Y, Z). For lines, the input vertices are 3 of the quad vertices produced by Quad Gen (QXB, QYB, ZB), (QXL, QYL, ZL), (QXR, QYR, ZR). In case of stipple lines, the Z partials are calculated once (for the original line) and saved and reused for each stippled line segment. In case of line mode triangles, an initial pass through this subunit is taken to calculate the depth offset, which will be saved and applied to each of the triangle's edges in subsequent passes. The Depth Offset is calculated only for filled and line mode triangles and only if the depth offset calculation is enabled.","5.4.8.1 Depth Gradients","The vertices are first sorted before being inserted in to the equation to calculate depth gradients. For triangles, the sorting information is was obtained in the triangle preprocessing unit described in greater detail above. (The information is contained in the pointers YsortTopSrc, YsortMidSrc, and YsortBotSrc.). For quads, the vertices are already sorted by Quadrilateral Generation unit described in greater detail above. Note: Sorting the vertices is desirable so that changing the input vertex ordering will not change the results.","We now describe pseudocode for sorting the vertices:","If triangles:\n\n\u20320sortBotSrc\u2192mux(210); \u20320sortBotSrc\u2192mux(210);\n\n\u20321sortMidSrc\u2192mux(210); \u20320sorMidSrc\u2192mux(210);\n\n\u20322sortTopSrc\u2192mux(210); \u20320sortTopSrc\u2192mux(210);\n","To illustrate the above notation, consider the following example where X\u2032=ptr\u2212>mux(x, x, x) means: if ptr==001, then X\u2032=x; if ptr==010, then X\u2032=x; and, if ptr==100, then X\u2032=x.","If Quads:\n\nX\u20320=QXB Y\u20320=QYB\n\nX\u20321=QXL Y\u20321=QYL\n\nX\u20322=QXR Y\u20322=QYR\n","The partial derivatives represent the depth gradient for the polygon. They are given by the following equation:",{"@attributes":{"id":"p-1145","num":"1155"},"maths":[{"@attributes":{"id":"MATH-US-00014","num":"00014"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["Z","X"]},"mo":"=","mrow":{"mfrac":[{"mrow":[{"mi":["\u03b4","z"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":["\u03b4","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]},{"mrow":[{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["y","\u2032"],"mn":"2"},{"mi":["y","\u2032"],"mn":"0"}],"mo":"-"}},{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["z","\u2032"],"mn":"1"},{"mi":["z","\u2032"],"mn":"0"}],"mo":"-"}}],"mo":"\u2062"},{"mrow":[{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["y","\u2032"],"mn":"1"},{"mi":["y","\u2032"],"mn":"0"}],"mo":"-"}},{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["z","\u2032"],"mn":"2"},{"mi":["z","\u2032"],"mn":"0"}],"mo":"-"}}],"mo":"\u2062"}],"mo":"-"},{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["x","\u2032"],"mn":"1"},{"mi":["x","\u2032"],"mn":"0"}],"mo":"-"}},{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["y","\u2032"],"mn":"2"},{"mi":["y","\u2032"],"mn":"0"}],"mo":"-"}}],"mo":"\u2062"},{"mrow":[{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["x","\u2032"],"mn":"2"},{"mi":["x","\u2032"],"mn":"0"}],"mo":"-"}},{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["y","\u2032"],"mn":"1"},{"mi":["y","\u2032"],"mn":"0"}],"mo":"-"}}],"mo":"\u2062"}],"mo":"-"}]}],"mo":"="}}}},{"@attributes":{"id":"MATH-US-00014-2","num":"00014.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["Z","Y"]},"mo":"=","mrow":{"mfrac":[{"mrow":[{"mi":["\u03b4","z"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}},{"mi":["\u03b4","y"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}]},{"mrow":[{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["x","\u2032"],"mn":"1"},{"mi":["x","\u2032"],"mn":"0"}],"mo":"-"}},{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["z","\u2032"],"mn":"2"},{"mi":["z","\u2032"],"mn":"0"}],"mo":"-"}}],"mo":"\u2062"},{"mrow":[{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["x","\u2032"],"mn":"2"},{"mi":["x","\u2032"],"mn":"0"}],"mo":"-"}},{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["z","\u2032"],"mn":"1"},{"mi":["z","\u2032"],"mn":"0"}],"mo":"-"}}],"mo":"\u2062"}],"mo":"-"},{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["x","\u2032"],"mn":"1"},{"mi":["x","\u2032"],"mn":"0"}],"mo":"-"}},{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["y","\u2032"],"mn":"2"},{"mi":["y","\u2032"],"mn":"0"}],"mo":"-"}}],"mo":"\u2062"},{"mrow":[{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["x","\u2032"],"mn":"2"},{"mi":["x","\u2032"],"mn":"0"}],"mo":"-"}},{"mo":["(",")"],"mrow":{"msubsup":[{"mi":["y","\u2032"],"mn":"1"},{"mi":["y","\u2032"],"mn":"0"}],"mo":"-"}}],"mo":"\u2062"}],"mo":"-"}]}],"mo":"="}}}}],"br":{},"b":["7","6"]},"The depth offset for triangles (both line mode and filled) is defined by OpenGL\u00ae as:\n\n*factor+Res*units, where:\n","M=max(|ZX|, |ZY|) of the triangle;","Factor is a parameter supplied by the user;","Res is a constant; and,","Units is a parameter supplied by the user.","The \u201cRes*units\u201d term has already been added to all the Z values by a previous stage of pipeline , for example, geometry Geometry . So Setup's  depth offset component becomes:\n\n*factor*8, Clamp to lie in the range (\u2212224, +224)\n","The multiply by 8 is required to maintain the units. The depth offset will be added to the Z values when they are computed for Zmin and Zref later.","In case of line mode triangles, the depth offset is calculated once and saved and applied to each of the subsequent triangle edges.","5.4.8.2.1 Determine X Major for Triangles","In the following unit (Zref and Zmin Subunit) Z values are computed using an \u201cedge-walking\u201d algorithm. This algorithm requires information regarding the orientation of the triangle, which is determined here.\n\nsortTopSrc\u2192mux(210);\n\nsortBotSrc\u2192mux(210);\n\nsortRhtSrc\u2192mux(210);\n\nsortLftSrc\u2192mux(210);\n\nDelta\n\nDelta\n\nIf triangle:\n\nmajor=|Delta|>=|Delta\n\nIf quad\n\nXmajor=value of Xmajor as determined for lines in the TLP subunit.\n","An x-major line is defined in OpenGL\u00ae specification. In setup , an x-major line is determined early, but conceptually may be determined anywhere it is convenient.","5.4.8.2.2 Compute ZslopeMjr and ZslopeMnr","(Z min and Z ref SubUnit) are the ZslopeMjr (Z derivative along the major edge), and ZslopeMnr (the Z gradient along the minor axis). Some definitions: (a) Xmajor Triangle: If the triangle spans greater or equal distance in the x dimension than the y dimension, then it is an Xmajor triangle, else it is a Ymajor triangle; (b) Xmajor Line: if the axis of the line spans greater or equal distance in the x dimension than the y dimension, then it is an Xmajor line, else it is a Ymajor line; (c) Major Edge (also known as Long edge). For Xmajor triangles, it is the edge connecting the Leftmost and Rightmost vertices. For Ymajor triangles, it is the edge connecting the Topmost and Bottommost vertices. For Lines, it is the axis of the line. Note that although, we often refer to the Major edge as the \u201clong edge\u201d it is not necessarily the longest edge. It is the edge that spans the greatest distance along either the x or y dimension; and, (d) Minor Axis: If the triangle or line is Xmajor, then the the minor axis is the y axis. If the triangle or line is Ymajor, then the minor axis is the x axis.","To compute ZslopeMjr and ZslopeMnr:","If Xmajor Triangle:\n\nslopeMjr=()\/() slopeMnr=\n\nIf Ymajor Triangle:\n\nslopeMjr=()\/() slopeMnr=\n\nIf Xmajor Line & (xCntUp==yCntUp)\n\nslopeMjr=()\/() slopeMnr=\n\nIf Xmajor Line & (xCntUp !=yCntUp)\n\nslopeMjr=()\/() slopeMnr=\n\nIf Ymajor Line & (xCntUp==yCntUp)\n\nslopeMjr=()\/() slopeMnr=\n\nIf Ymajor Line & (xCntUp !=yCntUp)\n\nslopeMjr=()\/() slopeMnr=\n\n5.4.8.2.3 Special Case for Large Depth Gradients\n","It is possible for triangles to generate arbitrarily large values of Dz\/Dx and Dz\/Dy. Values that are too large present two problems:\n\n","If Xmajor Triangle or Xmajor Line\n\nSet ZslopeMnr=0;\n\nSet slopeMjr;\n\nSet =0;\n","If Ymajor Triangle or Ymajor Line\n\nSet ZslopeMnr=0;\n\nSet =0; and,\n\nSet slopeMjr.\n\n5.4.8.2.4 Discarding Edge-On Triangles\n","Edge-on triangles are detected in depth gradient unit  (see FIG. D). Whenever the Dz\/Dx or Dz\/Dy is infinite (overflows) the triangle is invalidated. However, edge-on Line mode triangles are not discarded. Each of the visible edges are to be rendered. The depth offset (if turned on) for such a triangle will however overflow, and be clamped to +\/\u22122^24.","5.4.8.2.5 Infinite dx\/dy","An infinite dx\/dy implies that an edge is perfectly horizontal. In the case of horizontal edges, one of the two end-points has got to be a corner vertex (VtxLeftC or VtxRightC). With a primitive whose coordinates lie within the window range, Cull  (see FIG. D) will not make use of an infinite slope. This is because with Cull's  edge walking algorithm, it will be able to tell from the y value of the left and\/or right corner vertices that it has turned a corner and that it will not need to walk along the horizontal edge at all.","In this case, Cull's  edge walking will need a slope. Since the start point for edge walking is at the very edge of the window, any X that edge walking calculates with a correctly signed slope will cause an overflow (or underflow) and X will simply be clamped back to the window edge. So it is actually unimportant what value of slope it uses as long as it is of the correct sign.","A value of infinity is also a don't care for setup's  own usage of slopes. Setup uses slopes to calculate intercepts of primitive edges with tile edges. The equation for calculating the intercept is of the form X=X+_Y*dx\/dy. In this case, a dx\/dy of infinity necessarily implies a _Y of zero. If the implementation is such that zero plus any number equals zero, then dx\/dy is a don't care.","Setup  calculates slopes internally in floating point format. The floating point units will assert an infinity flag should an infinite result occur. Because Setup doesn't care about infinite slopes, and Cull  doesn't care about the magnitude of infinite slopes, but does care about the sign, setup  doesn't need to express infinity. To save the trouble of determining the correct sign, setup  forces an infinite slope to ZERO before it passes it onto Cull .","5.4.9 Z Min and Z Ref","We now compute minimum z value for the intersection of the primitive with the tile. The object of this subunit is to: (a) select the 3 possible locations where the minimum Z value may be; (b) calculate the Z's at these 3 points, applying a correction bias if needed; (c) sSelect he minimum Z value of the polygon within the tile; (d) use the stamp center nearest the location of the minimum Z value as the reference stamp location; (e) compute the Zref value; and, (f) apply the Z offset value.","There are possibly 9 valid clipping points as determined by the Clipping subunit. The minimum Z value will be at one of these points. Note that depth computation is an expensive operation, and therefore is desirable to minimize the number of depth computations that need to be carried out. Without pre-computing any Z values, it is possible to reduce the 9 possible locations to 3 possible Z min locations by checking the signs of ZX and ZY (the signs of the partial z derivatives in x and y).","Clipping points (Xmin, Ymin, Valid), (Xmin, Ymin, Valid), (Xmin, Ymin, Valid) are the 3 candidate Zmin locations and their valid bits. It is possible that some of these are invalid. It is desirable to remove invalid clipping points from consideration. To accomplish this, setup  locates the tile corner that would correspond to a minimum depth value if the primitive completely covered the tile. Once setup  has determined that tile corner, then setup  need only to compute the depth value at the two nearest clipped points. These two values along with the z value at vertex i (Clip Point PI) provide us with the three possible minimum z values. Possible clip points are PTL, PTR, PLT, PLB, PRT, PRB, PBR, PBL, and PI (the depth value of PI is always depth value of y-sorted middle (ysortMid)). The three possible depth value candidates must be compared to determine the smallest depth value and its location. We now know the minimum z value and the clip vertex it is obtained from. In a preferred embodiment of the present mentioned, Z-value is clamped to 24 bits before sending to CUL.","To to illustrate the above, referred to the pseudocode below for identifying those clipping point that are minimum depth value candidates:","Notational Note:",{"@attributes":{"id":"p-1170","num":"1182"},"tables":{"@attributes":{"id":"TABLE-US-00020","num":"00020"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003\u2003\u2003ClipTL = (ClipXTL, ClipYT, ValidClipT), ClipLT ="},{"entry":"\u2003\u2003\u2003(ClipXL, YLT, ValidClipL) , etc"},{"entry":"If (ZX>0) &(ZY>0) \/\/ Min Z is toward the bottom left"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Then","(Xmin0, Ymin0) =","ValidClipL","? ClipLB"]},{"entry":["ValidClipT","? ClipTL",{},{}]},{"entry":[{},": ClipRB",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Zmin0Valid =","ValidClipL | ValidClipT | ValidClipR"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(Xmin1, Ymin1) =","ValidClipB","? ClipBL"]},{"entry":["ValidClipR","? ClipRB",{},{}]},{"entry":[{},": ClipTL",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Zmin1Valid =","ValidClipL | ValidClipB | ValidClipT"]},{"entry":[{},"(Xmin2, Ymin2) = ClipI"]},{"entry":[{},"Zmin2Valid = (PrimType == Triangle)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"If (ZX>0) & (ZY<0) \/\/ Min Z is toward the top left"},{"entry":"Then"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(Xmin0, Ymin0) =","ValidClipL","? ClipLT"]},{"entry":["ValidClipB","? ClipBL",{},{}]},{"entry":[{},": ClipRT",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Zmin0Valid =","ValidClipL | ValidClipB | ValidClipR"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(Xmin1, Ymin1) =","ValidClipT","? ClipTL"]},{"entry":["ValidClipR","? ClipRT",{},{}]},{"entry":[{},": ClipBL",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Zmin1Valid =","ValidClipT | ValidClipR | ValidClipB"]},{"entry":[{},"(Xmin2, Ymin2) = ClipI"]},{"entry":[{},"Zmin2Valid = (PrimType == Triangle)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"If (ZX<0) & (ZY>0) \/\/ Min Z is toward the bottom right"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Then","(Xmin0, Ymin0) =","ValidClipR","? ClipRB"]},{"entry":["ValidClipT","? ClipTR",{},{}]},{"entry":[{},": ClipLB",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Zmin0Valid =","ValidClipR | ValidClipT | ValidClipL"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(Xmin1, Ymin1) =","ValidClipB","? ClipBR"]},{"entry":["ValidClipL","? ClipLB",{},{}]},{"entry":[{},": ClipTR",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Zmin1Valid =","ValidClipB | ValidClipL | ValidClipT"]},{"entry":[{},"(Xmin2, Ymin2) = ClipI"]},{"entry":[{},"Zmin2Valid = (PrimType == Triangle)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"If (ZX<0) & (ZY<0) \/\/ Min Z is toward the top right"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Then","(Xmin0, Ymin0) =","ValidClipR","? ClipRT"]},{"entry":["ValidClipB","? ClipBR",{},{}]},{"entry":[{},": ClipLT",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":["Zmin0Valid =","ValidClipR | ValidClipB | ValidClipL"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(Xmin1, Ymin1) =","ValidClipT","? ClipTR"]},{"entry":["ValidClipL","? ClipLT",{},{}]},{"entry":[{},": ClipBR",{},{}]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Zmin1Valid =","ValidClipT | ValidClipL | ValidClipB"]},{"entry":[{},"(Xmin2, Ymin2) = ClipI"]},{"entry":[{},"Zmin2Valid = (PrimType == Triangle)"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"Referring to FIG. D, there is shown in example of Zmin candidates.","5.4.9.1 The Z Calculation Algorithm","A straight forward approach to computing a Z value at any point on a triangle would be to use the following equation: Zdest=(Xdest\u2212X)*ZX+(Ydest\u2212Y)*ZY+Z+offset. However, this equation would suffer from two problems in the Apex implementation: (1) Because the equation would be implemented using limited precision floating point units, the equation suffers from massive cancellation errors, causing loss of accuracy; and, (2) A subsequent processing stage  in pipeline , in particular, Cull , is unable to handle Zx or Zy values of greater than 2^27. The above equation does not provide an easy route for combating these problems.","Conceptually, the problem with the above equation is that the path of computation involves walking outside of the triangle. The two product terms can be large and produce intermediate Z values far outside the range of than 2^24. The final Z value will be less than than 2^24 but it is arrived at by subtracting two very large numbers that are nearly equal but opposite in sign to obtain a relatively small number. Doing such an operation using floating point numbers that have limited bits in the mantissa may suffer loss of accuracy by a process called massive cancellation.","An algorithm by which the path of computation stays within the triangle will produce intermediate Z values that will stay within the range of than 2^24 and will not suffer as severely from massive cancellation. For a Y major triangle:",{"@attributes":{"id":"p-1175","num":"1187"},"maths":{"@attributes":{"id":"MATH-US-00015","num":"00015"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mi":["Zdest",{}],"mo":["=","\u2062"],"mrow":{"mrow":{"mo":"+","mrow":{"mo":["(",")"],"mrow":{"mi":["Ydest","Ytop"],"mo":"-"}}},"mo":"*","mi":"ZslopeMjr"}}},{"mrow":{"mi":"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0","mo":"\u2062","mrow":{"mo":["(",")"],"mn":"1"}}}]},{"mtd":[{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mrow":{"mo":"+","mrow":{"mo":["(",")"],"mrow":{"mi":"Xdest","mo":"-","mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mi":["Ydest","Ytop"],"mo":"-"}},"mo":"*"}}},{"mtd":{"mrow":{"mrow":{"mi":["DX","Dylong"],"mo":"\/"},"mo":"+","mi":"Xtop"}}}]}}}}},"mo":"*","mi":"ZslopeMnr"}}},{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mo":["(",")"],"mn":"2"}}}]},{"mtd":[{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mo":"+","mi":"Ztop"}}},{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mo":["(",")"],"mn":"3"}}}]},{"mtd":[{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mo":"+","mi":"offset"}}},{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mo":["(",")"],"mn":"4"}}}]}]}}}},"Line (1) represents the change in Z as you walk along the long edge down to the appropriate Y coordinate. Line (2) is the change in Z as you walk in from the long edge to the destination X coordinate.","For an X major triangle the equation is analogous:",{"@attributes":{"id":"p-1178","num":"1190"},"maths":{"@attributes":{"id":"MATH-US-00016","num":"00016"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":[{"mrow":{"mi":["Zdest",{}],"mo":["=","\u2062"],"mrow":{"mrow":{"mo":"+","mrow":{"mo":["(",")"],"mrow":{"mi":["Xdest","Xright"],"mo":"-"}}},"mo":"*","mi":"ZslopeMjr"}}},{"mrow":{"mi":"\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0","mo":"\u2062","mrow":{"mo":["(",")"],"mn":"1"}}}]},{"mtd":[{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mrow":{"mo":"+","mrow":{"mo":["(",")"],"mrow":{"mi":"Ydest","mo":"-","mrow":{"mo":["(",")"],"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":{"mo":["(",")"],"mrow":{"mi":["Xdest","Xright"],"mo":"-"}},"mo":"*"}}},{"mtd":{"mrow":{"mrow":{"mi":["Dy","Dxlong"],"mo":"\/"},"mo":"+","mi":"Yright"}}}]}}}}},"mo":"*","mi":"ZslopeMnr"}}},{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mo":["(",")"],"mn":"2"}}}]},{"mtd":[{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mo":"+","mi":"Ztop"}}},{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mo":["(",")"],"mn":"3"}}}]},{"mtd":[{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mo":"+","mi":"offset"}}},{"mrow":{"mi":{},"mo":"\u2062","mrow":{"mo":["(",")"],"mn":"4"}}}]}]}}}},"For dealing with large values of depth gradient, the values specified in special case for large depth gradients (discussed in greater detail above) are used.","5.4.9.2 Compute Z's for Zmin Candidates","The 3 candidate Zmin locations have been identified (discussed above in greater detail). Remember that a flag needs to be carried to indicate whether each Zmin candidate is valid or not.","Compute: If Ymajor triangle:\n\nmin0=+(min0top)*slopeMjr+(min0\u2212((min0top)*long+top))*slopeMnr (note that top and offset are NOT yet added).\n","If Xmajor triangle:\n\nmin0=+(min0right)*slopeMjr+(min0\u2212((min0right)*long+top))*slopeMnr (note that right and offset are NOT yet added).\n","A correction to the zmin value may need to be applied if the xminO or ymino is equal to a tile edge. Because of the limited precision math units used, the value of intercepts (computed above while calculating intersections and determining clipping points) have an error less than +\/\u2212 1\/16 of a pixel. To guarantee then that we compute a Zmin that is less than what would be the infinitely precise Zmin, we apply a Bias to the zmin that we compute here.\n\n","The same equations are used to compute Zmin and Zmin","5.4.9.3 Determine Zmin","The minimum valid value of the three Zmin candidates is the Tile's Zmin. The stamp whose center is nearest the location of the Zmin is the reference stamp. The pseudocode for selecting the Zmin is as follows:\n\nminTmp=(min1min0) & min1Valid|!min0Valid ? min1min0;\n\nminTmpValid=(min1min0) & min1Valid|!min0Valid ? min1Valid:min0Valid; and,\n\nmin=(minTmp<min2) & minTmpValid|!min2Valid ? minTmp:min2.\n","The x and y coordinates corresponding to each Zmin, Zmin and Zmin are also sorted in parallel along with the determination of Zmin. So when Zmin is determined, there is also a corresponding xmin and ymin.","5.4.10 Reference Stamp and Z ref","Instead of passing Z values for each vertex of the primitive, Setup passes a single Z value, representing the Z value at a specific point within the primitive. Setup chooses a reference stamp that contains the vertex with the minimum z. The reference stamp is identified by adding the increment values to the x and y coordinates of the clip vertex and finding the containing stamp by truncating the x and y values to the nearest even value. For vertices on the right edge, the x-coordinates is decremented and for the top edge the y-coordinate is decremented before the reference stamp is computed.","Logic Used to Identify the Reference Stamp","The reference Z value, \u201cZref\u201d is calculated at the center of the reference stamp. Setup  identifies the reference stamp with a pair of 3 bit values, xRefStamp and yRefStamp, that specify its location in the Tile. Note that the reference stamp is identified as an offset in stamps from the corner of the Tile. To get an offset in screen space, the number of subpixels in a stamp are multiplied. For example: x=x tile coordinate multiplied by the number of pixels in the width of a tile plus xrefstamp multiplied by two. This gives us an x-coordinate in pixels in screen space.","The reference stamp must touch the clipped polygon. To ensure this, choose the center of stamp nearest the location of the Zmin to be the reference stamp. In the Zmin selection and sorting, keep track of the vertex coordinates that were ultimately chosen. Call this point (Xmin, Ymin).","If Zmin is located on rht tile edge, then clamp Xmin=tileLft+7 stamps If Zmin is located on top tile edge, then clamp:\n\nmin=tileBot+7 stamps;\n\nref=trunc(min)stamp+1 pixel (truncate to snap to stamp resolution); and,\n\nref=trunc(min)stamp+1 pixel (add 1 pixel to move to stamp center).\n","Calculate Zref using an analogous equation to the zMin calculations. Compute:","If Ymajor triangle:\n\nref=+(ref\u2212top)*slopeMjr+(ref* ((ref\u2212top)*long+top))*slopeMnr (note that top and offset are NOT yet added).\n\nIf major triangle: ref=+(ref\u2212right)*slopeMjr+(ref\u2212((ref\u2212right)* long+right))*slopeMnr (note that top and offset are NOT yet added).\n\n5.4.10.1 Apply Depth Offset\n","The Zmin and Zref calculated thus far still need further Z components added.","If Xmajor:",{"@attributes":{"id":"p-1193","num":"0000"},"ul":{"@attributes":{"id":"ul0008","list-style":"none"},"li":["(a) Zmin=Zmin+Ztop+Zoffset;","(b) Clamp Zmin to lie within range (\u22122^24, 2^24); and","(c) Zref=Zref+Ztop+Zoffset."]}},"If Ymajor:\n\n","Setup calculates Quad vertices with extended range. (s12.5 pixels). In cases where a quad vertex does fall outside of the window range, Setup will pass the following values to CUL:\n\n","An infinite dx\/dy implies that an edge is perfectly horizontal. With a primitive whose coordinates lie within the window range, Cull will not make use of an infinite slope. This is because with Cull's edge walking algorithm, it will be able to tell from the YleftC (or YrightC) parameter that it has turned a corner and that it will not need to walk along the horizontal edge at all. Unfortunately, when quad vertices fall outside of the window range we run into slight problems, particularly with non-antialiased lines. Consider the case of a non-antialiased line whose top right corner is outside.of the window range. RightC is then moved onto the RightBot Clip Point, and Cull's edge walking will not think to turn a corner on the horizontal edge and it will try to calculate an X projected from XtopR. (See FIG. D above). In this case, Cull's edge walking will need a slope. Since the primitive is at the very edge of the window, any X that edge walking calculates with a correctly signed slope will cause an overflow (or underflow) and X will simply be clamped back to the window edge. So it is actually unimportant what value of slope it is uses as long as it is of the correct sign. A value of infinity is also a don't care for setup's own usage of slopes. Setup uses slopes to calculate intercepts of primitive edges with tile edges. The equation for calculating the intercept is of the form X=X+DY*dx\/dy. In this case, a dx\/dy of infinity necessarily implies a DY of zero. Hence, the value of dx\/dy is a don't care. Setup calculates slopes internally in floating point format. The floating point units will assert an infinity flag should an infinite result occur. Because Setup doesn't care about infinite slopes, and Cull doesn't care about the magnitude of infinite slopes, but does care about the sign, we don't really need to express infinity. To save the trouble of determining the correct sign, Setup will force an infinite slope to ZERO before it passes it onto Cull.",{"@attributes":{"id":"p-1197","num":"1223"},"tables":{"@attributes":{"id":"TABLE-US-00021","num":"00021"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of begin frame packet 1000"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["BeginFramePacket",{},"Starting",{},"Destination\/"]},{"entry":["parameter","bits\/packet","bit","Source","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Header","5",{},"send unit",{}]},{"entry":["Block3DPipe","1","0","SW","BKE"]},{"entry":["WinSourceL","8","1","SW","BKE"]},{"entry":["WinSourceR","8","9","SW","BKE"]},{"entry":["WinTargetL","8","17","SW","BKE"]},{"entry":["WinTargetR","8","25","SW","BKE"]},{"entry":["WinXOffset","8","33","SW","BKE"]},{"entry":["WinYOffset","12","41","SW","BKE"]},{"entry":["PixelFormat","2","53","SW","BKE"]},{"entry":["SrcColorKeyEnable3D","1","55","SW","BKE"]},{"entry":["DestColorKeyEnable3D","1","56","SW","BKE"]},{"entry":["NoColorBuffer","1","57","SW","PIX, BKE"]},{"entry":["NoSavedColorBuffer","1","58","SW","PIX, BKE"]},{"entry":["NoDepthBuffer","1","59","SW","PIX, BKE"]},{"entry":["NoSavedDepthBuffer","1","60","SW","PIX, BKE"]},{"entry":["NoStencilBuffer","1","61","SW","PIX, BKE"]},{"entry":["NoSavedStencilBuffer","1","62","SW","PIX, BKE"]},{"entry":["StencilMode","1","63","SW","PIX"]},{"entry":["DepthOutSelect","2","64","SW","PIX"]},{"entry":["ColorOutSelect","2","66","SW","PIX"]},{"entry":["ColorOutOverflowSelect","2","68","SW","PIX"]},{"entry":["PixelsVert","11","70","SW","SRT, BKE"]},{"entry":["PixelsHoriz","11","81","SW","SRT"]},{"entry":["SuperTileSize","2","92","SW","SRT"]},{"entry":["SuperTileStep","14","94","SW","SRT"]},{"entry":["SortTranspMode","1","108","SW","SRT, CUL"]},{"entry":["DrawFrontLeft","1","109","SW","SRT"]},{"entry":["DrawFrontRight","1","110","SW","SRT"]},{"entry":["DrawBackLeft","1","111","SW","SRT"]},{"entry":["DrawBackRight","1","112","SW","SRT"]},{"entry":["StencilFirst","1","113","SW","SRT"]},{"entry":["BreakPointFrame","1","114","SW","SRT"]},{"entry":[{},"120"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-1198","num":"1224"},"tables":{"@attributes":{"id":"TABLE-US-00022","num":"00022"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 2"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of begin tile packet 2000"},{"entry":"BeginTilePacket"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["parameter","bits\/packet","Starting bit","Source","Destination"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["PktType","5","0",{},{}]},{"entry":["FirstTileInFrame","1","0","SRT","STP to BKE"]},{"entry":["BreakPointTile","1","1","SRT","STP to BKE"]},{"entry":["TileRight","1","2","SRT","BKE"]},{"entry":["TileFront","1","3","SRT","BKE"]},{"entry":["TileXLocation","7","4","SRT","STP, CUL,"]},{"entry":[{},{},{},{},"PIX, BKE"]},{"entry":["TileYLocation","7","11","SRT","STP, CUL,"]},{"entry":[{},{},{},{},"PIX, BKE"]},{"entry":["TileRepeat","1","18","SRT","CUL"]},{"entry":["TileBeginSubFrame","1","19","SRT","CUL"]},{"entry":["BeginSuperTile","1","20","SRT","STP to BKE"]},{"entry":["OverflowFrame","1","21","SRT","PIX, BKE"]},{"entry":["WriteTileZS","1","22","SRT","BKE"]},{"entry":["BackendClearColor","1","23","SRT","PIX, BKE"]},{"entry":["BackendClearDepth","1","24","SRT","CUL, PIX,"]},{"entry":[{},{},{},{},"BKE"]},{"entry":["BackendClearStencil","1","25","SRT","PIX, BKE"]},{"entry":["ClearColorValue","32","26","SRT","PIX"]},{"entry":["ClearDepthValue","24","58","SRT","CUL, PIX"]},{"entry":["ClearStencilValue","8","82","SRT","PIX"]},{"entry":[{},"95"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-1199","num":"1225"},"tables":{"@attributes":{"id":"TABLE-US-00023","num":"00023"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 3"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of clear packet 3000"},{"entry":"Srt2Stpclear"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["parameter","bits\/packet","Starting bit","Source","Destination\/Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Header","5","0",{},{}]},{"entry":["PixelModeIndex","4","0",{},{}]},{"entry":["Clearcolor","1","4","SW","CUL, PIX"]},{"entry":["ClearDepth","1","5","SW","CUL, PIX"]},{"entry":["ClearStencil","1","6","SW","CUL, PIX"]},{"entry":["ClearColorValue","32","7","SW","SRT, PIX"]},{"entry":["ClearDepthValue","24","39","SW","SRT, CUL, PIX"]},{"entry":["ClearStencilValue","8","63","SW","SRT, PIX"]},{"entry":["SendToPixel","1","71","SW","SRT, CUL"]},{"entry":[{},{},"72",{},{}]},{"entry":["ColorAddress","23","72","MEX","MIJ"]},{"entry":["ColorOffset","8","95","MEX","MIJ"]},{"entry":["ColorType","2","103","MEX","MIJ"]},{"entry":["ColorSize","2","105","MEX","MIJ"]},{"entry":[{},"112"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-1200","num":"1226"},"tables":{"@attributes":{"id":"TABLE-US-00024","num":"00024"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 4"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of cull packet 4000"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["parameter","bits\/packet","Starting Bit","Source","Destination"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SrtOutPktType","5",{},"SRT","STP"]},{"entry":["CullFlushAll","1","0","SW","CUL"]},{"entry":["reserved","1","1","SW","CUL"]},{"entry":["OffsetFactor","24","2","SW","STP"]},{"entry":[{},"31"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-1201","num":"1227"},"tables":{"@attributes":{"id":"TABLE-US-00025","num":"00025"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 5"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of end frame packet 5000"},{"entry":"EndFramePacket"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"bits\/",{},{},"Destination\/"]},{"entry":["parameter","packet","Starting bit","Source","Value"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"42pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Header","5","0",{},{}]},{"entry":["InterruptNumber","6","0","SW","BKE"]},{"entry":["SoftEndFrame","1","6","SW","MEX"]},{"entry":["BufferOverflowOccurred","1","7","MEX","MEX, SRT"]},{"entry":[{},"13"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-1202","num":"1228"},"tables":{"@attributes":{"id":"TABLE-US-00026","num":"00026"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"center"}},"thead":{"row":{"entry":"TABLE 6"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of primitive packet 6000"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["parameter","bits\/packet","Starting Address","Source","Destination"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["SrtOutPktType","5","0","SRT","STP"]},{"entry":["ColorAddress","23","5","MEX","MIJ"]},{"entry":["ColorOffset","8","28","MEX","MIJ"]},{"entry":["ColorType","2","36","MEX","MIJ, STP"]},{"entry":["ColorSize","2","38","MEX","MIJ"]},{"entry":["LinePointWidth","3","40","MEX","STP"]},{"entry":["Multisample","1","43","MEX","STP, CUL, PIX"]},{"entry":["CullFlushOverlap","1","44","SW","CUL"]},{"entry":["DoAlphaTest","1","45","GEO","CUL"]},{"entry":["DoABlend","1","46","GEO","CUL"]},{"entry":["DepthFunc","3","47","SW","CUL"]},{"entry":["DepthTestEnabled","1","50","SW","CUL"]},{"entry":["DepthMask","1","51","SW","CUL"]},{"entry":["PolygonLineMode","1","52","SW","STP"]},{"entry":["ApplyOffsetFactor","1","53","SW","STP"]},{"entry":["LineFlags","3","54","GEO","STP"]},{"entry":["LineStippleMode","1","57","SW","STP"]},{"entry":["LineStipplePattern","16","58","SW","STP"]},{"entry":["LineStippleRepeatFactor","8","74","SW","STP"]},{"entry":["WindowX2","14","82","GEO","STP"]},{"entry":["WindowY2","14","96","GEO","STP"]},{"entry":["WindowZ2","26","110","GEO","STP"]},{"entry":["StartLineStippleBit2","4","136","GEO","STP"]},{"entry":["StartStippleRepeatFactor2","8","140","GEO","STP"]},{"entry":["WindowX1","14","148","GEO","STP"]},{"entry":["WindowY1","14","162","GEO","STP"]},{"entry":["WindowZ1","26","176","GEO","STP"]},{"entry":["StartLineStippleBit1","4","202","GEO","STP"]},{"entry":["StartStippleRepeatFactor1","8","206","GEO","STP"]},{"entry":["WindowX0","14","214","GEO","STP"]},{"entry":["WindowY0","14","228","GEO","STP"]},{"entry":["WindowZ0","26","242","GEO","STP"]},{"entry":["StartLineStippleBit0","4","268","GEO","STP"]},{"entry":["StartStippleRepeatFactor0","8","272","GEO","STP"]},{"entry":[{},"280"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-1203","num":"1229"},"tables":{"@attributes":{"id":"TABLE-US-00027","num":"00027"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"357pt","align":"center"}},"thead":{"row":{"entry":"TABLE 7"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example of setup output primitive packet 7000"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Parameter","Bits","Starting bit","Source","Destination","Comments"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["StpOutPktType","5",{},"STP","CUL",{}]},{"entry":["ColorAddress","23","0","MEX","MIJ",{}]},{"entry":["ColorOffset","8","23","MEX","MIJ",{}]},{"entry":["ColorType","2","31","MEX","MIJ","0 = strip 1 = fan 2 = line 3 = point"]},{"entry":["ColorSize","2","33","MEX","MIJ","These 6 bits of colortype, colorsize, and"]},{"entry":[{},{},{},{},{},"colorEdgeId are encoded as EESSTT."]},{"entry":["ColorEdgeId","2","35","STP","CUL","0 = filled, 1 = v0v1, 2 = v1v2, 3 = v2v0"]},{"entry":["LinePointWidth","3","37","GEO","CUL",{}]},{"entry":["Multisample","1","40","SRT","CUL, FRG, PIX",{}]},{"entry":["CullFlushOverlap","1","41","GEO","CUL",{}]},{"entry":["DoAlphaTest","1","42","GEO","CUL",{}]},{"entry":["DoABlend","1","43","GEO","CUL",{}]},{"entry":["DepthFunc","3","44","SW","CUL",{}]},{"entry":["DepthTestEnable","1","47","SW","CUL",{}]},{"entry":["DepthMask","1","48","SW","CUL",{}]},{"entry":["dZdx","35","49","STP","CUL","z partial along x; T27.7 (set to zero for points)"]},{"entry":["dZdy","35","84","STP","CUL","z partial along y; T27.7 (set to zero for points)"]},{"entry":["PrimType","2","119","STP","CUL","1 => triangle 2 => line, and 3=> point This is in"]},{"entry":[{},{},{},{},{},"addition to ColorType and ColorEdgeID. This is"]},{"entry":[{},{},{},{},{},"incorporated so that CUL does not have to decode"]},{"entry":[{},{},{},{},{},"ColorType. STP creates unified packets for"]},{"entry":[{},{},{},{},{},"triangles and lines. But they may have different"]},{"entry":[{},{},{},{},{},"aliasing state. So CUL needs to know whether the"]},{"entry":[{},{},{},{},{},"packet is point, line, or triangle."]},{"entry":["LeftValid","1","121","STP","CUL","LeftCorner valid? (don't care for points)"]},{"entry":["RightValid","1","122","STP","CUL","RightCorner valid? (don't care for points)"]},{"entry":["XleftTop","24","123","STP","CUL","Left and right intersects with top tile edge. Also"]},{"entry":[{},{},{},{},{},"contain xCenter for point. Note that these points are"]},{"entry":[{},{},{},{},{},"used to start edge walking on the left and right"]},{"entry":[{},{},{},{},{},"edge respectively. So these may actually be"]},{"entry":[{},{},{},{},{},"outside the edges of the tile. (11.13)"]},{"entry":["XrightTop","24","147","STP","CUL",{}]},{"entry":["YLRTop","8","171","STP","CUL","Bbox Ymax. Tile relative. 5.3"]},{"entry":["XleftCorner","24","179","STP","CUL","x window coordinate of the left corner (unsigned"]},{"entry":[{},{},{},{},{},"fixed point 11.13). (don't care for points)"]},{"entry":["YleftCorner","8","203","STP","CUL","tile-relative y coordinate of left corner (unsigned"]},{"entry":[{},{},{},{},{},"5.3). (don't care for points)"]},{"entry":["XrightCorner","24","211","STP","CUL","x window coordinate of the right corner, unsigned"]},{"entry":[{},{},{},{},{},"fixed point 11.13. (don't care for points)"]},{"entry":["YrightCorner","8","235","STP","CUL","tile-relative y coordinate of right corner 5.3; also"]},{"entry":[{},{},{},{},{},"contains Yoffset for point"]},{"entry":["YBot","8","243","STP","CUL","Bbox Ymin. Tile relative. 5.3"]},{"entry":["DxDyLeft","24","251","STP","CUL","slope of the left edge. T14.9 (don't care for points)"]},{"entry":["DxDyRight","24","275","STP","CUL","slope of the right edge. T14.9 (don't care for points)"]},{"entry":["DxDyBot","24","299","STP","CUL","slope of the bottom edge, T14.9 (don't care for"]},{"entry":[{},{},{},{},{},"points)"]},{"entry":["XrefStamp","3","323","STP","CUL","ref stamp x index on tile (set to zero for points)"]},{"entry":["YrefStamp","3","326","STP","CUL","ref stamp y index on tile (set to zero for points)"]},{"entry":["ZRefTile","32","329","STP","CUL","Ref z value, s28.3"]},{"entry":["XmaxStamp","3","361","STP","CUL","Bbox max stamp x index"]},{"entry":["XminStamp","3","364","STP","CUL","Bbox min stamp x index"]},{"entry":["ymaxStamp","3","367","STP","CUL","Bbox min stamp y index"]},{"entry":["YminStamp","3","370","STP","CUL","Bbox max stamp y index"]},{"entry":["ZminTile","24","373","STP","CUL","min z of the prim on tile"]},{"entry":[{},"402"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},"The inventive apparatus and method provide conservative hidden surface removal (CHSR) in a deferred shading graphics pipeline (DSGP). The pipeline renders primitives, and the invention is described relative to a set of renderable primitives that include: 1) triangles, 2) lines, and 3) points. Polygons with more than three vertices are divided into triangles in the Geometry block (described hereinafter), but the DSGP pipeline could be easily modified to render quadrilaterals or polygons with more sides. Therefore, since the pipeline can render any polygon once it is broken up into triangles, the inventive renderer effectively renders any polygon primitive. The invention advantageously takes into account whether and in what part of the display screen a given primitive may appear or have an effect. To identify what part of a 3D window on the display screen a given primitive may affect, the pipeline divides the 3D window being drawn into a series of smaller regions, called tiles and stamps. The pipeline performs deferred shading, in which pixel colors are not determined until after hidden-surface removal. The use of a Magnitude Comparison Content Addressable Memory (MCCAM) advantageously allows the pipeline to perform hidden geometry culling efficiently.","Implementation of the inventive Conservative Hidden Surface Removal procedure, advantageously maintains compatibility with other standard APIs, such as OpenGL\u00ae, including their support of dynamic rule changes for the primitives (e.g. changing the depth test or stencil test during a scene). In embodiments of the inventive deferred shader, the conventional rendering paradigm, wherein non-deferred shaders typically execute a sequence of rules for every geometry item and then check the final rendered result, is broken. The inventive structure and method anticipate or predict what geometry will actually affect the final values in the frame buffer without having to make or generate all the colors for every pixel inside of every piece of geometry. In principle, the spatial position of the geometry is examined, and a determination is made for any particular sample, the one geometry item that affects the final color in the z buffer, and then generates only that color.","In one embodiment, the CHSR processes each primitive in time order and, for each sample that a primitive touches, CHSR makes conservative decision based on the various Application Program Interface (API) state variables, such as depth test and alpha test. One of the advantageous features of the CHSR process is that color computation does not need to be done during hidden surface removal even though non-depth-dependent tests from the API, such as alpha test, color test, and stencil test can be performed by the DSGP pipeline. The CHSR process can be considered a finite state machine (FSM) per sample. Hereinafter, each per-sample FSM is called a sample finite state machine. Each sample FSM maintains per-sample data including: (1) z coordinate information; (2) primitive information (any information needed to generate the primitive's color at that sample or pixel, or a pointer to such information); and (3) one or more sample state bits (for example, these bits could designate the z value or z values to be accurate or conservative). While multiple z values per sample can be easily used, multiple sets of primitive information per sample would be expensive. Hereinafter, it is assumed that the sample FSM maintains primitive information for one primitive. Each sample FSM may also maintain transparency information, which is used for sorted transparencies.","The DSGP can operate in two distinct modes: 1) time order mode, and 2) sorted transparency mode. Time order mode is designed to preserve, within any particular tile, the same temporal sequence of primitives. In time order mode, time order of vertices and modes are preserved within each tile, where a tile is a portion of the display window bounded horizontally and vertically. By time order preserved, we mean that for a given tile, vertices and modes are read in the same order as they are written. In sorted transparency mode, the process of reading geometry from a tile is divided into multiple passes. In the first pass, the opaque geometry (i.e., geometry that can completely hide more distant geometry) is processed, and in subsequent passes, potentially transparent geometry is processed. Within each sorted transparency mode pass, the time ordering is preserved, and mode data is inserted in its correct time-order location. Sorted transparency mode can spatially sort (on a sample-by-sample basis) the geometry into either back-to-front or front-to-back order, thereby providing a mechanism for the visible transparent objects to be blended in spatial order (rather than time order), resulting in a more correct rendering. In a preferred embodiment, the sorted transparency method is performed jointly by the Sort block and the Cull block.","The inventive structure and method may be implemented in various embodiments. In one aspect, the invention provides structure and method for performing hidden surface removal wherein the structure is advantageously implemented as a computer graphics pipeline and wherein the inventive hidden surface removal method includes the following steps or procedures. First, an object primitive (current primitive) is selected from a group of primitives, each primitive comprising a plurality of stamps. Next, stamps in the current primitive are compared to stamps from previously evaluated primitives in the group of primitives, and a first stamp is selected from the current primitive by the stamp selection process as a current stamp (CS), and optionally by the SAM for performance reasons. CS is compared to a second stamp or a CPVS_selected from previously evaluated stamps that have not been discarded. The second stamp is discarded when no part of the second stamp would affect a final graphics display image based on the comparison with the CS. If part, but not all, of the second stamp would not affect the final image based on the comparison with the CS, then the part of second stamp that would not affect the final image is deleted from the second stamp. The CS is discarded when no part of the second stamp would affect a final graphics display image based on the comparison with the second stamp. If part, but not all, of the CS would not affect the final image based on the comparison with the second stamp, then the part of CS that would not affect the final image is deleted from the CS. When all stamps in all primitives within a region of the display screen have been evaluated, the stamps that have not been discarded have their pixels, or samples, colored by the part of the pipeline downstream from these first steps in performing hidden surface removal. In one embodiment, the set of non-discarded stamps can be limited to one stamp per sample. In this embodiment, when the second stamp and the CS include the same sample and both can not be discarded, the second stamp is dispatched and the CS is kept in the list of non-discarded stamps. Also for this alternate embodiment, when the visibility of the second stamp and the CS depends on parameters evaluated later in the computer graphics pipeline, the second stamp and the CS are dispatched. As an alternate embodiment, the selection of the first stamp by for example the SAM and the stamp selection process, as a current stamp (CS) is based on a relationship test of depth states of samples in the first stamp with depth states of samples of previously evaluated stamps; and an aspect of the inventive apparatus simultaneously performs the relationship test on a multiplicity of stamps.","In another aspect of the inventive structure and method for performing hidden surface removal, a set of currently potentially visible stamps (CPVSs) is maintained separately from the set of current depth values (CDVs), wherein the inventive hidden surface removal method includes the following steps or procedures. First, an object primitive (current primitive) is selected from a group of primitives, each primitive comprising a plurality of stamps. Next, a first stamp from the current primitive is selected as a currently stamp (CS). Next, a currently potentially visible stamp (CPVS) is selected from the set of CPVSs such that the CPVS overlaps the CS. For each sample that is overlapped by both the selected CPVS and the CS, the depth value of the CS is compared to the corresponding value in the set of CDVs, and this comparison operation takes into account the pipeline state and updates the CDVs. Samples in the selected CPVS that are determined to be not visible are deleted for the selected CPVS. If all samples in the selected CPVS are deleted, the selected CPVS is deleted from the set of CPVS's. If any sample in the CS is determined to be visible, the CS is added to the set of the CPVS's with only its visible samples included. If for any sample both the CS and selected CPVS are visible, then at least those visible samples in the selected CPVS are sent down the pipeline for color computations. If the visibility of a sample included in both the CS and CPVS depend on parameters evaluate later in the computer graphics pipeline, at least those samples are sent down the pipeline for color computations. The invention provides structure and method for processing in parallel all CPVS's that overlap the CS. Furthermore, the parallel processing is pipelined such that a CS can be processed at the rate of one CS per clock cycle. Also multiple CS's can be processed in parallel.","In another aspect, the invention provides structure and method for a hidden surface removal system for a deferred shader computer graphics pipeline, wherein the pipeline includes a Magnitude Comparison Content Addressable Memory (MCCAM) Cull unit for identifying a first group of potentially visible samples associated with a current primitive; a Stamp Selection unit, coupled to the MCCAM cull unit, for identifying, based on the first group and a perimeter of the primitive, a second group of potentially visible samples associated with the primitive; a Z-Cull unit, coupled to the stamp selection unit and the MCCAM cull unit, for identifying visible stamp portions by evaluating a pipeline state, and comparing depth states of the second group with stored depth state values; and a Stamp Portion Memory unit, coupled to the Z-Cull unit, for storing visible stamp portions based on control signals received from the Z-Cull unit, wherein the Stamp Portion Memory unit dispatches stamps having a visibility dependent on parameters evaluated later in the computer graphics pipeline.","In yet another aspect, the invention provides structure and method of rendering a graphics image including the steps of receiving a plurality of primitives to be rendered; selecting a sample location; rendering a front most opaque sample at the selected sample location, and defining the z value of the front most opaque sample as Zfar; comparing z values of a first plurality of samples at the selected sample location; defining to be Znear a first sample, at the selected sample location, having a z value which is less than Zfar and which is nearest to Zfar of the first plurality of samples; rendering the first sample; setting Zfar to the value of Znear; comparing z values of a second plurality of samples at the selected sample location; defining as Znear the z value of a second sample at the selected sample location, having a z value which is less than Zfar and which is nearest to Zfar of the second plurality of samples; and rendering the second sample.","FIG. E illustrates a block diagram of Cull block . The Cull block is responsible for: 1) pre-shading hidden surface removal; and 2) breaking down primitive geometry entities (triangles, lines and points) to stamp based geometry entities called Visible Stamp Portions (VSPs). The Cull block does, in general, a conservative culling of hidden surfaces. To facilitate the conservative hidden surface removal process Cull block  does not handle some \u201cfragment operations\u201d such as alpha test and stencil test. Z Cull  can store two depth values per sample, but Z Cull  only stores the attributes of one primitive per sample. Thus, whenever a sample requires blending colors from two pieces of geometry, the Cull block sends the first primitive (using time order) down the pipeline, even though there may be later geometry that hides both pieces of the blended geometry.","The Cull block receives input in the form of packets from the Setup block . One type of packet received by the Cull block is a mode packet. Mode packets provide the Cull block control information including the start of a new tile, a new frame, and the end of a frame. Cull block  also receives Setup Output Primitive Packets. The Setup Output Primitive Packets each describe, on a per tile basis, either a triangle, a line or a point. The data field in Setup Output Primitive Packets contain bits to indicate the primitive type (triangle, line or point). The interpretation of the rest of the geometry data field depends upon the primitive type. A non-geometry data field contains the Color Pointer and mode bits that control the culling mode that can be changed on a per primitive bases. Mode packets include mode bits that indicate whether alpha test is on, whether Z buffer write is enabled, whether culling is conservative or accurate, whether depth test is on, whether blending is on, whether a primitive is anti-aliased and other control information.","Sort block  bins the incoming geometry entities to tiles. Setup block  pre-processes the primitives to provide more detailed geometric information for the Cull block to do the hidden surface removal. Setup block  pre-calculates the slope value for all the edges, the bounding box of the primitive within the tile, minimum depth value (front most) of the primitive within the tile, and other relevant data. Prior to Sort, Mode Extraction block  has already extracted the color, light, texture and related mode data, the Cull block only gets the mode data that is relevant to the Cull block and a pointer, called Color Pointer, that points to color, light and texture data stored in Polygon Memory .","The Cull block performs two main functions. The primary function is to remove geometry that is guaranteed to not affect the final results in Frame Buffer  (i.e., a conservative form of hidden surface removal). The second function is to break primitives into units of Visible Stamp Portions (VSP). A stamp portion is the intersection of a primitive with a given stamp. A VSP is a visible portion of a geometry entity within a stamp. In one embodiment, each stamp is comprised of four pixels, and each pixel has four predetermined sample points. Thus each stamp has 16 predetermined sample points. The stamp portion \u201csize\u201d is then given by the number and the set of sample points covered by a primitive in a given stamp.","The Cull block sends one VSP at a time to the Mode Injection block . Mode Injection block  reconnects the VSP with its color, light and texture data and sends it to Fragment  and later stages in the pipeline.","The Cull block processes primitives one tile at a time. However, for the current frame, the pipeline is in one of two modes: 1) time order mode; or 2) sorted transparency mode. In time order mode, the time order of vertices and modes are preserved within each tile, and the tile is processed in a single pass through the data. That is, for a given tile, vertices and modes are read in the same order as they are written, but are skipped if they do not affect the current tile. In sorted transparency mode, the processing of each tile is divided into multiple passes, where, in the first pass, guaranteed opaque geometry is processed (the Sort block only sends non-transparent geometry for this pass). In subsequent passes, potentially transparent geometry is processed (the Sort block repeatedly sends all the transparent geometry for each pass). Within each pass, the time ordering is preserved, and mode data is inserted in its correct time-order location.","In time order mode, when there is only \u201csimple opaque geometry\u201d (i.e. no scissor testing, alpha testing, color testing, stencil testing, blending, or logicop) in a tile, the Cull block will process all the primitives in the tile before dispatching any VSPs to Mode Injection. This is because the Cull block hidden surface removal method can unambiguously determine, for each sample, the single primitive that covers (i.e., colors) that sample. The case of \u201csimple opaque geometry\u201d is a typically infrequent special case.","In time order mode, when the input geometry is not limited to \u201csimple opaque geometry\u201d within a tile, this may cause early dispatch of VSPs (an entire set of VSPs or selected VSPs). However, without exception all the VSPs of a given tile are dispatched before any of the VSPs of a different tile can be dispatched. In general, early dispatch is performed when more than one piece of geometry could possibly affect the final tile values (determined by Pixel block ) for any sample.","In sorted transparency mode, each tile is processed in multiple passes (assuming there is at least some transparent geometry in the tile). In each pass, there is no early dispatch of VSPs.","If the input packet is a Setup Output Primitive Packet, a PrimType parameter indicates the primitive type (triangle, line or point). The spatial location of the primitive (including derivatives, etc.) is done using a \u201cunified description\u201d. That is, the packet describes the primitive as a quadrilateral (not screen aligned), and triangles and points are degenerate cases. This \u201cunified description\u201d is described in more detail in the provisional patent application entitled \u201cGraphics Processor with Deferred Shading,\u201d filed Aug. 20, 1998, which is hereby incorporated by reference. The packet includes a color pointer, used by Mode Injection. The packet also includes several mode bits, many of which can change primitive by primitive. The following are considered to be \u201cmode bits\u201d, and are input to state machines in Z Cull : CullFlushOverlap, DoAlphaTest; DoABlend, DepthFunc, DepthTestEnabled, DepthTestMask, and NoColor.","In addition to Setup Output Primitive Packets, Cull block  receives the following packet types: Setup Output Clear Packet, Setup Output Cull Packet, Setup Output Begin Frame Packet, Setup Output End Frame Packet, Setup Output Begin Tile Packet, and Setup Output Tween Packet. Each of these packet types is described in detail in the Detailed Description of Cull Block section. But, collectively, these packets are referred to as \u201cmode packets.\u201d","In operation, when Cull block  receives a primitive, Cull attempts to eliminate it by querying the Magnitude Comparison Content Addressable Memory (MCCAM) Cull , shown in FIG. E, with the primitive's bounding box. If MCCAM Cull  indicates that a primitive is completely hidden within the tile, then the primitive is eliminated. If MCCAM Cull  cannot reject the primitive completely, it will generate a stamp list, each stamp in the list may contain a portion of the primitive that may be visible. This list of potentially visible stamps is sent to the Stamp Selection Logic  of Cull block . Stamp Selection Logic  uses the geometry data of the primitive to determine the set of stamps within each stamp row of the tile that are actually touched by the primitive. Combined with the stamp list produced by MCCAM Cull , the Stamp Selection Logic unit dispatches one potentially visible stamp  at a time to the Z Cull block . Each stamp is divided into a grid of 16 by 16 sub-pixels. Each horizontal grid line is called a subraster line. Each of the 16 sample points per stamp has to fall (for antialiased primitives) at the center of one of the 256 possible sub-pixel locations. Each pixel has four sample points within its boundary, as shown with stamp  in FIG. EA. (FIG. EB and FIG. E C illustrate the manner in which the Stamp Portion is input into the Z-Cull process and as stored in SPM, respectively.) Sample locations within pixels can be made programmable. With programmable sample locations, multiple processing passes can be made with different sample locations thereby increasing the effective number of samples per pixel. For example, four passes could be performed with four different sets of sample locations, thereby increasing the effective number of samples per pixel to fourteen.","The display image is divided into tiles to more efficiently render the image. The tile size as a fraction of the display size can be defined based upon the graphics pipeline hardware resources.","The process of determining the set of stamps within a stamp row that is touched by a primitive involves calculating the left most and right most positions of the primitive in each subraster line that contains at least one sample point. These left most and right most subraster line positions are referred to as XleftSubSand XrightSubSwhich stands for x left most subraster line for sample i and x right most subraster line for sample i respectively. Samples are numbered from 0 to 15. The determination of XleftSubSand XrightSubSis typically called the edge walking process. If a point on an edge (x, y) is known, then the value of x corresponding to the y position of y can easily be determined by:",{"@attributes":{"id":"p-1226","num":"1252"},"maths":{"@attributes":{"id":"MATH-US-00017","num":"00017"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mrow":[{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"},{"mrow":{"mo":["(",")"],"mrow":{"mrow":[{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"},{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}],"mo":"-"}},"mo":"*","mfrac":{"mrow":[{"mo":"\u2146","mi":"x"},{"mo":"\u2146","mi":"y"}]}}],"mo":"+"}],"mo":"="}}},"br":{},"sub":["i ","i "],"b":"9012"},"Z Cull unit  receives one stamp number (or StampID) at a time. Each stamp number contains a portion of a primitive that may be visible as determined by MCCAM Cull . The set of 16 pairs of XleftSubSand XrightSubSare used to determine which of the 16 sample points are covered by the primitive. Sample i is covered if Xsample, the x coordinate value of sample i satisfies:\n\nXletSubS,\u2266Xsample,<XrightSubS.\n","For each sample that is covered, the primitive's z value is computed at that sample point. At the same time, the current z values and z states for all 16 sample points are read from the Sample Z buffer .","Each sample point can have a z state of \u201cconservative\u201d or \u201caccurate\u201d. Alpha test, and other tests, are performed by pipeline stages after Cull block . Therefore, for example, a primitive that may appear to affect the final color in the frame buffer based on depth test, may in fact be eliminated by alpha test before the depth test is performed, and thus the primitive does not affect the final color in the frame buffer. To account for this, the Cull block  uses conservative z values. A conservative z value defines the outer limit of a z value for a sample based on the geometry that has been processed up to that point. A conservative z value means that the actual z value is either at that point or at a smaller z value. Thus the conservative z is the maximum z value that the point can have. If the depth test is render if greater than, then the conservative z value is a minimum z value. Conversely, if the depth test is render if less than, then the conservative z value is a maximum z value. For a render if less than depth test, any sample for a given sample location, with a z value less than the conservative z is thus a conservative pass because it is not known at that point in the processes whether it will pass.","An accurate z value is a value such that the surface which that z represents is the actual z value of the surface. With an accurate z it is known that the z value represents a surface that is known to be visible and anything in front of it is visible and everything behind it is obscured, at that point in the process. The status of a sample is maintained by a state machine, and as the process continues the status of a sample may switch between accurate and conservative. In one embodiment, a single conservative z value is used. In another embodiment, two z values are maintained for each sample location, a near z value (Znear) and a far z value (Zfar). The far z value is a conservative z value, and the near z value is an optimistic z value. Using two z values allows samples to be determined to be accurate again after being labeled as conservative. This improves the efficiency of the pipeline because an accurate z value can be used to eliminate more geometry than a conservative z value. For example, if a sample is received that is subject to alpha test, in the Cull block it is not known whether the sample will be eliminated due to alpha test. In an embodiment where only one z value is stored, the z value may have to be made conservative if the position of the sample subject to alpha test would pass the depth test. The sample that is subject to alpha test is then sent down the pipeline. Since, the sample subject to alpha test is not kept, the z value of the stored sample cannot later be converted back to accurate. By contrast, in an embodiment where two z values are stored, the sample subject to alpha test can, depending on its relative position, be stored as the Zfar\/Znear sample. Subsequent samples can then be compared with the sample subject to alpha test as well as the second stored sample. If the Cull block determines, based on the depth test, that one of the subsequent samples, such as an opaque sample in front of the sample subject to alpha test, renders the sample subject to alpha test not visible, then that subsequent sample can be labeled as accurate.","In OpenGL\u00ae primitives are processed in groups. The beginning and ending of a group of pimitives are identified by the commands, begin and end respectively. The depth test is defined independently for each group of primitives. The depth test is one component of the pipeline state.","Each sample point has a Finite State Machine (FSM) independent of other samples. The z state combined with the mode bits received by Cull drive the sample FSMs. The sample FSMs control the comparison on a per sample basis between the primitive's z value and the Z Cull  z value. The result of the comparison is used to determine whether the new primitive is visible or hidden at each sample point that the primitive covers. The maximum of the 16 sample points'z value is used to update the MCCAM Cull .","A sample's FSM also determines how the Sample Z Buffer in Z Cull  should be updated for that sample, and whether the sample point of the new VSP should be dispatched early. In addition, the sample FSM determines if any old VSP that may contain the sample point should be destroyed or should be dispatched early. For each sample Z Cull  generates four control bits that describe how the sample should be processed, and sends them to the Stamp Portion Mask unit . These per sample control bits are: SendNew, KeepOld, SendOld, and NewVSPMask. If the primitive contains a sample point that is visible, then a NewVSPMask control bit is asserted which causes Stamp Portion Memory (SPM)  to generate a new VSP coverage mask. The remaining three control bits determine how SPM  updates the VSP coverage mask for the primitive.","In sorted transparency mode, geometry is spatially sorted on a per-sample basis, and, within each sample, is rendered in either back-to-front or front-to-back order. In either case, only geometry that is determined to be in front of the front-most opaque geometry needs to be send down the pipeline, and this determination is done in Cull .","In back-to-front sorted transparency mode, transparent primitives are rasterized in spatial order starting with the layer closest to the front most opaque layer instead of the regular mode of time order rasterization. Two z values are used for each sample location, Zfar and Znear. In sorted transparency mode the transparent primitives go through Z Cull unit  several times. In the first pass, Sort block , illustrated in FIG. E, sends only the opaque primitives. The z values are updated as described above. The z values for opaque primitives are referred to as being of type Zfar. At the end of the pass, the opaque VSPs are dispatched. The second time Sort block  only sends the transparent primitives for the tile to Cull block . Initially the Znear portion of the Sample Z Buffer are preset to the smallest z value possible. A sample point with a z value behind Zfar is hidden, but a z value in front of Zfar and behind Znear is closer to the opaque layer and therefore replaces the current Znear's z value. This pass determines the z value of the layer that is closest to the opaque layer. The VSPs representing the closest to opaque layer are dispatched. The roles of Znear and Zfar are then switched, and Z Cull receives the second pass of transparent primitives. This process continues until Z Cull determines that it has processed all possible layers of transparent primitives. Z Cull in sorted transparent mode is also controlled by the sample finite state machines.","In back-to-front sorted transparency mode, for any particular tile, the number of transparent passes is equal to the number of visible transparent surfaces. The passes can be done as:\n\n","In front-to-back sorted transparency mode, for any particular tile, the number of transparent passes can be limited to a preselected maximum, even if the number of visible transparent surfaces at a sample is greater. The passes can be done as:\n\n","The efficiency of CUL is increased (i.e., fewer fragments sent down the pipeline) in front-to-back sorted transparency mode, especially when there are lots of visible depth complexity for transparent surfaces. Also, this may enhance image quality by allowing the user to discern the front-most N transparencies, rather than all those in front of the front-most opaque surface.","The stamp portion memory block  contains the VSP coverage masks for each stamp in the tile. The maximum number of VSPs a stamp can have is 16. The VSP masks should be updated or dispatched early when a new VSP comes in from Z Cull . The Stamp Portion Mask unit performs the mask update or dispatch strictly depending on the SendNew, KeepOld and SendOld control bits. The update should occur at the same time for a maximum of 16 old VSPs in a stamp because a new VSP can potentially modify the coverage mask of all the old VSPs in the stamp. The Stamp Portion Data unit  contains other information associated with a VSP including but not limited to the Color Pointer. The Stamp Portion Data memory also needs to hold the data for all VSPs contained in a tile. Whenever a new VSP is created, its associated data need to be stored in the Stamp Portion Data memory. Also, whenever an old VSP is dispatched, its data need to be retrieved from the Stamp Portion Data memory.","Detailed Description of Cull Block","FIG. E illustrates a detailed block diagram of Cull block . Cull block  is composed of the following components: Input FIFO , MCCAM Cull , Subrasterizer , Column Selection , MCCAM Update , Sample Z buffer , New VSP Queue , Stamp Portion Memory Masks  and , Stamp Portion Memory Data units  and , Dispatch Queues  and , and Dispatch Logic .","Mode and Data Packets","The operation of the Cull components is determined by the packets received by the Cull block. The following describes the mode packets:\n\n","In addition to the mode packets, the Cull block also receives Setup Output Primitive Packets, as illustrated in FIG. E.","The Setup Output Primitive Packets each describe, on a per tile basis, either a triangle, a line, or a point. More particularly, the data field in Setup Output Primitive Packets contain bits to indicate the primitive type (triangle, line, or point). The interpretation of the rest of the geometry data field depends upon the primitive type.","If the input packet is a Setup Output Primitive Packet, a PrimType parameter indicates the primitive type (triangle, line or point). The spatial location of the primitive (including derivatives, etc.) is specified using a unified description. That is, the packet describes the primitive as a quadrilateral (non-screen aligned), no matter whether the primitive is a quadrilateral, triagle, or point, and triangles and points are treated as degenerate cases of the quadralateral. The packet includes a color pointer, used by the Mode Injection unit. The packet also includes several mode bits, many of which can change state on a primitive by primitive basis. The following are considered to be \u201cmode bits\u201d, and are input to state machines in Z Cull : CullFlushOverlap, DoAlphaTest; DoABlend, DepthFunc, DepthTestEnabled, DepthTestMask, and NoColor.","The Cull components are described in greater detail in the following sections.","Input FIFO",{"@attributes":{"id":"p-1247","num":"1286"},"figref":"FIG. 16","b":["9000","14","9050","8000","9050","9160"]},"MCCAM Cull","The MCCAM Cull unit  uses an MCCAM array  to perform a spatial query on a primitive's bounding box to determine the set of stamps within the bounding box that may be visible. The Setup block  determines the bounding box for each primitive, and determines the minimum z value of the primitive inside the current tile, which is referred to as ZMin.  illustrates a sample tile including a primitive  and a bounding box  in MCCAM. MCCAM Cull  uses ZMin to perform z comparisons. MCCAM Cull  stores the maximum z value per stamp of all the primitives that have been processed. MCCAM Cull  then compares in parallel ZMin for the primitive with all the ZMaxes for every stamp. Based on this comparison, MCCAM Cull determines (a) whether the whole primitive is hidden, based on all the stamps inside the simple bounding box; or (b) what stamps are potentially visible in that bounding box, step . FIG. EB shows the largest z values (ZMax) for each stamp in the file.  shows the results of the comparison. Stamps where ZMin\u2266ZMax are indicated with a one, step . These are the potentially visible stamps. MCCAM Cull also identifies each row which has a stamp with ZMin\u2266ZMax, step . These are the rows that the Stamp Selection Logic unit  needs to process. Stamp Selection Logic unit  skips the rows that are identified with a zero.","MCCAM Cull can process one primitive per cycle from the input FIFO . Read operations from the FIFO occur when the FIFO is not empty and either the last primitive removed is completely hidden as determined by MCCAM Cull or the last primitive is being processed by the Subrasterizer unit . In other words, MCCAM Cull does not \u201cwork ahead\u201d of the Subrasterizer. Rather, MCCAM Cull only gets the next primitive that the Subrasterizer needs to process, and then waits.","In an alternative embodiment, Cull block  does not include an MCCAM Cull unit . In this embodiment, the Stamp Selection Logic unit  processes all of the rows.","Subrasterizer within the Stamp Selection Logic","Subrasterizer  is the unit that does the edge walking (actually, the computation is not iterative, as the term \u201cwalking\u201d would imply). Each cycle, Subrasterizer  obtains a packet from MCCAM Cull . One type of packet received by the Cull block is the Setup Output Primitive Packet, illustrated in FIG. E. Setup Output Primitive Packets include row numbers and row masks generated by MCCAM Cull  which indicate the potentially visible stamps in each row. Subrasterizer  also receives the vertex and slope data it needs to compute the the left most and right most positions of the primitive in each subraster line that contains at least one sample point, XleftSubSand XrightSubS. Subrasterizer  decodes the PrimitiveType field in the Setup Output Primitive Packet to determine if a primitive is a triangle, a line or a point, based on this information Subrasterizer  determines whether the primitive is anti-aliased. Referring to FIG. E, for each row of stamps that MCCAM Cull indicates is potentially visible (using the row selection bits ), Subrasterizer  simultaneously computes the XleftSuband XrightSubfor each of the sample points in the stamp, in a preferred embodiment there are 16 samples per stamp, step . Each pair of XleftSuband XrightSubdefine a set of stamps in the row that is touched by the primitive, which are referred to as a sample row mask. For example, FIG. E illustrates a set of XleftSuband XrightSub.","Referring to FIG. E, each stamp in the potentially visible rows that is touched by the primitive is indicated by setting the corresponding stamp coverage bit  to a one (\u201c1\u201d), as shown in tile . Subrasterizer  logically OR's the sixteen row masks to get the set of stamps touched by the primitive. Subraster  then ANDs the touched stamps with the stamp selection bits , as shown in tile , to form one touched stamp list, which is shown in tile , step . The Subrasterizer passes a request to MCCAM Cull for each stamp row, and receives a potentially visible stamp list from MCCAM Cull. The visible stamp list is combined with the touched stamp list, to determine the final potentially visible stamp set in a stamp row, step . For each row, the visible stamp set is sent to the Column Selection block  of Stamp Selection Logic unit . The Subrasterizer can process one row of stamps per cycle. If a primitive contains more than one row of stamps then the Subrasterizer takes more than one cycle to process the primitive and therefore will request MCCAM to stall the removal of primitives from the Input FIFO. The Subrasterizer itself can be stalled if a request is made by the Column Selection unit.","FIG. E illustrates a stamp , containing four pixels , ,  and . Each pixel is divided into 8\u00d78 subraster grid. The grid shown in FIG. E shows grid lines located at the mid-point of each subraster step. In one embodiment, samples are located at the center of a unit grid, as illustrated by samples - in FIG. E designated by the circled numbers (e.g. {circle around (1)}). Placing the samples in this manner, off grid by one half of a subraster step, avoids the complications of visibility rules that apply to samples on the edge of a polygon. In this embodiment, polygons can be defined to go to the edge of a subraster line or pixel boundary, but samples are restricted to positions off of the subraster grid. In a further embodiment, two samples in adjacent pixels are placed on the same subraster. This simplifies sample processing by reducing the number of XleftSuband XrightSubby a factor of two.","Column Selection within Stamp Selection Logic","Tthe Column Selection unit , shown in FIG. E, tells the Z Cull unit  which stamp to process in each clock cycle. If a stamp row contains more than one potentially visible stamp, the Column Selection unit requests that the Subrasterizer stall.","Z Cull","The Z Cull unit  contains the Sample Z Buffer unit  and Z Cull Sample State Machines , shown in FIG. E. The Sample Z Buffer unit  stores all the data for each sample in a tile, including the z value for each sample, and all the the sample FSM state bits. To enable the Z Cull Sample State Machines  to process one stamp per cycle, Z Cull unit  accesses the z values for all 16 sample points in a stamp in parallel and also computes the new primitive's z values at those sample points in parallel.","Z Cull unit  determines whether a primitive covers a particular sample point i by comparing the sample point x coordinate, Xsample, with the XlefSuband XrightSubvalues computed by the Subrasterizer. Sample i is covered if and only if XlefSub\u2266Xsample<XrightSub, step . Z Cull unit  then computes the z value of the primitive at those sample points, step , and compares the resulting z values to the corresponding z values stored in the Sample Z Buffer for that stamp, step . Generally if the sample point z value is less than the z value in the Z Buffer then the sample point is considered to be visible. However, an API can allow programmers to specify the comparison function (>, \u2267, <, \u2266, always, never). Also, the z comparison can be affected by whether alpha test or blending is turned on, and whether the pipeline is in sorted transparency mode.","The Z Cull Sample State Machines  includes a per-sample FSM for each sample in a stamp. In an embodiment where each stamp consists of 16 samples, there are 16 Z Cull Sample State Machines  that each determine in, parallel how to update the z value and sample state for the sample in the Z buffer it controls, and what action to take on the previously processed VSPs that overlap the sample point. Also in sorted transparency mode the Z Cull Sample State Machines determine whether to perform another pass through the transparent primitives.","Based on the results of the comparison between the z value of the primitive at the sample points and the corresponding z values stored in the Sample Z Buffer for that stamp, the current Cull mode bits and the states of the sample state machines, the Sample Z Buffer is updated, step . For each sample, the sixteen Z Cull Sample State Machines output the control bits: KeepOld, SendOld, NewVSPMask, and SendNew, to indicate how a sample is to be processed, step . The set of NewVSPMask bits (16 of them) constitute a new stamp portion (SP) coverage mask, step . The new stamp portion is dispatched to the New VSP Queue. In the event that the primitive is not visible at all in the stamp (all NewVSPMask bits are FALSE), then nothing is sent to the New VSP Queue. If more than one sample may affect the final sample position final value, then the stamp portions containing a sample for the sample position are early dispatched, step . All of the control bits for the 16 samples in a stamp are provided to Stamp Portion Memory  in parallel.","Samples are sent down the pipeline in VSPs, e.g. as part of a group comprising all of the currently visible samples in a stamp. When one sample within a stamp is dispatched (either early dispatch or end-of-tile dispatch), other samples within the same stamp and the same primitive are also dispatched as a VSP. While this causes more samples to be sent down the pipeline, it generally causes a net decrease in the amount of color computation. This is due to the spatial coherence within a pixel (i.e., samples within the same pixel tend to be either visible together or hidden together) and a tendency for the edges of polygons with alpha test, color test, stencil test, and\/or alpha blending to potentially split otherwise spatially coherent stamps. That is, sending additional samples down the pipeline when they do not appreciably increase the computational load is more than offset by reducing the total number of VSPs that need to be sent.","FIGS. EA-ED illustrate an example of the operation of an embodiment of Z Cull . As illustrated in FIG. EA primitive  is the first primitive in tile . Z Cull  therefore updates all the z values touched by the primitive and stores 35 stamp portions into Stamp Portion Memory . In FIG. EB a second primitive  is added to tile . Primitive  has lower z values than primitive . Z-Cull  processes the 27 stamps touched by primitive . FIG. EC illustrates the 54 stamp portions stored in Stamp Portion Memory  after primitive  is processed. The 54 stamp portions are the sum of the stamps touched by primitives  and  minus eight stamp portions from primitive  that are completely removed. Region  in FIG. ED indicates the eight stamp portions that are removed, which are the stamp portions wherein the entire component of the stamp portion touched by primitive  is also touched by primitive  which has lesser Z values.","In one embodiment, Z Cull  maintains one z value for each sample, as well as various state bits. In another embodiment, Z Cull  maintains two z values for each sample, the second z value improves the efficiency of the conservative hidden surface removal process. Z Cull  controls Stamp Portion Memory , but z values and state bits are not associated with stamp portions. Stamp Portion Memory  can maintain 16 stamp portions per stamp, for a total of 256 stamp portions per tile.","Z Cull  outputs the four bit control signal (SendNew, KeepOld and SendOld and NewVSPMask) to Stamp Portion Memory  that controls how the sample is processed. KeepOld indicates that the corresponding sample in Stamp Portion Memory  is not invalidated. That is, if the sample is part of a stamp portion in Stamp Portion Memory , it is not discarded. SendOld is the early dispatch indicator. If the sample corresponding to a SendOld bit belongs to a stamp portion in Stamp Portion Memory , then this stamp portion is sent down the pipeline. SendOld is only asserted when KeepOld is asserted. NewVSPMask is asserted, when the Z Cull  process determines this sample is visible (at that point in the processing) and a new stamp portion needs to be created for the new primitive, which is done by Stamp Portion Memory  when it receives the signal. SendNew is asserted when the Z Cull  process determines the sample is visible (at that point in the processing) and needs to be sent down the pipeline. SendNew causes an early dispatch of a stamp portion in the new primitive.","FIG. E illustrates an example of how samples are processed by Z Cull . Primitive  is processed in tile  before primitive . Primitive  has lesser z values than primitive  and is therefore in front of primitive . For the seven samples in oval region  Z Cull  sets the KeepOld control bits to zero, and the NewVSPMask control bits to one.","FIGS. EA-ED illustrate an example of early dispatch. Early dispatch is the sending of geometry down the pipeline before all geometry in the tile has been processed. In sorted transparency mode early dispatch is not used. First a single primitive , illustrated in  is processed in tile . Primitive  touches 35 stamps, and these are stored in Stamp Portion Memory . A second primitive, , with lesser z values is then added with the mode bit DoABlend asserted. The DoABlend mode bit indicates that the colors from the overlapping stamp portions should be blended. Z Cull  then processes the 27 stamps touched by primitive . Z Cull  can be designed so that samples from up to N primitives can be stored for each stamp. In one embodiment samples from only one primitive are stored for each stamp. FIG. EC illustrates the stamp portions in Stamp Portion Memory  after primitive  is processed. FIG. ED illustrates the 20 visible stamp portions touched by region  that are dispatched early from primitive  because the stamp portion z values were replaced by the lesser z values from primitive .","FIG. E illustrates a sample level example of early dispatch processing. Stamp  includes part of primitive  and part of primitive , both of which are shown in FIG. EB. The samples in region  all are touched by primitive  which has lesser z values than primitive . Therefore, for these seven samples Z Cull  outputs the control signal SendOld. In one embodiment, if Z Cull  determines that one sample in a stamp should be sent down the pipeline then Z Cull  sends all of the samples in that stamp down the pipeline so as to preserve spatial coherency. This is also minimizes the number of fragments that are sent down the pipeline. In another embodiment this approach is applied at a pixel level, wherein if Z Cull  determines that any sample in a pixel should be sent down the pipeline all of the samples in the pixel are sent down the pipeline.","In a cull process where everything in a scene is an opaque surface, after all the surfaces have been processed, only the stamp portions that are visible are left in Stamp Portion Memory . The known visible stamp portions are then sent down the pipeline. However, when an early dispatch occurs, the early dispatch stamp portions are sent down the pipeline right away.","For each stamp a reference called Zref is generated. In one embodiment, the Zref is placed at the center of the stamp. The values \u2202z\/\u2202x and \u2202z\/\u2202y at the Zref point are also computed. These three values are sent down the pipeline to Pixel block . Pixel block  does a final z test. As part of the final z test, Pixel block  re-computes the exactly equivalent z values for each sample using the Zref value and the \u2202z\/\u2202x and \u2202z\/\u2202y values using the equation:",{"@attributes":{"id":"p-1270","num":"1309"},"maths":{"@attributes":{"id":"MATH-US-00018","num":"00018"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":"z","mn":"1"},"mo":"=","mrow":{"mi":"Zref","mo":["+","+"],"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","mi":"z"},{"mo":"\u2202","mi":"y"}]},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"y","mn":"1"},{"mi":["y","ref"]}],"mo":"-"}}},{"mfrac":{"mrow":[{"mo":"\u2202","mi":"z"},{"mo":"\u2202","mi":"x"}]},"mo":"\u2062","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"x","mn":"1"},{"mi":["x","ref"]}],"mo":"-"}}}]}}}},"br":[{},{}],"b":["9012","15000","9012"]},"MCCAM Update unit , shown in FIG. E, determines the maximum of the sixteen updated z values for the sixteen sample points in each stamp and sends it to the MCCAM Cull unit to update the MCCAM array .","New VSP Queue","Each clock cycle, Z Cull unit  generates the four sets of four control bits (KeepOld, SendOld, NewVSPMask, and SendNew) per stamp portion. Thus Z Cull  processes one stamp per primitive per cycle, but not all of the stamps processed are visible, only the Visible Stamp Portions (VSPs) are sent into New VSP Queue . The input rate to New VSP Queue  is therefore variable. Under \u201cideal\u201d circumstances, the SPM Mask and Valid unit  can store one new stamp portion every clock cycle. However, the SPM Mask and Valid unit  requires multiple clocks for a new stamp portion when early dispatch of VSPs occurs. When VSPs are dispatched early, New VSP Queue  stores the new stamp portions, thus allowing Z Cull  to proceed without stalling. One new VSP may cause the dispatch of up to 16 old VSPs, so the removal rate from the New VSP Queue is also variable.","In one embodiment, New VSP Queue  is only used with early dispatches. The SPM Mask and Valid unit handles one VSP at a time. The New VSP Queue ensures stamp portions are available for Z Cull  when an early dispatch involves more than one VSP. Based upon performance analysis, typically about 450 stamps are expected to be touched in a tile. The depth complexity of a scene refers to the average number of times a pixel in the scene needs to be rendered. With a depth complexity of two, 225 VSPs would be expected to be provided as output from Z Cull  per tile. Therefore on average about four VSPs are expected per stamp. A triangle with blend turned on covering a 50 pixel area can touch on average three tiles, and the number of stamps it touches within a tile should be less than eight. Therefore, in one embodiment, the New VSP Queue depth is set to be 32.","The link between Z Cull unit  and Stamp Portion Memory  through New VSP Queue  is unidirectional. By avoiding using a feedback loop New VSP Queue  is able to process samples in each cycle.","SPM Mask and Valid","The active Stamp Portion Memory (SPM) Mask and Valid unit  stores the VSP coverage masks for the tile. Each VSP entry includes a valid bit to indicate if there is a valid VSP stored there. The valid bits for the VSPs are stored in a separate memory. The Stamp Portion Memory Mask and Valid unit  is double buffered (i.e. there are two copies  and ) as shown in FIG. E. The Memory Mask and Valid Active State unit  contains VSPs for the current tile while the Memory Mask and Valid Dispatch State unit page  contains VSPs from the previous tile (currently being dispatched). As a new VSP is removed from the New VSP Queue, the active state SPM Mask and Valid unit  updates the VSP Mask for the VSPs that already exist in its mask memory and adds the new VSP to the memory content. When color blending or other conditions occur that require early dispatch, the active state SPM Mask and Valid unit dispatches VSPs through the active SPM Data unit  to the dispatch queue. The operations performed in the mask update or early dispatch are controlled by the KeepOld, SendOld, SendNew and NewVSPMask control bits generated in Z Cull . In sorted transparency mode, the SendOld and SendNew mask bits are off. VSP coverage masks are mutually exclusive, therefore if a new VSP has a particular coverage mask bit turned on, the corresponding bit for all the previously processed VSPs in the stamp have to be turned off.","The state transition from active to dispatch and vice versa is controlled by mode packets. Receiving a packet signaling the end of a tile (Begin Tile, End Frame, Buffer Clear, or Cull Packet with CullFlushAll set to TRUE) causes the active state Stamp Portion Memory to switch over to dispatch state and vice versa. The page in dispatch state cycles through each stamp and sends all VSPs to the SPM Data unit, which forwards them to the dispatch queue. In an alternative embodiment, the Stamp Portion Memory Mask and Valid unit  is triple buffered.","The SPM Data","The active Stamp Portion Memory Data unit  stores the Zstamp, dz\/dx, dz\/dy and the Color Pointer for every VSP in the tile. The Stamp Portion Memory Data unit is also double buffered. The SPM Mask and Valid unit  sends new VSP information to the SPM Data unit . The VSP information includes control signals that instruct the SPM Data unit  to either send the new VSP or save the new VSP to its memory. If the new VSP should be saved, the SPM Mask and Valid unit control signals also determine which location among the 16 possible slots the new VSP should occupy. In addition, for the case of early dispatch, the SPM Data unit also gets a list of old VSP locations and the associated VSP Masks that need early dispatch. The SPM Data unit first checks to see if there are any old VSPs that need to be dispatched. If the SPM Data unit finds any, it will read the VSP data from its memory, merge the VSP data with the VSP Mask sent from the SPM Mask and Valid unit, and put the old VSPs into the dispatch queue. The SPM Data unit then checks if the new VSP should also be sent, and if it is affirmative, then it passes the new VSP data to the dispatch queue . If the new VSP should not be sent, then the SPM Data unit writes the new VSP data into its memory.","The Dispatch Queue and Dispatch Logic","The Dispatch Logic unit  sends one entry's worth of data at a time from one of the two SPM dispatch queues ,  to the Mode Injection unit . The Dispatch Logic unit  requests dispatch from the dispatch state SPM unit first. After the dispatch state SPM unit has exhausted all of its VSPs, the Dispatch Logic unit  requests dispatch from the active state SPM dispatch queue.","Alpha Test","Alpha test compares the alpha value of a given pixel to an alpha reference value. The alpha reference value is often used to indicate the transparency value of a pixel. The type of comparison may be specified, so that for example the comparison may be a greater-than operation, a less-than operation, or other arithmetic, algebraic, or logical comparison, and so forth. If the comparison is a greater-than operation, then a pixel's alpha value has to be greater than the reference to pass the alpha test. For instance, if a pixel's alpha value is 0.9, the reference alpha is 0.8, and the comparison is greater-than, then that pixel passes the alpha test. Any pixel not passing the alpha test is discarded.","Alpha test is a per-fragment operation and in a preferred embodiment is performed by the Pixel block after all of the fragment coloring calculations, lighting operations and shading operations are completed. FIG. E illustrates an example of processing samples with alpha test with a CHSR method. This diagram illustrates the rendering of six primitives (Primitives A, B, C, D, E, and F) at different z coordinate locations for a particular sample, rendered in the following order (starting with a \u201cdepth clear\u201d and with \u201cdepth test\u201d set to less-than): primitives A, B, and C (with \u201calpha test\u201d disabled); primitive D (with \u201calpha test\u201d enabled); and primitives E and F (with \u201calpha test\u201d disabled). Note from the illustration that z>z>z>z>z>z, such that primitive A is at the greatest z coordinate distance. Also note that alpha test is enabled for primitive D, but disabled for each of the other primitives.","The steps for rendering these six primitives under a conservative hidden surface removal process with alpha test are as follows:","Step 1: The depth clear causes the following result in each sample finite state machine: 1) z values are initialized to the maximum value; 2) primitive information is cleared; and 3) sample state bits are set to indicate the z value is accurate.","Step 2: When primitive A is processed by the sample FSM, the primitive is kept (i.e., it becomes the current best guess for the visible surface), and this causes the sample FSM to store: 1) the z value zas the \u201cnear\u201d z value; 2) primitive information needed to color primitive A; and 3) the z value (z) is labeled as accurate.","Step 3: When primitive B is processed by the sample FSM, the primitive is kept (its z value is less-than that of primitive A), and this causes the sample FSM to store: 1) the z value zas the \u201cnear\u201d z value (zis discarded); 2) primitive information needed to color primitive B (primitive A's information is discarded); and 3) the z value (z) is labeled as accurate.","Step 4: When primitive C is processed by the sample FSM the primitive is discarded (i.e., it is obscured by the current best guess for the visible surface, primitive B), and the sample FSM data is not changed.","Step 5: When primitive D (which has alpha test enabled) is processed by the sample FSM, the primitive's visibility cannot be determined because it is closer than primitive B and because its alpha value is unknown at the time the sample FSM operates. Because a decision cannot be made as to which primitive would end up being visible (either primitive B or primitive D) primitive B is early dispatched down the pipeline (to have its colors generated) and primitive D is kept. When processing of primitive D has been completed, the sample FSM stores: 1) the \u201cnear\u201d z value is zand the \u201cfar\u201d z value is z; 2) primitive information needed to color primitive D (primitive B's information has undergone early dispatch); and 3) the z values are labeled as conservative (because both a near and far are being maintained). In this condition, the sample FSM can determine that a piece of geometry closer than z obscures previous geometry, geometry farther than zis obscured, and geometry between zand zis indeterminate and must be assumed to be visible (hence a conservative assumption is made). When a sample FSM is in the conservative state and it contains valid primitive information, the sample FSM method considers the depth value of the stored primitive information to be the near depth value.","Step 6: When primitive E (which has alpha test disabled) is processed by the sample FSM, the primitive's visibility cannot be determined because it is between the near and far z values (i.e., between zand z). However, primitive E is not sent down the pipeline at this time because it could result in the primitives reaching the z buffered blend (part of the Pixel block in a preferred embodiment) out of correct time order. Therefore, primitive D is sent down the pipeline to preserve the time ordering. When processing of primitive E has been completed, the sample FSM stores: 1) the \u201cnear\u201d z value is zand the \u201cfar\u201d z value is z(note these have not changed, and zis not kept); 2) primitive information needed to color primitive E (primitive D's information has undergone early dispatch); and 3) the z values are labeled as conservative (because both a near and far are being maintained).","Step 7: When primitive F is processed by the sample FSM, the primitive is kept (its z value is less-than that of the near z value), and this causes the sample FSM to store: 1) the z value zas the \u201cnear\u201d z value (zand zare discarded); 2) primitive information needed to color primitive F (primitive E's information is discarded); and 3) the z value (z) is labeled as accurate.","Step 8: When all the geometry that touches the tile has been processed (or, in the case there are no tiles, when all the geometry in the frame has been processed), any valid primitive information is sent down the pipeline. In this case, primitive F's information is sent. This is the end-of-tile (or end-of-frame) dispatch, and not an early dispatch.","In summary in this CHSR process example involving alpha test, primitives A through F are processed, and primitives B, D, and F are sent down the pipeline. The Pixel block resolves the visibility of B, D, and F in the final z buffer blending stage. In this example, only the color primitive F is used for the sample.","Stencil Test","In OpenGL\u00ae stencil test conditionally discards a fragment based on the outcome of a comparison between a value stored in a stencil buffer at location (x, y) and a reference value. Several stencil comparison functions are permitted such that whether the stencil test passes can depend upon whether the reference value is less than, less than or equal to, equal to, greater than or equal to, greater than, or not equal to the masked stored value in the stencil buffer. In OpenGL\u00ae, if the stencil test fails, the incoming fragment is discarded. The reference value and the comparison value can have multiple bits, typically 8 bits so that 256 different values may be represented. When an object is rendered into Frame Buffer , a tag having the stencil bits is also written into the frame buffer. These stencil bits are part of the pipeline state. The type of stencil test to perform can be specified at the time the geometry is rendered.","The stencil bits are used to implement various filtering, masking or stenciling operations, to generate, for example, effects such as shadows. If a particular fragment ends up affecting a particular pixel in the frame buffer, then the stencil bits can be written to the frame buffer along with the pixel information.","In a preferred embodiment of the CHSR process, all stencil operations are done near the end of the pipeline in the Pixel block in a preferred embodiment. Therefore, the stencil values are stored in the Frame Buffer and as a result the stencil values are not available to the CHSR method performed in the Cull block. While it is possible for the stencil values to be transferred from the Frame Buffer for use in the CHSR process, this would generally require a long latency path that would reduce performance. In APIs such as OpenGL\u00ae, the stencil test is performed after alpha test, and the results of alpha test are not known to the CHSR process. Furthermore, renderers typically maintain stencil values over many frames (as opposed to depth values that are generally cleared at the start of each frame). Hence, the CHSR process utilizes a conservative approach to dealing with stencil operations. If a primitive can affect the stencil values in the frame buffer, then the VSPs in the primitive are always sent down the pipeline by the Cull block asserting the control bit CullFlushOverlap, shown in FIG. E. Primitives that can affect the stencil values are sent down the pipeline because stencil operations are performed by pipeline stages after Cull block  (see OpenGL\u00ae specification). A CullFlushOverlap condition sets the sample FSM to its most conservative state. Generally the stencil test is defined for a group of primitives. When Cull block  processes the first sample in a primitive with a new stencil test, control software sets the CullFlushAll bit in the corresponding Setup Output Cull Packet. CullFlushAll causes all of the VSPs from the Cull block to be sent to Pixel block , and clears the z values in Stamp Portion Memory . This \u201cflushing\u201d is needed because changing the stencil reference value effectively changes the \u201cvisibility rules\u201d in the z buffered blend (or Pixel block). Pixel block  compares the stencil values of the samples for a given sample location and determines which samples affect the final frame buffer color based on the stencil test. For example, for one group of samples corresponding to a sample location, the stencil test may be render if the stencil bit is equal to one. Pixel block  then discards each of the samples for that sample in this group that have a stencil bit value not equal to one.","As an example of the CHSR process dealing with stencil test (see OpenGL\u00ae specification), consider the diagrammatic illustration of FIG. E, which has two primitives (primitives A and C) covering four particular samples (with corresponding sample FSMs, referred to as SFSM through SFSM) and an additional primitive (primitive B) covering two of those four samples. The three primitives are rendered in the following order (starting with a depth clear and with depth test set to less-than): primitive A (with stencil test disabled); primitive B (with stencil test enabled and StencilOp set to \u201cREPLACE\u201d, see OpenGL\u00ae specification); and primitive C (with stencil test disabled). The steps are as follows:","Step 1: The depth clear causes the following in each of the four sample FSMs in this example: 1) z values are initialized to the maximum value; 2) primitive information is cleared; and 3) sample state bits are set to indicate the z value is accurate.","Step 2: When primitive A is processed by each sample FSM, the primitive is kept (i.e., it becomes the current best guess for the visible surface), and this causes the four sample FSMs to store: 1) their corresponding z values (either z, z, z, or zrespectively) as the \u201cnear\u201d z value; 2) primitive information needed to color primitive A; and 3) the z values in each sample FSM are labeled as accurate.","Step 3: When primitive B is processed by the sample FSMs, only samples  and  are affected, causing SFSM and SFSM to be unaffected and causing SFSM and SFSM to be updated as follows: 1) the far z values are set to the maximum value and the near z values are set to the minimum value; 2) primitive information for primitives A and B are sent down the pipeline; and 3) sample state bits are set to indicate the z values are conservative.","Step 4: When primitive C is processed by each sample FSM, the primitive is kept, but the sample FSMs do not all handle the primitive the same way. In SFSM and SFSM, the state is updated as: 1) zand zbecome the \u201cnear\u201d z values (zand zare discarded); 2) primitive information needed to color primitive C (primitive A's information is discarded); and 3) the z values are labeled as accurate. In SFSM and SFSM, the state is updated as: 1) zand zbecome the \u201cfar\u201d z values (the near z values are kept); 2) primitive information needed to color primitive C; and 3) the z values remain labeled as conservative.","In summary in this CHSR process example involving stencil test, primitives A through C are processed, and all the primitives are sent down the pipeline, but not all the samples. In a preferred embodiment, the Pixel blocks performs final z buffered blending operations to process the unresolved visibility issues. Multiple samples were shown in this example to illustrate that CullFlushOverlap \u201cflushes\u201d selected samples while leaving others unaffected.","Alpha Blending","Alpha blending is used to combine the colors of two primitives into one color. However, the primitives are still subject to the depth test for the updating of the z values. The amount of color contribution from each of the samples depends upon the transparency values, referred to as the alpha value, of the samples. The blend is performed according to the equation\n\n\u03b1(1\u2212\u03b1)\n\nwhere C is the resultant color, Cis the source color for an incoming primitive sample, \u03b1is the alpha value of the incoming primitive sample, and Cis the destination color at the corresponding frame buffer location. Alpha values are defined at the vertices of primitives, and alpha values for samples are interpolated from the values at the vertices.\n","As an example of the CHSR process dealing with alpha blending, consider FIG. E, which has four primitives (primitives A, B, C, and D) for a particular sample, rendered in the following order (starting with a depth clear and with depth test set to less-than): primitive A (with alpha blending disabled); primitives B and C (with alpha blending enabled); and primitive D (with alpha blending disabled). The steps are as follows:","Step : The depth clear causes the following in each CHSR sample FSM: 1) z values are initialized to the maximum value; 2) primitive information is cleared; and 3) sample state bits are set to indicate the z value is accurate.","Step : When primitive A is processed by the sample FSM, the primitive is kept (i.e., it becomes the current best guess for the visible surface), and this causes the sample FSM to store: 1) the z value zas the \u201cnear\u201d z value; 2) primitive information needed to color primitive A; and 3) the z value is labeled as accurate. Step : When primitive B is processed by the sample FSM, the primitive is kept (because its z value is less-than that of primitive A), and this causes the sample FSM to store: 1) the z value zas the \u201cnear\u201d z value (z is discarded); 2) primitive information needed to color primitive B (primitive A's information is sent down the pipeline); and 3) the z value (z) is labeled as accurate. Primitive A is sent down the pipeline because, at this point in the rendering process, the color of primitive B is to be blended with primitive A. This preserves the time order of the primitives as they are sent down the pipeline.","Step : When primitive C is processed by the sample FSM, the primitive is discarded (i.e., it is obscured by the current best guess for the visible surface, primitive B), and the sample FSM data is not changed. Note that if primitives B and C need to be rendered as transparent surfaces, then primitive C should not be hidden by primitive B. This could be accomplished by turning off the depth mask while primitive B is being rendered, but for transparency blending to be correct, the surfaces should be blended in either front-to-back or back-to-front order.","If the depth mask (see OpenGL\u00ae specification) is disabled, writing to the depth buffer (i.e., saving z values) is not performed; however, the depth test is still performed. In this example, if the depth mask is disabled for primitive B, then the value zis not saved in the sample FSM. Subsequently, primitive C would then be considered visible because its z value would be compared to z.","In summary of this example CHSR process example involving alpha blending, primitives A through D are processed, and all the primitives are sent down the pipeline, but not in all the samples. In a preferred embodiment, the Pixel blocks performs final z buffered blending operations to process the unresolved visibility issues. Multiple samples were shown in this example to illustrate that CullFlushOverlap dispatches selected samples without affecting other samples.","Control Bits","FIG. EA illustrates part of a Spatial Packet containing three control bits: DoAlphaTest, DoABlend and Transparent. The Transparent bit is set by the Geometry block  and is normally only used in sorted transparency mode. When the Transparent bit is reset the corresponding primitive is only processed in passes for opaque primitives. When the Transparent bit is set the corresponding primitive is only processed in passes for transparent primitives. The Transparent bit is generated in the Geometry block  and is used by the Sort block  to determine whether a particular primitive should be included in an opaque pass or a transparent pass; but, the Cull block  knows the type of pass (i.e. opaque or transparent) by looking at the Begin Tile packet, so there is no need to send the Transparent bit to the Cull block . The DoAlphaTest control bit controls whether Alpha test is performed on the samples in the primitive.","When the DoAlphaTest control bit is set to a one it means that downstream from Cull block  an alpha test will be performed on each fragment. When the alpha values of all of the samples in a stamp exceed a predetermined value, then even though an application program indicates that an alpha test should be performed, a functional block upstream from Cull block  may determine that none of the samples can fail alpha test. DoAlphaTest can then be set to zero which indicates to Cull block  that since all the samples are guaranteed to pass alpha test, it can process the samples as if they were not subject to alpha test. Observe that in an embodiment where one z value is stored, a sample being subject to alpha test can cause the stored sample to be made conservative. Therefore, DoAlphaTest being zero allows Cull to identify more samples as accurate and thereby eliminate more samples. A detailed description of the control of the DoAlphaTest control bit is provided in the provisional patent application entitled \u201cGraphics Processor with Deferred Shading,\u201d filed Aug. 20, 1998, which is incorporated by reference.","The DoABlend control bit, generated by the Geometry block , indicates whether a primitive is subject to blending. Blending combines the color values of two samples.","In one embodiment, the Geometry block  checks the alpha values at each vertex. If, given the alpha values, the BlendEquation and the BlendFunc pipeline state information is defined such that the frame buffer color values cannot affect the final color, then blending is turned off for that primitive using the DoABlend control bit. Observe that if blending was always on, and all primitives were treated as transparent, then a hidden surface removal process before lighting and shading might not not remove any geometry.","The following describes the method for evaluating texture data to determine whether blending can be turned off for a render if less than depth test. With a render if less than depth test, if there are two opaque primitives at the same location, the primitive that is in front is rendered. The present invention can also be used with a render if greater than depth test. Blending is turned off when a primitive is opaque and therefore no geometry behind the primitive will contribute to the corresponding final colors in the frame buffer. Whether a primitive is opaque is determined conservatively in that if there is any uncertainty as to whether the final frame buffer colors will be a blend of the current primitive and other primitives with greater z values, then the primitive is treated as transparent. For example, given an appropriately defined texture environment, if the alpha values at all of the vertices of a primitive are equal to one then blending can be turned off for that primitive because that primitive can be treated as opaque. Therefore, the culling method can be applied and more distant geometry can be eliminated.","Whether blending can be turned off for a primitive depends upon the texture type, the texture data, and the texture environment. In one embodiment there are two texture types. The first texture type is RGB texture. In RGB texture each texel (the equivalent of a pixel in texture space) is defined by a red color component value \u201cR,\u201d a green color component value \u201cG,\u201d and a blue color component value \u201cB.\u201d There are no alpha values in this first texture type. The second texture type describes each texel by R, G and B values as well as by an alpha value. The texture data comprise the values of the R, G, B and alpha components. The texture environment defines how to determine the final color of a pixel based on the relevant texture data and properties of the primitive. For example, the texture environment may define the type of interpolation that is used, as well as the lighting equation and when each operation is performed.","FIG. EB illustrates how the alpha values are evaluated to set the DoABlend control bit. Alpha mode register stores the Transparent bits for each of the three vertices of a triangular primitive. The Transparent bit defines whether the corresponding vertex is transparent indicated by a one, or opaque indicated by a zero. If all three of the vertices are opaque then blending is turned off, otherwise blending is on. Logic block implements this blending control function. When the AlphaAllOne control signal is asserted and all three of the transparent bits in the alpha mode register are equal to one, logic block sets DoABlend to a zero to turn off blending. The alpha value can also be inverted so that an alpha value of zero indicates that a vertex is opaque. Therefore, in this mode of operation, when the AlphaAllZero control signal is asserted and all three of the transparent bits are zero, the logic block sets DoABlend to a zero (\u201c0\u201d) to turn off blending.","Sorted Transparency Mode","The graphics pipeline operates in either time order mode or in sorted transparency mode. In sorted transparency mode, the process of reading geometry from a tile is divided into multiple passes. In the first pass, the Sort block outputs guaranteed opaque geometry, and in subsequent passes the Sort block outputs potentially transparent geometry. Within each sorted transparency mode pass, the time ordering is preserved, and mode data is inserted into its correct time-order location. Sorted transparency mode can be performed in either back-to-front or front-to-back order. In a preferred embodiment, the sorted transparency method is performed jointly by the Sort block and the Cull block.","In back-to-front sorted transparency modes a pixel color is determined by first rendering the front most opaque surface at the sample location. In the next pass the farthest transparent surface, that is in front of the opaque surface is rendered. In the subsequent pass the next farthest transparent surface is rendered, and this process is repeated until all of the samples at the sample location have been rendered or when a predetermined maximum number of samples have been rendered for the sample location.","The following provides a more detailed description of the back-to-front sorted transparency mode rendering method. This method is used with a render if less than depth test. Referring to FIG. E, in the first pass the Sort block sends the opaque primitives. Cull block  stores the z values for the opaque primitive samples in MCCAM array  (shown in FIG. E) (step ). The Sort block sends transparent primitives to the Cull block in the second and subsequent passes. In sorted transparency mode MCCAM array  and Sample Z Buffer  each store two z values (Zfar and Znear) for each corresponding sample. The Zfar value is the z value of the closest opaque sample. The Znear value is the z value of the sample nearest to, and less than, the z value of the opaque layer. One embodiment includes two MCCAM arrays  and two Sample Z Buffers  so as to store the Zfar and Znear values in separate units. First the z values for the front-most non-transparent samples are stored in the MCCAM array  (step ). The front-most non-transparent samples are then dispatched down the pipeline to be rendered (step ). In one embodiment, a flag bit in every pointer indicates whether the corresponding geometry is transparent or non-transparent. The Znear values for each sample are reset to zero (step ) in preparation for the next pass. During each transparent pass the z value for each sample point in the current primitive is compared with both the Zfar and the Znear values for that sample point. If the z value is larger than Znear but smaller than Zfar, then the sample is closer to the opaque layer and its z value replaces the current Znear value. The samples corresponding to the new Znear values are then dispatched down the pipeline to be rendered (step ), and Zfar for each such sample is set to the value of Znear (step ). This process is then repeated in the next pass.","Cull block  detects that it has finished processing a tile when for each sample point, there is at most one sample that is in front of Zfar. Transparent layer processing is not finished as long as there are two or more samples in front of Zfar for any sample point in the tile.","In front-to-back sorted transparency modes the transparent samples are rendered in order, starting at the front most transparent sample and then the next farther transparent sample in each subsequent cycle is rendered. An advantage of using a front-to-back sorted transparency mode is that if a maximum number of layers is defined, then the front most transparent layers are rendered which thereby provides a more accurate final displayed image.","In one embodiment, the maximum number of layers to render is determined by accumulating the alpha values. The alpha value represents the transparency of the sample location. As each sample is rendered the transparency at that sample location decreases, and the cumulative alpha value increases (where an alpha value of one is defined as opaque). For example, the maximum cumulative alpha value may be defined to be 0.9, when the cumulative alpha value exceeds 0.9 then no further samples at that sample location are rendered.","There are two counters in Sample Z Buffer , shown in FIG. E15, for every sample. When two samples from different primitives at the same sample location have the same z value, the samples are rendered in the time order that they arrived. The counters are used to determine which sample should be rendered based on the time order. The first counter identifies the primitive that is to be processed in the current pass. For example, in a case where there are five primitives all having a sample in a given sample location with the same z value, in the first pass the first counter is set to one which indicates the first primitive in this group should be rendered. In the second pass this first counter is incremented, to identify the second primitive as the primitive to be rendered.","The second counter maintains a count of the primitive being evaluated within a pass. In the five primitive example, in the third pass, the third primitive has the sample that should be rendered. At the start of the first pass the first counter is equal to three and the second counter is equal to one. The first counter value is compared with the second counter value and because the counter values are not equal the sample from the first primitive is not rendered. The second counter is then incremented, but the counters are still not equal so the sample from the second primitive is not rendered. In the third pass, the first and second counter values are equal, therefore the sample from the third primitive is rendered.","Characteristics of Particular Exemplary Embodiments","We now highlight particular embodiments of the inventive deferred shading graphics processor (DSGP). In one aspect (CULL) the inventive DSGP provides structure and method for performing conservative hidden surface removal. Numerous embodiments are shown and described, including but not limited to:","(1) A method of performing hidden surface removal in a computer graphics pipeline comprising the steps of: selecting a current primitive from a group of primitives, each primitive comprising a plurality of stamps; comparing stamps in the current primitive to stamps from previously evaluated primitives in the group of primitives; selecting a first stamp as a currently potentially visible stamp (CPVS) based on a relationship of depth states of samples in the first stamp with depth states of samples of previously evaluated stamps; comparing the CPVS to a second stamp; discarding the second stamp when no part of the second stamp would affect a final graphics display image based on the stamps that have been evaluated; discarding the CPVS and making the second stamp the CPVS, when the second stamp hides the CPVS; dispatching the CPVS and making the second stamp the CPVS when both the second stamp and the CPVS are at least partially visible in the final graphics display image; and dispatching the second stamp and the CPVS when the visibility of the second stamp and the CPVS depends on parameters evaluated later in the computer graphics pipeline.","(2) The method of (1) wherein the step of comparing the CPVS to a second stamp furthing comprises the steps of: comparing depth states of samples in the CPVS to depth states of samples in the second stamp; and evaluating pipeline state values. (3) The method of (1) wherein the depth state comprises one z value per sample, and wherein the z value includes a state bit which is defined to be accurate when the z value represents an actual z value of a currently visible surface and is defined to be conservative when the z value represents a maximum z value. (4) The method of (1) further comprising the step of dispatching the second stamp and the CPVS when the second stamp potentially alters the final graphics display image independent of the depth state. (5) The method of (1) further comprising the steps of: coloring the dispatched stamps; and performing an exact z buffer test on the dispatched stamps, after the coloring step. (6) The method of (1) further comprising the steps of: comparing alpha values of a plurality of samples to a reference alpha value; and performing the step of dispatching the second stamp and the CPVS, independent of alpha values when the alpha values of the plurality of samples are all greater than the reference value. (7) The method of (1) further comprising the steps of: determining whether any samples in the current primitive may affect final pixel color values in the final graphics display image; and turning blending off for the current primitive when no samples in the current primitive affect final pixel color values in the final graphics display image. (8) The method of claim  wherein the step of comparing stamps in the current primitive to stamps from previously evaluated primitives further comprises the steps of: determining a maximum z value for a plurality of stamp locations of the current primitive; comparing the maximum z value for a plurality of stamp positions with a minimum z value of the current primitive and setting corresponding stamp selection bits; and identifying as a process row a row of stamps wherein the maximum z value for a stamp position in the row is greater than the minimum z value of the current primitive. (9) The method of (8) wherein the step of determining a maximum z value for a plurality of stamp locations of the current primitive further comprises determining a maximum z value for each stamp in a bounding box of the current primitive. (10) The method of (8) wherein the step of comparing stamps in the current primitive to stamps from previously evaluated primitives further comprises the steps of: determining the left most and right most stamps touched by the current primitive in each of the process rows and defining corresponding stamp primitive coverage bits; and combining the stamp primitive coverage bits with the stamp selection bits to generate a final potentially visible stamp set. (11) The method of (10) wherein the step of comparing stamps in the current primitive to stamps from previously evaluated primitives further comprises the steps of: determining a set of sample points in a stamp in the final potentially visible stamp set; computing a z value for a plurality of sample points in the set of sample points; and comparing the computed z values with stored z values and outputting sample control signals. (12) The method of (10) wherein the step of comparing the computed z values with stored z values, further comprises the steps of: storing a first sample at a first sample location as a Zfar sample, if a first depth state of the first sample is the maximum depth state of a visible sample at the first sample location; comparing a second sample to the first sample; and storing the second sample if the second sample is currently potentially visible as a Zopt sample, and discarding the second sample when the Zfar sample hides the second sample. (13) The method of (10) wherein when it is determined that one sample in a stamp should be dispatched down the pipeline, all samples in the stamp are dispatched down the pipeline. (14) The method of (10) wherein when it is determined that one sample in a pixel should be dispatched down the pipeline, all samples in the pixel are dispatched down the pipeline. (15) The method of (10) wherein the step of computing a z value for a plurality of sample points in the set of sample points further comprises the steps of: creating a reference z value for a stamp; computing partial derivatives for a plurality of sample points in the set of sample points; sending down the pipeline the reference z value and the partial derivatives; and computing a z value for a sample based on the reference z value and partial derivatives. (16) The method of (10) further comprising the steps of: receiving a reference z value and partial derivatives; and re-computing a z value for a sample based on the reference z value and partial derivatives. (17) The method of (10) further comprising the step of dispatching the CPVS when the CPVS can affect stencil values. The method of (13) further comprising the step of dispatching all currently potentially visible stamps when a stencil test changes. (19) The method of (10) further comprising the steps of: storing concurrently samples from a plurality of primitives; and comparing a computed z value for a sample at a first sample location with stored z values of samples at the first sample location from a plurality of primitives. (20) The method of (10) wherein each stamp comprises at least one pixel and wherein the pixels in a stamp are processed in parallel. (21) The method of (20) further comprising the steps of: dividing a display image area into tiles; and rendering the display image in each tile independently. (22) The method of (10) wherein the sample points are located at positions between subraster grid lines. (23) The method of (20) wherein locations of the sample points within each pixel are programmable. (24) The method of (23) further comprising the steps of: programming a first set of sample locations in a plurality of pixels; evaluating stamp visibility using the first set of sample locations; programming a second set of sample locations in a plurality of pixels; and evaluating stamp visibility using the second set of sample locations. (25) The method of (10) further comprising the step of eliminating individual stamps that are determined not to affect the final graphics display image. (26) The method of (10) further comprising the step of turning off blending when alpha values at vertices of the current primitive have values such that frame buffer color values cannot affect a final color of samples in the current primitive. (27) The method of (1) wherein the depth state comprises a far z value and a near z value. (28) A hidden surface removal system for a deferred shader computer graphics pipeline comprising: a magnitude comparison content addressable memory Cull unit for identifying a first group of potentially visible samples associated with a current primitive; a Stamp Selection unit, coupled to the magnitude comparison content addressable memory cull unit, for identifying, based on the first group and a perimeter of the primitive, a second group of potentially visible samples associated with the primitive; a Z Cull unit, coupled to the stamp selection unit and the magnitude comparison content addressable memory cull unit, for identifying visible stamp portions by evaluating a pipeline state, and comparing depth states of the second group with stored depth state values; and a Stamp Portion Memory unit, coupled to the Z Cull unit, for storing visible stamp portions based on control signals received from the Z Cull unit, wherein the Stamp Portion Memory unit dispatches stamps having a visibility dependent on parameters evaluated later in the computer graphics pipeline. (29) The hidden surface removal system of (28) wherein the stored depth state values are stored separately from the visible stamp portions. (30) The hidden surface removal system of (28) wherein the Z Cull unit evaluates depth state and pipeline state values, and compares a currently potentially visible stamp (CPVS) to a first stamp; and wherein the Stamp Portion Memory, based on control signals from the Z Cull unit: discards the first stamp when no part of the first stamp would affect a final graphics display image based on the stamps that have been evaluated; discards the CPVS and makes the first stamp the CPVS, when the first stamp hides CPVS; dispatches the CPVS and makes the first stamp the CPVS when both the first stamp and the CPVS are at least partially visible in the final graphics display image; and dispatches the first stamp and the CPVS when the visibility of the first stamp and the CPVS depends on parameters evaluated later in the computer graphics pipeline. (31) The hidden surface removal system of (28) wherein the MCCAM Cull unit: determines a maximum z value for a plurality of stamp locations of the current primitive; compares the maximum z value for a plurality of stamp positions with a minimum z value of the current primitive and sets corresponding stamp selection bits; and identifies as a process row a row of stamps wherein the maximum z value for a stamp position in the row is greater than the minimum z value of the current primitive. (32) The hidden surface removal system of (31) wherein the Stamp Selection unit: determines the leftmost and right most stamps touched by the current primitive in each of the process rows and defines corresponding stamp primitive coverage bits; and combines the stamp primitive coverage bits with the stamp selection bits to generate a final potentially visible stamp set. (33) The hidden surface removal system of (32) wherein the Z Cull unit: determines a set of sample points in a stamp in the final potentially visible stamp set; computes a z value for a plurality of sample points in the set of sample points; and compares the computed z values with stored z values and outputs control signals. (34) The hidden surface removal system of (33) wherein the Z Cull unit comprises a plurality of Z Cull Sample State Machines, each of the Z Cull Sample State Machines receive, process and output control signals for samples in parallel. (35) A method of rendering a computer graphics image comprising the steps of: receiving a plurality of primitives to be rendered; selecting a sample location; rendering a front most opaque sample at the selected sample location, and defining the z value of the front most opaque sample as Zfar; comparing z values of a first plurality of samples at the selected sample location; defining to be Znear a first sample, at the selected sample location, having a z value which is less than Zfar and which is nearest to Zfar of the first plurality of samples; rendering the first sample; setting Zfar to the value of Znear; comparing z values of a second plurality of samples at the selected sample location; defining as Znear the z value of a second sample at the selected sample location, having a z value which is less than Zfar and which is nearest to Zfar of the second plurality of samples; and rendering the second sample. (36) The method of 35 further comprising the steps of: when a third plurality of samples at the selected sample location have a common z value which is less than Zfar, and the common z value is the z value nearest to Zfar of the first plurality of samples: rendering a third sample, wherein the third sample is the first sample received of the third plurality of samples; incrementing a first counter value to define a sample render number, wherein the sample render number identifies the sample to be rendered; selecting a fourth sample from the third plurality of samples; incrementing a second counter wherein the second counter defines an evaluation sample number; comparing the sample render number and the evaluation sample number; and rendering a sample when the corresponding evaluation sample number equals the sample render number.","The Fragment block is located after Cull and Mode Injection and before Texture, Phong, and Bump. It receives Visible Stamp Portions (VSPs) that consist of up to 4 fragments that need to be shaded. The fragments in a VSP always belongs to the same primitive, therefore the fragments share the primitive data defined at vertices including all the mode settings. A sample mask, sMask, defines which subpixel samples of the VSP are active. If one or more of the four samples for a given pixel is active. This means a fragment is needed for the pixel, and the vertex-based data for primitive will be interpolated to make fragment-based data. The active subpixel sample locations are used to determine the corresponding x and y coordinates of the fragment.","In order to save bandwidth, the Fragment block caches the color data to be reused by multiple VPSs belonging to the same primitive. Before sending a VSP, Mode Injection identifies if the color cache contains the required data. If it is a hit, Mode Injection sends the VSP, which includes an index into the cache. On a cache miss, Mode Injection replaces an entry from the cache with the new color data, prior to sending the VSP packet with the Color cache index pointing to the new entry. Similarly all modes, materials, texture info, and light info settings are cached in the blocks in which they are used. An index for each of these caches is also included in the VSP packet. In addition to the polygon data, the Fragment block caches some texture and mode info.  shows the flow and caching of mode data in the last half of the DSGP pipeline.","The Fragment block's main function is the interpolation of the polygon information provided at the vertices for all active fragments in a VSP. At the output of the Fragment block we still have stamps, with all the interpolated data per fragment. The Fragment block can perform the interpolations of a given fragment in parallel and fragments within a VSP can be done in an arbitrary order. Fully interpolated stamps are forwarded to the Texture, Phong and Bump blocks in the same order as received. In addition, the Fragment block generates Level of Detail (LOD or \u03bb) values for up to four textures and sends them to the Texture block.","The Fragment block will have an adequately sized FIFO in its input to smooth variable stamp processing time and the Color cache fill latency.",{"@attributes":{"id":"p-1329","num":"1368"},"figref":"FIG. 57"},"The Fragment block can be divided into six sub-blocks. Namely:\n\n","The first block handles Color cache misses. New polygon data replaces old data in the cache. The Color cache index, CCIX, points to the entry to be replaced. The block doesn't write all of the polygon data directly into the cache. It uses the vertex coordinates, the reciprocal of the w coordinate, and the optional texture q coordinate to calculate the barycentric coefficients. It writes the barycentric coefficients into the cache, instead of the info used to calculate them.","The second sub-block implements the Color cache. When Fragment receives a VSP packet (hit), the cache entry pointed to by CCIX is read to access the polygon data at the vertices and the associated barycentric coefficients.","The third sub-block prepares the interpolation coefficients for the first fragment of the VSP. The coefficients are expressed in plane equation form for the numerator and the denominator to facilitate incremental computation of the next fragment's coefficients. The total area of the triangle divides both the numerator and denominator, therefore can be simplified. Also, since the barycentric coefficients have redundancy built-in (the sum of the fractions are equal to the whole), additional storage and bandwidth is saved by only providing two out of three sets of barycentric coordinates along with the denominator. As a non-performance case, texture coordinates with a q other than 1 will be interpolated using 3 more coefficients for the denominator.","The x and y coordinates given per stamp correspond to the lower left pixel in the stamp. Only the position of the stamp in a tile is determined by these coordinates. A separate packet provides the coordinates of the tile that subsequent stamps belong to. A lookup table is used with the corresponding bits in sMask to determine the lower bits of the fragment x and y coordinates at subpixel accuracy. This choosing of an interpolation location at an active sample location ensures that the interpolation coefficients will always be positive with their sum being equal to one.","The fourth sub-block interpolates the colors, normals, texture coordinates, eye coordinates, and Bump tangents for each covered pixel. The interpolators are divided in four groups according to their precision. The first group interpolates 8 bit fixed point color fractions. The values are between 0 and 1, the binary representation of the value 1 is with all the bits set to one. The second set interpolates sixteen bit, fixed point, unit vectors for the normals and the surface tangent directions. The third set interpolates 24 bit floating point numbers with sixteen bit mantissas. The vertex eye coordinates and the magnitudes of the normals and surface tangents fall into this category. The last group interpolates the texture coordinates which are also 24 bit FP numbers but may have different interpolation coefficients. All interpolation coefficients are generated as 24 bit FP values but fewer bits or fixed point representation can be used when interpolating 8 bit or 16 bit fixed point values.","The fifth sub-block re-normalizes the normal and surface tangents. The magnitudes obtained during this process are discarded. The original magnitudes are interpolated separately before being forwarded to the Phong and Bump block.","The texture map u, v coordinates and Level of Detail (LOD) are evaluated in the sixth sub-block. The barycentric coefficients are used in determining the texture LOD. Up to four separate textures associated with two texture coordinates are supported. Therefore the unit can produce up to four LODs and two sets of s, t coordinates per fragment, represented as 24 bit FP values.","sMask and pMask",{"@attributes":{"id":"p-1338","num":"1383"},"figref":"FIG. 58"},"Barycentric Interpolation for Triangles","The Fragment block interpolates values using perspective corrected barycentric interpolation. This section describes the process.","As for the data associated with each fragment produced by rasterizing a triangle, we begin by specifying how these values are produced for fragments in a triangle. We define barycentric coordinates for a triangle  (). Barycentric coordinates are a set of three numbers, A, A, and A, each in the range of [0,1], with A+A+A=1. These coordinates uniquely specify any point p within the triangle or on the triangle's boundary as:\n\n()=()\u00d7()\u00d7()\u00d7\n\nwhere V, V, and Vare the vertices of the triangle. A, A, and A, can be found as:\n",{"@attributes":{"id":"p-1341","num":"1386"},"maths":{"@attributes":{"id":"MATH-US-00019","num":"00019"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":{"msub":{"mi":"A","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"=","mfrac":{"mrow":[{"mi":"Area","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"p","mo":[",",","],"msub":[{"mi":"V","mn":"1"},{"mi":"V","mn":"2"}]}}},{"mi":"Area","mo":"(","mrow":{"msub":[{"mi":"V","mn":"0"},{"mi":"V","mn":"1"},{"mi":"V","mn":"2"}],"mo":[",",","]}}]}},{"mrow":{"msub":{"mi":"A","mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mo":"\u2062","mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"=","mfrac":{"mrow":[{"mi":"Area","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"p","mo":",","mrow":{"msub":[{"mi":"V","mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mo":"\u2062","mn":"0"}},{"mi":"V","mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mo":"\u2062","mn":"2"}}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}}},{"mi":"Area","mo":["(","\u2062",")"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":"V","mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mo":"\u2062","mn":"0"}},{"mi":"V","mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mo":"\u2062","mn":"1"}},{"mi":"V","mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mo":"\u2062","mn":"2"}}],"mo":[",",","]}}]}},{"mrow":{"msub":{"mi":"A","mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mo":"\u2062","mn":"2"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"=","mfrac":{"mrow":[{"mi":"Area","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":"p","mo":",","mrow":{"msub":[{"mi":"V","mn":"0"},{"mi":"V","mn":"1"}],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}}},{"mi":"Area","mo":["(","\u2062",")"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mrow":{"msub":[{"mi":"V","mn":"0"},{"mi":"V","mn":"1"},{"mi":"V","mn":"2"}],"mo":[",",","]}}]}}],"mo":[",","\u2062",",","\u2062"],"mstyle":[{"mtext":{}},{"mtext":{}}]}}},"br":[{},{}],"in-line-formulae":[{},{}],"i":["V",",V",",V","x","\u00d7y","\u2212x","\u00d7y","+x","\u00d7y","\u2212x","\u00d7y","+x","\u00d7y","\u2212x","\u00d7y"],"sub":["0","1","2","w0","w1","w1","w0","w1","w2","w2","w1","w2","w0","w0","w2"]},"Denote a datum at V, V, and Vas f, f, and f, respectively. Then the value f(x,y) of a datum at a fragment with window coordinate x and y produced by rasterizing a triangle is given by:",{"@attributes":{"id":"p-1343","num":"1388"},"maths":{"@attributes":{"id":"MATH-US-00020","num":"00020"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"=","mfrac":{"mrow":[{"mrow":[{"msub":{"mi":"A","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"msub":[{"mi":"f","mn":"0"},{"mo":"\/","msub":{"mi":"w","mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}}],"mo":["\u2062","\u2062"],"mrow":{"mo":"+","mrow":{"msub":{"mi":"A","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}}},{"msub":[{"mi":"f","mn":"1"},{"mo":"\/","msub":{"mi":"w","mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}}],"mo":["\u2062","\u2062"],"mrow":{"mo":"+","mrow":{"msub":{"mi":"A","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}}},{"msub":[{"mi":"f","mn":"2"},{"mo":"\/","msub":{"mi":"w","mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}}}],"mo":"\u2062"}],"mo":["\u00d7","\u00d7","\u00d7"]},{"mrow":[{"msub":{"mi":"A","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"msub":[{"mi":"a","mn":"0"},{"mo":"\/","msub":{"mi":"w","mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}}],"mo":["\u2062","\u2062"],"mrow":{"mo":"+","mrow":{"msub":{"mi":"A","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}}},{"msub":[{"mi":"a","mn":"1"},{"mo":"\/","msub":{"mi":"w","mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}}],"mo":["\u2062","\u2062"],"mrow":{"mo":"+","mrow":{"msub":{"mi":"A","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}}},{"msub":[{"mi":"a","mn":"2"},{"mo":"\/","msub":{"mi":"w","mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}}}],"mo":"\u2062"}],"mo":["\u00d7","\u00d7","\u00d7"]}]}}}},"br":[{},{},{},{},{}],"sub":["c0","c1","c2","0","1","2","0","1","2","0","1","2","0","0","1","1","2","2 "],"in-line-formulae":[{},{},{},{}]},"For interpolation of fragment data along a line a slightly different formula is used:","Let the window coordinates of a produced fragment center be given by p=(x,y) and let the p=(x,y) and p=(x,y) the endpoints (vertices) of the line. Set t as the following and note that t=0 at pand t=1 at p:",{"@attributes":{"id":"p-1346","num":"1391"},"maths":[{"@attributes":{"id":"MATH-US-00021","num":"00021"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"t","mo":"=","mfrac":{"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"msub":[{"mi":["p","r"]},{"mi":"p","mn":"1"}],"mo":"-"}},{"mo":["(",")"],"mrow":{"msub":[{"mi":"p","mn":"2"},{"mi":"p","mn":"1"}],"mo":"-"}}],"mo":"\u00b7"},"msup":{"mrow":{"mo":["\uf605","\uf606"],"mrow":{"msub":[{"mi":"p","mn":"2"},{"mi":"p","mn":"1"}],"mo":"-"}},"mn":"2"}}}}},{"@attributes":{"id":"MATH-US-00021-2","num":"00021.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"f","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"=","mfrac":{"mrow":[{"mrow":[{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mi":"t"}},{"msub":[{"mi":"f","mn":"1"},{"mo":"\/","msub":{"mi":"w","mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}}],"mo":["\u2062","\u2062"],"mrow":{"mo":"+","mi":"t"}},{"msub":[{"mi":"f","mn":"2"},{"mo":"\/","msub":{"mi":"w","mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}}}],"mo":"\u2062"}],"mo":["\u00d7","\u00d7"]},{"mrow":[{"mo":["(",")"],"mrow":{"mn":"1","mo":"-","mi":"t"}},{"msub":[{"mi":"a","mn":"1"},{"mo":"\/","msub":{"mi":"w","mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}}],"mo":["\u2062","\u2062"],"mrow":{"mo":"+","mi":"t"}},{"msub":[{"mi":"a","mn":"2"},{"mo":"\/","msub":{"mi":"w","mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}}}],"mo":"\u2062"}],"mo":["\u00d7","\u00d7"]}]}}}}],"br":{}},"If the primitive is a point no interpolation is done. Vertex  is assumed to hold the data. In case q is not equal to one the s, t, and r coordinates need to be divided by q.","Vector Interpolation","For bump mapping the normal and surface tangents may have a magnitude associated with directional unit vectors. In this case we interpolate the unit vector components separately from the scalar magnitudes. This apparently gives a better visual result than interpolating the x, y and z components with their magnitudes. This is especially important when the direction and the magnitude are used separately.",{"@attributes":{"id":"p-1349","num":"1394"},"figref":"FIG. 60"},"Fragment x and y Coordinates",{"@attributes":{"id":"p-1350","num":"1395"},"figref":"FIG. 61"},"Equations","Cache Miss Calculations","First barycentric coefficients will need to be evaluated in the Fragment Unit on a Color cache miss. For a triangle:\n\n\n\n\n\n\n\nIn the equations above, x, x, x, are the window x-coordinates of the three triangle vertices. Similarly, y, y, y, are the three y-coordinates of the triangle vertices. With the actual barycentric coefficients, all the components need to be divided by the area of the triangle. This is not necessary in our case because of the perspective correction, that forms a denominator with coefficients also divided by the area.\n\nFor a line with vertex coordinates x, Xand y, y:\n\n=\u2212()\n\n\n\nb=0; b=0; b=0.\n\nWe now form the perspective corrected barycentric coefficient components:\n\n\n\n\n\n\n\nWhere wis the reciprocal of the clip w-coordinate of vertex  (reciprocal done in Geometry):\n",{"@attributes":{"id":"p-1352","num":"1397"},"maths":{"@attributes":{"id":"MATH-US-00022","num":"00022"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"w","mrow":{"mi":"ic","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"=","mfrac":{"mn":"1","msub":{"mi":"w","mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}}},{"msub":{"mi":"w","mrow":{"mi":"ic","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"=","mfrac":{"mn":"1","msub":{"mi":"w","mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}}},{"msub":{"mi":"w","mrow":{"mi":"ic","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":"=","mfrac":{"mn":"1","msub":{"mi":"w","mrow":{"mi":"c","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}}}}],"mo":[";",";"]}}}},"The denominator components can be formed by adding the individual constants in the numerator:\n\n\n\nThe above calculations need to be done only once per triangle. The color memory cache is used to save the coefficients for the next VSP of the same triangle. On a cache miss the coefficients need to be re-evaluated.\n\nInterpolation Coefficients\n","Next, we prepare the barycentric coordinates for the first pixel of the VSP with coordinates (x,y):",{"@attributes":{"id":"p-1355","num":"1400"},"maths":[{"@attributes":{"id":"MATH-US-00023","num":"00023"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mrow":[{"msub":{"mi":["D","x"]},"mo":"\u00d7","mi":"x"},{"msub":{"mi":["D","y"]},"mo":"\u00d7","mi":"y"}],"mo":["+","+"],"msub":{"mi":["D","k"]}}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00023-2","num":"00023.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"G","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"\u00d7","mi":"x"},{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"\u00d7","mi":"y"}],"mo":["+","+"],"msub":{"mi":"C","mrow":{"mi":"k","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00023-3","num":"00023.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"G","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u00d7","mi":"x"},{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u00d7","mi":"y"}],"mo":["+","+"],"msub":{"mi":"C","mrow":{"mi":"k","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00023-4","num":"00023.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"G","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mrow":[{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"msub":{"mi":"G","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"msub":{"mi":"G","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}],"mo":["-","-"]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00023-5","num":"00023.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"G","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}},{"mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"G","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}},{"mrow":{"msub":{"mi":"L","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"G","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}}],"mo":[";",";"]}}}],"br":{}},{"@attributes":{"id":"p-1356","num":"1401"},"maths":[{"@attributes":{"id":"MATH-US-00024","num":"00024"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"mrow":{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"+","msub":{"mi":["D","x"]}}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00024-2","num":"00024.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"G","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"mrow":{"msub":{"mi":"G","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"+","msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00024-3","num":"00024.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"G","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"mrow":{"msub":{"mi":"G","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"+","msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00024-4","num":"00024.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"G","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"mrow":{"msub":{"mi":"G","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"+","msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}}}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00024-5","num":"00024.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"G","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}}]}},"mo":";"}}},{"@attributes":{"id":"MATH-US-00024-6","num":"00024.6"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"G","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}}]}},"mo":";"}}},{"@attributes":{"id":"MATH-US-00024-7","num":"00024.7"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msub":{"mi":"L","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"G","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}}]}}}}],"br":{}},{"@attributes":{"id":"p-1357","num":"1402"},"maths":[{"@attributes":{"id":"MATH-US-00025","num":"00025"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"mrow":{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"+","msub":{"mi":["D","x"]}}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00025-2","num":"00025.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"G","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"mrow":{"msub":{"mi":"G","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"+","msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00025-3","num":"00025.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"G","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"mrow":{"msub":{"mi":"G","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"+","msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}}}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00025-4","num":"00025.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":"G","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"mrow":{"msub":{"mi":"G","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"+","msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}}}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00025-5","num":"00025.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"G","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}}]}},"mo":";"}}},{"@attributes":{"id":"MATH-US-00025-6","num":"00025.6"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"G","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}}]}},"mo":";"}}},{"@attributes":{"id":"MATH-US-00025-7","num":"00025.7"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"msub":{"mi":"L","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"G","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}}]}}}}]},"As a non-performance case (half-rate), when texture coordinate q[m] is not equal to one, where n is the vertex number (0 to 2) and m is the texture number (0 to 3), an additional denominator for interpolating texture coordinates is evaluated:",{"@attributes":{"id":"p-1359","num":"1404"},"maths":[{"@attributes":{"id":"MATH-US-00026","num":"00026"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["D","qx"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"\u00d7","mrow":{"msub":{"mi":"q","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u00d7","mrow":{"msub":{"mi":"q","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":"\u00d7","mrow":{"msub":{"mi":"q","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+"]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00026-2","num":"00026.2"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"msub":{"mi":["D","qy"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"\u00d7","mrow":{"msub":{"mi":"q","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u00d7","mrow":{"msub":{"mi":"q","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mo":"\u2062","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}}},"mo":"\u00d7","mrow":{"msub":{"mi":"q","mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mo":"\u2062","mn":"2"}},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+"]}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mrow":[{"mrow":{"mi":"if","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"msub":{"mi":"q","mrow":{"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mo":"\u2062","mi":"n"}},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},"mo":"\u2260","mn":"1"},{"mi":"n","mo":"=","mn":"0"}],"mo":";"},{"mn":"2","mo":";","mrow":{"mi":"m","mo":"=","mn":"0"}}],"mo":[",",",",",",",",","],"mn":["1","1","2","3"]}}}]}}},{"@attributes":{"id":"MATH-US-00026-3","num":"00026.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["D","qz"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"z","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"\u00d7","mrow":{"msub":{"mi":"q","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"z","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u00d7","mrow":{"msub":{"mi":"q","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"z","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":"\u00d7","mrow":{"msub":{"mi":"q","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+"]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00026-4","num":"00026.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"msub":{"mi":"W","mrow":{"mi":"q","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mo":["[","]"],"mi":"m"}],"mo":"\u2061"},{"mrow":[{"mrow":{"msub":{"mi":["D","qx"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},"mo":"\u00d7","mi":"x"},{"mrow":{"msub":{"mi":["D","qy"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},"mo":"\u00d7","mi":"y"},{"msub":{"mi":["D","qk"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}],"mo":["+","+"]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00026-5","num":"00026.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":{"mrow":[{"msub":{"mi":"L","mrow":{"mi":"q","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mo":["[","]"],"mi":"m"}],"mo":"\u2061"},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"G","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mrow":[{"msub":{"mi":"W","mrow":{"mi":"q","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mo":["[","]"],"mi":"m"}],"mo":"\u2061"}]}},"mo":";"}}},{"@attributes":{"id":"MATH-US-00026-6","num":"00026.6"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":{"mrow":[{"msub":{"mi":"L","mrow":{"mi":"q","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mo":["[","]"],"mi":"m"}],"mo":"\u2061"},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"G","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mrow":[{"msub":{"mi":"W","mrow":{"mi":"q","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mo":["[","]"],"mi":"m"}],"mo":"\u2061"}]}},"mo":";"}}},{"@attributes":{"id":"MATH-US-00026-7","num":"00026.7"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"msub":{"mi":"L","mrow":{"mi":"q","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mo":["[","]"],"mi":"m"}],"mo":"\u2061"},"mo":"=","mfrac":{"mrow":[{"msub":{"mi":"G","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mrow":[{"msub":{"mi":"W","mrow":{"mi":"q","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mo":["[","]"],"mi":"m"}],"mo":"\u2061"}]}}}}]},"When the barycentric coordinates for a given pixel with (x,y) coordinates are evaluated we use them to interpolate. For a line L is not needed but is assumed to be zero in the following formulas.","Interpolation Equations","For full performance mode, we interpolate one set of texture coordinates:\n\n[0]=()\u00d7[0]+()\u00d7[0]+()\u00d7[0]\n\n[0]=()\u00d7[0]+()\u00d7[0]+()\u00d7[0]\n\nDiffuse and specular colors:\n\n()\u00d7()\u00d7()\u00d7\n\n()\u00d7()\u00d7()\u00d7\n\n()\u00d7()\u00d7()\u00d7\n\n()\u00d7()\u00d7()\u00d7\n\n()\u00d7()\u00d7()\u00d7\n\n()\u00d7()\u00d7()\u00d7\n\n()\u00d7()\u00d7()\u00d7\n","Note that the 8-bit color values are actually fraction between 0 and 1 inclusive. By convention, the missing represented number is 1-2. The value one is represented with all the bits set taking the place of the missing representation. When color index is used instead of R, G, B and A, the 8-bit index value replaces the R value of the Diffuse and the Specular component of the color.","And surface normals:\n\n()\u00d7()\u00d7()\u00d7\n\n()\u00d7()\u00d7()\u00d7\n\n()\u00d7()\u00d7()\u00d7\n","The normal vector has to be re-normalized after the interpolation:",{"@attributes":{"id":"p-1365","num":"1410"},"maths":[{"@attributes":{"id":"MATH-US-00027","num":"00027"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msup":{"mrow":[{"mo":["\uf605","\uf606"],"mtable":{"mtr":[{"mtd":{"mn":"0"}},{"mtd":{"mi":"h"}}]}},{"mo":"-","mn":"1"}]},"mo":"=","mfrac":{"mn":"1","msqrt":{"mrow":{"msubsup":[{"mi":["n","x"],"mn":"2"},{"mi":["n","y"],"mn":"2"},{"mi":["n","z"],"mn":"2"}],"mo":["+","+"]}}}}}},{"@attributes":{"id":"MATH-US-00027-2","num":"00027.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mover":{"mi":"n","mo":"^"},"mi":"x"},"mo":"=","mrow":{"msub":{"mi":["n","x"]},"mo":"\u00d7","msup":{"mrow":[{"mo":["\uf605","\uf606"],"mtable":{"mtr":[{"mtd":{"mn":"0"}},{"mtd":{"mi":"h"}}]}},{"mo":"-","mn":"1"}]}}}}},{"@attributes":{"id":"MATH-US-00027-3","num":"00027.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mover":{"mi":"n","mo":"^"},"mi":"y"},"mo":"=","mrow":{"msub":{"mi":["n","y"]},"mo":"\u00d7","msup":{"mrow":[{"mo":["\uf605","\uf606"],"mtable":{"mtr":[{"mtd":{"mn":"0"}},{"mtd":{"mi":"h"}}]}},{"mo":"-","mn":"1"}]}}}}},{"@attributes":{"id":"MATH-US-00027-4","num":"00027.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mover":{"mi":"n","mo":"^"},"mi":"z"},"mo":"=","mrow":{"msub":{"mi":["n","x"]},"mo":"\u00d7","msup":{"mrow":[{"mo":["\uf605","\uf606"],"mtable":{"mtr":[{"mtd":{"mn":"0"}},{"mtd":{"mi":"h"}}]}},{"mo":"-","mn":"1"}]}}}}}],"br":[{},{},{},{}],"in-line-formulae":[{},{},{},{},{},{}],"i":["X","=L","x,y","X","+L","x,y","X","+L","x,y","X","Y","=L","x,y","Y","+L","x,y","Y","+L","x,y","Y","z","=L","x,y","z","+L","x,y","z","+L","x,y","z"],"sub":["0","0","e0","1","e1","2","e2 ","0","0","e0","1","e1","2","e2 ","0","0","e0","1","e1","2","e2 "]},"At half-rate (accumulative) we interpolate up to four texture coordinates. This is done either using the plane equations or barycentric coordinates. The r-texture coordinates are also interpolated for volume texture rendering but at one third of the full rate.\n\n[1]=()\u00d7[1]()\u00d7[1]()\u00d7[1]\n\n[1]=()\u00d7[1]()\u00d7[1]()\u00d7[1]\n\n[0]=()\u00d7[0]()\u00d7[0]()\u00d7[0]\n\n[1]=()\u00d7[1]()\u00d7[1]()\u00d7[1]\n","In case the partials are provided by the user as the bump tangents per vertex, we need to interpolate them. As a simplification the hardware will always interpolate the surface tangents at half rate:",{"@attributes":{"id":"p-1368","num":"1413"},"maths":[{"@attributes":{"id":"MATH-US-00028","num":"00028"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","msub":{"mi":["x","e"]}},{"mo":"\u2202","mi":"s"}]},"mo":"=","mrow":{"mrow":[{"mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"\u00d7","mfrac":{"mrow":[{"mo":"\u2202","msub":{"mi":"x","mrow":{"mi":"e","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}},{"mo":"\u2202","mi":"s"}]}},{"mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"\u2062","mstyle":{"mtext":":"}}],"mo":"+"}}}},{"@attributes":{"id":"MATH-US-00028-2","num":"00028.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","msub":{"mi":["x","e"]}},{"mo":"\u2202","mi":"t"}]},"mo":"=","mrow":{"mrow":[{"mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"\u00d7","mfrac":{"mrow":[{"mo":"\u2202","msub":{"mi":"x","mrow":{"mi":"e","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}},{"mo":"\u2202","mi":"t"}]}},{"mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"\u2062","mstyle":{"mtext":":"}}],"mo":"+"}}}},{"@attributes":{"id":"MATH-US-00028-3","num":"00028.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","msub":{"mi":["y","e"]}},{"mo":"\u2202","mi":"s"}]},"mo":"=","mrow":{"mrow":[{"mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"\u00d7","mfrac":{"mrow":[{"mo":"\u2202","msub":{"mi":"y","mrow":{"mi":"e","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}},{"mo":"\u2202","mi":"s"}]}},{"mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"\u2062","mstyle":{"mtext":":"}}],"mo":"+"}}}},{"@attributes":{"id":"MATH-US-00028-4","num":"00028.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","msub":{"mi":["y","e"]}},{"mo":"\u2202","mi":"t"}]},"mo":"=","mrow":{"mrow":[{"mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"\u00d7","mfrac":{"mrow":[{"mo":"\u2202","msub":{"mi":"y","mrow":{"mi":"e","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}},{"mo":"\u2202","mi":"t"}]}},{"mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"\u2062","mstyle":{"mtext":":"}}],"mo":"+"}}}},{"@attributes":{"id":"MATH-US-00028-5","num":"00028.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","msub":{"mi":["z","e"]}},{"mo":"\u2202","mi":"s"}]},"mo":"=","mrow":{"mrow":[{"mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"\u00d7","mfrac":{"mrow":[{"mo":"\u2202","msub":{"mi":"z","mrow":{"mi":"e","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}},{"mo":"\u2202","mi":"s"}]}},{"mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"\u2062","mstyle":{"mtext":":"}}],"mo":"+"}}}},{"@attributes":{"id":"MATH-US-00028-6","num":"00028.6"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","msub":{"mi":["z","e"]}},{"mo":"\u2202","mi":"t"}]},"mo":"=","mrow":{"mrow":[{"mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"\u00d7","mfrac":{"mrow":[{"mo":"\u2202","msub":{"mi":"z","mrow":{"mi":"e","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}}},{"mo":"\u2202","mi":"t"}]}},{"mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"\u2062","mstyle":{"mtext":":"}}],"mo":"+"}}}}]},"The surface tangents also have to be normalized, like the normals, after interpolation.","We also use the barycentric coefficients to evaluate the partial derivatives of the texture coordinates s and t with respect to window x and y-coordinates:",{"@attributes":{"id":"p-1371","num":"1416"},"maths":[{"@attributes":{"id":"MATH-US-00029","num":"00029"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","mi":"s"},{"mo":"\u2202","mi":"x"}]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},{"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"x"}]},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"x"}]},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"x"}]},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+"]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00029-2","num":"00029.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","mi":"t"},{"mo":"\u2202","mi":"x"}]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},{"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"x"}]},"mo":"\u00d7","mrow":{"msub":{"mi":"t","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"x"}]},"mo":"\u00d7","mrow":{"msub":{"mi":"t","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"x"}]},"mo":"\u00d7","mrow":{"msub":{"mi":"t","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+"]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00029-3","num":"00029.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","mi":"s"},{"mo":"\u2202","mi":"y"}]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},{"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"y"}]},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"y"}]},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"y"}]},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+"]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00029-4","num":"00029.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","mi":"t"},{"mo":"\u2202","mi":"y"}]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},{"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"y"}]},"mo":"\u00d7","mrow":{"msub":{"mi":"t","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"y"}]},"mo":"\u00d7","mrow":{"msub":{"mi":"t","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"mfrac":{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"y"}]},"mo":"\u00d7","mrow":{"msub":{"mi":"t","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+"]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00029-5","num":"00029.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":[{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"x"}]},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"-","mrow":{"msub":{"mi":["D","x"]},"mo":"\u00d7","mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00029-6","num":"00029.6"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":[{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"x"}]},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"-","mrow":{"msub":{"mi":["D","x"]},"mo":"\u00d7","mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00029-7","num":"00029.7"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":[{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"x"}]},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":"-","mrow":{"msub":{"mi":["D","x"]},"mo":"\u00d7","mrow":{"msub":{"mi":"L","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00029-8","num":"00029.8"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":[{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"0"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"y"}]},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"-","mrow":{"msub":{"mi":["D","y"]},"mo":"\u00d7","mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00029-9","num":"00029.9"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":[{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"y"}]},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"-","mrow":{"msub":{"mi":["D","y"]},"mo":"\u00d7","mrow":{"msub":{"mi":"L","mn":"1"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00029-10","num":"00029.10"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":[{"mrow":[{"mo":"\u2202","mrow":{"msub":{"mi":"L","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}},{"mo":"\u2202","mi":"y"}]},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":"-","mrow":{"msub":{"mi":["D","y"]},"mo":"\u00d7","mrow":{"msub":{"mi":"L","mn":"2"},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}}},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00029-11","num":"00029.11"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","mi":"s"},{"mo":"\u2202","mi":"x"}]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":["D","x"]},"mo":"\u00d7","mrow":{"mi":"s","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+","-"]},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}}}},{"@attributes":{"id":"MATH-US-00029-12","num":"00029.12"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","mi":"t"},{"mo":"\u2202","mi":"x"}]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"\u00d7","mrow":{"msub":{"mi":"t","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u00d7","mrow":{"msub":{"mi":"t","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":"\u00d7","mrow":{"msub":{"mi":"t","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":["D","x"]},"mo":"\u00d7","mrow":{"mi":"t","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+","-"]},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}}}},{"@attributes":{"id":"MATH-US-00029-13","num":"00029.13"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","mi":"s"},{"mo":"\u2202","mi":"y"}]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":["D","y"]},"mo":"\u00d7","mrow":{"mi":"s","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+","-"]},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}}}},{"@attributes":{"id":"MATH-US-00029-14","num":"00029.14"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","mi":"t"},{"mo":"\u2202","mi":"y"}]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"\u00d7","mrow":{"msub":{"mi":"t","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u00d7","mrow":{"msub":{"mi":"t","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":"\u00d7","mrow":{"msub":{"mi":"t","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":["D","y"]},"mo":"\u00d7","mrow":{"mi":"t","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+","-"]},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}}}}]},"In the event of q[m] is not equal to one, W(x,y) is replaced by W[m](x,y).","This is a good introduction for an alternative way of evaluating the interpolated s, t and their partials:",{"@attributes":{"id":"p-1373","num":"1418"},"maths":[{"@attributes":{"id":"MATH-US-00030","num":"00030"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mi":"s","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"mrow":[{"mrow":{"msub":{"mi":["S","x"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},"mo":"\u00d7","mi":"x"},{"mrow":{"msub":{"mi":["S","y"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},"mo":"\u00d7","mi":"y"},{"msub":{"mi":["S","k"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}],"mo":["+","+"]},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}}}},{"@attributes":{"id":"MATH-US-00030-2","num":"00030.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["S","x"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"x","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+"]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00030-3","num":"00030.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["S","y"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"y","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+"]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00030-4","num":"00030.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mi":["S","k"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},{"mrow":[{"msub":{"mi":"C","mrow":{"mi":"k","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"0"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"0"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"k","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"1"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"1"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}},{"msub":{"mi":"C","mrow":{"mi":"k","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}},"mn":"2"}},"mo":"\u00d7","mrow":{"msub":{"mi":"s","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":["+","+"]}],"mo":"="}}},{"@attributes":{"id":"MATH-US-00030-5","num":"00030.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","mi":"s"},{"mo":"\u2202","mi":"x"}]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},"mo":"=","mfrac":{"mrow":[{"mrow":[{"msub":{"mi":["S","x"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},{"msub":{"mi":["D","x"]},"mo":"\u00d7","mrow":{"mi":"s","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}}],"mo":"-"},{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}]}}}},{"@attributes":{"id":"MATH-US-00030-6","num":"00030.6"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mrow":[{"mi":"s","mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},{"mo":["(",")"],"mrow":{"mrow":{"mi":"x","mo":"+","mn":"1"},"mo":",","mi":"y"}}],"mo":"\u2062"},"mo":"=","mfrac":{"mrow":[{"msub":{"mrow":{"mrow":[{"msub":{"mi":["s","n"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mo":["[","]"],"mi":"m"}],"mo":"\u2061"},"msub":{"mi":["s","x"]}},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},{"mrow":{"msub":{"mi":["W","i"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},"mo":"+","msub":{"mi":["D","x"]}}]}}}},{"@attributes":{"id":"MATH-US-00030-7","num":"00030.7"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mrow":[{"msub":{"mi":["s","n"]},"mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mo":["[","]"],"mi":"m"}],"mo":"\u2061"},{"mrow":[{"mrow":{"msub":{"mi":["S","x"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},"mo":"\u00d7","mi":"x"},{"mrow":{"msub":{"mi":["S","y"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}},"mo":"\u00d7","mi":"y"},{"msub":{"mi":["S","k"]},"mo":"\u2061","mrow":{"mo":["[","]"],"mi":"m"}}],"mo":["+","+"]}],"mo":"="}}}]},"Other terms can be evaluated similarly. Note that all values that need to be interpolated, like colors and normals could be expressed in this plane equation mode and saved in the triangle info cache to reduce the computation requirements with the incremental evaluation approach.","We define:",{"@attributes":{"id":"p-1376","num":"1421"},"maths":{"@attributes":{"id":"MATH-US-00031","num":"00031"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mrow":[{"mi":"u","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"msup":{"mn":"2","mi":"\u2033"},"mo":"\u00d7","mrow":{"mi":"s","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":"v","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"msup":{"mn":"2","mi":"\u2032\u2032\u2032"},"mo":"\u00d7","mrow":{"mi":"t","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}}],"mo":"="}}},{"mtd":{"mrow":{"mrow":[{"mi":"\u03c1","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}},{"mi":"max","mo":"\u2062","mrow":{"mo":["{","}"],"mrow":{"msqrt":[{"mrow":{"msup":[{"mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"u"},{"mo":"\u2202","mi":"x"}]}},"mn":"2"},{"mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"v"},{"mo":"\u2202","mi":"x"}]}},"mn":"2"}],"mo":"+"}},{"mrow":{"msup":[{"mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"u"},{"mo":"\u2202","mi":"y"}]}},"mn":"2"},{"mrow":{"mo":["(",")"],"mfrac":{"mrow":[{"mo":"\u2202","mi":"v"},{"mo":"\u2202","mi":"y"}]}},"mn":"2"}],"mo":"+"}}],"mo":","}}}],"mo":"="}}},{"mtd":{"mrow":{"mi":"\u03bb","mo":"=","mrow":{"msub":{"mi":"log","mn":"2"},"mo":"\u2061","mrow":{"mo":["[","]"],"mrow":{"mi":"\u03c1","mo":"\u2061","mrow":{"mo":["(",")"],"mrow":{"mi":["x","y"],"mo":","}}}}}}}}]}}}},"Here, \u03bb is called the Level of Detail (LOD) and p is called the scale factor that governs the magnification or minification of the texture image. n and m are the width and the height of a two dimensional texture map. The partial derivatives of u and v are obtained using the partials of s and t. For one dimension texture map t, v, and the partial derivatives \u03b4v\/\u03b4x and \u03b4v\/\u03b4y are set to zero. For a line the formula is:\n\n\u0394\n","The DSGP pipeline supports up to four textures with two sets of texture coordinates. Specifically, for i=0.3 if:","TEXTURE1D[i]==1 or TEXTURE2D[i]==1 then we compute \u03bb using the texture coordinates TEXTURE_COORD_SET_SOURCE[i].","The Fragment block passes s, t, r, and \u03bb to the Texture block for each active texture. Note that \u03bb is not the final LOD. The Texture block applies additional rules such as LOD clamping to obtain the final value for \u03bb.","Memory Caching Schemes","Fragment uses three caches to perform the needed operations. The primary cache is the Color cache. It holds the color data for the primitive (triangle, line, or point). The cache miss determination and replacement logic is actually located in the Mode Inject block. The Fragment block normally receives a \u201chit\u201d packet with an index pointing to the entry that hold the associated Color data. If a miss is detected by the Mode Inject block, a \u201cfill\u201d packet is sent first to replace an entry in the cache with the new data before any \u201chit\u201d packets are sent to use the new data. Therefore it is important not to change the order of packets sent by Mode Inject, since the cache replacement and use logic assumes that the incoming packets are processed in order.","The Fragment block modifies some of the data before writing in the Color cache during cache fills. This is done to prepare the barycentric coefficients during miss time. The vertex window coordinates, the reciprocal of the clip-w coordinates at the vertices and texture q coordinates at the vertices are used and replaced by the C, C, C, D, D, Dbarycentric coefficients. Similarly the S, S, T, and T, values are evaluated during cache misses and stored along with the other data.","The Color cache is currently organized as a 256 entry, four set associative cache. The microArchitecture of the Mode Inject and Fragment Units may change this organization provided that the performance goals are retained. It assumed that at full rate the Color cache misses will be less than 15% of the average processed VSPs.","The data needed at half rate is stored as two consecutive entries in the Color cache. The index provided in this case will be always be an even number.","For the texture information used in the Fragment block two texture mode caches are used. These are identically organized caches each holding information for two textures. Two texture indices, TXIX and TXIX, are provided in every \u201chit\u201d packet to associate the texture coordinates with up to four textures. Per texture the following data is read from the texture mode caches:","TEXTURE1D, TEXTURE2D, TEXTURE3D are the enable bits for a given texture.","TEXTURE_HIGH, TEXTURE_WIDTH define respectively the m and n values used in the u and v calculations.","TEXTURE_COORD_SET_SOURCE identifies which texture coordinate is bound to a given texture.","The texture mode caches are organized as a 32 entry fully associative cache. The assumed miss rate for texture mode cache 0 is less than 0.2% per VSP.","In addition, modes are also cached in Fragment in a Mode Cache. The Mode Cache is organized as a fully associative, eight-entry cache. The assumed miss rate is 0.001% per VSP (negligible). The following info is cached in the Mode Cache:","SHADE_MODEL (1 bit),","BUMP_NO_INTERPOLATE (1 bit)","SAMPLE_LOCATION_SELECT (3 bits)","Other Considerations","The order of processing of VSPs can also be changed. A reorder buffer before the Pixel block reassembles the stamps. VSPs that share the same x and y coordinates (belonging to separate primitives) need to be presented to Pixel in arrival order. VSPptr accompanies each VSP, indicating the VSP's position in the reorder buffer. The buffer is organized as a FIFO, where the front-most stamp for which the shading has completed is forwarded to the Pixel block.","Another consideration for the VSP processing order is the various mode caches. Mode index assumes that \u201chit\u201d packets will not cross \u201cmiss\u201d packets. This means the \u201cmiss\u201d packets form a barrier for the \u201chit\u201d packets. Obviously the process order can be changed after fetching the corresponding mode cache info, provided the downstream block sees the packets at the same order provided by Mode Injection.","The invention is directed to a new graphics processor and method and encompasses numerous substructures including specialized subsystems, subprocessors, devices, architectures, and corresponding procedures. Embodiments of the invention may include one or more of deferred shading, a tiled frame buffer, and multiple-stage hidden surface removal processing, as well as other structures and\/or procedures. In this document, this graphics processor of this invention is referred to as the DSGP (for Deferred Shading Graphics Processor), and the associated pipeline is referred to as the \u201cDSGP pipeline\u201d, or simply \u201cthe pipeline\u201d.","This present invention includes numerous embodiments of the DSGP pipeline. Embodiments of the present invention are designed to provide high-performance 3D graphics with Phong shading, subpixel anti-aliasing, and texture- and bump-mapping in hardware. The DSGP pipeline provides these sophisticated features without sacrificing performance.","The DSGP pipeline can be connected to a computer via a variety of possible interfaces, including but not limited to for example, an Advanced Graphics Port (AGP) and\/or a PCI bus interface, amongst the possible interface choices. VGA and video output are generally also included. Embodiments of the invention supports both OpenGL and Direct 3D Application Program Interfaces (APIs). The OpenGL specification, entitled \u201cThe OpenGL Graphics System: A Specification (Version 1.2)\u201d by Mark Segal and Kurt Akeley, edited by Jon Leech, is included incorporated by reference.","Several exemplary embodiments or versions of a Deferred Shading Graphics Pipeline are described here, and embodiments having various combinations of features may be implemented. Additionally, features of the invention may be implemented independently of other features, and need not be used exclusively in Graphics Pipelines which perform shading in a deferred manner.","Tiles, Stamps, Samples, and Fragments","Each frame (also called a scene or user frame) of 3D graphics primitives is rendered into a 3D window on the display screen. The pipeline renders primftives, and the invention is described relative to a set of renderable primitives that include: 1) triangles, 2) lines, and 3) points. Polygons with more than three vertices are divided into triangles in the Geometry block, but the DSGP pipeline could be easily modified to render quadrilaterals or polygons with more sides. Therefore, since the pipeline can render any polygon once it is broken up into triangles, the inventive renderer effectively renders any polygon primitive. A window consists of a rectangular grid of pixels, and the window is divided into tiles (hereinafter tiles are assumed to be 16\u00d716 pixels, but could be any size). If tiles are not used, then the window is considered to be one tile. Each tile is further divided into stamps (hereinafter stamps are assumed to be 2\u00d72 pixels, thereby resulting in 64 stamps per tile, but stamps could be any size within a tile). Each pixel includes one or more samples, where each sample has its own color value and z-value (hereinafter, pixels are assumed to include four samples, but any number could be used). A fragment is the collection of samples covered by a primitive within a particular pixel. The term \u201cfragment\u201d is also used to describe the collection of visible samples within a particular primitive and a particular pixel.","Deferred Shading","In ordinary Z-buffer rendering, the renderer calculates the color value (RGB or RGBA) and z value for each pixel of each primitive, then compares the z value of the new pixel with the current z value in the Z-buffer. If the z value comparison indicates the new pixel is \u201cin front of\u201d the existing pixel in the frame buffer, the new pixel overwrites the old one; otherwise, the new pixel is thrown away.","Z-buffer rendering works well and requires no elaborate hardware. However, it typically results in a great deal of wasted processing effort if the scene contains many hidden surfaces. In complex scenes, the renderer may calculate color values for ten or twenty times as many pixels as are visible in the final picture. This means the computational cost of any per-pixel operation\u2014such as Phong shading or texture-mapping\u2014is multiplied by ten or twenty. The number of surfaces per pixel, averaged over an entire frame, is called the depth complexity of the frame. In conventional z-buffered renderers, the depth complexity is a measure of the renderer's inefficiency when rendering a particular frame.","In accordance with the present invention, in a pipeline that performs deferred shading, hidden surface removal (HSR) is completed before any pixel coloring is done. The objective of a deferred shading pipeline is to generate pixel colors for only those primitives that appear in the final image (i.e., exact HSR). Deferred shading generally requires the primitives to be accumulated before HSR can begin. For a frame with only opaque primitives, the HSR process determines the single visible primitive at each sample within all the pixels. Once the visible primitive is determined for a sample, then the primitive's color at that sample location is determined. Additional efficiency can be achieved by determining a single per-pixel color for all the samples within the same pixel, rather than computing per-sample colors.","For a frame with at least some alpha blending (as defined in the above referenced OpenGL specification) of primitives (generally due to transparency), there are some samples that are colored by two or more primitives. This means the HSR process must determine a set of visible primitives per sample.","In some APIs, such as OpenGL, the HSR process can be complicated by other operations (that is by operation other than depth test) that can discard primitives. These other operations include: pixel ownership test, scissor test, alpha test, color test, and stencil test (as described elsewhere in this specification). Some of these operations discard a primitive based on its color (such as alpha test), which is not determined in a deferred shading pipeline until after the HSR process (this is because alpha values are often generated by the texturing process, included in pixel fragment coloring). For example, a primitive that would normally obscure a more distant primitive (generally at a greater z-value) can be discarded by alpha test, thereby causing it to not obscure the more distant primitive. A HSR process that does not take alpha test into account could mistakenly discard the more distant primitive. Hence, there may be an inconsistency between deferred shading and alpha test (similarly, with color test and stencil test); that is, pixel coloring is postponed until after HSR, but HSR can depend on pixel colors. Simple solutions to this problem include: 1) eliminating non-depth-dependent tests from the API, such as alpha test, color test, and stencil test, but this potential solution might prevent existing programs from executing properly on the deferred shading pipeline; and 2) having the HSR process do some color generation, only when needed, but this potential solution would complicate the data flow considerably. Therefore, neither of these choices is attractive. A third alternative, called conservative hidden surface removal (CHSR), is one of the important innovations provided by the inventive structure and method. CHSR is described in great detail in subsequent sections of the specification.","Another complication in many APIs is their ability to change the depth test. The standard way of thinking about 3D rendering assumes visible objects are closer than obscured objects (i.e., at lesser z-values), and this is accomplished by selecting a \u201cless-than\u201d depth test (i.e., an object is visible if its z-value is \u201cless-than\u201d other geometry). However, most APIs support other depth tests such as: greater-than, less-than, greater-than-or-equal-to, equal, less-than-or-equal-to, less-than, not-equal, and the like algebraic, magnitude, and logical relationships. This essentially \u201cchanges the rules\u201d for what is visible. This complication is compounded by an API allowing the application program to change the depth test within a frame. Different geometry may be subject to drastically dfferent rules for visibility. Hence, the time order of primitives with different rendering rules must be taken into account. If they are rendered in the order A, B, then C, primitive C will be the final visible surface. However, if the primitives are rendered in the order C, B, then A, primitive A will be the final visible surface. This illustrates how a deferred shading pipeline must preserve the time ordering of primitives, and correct pipeline state (for example, the depth test) must be associated with each primitive.","Deferred Shading Graphics Pipeline","Provisional U.S. patent application Ser. No. 60\/097,336; filed Aug. 20, 1998, describes various embodiments of novel deferred Shading Graphics Pipelines. The present invention, and its various embodiments, is suitable for use as the Texture Block in the various embodiments of that differed shading graphics pipeline, or for use with other graphics pipelines which do not use differed shading. Details of such graphics pipelines are for convenience not described again herein.","Texture","The Texture Block of a graphics pipeline applies texture maps to the pixel fragments. Texture maps are stored in Texture Memory, which is typically loaded from the host computer's memory using the AGP interface. In one embodiment, a single polygon can use up to eight textures, although alternative embodiments allow any desired number of textures per polygon.","The inventive structure and method may advantageously make use of trilinear mapping of multiple layers (resolutions) of texture maps. Texture maps are stored in a Texture Memory which may generally comprise a single-buffered memory loaded from the host computer's memory using the AGP interface. In the exemplary embodiment, a single polygon can use up to eight textures. Textures are MIP-mapped. That is, each texture comprises a series of texture maps at different levels of detail, each map representing the appearance of the texture at a given distance from the eye point. To produce a texture value for a given pixel fragment, the Texture Block performs tri-linear interpolation from the texture maps, to approximate the correct level of detail. The Texture Block can, in conjunction with the Fragment Block, perform other interpolation methods, such as anisotropic interpolation.","The Texture Block supplies interpolated texture values (generally as RGBA color values) to the graphics pipeline shading block on a per-fragment basis. Bump maps represent a special kind of texture map. Instead of a color, each texel of a bump map contains a height field gradient. The multiple layers are MIP layers, and interpolation is within and between the MIP layers. The first interpolation is within each layer, then you interpolate between the two adjacent layers, one nominally having resolution greater than required and the other layer having less resolution than required, so that it is done three-dimensionally to generate an optimum resolution.","Detailed Description of Texture Pipeline","Referring to FIG. F, there is shown a block diagram of one embodiment of a texture pipeline constructed in accordance with the present invention. Texture unit  receives texture coordinates for individual fragments, accesses the appropriate texture maps stored in texture memory, and generates a texture value for each fragment. The texture values are sent downstream, for example to a shading block which may then combine the texture value with other image information such as lighting to generate the final color value for a fragment.","Texture Setup  receives data packets, for example, from the Fragment unit of U.S. Provisional Patent application 60\/097,336. Data packets provide texture LOD data for the texture maps, and potentially visible fragment data for an image to be rendered. The fragment data includes (s, t, r) texture coordinates for each fragment. As shown in FIG. D, the (s, t) coordinates are normalized texture space coordinates. For 3D textures, the \u201cr\u201d index is used to indicate texture depth. The s and t coordinates are floating point numbers. Texture setup  translates the s, and t coordinates into i, i, j, j (4 bilinear samples) and","LODA\/LODB (adjacent LODs for trilinear mipmapping) coordinates. The i, i, j, j coordinates are 12 bit unsigned integers. LODA and LODB are 4 bit integers, for example with LODA being the stored LOD greater than the actual LOD, and LODB being the stored LOD less than the actual LOD. For 3D textures the r coordinate is converted into a k coordinate. In a trilinear mipmapping embodiment, each fragment has eight texture coordinates associated with it. The i, j, and LOD\/k values are all transferred to Dualoct Bank Mapping unit .","The Fragment Unit receives S, T, R coordinates in floating point format. Setup converts these S, T, R coordinates into U, V, W coordinates, which are fixed point coordinates used prior to texture look-up. The Texture Block then performs a texture look-up and provides i, j, k coordinates, which are integer coordinates mapped in normalized space. Thus, u=i x texture width, v=j x texture height, and w=k x texture depth.","Texture Maps","Texture maps are allocated to Texture Memory  and Texel Prefetch Buffer  using methods to minimize memory conflicts and maximize throughput. Dualoct Bank Mapping unit  maps the i, j, and LOD\/k coordinates into Texture Memory  and Texel Prefetch Buffer . Dualoct Bank Mapping unit  also generates tags for texels stored in Texel Prefetch Buffer . The tags are stored in the eight Tag Banks - through -. The tags indicate whether a texel is stored in Texel Prefetch Buffer , and the location of the texel in the buffer.","Texture Memory Management Unit (MMU)  controls access to Texture Memory . Texture Memory  stores the active texture maps. If a texel is not found in Texel Prefetch Buffer , then Texture MMU  requests the texel from Texture Memory . If the texel is from a texture map not stored in Texture Memory  then the texture map can be retrieved from another source as is shown in FIG. F. Texture memory has, in various embodiments, access to Frame buffer , AGP memory , Virtual memory , with Virtual memory in turn having access to disk  and network . Thus, a variety of locations are available for texture addresses to be received in the event of a miss in order to greatly reduce the instances where a needed texel is ultimately not available at the time it is needed in the pipeline, since there is time between the determination of a texture cache miss and the time that texel is actually needed later on down the pipeline.","After the texels for a given fragment are retrieved, Texture Interpolator  interpolates the texel color values to generate a color value for the fragment. The color value is then inserted into a packet and sent down the pipeline, for example to a shading block.","A texture array is divided into 2\u00d72 texel blocks. Each texel block in an array is represented in Texture Memory. Texturing a given fragment with tri-linear mipmapping requires accessing two to eight of these blocks, depending on where the fragment falls relative to the 2\u00d72 blocks. For trilinear mipmapping for each fragment, up to eight texels must be retrieved from memory. Ideally all eight texels are retrieved in parallel. As shown in FIG. F, to provide all eight texels in parallel, Texel Prefetch Buffer  consists of eight independently accessible memory banks  through -. Similarly, as shown in FIG. F, Texture Memory  includes a plurality of Texture Memory Devices, organized into a plurality of channels, such as channels - and -. To access all eight texels in parallel from Texel Prefetch Buffer  each texel must be stored in a separate Prefetch Buffer Bank.","Texture Tile Addressing","To maximize the memory throughput the texels in the texture maps are re-mapped into a spatially coherent form using texture tile addresses. The texels required to generate adjacent fragments depend upon the orientation of the object being rendered, and the depth location of the object in the scene. For example, adjacent fragments of a surface of an object at a large skew angle with respect to the viewing point will use texels at farther distances apart in the selected LOD than adjacent fragments of a surface that are approximately perpendicular to the viewing point. However, there is typically some spatial coherence between groups of fragments in close proximity and the texels used to generate texture for the fragments. Therefore, the texture tile addresses for the texels in the texture maps are defined so as to maximize the spatial coherence of the texture maps.","FIG. Fand Fillustrate a spatially coherent texel mapping for texture memory , including texture map , including texture \u201csuper blocks\u201d - through -. In one embodiment, a RAMBUS\u2122, RAMBUS Corp., Mountain View Calif., memory is used for Texture Memory . The smallest accessible data structure in RAMBUS memory is a \u201cDualoct\u201d which is 16 bytes. Each texel contains 32 bits of color data in the format RGBA-8, or Lum\/Alpha 16. Four texels can therefore be stored in each dualoct. The X and Y axis of FIG. Fand Finclude dualoct labels. The (X,Y) coordinates correspond to the (i, j) coordinates with the least significant bit of (i, j) dropped. FIG. Fillustrates how the texels are renumbered within each dualoct. The texels are numbered sequentially starting at the origin of each dualoct and increasing sequentially in a counterclockwise order. FIG. Fshows how texel locations are remapped from linear addressing to a reconfigured address including a \u201cswirl address\u201d portion.","Referring to FIG. F, sector -- shows the swirl pattern mapping for 16 dualocts. The four bit labels in each dualoct indicate the dualoct number that is used to generate an address for storing the dualoct in RAMBUS Texture Memory  and Texel Prefetch Buffer . Each dualoct shown in FIG. Fcontains 4 texels arranged as shown in FIG. F. Dualocts are renumbered sequentially in groups of four, starting at the origin and moving in a counter-clockwise direction. After renumbering a group of dualocts, the next group of four dualocts are selected moving in a counter clockwise direction around the sector. After all four groups in a sector have been renumbered, the renumbering pattern is repeated for the next sector (i.e., sector --) moving counter-clockwise around a dualoct block. For example, after the 16 dualocts in sector --, the dualoct numbers continue in sector -- which contains dualoct numbers - which are numbered in the same pattern as sector --. This pattern is then repeated in sector -- and in sector --. Dualoct block  (-) consists of the four sectors -- through --. The dualoct block  pattern is then repeated in dualoct block  (-) starting with dualoct number , followed by dualoct block  (-), and dualoct block  (-). In one embodiment, the recursive swirl pattern stops at the texture super block  () level.","Alternative spatially coherent patterns are used in alternative embodiments, rather than the recursive swirl pattern illustrated in FIG. Fand . FIG. F illustrates a super block  of a texture map that is mapped using one such alternative pattern. Super block  includes sectors -. The dualoct numbering pattern within each sector is the same for the super block  pattern as for texture super block  () shown in FIG. F. However, rather than repeating the counter-clockwise swirl pattern at the sector level, the dualoct numbers at the sector level follow the pattern indicated by the sector numbers - in FIG. F, limiting the swirl size to 64\u00d764 texels.","FIG. F illustrates the dualoct numbering pattern at the super block level of a texture map . At the super block level the pattern changes to a simple linear mapping, since in certain embodiments it has been determined that beyond 64\u00d764 texels recursive swirling patterns begin to hurt spatial locality. The swirling is inherently a square operation, implying that it does not work very well at large sizes of rectangular but non-square textures, and textures with border information. Limiting the swirl to 64\u00d764 in certain embodiments of this invention, limits the minimum allocated size to a manageable amount of memory. In accordance with this invention, the swirling scheme provides that, upon servicing a miss request, the four samples fetched will reside in distinct memory banks of the prefetched buffer, thus avoiding bank conflict. Furthermore, the swirling scheme maximizes subsequent hits to the prefetched buffer so that misses are typically spread out, so the memory system can service requests while the texture unit is working on hit data, thus minimizing stalls. The next super block of dualocts after texture super block  () is located directly to the right of texture super block  (). This linear pattern is repeated until super block n\/64, and then a new row of super blocks is started with super block n\/64+1, as shown.","The spatially coherent texel mapping patterns illustrated in FIGS. F, Fand F are designed to maximize the likelihood that the four texels used to generate texture for a fragment will be stored either in separate Texel Prefetch Buffer  banks, or separate Texture Memory  devices.","Memory Addressing","Referring to FIG. F, Texel Prefetch Buffer  includes eight Prefetch Buffer Banks - through -. FIG. Fshows how the numbered dualocts in FIG. Fmap into the eight Prefetch Buffer Banks - through -. Also shown are the four texels fetched for a particular pixel location , shown in FIG. F, appearing without a memory conflict. FIG. Fshows the texels stored for one LOD. For trilinear mipmapping, Banks - through - contain texels for the second LOD.","Referring to FIG. F, there is shown a block diagram of one embodiment of Texture Memory . Texture Memory  has two channels - and -. Each channel contains eight devices -- through -- and -- through --, respectively. Each device has an independent set of addresses and independent I\/O data lines to allow data to be independently accessed in each of the eight devices. Each device contains sixteen banks, meaning that in this embodiment there are 256 open pages, clearly reducing the likelihood of memory conflict. In one embodiment each channel is a 64 Mbyte memory.","To map the texels in the texture map into a spatially coherent format, Dualoct Bank Mapping unit  generates a texture tile address for each dualoct. FIG. F illustrates a texture tile address data structure  according to one embodiment of the present invention. Texture Field ID  field is an 11 bit field that defines the texture that is being referenced. Up to 2048 different textures can be used in a single display. These textures may be stored in any memory resource. Each fragment may then reference up to eight different textures. When a texture is referenced that is not in Texture Prefetch Buffer , Texture MMU  loads the memory from an external memory resource, and if necessary de-allocates the required Texture Prefetch Buffer  space to load the new texture. The LOD  field is a 4 bit field that defines the LOD to be used in the selected texture map. The U, V fields  and  are 11 bit fields for texture coordinates with a range from 0-2047. The U, V fields for each dualoct are defined to generate the spatially coherent format, such as the format shown in FIG. Fand F. For 3D textures, the 4 LSB's of the Texture field ID  contain the 4 MSB's of the texture R coordinate, which is a texture depth index generated from the k coordinate. Dualoct Bank Mapping unit  provides the four R coordinate bits whenever a 3D texture operation is in the pipeline. Thereafter, 3D texture tile addresses are essentially treated the same as 2D and 1D addresses.","The texture tile address is provided to Texture MMU  which generates a corresponding texture memory address. Texture MMU  performs the texture file address to texture memory address translation using a linear mapping of the texture tile address into a table of texture memory addresses stored in Texture Memory . This table is maintained by software. FIG. F illustrates a texture memory address data structure  for a RAMBUS\u2122 Texture Memory . Texture memory address data structure  is designed to maximize the likelihood that the dualocts required to generate the texture for a fragment will be stored in different Texture Memory pages, as shown in FIG. F. In one embodiment, Device field  consists of the least significant 3 bits of the texture memory address data structure . Device field  defines the texture memory device that a dualoct is stored in. Therefore, each sequential dualoct, as defined by the mapped texture, is stored in a different texture memory device. The Bank field  comprises the next four low order bits, followed by a 1 bit Channel field , a 9 bit Row field  and a 6 bit Column field .","The texture memory address data structure  is also programmable. This allows the texture memory address to accommodate different memory configurations, and to alter the placement of bit fields to optimize the access to the texture data. For example, an alternative memory configuration may have more than eight texture memory devices.","Texels are loaded from Texture Memory  into Texel Prefetch Buffer  to provide higher speed access. When texels are moved into Texel Prefetch Buffer , a corresponding tag is created in one of the eight Prefetch Buffer Tag Blocks - through -, shown in FIG. F. Each of the eight Tag Blocks - through - has a corresponding memory Queue - through -. Note that the tags are 64 entries, and the cache SRAM's are 256 entries. This mapping allows each Prefetch Buffer tag entry to map a \u201cline\u201d of 4 texels across four Prefetch Buffer Banks, as shown in Texel Prefetch Buffer  in FIG. F. This mapping allows 4 texels to be retrieved from four separate Prefetch Buffer Banks every cycle, thus ensuring maximum texture data access bandwidth. Each Tag Block may receive up to one texture tile address per cycle. The texture tile address points to a particular dualoct of 4 texels. Each Tag Block entry points to one dualoct line of texels in Texel Prefetch Buffer  memory. The incoming texture tile address is checked against the contents of the Tag Block to determine whether the desired dualoct is stored in Texel Prefetch Buffer .","FIG. Fshows the texels stored for one LOD. For trilinear mipmapping, Banks - through - contain texels for the second LOD. The Texture ID  bit [] in the texture tile address is used to control whether an LOD gets mapped to Prefetch Buffer Banks - (- through -) or Banks - (- through -). If Texture ID  bit []=0, then the even LOD's (LOD[]=0) are mapped into Prefetch Buffer Banks -, and the odd LOD's (LOD[]=1) are mapped into Prefetch Buffer Banks -. Conversely, if Texture ID[]=1 then the odd LOD's are mapped into Prefetch Buffer Banks -, and the even LOD's are mapped into Prefetch Buffer Banks -. This mapping ensures that all eight tags can be accessed in each cycle, and that texture information is evenly distributed in the caches. Dualoct Bank Mapping unit  also follows this LOD mapping rule when sending texture tile addresses to the corresponding Tag Block - through -, shown in FIG. F","To generate a texture for a fragment, Dualoct Bank Mapping unit  generates up to eight dualoct requests, and sends them to the appropriate Prefetch Buffer Bank. The Prefetch Buffer Tags - through - are checked for a match. If there is a hit, the request is sent to the appropriate bank of Memory Queue . When the memory request exits Memory Queue , the line number is sent to Texel Prefetch Buffer  to look-up the data. If there is a miss on a given texture tile address, then a miss request is put into the miss queue for the corresponding tag block. The miss address is eventually read out of the miss queue and forwarded to Texture MMU . The miss request is then serviced, the data is retrieved from Texture Memory  or another external memory source, and is ultimately provided to the appropriate Texel Prefetch Buffer Banks - through -.","Each line in Memory Queue  records one memory access for a particular texture operation on one fragment of data. Memory requests are received at the top of Memory Queue , and when they reach the bottom, Texel Prefetch Buffer  is accessed for the data. Miss data is only filled into Texel Prefetch Buffer  when a particular miss request reaches the bottom of the corresponding memory Queue - through -.","Each of the eight memory Queues - through - hold up to eight pending miss addresses for a particular Prefetch Buffer Bank - through -. If a memory Queue is not empty, then it can be assumed to contain at least one valid address. Every clock cycle Prefetch Buffer Controller  scans the memory Queues - through - searching for a valid entry. When a miss address is found, it is sent to Texture MMU .","FIG. F is a Texture Tile Address Structure which serves as the tag for Texel Prefetch Buffer . When this tag indicates a Texel Prefetch Buffer miss, a Texture Memory  look-up is needed. The Virtual Address Structure includes an 11 bit texture ID , a four bit LOD , and 11 bit U and V addresses  and . This Virtual Address of FIG. F serves as a tag entry in tag memories - through - (FIG. F). In the event of a miss, a look-up in Texture Memory  is required.","FIG. F depicts pointer look-up translation tag block , which is stored, for example, in a dedicated portion of the texture memory, and is addressed using the 11 bit texture ID and four bit LOD number, forming a 15 bit index to locate the pointer of FIG. F. The pointer, once located, points to a base address within texture memory where the start of the desired texture\/LOD is stored. This base address is then appended by addresses to be created by the U and V components of the virtual address to create the virtual address of a dualoct, which in turn is mapped to the physical address of RAMBus memory using the address structure of FIG. F.","FIG. F is a diagram depicting the address reconfigurations and process for re-configuring the addresses with respect to FIGS. F, F, F, and F. As shown in FIG. F, texture tile address structure  (previously discussed with reference to FIG. F) serves as a tag for Texel Prefetch Buffer . When this tag indicates a Texel Prefetch Buffer miss, a texture memory  look-up is needed. Translation buffer  uses the 11-bit texture ID and four-bit LOD to form a 15 bit index to pointer look-up translation tag block  (previously discussed with reference to FIG. F). Swirl addresses block  remaps the bits from texture tile address data structure  to form the \u201cswirl address\u201d  (previously discussed with respect to FIGS. F-). Adder  combines the pointer look-up translation tag block  and \u201cswirl address\u201d  to form the physical address  to address RAMBus memory (as previously discussed with respect to FIG. F).","Reorder Logic","FIG. Fis a block diagram depicting one embodiment of Read Miss Control Circuitry . Read Miss Control Circuity  receives a read miss request from the miss logic shown in FIG. F, when the tag mechanism determines that the desired information is not contained in texel prefetch buffer . There are four types of read miss requests: texture look-up (miss), copy texture, read texture, and Auxring read dualoct (a maintenance utility function). The read miss requests received by read control circuitry  are prioritized by prioritization block , for example, in the order listed above. Prioritization block  sends the read request to the appropriate channel based upon the channel bit (FIG. F) contained in the texture memory address to be accessed. These addresses are thus sent to request queues - and -, which, in one embodiment, are 32 addresses deep. The addresses stored in request queues - and - are applied to reorder logic circuity - and -, respectively, which in turn access RAMBus memory controller . Reorder logic - and - reorder the addresses received from request queues - and - in order to avoid memory conflict in texture memory, as will be described with respect to FIG. F. Since reorder logic - and - reorder the memory addresses to be accessed by RAMBus memory controller , tag queue  keeps track of channel and requester information. The accessed data is output to in-order return queue , where the results are placed in the appropriate slots based upon the original order as indicated by queues  and . The data, once stored in proper order in in-order return queue  is then provided to its requestor as data and a data valid signal. In one embodiment, the data is output in a 144 bits wide, which corresponds to a dualoct.","FIG. Fis a block diagram of one embodiment of this invention which includes reorder logic - (with reorder logic - being identical), and showing RAMBus memory controller . The purpose of reorder logic  is to monitor incoming address requests and reorder those requests so as to avoid memory conflicts in RAMBus memory controller . For each memory address received as a request on Bus , conflict detection block  determines if a memory conflict is likely to occur based upon the addresses contained in first level reorder queue . If not, that address is directly forwarded to control block , and is added to first level reorder queue , to allow for conflict checking of subsequently received addresses. On the other hand if a conflict is determined by conflict detection block , the conflicting address request is sent to conflict queue . In one embodiment, in order to prevent conflicting address requests from being utilized too distant from other requests received in the same recent time frame, 32 address requests are received by conflict detection block  and either forwarded to control block  (no conflict), or placed in conflict queue , after which the addresses stored in conflict queue  are output to control circuit . In this manner, the reordered address requests are applied to reordered address queue  to access RAMBus memory controller  with fewer, and often times zero, conflicts, in contrast to the conflict situations which would exist if the original order of the read request were applied directly to RAMBus memory controller  without any reordering.","In-Order tag queue  and out-of-order tag queue  maintains tag information in order to preserve the original address order so that when the results are looked up and output from reorder logic - and -, the desired (original) order is maintained.","Information read from RAMBus memory controller  is stored in read data queue . Through control block , data from queue  is forwarded to either out-of-order queue  or in-order queue . Control block  reassembles data from queues  and  in the original request order and forwards it to the appropriate channel port of block  in order. Control block  receives channel specific data from blocks - and - which is then re-associated and issued back to the waiting requester.","The inventive pipeline includes a texture memory which includes a prefetch buffer. The host also includes storage for texture, which may typically be very large, but in order to render a texture, it must be loaded into texture memory. Associated with each VSP are S and T's. In order to perform trilinear MIP mapping, we necessarily blend eight (8) samples, so the inventive structure provides a set of eight content addressable (memory) caches running in parallel. In one embodiment, the cache identifier is one of the content addressable tags, and that's the reason the tag part of the cache and the data part of the cache are located separate. Conventionally, the tag and data are co-located so that a query on the tag gives the data. In the inventive structure and method, the tags and data are split up and indices are sent down the pipeline.","The data and tags are stored in different blocks and the content addressable look-up is a look-up or query of an address, and even the \u201cdata\u201d stored at that address in itself an index that references the actual data which is stored in a different block. The indices are determined, and sent down the pipeline so that the data referenced by the index can be determined. In other words, the tag is in one location, the texture data is in a second location, and the indices provide a link between the two storage structures.","In one embodiment of the invention, the prefetch buffer comprises a multiplicity of associative memories, generally located on the same integrated circuit as the texel interpolator. In the preferred embodiment, the texel reuse detection method is performed in the Texture Block.","In conventional 3-D graphics pipelines, an object in some orientation in space is rendered. The object has a texture map associated with it, which is represented by many triangle primitives. The procedure implemented in software, will instruct the hardware to load the particular object texture into a Texture Memory. Then all of the triangles that are common to the particular object and therefore have the same texture map are fed into the unit and texture interpolation is performed to generate all of the colored pixels needed to represent that particular object. When that object has been colored, the texture map in DRAM can be destroyed since, for example by a reallocation algorithm, the object has been rendered. If there are more than one object that have the same texture map, such as a plurality of identical objects (possibly at different orientations or locations), then all of that type of object may desirably be textured before the texture map in DRAM is discarded. Different geometry may be fed in, but the same texture map could be used for all, thereby eliminating any need to repeatedly retrieve the texture map from host memory and place it temporarily in one or more pipeline structures.","In more sophisticated conventional schemes, more than one texture map may be retrieved and stored in the memory, for example two or several maps may be stored depending on the available memory, the size of the texture maps, the need to store or retain multiple texture maps, and the sophistication of the management scheme. Each of these conventional texture mapping schemes, spatial object coherence is of primary importance. At least for an entire single object, and typically for groups of objects using the same texture map, all of the triangles making up the object are processed together. The phrase spatial coherency is applied to such a scheme because the triangles form the object and are connected in space, and therefore spatially coherent.","In the inventive structure and method, a sizable memory is supported on the card. In one implementation 128 megabytes are provided, but more or fewer megabytes may be provided. For example, 32 Mb, 64 Mb, 256 Mb, 512 Mb, or more may be provided, depending upon the needs of the user, the real estate available on the card for memory, and the density of memory available.","Rather that reading the eight texels for every visible fragment, using them, and throwing them away so that the eight texels for the next fragment can be retrieved and stored, the inventive structure and method stores and reuses them when there is a reasonable chance they will be needed again.","It would be impractical to read and throw away the eight texels every time a visible fragment is received. Rather, it is desirable to make reuse of these texels, because if you're marching along in tile space, your pixel grid within the tile (typically processed along sequential rows in the rectangular tile pixel grid) could come such that while the same texture map is not needed for sequential pixels, the same texture map might be needed for several pixels clustered in an area of the tile, and hence needed only a few process steps after the first use. Desirably, the invention uses the texels that have been read over and over, so when we need one, we read it, and we know that chances are good that once we have seen one fragment requiring a particular texture map, chances are good that for some period of time afterward while we are in the same tile, we will encounter another fragment from the same object that will need the same texture. So we save those things in this cache, and then on the fly we look-up from the cache (texture reuse register) which ones we need. If there is a cache miss, for example, when a fragment and texture map are encountered for the first time, that texture map is retrieved and stored in the cache.","Texture Map retrieval latency is another concern, but is handled through the use of First-In-First-Out (FIFO) data structures and a look-ahead or predictive retrieval procedure. The FIFO's are large and work in association with the CAM. When an item is needed, a determination is made as to whether it is already stored, and a designator is also placed in the FIFO so that if there is a cache miss, it is still possible to go out to the relatively slow memory to retrieve the information and store it. In either event, that is if the data was in the cache or it was retrieved from the host memory, it is placed in the unit memory (and also into the cache if newly retrieved).","Effectively, the FIFO acts as a sort of delay so that once the need for the texture is identified (prior to its actual use) the data can be retrieved and re-associated, before it is needed, such that the retrieval does not typically slow down the processing. The FIFO queues provide and take up the slack in the pipeline so that it always predicts and looks ahead. By examining the FIFO, non-cached texture can be identified, retrieved from host memory, placed in the cache and in a special unit memory, so that it is ready for use when a read is executed.","The FIFO and other structures that provide the look-ahead and predictive retrieval are provided in some sense to get around the problem created when the spatial object coherence typically used in per-object processing is lost in our per-tile processing. One also notes that the inventive structure and method makes use of any spatial coherence within an object, so that if all the pixels in one object are done sequentially, the invention does take advantage of the fact that there's temporal and spatial coherence.","The Texture Block caches texels to get local reuse. Texture maps are stored in texture memory in 2\u00d72 blocks of RGBA data (16 bytes per block) except for normal vectors, which may be stored in 18 byte blocks.","Virtual Texture Numbers","The user provides a texture number when the texture is passed from user space with OpenGL calls. The user can send some triangles to be textured with one map and then change the texture data associated with the same texture number to texture other triangles in the same frame. Our pipeline requires that all sets of texture data for a frame be available to the Texture Block. The driver assigns a virtual texture number to each texture map.","Texture Memory","Texture Memory stores texture arrays that the Texture Block is currently using. Software manages the texture memory, copying texture arrays from host memory into Texture Memory. It also maintains a table of texture array addresses in Texture Memory.","Texture Addressing","The Texture Block identifies texture arrays by virtual texture number and LOD. The arrays for the highest LODs are lumped into a single record. A texture array pointer table associates a texture array ID (virtual texture number concatenated with the LOD) with an address in Texture Memory. We need to support thousands of texture array pointers, so the texture array pointer table will have to be stored in Texture Memory. We need to map texture array IDs to addresses approximately 500M times per second. Fortunately, adjacent fragments will usually share the same the texture array, so we should get good hit rates with a cache for the texture array pointers. (In one embodiment, the size of the texture array cache is 128 entries, but other sizes, larger or smaller, may be implemented.)","The Texture Block implements a direct map algorithm to search the pointer table in memory. Software manages the texture array pointer table, using the hardware look-up scheme to store table elements.","Texture Memory Allocation","Software handles allocation of texture memory. The Texture Block sends an interrupt to the host when it needs a texture array that is not already in texture memory. The host copies the texture array from main memory frame buffer to texture memory, and updates the texture array pointer table, as described above. The host controls which texture arrays are overwritten by new data.","The host will need to rearrange texture memory to do garbage collection, etc. The hardware will support the following memory copies: (a) host to memory, (b) memory to host, and (c) memory to memory.","Conventional Lighting\/Bump Mapping Approaches","The invention described herein is a system and method for performing tangent space lighting in a deferred shading architecture. As documented in the detailed description, in a deferred shading architecture implemented in accordance with the present invention floating point-intensive lighting computations are performed only after hidden surfaces have been removed from the graphics pipeline. This can result in dramatically fewer lighting computations than in the conventional approach described in reference to FIG. G , where shading computations (FIG. G , ) are performed for nearly all surfaces before hidden pixels are removed in the z-buffered blending operation (FIG. G , ). To illustrate the advantages of the present invention a description is now provided of a few conventional approaches to performing lighting computations, including bump mapping. One of the described approaches is embodied in 3D graphics hardware sold by Silicon Graphics International (SGI).","The theoretical basis and implementation of lighting computations in conventional 3D graphics systems is well-known and is thoroughly documented in the following publications, which are incorporated herein by reference: (1) Phong, B. T., , Communications of the ACM 18, 6 (June 1975), 311-317 (hereinafter referred to as the Phong reference); (2) Blinn, J. F., , In Computer Graphics (SIGGRAPH '78 Proceedings) (August 1978), vol. 12, pp. 286-292 (hereinafter referred to as the Blinn reference); (3) Watt, Alan, 3(2nd ed.), p. 250 (hereinafter referred to as the Watt reference); (4) Peercy, M. et al., , In Computer Graphics (SIGGRAPH '97 Proceedings) (July 1997), vol. 8, pp. 303-306 (hereinafter referred to as the Peercy reference).","Generally, lighting computations generate for each pixel of a surface an RGBA color value that accounts for the surface's color, orientation and material properties; the orientation and properties of the surface illumination; and the viewpoint from which the illuminated surface is observed. The material properties can include: fog, emissive color, reflective properties (ambient, diffuse, specular) and bump effects. The illumination properties can include for one or more lights: color (global ambient, light ambient, light diffuse, light specular) and attenuation, spotlight and shadow effects.","There are many different lighting models that can be implemented in a 3D graphics system, including Gouraud shading and Phong shading. In Gouraud shading, lighting computations are made at each vertex of an illuminated surface and the resulting colors are interpolated. This technique is computationally simple but provides many undesirable artifacts, such as mach banding. The most realistic lighting effects are provided by Phong shading, where lighting computations are made at each pixel based on interpolated and normalized vertex normals. Typically, a graphics system supports many different lighting models. However, as a focus of the present invention is to efficiently combine Phong shading and bump mapping, the other lighting models are not further described.","Lighting Computations","Referring to FIG. G  there is shown a diagram illustrating the elements employed in the lighting computations of both the conventional approach and the present invention. This figure does not illustrate the elements used in bump mapping calculations, which are shown in FIG. G . The elements shown in FIG. G  are defined below.","Definitions of Elements of Lighting Computations",{"@attributes":{"id":"p-1465","num":"0000"},"ul":{"@attributes":{"id":"ul0018","list-style":"none"},"li":["V the position of the fragment to be illuminated in eye coordinates (V, V, V).","{circumflex over (N)} the unit normal vector at the fragment(N, N, N).","Pthe location of the light source in eye coordinates (P, P, P).","Pindicates whether the light is located at infinity (0=infinity). If the light is at infinity then Prepresents the coordinates of a unit vector from the origin to the light, {circumflex over (P)}","Pthe location of the viewer (viewpoint). In eye coordinates the viewpoint is at either (0, 0, 0) or (0, 0, \u221e). This is specified as a lighting mode.","\u00ca is the unit vector from the vertex to the viewpoint, P, and is defined as follows:"]}},{"@attributes":{"id":"p-1466","num":"1516"},"maths":{"@attributes":{"id":"MATH-US-00032","num":"00032"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mover":{"mi":"E","mo":"^"},"mo":"=","mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":["E","x"]}}},{"mtd":{"msub":{"mi":["E","y"]}}},{"mtd":{"msub":{"mi":["E","z"]}}}]}}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mo":"{","mrow":{"mtable":{"mtr":[{"mtd":[{"mrow":{"mfrac":{"mn":"1","msub":{"mi":["d","E"]}},"mo":"\u00b7","msup":{"mrow":{"mo":["[","\u2062","\u2062","]"],"mstyle":[{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}},{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}}],"mtable":{"mtr":{"mtd":[{"mrow":{"mo":["(",")"],"mrow":{"mo":"-","msub":{"mi":["V","x"]}}}},{"mrow":{"mo":["(",")"],"mrow":{"mo":"-","msub":{"mi":["V","y"]}}}},{"mrow":{"mo":["(",")"],"mrow":{"mo":"-","msub":{"mi":["V","z"]}}}}]}}},"mi":"T"}}},{"mrow":{"mrow":[{"mi":"for","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["P","E"]}},{"mo":["(",")"],"mrow":{"mn":["0","0","0"],"mo":[",",","]}}],"mo":"="}}]},{"mtd":[{"msup":{"mrow":{"mo":["[","\u2062","\u2062","]"],"mstyle":[{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}},{"mspace":{"@attributes":{"width":"0.em","height":"0.ex"}}}],"mtable":{"mtr":{"mtd":[{"mn":"0"},{"mn":"0"},{"mn":"1"}]}}},"mi":"T"}},{"mrow":{"mrow":[{"mi":"for","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["P","E"]}},{"mo":["(",")"],"mrow":{"mn":["0","0"],"mo":[",",","],"mi":"\u221e"}}],"mo":"="}}]}]},"mo":["\u2062","\u2062"],"mstyle":{"mtext":{}},"mi":"where"}}}}},{"mtd":{"mrow":{"msub":{"mi":["d","E"]},"mo":"=","msqrt":{"mrow":{"msubsup":[{"mi":["V","x"],"mn":"2"},{"mi":["V","y"],"mn":"2"},{"mi":["V","z"],"mn":"2"}],"mo":["+","+"]}}}}}]}}},"ul":{"@attributes":{"id":"ul0019","list-style":"none"},"li":"{circumflex over (L)} is the unit vector from the vertex to the light, Pand is defined as follows:"}},{"@attributes":{"id":"p-1467","num":"1518"},"maths":{"@attributes":{"id":"MATH-US-00033","num":"00033"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mover":{"mi":"L","mo":"^"},"mo":"=","mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":["L","x"]}}},{"mtd":{"msub":{"mi":["L","y"]}}},{"mtd":{"msub":{"mi":["L","z"]}}}]}}}}},{"mtd":{"mrow":{"mo":"=","mrow":{"mo":"{","mrow":{"mtable":{"mtr":[{"mtd":[{"mrow":{"mfrac":{"mn":"1","msub":{"mi":["d","L"]}},"mo":"\u00b7","mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["P","Lx"]},{"mi":["V","x"]}],"mo":"-"}}}},{"mtd":{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["P","Ly"]},{"mi":["V","y"]}],"mo":"-"}}}},{"mtd":{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["P","Lz"]},{"mi":["V","z"]}],"mo":"-"}}}}]}}}},{"mrow":{"mrow":{"mi":"for","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["P","Li"]}},"mo":"=","mi":"local"}}]},{"mtd":[{"mrow":{"mo":["[","]"],"mtable":{"mtr":[{"mtd":{"msub":{"mi":["P","Lx"]}}},{"mtd":{"msub":{"mi":["P","Ly"]}}},{"mtd":{"msub":{"mi":["P","Lz"]}}}]}}},{"mrow":{"mrow":{"mi":"for","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["P","Li"]}},"mo":"=","mi":"\u221e"}}]}]},"mo":["\u2062","\u2062"],"mstyle":{"mtext":{}},"mi":"where"}}}}},{"mtd":{"mrow":{"msub":{"mi":["d","L"]},"mo":"=","msqrt":{"mrow":{"msup":[{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["P","Lx"]},{"mi":["V","x"]}],"mo":"-"}},"mn":"2"},{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["P","Ly"]},{"mi":["V","y"]}],"mo":"-"}},"mn":"2"},{"mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":["P","Lz"]},{"mi":["V","z"]}],"mo":"-"}},"mn":"2"}],"mo":["+","+"]}}}}}]}}},"ul":{"@attributes":{"id":"ul0020","list-style":"none"},"li":"\u0124 is the unit vector half way between \u00ca and {circumflex over (L)}, and is defined as follows:"}},{"@attributes":{"id":"p-1468","num":"1520"},"maths":{"@attributes":{"id":"MATH-US-00034","num":"00034"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mover":{"mi":"H","mo":"^"},"mo":"=","mrow":{"mfrac":{"mover":{"mi":["H","\u03c9"]},"mrow":{"mo":["\uf605","\uf606"],"mover":{"mi":["H","\u03d6"]}}},"mo":"."}}}},{"mtd":{"mrow":{"mrow":[{"mi":"where","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mover":{"mi":["H","\u03d6"]}},{"mover":[{"mi":"E","mo":"^"},{"mi":"L","mo":"^"}],"mo":"+"}],"mo":"="}}}]}}},"ul":{"@attributes":{"id":"ul0021","list-style":"none"},"li":["his the cosine of the angle between {circumflex over (N)}, and the half way vector, \u0124, and is defined as follows:\n\n\n","pthe cosine of the angle between {circumflex over (N)}, and the vector to the light, {circumflex over (L)}, and is defined as follows:\n\n\n","\u015cthe unit vector in the direction of the spotlight. It is a Lighting Source Parameter and is provided as a unit vector.","sis the cosine of the angle that defines the spotlight cone. It is a Lighting Source Parameter.","sthe cosine of the angle between the spotlight direction. \u015c, and the vector from the light to the vertex, \u2212{circumflex over (L)}, and is defined as follows:\n\n\u00b7(\u2212{circumflex over ()})\n","dthe distance from the light to the vertex. See {circumflex over (L)} above.\n\nLighting Equation\n"]}},"The \u201cLighting Color\u201d of each pixel is computed according to the following lighting equation (Eq. (1)):",{"@attributes":{"id":"p-1470","num":"1528"},"maths":{"@attributes":{"id":"MATH-US-00035","num":"00035"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":{"mtd":[{"mrow":{"mi":"LightingColor","mo":"=","mrow":{"mi":["EmissiveColor","GlobalAmbientColor"],"mo":["+","+"],"mrow":{"munderover":{"mo":"\u2211","mrow":[{"mi":"i","mo":"=","mn":"0"},{"mi":"n","mo":"-","mn":"1"}]},"mo":"\u2062","mrow":{"mo":["[","]"],"mrow":{"mi":["Attenuation","SpotLightEffect"],"mo":["\u00b7","\u00b7"],"mrow":{"mo":["(",")"],"mrow":{"mi":["AmbientColor","DiffuseColor","SpecularColor"],"mo":["+","+"]}}}}}}}},{"mrow":{"mi":"Eq","mo":[".","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"mrow":{"mo":["(",")"],"mn":"29"}}}]}}}},"br":{}},"The terms used in the lighting equation (Eq. (1)) are defined for the purposes of the present application as follows. These definitions are consistent with prior art usage.\n\n","The meaning and derivation of each of these terms is now described.","Emissive Color","The emissive color is just the emissive attribute of the material (E). I.e.,\n\nEmissiveColor=E\n\nAmbient Effects\n","The ambient attribute of a material, A, is used to scale the Global Scene Ambient Light, A, to determine the global ambient effect. I.e.,\n\nGlobalAmbientColor=\n\nIndividual Light Effects\n","Individual lights have an ambient, diffuse, and specular attribute associated with them. These attributes are effected by the ambient, diffuse, and specular attributes of the material, resp. Each light may also have a spotlight attribute and an attenuation factor, which are expressed as follows.","Attenuation","The Attenuation factor is a fraction that reduces the lighting effect from a particular light depending on the distance of the light's position to the position of the vertex, d. If the light's position is at infinity (P=0), then the attenuation factor is one and has no effect. Three positive factors are provided per light that determine the attenuation value, K, Kand K. These are the constant, linear, and quadratic effects, resp. Note that eye coordinates of the surface are needed to determine the light's distance. Given these factors, Attenuation is expressed as follows:",{"@attributes":{"id":"p-1478","num":"1542"},"maths":{"@attributes":{"id":"MATH-US-00036","num":"00036"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Attenuation","mo":"=","mfrac":{"mn":"1","mrow":{"msub":{"mi":["K","c"]},"mo":["+","+"],"mrow":[{"msub":[{"mi":["K","l"]},{"mi":["d","L"]}],"mo":"\u00b7"},{"msub":{"mi":["K","q"]},"mo":"\u00b7","msubsup":{"mi":["d","L"],"mn":"2"}}]}}}}},"br":{}},"Each light can be specified to act as a spotlight. The result of a spotlight is to diminish the effect that a light has on a vertex based upon the distance of the vertex from the direction that the spotlight is pointed. If the light is not a spotlight then there is no effect and the spotlight factor is one. The parameters needed to specify a spotlight are the position of the spotlight, P, P, the unit length direction of the spotlight, \u015c, the cosine of the spotlight cutoff angle, s, and the spotlight exponent, s. The range of the cutoff angle cosine is 0 to 1. A negative value of sindicates no spotlight effect. If the Vertex lies within the spotlight cutoff angle, then it is lit, otherwise, it is not lit. The amount that a vertex is lit is determined by the spotlight exponent, the further the vertex is from the center of the cone the less it is lit.","s, the cosine of the angle between the spotlight direction and the vector from light to vertex, is used to determine whether the vertex is lit and how far the vertex is from the center of the spotlight cone.\n\n\u00b7(\u2212{circumflex over ()})\n\nIf S\u2267Sthen the vertex is lit. How much it is lit depends on (S).\n","To summarize:",{"@attributes":{"id":"p-1481","num":"1545"},"maths":{"@attributes":{"id":"MATH-US-00037","num":"00037"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"SpotlightEffect","mo":"=","mrow":{"mo":"{","mtable":{"mtr":[{"mtd":[{"mrow":{"mn":"1","mo":","}},{"mrow":{"mrow":{"mrow":[{"mi":"for","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["s","c"]}},{"mo":"-","mn":"1"}],"mo":"="},"mo":","}}]},{"mtd":[{"mrow":{"mn":"0","mo":","}},{"mrow":{"mrow":[{"mi":"for","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["s","c"]}},{"mrow":{"mo":"-","mn":"1"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"and","msub":{"mi":["s","c"]}}],"mo":["\u2260","<"],"msub":{"mi":["s","dv"]}}}]},{"mtd":[{"mrow":{"msup":{"mrow":{"mo":["(",")"],"msub":{"mi":["s","dv"]}},"msub":{"mi":["s","E"]}},"mo":","}},{"mrow":{"mrow":[{"mi":"for","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["s","c"]}},{"mrow":{"mo":"-","mn":"1"},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"and","msub":{"mi":["s","c"]}}],"mo":["\u2260","\u2265"],"msub":{"mi":["s","dv"]}}}]}]}}}}},"br":{}},"The ambient effect of local lights is the Local Ambient Light, A, scaled by the ambient attribute of a material, A.\n\nAmbientCobr=\n\nDiffuse Effect\n","The diffuse light effect is determined by the position of the light with respect to the normal of the surface. It does not depend on the position of the viewpoint. It is determined by the diffuse attribute of the material, D, the diffuse attribute of the light, D, the position of the light, P, P, the position of the vertex, V, and the unit vector normal of the vertex, {circumflex over (N)}.","{circumflex over (L)} is the unit length vector from the vertex to the light position. If the light position is at infinity (P=0), then only the light position is used, P, and the eye coordinates of the vertex are not needed.","The diffuse effect can be described as D, the diffuse light, scaled by, D, the diffuse material, and finally scaled by P, the cosine of the angle between the direction of the light and the surface normal. This cosine is limited between 0 and 1. If the cosine is negative, then the diffuse effect is 0.",{"@attributes":{"id":"p-1485","num":"1549"},"maths":{"@attributes":{"id":"MATH-US-00038","num":"00038"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"DiffuseCobr","mo":"=","mrow":{"mo":"{","mrow":{"mtable":{"mtr":[{"mtd":[{"mrow":{"mn":"0","mo":","}},{"mrow":{"mrow":{"mi":"for","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["p","N"]}},"mo":"\u2264","mn":"0"}}]},{"mtd":[{"mrow":{"mrow":{"msub":[{"mi":["D","cl"]},{"mi":["D","cm"]},{"mi":["p","N"]}],"mo":["\u00b7","\u00b7"]},"mo":","}},{"mrow":{"mrow":{"mi":"for","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["p","N"]}},"mo":">","mn":"0"}}]}]},"mo":["\u2062","\u2062"],"mstyle":{"mtext":{}},"mi":"where"}}}}},{"mtd":{"mrow":{"msub":{"mi":["p","N"]},"mo":"=","mrow":{"mi":"N","mo":"\u00b7","mover":{"mi":"L","mo":"^"}}}}}]}}},"br":{}},"The specular light effect is determined by the position of the light with respect to the normal of the surface and the position of the viewpoint. It is determined by the specular color of the material, S, the specular exponent (shininess) of the material, S, the specular attribute of the light, S, the position of the light, P, P, the unit eye vector \u00ca (described below), the position of the vertex, V, and the unit vector normal of the vertex, {circumflex over (N)}.","{circumflex over (L)} is the unit length vector from the vertex to the light position. If the light position is at infinity (P=0), then only the light position, P, is used and {circumflex over (L)} is independent of the vertex's eye coordinates.","\u00ca is the unit length vector from the vertex to the viewpoint. If the viewpoint position is at infinity, then \u00ca=[0 0 1]={circumflex over (Z)} and is independent of the vertex's eye coordinates.","\u0124 is the unit length vector halfway between {circumflex over (L)} and \u00ca.",{"@attributes":{"id":"p-1490","num":"1554"},"maths":{"@attributes":{"id":"MATH-US-00039","num":"00039"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mover":{"mi":"H","mo":"^"},"mo":"=","mfrac":{"mover":{"mi":["H","\u03c9"]},"mrow":{"mo":["\uf605","\uf606"],"mover":{"mi":["H","\u03d6"]}}}}}},{"mtd":{"mrow":{"mo":"=","mfrac":{"mrow":[{"mover":[{"mi":"L","mo":"^"},{"mi":"E","mo":"^"}],"mo":"+"},{"mo":["\uf605","\uf606"],"mrow":{"mover":[{"mi":"L","mo":"^"},{"mi":"E","mo":"^"}],"mo":"+"}}]}}}}]}}},"br":{}},"The specular effect can be described as S, the diffuse light, scaled by, S, the diffuse material, and finally scaled by (h), the cosine of the angle between the halfway vector and the surface normal raised to the power of the shininess. The cosine is limited between 0 and 1. If the cosine is negative, then the specular effect is 0.",{"@attributes":{"id":"p-1492","num":"1556"},"maths":{"@attributes":{"id":"MATH-US-00040","num":"00040"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"mi":"SpecularColor","mo":"=","mrow":{"mo":"{","mrow":{"mtable":{"mtr":[{"mtd":[{"mrow":{"mn":"0","mo":","}},{"mrow":{"mrow":{"mi":"for","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["h","N"]}},"mo":"\u2264","mn":"0"}}]},{"mtd":[{"mrow":{"mrow":{"msub":[{"mi":["S","cl"]},{"mi":["S","cm"]}],"mo":["\u00b7","\u00b7"],"msup":{"mrow":{"mo":["(",")"],"msub":{"mi":["h","N"]}},"msub":{"mi":["S","mn"]}}},"mo":","}},{"mrow":{"mrow":{"mi":"for","mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},"msub":{"mi":["h","N"]}},"mo":">","mn":"0"}}]}]},"mo":["\u2062","\u2062"],"mstyle":{"mtext":{}},"mi":"where"}}}}},{"mtd":{"mrow":{"msub":{"mi":["h","N"]},"mo":"=","mrow":{"mover":[{"mi":"N","mo":"^"},{"mi":"H","mo":"^"}],"mo":"\u00b7"}}}}]}}},"br":{}},"In OpenGL, a light's position can be defined as having a distance of infinity from the origin but still have a vector pointing to its position. This definition is used in simplifying the calculation needed to determine the vector from the vertex to the light (in other APIs, which do not define the light's position in this way, this simplification cannot be made). If a light is at infinity, then this vector is independent of the position of the vertex, is constant for every vertex, and does not need the vertex's eye coordinates. This simplification is used for spotlights, diffuse color, and specular color.","The viewpoint is defined as being at the origin or at infinity in the z direction. This is used to simplify the calculation for specular color. If the viewer is at infinity then the vector from the vertex to the viewpoint is independent of the position of the vertex, is constant for every vertex, and does not need the vertex's eye coordinates. This vector is then just the unit vector in the z direction, {circumflex over (Z)}.","Calculation Cases Summary","The following table (Table 1) summarizes the calculations needed for lighting depending on whether local or infinite light position and viewer are specified.",{"@attributes":{"id":"p-1497","num":"1561"},"tables":{"@attributes":{"id":"TABLE-US-00028","num":"00028"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":[{},"Infinite Light","Local Light"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Infinite","Local","Infinite","Local"]},{"entry":[{},"Viewpoint","Viewpoint","Viewpoint","Viewpoint"]},{"entry":[{},"(0, 0, \u221e)","(0, 0, 0)","(0, 0, \u221e)","(0, 0, 0)"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Emissive","E"]},{"entry":["Global Ambient","A\u00b7 A"]},{"entry":["Ambient","A\u00b7 A"]},{"entry":{}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Diffuse D\u00b7 D\u00b7 p p= {circumflex over (N)} \u00b7 {circumflex over (L)} ","{circumflex over (L)} ={circumflex over (P)}",{"maths":{"@attributes":{"id":"MATH-US-00041","num":"00041"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mi":"L","mo":"^"},"mo":"=","mfrac":{"mrow":{"msub":{"mover":{"mi":["P","\u03c9"]},"mi":"L"},"mo":"-","mover":{"mi":["V","\u03c9"]}},"msub":{"mi":"d","mn":"1"}}}}}}]},{"entry":{}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"5","colwidth":"49pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Specular",{},{"maths":{"@attributes":{"id":"MATH-US-00042","num":"00042"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mi":"E","mo":"^"},"mo":"=","mfrac":{"mover":{"mi":["V","\u03c9"]},"mrow":{"mo":["\uf605","\uf606"],"mover":{"mi":["V","\u03d6"]}}}}}}},"\u00ca = {circumflex over (Z)}",{"maths":{"@attributes":{"id":"MATH-US-00043","num":"00043"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mi":"E","mo":"^"},"mo":"=","mfrac":{"mover":{"mi":["V","\u03c9"]},"mrow":{"mo":["\uf605","\uf606"],"mover":{"mi":["V","\u03d6"]}}}}}}}]},{"entry":{}},{"entry":["S\u00b7 S\u00b7 (h) h= {circumflex over (N)} \u00b7\u0124","\u0124",{"maths":{"@attributes":{"id":"MATH-US-00044","num":"00044"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mi":"E","mo":"^"},"mo":"=","mfrac":{"mover":{"mi":["V","\u03c9"]},"mrow":{"mo":["\uf605","\uf606"],"mover":{"mi":["V","\u03d6"]}}}}}}},{"maths":{"@attributes":{"id":"MATH-US-00045","num":"00045"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mi":"L","mo":"^"},"mo":"=","mfrac":{"mrow":{"msub":{"mover":{"mi":["P","\u03c9"]},"mi":"L"},"mo":"-","mover":{"mi":["V","\u03c9"]}},"msub":{"mi":["d","L"]}}}}}},{"maths":{"@attributes":{"id":"MATH-US-00046","num":"00046"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mi":"L","mo":"^"},"mo":"=","mfrac":{"mrow":{"msub":{"mover":{"mi":["P","\u03c9"]},"mi":"L"},"mo":"-","mover":{"mi":["V","\u03c9"]}},"msub":{"mi":["d","L"]}}}}}}]},{"entry":{}},{"entry":[{"maths":{"@attributes":{"id":"MATH-US-00047","num":"00047"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mi":"H","mo":"^"},"mo":"=","mfrac":{"mover":{"mi":["H","\u03c9"]},"mrow":{"mo":["\uf605","\uf606"],"mover":{"mi":["H","\u03d6"]}}}}}}},{"maths":{"@attributes":{"id":"MATH-US-00048","num":"00048"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mo":["(",")"],"mrow":{"mover":{"mi":["H","\u03d6"]},"mo":"=","mrow":{"mover":{"mi":"Z","mo":"^"},"mo":"+","msub":{"mover":{"mi":"P","mo":"^"},"mi":"L"}}}}}}},{},{},{}]},{"entry":{}},{"entry":[{"maths":{"@attributes":{"id":"MATH-US-00049","num":"00049"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mi":["H","\u03d6"]},"mo":"=","mrow":{"mover":[{"mi":"E","mo":"^"},{"mi":"L","mo":"^"}],"mo":"+"}}}}},{},"{circumflex over (L)} = {circumflex over (P)}",{},{}]},{"entry":{}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"112pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Attenuation","No Attenuation",{"maths":{"@attributes":{"id":"MATH-US-00050","num":"00050"},"math":{"@attributes":{"overflow":"scroll"},"mfrac":{"mn":"1","mrow":{"mrow":[{"msub":[{"mi":["K","c"]},{"mi":["K","l"]},{"mi":["d","L"]}],"mo":["\u00b7","\u00b7"]},{"msub":{"mi":["K","q"]},"mo":"\u00b7","msubsup":{"mi":["d","L"],"mn":"2"}}],"mo":"+"}}}}}]},{"entry":{}},{"entry":["Spotlight (s) s= \u015c\u00b7 (\u2212{circumflex over (L)})","{circumflex over (L)} = {circumflex over (P)}",{"maths":{"@attributes":{"id":"MATH-US-00051","num":"00051"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mi":"L","mo":"^"},"mo":"=","mfrac":{"mrow":{"msub":{"mover":{"mi":["P","\u03c9"]},"mi":"L"},"mo":"-","mover":{"mi":["V","\u03c9"]}},"msub":{"mi":["d","L"]}}}}}}]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Bump Mapping","In advanced lighting systems, the lighting computations can account for bump mapping effects. As described in the Blinn reference, bump mapping produces more realistic lighting by simulating the shadows and highlights resulting from illumination of a surface on which the effect of a three dimensional texture is imposed\/mapped. An example of such a textured surface is the pebbled surface of a basketball or the dimpled surface of a golf ball.","Generally, in a lighting system that supports bump mapping a texture map (e.g., a representation of the pebbled basketball surface) is used to perturb the surface normal (N) used in the fragmenlighting calculation (described above). This gives a visual effect of 3-dimensional structure to the surface that cannot be obtained with conventional texture mapping. It also assumes per-fragment lighting is being performed. Bump mapping requires extensions to the OpenGL standard. The theoretical basis of bump mapping is now described with reference to FIG. G . This approach is common to both of the most common bump mapping methods: the SGI approach and the Blinn approach.","Referring to FIG. G , there are illustrated some of the elements employed in bump mapping computations. The illustrated approach is described at depth in the Blinn reference and is briefly summarized herein.","Bump Mapping Background","Bump Mapping is defined as a perturbation of the Normal Vector, {right arrow over (N)} resulting in the perturbed Vector {right arrow over (N)}\u2032","The perturbed vector can be calculated by defining {right arrow over (V)}\u2032to be the location of a point, {right arrow over (V)}\u2032, after it has been moved (\u201cbumped\u201d) a distance h in the direction of the Normal, {right arrow over (N)}. Define the unit vector in the Normal direction as,",{"@attributes":{"id":"p-1505","num":"1569"},"maths":[{"@attributes":{"id":"MATH-US-00052","num":"00052"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mi":"N","mo":"^"},"mo":"=","mfrac":{"mover":{"mi":"N","mo":"\u2192"},"mrow":{"mo":["\uf605","\uf606"],"mover":{"mi":"N","mo":"\u2192"}}}}}},{"@attributes":{"id":"MATH-US-00052-2","num":"00052.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Then","mo":[",","\u2062"],"mstyle":{"mtext":{}},"mrow":{"mrow":[{"mrow":{"mo":["[","]"],"mn":"1"},"mo":"\u2062","msubsup":{"mover":{"mi":"V","mo":"\u2192"},"mi":["e","\u2032"]}},{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"e"},"mo":"+","mrow":{"mi":"h","mo":"\u00b7","mover":{"mi":"N","mo":"^"}}}],"mo":"="}}}}]},"The surface tangents, {right arrow over (V)}s and {right arrow over (V)}t, are defined as the partial derivatives of {right arrow over (V)}:",{"@attributes":{"id":"p-1507","num":"1571"},"maths":{"@attributes":{"id":"MATH-US-00053","num":"00053"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"s"},"mo":"=","mfrac":{"mrow":[{"mo":"\u2202","msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"e"}},{"mo":"\u2202","mi":"s"}]}},{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"t"},"mo":"=","mfrac":{"mrow":{"mo":"\u2202","msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"e"}},"msub":{"mo":"\u2202","mi":"t"}}}],"mo":","}}}},"The Normal Vector can be defined as the cross product of the surface tangents:\n\n\n","Then the Perturbed Normal can be defined as the cross product of the surface tangents of the bumped point.\n\n\u2032\u00d7V\u2032\u2003\u2003[2]\n","Expanding the partials from [1] gives:",{"@attributes":{"id":"p-1511","num":"1575"},"maths":[{"@attributes":{"id":"MATH-US-00054","num":"00054"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msubsup":{"mover":{"mi":"V","mo":"\u2192"},"mi":["s","\u2032"]},"mo":"=","mrow":{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"s"},"mo":["+","+"],"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","mi":"h"},{"mo":"\u2202","mi":"s"}]},"mo":"\u00b7","mover":{"mi":"N","mo":"^"}},{"mi":"h","mo":"\u00b7","mfrac":{"mrow":[{"mo":"\u2202","mover":{"mi":"N","mo":"^"}},{"mo":"\u2202","mi":"s"}]}}]}}}},{"@attributes":{"id":"MATH-US-00054-2","num":"00054.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msubsup":{"mover":{"mi":"V","mo":"\u2192"},"mi":["t","\u2032"]},"mo":"=","mrow":{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"t"},"mo":["+","+"],"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","mi":"h"},{"mo":"\u2202","mi":"t"}]},"mo":"\u00b7","mover":{"mi":"N","mo":"^"}},{"mi":"h","mo":"\u00b7","mfrac":{"mrow":[{"mo":"\u2202","mover":{"mi":"N","mo":"^"}},{"mo":"\u2202","mi":"t"}]}}]}}}}]},"Since",{"@attributes":{"id":"p-1513","num":"1577"},"maths":{"@attributes":{"id":"MATH-US-00055","num":"00055"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mfrac":[{"mrow":[{"mo":"\u2202","mover":{"mi":"N","mo":"^"}},{"mo":"\u2202","mi":"s"}]},{"mrow":[{"mo":"\u2202","mover":{"mi":"N","mo":"^"}},{"mo":"\u2202","mi":"t"}]}],"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"and"}}},"br":{}},"Let",{"@attributes":{"id":"p-1515","num":"1579"},"maths":{"@attributes":{"id":"MATH-US-00056","num":"00056"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["h","s"]},"mo":"=","mrow":{"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","mi":"h"},{"mo":"\u2202","mi":"s"}]},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"and","msub":{"mi":["h","t"]}},"mo":"=","mfrac":{"mrow":[{"mo":"\u2202","mi":"h"},{"mo":"\u2202","mi":"t"}]}}}}},"br":{}},{"@attributes":{"id":"p-1516","num":"1580"},"maths":{"@attributes":{"id":"MATH-US-00057","num":"00057"},"math":{"@attributes":{"overflow":"scroll"},"mtable":{"mtr":[{"mtd":{"mrow":{"msup":{"mover":{"mi":"N","mo":"\u2192"},"mi":"\u2032"},"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"s"},"mo":"+","mrow":{"msub":{"mi":["h","s"]},"mo":"\u00b7","mover":{"mi":"N","mo":"^"}}}},{"mo":["(",")"],"mrow":{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"t"},"mo":"+","mrow":{"msub":{"mi":["h","t"]},"mo":"\u00b7","mover":{"mi":"N","mo":"^"}}}}],"mo":"\u00d7"}}}},{"mtd":{"mrow":{"mo":["=","\u2062"],"mi":{},"mrow":{"mrow":[{"mo":["(",")"],"mrow":{"msub":[{"mover":{"mi":"V","mo":"\u2192"},"mi":"s"},{"mover":{"mi":"V","mo":"\u2192"},"mi":"t"}],"mo":"\u00d7"}},{"mo":["(",")"],"mrow":{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"s"},"mo":"\u00d7","mrow":{"msub":{"mi":["h","t"]},"mo":"\u00b7","mover":{"mi":"N","mo":"^"}}}},{"mo":["(",")"],"mrow":{"mrow":{"msub":{"mi":["h","s"]},"mo":"\u00b7","mover":{"mi":"N","mo":"^"}},"mo":"\u00d7","msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"t"}}},{"mo":["(",")"],"mrow":{"mrow":[{"msub":{"mi":["h","s"]},"mo":"\u00b7","mover":{"mi":"N","mo":"^"}},{"msub":{"mi":["h","t"]},"mo":"\u00b7","mover":{"mi":"N","mo":"^"}}],"mo":"\u00d7"}}],"mo":["+","+","+"]}}}}]}}}},"Define Basis Vectors:\n\n\u2003\u2003[3]\n","Then, since {circumflex over (N)}\u00d7{circumflex over (N)}=0,\n\n\u2003\u2003[4]\n","This equation [4] is used to perturb the Normal, {right arrow over (N)}, given Height Gradients, hand h, and Basis Vectors, {right arrow over (b)}and {right arrow over (b)}.","How the Height Gradients and Basis Vectors are specified depends on the model used.","Basis Vectors","Basis Vectors can be calculated using [5].\n\n\n\n\n\n\u2003\u2003[5]\n","This calculation for Basis Vectors is the one proposed by Blinn and requires Surface Tangents, a unit Normal Vector, and a cross product.","From the diagram, if the Surface Tangents are orthogonal, the Basis can be approximated by:\n\n\n\n\n\n\u2003\u2003[6]\n\nHeight Gradients\n","The Height Gradients, hand h, are provided per fragment by in the conventional approaches.","Surface Tangent Generation","The partial derivatives,",{"@attributes":{"id":"p-1526","num":"1590"},"maths":{"@attributes":{"id":"MATH-US-00058","num":"00058"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"s"},"mo":"=","mrow":{"mrow":{"mfrac":{"mrow":[{"mo":"\u2202","msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"e"}},{"mo":"\u2202","mi":"s"}]},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"and","msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"e"}},"mo":"=","mfrac":{"mrow":[{"mo":"\u2202","msub":{"mi":["V","e"]}},{"mo":"\u2202","mi":"t"}]}}}}},"br":{},"b":["1","2","0"]},{"@attributes":{"id":"p-1527","num":"1591"},"maths":[{"@attributes":{"id":"MATH-US-00059","num":"00059"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mn":"1"},"mo":"=","mrow":{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mn":"0"},"mo":["+","+"],"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"e"}},{"mo":"\u2202","mi":"s"}]},"mo":"\u00b7","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"s","mn":"1"},{"mi":"s","mn":"0"}],"mo":"-"}}},{"mfrac":{"mrow":[{"mo":"\u2202","msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"e"}},{"mo":"\u2202","mi":"t"}]},"mo":"\u00b7","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"t","mn":"1"},{"mi":"t","mn":"0"}],"mo":"-"}}}]}}}},{"@attributes":{"id":"MATH-US-00059-2","num":"00059.2"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mn":"2"},"mo":"=","mrow":{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mn":"0"},"mo":["+","+"],"mrow":[{"mfrac":{"mrow":[{"mo":"\u2202","msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"e"}},{"mo":"\u2202","mi":"s"}]},"mo":"\u00b7","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"s","mn":"2"},{"mi":"s","mn":"0"}],"mo":"-"}}},{"mfrac":{"mrow":[{"mo":"\u2202","msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"e"}},{"mo":"\u2202","mi":"t"}]},"mo":"\u00b7","mrow":{"mo":["(",")"],"mrow":{"msub":[{"mi":"t","mn":"2"},{"mi":"t","mn":"0"}],"mo":"-"}}}]}}}},{"@attributes":{"id":"MATH-US-00059-3","num":"00059.3"},"math":{"@attributes":{"overflow":"scroll"},"mi":"Let"}},{"@attributes":{"id":"MATH-US-00059-4","num":"00059.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mover":{"mi":"V","mo":"^"},"mn":"1"},"mo":"=","mrow":{"msub":[{"mover":{"mi":"V","mo":"\u2192"},"mn":"1"},{"mover":{"mi":"V","mo":"\u2192"},"mn":"0"}],"mo":"-"}},{"msub":{"mover":{"mi":"x","mo":"^"},"mn":"1"},"mo":"=","mrow":{"msub":[{"mi":"x","mn":"1"},{"mi":"x","mn":"0"}],"mo":"-"}},{"msub":{"mover":{"mi":"y","mo":"^"},"mn":"1"},"mo":"=","mrow":{"msub":[{"mi":"y","mn":"1"},{"mi":"y","mn":"0"}],"mo":"-"}},{"msub":{"mover":{"mi":"z","mo":"^"},"mn":"1"},"mo":"=","mrow":{"msub":{"mi":"z","mn":"1"},"mo":"-","mi":"z"}}],"mo":[",",",",","]}}},{"@attributes":{"id":"MATH-US-00059-5","num":"00059.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mover":{"mi":"V","mo":"^"},"mn":"2"},"mo":"=","mrow":{"msub":[{"mover":{"mi":"V","mo":"\u2192"},"mn":"2"},{"mover":{"mi":"V","mo":"\u2192"},"mn":"0"}],"mo":"-"}},{"msub":{"mover":{"mi":"x","mo":"^"},"mn":"2"},"mo":"=","mrow":{"msub":[{"mi":"x","mn":"2"},{"mi":"x","mn":"0"}],"mo":"-"}},{"msub":{"mover":{"mi":"y","mo":"^"},"mn":"2"},"mo":"=","mrow":{"msub":[{"mi":"y","mn":"2"},{"mi":"y","mn":"0"}],"mo":"-"}},{"msub":{"mover":{"mi":"z","mo":"^"},"mn":"2"},"mo":"=","mrow":{"msub":{"mi":"z","mn":"2"},"mo":"-","mi":"z"}}],"mo":[",",",",","]}}},{"@attributes":{"id":"MATH-US-00059-6","num":"00059.6"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mover":{"mi":"s","mo":"^"},"mn":"1"},"mo":"=","mrow":{"msub":[{"mi":"s","mn":"1"},{"mi":"s","mn":"0"}],"mo":"-"}},{"msub":{"mover":{"mi":"t","mo":"^"},"mn":"1"},"mo":"=","mrow":{"msub":[{"mi":"t","mn":"1"},{"mi":"t","mn":"0"}],"mo":"-"}}],"mo":","}}},{"@attributes":{"id":"MATH-US-00059-7","num":"00059.7"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mover":{"mi":"s","mo":"^"},"mn":"2"},"mo":"=","mrow":{"msub":[{"mi":"s","mn":"2"},{"mi":"s","mn":"0"}],"mo":"-"}},{"msub":{"mover":{"mi":"t","mo":"^"},"mn":"2"},"mo":"=","mrow":{"msub":[{"mi":"t","mn":"2"},{"mi":"t","mn":"0"}],"mo":"-"}}],"mo":","}}},{"@attributes":{"id":"MATH-US-00059-8","num":"00059.8"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"Then","mo":[",","\u2062"],"mstyle":{"mtext":{}},"mrow":{"msub":{"mover":{"mi":"V","mo":"^"},"mn":"1"},"mo":"=","mrow":{"mrow":[{"msub":[{"mover":{"mi":"V","mo":"\u2192"},"mi":"s"},{"mover":{"mi":"s","mo":"^"},"mn":"1"}],"mo":"\u00b7"},{"msub":[{"mover":{"mi":"V","mo":"\u2192"},"mi":"t"},{"mover":{"mi":"t","mo":"^"},"mn":"1"}],"mo":"\u00b7"}],"mo":"+"}}}}},{"@attributes":{"id":"MATH-US-00059-9","num":"00059.9"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mover":{"mi":"V","mo":"^"},"mn":"2"},"mo":"=","mrow":{"mrow":[{"msub":[{"mover":{"mi":"V","mo":"\u2192"},"mi":"s"},{"mover":{"mi":"s","mo":"^"},"mn":"2"}],"mo":"\u00b7"},{"msub":[{"mover":{"mi":"V","mo":"\u2192"},"mi":"t"},{"mover":{"mi":"t","mo":"^"},"mn":"2"}],"mo":"\u00b7"}],"mo":"+"}}}}],"br":{}},{"@attributes":{"id":"p-1528","num":"1592"},"maths":[{"@attributes":{"id":"MATH-US-00060","num":"00060"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"s"},"mo":"=","mfrac":{"mrow":[{"mrow":[{"msub":[{"mover":{"mi":"V","mo":"^"},"mn":"1"},{"mover":{"mi":"t","mo":"^"},"mn":"2"}],"mo":"\u00b7"},{"msub":[{"mover":{"mi":"V","mo":"^"},"mn":"2"},{"mover":{"mi":"t","mo":"^"},"mn":"1"}],"mo":"\u00b7"}],"mo":"-"},{"mrow":[{"msub":[{"mover":{"mi":"s","mo":"^"},"mn":"1"},{"mover":{"mi":"t","mo":"^"},"mn":"2"}],"mo":"\u00b7"},{"msub":[{"mover":{"mi":"s","mo":"^"},"mn":"2"},{"mover":{"mi":"t","mo":"^"},"mn":"1"}],"mo":"\u00b7"}],"mo":"-"}]}},{"msub":{"mover":{"mi":"V","mo":"\u2192"},"mi":"t"},"mo":"=","mfrac":{"mrow":[{"msub":[{"mover":{"mi":"s","mo":"^"},"mn":"1"},{"mover":{"mi":"V","mo":"^"},"mn":"2"}],"mo":"\u00b7"},{"msub":[{"mover":{"mi":"s","mo":"^"},"mn":"1"},{"mover":{"mi":"t","mo":"^"},"mn":"2"}],"mo":"\u00b7"}]}}],"mo":","}}},{"@attributes":{"id":"MATH-US-00060-2","num":"00060.2"},"math":{"@attributes":{"overflow":"scroll"},"mi":"or"}},{"@attributes":{"id":"MATH-US-00060-3","num":"00060.3"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mfrac":[{"mrow":[{"mo":"\u2202","msub":{"mi":["x","e"]}},{"mo":"\u2202","mi":"s"}]},{"msub":[{"mi":"D","mrow":{"mi":["x","t"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},{"mi":"D","mrow":{"mi":["s","t"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}]}],"mo":"="},{"mfrac":[{"mrow":[{"mo":"\u2202","msub":{"mi":["x","e"]}},{"mo":"\u2202","mi":"t"}]},{"msub":[{"mi":"D","mrow":{"mi":["s","x"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},{"mi":"D","mrow":{"mi":["s","t"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}]}],"mo":"="}],"mo":","}}},{"@attributes":{"id":"MATH-US-00060-4","num":"00060.4"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mfrac":[{"mrow":[{"mo":"\u2202","msub":{"mi":["y","e"]}},{"mo":"\u2202","mi":"s"}]},{"msub":[{"mi":"D","mrow":{"mi":["y","t"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},{"mi":"D","mrow":{"mi":["s","t"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}]}],"mo":"="},{"mfrac":[{"mrow":[{"mo":"\u2202","msub":{"mi":["y","e"]}},{"mo":"\u2202","mi":"t"}]},{"msub":[{"mi":"D","mrow":{"mi":["s","y"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},{"mi":"D","mrow":{"mi":["s","t"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}]}],"mo":"="}],"mo":","}}},{"@attributes":{"id":"MATH-US-00060-5","num":"00060.5"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":[{"mfrac":[{"mrow":[{"mo":"\u2202","msub":{"mi":["z","e"]}},{"mo":"\u2202","mi":"s"}]},{"msub":[{"mi":"D","mrow":{"mi":["z","t"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},{"mi":"D","mrow":{"mi":["s","t"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}]}],"mo":"="},{"mfrac":[{"mrow":[{"mo":"\u2202","msub":{"mi":["z","e"]}},{"mo":"\u2202","mi":"t"}]},{"msub":[{"mi":"D","mrow":{"mi":["s","z"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}},{"mi":"D","mrow":{"mi":["s","t"],"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.3em","height":"0.3ex"}}}}}]}],"mo":"="}],"mo":","}}},{"@attributes":{"id":"MATH-US-00060-6","num":"00060.6"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"where","mo":";"}}},{"@attributes":{"id":"MATH-US-00060-7","num":"00060.7"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"msub":{"mi":["D","ij"]},"mo":"=","mrow":{"mrow":[{"msub":[{"mover":{"mi":"i","mo":"^"},"mn":"1"},{"mover":{"mi":"j","mo":"^"},"mn":"2"}],"mo":"\u2062"},{"msub":[{"mover":{"mi":"i","mo":"^"},"mn":"2"},{"mover":{"mi":"j","mo":"^"},"mn":"1"}],"mo":"\u2062"}],"mo":"-"}}}}],"br":{},"figref":"FIGS. 5A","b":["5","6","6"]},"SGI Bump Mapping","Referring to FIG. G A, there is shown a functional flow diagram illustrating a bump mapping approach proposed by Silicon Graphics (SGI). The functional blocks include: \u201ccompute perturbed normal\u201d SGI, \u201cstore texture map\u201d SGI, \u201cperform lighting computations\u201d SGI and \u201ctransform eye space to tangent space\u201d SGI. In the typical embodiment of this approach the steps SGI and SGI are performed in software and the steps SGI and SGI are performed in 3D graphics hardware. In particular, the step SGI is performed using the same hardware that is optimized to perform Phong shading. The SGI approach is documented in the Peercy reference.","A key aspect of the SGI approach is that all lighting and bump mapping computations are performed in tangent space, which is a space defined for each surface\/object by orthonormal vectors comprising a unit surface normal (N) and two unit surface tangents (T and B). The basis vectors could be explicitly defined at each vertex by an application program or could be derived by the graphics processor from a reference frame that is local to each object. However the tangent space is defined, the components of the basis vectors are given in eye space. A standard theorem from linear algebra states that the matrix used to transform from coordinate system A (e.g., eye space) to system B (e.g., tangent space) can be formed from the coordinates of the basis vectors of system B in system A. Consequently, a matrix M whose columns comprise the basis vectors N, T and B represented in eye space coordinates can be used to transform eye space vectors into corresponding tangent space vectors. As described below, this transformation is used in the SGI pipeline to enable the lighting and bump mapping computations to be done in tangent space.","The elements employed in the illustrated SGI approach include the following:\n\n","Note: the preceding discussion uses notation from the Peercy paper, other portions of this application (e.g., the remainder of the background and the detailed description) use different notation for similar parameters. The correspondance between the two systems is shown below, with the Peercy notation listed under the column labelled \u201cSGI\u201d and the other notation listed under the column labelled \u201cRaycer\u201d.",{"@attributes":{"id":"p-1534","num":"1611"},"tables":{"@attributes":{"id":"TABLE-US-00029","num":"00029"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"91pt","align":"left"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"SGI","Raycer"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"N","N"]},{"entry":[{},"L","L"]},{"entry":[{},"H","H"]},{"entry":[{},"u","s"]},{"entry":[{},"v","t"]},{"entry":[{},"\u2202h\/\u2202s","f(u, v)"]},{"entry":[{},"\u2202h\/\u2202t","f(u, v)"]},{"entry":[{},"P","V"]},{"entry":[{},"P","V"]},{"entry":[{},"T","T"]},{"entry":[{},"B","B"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"In the SGI approach an input texture map comprising a set of partial derivatives f(u,v), f(u,v) is used in combination with the surface normal (N) and tangents (P, P) and basis vectors B and T to compute the perturbed normal in tangent space (N\u2032) at each point of the height field according to the following equations (step SGI):\n\n=()\/\u221a{square root over ()}\n\nwhere:\n\n()\n\n()\n\n|\n","The coefficients a, b and c are the unnormalized components of the perturbed normal N\u2032in tangent space (i.e., the coefficient c is in the normal direction and the coefficients a and b represent perturbations to the normal in the u and v directions). In step (SGI) these coefficients are stored as a texture map TMAP, which is provided to the SGI 3D hardware in a format specified by an appropriate API (e.g, OpenGL).","Using the linear algebra theorem mentioned above, the light and half angle vectors (L, H) are transformed to the tangent space using a matrix M (shown below) whose columns comprise the eye space (i.e. x, y and z) coordinates of the tangent, binormal and normal (T, B, N) (SGI):",{"@attributes":{"id":"p-1538","num":"1615"},"maths":{"@attributes":{"id":"MATH-US-00061","num":"00061"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"M","mo":"=","mrow":{"mo":["\uf603","\uf604"],"mtable":{"mtr":[{"mtd":[{"msub":{"mi":["T","x"]}},{"msub":{"mi":["B","x"]}},{"msub":{"mi":["N","x"]}}]},{"mtd":[{"msub":{"mi":["T","y"]}},{"msub":{"mi":["B","y"]}},{"msub":{"mi":["N","y"]}}]},{"mtd":[{"msub":{"mi":["T","z"]}},{"msub":{"mi":["B","z"]}},{"msub":{"mi":["N","z"]}}]}]}}}}},"br":[{},{},{},{}],"sub":["TS ","TS ","TS","TS","TS ","TS ","TS "],"in-line-formulae":[{},{},{},{}],"i":["L","=L\u00b7M ","H","=H\u00b7M "],"b":["14","14","14"],"ul":{"@attributes":{"id":"ul0025","list-style":"none"},"li":{"@attributes":{"id":"ul0025-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0026","list-style":"none"},"li":["1. interpolating the N\u2032, L, Hand Nvectors for each pixel for which illumination is calculated;","2. normalizing the interpolated vectors;","3. performing the illumination computations."]}}}},"A disadvantage of the SGI approach is that it requires a large amount of unnecessary information to be computed (e.g., for vertices associated with pixels that are not visible in the final graphics image). This information includes:","N\u2032for each vertex of each surface;","Lfor each vertex of each surface;","Hfor each vertex of each surface.","The SGI approach requires extension to the OpenGL specification. In particular, extensions are required to support the novel texture map representation. These extensions are defined in: SGI OpenGL extension: SGIX_fragment_lighting_space, which is incorporated herein by reference.","FIG. G B shows a hypothetical hardware implementation of the SGI bump mapping\/Phong shading approach that is proposed in the Peercy reference. In this system note that the surface normal N and transformed light and Half-angle vectors L, Hare interpolated at the input of the block SGI. The Land Hinterpolations could be done multiple times, once for each of the active lights. The switch S is used to select the perturbed normal N\u2032when bump mapping is in effect or the unperturbed surface normal N when bump mapping is not in effect. The resulting normal and interpolated light and half-angle vectors are then normalized and the normalized resulting normalized vectors are input to the illumination computation, which outputs a corresponding pixel value.","Problems with SGI bump mapping include:\n\n","\u201cBlinn\u201d Bump Mapping","Referring to FIG. G A, there is shown a functional flow diagram illustrating the Blinn bump mapping approach. The functional blocks include: generate gradients B, \u201ccompute perturbed normal\u201d B and \u201cperform lighting computations\u201d B. In the typical embodiment of this approach the step B is performed in software and the steps B and B are performed in dedicated bump mapping hardware. The Blinn approach is described in the Blinn and Peercy references.","The elements employed in the illustrated Blinn approach include the following:\n\n","The Blinn approach presumes that a texture to be applied to a surface is initially defined by a height field h(s, t). The Blinn approach does not directly use this height field, but requires that the texture map representing the height field be provided by the API as a set of gradients h(s, t) and h(s, t) (SGI). That is, rather than providing the perturbed normal N\u2032 (as in the SGI approach), the Blinn texture map provides two scalar values h, hthat represent offsets\/perturbations to the normal. For the offsets to be applied to the normal N two basis vectors band bare needed that define (in eye space) the reference frame in which the offsets are provided. The two possible sources of these vectors are:\n\n","FIG. G B shows a hypothetical hardware implementation of the Blinn bump mapping approach that is proposed in the Peercy reference. In this system note that the multiple vector cross-products that must be computed and the required number of interpolations and normalizations. The extra operations are required in the Blinn approach to derive the basis vectors at each pixel (i.e., for each illumination calculation). Moreover, the three interpolation operations applied to the cross-products (B\u00d7N), (N\u00d7B), (N\u00d7B) are required to be wide floating point operations (i.e., 32 bit operations) due to the possible large range of the cross-product values.","Summary of Tangent Space Lighting in a Deferred Shading Architecture","The invention provides structure and method for performing lighting in a graphics processor. In one aspect the invention specifcially provides structure and method for performing tangent space lighting in a deferred shading architecture. Embodiments of the invention may also provide variable scale bump mapping, automatic basis generation, automatic gradient-field generation, normal interpolation by doing angle and magnitude computations separately.","In one embodiment, the invention provides a bump mapping method for use in a deferred graphics pipeline processor comprising: receiving for a pixel fragment associated with a surface for which bump effects are to be computed: a surface tangent, binormal and normal defining a tangent space relative to the surface associated with the fragment; and a texture vector representing perturbations to the surface normal in the directions of the surface tangent and binormal caused by the bump effects at the surface position associated with the pixel fragment; computing a set of basis vectors from the surface tangent, binormal and normal that define a transformation from the tangent space to eye space in view of the orientation of the texture vector; computing a perturbed, eye space, surface normal reflecting the bump effects by performing a matrix multiplication in which the texture vector is multiplied by a transformation matrix whose columns comprise the basis vectors, giving a result that is the perturbed, eye space, surface normal; and performing lighting computations for the pixel fragment using the perturbed, eye space, surface normal, giving an apparent color for the pixel fragment that accounts for the bump effects without needing to interpolate and translate light and half-angle vectors (L and H) used in the lighting computations.","In another embodiment automatic basis or vector generation is provided. A variable scale bump mapping method for shading a computer graphics image, the method comprising steps of: receiving for a vertex of polygon associated with a surface to which bump effects are to be mapped geometry vectors (V, V, N) and a texture vector (Tb); separating the geometry vectors into unit basis vectors ({circumflex over (b)}, {circumflex over (b)}, n) and magnitudes (m, m, m); multiplying the magnitudes and the texture vector to form a texture-magnitude vector (mTb\u2032); scaling components of the texture-magnitude vector by a vector s to form a scaled texture-magnitude vector (mTb\u2033); and multiplying the scaled texture-magnitude vector and the unit basis vectors to provide a perturbed unit normal (N\u2032) in eye space for a pixel location, whereby the need to specify surface tangents and binormal at the pixel location to perform lighting computations to give the pixel fragment bump effects is eliminated.","In another embodiment, this method is further defined such that the step of multiplying the magnitudes and the texture-magnitude vector produces a transformation matrix, which enables fixed point multiplication hardware to be used. In another embodiment, this method is further defined such that the step of multiplying the magnitudes and the texture-magnitude vector produces a transformation matrix that defines a transformation from different tangent space coordinates systems to an eye space coordinate system. In still another variation, this method is performed such that the different tangent space coordinates systems are selected from known coordinate systems, including from the Blinn coordinate system.","In another embodiment, the invention provides automatic gradient field generation. One embodiment of this provides a variable scale bump mapping method for shading a computer graphics image, the method comprising steps of: receiving a gray scale image for which bump effects are to be computed; taking a derivative relative to a gray scale intensity for a pixel fragment associated with the gray scale image; and computing from the derivative a perturbed unit normal in eye space to give the pixel fragment bump effects. This method may also optionally include the step of computing from the derivative a perturbed unit normal in eye space comprises the step of forming a transformation matrix that defines a transformation of the derivative of the gray scale intensity to an eye space coordinate system.","In another embodiment of the invention, structure and method for performing normal interpolation by doing angle and magnitude computations separately are provided. In one particular embodiment of this method, the method for bump mapping for shading a computer graphics image, comprises: receiving for a pixel fragment associated with a surface for which bump effects are to be computed: a magnitude vector (m), and a bump vector (Tb); and a unit transformation matrix (M); multiplying the magnitude vector and the bump vector to form a texture-magnitude vector (mTb\u2032); scaling components of the texture-magnitude vector by a vector s to form a scaled texture-magnitude vector (mTb\u2033); multiplying the scaled texture-magnitude vector and the unit transformation matrix to provide a perturbed normal (N\u2033); re-scaling components of the perturbed normal to form rescaled vector (N\u2033); and normalizing the resealed vector to provide a unit perturbed normal that is used to perform lighting computations to give the pixel fragment bump effects.","In a variation of this method, the step of scaling the components of the texture-magnitude vector comprises the step of selecting the scalars so the resulting matrix can be represented as a fixed-point vector. In another variation of this method, the vector s comprises scalars (s, s, s), and wherein the step of scaling the components of the texture-magnitude vector comprises the step of multiplying texture-magnitude vector comprising s as follows: mTb\u2033=(s\u00d7mh, s\u00d7mh, s\u00d7mk). In yet another variation of this method, the unit transformation matrix also comprises fixed-point values, and wherein the step of multiplying the scaled texture-magnitude vector and the unit transformation matrix comprises the step of multiplying using fixed-point multiplication hardware. In a further variation of this method, the step of re-scaling components of the perturbed normal comprises the step of multiplying by a reciprocal of vector s (1\/(s, s, s)) to re-establish a correct relationship between their values.","Other aspects and embodiments of the inventive structure and method are described in the remainder of the specification and in the drawings.","The Phong Block calculates the color of a fragment by combining the color, material, geometric, and lighting information from the Fragment Block with the texture information from the Texture Block. The result is a colored fragment that is forwarded to the Pixel Block where it is blended with any color information already residing in the frame buffer.","Note that Phong does not care about the concepts of frames, tiles, or screen-space.","In accordance with the present invention the Phong Block embodies a number of features for performing tangent space lighting in a deferred shading environment. These features include:\n\n","One feature of the Phong block  is that it does not interpolate partials or normals. Instead, these interpolations are done in the Fragment block , which passes the interpolated results to Phong. The method by which Fragment  performs these interpolations is described above; however, features of this method and its advantages are briefly recited herein:\n\n","Another feature of the Phong block  is that it does not interpolate L or H vectors. Instead, Phong receives from the Fragment block  a unit light vector PI and a unit fragment vector V, both defined in eye space coordinates. Phong derives the light vector L without interpolation b y subtracting V from P. Phong is then able to derive the half-angle vector H from the light vector and a known eye vector E.","Compared to the prior art, advantages of the inventive system for performing tangent space lighting in a deferred shading architecture include:\n\n","Various features of the present invention are now described, first in summary and then at an appropriate higher level of detail.","Color Index Mode","Texture and fragment lighting operations do not take place in color index mode. In this mode the only calculations performed by the Phong Block are the fog calculations. In this case the mantissa of the R value of the incoming fragment color is interpreted as an 8-bit color index varying from 0 to 255, and is routed directly to the fog block for processing.","Pipeline Position","Referring to FIG. G , there is shown a block diagram illustrating Phong's position in the pipeline and relationship to adjacent blocks. The Phong Block  is located after Texture  and before Pixel . It receives data from both Texture and Fragment . Fragment sends per-fragment data as well as cache fill data that are passed through from mode injection. Texture sends only texel data . In the illustrated DSGP the data from Fragment  include: stamp x, y ; RGBA diffuse data ; RGBA spectral data ; surface normals ; bump basis vectors ; eye coordinates ; light cache index ; and material cache index ","Only the results  produced by Phong are sent to Pixel ; all other data  required by Pixel  comes via a separate data path. The Phong Block has two internal caches: the alight cache , which holds infrequently changing information such as scene lights and global rendering modes, and the \u201cmaterial\u201d cache , which holds information that generally changes on a per-object basis.","Phong Computational Blocks","The Phong procedure is composed of several sub-computations, or blocks, which are summarized here. Pseudo-code along with details of required data and state information are described later in this specification. FIG. G  shows a block diagram of Phong , showing the various Phong computations.","Texture Computation","Texture computation  accepts incoming texels  from the Texture Block and texture mode information from the material cache . This computation applies the texture-environment calculation and merges multiple textures if present. The result is forwarded to the Light-environment subunit  in the case of the conventional use of textures, or to other subunits, such as Bump , in case the texture is to be interpreted as modifying some parameter of the Phong calculation other than color.","Material Computation\/Selection","Material computation  determines the source of the material values for the lighting computation. Inputs to Material computation  include material texture values from Texture , fragment material values  from Fragment and a primary color  originating in the Gouraud calculation. Using current material mode bits from the material cache  the Material computation may decide to replace the fragment material  with the texture values  or with the incoming primary color .","Bump Computation","Bump computation  determines the surface normal to be used in the lighting calculation. Inputs to Bump include bump texture information  from Texture  and the surface normal, tangent and binormal  from Fragment . The Bump computation  may simply pass through the normal as interpolated by Fragment, or may use a texel value  in a calculation that involves a 3\u00d73 matrix multiply.","Light-Texture Computation","Inputs to Light-Texture computation  include light texture information  from the Texture computation  and the fragment light information  from Fragment. Light-Texture computation  decides whether any of the components of the lights  should be replaced by a texel .","Fragment Lighting Computation","Fragment lighting computation  performs the actual lighting calculation for this fragment using an equation similar to that used for per-vertex lighting in the GEO block. This equation has been discussed in detail in the Background section. Inputs to Fragment Lighting include material data  from Material selection , surface normal from Bump  and light data from  from Light-Texture .","Light Environment Computation","Light environment computation  blends the result  of the fragment lighting computation with the texture color  forwarded from the Texture Block.","Fog Computation Fog computation  applies \u201cfog\u201d; modifies the fragment color  using a computation that depends only on the distance from the viewer's eye to the fragment, the final result  from Fog computation  is forwarded to the Pixel Block.\n\nPhong Hardware Details\n","The previous section has generally described the blocks composing the Phong computation and the data used and generated by those sub-blocks. The blocks can be implemented in hardware or software that meets the requirements of the preceding general description and subsequent detailed descriptions. Similarly, data can be transferred between the Phong blocks and the external units (i.e., Texture, Fragment and Pixel) and among the Phong blocks using a variety of implementations capable of satisfying Phong I\/O requirements. While all of these alternative embodiments are within the scope of the present invention, a description is now provided of one preferred embodiment where the Phong blocks are implemented in hardware and data is transferred between top-level units (i.e., Texture, Fragment, Phong and Pixel) using packets. The content of the I\/O packets is described first.","I\/O Packets","Referring to FIG. G , there is shown a block diagram illustrating packets exchanged between Phong , Fragment , Texture  and Pixel  in one embodiment. The packets include:\n\n","Each of these packets is now described.","Input Packets from Fragment","The Phong block  receives packets ,  from the Fragment block  containing information that changes per-fragment that cannot be cached. Generally, a packet from the Fragment  contains for one fragment:\n\n","In the full-performance mode, an \u201cinfinite viewer\u201d condition is assumed in which:\n\n","In this case the only data that varies per fragment is the surface normal direction and the Gouraud colors produced by the geometry engine.","In one embodiment, to reduce bandwidth and input queue size per-stamp information is shared among all the pixels of a visible stamp portion. This allows Fragment  to send only one full-rate packet  per VSP that also applies to up to four fragments composing the VSP). In this case, Phong needs to be told how many fragments make up the stamp, but has no need to know the screen space coordinates of the fragment.","In view of these aspects of the full performance mode, among other parameters, the full-rate packet  provides:\n\n","One embodiment of a full-rate packet  from Fragment is described in Table P1. This table lists for each data item in the packet: item name; bits per item; number of item in packet; bits per packet used for the item; bytes per packet used for the item; shared factor; and bytes per fragment used for the item.","A key subset of the parameters\/data items recited in Table P1 are defined below, in the section of the document entitled \u201cPhong Parameter Descriptions\u201d. This full-rate packet embodiment is merely exemplary and is not to be construed to limit the present invention.","At the bottom of the table is an estimate of the bandwidth required to transfer the full-rate packets (3,812.50M bytes per second) shown in Table P1 assuming the DSGP processes 250.00M fragments per second.","Half Rate Packet from Fragment","At half-rate the illustrated Phong embodiment can perform bump mapping and local viewer (i.e., variable eye position) operations. An additional difference over the full-rate operations is that the normal provided by the Fragment block for these operations is not required to be of unit magnitude.","As a result of these differences, in addition to the information provided in the full-rate packet , the half-rate packet  provides for each fragment in a stamp: normal unit vector and associated magnitude (FIG. G ); surface tangent unit vector and associated magnitude (part of bump basis , FIG. G ); surface binormal unit vector and associate magnitude (part of bump basis , FIG. G ); eye coordinates ","As with the full-rate embodiment described above, Fragment  can send one half-rate packet  per VSP that also applies to up to four fragments composing the VSP.","One embodiment of a half-rate packet  from Fragment is descri
