---
title: Recovery and representation of object interaction in an object oriented program
abstract: A process and system are provided for representing object interactions, by means of a sequence diagram or the like, wherein the object interactions are recovered from source code written in Java or other object-oriented programming language. Initially, a Method Information Parser determines the respective methods declared inside the source code and extracts their names. A Method Detail Parser then extracts the method calls to other objects within a method, to resolve each complex method call into multiple lines of single method calls. Information derived from the multiple lines of single method calls is then used to generate the sequence diagram.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07426716&OS=07426716&RS=07426716
owner: Board of Regents, The University of Texas System
number: 07426716
owner_city: Austin
owner_country: US
publication_date: 20030711
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF A PREFERRED EMBODIMENT"],"p":["The Grant Program of the State of Texas may own certain rights in this invention pursuant to the terms of the Advanced Technology Program No. 003656-97 and Technology Development & Transfer Program No. 003656-92.","The invention is generally directed to a process and system for recovering information pertaining to object interactions in a previously developed object-oriented software program, and to providing a visual or other representation of the recovered object interactions. More particularly, the invention pertains to a reverse engineering approach for automatically recovering the object interaction information, and generating a corresponding sequence diagram or other useful representation thereof.","Software testing tends to consume a substantial portion of total software development effort, and software maintenance can amount to up to 60% of life cycle costs. A common problem in both software testing and maintenance is deficient documentation, wherein the documentation is often non-existent, inadequate or outdated. These deficiencies can occur for a number of reasons, including inadequate analysis and design effort, requirements changes and changes to code, wherein corresponding updates to the design are not made. Design recovery from object-oriented (OO) programs such as JAVA\u2122 by Sun Microsystems and C++ has been proposed, as a means to obtain design information when accurate documentation is not available. Previously, techniques have been proposed for reverse engineering JAVA\u2122 and C++ programs to uncover static relationships among objects, such as inheritance, aggregation and association, member function control and data flow relationships, and object state dependent behavior. Reverse engineering is generally the process of analyzing a subject to identify system components and their relationships, and to create representations of a system in another form at a higher level of abstraction.","Object-Oriented Technologies Works (OOTWorks) is a tool that uses the reverse engineering approach to help analyze, test, and maintain object-oriented software. It contains three kinds of diagrams. They are Object Relation Diagram (ORD), Block Branch Diagram (BBD), and Object State Diagram (OSD). ORD is used to display class relationships, BBD is used to represent the structure of a member function within a class, and OSD is used to display the state dependent behaviors of objects.","Object Relation Diagram not only can represent the relations between classes, but also can generate automated test schedule, test order, and identify the ripple effect to save time and effort in regression testing.","BBD (Block Branch Diagram) is a reverse engineering tool that displays the control structure and the interfaces of a member function. Besides the structure of a member function, Block Branch Diagram also shows the independent basis paths in the method. It also helps identify the complexity of a method. Like ORD, it can generate the test case based on the basis paths it found.","The three tools of OOTWorks offer tests from different levels. ORD tests at class level. BBD tests at the class member function level. OSD tests at the class data member level based on the different states of the objects. The reverse-engineering tool, SDG, is added to become another integral part of the toolset.","Objects in an OO program interact with each other to accomplish a business task. The objects are instances of respective object classes, and the classes also have methods belonging to them. A method is a certain single operation that is invoked or called at run-time, in order to change the state or characteristic of an object in its associated class. The interactions among the objects may be quite complex, due to powerful OO features such as encapsulation, information hiding, polymorphism and inheritance. Encapsulation is modeling and storing, with an object, the attributes and methods or operations that the object is capable of performing. In information hiding, only the operations of a particular object can be used to access private components of the particular object. As a result of the above OO features, several member functions, or method calls, can be invoked to achieve an intended functionality, wherein the member functions or method calls may be from different object classes. In object-oriented programming, polymorphism is the characteristic of being able to assign a different meaning or usage to something in different contexts\u2014specifically, to allow an entity such as a variable, a function, or an object to have more than one form","All reversed engineering environment need tools for extracting the information to be analyzed. Static information includes software artifacts and their relations. In JAVA\u2122, for example, such artifacts may be classes, interfaces, methods and variables. The relations might include extension relationships between classes or interfaces, and calls between methods. Dynamic information contains software artifacts as well, and in addition contains sequential event trace information, information about current behavior and code convergence. Static information can be extracted, for example, by using parser-based grammars. For extracting dynamic information, a debugger, profilers, or event recorders can be used.","Extracted information of the above type is not useful unless it can be shown in a readable and descriptive way. Accordingly, program comprehension, by building graphical or viewable design models from existing software, has been supported in many reverse engineering and design recovery tools and environments. There are generally three kinds of views that can be used to illustrate the extracted information, i.e., static, dynamic and merged views, respectively. A static view contains only static information and a dynamic view contains only dynamic information. A merged view is used to show both static and dynamic information in a single view. A merged view is useful, as it provides a connection between static and dynamic information. However, because of polymorphism and inheritance, a static analysis is not able to extract method information from method calls. On the other hand, building an abstraction for merged views can be difficult, since static and dynamic abstractions usually differ considerably.","In order to facilitate understanding, test generation, debugging and documentation, an embodiment of the invention has been developed to provide a reverse engineering technique for design recovery of object interactions from OO programs, such as JAVA\u2122 or C++. Moreover, the embodiment is adapted to represent the artifacts of the program in a very useful form, such as in the form of sequence diagrams. The embodiment of the invention usefully comprises a static analysis technique, wherein multiple passes are used to break the complex OO code and uncover object interactions gradually during successive passes. This enables the embodiment of the invention to support certain powerful features of the OO paradigm, such as inheritance and polymorphism. That is, the proposed method can handle calls to member functions of super-classes as well as calls to polymorphic functions. In addition, the embodiment can handle consecutive calls in the form of O.f ( . . . ).g( . . . ).h( . . . ).k( . . . ), where \u201cO\u201d represents an object reference, and \u201cf,\u201d \u201cg,\u201d \u201ch\u201d and \u201ck\u201d each represent methods, which is very common in JAVA\u2122 programming. It is to be understood, however, that embodiments of the invention are not limited to either JAVA\u2122 or to representation by means of sequence diagrams.","It is anticipated that embodiments of the invention will be particularly beneficial in software design modification and debugging, and in providing accurate documentation for software maintenance. In regard to design modification, designs usually have to be modified during the implementation phase to accommodate requirements changes. Debugging involves tracing code to identify discrepancies between implementation and expectations. Accurate and comprehensible documentation is crucial to the success of large-scale development.","One embodiment of the invention is directed to a process for providing a representation of object interactions or other specified characteristics of a previously developed object-oriented software program, the program including a number of object classes and further including object related methods belonging to respective classes. The process comprises the steps of sensing that at least one complex method call is included in the software program, a number of methods being associated with each complex method call, and extracting a number of single or individual method calls from each complex method call. The process further comprises the steps of generating a set of information for each of the methods from the single method calls, and constructing a representation of interactions between objects of the software program from the information contained in the method information sets.","Preferably, the extracting step of the above process comprises replacing a component of a complex method call with a phase variable, to produce a method call of reduced complexity. Preferably also, the process includes an initial step of extracting the names of the methods from the software program, and the class to which each method belongs.","In a preferred embodiment of the above process, the extracting step comprises a first parsing phase disposed to separate all casting operations, a second parsing phase disposed to isolate all method parameters, and a third parsing phase disposed to separate the complex method call into multiple lines, one for each single method call. The representation construction step comprises constructing a sequenced diagram depicting the interactions between respective objects of the software program.","A very useful embodiment of the invention may be employed to recover, or uncover, object interaction features from the source code of a JAVA\u2122 program, although other embodiments may be used in connection with C++ or other programming languages. Generally, respective methods are detected and parsed to gain insight into object interactions. The object interactions are then graphically depicted in the form of a sequence diagram, using a sequence diagram Generator (SDG) constructed in accordance with an embodiment of the invention. The sequence diagram preferably uses a Unified Modeling Language (UML), although other languages can alternatively be used.","A UML sequence diagram is preferred in representing the uncovered object interactions because UML is widely used in the software industry. A sequence diagram helps a user to document and understand the dynamic aspects of a software system through sequences of messages that are sent and received among objects. In particular, it shows the objects participating in the interaction by their \u201clifelines\u201d and the messages they exchange are arranged in time sequence. A sequence diagram has four primary elements: objects, lifelines, messages and focus. Objects are represented by boxes and placed at the top of the sequence diagram across its horizontal axis. A lifeline, represented by a dotted line that extends down the vertical axis from the base of an object, indicates the existence of an object during a period of time. Messages represent the interactions among the objects. Messages are shown as labeled arrows from the lifeline of one object to the lifeline of another object. Focus of control shows a time period during which an object is performing an action in response to a message received. Focus of control is shown as a tall thin rectangle whose top is aligned with the action's initiation time and whose bottom is aligned with the action's completion time. The top of the focus of control rectangle coincides with the receipt of a message. The bottom of the rectangle coincides with the completion of an action. Focus of control rectangles can be stacked in layers on a sequence diagram to indicate focus of control nesting.","To further illustrate respective components of a sequence diagram, reference may be made to .  shows objects A-E, respectively labeled \u201cPassenger,\u201d \u201cElevator Button,\u201d \u201cElevator Control,\u201d \u201cElevator\u201d and \u201cDoor.\u201d  further shows lifelines A-E, associated with objects A-E, respectively, and messages A-I. The message arrows A-I are respectively directed as shown, and are respectively labeled \u201cpressed,\u201d \u201cupdated,\u201d \u201cilluminate,\u201d \u201ccancel illuminate,\u201d \u201cmove,\u201d \u201cfloor reach,\u201d \u201cstop,\u201d \u201copen\u201d and \u201cclose.\u201d The focus of controls are referenced as A-H.","Referring to , there is shown SDG  comprising an embodiment of the invention. SDG  includes a Method Information Parser , a Method Detail Parser , a Diagram Generator  and a Drawing Engine .  further shows a Graphic User Interface (GUI)  connected to interact with Method Information Parser , Diagram Generator  and Drawing Engine , and JAVA\u2122 (or C++) Source Code  is accessed by both Information Parser  and Detail Parser . The output of Method Information Parser  is provided as the input to Method Detail Parser , and the output thereof is placed in Method Detail Data Base, or repository, . Diagram Generator  is coupled to Data Base  and to Sequence Diagram Data Base , and Drawing Engine  is likewise coupled to Data Base .","In summarizing operation of SDG , Method Information Parser  extracts the method name and the beginning line number of a method selected by the user, by means of GUI . After extracting this information, method calls made by the selected method are captured and recorded in data repository . Since it is possible to combine several method calls into one complex single-line method call in OO programming, e.g., object. O.f( . . . ).g( . . . ).h( . . . ).k( . . . ), Method Detail Parser  is designed and implemented to extract the single or individual method calls from the complex single-line method call statement, as described hereinafter in further detail. The Diagram Generator  recursively invokes Method Information Parser  and Method Detail Parser  to extract method name, to capture methods being called from the current method, and to generate the corresponding sequence diagram entry in an ASCII file contained in Data Base . The Drawing Engine  reads the ASCII file and draws the sequence diagram. An entry for the sequence diagram is a quadruple, in which the components are separated by vertical bars \u201c|,\u201d as follows:\n\n","The Sequence Diagram Generator  follows the depth first search strategy. That is, the recursive search is stopped when the Sequence Diagram Generator  encounters a JAVA\u2122 Application Programming Interface (API) in the source code. In the embodiment, JAVA\u2122 APIs are treated as black-boxes and not expanded. After all method calls are processed, the entries for the sequence diagram are passed to the Drawing Engine  to draw the sequence diagram.","The purpose of Method Information Parser  is to extract basic information about the methods of the classes from the source code. In the operation of Parser , the methods declared inside the source code are determined. Parser  then parses the source code and when it reaches a method declaration, the name of the method being declared is provided, as well as the class this method belongs to and its starting line number. The starting line number is required because this information is used to quickly locate the method in the operation of Method Detail Parser  to parse the method. The class name and method name tell which method and which class it belongs to will be parsed. The captured information regarding the method is stored in the following format:","FileName|MethodName|StartingLineNumber","This information is eventually written to an ASCII file so that other tools can easily read and process it. In order to ensure that the ASCII file corresponding to a particular class is not overwritten, a hierarchy of directory structure is used to organize the ASCII files, as follows:",".\\dat\\PackageName\\ClassName\\filename.dat","Method Operation Parser  can also extract information regarding all the packages or classes that are imported in the JAVA\u2122 file being parsed, and this information is likewise stored in the data repository  in an ASCII file. This information can be helpful in later stages of parsing, if it is necessary to determine the return type of a method.","Method Detail Parser  extracts the method calls to other objects within a method. It produces the following information, represented in the following format:","ClassName|MethodName|NumberOfParameters|ParameterList|ReturnType|Absolute Path|Condition","ClassName: the name of the class that this method belongs to.","MethodName: the name of this method.","NumberOfParameters: the number of parameters.","ParameterList: the list of all parameters for this method.","Condition: the condition that must be evaluated to true for the method to be invoked.","ReturnType: gives information about the return type of the method.","AbsolutePath: absolute path of the source file containing the method","To maintain this information for a particular method, the following directory structure, similar to the structure for Method Information Parser , is used:",".\\dat\\PackageName\\ClassName\\MethodName\\function.dat","Method Detail Parser  overcomes several technical difficulties, including a difficulty caused by the common practice of OO programming of making consecutive function calls using a single statement of the form object O.f ( . . . ) g( . . . ) h( ) . . . . For the purpose of sequence diagram generation, it is necessary to determine the classes associated with the objects making the function calls. Thus, in the above example, it is necessary to obtain the class for object, that is the class for the object resulting from the call to object O.f ( . . . ) . . . Another difficulty overcome by Detail Parser  is associated with the casting operation, which changes the type or class of an object. The casting operation can appear anywhere, including consecutive method calls in a single statement. This poses some difficulty in the static analysis of programs. A further challenge overcome is the handling of complex actual parameters that are passed to a method during a call. For example, an actual parameter may itself be a consecutive function call in a single phrase like object O.f (x.g( . . . )h( . . . ) . . . ). Finally, Parser  is able to differentiate and properly process both application defined functions and JAVA\u2122 APIs.","Method Detail Parser  achieves its results by breaking the complex parsing process into a series of simple parsing phases as follows:\n\n","Referring to , there is shown Method Detail Parser  comprising the above phases or components -, respectively. The phases are each described hereinafter.","Separating Casting Operations","Casting changes the type of an object or the return type of a method call. Since the casted type must be determined before any operation on an object of the casted type can be executed, the casting operation needs to be taken care of in the first step. This phase separates all the casting operations in a method call. Accordingly, phase variables are used to replace the casting expression. The idea of this phase can be easily conveyed by a dummy example:\n\n","Next, it is necessary to take care of complex arguments in method calls. Complex arguments, such as a function call to an object, must be isolated and replaced with simple arguments. This is necessary if the type of an argument cannot be found from the declarations of variables. For example, the argument is a function call. Phase variables are again introduced to represent the arguments that are isolated. This is done in order to get the return type of the function call. The argument type is needed to resolve polymorphism. This is illustrated using a simple example:\n\n","This phase breaks single statement continuous method calls into multiple lines of simple method calls. For example:\n\n","This is the main phase, which finds out the types for all variables and method calls. In this phase, the output provided by the Separating Continuous Method Calls phase is parsed to find the correct variable types (including the phase variables). If a standard JAVA\u2122 API is called, then reflection and the imports file generated by Method Information Parser  is used to get the return type.","Parsing Issues","Since JAVA\u2122 is a new programming language and still evolving, it is inefficient to keep a large record for all standard JAVA\u2122 methods (API's) and use it to distinguish between them and user-defined methods. To distinguish between standard JAVA\u2122 APIs and user-defined methods, a preferred approach is to use the symbol table created by ORD. This table contains all the user-defined classes and file locations for the classes. To determine if a method is a user defined method, the class name of the object containing this method is first retrieved. This class name is then compared with all the class names in the symbol table (this comparison includes package name and class name). If this class name is recorded in the symbol table, then it is a user-defined method; otherwise, it is a standard Java JAVA\u2122.","Reference was previously made to inheritance, one of the powerful features of modern object-oriented programming language. Inheritance implies that methods defined for a superclass are automatically defined for its subclasses. That is, a call to a method of an object of a subclass may in fact invoke a method defined in the superclass. The Method Detail Parser  utilizes the inheritance relationships captured by ORD. When encountering a method call, it first tracks the inheritance path until it reaches a parent class in which the method is defined. If no such class is found, then the parser uses the import clauses and reflection to trace the JAVA\u2122 APIs, to identify the class that defines the method. Another powerful feature in OO programming is polymorphism. Polymorphism allows programmers to write multiple methods with the same name but different parameter types or number of parameters. In the approach of the invention, polymorphism is solved by using reflection and a symbol table generated by ORD. The symbol table entry contains the following information:","PackageName\\ClassName\\MethodName\\ParameterList\\NumberofParameters\\ReturnType\\Starting-LineNumber\\","Reflection is used to retrieve class-related information such as class attributes and methods. Since a method can be either a standard JAVA\u2122 API or a user-defined method, it is necessary to match the correct method separately. If it is decided that the method call is a standard JAVA\u2122 API, reflection is used to get the return type of the standard JAVA\u2122 API. The type is then used to update the variable table in case it is used as one of the parameters in another method call. On the other hand, if this method call is a user-defined method call, the data in the ORD symbol table is searched for the user-defined method to match with the correct version of the method call. As in retrieving the return type in standard JAVA\u2122 API, the return object type is updated in the variable table as well.","A sequence diagram displays the condition of a method call to indicate that the call occurs only when the condition is evaluated to true. Nested if-then-else statements require that the Parser  must generate correct conditions for drawing the sequence diagram. Accordingly, a condition stack and recursion to handling nested if-then-else statements is used as follows:\n\n","Switch and iterative statements are handled similarly.","Referring to , there is shown a sequence diagram generated in accordance with an embodiment of the invention, from software code listed hereinafter under the headings \u201cMain Program,\u201d \u201cVending Machine,\u201d \u201cCoin Box\u201d and \u201cItem Dispenser.\u201d In the sequence diagram of , a sequence number notation is used to signify the order of the messages, and thus simplify the drawing effort. For example, a message with a sequence number .. implies that it is a call from the message with a sequence number . which in turn is called from a message with a sequence number .  also shows the use of phase variables, such as SDG_P26543210 shown in connection with sequence numbers  and  of , to recursively simplify complex method calls as described above. Obviously, many other modifications and variations of the present invention are possible in light of the above teachings. The specific embodiments discussed here are merely illustrative and are not meant to limit the scope of the present invention in any manner. It should be appreciated that the present invention provides many applicable inventive concepts that may be embodied in a wide variety of specific contexts. It is therefore to be understood that within the scope of the disclosed concept, the invention may be practiced otherwise than as specifically described.","Main Program",{"@attributes":{"id":"p-0057","num":"0096"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"package coinbox;"]},{"entry":[{},"import java.io.*;"]},{"entry":[{},"import Math.*;"]},{"entry":[{},"public class Main"]},{"entry":[{},"{"]},{"entry":[{},"private static BufferedReader br ="]},{"entry":[{},"new BufferedReader (new InputStreamReader(System.in));"]},{"entry":[{},"private static int readln( )"]},{"entry":[{},"{"]},{"entry":[{},"String selection = \u201c\u201d;"]},{"entry":[{},"try {"]},{"entry":[{},"selection = br.readLine( );"]},{"entry":[{},"} catch (IOException e)"]},{"entry":[{},"{"]},{"entry":[{},"e.printStackTrace( );"]},{"entry":[{},"}"]},{"entry":[{},"return Integer.parseInt(selection);"]},{"entry":[{},"}"]},{"entry":[{},"public static void main(String[] args)"]},{"entry":[{},"{"]},{"entry":[{},"VendingMachine vm = new VendingMachine( );"]},{"entry":[{},"int selection = 0;"]},{"entry":[{},"while (true)"]},{"entry":[{},"{"]},{"entry":[{},"switch (readln( ))"]},{"entry":[{},"{"]},{"entry":[{},"case 0: vm.insertCoin(25);"]},{"entry":[{},"break;"]},{"entry":[{},"case 1: System.out.print(\u201cselect item 0-4: \u201d);"]},{"entry":[{},"vm.vend(readln( ));"]},{"entry":[{},"break;"]},{"entry":[{},"case 2: vm.returnCoin( );"]},{"entry":[{},"break;"]},{"entry":[{},"case 3: System.exit(0);"]},{"entry":[{},"break;"]},{"entry":[{},"default: ;"]},{"entry":[{},"}"]},{"entry":[{},"}"]},{"entry":[{},"}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0058","num":"0097"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"package coinbox;"]},{"entry":[{},"import java.io.*;"]},{"entry":[{},"public class VendingMachine"]},{"entry":[{},"{"]},{"entry":[{},"private CoinBox coinBox = new CoinBox( );"]},{"entry":[{},"private Dispenser dispenser = new Dispenser( );"]},{"entry":[{},"public void insertCoin(int amt)"]},{"entry":[{},"{ try {"]},{"entry":[{},"coinBox.insertCoin(amt);"]},{"entry":[{},"} catch (InvalidCoinException e)"]},{"entry":[{},"{ coinBox.returnCoin( );"]},{"entry":[{},"e.printStackTrace( );"]},{"entry":[{},"}"]},{"entry":[{},"}"]},{"entry":[{},"public void vend(int item)"]},{"entry":[{},"{"]},{"entry":[{},"int c = coinBox.getCurAmt( );"]},{"entry":[{},"try {"]},{"entry":[{},"int p = dispenser.getPrice(item);"]},{"entry":[{},"if (c<p)"]},{"entry":[{},"System.out.println (\u201cinadequate payment\u201d);"]},{"entry":[{},"else"]},{"entry":[{},"{"]},{"entry":[{},"coinBox.makeChange(p);"]},{"entry":[{},"dispenser.dispense(item);"]},{"entry":[{},"}"]},{"entry":[{},"} catch (UnknownItemException uie)"]},{"entry":[{},"{ uie.printStackTrace( );"]},{"entry":[{},"} catch (ItemNotAvailableException inae)"]},{"entry":[{},"{ inae.printStackTrace( );"]},{"entry":[{},"coinBox.returnCoin( );"]},{"entry":[{},"} catch (InvalidPriceException ipe)"]},{"entry":[{},"{ ipe.printStackTrace( );"]},{"entry":[{},"coinBox.returnCoin( );"]},{"entry":[{},"}"]},{"entry":[{},"}"]},{"entry":[{},"public void returnCoin( ) { coinBox.returnCoin( ); }"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0059","num":"0098"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"package coinbox;"]},{"entry":[{},"import java.io.*;"]},{"entry":[{},"public class CoinBox"]},{"entry":[{},"{"]},{"entry":[{},"private int curAmt;"]},{"entry":[{},"private int total;"]},{"entry":[{},"public int getCurAmt ( ) { return curAmt; }"]},{"entry":[{},"public void insertCoin (int amt)"]},{"entry":[{},"throws InvalidCoinException"]},{"entry":[{},"{ if(amt!=5&&amt!=10&&amt!=25)"]},{"entry":[{},"throw new InvalidCoinException( );"]},{"entry":[{},"this.curAmt += amt;"]},{"entry":[{},"System.out.println (\u201cCurrent Amount is \u201d+curAmt);"]},{"entry":[{},"}"]},{"entry":[{},"public int getTotal ( ) { return total; }"]},{"entry":[{},"public void makeChange (int price)"]},{"entry":[{},"throws InvalidPriceException"]},{"entry":[{},"{ if (price>0)"]},{"entry":[{},"{ release(curAmt-price);"]},{"entry":[{},"curAmt = 0;"]},{"entry":[{},"total += price;"]},{"entry":[{},"}"]},{"entry":[{},"else"]},{"entry":[{},"throw new InvalidPriceException( );"]},{"entry":[{},"}"]},{"entry":[{},"private void release (int amt)"]},{"entry":[{},"{ System.out.println (\u201cRelease \u201d+amt); }"]},{"entry":[{},"public void returnCoin ( )"]},{"entry":[{},"{ release (curAmt); curAmt=0; }"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0060","num":"0099"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"package coinbox;"]},{"entry":[{},"import java.io.*;"]},{"entry":[{},"public class Dispenser"]},{"entry":[{},"{"]},{"entry":[{},"private int[] prices = new int[] {50, 50, 50, 50, 50};"]},{"entry":[{},"private int[] qoh = new int[] {100, 100, 100, 100, 100};"]},{"entry":[{},"public int getPrice (int item)"]},{"entry":[{},"throws UnknownItemException"]},{"entry":[{},"{"]},{"entry":[{},"if(item<0 \u2225 item > prices.length)"]},{"entry":[{},"throw new UnknownItemException( );"]},{"entry":[{},"return prices[item];"]},{"entry":[{},"}"]},{"entry":[{},"public void dispense (int item)"]},{"entry":[{},"throws ItemNotAvailableException"]},{"entry":[{},"{"]},{"entry":[{},"if (qoh[item]==0)"]},{"entry":[{},"throw new ItemNotAvailableException( );"]},{"entry":[{},"release (item);"]},{"entry":[{},"qoh[item]--;"]},{"entry":[{},"}"]},{"entry":[{},"private void release (int item)"]},{"entry":[{},"{"]},{"entry":[{},"System.out.println (\u201cCall dispenser driver to release item \u201d+item);"]},{"entry":[{},"}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
