---
title: System and method for command tracking
abstract: Embodiments of the present invention provide a system and method of command tracking that eliminates, or at least substantially reduces, the shortcomings of prior art systems and methods for command tracking. More particularly, embodiments of the present invention provide a system and method in which a command is assigned a unique identification. State information for the command (e.g., has the command been completed, has all the data associated with the command been received and other state information) can be associated with the unique identification and recorded. According to one embodiment, the state information can be stored in various tables that correspond to particular data transport protocols and/or devices. Because the state information for the command is associated with the unique identification in the tables, state information for the same command can be identified, even if the command changes data transport protocols.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07711805&OS=07711805&RS=07711805
owner: Crossroads Systems, Inc.
number: 07711805
owner_city: Austin
owner_country: US
publication_date: 20041222
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","TECHNICAL FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["This application claims priority under 35 U.S.C. 119 (e) to U.S. Provisional Application No. 60\/629,719, entitled \u201cSystem and Method for Command Tracking\u201d by Stephen Dale, filed Nov. 19, 2004, which is hereby fully incorporated by reference herein.","Embodiments of the present invention relate to tracking commands. More particularly, embodiments of the present invention relate to tracking the flow of a command across protocol layers.","In storage area networks, routers process commands between hosts and target devices. Typically, the hosts are connected to the router by a first data transport medium (e.g., fibre channel transport medium) and the target devices are connected to the hosts by a second data transport medium (e.g., a SCSI transport medium). This presents problems in being able to understand the flow of information through the router as the manner in which information is transported changes. Because the flow of information in the router is not well understood, it is often difficult to assess the cause of an error or other issue, particularly when the issue only manifests itself under heavy loads with data flowing to multiple hosts\/devices at a time.","Typically, in prior systems, insufficient information is maintained to track a command through a router. In order to determine the source of an error associated with a command, the conditions under which the error occurred (including hardware, software and load conditions) must be replicated. The router must then be monitored to determine the cause of the error, assuming the error reoccurs in the replicated conditions. Replication of the conditions under which an error occurred can be time consuming and costly.","To the extent that information that can aid in diagnosing errors or other issues associated with commands is maintained, it is typically kept in a chronological log that records each status message as it occurs. When the list becomes too long, the oldest entries in the list are overwritten. In attempting to resolve an issue, a system administrator must typically print out the list to determine when errors occurred. However, it is often difficult to associate status messages with particular commands from such a list or to determine if an error is the result of issues at the host-side or target-side of a device.","Embodiments of the present invention provide a system and method of command tracking that eliminates, or at least substantially reduces, the shortcomings of prior art systems and methods for command tracking. More particularly, embodiments of the present invention provide a system and method in which a command is assigned a unique identification. State information for the command (e.g., has the command been completed, has all the data associated with the command been received and other state information) can be recorded in a manner that associates it with the unique identification. According to one embodiment, the state information can be stored in various tables that correspond to particular data transport protocols and\/or devices. Because the state information for the command is associated with the unique identification in the tables, state information for the same command can be identified even if the command changes data transport protocols.","One embodiment of the present invention includes a method for tracking commands that comprises receiving a command, assigning the command a unique identification and recording state information for the command. The state information is recorded in a manner such that it is associated with the unique identification. According to one embodiment, a first portion of this state information is recorded in a first table corresponding to a first data transport protocol while a second portion of the state information is recorded in a second table that corresponds to a second data transport protocol. The first table can further correspond to a particular host and the second table can correspond to a particular target device.","The state information for the command can be recorded by various protocol layers. Therefore, one embodiment of the method can include, at a first protocol layer corresponding to a first data transport protocol: determining that a message contains a command, assigning the command the unique identification, recording at least a first portion of the state information for the command in a first table, and passing the unique identification and the command to another layer. The method can further comprise, at a second protocol layer corresponding to a second data transport protocol: receiving the unique identification and the command and recording at least a second portion of the state information for the command in a second table.","Another embodiment of the present invention includes a computer program product for tracking commands that comprises a set of computer instructions stored on a computer readable medium. The set of computer instructions comprise instructions executable to assign a command a unique identification and record the state information for the command in a manner that associates the state information with the unique identification.","Yet another embodiment of the present invention includes a routing device that comprises a routing device that has a first controller operable to interface with a first data transport medium, a second controller operable to interface with a second data transport medium, a buffer to provide a memory workspace for the routing device and a processing unit connected to the first controller, the second controller and the buffer. The processing unit is operable to, assign a command a unique identification, associate state information for the command with the unique identification and record the state information for the command. The processing unit can be further operable to record a first portion of the state information in a first table corresponding to a first data transport medium and a second portion of the state information in a second table corresponding to a second data transport medium.","Another embodiment of the present invention includes a computer program product comprising a set of computer instructions stored on a computer readable medium. The computer instructions comprise instructions executable to assign a command received from an initiator a unique identification, record a first portion of state information for the command in a first table corresponding to a first data transport protocol wherein the first portion of the state information is associated with an initiator identification and the unique identification in the first table and record a second portion of the state information for the command in a second table corresponding to the second data transport medium, wherein the second portion of the state information is associated with a target identification and the unique identification in the second table.","Embodiments of the present invention provide an advantage over prior art systems and methods of command tracking by tracking state information for commands on a protocol-by-protocol basis.","Embodiments of the present invention provide another advantage over prior art systems and methods of command tracking by allowing a user to correlate various pieces of state information together using a unique identifier.","Embodiments of the present invention provide another advantage by tracking information on the host and target sides of a routing device. This can allow a user to determine whether an error manifested itself due to issues on the host-side or the target-side of the routing device.","Preferred embodiments of the invention are illustrated in the FIGURES, like numerals being used to refer to like and corresponding parts of the various drawings.","The small computer system interface (\u201cSCSI\u201d) protocol has become a ubiquitous protocol for formatting commands. Versions of the SCSI standard (e.g., SCSI-1, SCSI-2, SCSI-3) define both a command protocol with a set of defined commands (\u201cSCSI commands\u201d) and responses, a data transport protocol (the \u201cSCSI transport protocol\u201d) for encapsulating the commands and responses, and a SCSI physical interface. SCSI commands can be encapsulated according to a variety of data transport protocols without using the SCSI data transport protocol or SCSI physical interface. Example data transport protocols include fibre channel, serial storage architecture, serial bus protocol, iSCSI, advanced technology attachment (\u201cATA\u201d), serial ATA (\u201cSATA\u201d), serial attached SCSI (\u201cSAS\u201d) and others. Thus, the SCSI standard separates the SCSI physical interface, SCSI command sets and the SCSI data transport protocol.","Embodiments of the present invention provide a system and method for tracking the state of commands, particularly SCSI commands, in a routing device. When a command is received at a routing device, the command can be assigned a unique identification to internally identify the command at the routing device. State information for the command (e.g., has the command been completed, has all the data associated with the command been received and other state information) can then be recorded. When the state information is recorded it can be associated with the unique identifier. This can allow the command to which a particular set of state information belongs to be identified. The state information, according to one embodiment of the present invention, is stored in various tables associated with the data transport protocols supported by the routing device. According to one embodiment of the present invention, there are two tables for each protocol. The first table tracks commands received from devices connected by that protocol and the second table tracks commands sent to devices connected by that protocol. According to another embodiment, tables can be further kept on a device-by-device basis so that for each device connected to a routing device by a particular data transport protocol, say fibre channel, there will be a table to track commands received from that device and a table to track commands sent to that device. Because the state information is associated with the unique identifier in the tables, state information for the same command from the various tables can be correlated. This can aid in resolving issues experienced by the routing device.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":["100","100","100","102","104","106","108","104","102","110","104","106","100","102","106","102","106"]},"Continuing with the example in which data transport medium  is a fibre channel data transport medium and data transport medium  is a SCSI transport medium, routing device  can map the initiator\/host device to the target(s) according to any address mapping scheme known in the art, including that described in U.S. Pat. No. 6,041,381, entitled \u201cFibre Channel to SCSI Addressing Method and System,\u201d issued Mar. 21, 2000 to Hoese, which is hereby fully incorporated by reference herein and provide access control between host and target devices, such as described in U.S. Pat. No. 5,941,972, entitled \u201cStorage Router and Method for Providing Virtual Local Storage\u201d by Hoese, et al., issued Aug. 24, 1999, U.S. Pat. No. 6,421,753, entitled \u201cStorage Router and Method for Providing Virtual Local Storage\u201d by Hoese, et al., issued Jul. 16, 2002, U.S. Pat. No. 6,425,035, entitled \u201cStorage Router and Method for Providing Virtual Local Storage\u201d by Hoese, et al., issued Jul. 23, 2002, U.S. Pat. No. 6,730,854, entitled \u201cStorage Router and Method for Providing Virtual Local Storage\u201d by Hoese, et al., issued May 18, 2004, U.S. Pat. No. 6,789,752, entitled \u201cStorage Router and Method for Providing Virtual Local Storage\u201d by Hoese, et al., issued Jul. 19, 2004, U.S. Pat. No. 6,763,419 entitled \u201cStorage Router and Method for Providing Virtual Local Storage\u201d by Hoese, et al., issued Sep. 7, 2004, U.S. patent application Ser. No. 10\/658,163, filed Sep. 9, 2003, entitled \u201cStorage Router and Method for Providing Virtual Local Storage\u201d by Hoese, et al., each of which is hereby fully incorporated by reference herein.","Routing device  can include any network device known in the art, including storage routers, bridges, gateways or other device capable of routing data. Exemplary embodiments of routing devices include the Crossroads 6,000 and 10,000 Storage Routers by Crossroads Systems, Inc., of Austin Tex. Routing device  can include a first interface to connect to first data transport network  and a second interface to connect to second data transport medium . A processing unit can include a processor and a computer readable medium (RAM, ROM, magnetic storage and\/or other computer readable medium known in the art) storing a set of computer instructions (the \u201ctracking program\u201d). The processing unit can access memory that provides a memory workspace for the processing unit. One embodiment of a routing device is described in greater detail in conjunction with .","According to one embodiment of the present invention, routing device  can receive commands from host . The commands can include SCSI commands encapsulated according to a data transport protocol such as a fibre channel protocol or other data transport protocol. When a command is received from host , the tracking program can assign the command a unique identifier. The identifier can be arbitrarily derived, for example, from the data transport protocol used to transport the command (fibre channel, SCSI, iSCSI), a port number and an overall counter. The unique identifier, according to one embodiment, can be a thirty-two bit number. Routing device  can track the state of the command using the unique identifier for that command.","Commands, according to one embodiment of the present invention, can be tracked on a data transport protocol basis, so that for each data transport protocol, commands that are received from devices on that data transport protocol and commands sent to devices on that data transport protocol can be identified. The state information for the commands can be kept in one or more tables, with each table corresponding with a data transport protocol. In the example of the fibre channel-to-SCSI router, for example, there can be a host-side table  and a host-side table  to track commands received from hosts and sent to hosts, respectively, on the fibre channel data transport medium. There can also be a target-side table  and a target-side table  to respectively track commands sent to devices or received from devices on the SCSI data transport medium. In this case host-side table  and host-side table  correspond to the fibre channel data transport protocol, while target-side table  and target-side table  correspond to the SCSI data transport medium.","According to one embodiment of the present invention, host-side table  and host-side table  can be indexed by the host from which a command is received or to which a command is sent and the target-side table  and target side table  can be indexed by the target to which each command is sent or from which a command is received. Thus, each table provides a list of devices, commands sent to or received from those devices and any information recorded for the commands. Because each command is assigned a unique identifier, state information for the same command can be located in the various tables. According to another embodiment, the tables can be kept on a device-by-device basis. In this case, host-side table  and host-side table  may only include information related to commands sent to or received from host . Additional tables would be created to track commands sent to or received from other hosts.","According to one embodiment, each table can be stored using a circular buffer. When the memory allocated to a table is exceeded, the last entries in the table can be overwritten. For example, the information associated with each host device stored in host-side table  and the information associated with each target device stored in target-side table  can be stored in a circular buffer such that when the memory allocated for a particular device is exceeded, the oldest entries in the table for that device are overwritten. Thus, if one host sends a large number of commands to routing device  and the memory required to store information associated with that host in host-side table  is exceeded, only information associated with that host will be overwritten with new information for that host. The information associated with other hosts will not be affected.","The host-side and target-side information recorded for each command can be a matter of implementation. According to one embodiment of the present invention, the information recorded will indicate a change in state or status of the command at each side. For example, if a WRITE command is received from host , the WRITE command can be assigned a unique identifier and can be indexed in host-side table  under host . For the WRITE command, the fact that the command was received, the time that the command was received and other information associated with WRITE command can be stored. On the target side, the WRITE command can be indexed according to the target device in target-side table  and information associated for the WRITE command, such as the fact that the WRITE command was sent to target , the time the command was sent and other information.","Continuing with the previous example, when routing device  receives a \u201ctransfer ready\u201d message from target , routing device  can record the fact that a transfer ready was received and the time the transfer ready was received in target-side table  for the WRITE command. If routing device  sends a transfer ready message to host  for the WRITE command, routing device  can record information for the transfer ready message in host-side table  for the WRITE command. If routing device  must await the transfer of data associated with the WRITE command from host , routing device  can record, for example, an \u201cawaiting data\u201d status for the command in host-side table . As data arrives from host  for the WRITE command, routing device  can record this fact in host-side table  for the WRITE command. As routing device  sends the data to target , this fact can also be recorded for the WRITE command in target-side table . If target  sends a SCSI Status=good message in response to receiving data from routing device , routing device  can record the status=good for the WRITE command in target-side table . If routing device  forwards a SCSI Status=good message to host , this fact can be recorded for the WRITE command in host-side table .","According to another embodiment of the present invention, for a WRITE command, the information that can be recorded can include receipt of the command, receipt of the data to write, command sent to the target, data sent to the target and command completion. Other commands have similar common state changes that can be recorded.","Thus, for a command that is passed through routing device , routing device  can receive the command, assign the command a unique identification and record state information for the command. The state information for the command can be associated with the unique identification so that state information corresponding to the same command can be identified. The state information for the command can be stored in multiple tables. For example, a first portion of the state information (e.g., state information related to the host-side of routing device ) can be recorded in a first table corresponding to the first data transport protocol and a second portion of the state information (e.g., state information related to the target-side of routing device ) can be recorded in a second table corresponding to the second data transport protocol. The first table can further correspond to a particular host device while the second table can further correspond to a particular target device.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2A","b":["204","202","104","202","204"]},"In other embodiments of the present invention the first and second transport media (and respective controllers) can be: Fibre Channel and Fibre Channel; SCSI and SCSI; iSCSI and iSCSI; Fibre Channel and iSCSI; iSCSI and Fibre Channel; iSCSI and SCSI; SCSI and iSCSI; Fibre Channel and Infiniband; Infiniband and Fibre Channel; iSCSI and ATA; ATA and iSCSI; iSCSI and SATA; Serial ATA and iSCSI; Fibre Channel and Serial Attached SCSI; Serial Attached SCSI and Fibre Channel; iSCSI and Serial Attached SCSI; Serial Attached SCSI and iSCSI; Fibre Channel and ATA; ATA and Fibre Channel; Fibre Channel and SATA; SATA and Fibre Channel; Fibre Channel and Serial SCSI Architecture; Serial SCSI Architecture and Fibre Channel; Infiniband and Serial Attached SCSI; Serial Attached SCSI and Infiniband. Each transport medium, regardless of the data transport protocol by which it operates, can carry SCSI commands.","A buffer  provides memory work space and is connected to both controller  and to controller . A processing unit  is connected to controller , controller  and buffer . According to one embodiment of the present invention, processing unit  comprises one or more processors  for controlling operation of the storage router, handling address mapping and security access and converting commands between protocols and a computer readable medium  accessible by the processor storing a set of computer instructions  that are executable by the processor. According to other embodiments of the present invention buffer  and\/or computer readable medium  can be onboard processor .","In one implementation (not shown), the storage router can be a rack mount or free standing device with an internal power supply. The routing device can have a Fibre Channel and SCSI port, and a standard, detachable power cord can be used, the FC connector can be an optical Small Form Factor (\u201cSFF\u201d) connector, and the SCSI connector can be a VHDCI type. Additional modular jacks can be provided for a serial port and an 802.3 10BaseT port, i.e. twisted pair Ethernet, for management access. The SCSI port of the storage router can support SCSI direct and sequential access target devices and can support SCSI initiators, as well. The Fibre Channel port can interface to SCSI-3 FCP enabled devices and initiators or other Fibre Channel devices.","To accomplish its functionality, one implementation of the routing device uses: a Fibre Channel interface based on the Agilent XL2  Gb\/s Fibre Channel controller and an optical SFF transceiver; a PMCS RM7000A processor, incorporating independent data and program memory spaces, and associated logic required to implement a stand alone processing system; and a serial port for debug and system configuration. Further, this implementation includes a SCSI interface supporting Ultra-2 based on the SYMBIOS 53C8xx series SCSI controllers, and an operating system based upon the WIND RIVERS SYSTEMS VXWORKS kernel. In addition, the routing device can include software as required to control functions of the various elements, track commands, generate commands and provide appropriate translations between the FC and SCSI data transport protocols.",{"@attributes":{"id":"p-0041","num":"0040"},"figref":["FIG. 2B","FIG. 2A"],"b":["212","214","216","214","306"]},"Processing unit  processes the data in buffer  as represented by supervisor processing . This processing can include mapping between the first data transport protocol and the second data transport protocol, tracking commands and applying access controls and routing functions. A DMA interface  then pulls data from buffer  and places it into a buffer . A second protocol unit  pulls data from buffer  and communicates the data on the second transport medium (e.g., the SCSI bus). Data flow in the reverse direction, from the second data transport medium to the first data transport medium, can be accomplished in a reverse manner. Processing unit  can be operable to execute a tracking program that can assign commands arriving at routing device  a unique identification and record status information for the commands for each data transport protocol.","It should be noted that while the tracking program, in the above example, is discussed as a single program, the tracking program can be code that is distributed among the various programs utilized by the routing device. Using the example of a fibre channel-to-SCSI router, some portions of the tracking program may be implemented as part of the software drivers for the fibre channel interface while other portions of the tracking portion may be implemented as part of the software drivers for the SCSI interface. Thus, it should be understood that the functionality of the tracking program can be implemented according to any suitable software architecture.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 3","FIG. 3"],"b":["302","304","306","308","310","302","312","314","316","308","302","314","302","304","302","312","302","312","0","4","306","314"]},"First data transport medium  and second data transport medium  can operate according to the same or different data transport protocols. When routing device  receives the command, the routing device determines, at first protocol layer , if there is a SCSI command and, if so, can pass the SCSI command to the routing layer  for further processing. The routing device, at routing layer , can route the command from one data transport protocol to another data transport protocol. For example, the routing device can map a command received from a fibre channel host to a SCSI target device. It can also check for reservation conflicts, unit attentions and other issues that may affect passing the command to device . Finally, routing device , at second protocol layer , can send the command to device  via the second data transport medium.","In the reverse direction, routing device  can receive a response to the command (e.g., at protocol layer ), route the response from the data transport protocol supported by target device  to the data transport protocol supported by the host (e.g., can map a response sent according to a SCSI data transport protocol to a fibre channel response) (e.g., at routing layer ) and can send the response back to the host (e.g., at protocol layer ).","Thus, in the example of , a SCSI command is issued from host  to target device . The data transport protocol used to transmit the command and the data transport protocol by which target device  communicates with routing device  may be the same or different. Routing layer  handles transmission of information across protocol layers (e.g., between protocol layer  and protocol layer ). In addition, routing layer  can check for router events that will prevent the completion of the command such as reservation conflicts, unit attentions and other events.","As a command and its responses are processed by the host, routing device or target device, the state of the command changes. These state changes can be recorded. If, for example, a WRITE command is received, the state information can include receipt of the command, a request for the data to write, receipt of the data to write, command sent to target device  and command completion. Other SCSI commands have similar common state changes that are understood by those of skill in the art. According to one embodiment of the present invention, routing device  can record the state change information for a command on a protocol-by-protocol basis. Thus, for each data transport protocol, the state information can be tracked to determine what happens to commands that are received from initiators attached via that data transport protocol and to commands addressed to devices attached by that data transport protocol.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 4"},"Again, for explanatory purposes, the example of tracking SCSI commands is used. When information received by routing device  from host  is determined to include a SCSI command, a unique identifier for the SCSI command is generated. The unique identifier (Unique ID) can be used to track a command through processing by routing device . This Unique ID is generated based, for example, on the protocol, port and a counter. The counter is maintained by the tracking program and increments across a 24-bit value for each call to the routine:\n\n","The Unique ID is used to track the command and will be passed through the system, from protocol layer to protocol layer within the protocol specific structures. For example, in the case of a fibre channel-to-SCSI router, the Unique ID value can be entered into the fcp_cmd structure in protocol layer , passed across the routing layer (e.g., routing layer , not shown for simplicity) using remote method invocation (\u201cRMI\u201d) (e.g., can be passed to routing layer  using an RMI Packet) and then inserted into the pTask on the SCSI side by protocol layer . In this manner, the same Unique ID can be used for tracking the SCSI command on the fibre channel side of the routing device and the SCSI side of the routing device. Typically, the getUniqueID routine would only need to be called by routing device  when first receiving a command from the initiator. The same Unique ID can then be used at both the initiator and target side of routing device . However, in the case of some of the internal routing device commands, it may be clearer to only track the command for the host or target device to which the command is sent. In this case the Unique ID can be requested just before recording the sending of a router generated command to host  or target device .","When a Unique ID is assigned to a command the command can be tracked throughout routing device . Tracking can be performed for example through the use of multiple tables. In the embodiment of , four tables are illustrated, a first protocol table for tracking commands issued by an attached initiator (table ) connected to routing device , a first protocol table for tracking commands sent to an attached device (table ), a second protocol table to track commands issued by an initiator (table ) and a second protocol table to track commands received from an attached device (table ). Tables  and  thus respectively track commands received from and sent to devices attached to routing device  via first data transport medium  while tables  and  respectively track commands received from and sent to devices attached to routing device  via second data transport medium . It should be noted that a particular table can store commands associated with multiple devices or may correspond to a specific device. Thus, for example, table  can store command tracking information for all hosts attached to routing device  via data transport medium  or may be specific to host .","According to the embodiment of , the tables for each data transport protocol are maintained by the corresponding protocol layer; protocol layer  maintains table  and table  while protocol layer  maintains table  and table . Each table can include information that indicates changes in the state of a command. State changes for a command are recorded in the appropriate table to indicate the state of a command has changed. Along with the change in state, ancillary data such as system time, SCSI status, sense data, msgOutbytes, amount of data received and other data related to commands and system information can be recorded. The tables can be constructed in a manner that allows for quick access. For example, protocol layer  can index table  using the active initiator identification (e.g., s_id for fibre channel) and protocol layer  can index table  use a target identification (e.g., bus and target ID for SCSI or target IP address for iSCSI).","Protocol table , for example, can include state information related to commands that are received via first data transport medium . The information in the tables can be updated by the protocol layer that maintains the table. For state changes generated at the routing device, routing layer  can pass state change information to the appropriate protocol layer and that protocol layer can update the appropriate table entry. Examples of state information that can be generated at routing device  include busy\/queue full, reservation conflict, unit attention and other state change information known in the art.","As an example of recording state change information, if a WRITE command is received from host  destined for target device , protocol layer  can assign the command a Unique ID and record the receipt of the WRITE command in table . The receipt of the command is a change in state as, previously, the command had not been received. In addition to the fact that the command was received, system information, such as system time can be recorded in table . Protocol layer  can pass the command and Unique ID to routing layer . Routing layer  can map WRITE command to the appropriate target device using, for example, fibre channel-to-SCSI addressing techniques known in the art. If routing device  is aware of a unit attention at target device , a persistent key reservation at target device  for another host, or other state that would affect processing of the WRITE command, routing layer  can pass this information along with the Unique ID back to protocol layer  and protocol layer  can update the entry for the WRITE command in table  to reflect the change in state (i.e., to reflect the fact that the command could not be completed because of the unit attention or persistent key reservation). If the WRITE command can be sent to target device , routing layer  can pass the command and Unique ID to protocol layer  which can forward the command to target device  on the second data transport medium. Protocol layer  can record the fact that the command was sent to target device  in table .","As the state of the WRITE command changes or additional state information is generated, the state information can be recorded in the appropriate table. For example, protocol layer  can record in table  state information indicating that routing device  sent request for data corresponding to the WRITE to host , state information indicating receipt of the data from host  and state information indicating that routing device  forwarded a command complete message to host . Protocol layer  can record in table  state information indicating when routing device  sends data corresponding to the WRITE command to target device  and state information indicating when routing device  receives the command complete from target device . The state information recorded for each command can be a matter of implementation. For example, in the case of a WRITE command, additional state information can be recorded such as the receipt of transfer ready messages from target device  and other state information.","Table 1 provides an example of various parameters that can be entered to record state information for a command.",{"@attributes":{"id":"p-0058","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":[{"entry":[{},"TABLE 1"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Parameter","Description"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"U32 uniqueID","Unique identification assigned to the"]},{"entry":[{},{},"command."]},{"entry":[{},"U32 targetLun","Lun to which command is directed. This"]},{"entry":[{},{},"can be a fibre channel LUN for fibre"]},{"entry":[{},{},"channel devices or a bus\/target\/LUN for"]},{"entry":[{},{},"SCSI devices."]},{"entry":[{},"u32 hostID","Identification of host that sent the"]},{"entry":[{},{},"command."]},{"entry":[{},"u32 msgOut","Indication of message out."]},{"entry":[{},"u8 cdb[16]","Command descriptor block of the SCSI"]},{"entry":[{},{},"command being tracked."]},{"entry":[{},"u8 state","State of the command. Example states"]},{"entry":[{},{},"are described in Table 2."]},{"entry":[{},"u8 flags","Includes a flag if the command is handled"]},{"entry":[{},{},"by the routing device."]},{"entry":[{},"u32 response","Includes responses to the command sent"]},{"entry":[{},{},"to the host such as SCSI status messages,"]},{"entry":[{},{},"sense key\/ASC\/ASCQ and other response"]},{"entry":[{},{},"messages."]},{"entry":[{},"u32 origSysTime","Date and time of entry of command to"]},{"entry":[{},{},"routing device"]},{"entry":[{},"u32 systemTime","Date and time of last update for the"]},{"entry":[{},{},"command."]},{"entry":[{},"u32 subState","Substates for a given state. A listing of"]},{"entry":[{},{},"example SCSI substates and fibre channel"]},{"entry":[{},{},"substates is provided below."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The parameters provided in Table 1 are provided by way of example and other parameters can be stored for each command. Table 2 includes an example list of states that can be tracked for a command.",{"@attributes":{"id":"p-0060","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}},{"entry":["Parameter","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["DCS_RCVD = 1,","Command just received."]},{"entry":["DCS_RCVD_PHASE","SCSI cmd substate change."]},{"entry":["DCS_WAIT_DATA,","Routing device to get data from host."]},{"entry":["DCS_BLOCKED","Set to forward command, but target device"]},{"entry":[{},"busy."]},{"entry":["DCS_GOTDATA_AWAIT,","Routing devices has received all the data,"]},{"entry":[{},"waiting to go to next state."]},{"entry":["DCS_GOTSOMEDATA","Routing device has received some but not"]},{"entry":[{},"all of the data."]},{"entry":["DCS_ISSUED","Command issued to target device via RMI"]},{"entry":[{},"or driver."]},{"entry":["DCS_ISSUED_PHASE","Command at target drive and SCSI"]},{"entry":[{},"substate change."]},{"entry":["DCS_DONE_INTERNAL","Command completed by router, not"]},{"entry":[{},"device."]},{"entry":["DCS_DONE","Command completed by target device."]},{"entry":["DCS_NOTSURE","Possible spoof state."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The states of table 2 provide examples of states that can exist at a target drive and are not limiting of the present invention. It should be understood that other states and information can be recorded for a command.","As described above, when a command is received from an initiator, routing device  creates an entry for that initiator in the appropriate table. For example, if routing device receives a command from host , routing device  can create a table entry for the command in table . This can be done, for example, by calling a AddCmdInfoElt routine. If a table does not exist into which information for host  can be entered, the AddCmdInfoElt routine can create a table. An example call for the AddCmdInfoElt routine is:\n\n","This routine will create a new entry for the command just received using the UniqueID for tracking the command through the system. Besides the UniqueID, the input parameters for one embodiment of the present invention are: route, initiatorID, targetLun, and CDB. These are stored in a new entry in the appropriate initiator table. The routine can add the origination systemTime for when the entry was received and set the state indicating the command was received. The route can be used during the display process (described below) to obtain information about the initiator to help the user understand where the command originated.","Whenever routing device  detects a state change for the command, the state information for the command can be updated by the appropriate protocol layer. For example, when routing device  determines that it has received all the data associated with a WRITE command from host , protocol layer  can update the state information for the WRITE command in table  indicating that it got all the data and is waiting to further process the command. Updating the state information for a command can be done using, for example, an UpdateCmdInfoElt routine:\n\n","This routine will update the systemTime to the current time. The state will be changed to reflect the changed state. Finally, the msgOut, response or subState may be updated, depending on the state change entered. Each of these, according to one embodiment, is a 32-bit value that can be passed to the routine as the \u201cu32 value\u201d.","Similarly, for each target device, routing device  can record state information for commands that were sent to that target device. For example, if routing device  forwards the WRITE command of the previous example to target device , routing device  can make a table entry for the WRITE command in table . For each command, state information indicating what happened to the command (e.g., did it complete normally, was all the data transferred or other state information) can be recorded.","Whenever it is detected that a command is to go to a device, the appropriate protocol layer can create an entry for the command. This can be done, for example, by calling an AddDevInfoElt routine. If there is not yet a table into which information for the target device can be entered, the AddDevInfo routine can create one. An example call for the AddDevInfoElt routine is:\n\n","This routine will create a new entry for the SCSI command. The input parameters, according to one embodiment, are: UniqueID, route, targetLun, and CDB. These are stored into a new entry in the appropriate table. The routine will add the origination systemTime for when the entry was received and set the state to indicate that the command has been sent. The protocol layer sending the command to the target device (e.g., protocol layer ) may not know the initiatorID as this information may not be passed from the protocol layer that received the command from the host (e.g., protocol layer ) across routing layer . However, because the UniqueID is used, state information for the same command can be located in the host-side tables and the target-side tables.","Whenever a state change for an existing command that has been sent to a target device is detected, the routing device can update the table entry for the command (e.g., the table entry in table ) by calling, for example, an UpdateDevInfoElt routine. One example of a call to the UpdateDevInfoElt routine is:\n\n","This routine will update the systemTime to the current time. The state will be changed to reflect the changed state of the command. Finally, the msgOut, response or subState may be updated, depending on the state change entered. Each of these can be a 32-bit value that can be passed to the routine in the fourth parameter.","In addition to tracking commands received from initiators and passed to target devices, routing device  can generate commands or handle commands internally. These commands can also be tracked. For example, if routing device  handles a command received from host , the fact that the command was handled by routing device  can be entered in the state information for the command in table . Similarly, if routing device  generates a command that is sent to target device , state information for the command can be entered in table . Routing device  can additionally track other information that may be helpful in diagnosing error conditions. For example, routing device  can track whether the initiator (e.g., host ) performed any error recovery or sent tracking messages.","Additionally, embodiments of the present invention can track task management commands. Although task management commands are valid SCSI commands that can be tracked, they are not received in quite the same fashion and as such may require special handling to capture and display their occurrences. One way to do this is to use a \u201cfake\u201d CDB to record the task management command, since there isn't a real CDB that is transmitted with a task management command. This can be used for both the tracking and display to allow the user to see the non-standard command and see how it may have affected the operation in progress.","Information can also be recorded to tell the current state of a spoofed write (such as sent response not to drive yet, got data and started at drive and response sent, etc), as well as information to determine what happened to commands that were at a target drive and were to be terminated early (e.g., ABTS received but the command was completed at the drive anyway).","In addition to the commands, many other messages may flow across a data transport medium. While this information can data transport protocol specific, it can be useful for determining how far a command has progressed. Also, this information can reflect changes in the state of a command. This sub-state data can be tracked at the driver layer for each protocol layer and can be recorded in the table entry for the initiator or target device, if it is identifiable as being that specific, or elsewhere in the tables. This data, according to one embodiment of the present invention, can be correlated with the other command information when a display request is received from a user.","The sub-state information can be added to the appropriate table using the routines described above. Most of the SCSI protocol low-level states will directly affect one command and will be placed into the proper entry. A few, like a Bus Reset, affect all commands on that port. However, most of the FC low-level states are link service commands, which typically affect the state of the FC link and so most of the commands received or sent over particular ports. A few, like a REC, will affect a particular command, and the appropriate table entry can be updated. Those that affect multiple commands will be entered, according to one embodiment, as new commands using a targetLun of \u22121. This will allow the display software to mark these as potentially affecting multiple commands.","Below is a sample list of low level or sub-states for the SCSI data transport protocol that can be recorded:\n\n","For the Fibre Channel protocol, the low level states can arise from the BLS and ELS commands as would be understood by those in the art. Below is a sample listing of codes for the fibre channel low level states and their ASCII names. The elsCode is used in the table entries to represent the low level states and the elsNames can be used for display of those codes.","Example elsNames, as would be understood by those in the art include:","\u201cLSRJT\u201d, \u201cACC\u201d, \u201cPLOGI\u201d, \u201cFLOGI\u201d, \u201cLOGO\u201d, \u201cABTX\u201d, \u201cRCS\u201d, \u201cRES\u201d, \u201cRSS\u201d, \u201cRSI\u201d, \u201cESTS\u201d, \u201cESTC\u201d, \u201cADVC\u201d, \u201cRTV\u201d, \u201cRLS\u201d, \u201cECHO\u201d, \u201cTEST\u201d, \u201cRRQ\u201d, \u201cREC\u201d, \u201cSRR\u201d, \u201cPRLI\u201d, \u201cPR LO\u201d, \u201cSCN\u201d, \u201cTPLS\u201d, \u201cTPRLO\u201d, \u201cLCLM\u201d, \u201cGAID\u201d, \u201cFACT\u201d, \u201cFDACT\u201d, \u201cNACT\u201d, \u201cNDACT\u201d, \u201cQoSR\u201d, \u201cRVCS\u201d, \u201cPDISC\u201d, \u201cFDISC\u201d, \u201cADISC\u201d, \u201cRNC\u201d, \u201cF-REQ\u201d, \u201cFRPLY\u201d, \u201cRPS\u201d, \u201cRPL\u201d, \u201cFAN\u201d, \u201cRSCN\u201d, \u201cSCR\u201d, \u201cRNFT\u201d, \u201cCSR\u201d, \u201cCSU\u201d, \u201cLINIT\u201d, \u201cLPC\u201d, \u201cLSTS\u201d, \u201cRTIN\u201d, \u201cRNID\u201d, \u201cRLIR\u201d, \u201cLIRR\u201d, \u201cSRL\u201d, \u201cSBRP\u201d, \u201cRPSC\u201d, \u201cUNKWN\u201d};","The corresponding elsCodes are:","0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x30, 0x31, 0x32, 0x33, 0x34, 0x40, 0x41, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x60, 0x61, 0x62, 0x63, 0x68, 0x69, 0x70, 0x71, 0x72, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D.","Again, this information can be added to the table through the last parameter of theUpdateDevInfoElt or AddDevInfoElt routines. It should be noted that the SCSI and fibre channel low level states provided above are provided by way of example and other low-level states that affect the success of a command can be recorded.","Thus, the routing device can receive a command, assign the command a Unique ID and record state information for the command in one or more tables. The state information can be associated with the Unique ID for the command in the tables. The state information can include any information that indicates the progress of a command and can include sub-state information. Each table that stores the state information for the command can correspond to a particular data transport protocol and further to a particular device on that data transport protocol.","The tables used, according to one embodiment of the present invention, are not static tables that are constructed at compile or boot time, but are allocated dynamically as they are needed. This allows for using only the amount of memory needed for the number of initiators and devices in use. A table for any given host or target device can be created the first time that a command to or from that host or target device is encountered. For a single command, multiple tables may be generated, depending on whether the command proceeds from the routing device to a target device, or is handled internally by the routing device. According to one embodiment of the present invention, if, at any time, the routing device is unable to allocate the table it needs, routing device  can generate an indication that there is insufficient memory to track the command. The first time this happens routing device  can put an entry in an event log to make sure that this event is noted for later analysis and\/or debug. According to one embodiment, it is not necessary to preserve the command tracking information across reboots of the routing device. Thus, no form of non-volatile memory (flash, NVRAM, etc.) is necessary for this function. Routing device  can also provide the option to allow a user to clear the tables at any time.","According to one embodiment of the present invention, if a state for a command arises that may be an item of note or be a precursor to an issue, the information for the command can be placed into a locked state to preserve that information for later review. This, according to one embodiment, copies not only the state information for the command in question, but also some number of commands before it to show what may have led up to the issue. This way the user can look back at the last series of commands for a given device. Embodiments of the present invention can include rules for locking commands so that normal expected states are not locked. For example, an embodiment of the present invention can automatically lock on non-zero statuses, except for Unit Attention and possibly expected tape conditions like EOT, EOM or ILI. This way it can capture real conditions, but not fill the lock sets with normal expected states.","The command tracking information can be accessed by a user through, for example, a graphical user interface.  illustrate various embodiments of screens that can be presented to a user to display command tracking information. Presentation layer applications (e.g., HTTP applications, Async\\Telnet and other applications known in the art) at the routing device can receive requests to display the command tracking information. According to one embodiment, the information may be displayed based on the initiators (e.g., hosts) or target devices. Additionally, information from the host-side and target device-side can be correlated together.",{"@attributes":{"id":"p-0087","num":"0120"},"figref":["FIG. 5A","FIGS. 5B and 5C","FIG. 5B","FIG. 5C","FIG. 5C"],"b":["500","502","504","506","508","510","520","5","530"]},"Although the present invention has been described in detail herein with reference to the illustrated embodiments, it should be understood that the description is by way of example only and is not to be construed in a limiting sense. It is to be further understood, therefore, that numerous changes in the details of the embodiment of this invention and additional embodiments of this invention will be apparent, and may be made by, persons of ordinary skill in the art having reference to this description. It is contemplated that all such changes and additional embodiments are within scope of the invention as claimed below."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE FIGURES","p":["A more complete understanding of the present invention and the advantages thereof may be acquired by referring to the following description, taken in conjunction with the accompanying drawings in which like reference numbers indicate like features and wherein:",{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 2A and 2B"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIGS. 5A-5C"}]},"DETDESC":[{},{}]}
