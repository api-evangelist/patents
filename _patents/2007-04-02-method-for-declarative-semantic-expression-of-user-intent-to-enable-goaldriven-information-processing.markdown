---
title: Method for declarative semantic expression of user intent to enable goal-driven information processing
abstract: A method for constructing a processing request so that an information processing application satisfying the processing request can be assembled, includes: inputting a processing request, wherein the processing request includes a goal that is represented by a graph pattern that semantically describes a desired processing outcome; and assembling a processing graph that includes at least one component that satisfies the desired processing outcome, wherein the processing graph is assembled by associating the graph pattern that semantically describes the desired processing outcome with a graph pattern that semantically describes an applicability condition of the at least one component or a graph pattern that semantically describes an inclusion effect of the at least one component.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08307372&OS=08307372&RS=08307372
owner: International Business Machines Corporation
number: 08307372
owner_city: Armonk
owner_country: US
publication_date: 20070402
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"heading":["GOVERNMENT INTERESTS","RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF EXEMPLARY EMBODIMENTS"],"p":["This invention was made with Government support under Contract No.: H98230-05-3-0001 awarded by the U.S. Department of Defense. The Government has certain rights in this invention.","This application is related to: commonly assigned U.S. application entitled \u201cMETHOD AND SYSTEM FOR ASSEMBLING INFORMATION PROCESSING APPLICATIONS BASED ON DECLARATIVE SEMANTIC SPECIFICATIONS\u201d, Ser. No. 11\/695,238, filed concurrently herewith and incorporated by reference herein in its entirety; commonly assigned U.S. application entitled \u201cMETHOD AND SYSTEM FOR AUTOMATICALLY ASSEMBLING STREAM PROCESSING GRAPHS IN STREAM PROCESSING SYSTEMS\u201d, Ser. No. 11\/695,487, filed concurrently herewith and incorporated by reference herein in its entirety; commonly assigned U.S. application entitled \u201cMETHOD FOR SEMANTIC MODELING OF STREAM PROCESSING COMPONENTS TO ENABLE AUTOMATIC APPLICATION COMPOSITION\u201d, Ser. No. 11\/695,457, filed concurrently herewith and incorporated by reference herein in its entirety; commonly assigned U.S. application entitled \u201cMETHOD FOR DECLARATIVE SEMANTIC EXPRESSION OF USER INTENT TO ENABLE GOAL-DRIVEN STREAM PROCESSING\u201d, Ser. No. 11\/695,430, filed concurrently herewith and incorporated by reference herein in its entirety, commonly assigned U.S. application entitled \u201cMETHOD AND SYSTEM FOR AUTOMATICALLY ASSEMBLING PROCESSING GRAPHS IN INFORMATION PROCESSING SYSTEMS\u201d, Ser. No. 11\/695,349, filed concurrently herewith and incorporated by reference herein in its entirety; commonly assigned U.S. application entitled \u201cMETHOD FOR MODELING COMPONENTS OF AN INFORMATION PROCESSING APPLICATION USING SEMANTIC GRAPH TRANSFORMATIONS\u201dSer. No. 11\/695,311, filed concurrently herewith and incorporated by reference herein in its entirety; and commonly assigned U.S. application entitled \u201cMETHOD AND SYSTEM FOR COMPOSING STREAM PROCESSING APPLICATIONS ACCORDING TO A SEMANTIC DESCRIPTION OF A PROCESSING GOAL\u201dSer. No. 11\/695,410, filed concurrently herewith and incorporated by reference herein in its entirety.","1. Technical Field","The present invention relates to constructing declarative descriptions of information processing requests, and more particularly, to a method for declarative semantic expression of user intent to enable goal-driven information processing.","2. Discussion of the Related Art","Generally, software applications achieve a desired processing outcome at the request of a person or agent by using a collection of reusable software components assembled to achieve the outcome. When a request must be accommodated and no suitable application exists, the requester can cobble together a solution by collecting partial solutions from existing applications, doing some additional manual work to complete the task. However, new or adapted applications are generally needed; thus, requiring the initiation of a human process to accumulate application requirements and to develop\/adapt\/assemble applications that can achieve the desired outcome. A challenge arises in understanding the processing request, understanding the components that might achieve the desired outcome, and knowing how to build and\/or assemble the components to achieve the processing outcome and fulfill the request.","Expressing desired processing outcomes directly as computer programs coded using general-purpose languages such as C++ or Java generally requires long development cycles and imposes high maintenance costs for any new type or variant of information processing outcome. Casting such requests as traditional queries can reduce some of the costs and delays by providing a simpler means of expressing and applying complex data transformations, etc. However, these query-oriented approaches do not offer sufficient coverage for a wide variety of requests involving non-query goals or requests for outcomes involving operations on unstructured data (e.g., speech-to-text and image recognition operations), nor are they resilient in the face of modifications to underlying conceptual schemas.","Both of the programming approaches and the query approaches suffer from an absence of an explicitly declared intent. In other words, they do not explicitly denote the intent of the outcome requested, with instead the intent being implicit and often only present in the minds of software developers. Thus, any adjustments to either the requested outcome or the underlying conceptual schemas can become challenging and costly, often requiring developers to \u201creverse engineer\u201d existing applications in an attempt to harvest the original intent in order to adapt to the modifications.","Further, in such approaches, the requester of the processing outcome must generally know some potentially large amount of detail as to the means of fulfilling the request. For example, programmers need to know specific steps to be taken and query writers need to know the structure of tables and the details of the operation composition to produce just one approach, representing only one approach to fulfilling the request. If there are many possible means of satisfying a request, the users must also know which way is best, under what circumstances, and the circumstances under which their solutions are to be used.","In an exemplary embodiment of the present invention, a method for constructing a processing request so that an information processing application satisfying the processing request can be assembled, comprises: inputting a processing request, wherein the processing request includes a goal that is represented by a graph pattern that semantically describes a desired processing outcome; and assembling a processing graph that includes at least one component that satisfies the desired processing outcome, wherein the processing graph is assembled by associating the graph pattern that semantically describes the desired processing outcome with a graph pattern that semantically describes an applicability condition of the at least one component or a graph pattern that semantically describes an inclusion effect of the at least one component.","The processing request is encoded in a request specification language.","The goal is a goal that requests production of data, a goal that requests an update of retained state information, a goal that requests installation of a component or a goal that requests removal of a component.","The method farther comprises: deploying an information processing application embodying the at least one component of the processing graph; and operating the information processing application.","Result data is produced when operating the information processing application. The result data is an end result of the operated information processing application or an intermediate result of the operated information processing application, wherein the intermediate result is an inclusion effect of the at least one component of the processing graph.","When the goal is a goal that requests the production of data, the result data includes an element that is a requested data item. The element is expressed as a variable. The element is defined in a where clause. The where clause explicitly references the variable. The where clause includes an assertion that constrains a type of data item acceptable as an element. The assertion refers to a class description in an ontology.","When the goal is a goal that requests the production of data, the processing request further includes a disposition that semantically describes a means of handling the result data. The disposition includes a condition expression that defines a condition under which the disposition is to occur. The condition expression is a Boolean expression. The disposition indicates that the result data is to be conveyed to a network destination, the result data is to be retained for further processing, the result data is available for retrieval or the result data is to be conveyed to an external data store.","The processing request further includes a constraint that is represented by a graph pattern that semantically describes constraints on the assembly of the processing graph. The constraint establishes a preference on the inclusion of an algorithm or a component that is to be included in the processing graph or the interconnection of components in the processing graph. The constraint is a hard constraint or a soft constraint.","The processing request further includes an outcome response that is represented by a graph pattern that semantically describes an action to be taken upon achievement of the desired processing outcome. The outcome response includes a condition under which the action is to be taken.","When the goal is a goal that requests the production of data, the graph pattern that semantically describes an action to be taken upon achievement of the desired processing outcome further describes a means of handling result data that is produced when operating an information processing application embodying the at least one component after the information processing application has been deployed.","The applicability condition of the component is a semantic description of criteria that must be satisfied in order to include the component into the processing graph.","The inclusion effect of the component is a semantic description of an effect of including the component in the processing graph.","In an exemplary embodiment of the present invention, a system for constructing a processing request so that an information processing application satisfying the processing request can be assembled, comprises: a memory device for storing a program; a processor in communication with the memory device, the processor operative with the program to: receive and compile a processing request, wherein the processing request includes a goal that: is represented by a graph pattern that semantically describes a desired processing outcome; and assemble a processing graph that includes at least one component that satisfies the desired processing outcome, wherein the processing graph is assembled by associating the graph pattern that semantically describes the desired processing outcome with a graph pattern that semantically describes an applicability condition of the at least one component or a graph pattern that semantically describes an inclusion effect of the at least one component.","In an exemplary embodiment of the present invention, a computer program product comprising a computer useable medium having computer program logic recorded thereon for constructing a processing request so that an information processing application satisfying the processing request can be assembled, the computer program logic comprises: program code for receiving and compiling a processing request, wherein the processing request includes a goal that is represented by a graph pattern that semantically describes a desired processing outcome; and program code for assembling a processing graph that includes at least one component that satisfies the desired processing outcome, wherein the processing graph is assembled by associating the graph pattern that semantically describes the desired processing outcome with a graph pattern that semantically describes an applicability condition of the at least one component or a graph pattern that semantically describes an inclusion effect of the at least one component.","The foregoing features are of representative embodiments and are presented to assist in understanding the invention. It should be understood that they are not intended to be considered limitations on the invention as defined by the claims, or limitations on equivalents to the claims. Therefore, this summary of features should not be considered dispositive in determining equivalents. Additional features of the invention will become apparent in the following description, from the drawings and from the claims.","In accordance with an exemplary embodiment of the present invention, a method for conveying to an information system a user's desired outcome of one or more processing requests using semantic descriptions of processing goals plus semantically described constraints on potential solutions is provided. The corresponding semantic descriptions, when specified according to the method and interpreted in the presence of semantically described processing components, are used by a planner\/compiler to automatically assemble a processing graph to fulfill the request.","In this embodiment, semantic graph patterns are used to convey the desired processing outcomes such as goals, and constraints on the means by which the outcomes are pursued. In this manner, the goals and constraints prepared by the user do not convey the mechanism by which the request is to be satisfied, nor do they convey the operators to be applied to produce a result. This allows the compilation mechanism the freedom and flexibility to select from many alternative data sources and processing methods best suited to the computational resources at the time of the request. In this way, information processing components not envisioned by the user can be applied, thus potentially providing a higher quality outcome such as an outcome that consumes fewer computational resources or that satisfies any of a number of desired processing characteristics, than can be selected by the user.","It is to be understood that since a predominant type of processing request for software systems is the production of information, the following description of exemplary embodiments of the present invention will focus on how the method is used to describe information production requests and on how the method is used to automatically assemble processing graphs producing the requested information. However, since other types of outcomes, for example, the modification of stored data or the initiation of a process, are also in the realm of desired processing outcomes, several other types of information processing goals are envisioned for use with the present invention. Further, since the set of all processing outcomes is never completely known, the method provides a means of extending the set of defined outcomes as well as a means of extending the set of constraints that may be imposed on the solutions.","In accordance with another exemplary embodiment of the present invention, a method for semantically describing software components, which can be dynamically added to a system embodying the present invention is provided. In accordance with yet another exemplary embodiment of the present invention, a method and system for processing all of these descriptions by using a planner\/compiler is provided. Here, the planner\/compiler interprets the desired outcomes, the descriptions of candidate data sources and processing methods, and produces one or more information processing applications believed to be responsive to the semantically expressed intent.","Since a processing graph will be referred to when describing exemplary embodiments of the present invention, a brief description of a processing graph will now be provided.","Processing Graph","A processing request is a semantically expressed request for processing to be performed by a suitable processing application. Typically, such requests are for the production of information, but other types of outcomes are possible.","Applications that process these requests are viewed as compositions of reusable software components. The compositions are referred to as processing graphs, with the nodes being the various software components, interconnected by arcs connecting inclusion effects, which are typically output data productions, to applicability conditions, which are typically input data requirements.","For a given processing request, a collection of data sources  and components  can be configured into a processing graph  that can achieve the request's goal (see ).","A single processing graph might draw from one or more data sources, and may perform any type of processing. For example, a dataflow processing graph may filter, transform, aggregate, correlate, etc., data to provide the desired result data. Consider, a stock prediction model (isolating the top thread in ) that draws upon a single Trades data input and applies a Trade Analytics component and a Stock Price Predictor component to produce a single Stock Price Prediction. In order to improve the accuracy of the prediction, the application may analyze data from Trades, TV News and Radio sources, as shown in , with the Stock Price Predictor component basing a prediction on feeds from each of the analytic chains, each conveying some information about the company in question.","A description of the exemplary embodiments of the present invention will now be provided in the following order: Specification of Processing Requests; Modeling Components using Semantic Graph Transformations; and Method and System for Automatic Composition of Information Processing Applications.","Specification of Processing Requests","Users convey to a system embodying the present invention their desired processing outcomes via processing requests. Processing requests are expressed via request specifications encoded in a request specification language. The request specification language is a machine-interpretable encoding of the request. The specific encoding format is not important, so long as the requisite elements are described and conveyed, with enough formal, machine-interpretable descriptive content, so that they can be interpreted by a request compiler\/planner. When feasible, the compiler automatically assembles an application believed capable of achieving the processing outcome conveyed in the request specification.","A request specification is a declarative semantic expression of the desired effects of running a software application and the constraints under which the application is assembled. Request specifications carry the least amount of description needed to convey intent, without unnecessary detail of how the request is to be carried out. A request specification can be automatically transformed by a request compiler into an application that is represented as a processing graph.","Request specifications are built from semantic graph expressions, which are to be evaluated according to a semantic model of the concepts from a domain or domains of interest. Request specifications use terms that are formally defined in domain ontologies captured, for example, in a language such as Web Ontology Language-Description Logic (OWL-DL), W3C Rec. 10 Feb. 2004, a copy of which is incorporated by reference herein in its entirety. These domain ontologies contain formal models of the user's problem domain. In addition, there are system ontologies that contain formal functional descriptions of processing components. With terms defined in a formal logic, automated reasoners can be employed to match the request goals to component capabilities by using inference where necessary to apply domain-independent components to the task of producing domain-specific results.","Request specifications are authored by a user or some user agent and convey, at the very least, an expression of the user's goal for the request, for example, the goal of producing a notification that a particular company's stock value is anticipated to change by an amount greater than 5% of its current value, or non-information-production goals such as the goal of having a piece of software installed or having a particular device configured. The request specification may also contain constraints on how that goal is to be achieved, for example, to avoid the use of video surveillance cameras as data sources or to favor the use of K-means clustering algorithms.","The goals, along with the accompanying constraints, are described and conveyed in such a way that they can be processed by a request compiler. The compiler is a specialized artificial intelligence (AI) planner that treats these constrained goal specifications as end effects, deriving them from the information needed to assemble suitable processing graphs.","Consider a simple request to watch for factors that might anticipate a significant change in a company's stock price. The request might be expressed informally as \u201cwatch for changes greater than 5 percent in the stock price of company Breakfast Foods Group (ticker symbol BFG).\u201d","BFG stock price prediction might be expressed as:",{"@attributes":{"id":"p-0052","num":"0051"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Request BFGStockActivityPrediction"]},{"entry":[{},"\u2003Produce"]},{"entry":[{},"\u2003\u2003Result"]},{"entry":[{},"\u2003\u2003\u2003With Elements"]},{"entry":[{},"\u2003\u2003\u2003\u2003?PredictedStockPrice,"]},{"entry":[{},"\u2003\u2003\u2003\u2003?PredictedPercentageChange"]},{"entry":[{},"\u2003\u2003Where"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"?Company","a BreakfastFoodsCompany ;"]},{"entry":[{},{},"hasTicker BFG ;"]},{"entry":[{},{},"hasStockPricePrediction ?Prediction ."]},{"entry":[{},"?Prediction","a :StockPricePrediction ;"]},{"entry":[{},{},"hasPredictedStockPrice ?PredictedStockPrice ;"]},{"entry":[{},{},"hasPercentChange ?PredictedPercentageChange ."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"?PredictedStockPrice"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"a :MonetaryAmount ."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"?PredictedPercentageChange"]},{"entry":[{},"\u2003\u2003a :PercentChange ."]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}]}}},"The request \u201cBFG Stock Activity Prediction\u201d has one goal, that is, to produce one result with two result elements, the variables ?PredictedStockPrice and ?PredictedPercentageChange.","The request is written with a domain ontology in mind (as shown, e.g., by a domain ontology fragment  in ), and states, that for a Breakfast Foods Company with Ticker symbol BFG, the elements ?PredictedStockPrice and ?PredictedPercentageChange are part of a ?Prediction associated with the company.","Produce goals optionally describe result disposition specifications, which are descriptions of what to do with the resulting data. Some result data is surfaced for further processing, some retained for later reference, some for export to external stores (database (DB), knowledgebase (KB), . . . ), and some for external reference, for example, via notification.","Results can be dealt with in a number of ways according to a set of disposition instructions (e.g., to notify some interested person or their agent of the result, to persist the result for some specified amount of time, or to send the result to some IP port on some remote host, etc.). Multiple dispositions can be expressed for each declared result, and any disposition can be conditionally applied.","Here, the result is persisted for one month (six months if the PredictedPercentageChange >=5 percentage points), and the inquirer will be notified via a default mechanism of any PredictedPercentageChange >=5 percentage points.",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Request BFGStockActivityPrediction"]},{"entry":[{},"\u2003Produce"]},{"entry":[{},"\u2003\u2003Result"]},{"entry":[{},"\u2003\u2003\u2003With Elements"]},{"entry":[{},"\u2003\u2003\u2003\u2003?PredictedStockPrice,"]},{"entry":[{},"\u2003\u2003\u2003\u2003?PredictedPercentageChange"]},{"entry":[{},"\u2003\u2003\u2003With Dispositions"]},{"entry":[{},"\u2003\u2003\u2003\u2003persist for 1 month,"]},{"entry":[{},"\u2003\u2003\u2003\u2003notify if ?PredictedPercentageChange >= 5,"]},{"entry":[{},"\u2003\u2003\u2003\u2003persist for 6 months"]},{"entry":[{},"\u2003\u2003if ?PredictedPercentageChange >= 5"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Note that the request shown above neither specifies nor constrains the components to be used in the processing graph. This approach favors discovery of components, for example, individual algorithms or processing subgraphs, in an attempt to avoid over-constrained specifications. User designation of components is optional; the absence of such designations enables the request compiler to identify sources and methods that users may not have been aware of, or that may produce higher quality results than those produced by user-specified sources and methods.","However, a request specification can include constraints regarding various plan elements. Constraints convey a requestor's instructions to Prefer, Avoid, etc., specified plan elements such as Data Sources, Methods, etc. These expressions provide indirect guidance to the compiler (as soft constraints) on the assembly of processing graphs. Say, for example, a custom developed algorithm for interpreting stock ticker data is strongly preferred, or the use of any surveillance video is to be avoided:",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"Request BFGStockActivityPrediction"},{"entry":"\u2003Produce"},{"entry":"\u2003\u2003. . ."},{"entry":"\u2003Prefer"},{"entry":"\u2003\u2003Method ?M"},{"entry":"\u2003\u2003\u2003Where"},{"entry":"\u2003\u2003\u2003\u2003?M implementsAlgorithm ProprietaryTradesAnalysisAlgorithm ."},{"entry":"\u2003\u2003DataSource ?STDFeed"},{"entry":"\u2003\u2003\u2003Where"},{"entry":"\u2003\u2003\u2003\u2003?STD produces StockTickerData ."},{"entry":"\u2003Avoid"},{"entry":"\u2003\u2003DataSource ?SVFeed"},{"entry":"\u2003\u2003\u2003Where"},{"entry":"\u2003?SVFeed produces SurveillanceVideo ."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Constraints can be either hard (e.g., absolute), or soft (e.g., preferences). Hard constraints specifically require or prohibit some element or property of the solution. Soft constraints provide less strict guidance as to the composition of the processing graph. The use of preferences rather than absolute designations allows for the discovery of better alternative solutions in the context of user preferences and is thus favored for this method. Using only soft constraints, the request specification can guide choices a compiler might make, requiring user knowledge only of the items to be constrained but not of how the processing graph is assembled. But, because hard constraints are sometimes required, the method also provides a means of expressing such constraints.","The ontology in this example defines a property of Company called hasStockPricePrediction with a range StockPricePrediction. This value of this property is not likely to be available from a data source. More likely, a combination of components capable of producing such a result would be needed to establish that relation and populate the remainder of the price prediction submodel, for example, the hasPredictedStockPrice and the hasPercentChange properties.","While subtle, this is a key element for operator extensibility. For example, rather than enriching a language with function calls accessing user-provided code modules, request specifications declaratively express the goal or goals of analysis via concepts and relations in the ontologies. So, rather than calling a function to perform a task, request specifications describe a result that can be achieved by assembling a processing graph that can produce the result. Thus, a goal-specified, declarative description is used, rather than a function invoked in a query expression. Further, instead of requiring the requester to describe the operations needed to calculate a ?PredictedPercentChange, some processing graph is automatically assembled to produce the result, composed from the needed operators, for example, the data sources and software components that jointly surface the requested data.","Request specifications can be expressed and conveyed in a textual form, as depicted in the BFG example above. Since request specifications are expected to be produced and consumed mostly by tools, the predominant representation is expected to be an XML encoding, conformant to an XML Schema, W3C Rec. 28 Oct. 2004, a copy of which is incorporated by reference herein in its entirety.","The processing request can further include an outcome response represented by a graph that semantically describes additional goals that are to be achieved upon the fulfillment of the processing request goal. In other words, the outcome response extends the processing request to include such other goals, which are to be pursued upon the achievement of the processing request goal. When the outcome response is included in the processing request, a generated processing graph must be assembled in a way such that, upon operation, the graph fulfills the goal of the processing request and also performs any additional specified outcome response goals.","Modeling Components Using Semantic Graph Transformations","For processing graph assembly to be automatable, machine-interpretable semantic descriptions of components' functional characteristics are needed. Here, the focus is on black-box descriptions of each component, providing semantic descriptions of the applicability conditions and inclusion effects of each component and the inclusion effects of each data source. Any machine-interpretable description of a component's functional capabilities can be considered, so long as there is a means by which those descriptions can be used by a planner\/compiler to create a suitable processing graph.","Applicability conditions and inclusion effects are modeled using semantic graph patterns. These graphs describe the criteria that determine the assembly of the processing graphs from among the complete set of graph elements (i.e., the data sources and software components). For a graph element to be included in a processing graph, its applicability condition must be met; these conditions are met by the inclusion effects of other elements. The graphs associated with a given component's applicability conditions describe constraints that must be satisfied in order for the components to work correctly. Hence, the descriptions are used to determine which other components, via their inclusion effects, can satisfy the inclusion criteria, forming the basis for automated assembly of processing graphs.","For an embodiment in which a request for the production of data is provided, the applicability conditions describe the availability of data for input to the component, and the inclusion effects are the production by the component of output data. More simply, the applicability conditions describe the component's inputs and the inclusion effects describe the component's outputs. The graphs associated with a given component's inputs describe constraints that any input data must satisfy in order for the component to work correctly. Hence, the descriptions are used to determine which other components can provide input data to the component, forming the basis for automated assembly of processing graphs.","These descriptions are represented using a semantic description technique, for example, OWL-DL. Reasoning at an expressivity similar to DL reasoning is essential in the graph assembly process, if any but the most trivial matching is to be pursued.","Representation of Semantic Descriptions","Semantic descriptions consist of processing component descriptions and descriptions of the conditions for applying the component and the effects of including the component in the graph. For data production graphs, the semantic descriptions consist of processing component descriptions of the data produced\/required by the components. Processing component descriptions are based on core concepts defined in the system ontologies, and the data descriptions are based on sets of domain and shared ontologies. The system ontologies define concepts such as DataSource, and SoftwareComponent, and the relations, produces, requires, and contains. Expressed below in RDF N3 format is an excerpt of an exemplary OWL representation:",{"@attributes":{"id":"p-0073","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"63pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},":DataSource","a","owl:Class ;"]},{"entry":[{},{},":produces",":Output ."]},{"entry":[{},":SoftwareComponent","a","owl:Class ;"]},{"entry":[{},{},":requires",":Input ;"]},{"entry":[{},{},":produces",":Output ."]},{"entry":[{},":Output",":contains","owl:Thing ."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}}}},"From these basic building blocks, specific Data Source, Software Component, Input and Output prototypes can be defined, each describing specific Data Source, Input, Output, and Software Component exemplars such as DataSource :HubbleEarthImageSource_ and SoftwareComponent :ImagePatternRecognizer_, and their respective inputs and outputs.","The contains relation for input and outputs, provides the mechanism for associating to a component semantic description of data to be carried on its inputs and\/or outputs.","In , HubbleEarthImageSource_, a DataSource , produces an Output  that contains HubbleEarthImage_, an individual in the class InfraredImage:",{"@attributes":{"id":"p-0077","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"91pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[":HubbleEarthImageSource_1","a",":DataSource ;"]},{"entry":[{},":produces",":HubbleEarthImageOutput_1 ."]},{"entry":[":HubbleEarthImageOutput_1",":contains",":HubbleEarthImage_1 ."]},{"entry":["\u2003:HubbleEarthImage_1","a",":InfraredImage ;"]},{"entry":[{},":imageOf",":Earth ;"]},{"entry":[{},":capturedBy",":Hubble ;"]},{"entry":[{},"a",":Variable ;"]},{"entry":[{},"a",":Exemplar."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"The use of the double underscores (\u201c_\u201d) in _HubbleEarthImage_ is a graphical shorthand indicating that Image_ is also a Variable and an Exemplar, represented above as being of type Variable and of type Exemplar (both of which are special classes defined in the system ontology). The _HubbleEarthImage_ is an Exemplar that can take the value of an individual in the class InfraredImage and that has the appropriate capturedBy and imageOf properties associated therewith. Note that Hubble and Earth do not really appear in the output; instead, they are semantic descriptions of the _HubbleEarthImage_ data, which appears in the output. Hence, the contains relation is a special relation (i.e., only those data items that the output explicitly describes using the contains relation are actually contained in the output). The remainder of the objects (e.g., Earth), while not contained in the output, form a rich semantic description of the objects contained in the output (_HubbleEarthImage_).","Software components are described as requiring some number of inputs and producing some number of outputs. An ImagePatternRecognizer_ processing component (ImagePatternRecognizer  in ), is defined as requiring one input  containing ?Image_, an Image, and as producing a single output  containing ?Image_, and a Keyword _Keyword_, such that ?Image_ is described By Keyword_. Here the \u201c?\u201d preceding Image_ is a graphical notation that Image_ is a Varnable (not an Exemplar). This means that the ImagePatterRecognizer_ requires an input ?Image_ and produces the same ?Image_ as an output annotated by a new thing, _Keyword_.","The ImagePatternRecognizer_ is defined to perform a few functions: it conveys a known Image from input to output, it creates a new object (Exemplar) (e.g., a Keyword), and it establishes a new relation, describedBy.","Method and System for Automatic Composition of Information Processing Applications","In order to connect two components together, it is first determined if the output of a first component can be connected to the input of a second component, and once the components are connected to each other, the resulting output produced by the second software component is then determined.","Given the descriptions of inputs and outputs of components, a process for determining if an output of a first component can be matched to an input of a second component will now be described. The component matching problem is treated as a graph embedding problem in which the question, \u201cCan the graph describing the input be embedded in a graph describing another component's output?\u201d is answered. This approach is different from traditional approaches where matching is generally based on simple type-checking alone. The graph embedding approach is more powerful, building on the expressivity of semantic graphs.","To formally describe the component matching problem, let G=(V, C, E) represent the input graph where Vis the set of variable modules, Cis the set of non-variable of constant nodes, and Eis the set of edges of the form {u, p, v} where node u is related to node v through property p. Similarly, let G=(V, C, E) represent the output graph. Note that Gand Gare directed graphs.","Gcan be embedded in G, if there exists a graph homomorphism f: G\u2192G, that is, there is a mapping f:V\u222aC\u2192V\u222aCsuch that if {u, p, v}\u03b5Ethen {f(u), f(p), f(v)}\u03b5E. In addition, for any x\u03b5C, f(x)=x. This means that constant nodes can only be mapped to equivalent constant nodes in the other graph, while variable nodes can be mapped to other variable nodes or constant nodes.","In addition, DL reasoning is applied to the output graphs to enable more flexible matching. In other words, graph Gis expanded with the results of DL reasoning to create graph G\u2032. Graph Gis then checked to see if it can be embedded in G\u2032. The use of reasoning provides a matching process that is capable of connecting components, even if the inputs and outputs are described using different terms. DL reasoning allows inferring new facts based on definitions in the ontology such as subclass and subproperty relationships, transitive, symmetric, inverse and functional properties, property restrictions, equality and inequality statements, etc.","For example, in , an output graph  from HubbleEarthImageSource_ is first expanded to include the results of DL reasoning. As a result, a type link is added from HubbleEarthImage_ to Image (this is obtained from the subclass relationship between InfraredImage and Image). In addition, a depictedIn link is added from Earth to _HubbleEarthImage_ (depictedIn defined as an inverse property of imageOf). Next, the matching process finds a homomorphism from an input graph  of the ImagePatternRecognizer to the output graph  of HubbleEarthImageSource_. In this homomorphism, ?Image_ is mapped to _HubbleEarthImage_ (since they are both variables) and Image is mapped to Image (since they are both the same concept). Hence, the matching process determines that there is a match.","Determining the Output of a Software Component","To help determine the output of a software component as a result of drawing data from the outputs of other components, a formal functional model of the software component is defined. In the model, the software component can be viewed as performing a graph transformation on the semantic graphs on the inputs to produce semantic graphs on the outputs.",{"@attributes":{"id":"p-0089","num":"0088"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mi":["L","_"]},"mo":"=","mrow":{"mrow":[{"mover":{"munder":{"mo":"\u22c3","mrow":{"mi":"i","mo":"=","mn":"1"}},"mi":"m"},"mo":"\u2062","mrow":{"msub":{"mi":["L","i"]},"mo":["\u2062","\u2062","\u2062","\u2062"],"mstyle":[{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}},{"mspace":{"@attributes":{"width":"0.8em","height":"0.8ex"}}}],"mi":"and","mover":{"mi":["R","_"]}}},{"mover":{"munder":{"mo":"\u22c3","mrow":{"mi":"j","mo":"=","mn":"1"}},"mi":"n"},"mo":"\u2062","mrow":{"msub":{"mi":["R","j"]},"mo":"."}}],"mo":"="}}}},"br":{},"o":["L","R"]},"Note that there may be an overlap between  and . Now assume that the m input graphs have been matched to m outputs generated by other components, that is, Lis matched to Xfor i=1 . . . m. The outputs Ycoming from this software component are determined as a result of connecting the inputs Xto the software component using a graph homomorphism, f: \u222a \u2192 \u222a  where",{"@attributes":{"id":"p-0091","num":"0090"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mover":{"mi":["X","_"]},"mo":"=","mrow":{"mrow":[{"mrow":{"mrow":{"mover":{"munder":{"mo":"\u22c3","mrow":{"mi":"i","mo":"=","mn":"1"}},"mi":"m"},"mo":"\u2062","msub":{"mi":["X","i"]}},"mo":"&"},"mo":["\u2062","\u2062"],"mstyle":{"mspace":{"@attributes":{"width":"0.6em","height":"0.6ex"}}},"mover":{"mi":["Y","_"]}},{"mover":{"munder":{"mo":"\u22c3","mrow":{"mi":"j","mo":"=","mn":"1"}},"mi":"n"},"mo":"\u2062","mrow":{"msub":{"mi":["Y","j"]},"mo":"."}}],"mo":"="}}}}},"In the model of the software components, f satisfies the following properties (for i=1 . . . m and j=1 . . . n):","1. f(L)\u2282X. This is acquired from the previous step that matched the components.","2. f(R)\u2282Y.","3. f( \\ )=f( \\ ) and f( \\ )=f( \\ ), where \u201c\\\u201d represents the graph difference operation. This means that exactly that part of  is deleted which is matched by elements of  not in , and exactly that part of  is created that is matched by elements new in .","Using properties  and , the outputs, Y, of a software component can be determined as a result of connecting Xto the component. An example of this process is shown in , where the output  of the ImagePatternRecognizer_ is generated based on the input  that is connected to the ImagePatternRecognizer_.","Composition Process","A semantic planner for automatically generating processing graphs from processing requests and semantic descriptions of components will now be discussed. The semantic planner enhances traditional AI planning techniques to plan on domains expressed in onotologies. Processing requests, in this case, user queries, are expressed as semantic graph patterns. The planner recursively connects components to each other using the methods described above until it arrives at an outcome description that can be matched to the request specification, or until no new output descriptions can be produced. In addition, the planner satisfies various constraints such as privacy and security, and produces optimal plans for a given resource consumption range.","As shown in , a semantic planner  consists of three main components: a Stream Processing Planning Language (SPPL) Generator, a DL Reasoner and a Plan Solver. The SPPL Generator takes OWL files describing software components and data sources and compiles them into a planning domain represented in the intermediate language SPPL as described, for example, in A. Riabov, Z. Liu, Planning for Stream Processing Systems, in Proceeding of AAAI-2005, July 2005, a copy of which is incorporated by reference herein in its entirety.","The SPPL Generator makes use of the DL Reasoner to make inferences about the software component descriptions and inserts these inferences as facts into the domain description. In addition to semantic descriptions of inputs and outputs, the planning domain also includes descriptions of other compositional\/operational constraints such as security and privacy constraints. In addition to creating the domain file, the SPPL","Generator translates each stream query into a goal description in SPPL. The Plan Solver then parses the generated domain and problem SPPL files and produces optimal plans using a backward-chaining branch and bound algorithm as described, for example, A. Riabov, Z. Liu, Planning for Stream Processing Systems, in Proceeding of AAAI-2005, July 2005. The Plan Solver solves the graph embedding problem by deducing appropriate mappings of variables in the input graph to nodes in the output graph. In this planning process multi-objective optimization is carried out including, for example, computational cost and result quality. A Minerva Reasoner, which is a highly scalable reasoner, operating on a description logic program (DLP), which is an expressive subset of DL, may be used as the DL Reasoner.","When the planner  is given a processing request, the planner  searches for multiple alternative plans, visiting software component descriptions and traversing potentially large associated input and output description graphs many times. Incurring the overhead of DL reasoning on each visit could have a huge negative impact on performance. This is overcome by adopting a two-phase approach, performing a priori reasoning over graphs of asserted and inferred facts, caching expanded graphs for later use during query compilation. Because the products of the reasoning have been cached, no DL reasoning need be used while searching for viable processing graphs.","An example of a processing graph  assembled by the semantic planner  in response to a request for hurricane associated images is shown in . It is to be understood that although only one processing graph is shown in , the semantic planner  can assemble several alternative processing graphs. The processing graph  shown in  draws on two data sources  feeding three operators\/components  to produce a sink including hurricane-associated images  (e.g., images that contain possible storm pattern and images that were taken around that same time a hurricane was reported).  depicts the same processing graph as shown in ; however, here, semantic graphs describing each data source's outputs _out, each component's inputs _in and outputs _out and the sink's inputs _in are provided.","As can be gleaned from a review of , it can be difficult to select from among a large set of data sources and software components to compose such a graph manually. For example, even with the relatively small number of operators depicted in the processing graph , the work needed to identify appropriate elements and to match outputs to inputs can be daunting, especially for matches requiring reasoning. Since most processing graphs involve many more operators, manual composition of even one graph is tedious and manual composition of multiple, alternative processing graphs is impracticable. Hence, automated compilation approaches such as planning are essential for compiling processing requests into processing graphs.",{"@attributes":{"id":"p-0105","num":"0104"},"figref":"FIG. 8","b":"800"},{"@attributes":{"id":"p-0106","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"280pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"\u2003<xs:schema"},{"entry":"targetNamespace=\u201chttp:\/\/www.ibm.com\/research\/distillery\/inq\/isl\/1.0\u201d"},{"entry":"xmlns=\u201chttp:\/\/www.ibm.com\/research\/distillery\/inq\/isl\/1.0\u201d"},{"entry":"xmlns:xs=\u201chttp:\/\/www.w3.org\/2001\/XMLSchema\u201d elementFormDefault=\u201cqualified\u201d"},{"entry":"attributeFormDefault=\u201cunqualified\u201d>"},{"entry":"\u2003\u2003<xs:element name=\u201cProcessingRequest\u201dtype=\u201cProcessingRequest\u201d>"},{"entry":"\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:documentation>The processing request described by this ISL"},{"entry":"specification.<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003<\/xs:complexType name=\u201cProcessingRequest\u201d>"},{"entry":"\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:documentation>The type for a processing request"},{"entry":"specification.<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003<xs:element name=\u201cGoals\u201d type=\u201cGoalExpression\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<xs:element name=\u201cConstraints\u201d type=\u201cConstraintExpression\u201d"},{"entry":"minOccurs=\u201c0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<xs:element name=\u201cOperationalParameters\u201d"},{"entry":"type=\u201cOperationalParameters\u201d minOccurs=\u201c0\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:documentation>Items passed to the planner(s) and\/or the runtime,"},{"entry":"providing values\/functions needed to plan\/shcedule\/deploy the processing request. Limited"},{"entry":"set for ISL 1.0 - to expand as knowledge of paramenters<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003\u2003<xs:attribute name=\u201ccomment\u201d type=\u201cxs:string\u201d\/>"},{"entry":"\u2003\u2003\u2003<xs:attribute name=\u201cname\u201d type=\u201cxs:string\u201d use=\u201crequired\u201d\/>"},{"entry":"\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003\u2003<xs:element name=\u201cGoal\u201d type=\u201cProcessingRequestGoal\u201d abstract=\u201ctrue\u201d>"},{"entry":"\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:documentation>Abstract element. To be substituted by any defined"},{"entry":"type of goal element.<\/xs:documentation>"},{"entry":"\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003<\/xs:element>"},{"entry":"\u2003<xs:complexType name=\u201cProcessingRequestGoal\u201d abstract=\u201ctrue\u201d>"},{"entry":"\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003<xs:documentation>Base type for processing request goals. Abstract,"},{"entry":"intended to be extended.<\/xs:documentation>"},{"entry":"\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003<\/xs:complexType>"},{"entry":"\u2003<xs:complexType name=\u201cGoalExpression\u201d>"},{"entry":"\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003<xs:documentation>Making room for a richer goal expression language."},{"entry":"FOr now, simply a conjunction of goals.<\/xs:documentation>"},{"entry":"\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:documentation>Conjoined (ANDed) goals. Conjunction will suffice"},{"entry":"for our current planning needs. We may need to consider full boolean expxressions to"},{"entry":"express various goal combinations, and\/or preference weighting to convey semantics other"},{"entry":"than conjoined non-optional goals. <\/xs:documentation>"},{"entry":"\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003\u2003<xs:element ref=\u201cGoal\u201d maxOccurs=\u201cunbounded\u201d\/>"},{"entry":"\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003<\/xs:complexType>"},{"entry":"\u2003<xs:complexType name=\u201cGraphPattern\u201d>"},{"entry":"\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003<xs:documentation>Any graph pattern, expressed in some interpretable"},{"entry":"language. For ISL1.0, it's SPARQL WHERE graph patterns.<\/xs:documentation>"},{"entry":"\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003<xs:simpleContent>"},{"entry":"\u2003\u2003\u2003<xs:extension base=\u201cxs:string\u201d\/>"},{"entry":"\u2003\u2003<\/xs:simpleContent>"},{"entry":"\u2003<\/xs:complexType>"},{"entry":"\u2003<xs:complexType name=\u201cBooleanExpression\u201d>"},{"entry":"\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003<xs:documentation>Any boolean expression, expressed in some"},{"entry":"interpretable language. For ISL 1.0, it's the SPARQL FILTER Expression sublanguage."},{"entry":"<\/xs:documentation>"},{"entry":"\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003<xs:simpleContent>"},{"entry":"\u2003\u2003\u2003<xs:extension base=\u201cxs:string\u201d\/>"},{"entry":"\u2003\u2003<\/xs:simpleContent>"},{"entry":"\u2003<\/xs:complexType>"},{"entry":"\u2003<xs:element name=\u201cPlanElement\u201d type=\u201cPlanElement\u201d abstract=\u201ctrue\u201d>"},{"entry":"\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003<xs:documentation>Abstract element for constrained Plan elements. To be"},{"entry":"substituted by specific kinds of plan elements (e.g., DataSource,"},{"entry":"Method).<\/xs:documentation>"},{"entry":"\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003<\/xs:element>"},{"entry":"\u2003<\/xs:complexType name=\u201cPlanElementConstraint\u201c>"},{"entry":"\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003<xs:element ref=\u201cPlanElement\u201d maxOccurs=\u201cunbounded\u201d\/>"},{"entry":"\u2003\u2003\u2003<xs:element ref=\u201cWhere\u201d minOccurs=\u201c0\u201d\/>"},{"entry":"\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003<xs:attribute name=\u201cweight\u201d type=\u201cxs:decimal\u201d use=\u201crequired\u201d\/>"},{"entry":"\u2003<\/xs:complexType>"},{"entry":"\u2003<xs:element name=\u201cWhere\u201d type=\u201cGraphPattern\u201d>"},{"entry":"\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003<xs:documentation>The graph pattern providing the semantic description"},{"entry":"of the named elements (variables) above. <\/xs:documentation>"},{"entry":"\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003<\/xs:element>"},{"entry":"\u2003<xs:complexType name=\u201cResultDisposition\u201d>"},{"entry":"\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003<xs:element name=\u201cif\u201d type=\u201cBooleanExpression\u201d minOccurs=\u201c0\u201d\/>"},{"entry":"\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003<\/xs:complexType>"},{"entry":"\u2003<xs:complexType name=\u201cNotification\u201d>"},{"entry":"\u2003\u2003<xs:complexContent>"},{"entry":"\u2003\u2003\u2003<xs:extension base=\u201cResultDisposition\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cRecipient\u201d minOccurs=\u201c0\u201d"},{"entry":"maxOccurs=\u201cunbounded\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:documentation>Recipients specified in the processing"},{"entry":"request, providing initial set of subscribers to notification. Others could be added (subject"},{"entry":"to credential-clearining planning), and any can be removed.<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:complexType>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cUserName\u201d type=\u201cxs:string\u201d"},{"entry":"minOccurs=\u201c0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cmBox\u201d type=\u201cxs:anyURI\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cPriority\u201d type=\u201cxs:decimal\u201d minOccurs=\u201c0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cMessageString\u201d type=\u201cxs:string\u201d"},{"entry":"minOccurs=\u201c0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:extension>"},{"entry":"\u2003\u2003\u2003<\/xs:complexContent>"},{"entry":"\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003\u2003<xs:element name=\u201cDisposition\u201d type=\u201cResultDisposition\u201d abstract=\u201ctrue\u201d>"},{"entry":"\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:documentation>Plugins for various types of result"},{"entry":"disposition<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003<xs:element name=\u201cNotify\u201d substitutionGroup=\u201cDisposition\u201d>"},{"entry":"\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:documentation>Send all ResultElements to external notification"},{"entry":"service."},{"entry":"\u2003Notificiation mechanism TBD . If external, ResultElementSet required to carry all"},{"entry":"variables in notify \u201cif\u201d clause.<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003\u2003<xs:complexType>"},{"entry":"\u2003\u2003\u2003\u2003<xs:complexContent>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:extension base=\u201cNotification\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:complexContent>"},{"entry":"\u2003\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003<xs:element name=\u201cExport\u201d type=\u201cExportDisposition\u201d>"},{"entry":"\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:documentation>ISL 2.0: Export from SPC - no presumption of"},{"entry":"retention - simply export. Valid?<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003<xs:complexType name=\u201cExportDisposition\u201d>"},{"entry":"\u2003\u2003\u2003<xs:complexContent>"},{"entry":"\u2003\u2003\u2003\u2003<xs:extension base=\u201cResultDisposition\u201d\/>"},{"entry":"\u2003\u2003\u2003<\/xs:complexContent>"},{"entry":"\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003\u2003<xs:element name=\u201cDisposition2.0\u201d type=\u201cResultDisposition\u201d\/>"},{"entry":"\u2003\u2003<xs:element name=\u201cExportToDB\u201d type=\u201cExportToDBDisposition\u201d"},{"entry":"substitutionGroup=\u201cDisposition2.0\u201d>"},{"entry":"\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:documentation>ISL 2.0:Store all ResultElements to external"},{"entry":"DB<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003<xs:element name=\u201cProduce\u201d type=\u201cProducesGoalExpression\u201d"},{"entry":"substitutionGroup=\u201cGoal\u201d>"},{"entry":"\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:documentation>The primary means of identifying the data to be"},{"entry":"sought\/produced by and processing request, since Distillery's raison d'etre is streaming"},{"entry":"data analysis.<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003<xs:element name=\u201cPersistWithNotification\u201d type=\u201cPersistWithNotification\u201d\/>"},{"entry":"\u2003\u2003<xs:complexType name=\u201cPersistWithNotification\u201d>"},{"entry":"\u2003\u2003\u2003<xs:complexContent>"},{"entry":"\u2003\u2003\u2003\u2003<xs:extension base=\u201cNotification\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cRetentionValue\u201d type=\u201cRetentionValue\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:extension>"},{"entry":"\u2003\u2003\u2003<\/xs:complexContent>"},{"entry":"\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003\u2003<xs:element name=\u201cConstraint\u201d type=\u201cPlanElementConstraint\u201d"},{"entry":"abstract=\u201ctrue\u201d>"},{"entry":"\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:documentation>Abstract element capturing the constraint type."},{"entry":"Specific constraint types substitute for this element.<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003<xs:element name=\u201cAvoid\u201d type=\u201cPlanElementConstraint\u201d"},{"entry":"substitutionGroup=\u201cConstraint\u201d>"},{"entry":"\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:documentation>Avoid the plan element(s) described within."},{"entry":"<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003<xs:element name=\u201cPrefer\u201d type=\u201cPlanElementConstraint\u201d"},{"entry":"substitutionGroup=\u201cConstraint\u201d>"},{"entry":"\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:documentation>Prefer the plan elements defined within"},{"entry":"<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003<xs:complexType name=\u201cResultSetWithDisposition\u201d>"},{"entry":"\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003<xs:element name=\u201cwithElements\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:documentation>Set of elements comprising a complete result set."},{"entry":"If a result set with more or fewer elements is needed, create another."},{"entry":"\u2003Post 1.0: optional elements<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:complexType>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cResultElement\u201d type=\u201cVariableName\u201d"},{"entry":"maxOccurs=\u201cunbounded\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:documentation>Each element corresponds to a variable in"},{"entry":"the Where clause.<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003\u2003<xs:element name=\u201cwithDispositions\u201d minOccurs=\u201c0\u201d"},{"entry":"\u2003\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:documentation>Result Dispositions are the handling of result sets."},{"entry":"To get results to be, e.g., persisted, notified, etc., apply one or more dispositions. This set is"},{"entry":"extensible, based on the kinds of dispositions defined for the"},{"entry":"application.<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:complexType>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:element ref=\u201cDisposition\u201d maxOccurs=\u201cunbounded\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003<\/xs:complexType>"},{"entry":"\u2003<xs:complexType name=\u201cRetentionValue\u201d>"},{"entry":"\u2003\u2003<xs:simpleContent>"},{"entry":"\u2003\u2003\u2003<xs:extension base=\u201cxs:decimal\u201d\/>"},{"entry":"\u2003\u2003<\/xs:simpleContent>"},{"entry":"\u2003<\/xs:complexType>"},{"entry":"\u2003<xs:complexType name=\u201cProducesGoalExpression\u201d>"},{"entry":"\u2003\u2003<xs:complexContent>"},{"entry":"\u2003\u2003\u2003<xs:extension base=\u201cProcessingRequestGoal\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cResult\u201d maxOccurs=\u201cunbounded\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:complexType>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:complexContent>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:extension base=\u201cResultSetWithDisposition\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:attribute name=\u201ccomment\u201d type=\u201cxs:string\u201d"},{"entry":"use=\u201coptional\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<\/xs:extension>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003<\/xs:complexContent>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:element ref=\u201cWhere\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003\u2003<\/xs:extension>"},{"entry":"\u2003\u2003<\/xs:complexContent>"},{"entry":"\u2003<\/xs:complexType>"},{"entry":"\u2003<xs:element name=\u201cDataSource\u201d substitutionGroup=\u201cPlanElement\u201d>"},{"entry":"\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003<xs:documentation>Named Data Source to be avoided or preferred in the"},{"entry":"processing request. The name is a variable (?DS1), which is defined in the Where"},{"entry":"clause<\/xs:documentation>"},{"entry":"\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003<xs:complexType>"},{"entry":"\u2003\u2003\u2003<xs:simpleContent>"},{"entry":"\u2003\u2003\u2003\u2003<xs:restriction base=\u201cPlanElement\u201d\/>"},{"entry":"\u2003\u2003\u2003<\/xs:simpleContent>"},{"entry":"\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003<\/xs:element>"},{"entry":"\u2003<xs:element name=\u201cMethod\u201d type=\u201cPlanElement\u201d"},{"entry":"substitutionGroup=\u201cPlanElement\u201d>"},{"entry":"\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003<xs:documentation>Named Method (PE or collection of PEs) to be avoided"},{"entry":"or preferred in the processing request. The name is a variable (?ME1), which is defined in"},{"entry":"the Where clause<\/xs:documentation>"},{"entry":"\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003<\/xs:element>"},{"entry":"\u2003<xs:complexType name=\u201cPlanElement\u201d>"},{"entry":"\u2003\u2003<xs:simpleContent>"},{"entry":"\u2003\u2003\u2003<xs:extension base=\u201cxs:string\u201d\/>"},{"entry":"\u2003\u2003<\/xs:simpleContent>"},{"entry":"\u2003<\/xs:complexType>"},{"entry":"\u2003<xs:complexType name=\u201cExportToDBDisposition\u201d>"},{"entry":"\u2003\u2003<xs:complexContent>"},{"entry":"\u2003\u2003\u2003<xs:extension base=\u201cExportDisposition\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cStoreToDBScript\u201d type=\u201cxs:string\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:documentation>May contain references to ResultElement"},{"entry":"variables, which would need binding prior to execution.<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003\u2003<\/xs:extension>"},{"entry":"\u2003\u2003<\/xs:complexContent>"},{"entry":"\u2003<\/xs:complexType>"},{"entry":"\u2003<xs:element name=\u201cPersist\u201d type=\u201cPersistDisposition\u201d"},{"entry":"substitutionGroup=\u201cDisposition\u201d>"},{"entry":"\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<xs:documentation>ISL 1.0:"},{"entry":"\u2003Assume default result persistence for results. This disposition provides a means of"},{"entry":"overriding default persistence and retention attributes (as defined in JDL)."},{"entry":"\u2003Should eventually be policy-driven."},{"entry":"\u2003With experience we can abstract this to more general disposition statements, such"},{"entry":"as AdjustRetention and SetRetention.<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003<xs:complexType name=\u201cPersistDisposition\u201d>"},{"entry":"\u2003\u2003\u2003<xs:complexContent>"},{"entry":"\u2003\u2003\u2003\u2003<xs:extension base=\u201cResultDisposition\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cfor\u201d type=\u201cxs:duration\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cRetentionAttributes\u201d type=\u201cxs:string\u201d"},{"entry":"minOccurs=\u201c0\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:extension>"},{"entry":"\u2003\u2003\u2003<\/xs:complexContent>"},{"entry":"\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003\u2003<xs:simpleType name=\u201cVariableName\u201d>"},{"entry":"\u2003\u2003\u2003<xs:restriction base=\u201cxs:string\u201d>"},{"entry":"\u2003\u2003\u2003\u2003<xs:pattern"},{"entry":"value=\u201c\\?[A-Za-z&#x00C0;-&#x00D6;&#x00D8;-&#x00F6;&#x00F8;-&#x02FF;&#x0"},{"entry":"370;-&#x037D;&#x037F;-&#x1FFF;&#x200C;-&#x200D;&#x2070;-&#x218F;&#x2C0"},{"entry":"0;-&#x2FEF;&#x3001;-&#xD7FF;&#xF900;-&#xFDCF;&#xFDF0;-&#xFFFD;][A-Za-z"},{"entry":"0-9\\-_&#x00B7;&#x0300;-&#x036F;&#x203F;-&#x2040;&#x00C0;-&#x00D6;&#x00"},{"entry":"D8;-&#x00F6;&#x00F8;-&#x02FF;&#x0370;-&#x037D;&#x037F;-&#x1FFF;&#x200C"},{"entry":";-&#x200D;&#x2070;-&#x218F;&#x2C00;-&#x2FEF;&#x3001;-&#xD7FF;&#xF900;-"},{"entry":"&#xFDCF;&#xFDF0;-&#xFFFD;]*\u201d\/>"},{"entry":"\u2003\u2003\u2003<\/xs:restriction>"},{"entry":"\u2003\u2003<\/xs:simpleType>"},{"entry":"\u2003\u2003<xs:complexType name=\u201cConstraintExpression\u201d>"},{"entry":"\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003<xs:element ref=\u201cConstraint\u201d minOccurs=\u201c0\u201d maxOccurs=\u201cunbounded\u201d\/>"},{"entry":"\u2003\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003\u2003<xs:complexType name=\u201cOperationalParameters\u201d>"},{"entry":"\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003<xs:element name=\u201cRiskMax\u201d type=\u201cxs:nonNegativeInteger\u201d"},{"entry":"minOccurs=\u201c0\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:documentation>The maximum risk allowable for this processing"},{"entry":"request. <\/xs:documentation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003\u2003\u2003<xs:element name=\u201cResourceUtilizationMax\u201d"},{"entry":"type=\u201cxs:nonNegativeInteger\u201d minOccurs=\u201c0\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:documentation>The maximum resource utilization for this"},{"entry":"processing request<\/xs:documentation>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<\/xs:annotation>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003\u2003<\/xs:element name=\u201cStreamOut\u201d type=\u201cStreamOutDisposition\u201d"},{"entry":"substitutionGroup=\u201dDisposition\u201d\/>"},{"entry":"\u2003\u2003<xs:complexType name=\u201cStreamOutDisposition\u201d>"},{"entry":"\u2003\u2003\u2003<xs:complexContent>"},{"entry":"\u2003\u2003\u2003\u2003<xs:extension base=\u201cResultDisposition\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cDestination\u201d maxOccurs=\u201cunbounded\u201d>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:complexType>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cHost\u201d type=\u201cxs:string\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<xs:element name=\u201cPort\u201d type=\u201cxs:integer\u201d"},{"entry":"maxOccurs=\u201cunbounded\u201d\/>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003<\/xs:element>"},{"entry":"\u2003\u2003\u2003\u2003\u2003<\/xs:sequence>"},{"entry":"\u2003\u2003\u2003\u2003<\/xs:extension>"},{"entry":"\u2003\u2003\u2003<\/xs:complexContent>"},{"entry":"\u2003\u2003<\/xs:complexType>"},{"entry":"\u2003<\/xs:schema>"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"In accordance with an exemplary embodiment of the present invention, a means of describing processing outcomes in such a way that information processing applications that satisfy these requests can be generated is provided. In this way, software applications can be assembled more dynamically (in seconds or minutes as opposed to days or months), taking into account many more considerations (security, privacy, resource availability and consumption, etc.) than most users could fathom, let alone have the time or patience to accommodate. A key characteristic of the request specification method is its emphasis on goal specification.","By using the present invention a user can describe solely the intended processing outcome, not needing to know nor be required to express the details of how the processing outcome is to be fulfilled. The method has the effect of preventing over-specification of processing requests. Thus, an application planner can discover better ways of accommodating the request, better data sources to draw from, better algorithms to apply, and the assembly of more effective and\/or efficient applications than the requester might envision. Here, users need only describe their requests and convey their constraints (if any) on how the request is to be fulfilled, and need a mechanism, preferably automated, whereby various ways to fulfill their request can be generated, compared, pruned, and applied.","By providing a means of conveying the goals for processing outcome and doing so using semantic descriptions built according to an explicitly represented semantic model, the user is freed from the burden of knowing and applying some set of operators to produce some outcome. This allows the work of two different groups of people, those conveying their request and those developing and describing application components, to proceed in parallel. The present invention makes this possible by allowing the first group to convey their requests without having any knowledge of which data sources or processing methods are available for use or how they must be assembled. Request specifications are semantically described, expressed by graph patterns represented as triple patterns, describing both the goal of the processing request and the constraints on the resultant processing graphs. Expressivity is similar to that of the SPARQL RDF query language, a language used to encode the triple patterns. Request specifications are different from SPARQL queries in that they express outcomes beyond those of information production (i.e., not just queries), and are used not as input to a query processor but for matching the outcomes to components in automatically assembled processing graphs.","It should be understood that the present invention may be implemented in various forms of hardware, software, firmware, special purpose processors, or a combination thereof. In one embodiment, the present invention may be implemented in software as an application program tangibly embodied on a program storage device (e.g., magnetic floppy disk, RAM, CD ROM, DVD, ROM, and flash memory). The application program may be uploaded to, and executed by, a machine comprising any suitable architecture.","It is to be further understood that because some of the constituent system components and method steps depicted in the accompanying figures may be implemented in software, the actual connections between the system components (or the process steps) may differ depending on the manner in which the present invention is programmed. Given the teachings of the present invention provided herein, one of ordinary skill in the art will be able to contemplate these and similar implementations or configurations of the present invention.","It should also be understood that the above description is only representative of illustrative embodiments. For the convenience of the reader, the above description has focused on a representative sample of possible embodiments, a sample that is illustrative of the principles of the invention. The description has not attempted to exhaustively enumerate all possible variations. That alternative embodiments may not have been presented for a specific portion of the invention, or that further undescribed alternatives may be available for a portion, is not to be considered a disclaimer of those alternate embodiments. Other applications and embodiments can be implemented without departing from the spirit and scope of the present invention.","It is therefore intended, that the invention not be limited to the specifically described embodiments, because numerous permutations and combinations of the above and implementations involving non-inventive substitutions for the above can be created, but the invention is to be defined in accordance with the claims that follow. It can be appreciated that many of those undescribed embodiments are within the literal scope of the following claims, and that others are equivalent."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 7B","FIG. 7A"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
