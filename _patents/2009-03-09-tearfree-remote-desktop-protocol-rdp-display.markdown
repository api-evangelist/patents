---
title: Tear-free remote desktop protocol (RDP) display
abstract: Systems, methods and computer readable media are disclosed for reducing the tearing of display data received across a communications network. A server determines at least two logically related drawing orders in an order heap and warps those orders with a begin marker and an end marker. It sends those wrapped orders across the communications network to a client. The client receives those orders and renders them to a shadow buffer. When the client processes the end marker, it moves the drawing orders in the shadow buffer to a client display surface.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08307103&OS=08307103&RS=08307103
owner: Microsoft Corporation
number: 08307103
owner_city: Redmond
owner_country: US
publication_date: 20090309
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF ILLUSTRATIVE EMBODIMENTS","CONCLUSION"],"p":["Although computers were once isolated and had minimal or little interaction with other computers, today's computers interact with a wide variety of other computers through communications networks, such as Local Area Networks (LANs) and Wide Area Networks (WANs). With the wide-spread growth of the INTERNET\u2122, connectivity between computers is becoming more important and has opened up many new applications and technologies. The growth of large-scale networks, and the wide-spread availability of low-cost personal computers, has fundamentally changed the way that many people work, interact, communicate, and play.","One increasing popular form of networking may generally be referred to as virtual computing systems, which can use protocols such as Remote Desktop Protocol (RDP), Independent Computing Architecture (ICA), and others to share a desktop and other applications with a remote client. Such computing systems typically transmit the keyboard presses and mouse clicks or selections from the client to a server, relaying the screen updates back in the other direction over a network connection (e.g., the INTERNET). As such, the user has the experience as if their machine is operating as part of a LAN, when in reality the client device is only sent screenshots of the applications as they appear on the server side.","In a remote session, \u201cscreen tearing\u201d may occur on a display where a newly rendered frame partially overlaps a previously rendered frame, creating a torn look as two parts of a displayed object do not line up. This most commonly occurs in a remote desktop protocol (RDP) session during periods of rapid drawing, such as for animation or video playback. Screen tearing will become more significant as RDP advances in areas such as bitmap encoding, bulk compression and the transport stack. It would therefore be an improvement over the prior art to group related graphics data to ensure that it is rendered as a single visual unit, as well as to logically batch related drawing orders that should be copied from the shadow buffer to the display surface as a group.","This logically batching of instructions may be added by the RDP server. This addition may be accomplished by allowing an application that has display output sent through RDP to insert \u201cbegin-logical-frame\u201d and \u201cend-logical-frame\u201d markers. This may also be accomplished by a component of the RDP system examining the received stream of encoded drawing orders, from there determining a start and end of related drawing orders and at those points inserting \u201cbegin-logical-frame\u201d and \u201cend-logical-frame\u201d markers.","In an exemplary embodiment, a server determines at least two logically related drawing orders in an order heap and warps those orders with a begin marker and an end marker. It sends those wrapped orders across the communications network to a client. The client receives those orders and renders them to a shadow buffer. When the client processes the end marker, it moves the drawing orders in the shadow buffer to a client display surface.","It can be appreciated by one of skill in the art that one or more various aspects of the disclosure may include but are not limited to circuitry and\/or programming for effecting the herein-referenced aspects of the present disclosure; the circuitry and\/or programming can be virtually any combination of hardware, software, and\/or firmware configured to effect the herein-referenced aspects depending upon the design choices of the system designer.","The foregoing is a summary and thus contains, by necessity, simplifications, generalizations and omissions of detail. Those skilled in the art will appreciate that the summary is illustrative only and is not intended to be in any way limiting.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1","b":["120","120","120"]},"Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way of example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable, volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through an non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies. A user may enter commands and information into the computer  through input devices such as a keyboard  and pointing device , commonly referred to as a mouse, trackball or touch pad. Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through a output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on memory device . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","Referring now to , it generally illustrates an example environment wherein aspects of the present disclosure can be implemented. One skilled in the art can appreciate that the example elements depicted by  provide an operational framework for describing the present disclosure. Accordingly, in some embodiments the physical layout of the environment may be different depending on different implementation schemes. Thus the example operational framework is to be treated as illustrative only and in no way limit the scope of the claims. One skilled in the art can also appreciate that the following discussion is introductory and the elements depicted by  are described in more detail within the discussion of the operational procedures of  through .","Generally,  depicts a high level overview of a terminal server environment that can be configured to include aspects of the present disclosure. In reference to the figure, a server  is depicted that can include circuitry configured to effectuate a terminal server and for example, three example clients , , and  (while three clients are depicted the server  in embodiments can service more or less clients). The example clients - can include computer terminals effectuated by hardware configured to direct user input to the server  and display user interface information generated by the server . In other embodiments, clients - can be computers that include similar elements as those of computer  . In these example embodiments, clients - can include circuitry configured to effect operating systems and circuitry configured to emulate the functionality of terminals. In these examples one skilled in the art can appreciate that the circuitry configured to effectuate the operating systems can also include the circuitry configured to emulate terminals.","In the depicted example, the server  can be configured to generate one or more sessions for connecting clients , , and  such as sessions  through N (where N is an integer greater than 1). Briefly, a session in example embodiments of the present disclosure can generally include an operational environment that is effectuated by a plurality of subsystems, e.g., software code, that are configured to effectuate an execution environment and interact with a kernel  an operating system . For example, a session can include a shell and a user interface such as a desktop, the subsystems that track mouse movement within the desktop, the subsystems that translate a mouse click on an icon into commands that effectuate an instance of a program, etc. In another example embodiment the session can include an application. In this example while an application is rendered, a desktop environment may still be generated and hidden from the user. The session in this example can include similar subsystems as the session described above. Generally, a session can be generated by the server  on a user by user basis when, for example, the server  receives a connection request over a network connection from a client such as client . Generally, a connection request can first be handled by the transport logic  that can, for example, be effectuated by circuitry of the server . The transport logic  can in some embodiments include a network adaptor, firmware, and software that can be configured to listen for connection messages and forward them to the engine . As illustrated by , when sessions are generated the transport logic  can include protocol stack instances for each session. Generally, each protocol stack instance can be configured to route user interface output to an associated client and route user input received from the associated client to the appropriate session core .","As depicted by , during the session generation process the engine  can be configured to obtain a license for the session. For example, in one example embodiment the engine  can receive a license from the client  during the session generation process. In other example embodiments the engine  can receive a copy of a license from a license database . In some embodiments of the present disclosure the license database  can include a relational database management program that can be executed on an operating system of a computer such as computer  of . In an example embodiment that includes a license database , it can store one or more licenses that can be checked out when a client attempts to obtain a session from the server . In another embodiment each license can itself be associated with an account identifier, e.g., a username\/password combination, a smartcard identifier, etc., and each license can only be checked out if the correct account identifier is presented. Generally, the number of connections that a server  can generate can be dependent upon the number of licensees the entity that controls the server  has purchased from a service provider. If for example, the entity has purchased one license, then the server  can be configured to only allow one session. In this example if the license is associated with an account identifier, then only a user that presents the correct account identifier can obtain a session.","In example embodiments of the present disclosure each license can be validated by a service provider  before they can be used. For example, the service provider  can in example embodiments act as a certificate authority that aphorizes and activates licenses and servers. In these embodiments the service provider  can ensure that licenses are not stolen, copied, or pirated. The service provider  can also ensure that the license are only used by the server  they are purchased for by storing a copy of the licenses in a database and associating the licenses with server .","As illustrated by , a configuration manager  in an example embodiment of the present disclosure can include computer readable instructions that when executed instantiate a process that can receive a license during the session creation process and determine a service level for a newly spawned session by interfacing with various subsystems such as session manager . The session manager  in an embodiment can be configured to initialize and manage each session by for example, generating a session identifier for a session space; adding the session identifier to a table; assigning memory to the session space; and generating system environment variables and instances of subsystem processes in memory assigned to the session space. As illustrated by , in an embodiment the session manager  can instantiate environment subsystems such as a runtime subsystem  that can include a kernel mode part such as the session core . For example, the environment subsystems in an embodiment can be configured to expose a subset of services to application programs and provide an access point to the kernel  of the operating system . As illustrated by , in some embodiments the kernel  can include a security subsystem  and a resource manager . In an example embodiment the security subsystem  can enforce security policies of the server  by, for example, performing run-time object protection. In these embodiments the resource manager  in an embodiment can create and terminate processes and threads in response to requests from the runtime subsystem . More specifically, in an embodiment the runtime subsystem  can request the execution of threads and the session core  can send requests to the executive of the kernel  to allocate memory for the threads and schedule time for them to be executed.","Continuing with the description of , in an embodiment the session core  can include a graphics display interface  (GDI) and an input subsystem . The input subsystem  in an example embodiment can be configured to receive user input from a client  via the protocol stack instance associated with the session and transmit the input to the session core . The user input can in some embodiments include signals indicative of absolute and\/or relative mouse movement commands, mouse coordinates, mouse clicks, keyboard signals, joystick movement signals, etc. User input, for example, a mouse double-click on an icon, can be received by the session core  and the input subsystem  can be configured to determine that an icon is located at the coordinates associated with the double-click. The input subsystem  can then be configured to send a notification to the runtime subsystem  that can execute a process for the application associated with the icon.","In addition to receiving input from a client , draw commands can be received from applications and\/or a desktop and processed by the GDI . The GDI  in general can include a process that can generate graphical object draw commands. The GDI  in this example embodiment can be configured to pass the commands to the remote display subsystem  that can instantiate a display driver for the session. In an example embodiment the remote display subsystem  can be configured to include virtual display driver(s) that may not be associated with displays physically attacked to the server , e.g., the server  could be running headless. The virtual display driver in this embodiment can be configured to receive the draw commands and transmit them to the client  via a stack instance associated with the session.",{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3","b":["310","302"]},"In an embodiment where tear-free remote display techniques are not present, a server  is executing an application , such as a video player, and sending the output to a client  via a RDP session comprising a RDP server  and a RDP client . The application  continually outputs to a display by issuing drawing commands, such as graphics device interface (GDI) application  programming interface (API) commands. This can be done with bit-block transfer (BitBlt) from a source bitmap to a destination bitmap. These commands are then translated into display driver interface (DDI) calls (such as Win32K DDI calls) that are dispatched to a remote desktop protocol display driver (RDPDD). The RDPDD encodes the DDI calls into RDP drawing orders.","The RDP drawing orders are placed into an \u201corder heap\u201d  in memory shared with a remote desktop protocol windows driver (RDPWD) of the RDP server  that serves as keyboard and mouse driver that receives keyboard and mouse input over the TCP connection and presents them as keyboard or mouse inputs. RDPWD also allows creation of virtual channels, that allow other devices, such as disc, audio, printers, and COM ports to be redirected, i.e., the channels act as replacement for these devices. The channels connect to the client  over the TCP connection across the network ; as the channels are accessed for data, the client  is informed of the request, which is then transferred over the TCP connection to the application . This entire procedure is done by the terminal server  and the client , with the RDP protocol mediating the correct transfer, and is entirely transparent to the application .","Then, the RDPWD driver associated with the stack that is connected to the client  extracts the drawing orders from the order heap. That RDPWD bulk compresses the drawing orders and wraps them within RDP transport structures, then sends them down the stack to the client .","The client  receives these drawing orders in RDP transport structures. It extracts the drawing orders from the RDP transport structures and renders them to a shadow buffer. When at most a pre-determined number of orders have been rendered to the shadow buffer, the dirty areas of the shadow buffer are copied to a user-visible display surface.","For instance, if the pre-determined number of orders is 25 and the client  receives a RDP packet containing 54 orders, the client  will progressively render to the display surface as follows. It will render the first 25 orders, then it will render the second 25 orders, and then it will render the remaining four orders.","Rendering from the shadow buffer  to the display surface  (which corresponds to output on display device ) at this arbitrary pre-determined number of orders (here, 25) may result in the user momentarily viewing an incomplete image (the tearing). This problem will also persist where each order is immediately rendered to the display surface.","In an embodiment with tear free techniques, the application  that is executing on a server  and has display output remotely displayed on a client  may instruct RDPDD to insert \u201cbegin\u201d and \u201cend\u201d frame markers.","In such an embodiment, an application , such as a video player, executes on the server . The application  signals the remote desktop protocol display driver of the RDP server  through an application  programming interface (API) call that a logical frame is to be drawn. In response to this call, RDPDD adds a \u201cbegin\u201d marker to an order heap , a place where drawing orders are stored for processing. The application  draws the frame by issuing GDI drawing commands. These GDI commands are translated into display driver interface (DDI) calls that are dispatched to the RDPDD driver of the RDP server . RDP encodes the DDI calls into RDP drawing orders. These encoded drawing orders are placed into the order heap  in memory that is shared with the RDPWD driver. RDPDD adds an \u201cend\u201d marker to the order heap . The RDPWD driver associated with the stack that is connected to the client  extracts the drawing orders from the shared memory. The drawing orders are bulk compressed and wrapped within RDP transport structures and sent down the stack to the client  across a communications network .","In another embodiment, the server  may examine a received stream of encoded drawing orders and place \u201cbegin\u201d and \u201cend\u201d frame markers where appropriate.","In such an embodiment, an application , such as a video player, executes on the server . The application  affects its visual display output by issuing GDI drawing commands. These commands are translated into DDI calls that are then dispatched to the RDPDD driver of the RDP server . RDPDD encodes the DDI callbacks into RDP drawing orders. The encoding drawing orders are placed into the order heap  in memory that is shared with the RDPWD driver. A \u201cRDP batching engine\u201d scans the orders in the order heap to determine if there are any orders that are logically related. Any related orders are wrapped with \u201cbegin\u201d and \u201cend\u201d markers. The RDPWD driver associated with the stack that is connected to the client  extracts the drawing orders from the order heap. It bulk compresses the drawing orders and wraps them within RDP transport structures, then sends them down the stack and to the client  across a communications network .","A client  may receive RDP transport structures from both the embodiment where an application  that is executing on a server  and has display output remotely displayed on a client  may instruct RDPDD to insert \u201cbegin\u201d and \u201cend\u201d frame markers, and the embodiment where the server  examines a received stream of encoded drawing orders and place \u201cbegin\u201d and \u201cend\u201d frame markers where appropriate","When the client  receives RDP transport structures, it extracts the drawing orders from those transport structures. If a \u201cbegin\u201d marker is encountered, then any subsequent drawing orders in the RDP stream that are rendered to the shadow buffer  are not copied to the display surface  and thus the display device  until the corresponding \u201cend\u201d marker is encountered. If no \u201cbegin\u201d marker is identified, then the client  may use the existing graphics decoding pipeline.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 4"},"Operation  depicts determining at least two logically related drawing orders in an order heap, the logically related drawing orders having a start and an end.","In an embodiment, the logically related drawing orders are logically related because an image frame comprises the logically related drawing orders. The drawing orders that make up an image frame may be grouped together because they will be displayed together. The start of these logically related drawing orders may be the first drawing order that will be executed and the end may be the last drawing order that will be executed. This may correspond to the upper-left corner of a rectangular image and the bottom right corner of that rectangular image.","In an embodiment, the logically related drawing orders are logically related because one thread produced each logically related drawing order. In a multi-threaded system, multiple processes may execute. Where each process has a single thread that issues drawing orders, then one may determine that the drawing orders from different threads are likely not logically related, and that the drawing orders emanating from one thread likely are logically related.","Threads typically switch in two instances. The first is when the thread voluntarily relinquishes its turn on the processor because it has completed its task. This may typically occur where a thread has completed issuing drawing orders for an image frame. Thus, in an embodiment, this may be used as an indication that all drawing orders issued by the thread during its turn where it was active on a processor are logically related and comprise a frame. The second instance is where a thread runs out of its allotted time in which to execute on a processor. In this case, while it is likely that every drawing order issued by the thread during this period of executing is logically related, it may be that drawing orders issued by the thread when it next executes on a processor are also logically related to this present thread. In an embodiment, the logically related drawing orders span from when a thread next regains use of a processor after voluntarily giving it up until it next voluntarily gives up use of a processor.","A thread may be determined according to its thread ID (TID). Where a process has multiple threads that issue logically related drawing orders, similar techniques as the above may be used, and the processes may be distinguished according to their process ID (PID).","In an embodiment, the logically related drawing orders are logically related because they correspond to one portion of a display. An application window may comprise a contiguous region of a display surface. It may then be determined that those orders that correspond to a particular portion of the display surface are all generated by a single process and therefore are logically related.","In an embodiment, the logically related drawing orders are logically related because they were issued at a similar time. Drawing orders for a frame are typically issued temporally near to each other, making it more likely that a drawing order is logically related to one issued temporally near to it than temporally far from it. It may also be determined that two drawing orders are not logically related when a temporally intervening drawing order is issued between them.","In an embodiment, a drawing order comprises an application programming interface (API) call, and the begin marker and the end marker each comprise a call to the API. For instance, where drawing orders are issued by making calls to the graphics device interface (DDI) application programming interface (API), the API may be expanded to have special begin_marker( ) and end_marker( ) function calls that are used to signify the beginning and the end of the marker, respectively.","In an embodiment, the logically related drawing orders are logically related based on the application type. This may be used where only drawing orders emanating from the same application are logically related.","Operation  depicts wrapping the logically related drawing orders by placing a begin marker and at the start of the logically related drawing orders, and placing an end marker at the end of the end of the logically related drawing orders.","In an embodiment, the begin and the end are determined by an application from which the logically related drawing orders originate. Such an \u201caware\u201d application may be designed to keep track of which drawing orders are logically related, and send an indication of such to a component that inserts the begin and end markers. As the application likely knows the dimensions of a frame, and when a particular frame is being generated through drawing orders, there is an advantage of efficiency of it marking logically related drawing orders, as opposed to some later component doing the same having only a stream of drawing orders from which to make these determinations.","In an embodiment, the application wraps the logically related drawing orders. Rather than sending an indication of where the begin and end markers are to occur, the application may insert these itself. For instance, where these markers comprise an API call as above, the application may be the entity that issues these begin_marker( ) and end_marker( ) calls.","In an embodiment, the logically related drawing orders correspond to a screen scrape with a known start and a known end, and wrapping the logically related drawing orders further comprises placing the begin marker at the known start and placing the end marker at the known end. A screen scrape may comprise image data as it is intended for display on a display device, such as a bitmap. It may comprise the entire screen, or a subportion thereof. Typically, the dimensions of the image being \u201cscraped\u201d are known, so the start (typically the upper leftmost pixel where the scrape is rectangular) and the end (typically the lower rightmost pixel in that situation) are known as well, and begin and end markers may then be placed appropriately.","In an embodiment, the end marker comprises a transmission control protocol (TCP) flush command. A TCP flush command may be an indication for a TCP layer of a network protocol stack to send all currently held data to the next lower layer in the stack for transmission across a communications network. A TCP flush command typically comprises a null buffer that is zero bytes long. Where an entity sets the end marker by making an API call, such as the above end_marker( ) call, that call may operate to insert a TCP flush command in its place.","Operation  depicts sending the client the wrapped logically related drawing orders across a communications network, with an indication to display all of the logically related drawing orders simultaneously.","In embodiment, the wrapped logically related drawing orders are sent across the communications network in a packet, and the packet is sent when the end marker is inserted into the packet. Considerations of efficiency come into play when choosing a packet size to send across a communications network. Each packet comprises header information, so sending a series of packets with small payloads results in sending a small amount of data (the payloads) relative to the metadata (the header information). However, sending a large packet results in that packet spending an increased amount of time on a network control path (such as a wire, or a part of wireless spectrum), leading to an increased chance that some other device will send a packet at that time on that path, causing a collision where both packets are lost, and must be resent.","In this embodiment, all logically related drawing orders are sent in a single packet. This ensures that they arrive at the client at the same time. Where they are sent in multiple packets, the client will still wait on the final packet, containing the end marker, to display the logically related drawing orders.","In an embodiment, a packet has a minimum packet size, further comprising: sending the packet when the end marker is inserted into the packet, when the minimum packet size of the packet is reached. Where the logically related drawing orders comprise only a few drawing orders, it may not be efficient to send such a small packet, for reasons discussed above. In this case, new drawing orders may be added to the packet until it reaches a minimum packet size, and then it is sent. In an embodiment, the packet is sent once the first end marker has been inserted into it once the minimum packet size has been reached. In an embodiment, the packet is sent once the first end marker has been inserted into it once the minimum packet size has been reached, or a maximum packet size is reached.","In an embodiment, the packet is sent via a plurality of protocol layers, further comprising: flushing the packet to the communications network, by each protocol layer, when detecting the end marker. In an embodiment, the protocol layers for a network comprise application layer (e.g. hyper-text transfer protocol, or HTTP), transport layer (e.g. TCP), internet layer (e.g. internet protocol, or IP), link layer (e.g. Ethernet), and physical layer (e.g. RJ45\/CAT5). Where those layers have a flush command, the end marker may comprise the flush command for each layer, so that by inserting the end marker, the packet is flushed through all layers and sent across the communications network. In an embodiment, where two layers share the same flush command, it is not repeated for each layer.","In an embodiment, the wrapped logically related drawing orders are sent according to a remote desktop protocol (RDP).",{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 5"},"Operation  depicts receiving display data across a communications network. In an embodiment, this data is received as RDP packets as sent by the server as depicted in operation .","Operation  depicts storing the display data in a shadow buffer. In an embodiment, the shadow buffer comprises an area in memory in which drawing commands are rendered to a bitmap representation of those drawing commands. The shadow buffer may correspond to a display buffer, where the data that is displayed on a display device exists. When the data in the shadow buffer is to be displayed, it is then copied to the display buffer, and new data may be rendered to the shadow buffer. In an embodiment, the shadow buffer and the display buffer exist in video memory of the system. In an embodiment, the display data comprises drawing commands. In another embodiment, the display data comprises an image, such as a bitmap.","Operation  depicts determining a begin marker and an end marker in the display data. Where the display data comprises a plurality of drawing commands in an API, this may comprise identifying the commands corresponding to begin_marker( ) and end_marker( ).","Operation  depicts flushing all display data between the begin marker and the end marker to a display surface. Where the display surface corresponds to a display buffer, this may comprise transferring all data in shadow buffer to the display buffer. Where data in the shadow buffer is identified by whether it has been updated since it was last moved to the display buffer, such as with a dirty bit, it may be that only those dirty parts of the shadow buffer are copied to the display buffer.","In an embodiment, there is a timer, and flushing all display data includes flushing all display data between the begin marker and the most recently received display data, including the most recently received display data, when a timer expiration of the timer is reached. Where the end marker is delayed, be it in generation or transport, it may be preferable to display some new display data on the display surface so that the end user does not find the session to be unresponsive, or think that it has frozen. In this case, every time the display buffer is updated, the timer is reset, and if the timer should reach a specified time before an end marker is received, it is flushed to the display surface.","In the embodiment where the timer has expired, then the end marker is received, the operation may then flush all flush all display data received since the timer expiration was reached when end marker is determined.","While the present disclosure has been described in connection with the preferred aspects, as illustrated in the various figures, it is understood that other similar aspects may be used or modifications and additions may be made to the described aspects for performing the same function of the present disclosure without deviating therefrom. Therefore, the present disclosure should not be limited to any single aspect, but rather construed in breadth and scope in accordance with the appended claims. For example, the various procedures described herein may be implemented with hardware or software, or a combination of both. Thus, the methods and apparatus of the disclosed embodiments, or certain aspects or portions thereof, may take the form of program code (i.e., instructions) embodied in tangible media, such as floppy diskettes, CD-ROMs, hard drives, or any other machine-readable storage medium. When the program code is loaded into and executed by a machine, such as a computer, the machine becomes an apparatus configured for practicing the disclosed embodiments. In addition to the specific implementations explicitly set forth herein, other aspects and implementations will be apparent to those skilled in the art from consideration of the specification disclosed herein. It is intended that the specification and illustrated implementations be considered as examples only."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The systems, methods, and computer readable media in accordance with this specification are further described with reference to the accompanying drawings in which:",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
