---
title: Efficient schema for storing multi-value attributes in a directory service backing store
abstract: A database schema for storing application data in a relational database backing store of a directory service. The application data has at least some entries with multiple value attributes. According to the invention, the application data is profiled to determine how it may be optimally stored in the backing store. Preferably, single entries having single value attributes are stored in a merged attribute table, while entries having multiple value attributes are stored in per attribute tables. According to the optimization, a majority of the attributes are single valued and are stored in the merged table, and the per attribute tables thus store a relatively smaller number of exceptions. This database schema enhances processing of conventional directory service queries into the backing store.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06865576&OS=06865576&RS=06865576
owner: International Business Machines Corporation
number: 06865576
owner_city: Armonk
owner_country: US
publication_date: 19990521
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"p":["This application includes subject matter protected by copyright. All rights are reserved.","1. Technical Field","This invention relates generally to providing directory services in a distributed computing environment.","2. Description of the Related Art","A directory service is the central point where network services, security services and applications can form an integrated distributed computing environment. Typical uses of a directory services may be classified into several categories. A \u201cnaming service\u201d (e.g., DNS and DCE Cell Directory Service (CDS)) uses the directory as a source to locate an Internet host address or the location of a given server. A \u201cuser registry\u201d (e.g., Novell NDS) stores information about users in a system composed of a number of interconnected machines. The central repository of user information enables a system administrator to administer the distributed system as a single system image. Still another directory service is a \u201cwhite pages\u201d lookup provided by some e-mail clients, e.g., Netscape Communicator, Lotus Notes, Endora and the like).","With more and more applications and system services demanding a central information repository, the next generation directory service will need to provide system administrators with a data repository that can significantly ease administrative burdens. In addition, the future directory service must also provide end users with a rich information data warehouse that allows them to access department or company employee data, as well as resource information, such as name and location of printers, copy machines, and other environment resources. In the Internet\/intranet environment, it will be required to provide user access to such information in a secure manner.","To this end, the Lightweight Directory Access Protocol (LDAP) has emerged as an IETF open standard to provide directory services to applications ranging from e-mail systems to distributed system management tools. LDAP is an evolving protocol that is based on a client-server model in which a client makes a TCP\/IP connection to an LDAP server, sends requests, and receives responses. The LDAP information model in particular is based on an \u201centry,\u201d which contains information about some object. Entries are typically organized in a specified tree structure, and each entry is composed of attributes.","LDAP provides a number of known functions including query (search and compare), update, authentication and others. The search and compare operations are used to retrieve information from the database. For the search function, the criteria of the search is specified in a search filter. The search filter typically is a Boolean expression that consists of qualifiers including attribute name, attribute value and Boolean operators like AND, OR and NOT. Users can use the filter to perform complex search operations. One filter syntax is defined in RFC 2254.","LDAP thus provides the capability for directory information to be efficiently queried or updated. It offers a rich set of searching capabilities with which users can put together complex queries to get desired information from a backing store. Increasingly, it has become desirable to use a relational database for storing LDAP directory data. Representative database implementations include DB\/2, Oracle, Sybase, Informix and the like. As is well known, Structured Query Language (SQL) is the standard language used to access such databases.","Relational database guidelines (e.g., the First Normal Form) requires that attributes within each tuple are ordered and complete and that searchable domains permit only simple values. Further, simple values cannot be decomposed into multiple values, and they cannot be decomposed into multiple relations. If these guidelines are not followed, the database application becomes quite difficult to manage. Such limitations present difficulties when it is desired to use a relational database as an LDAP backing store. In particular, LDAP allows multi-value attributes. As a result, implementation of the LDAP directory model requires that there is a relation (or table) for each searchable attribute. This \u201cper attribute\u201d table design basically normalizes all the attributes to achieve a manageable implementation. A schema of this type provides a general solution for LDAP applications.","However, for applications which rarely use multi-value attributes, the per attribute table does not perform well for certain functions. In particular, add\/updates are very expensive. Thus, for example, for an entry with ten attributes, more than ten tables need to be updated. As another example, logical operations involving multiple attributes require expensive table joins to perform the operation.","It would be highly desirable to provide a database schema to solve the performance problem of per-attribute tables, especially for directory applications that rarely use multi-value attributes. The present invention solves this problem.","It is a primary object of this invention to provide a flexible and efficient database schema for a directory service having a relational database backing store.","It is another primary object of this invention to solve the performance problem of per-attribute tables, especially for directory applications that rarely use multi-value attributes.","It is yet another primary object of the present invention to provide an efficient method of dealing with multi-value attributes in a directory service, e.g., a service conforming to the Lightweight Directory Access Protocol (\u201cLDAP\u201d).","A still further object of this invention is to extend the LDAP attribute schema to facilitate handling of multi-value attributes in a relational database backing store.","A more general object of this invention is to provide a reliable and scaleable enterprise directory solution, wherein a preferred implementation is LDAP using a DB\/2 backing store.","These and other objects of the invention are achieved by a database schema that includes a so-called \u201cmerged\u201d attribute table. The merged attribute table stores normalized attributes to facilitate database searches. Generally, the merged attribute table stores single value attributes, wherein multi-value attributes are stored in the per attribute tables, however, each attribute can exist either in the merged table, an attribute table or both.","In a preferred embodiment, the present invention describes a database schema for storing application data in a backing store of a directory service. Thus, for example, the directory service is LDAP and the backing store is a relational database, such as DB2. The application data has at least some entries with multiple value attributes. According to the invention, the application data is profiled to determine how it may be optimally stored in the backing store. Preferably, single entries having single value attributes are stored in a merged attribute table, while entries having multiple value attributes are stored in per attribute tables. According to the optimization, a majority of the attributes are single valued and are stored in the merged table, and the per attribute tables thus store a relatively smaller number of exceptions. This database schema enhances processing of conventional directory service queries into the backing store.","The foregoing has outlined some of the more pertinent objects and features of the present invention. These objects and features should be construed to be merely illustrative of some of the more prominent features and applications of the invention. Many other beneficial results can be attained by applying the disclosed invention in a different manner or modifying the invention as will be described. Accordingly, other objects and a fuller understanding of the invention may be had by referring to the following Detailed Description of the preferred embodiment.","A block diagram of a representative LDAP directory service in which the present invention may be implemented is shown in FIG. . As is well-known, LDAP is the lightweight directory access protocol, and this protocol has been implemented in the prior art, e.g., as either a front end to the X.500 directory service, or as a standalone directory service. According to the protocol, a client machine  makes a TCP\/IP connection to an LDAP server , sends requests and receives responses. LDAP server  supports a directory  as illustrated in a simplified form in FIG. . Each of the client and server machines further include a directory \u201cruntime\u201d component  for implementing the directory service operations as is described below. The directory  is based on the concept of an \u201centry\u201d , which contains information about some object (e.g., a person). Entries are composed of attributes , which have a type and one or more values. Each attribute  has a particular syntax that determines what kinds of values are allowed in the attribute (e.g., ASCII characters, jpeg file, etc.) and how these values are constrained during a particular directory operation.","The directory tree is organized in a predetermined manner, with each entry uniquely named relative to its sibling entries by a \u201crelative distinguished name\u201d (RDN). An RDN comprises at least one distinguished attribute value from the entry and, at most, one value from each attribute is used in the RDN. According to the protocol, a globally unique name for an entry, referred to as a \u201cdistinguished name\u201d (DN), comprises a concatenation of the RDN sequence from a given entry to the tree root.","The LDAP search can be applied to a single entry (a base level search), an entry's children (a one level search), or an entire subtree (a subtree search). Thus, the \u201cscope\u201d supported by LDAP search are: base, one level and subtree. LDAP does not support search for arbitrary tree levels and path enumeration.","LDAP includes an application programming interface (API), as described in \u201cThe C LDAP Application Program Interface\u201d, IETF Working Draft, Jul. 29, 1997, which is incorporated herein by reference. An application on a given client machine uses the LDAP API to effect a directory service \u201csession\u201d according to the flowchart of FIG. . At step , an LDAP session with a default LDAP server is initialized. At step , an API function ldap_init( ) returns a handle to the client, and this handle may allow multiple connections to be open at one time. At step , the client authenticates to the LDAP server using, for example, an API ldap_bind( ) function. At step , one or more LDAP operations are performed. For example, the API function ldap_search( ) may be used to perform a given directory search. At step , the LDAP server returns the results of the directory search, e.g., one or more database elements that meet the search criteria. The session is then closed at step  with the API ldap_unbind( ) function then being used to close the connection.","It may be desirable to store LDAP directory data in a backing store.  illustrate several representative LDAP directory service implementations that use a relational database management system (RDBMS) for this purpose. These systems merely illustrate possible LDAP directory services in which the present invention may be implemented. One of ordinary skill should appreciate, however, that the invention is not limited to an LDAP directory service provided with a DB\/2 backing store. The principles of the present invention may be practiced in other types of directory services (e.g., X.500) and using other relational database management systems (e.g., Oracle, Sybase, Informix, and the like) as the backing store.","In , an LDAP client  can connect to a number of networked databases -through an LDAP server . The databases -contain the directory information. However, from the user's perspective, the LDAP server  stores all the information without knowing the database  in which the data is actually located. With this configuration, the LDAP server  is freed from managing the physical data storage and is able to retrieve information from multiple database servers  which work together to form a huge data storage.",{"@attributes":{"id":"P-00037","num":"00037"},"figref":"FIG. 4B","b":["36","38","38","38","36","36","37","36"],"i":["a","n "]},"One of ordinary skill should appreciate that the system architectures illustrated in  are not to be taken as limiting the present invention. The inventive technique may be used to search any relational database using hierarchical, filter-based database queries.","Implementation of the LDAP directory model requires that there is a relation (or table) for each searchable attribute. This is sometimes referred to as a \u201cper attribute\u201d table database schema. For applications that rarely use multi-value attributes, the per attribute table does not perform well for certain operations. The present invention solves this problem by providing a new database schema wherein a so-called \u201cmerged\u201d attribute table is used to store single value attributes. A simplified illustration of the inventive schema is shown in FIG. .","As illustrated in this drawing, the novel schema comprises the merged attribute table  and the set of per attribute tables -. A given set of per attribute tables is sometimes referred to herein as an \u201coverflow\u201d table. According to the present invention, single value attributes  are stored into the merged table , and multiple value attributes  are typically stored in the per attribute tables . As will be seen, however, each attribute can exist in the merged table, the per attribute tables, or both.","In the LDAP Version 3.0 schema, attributes having a single value are specified by a SINGLE-VALUE keyword. For example, the attribute \u201cc\u201d contains a two-letter ISO 3166 country code (countryName). The schema definition of \u201cc\u201d is then as follows: (2.5.4.6 NAME \u2018c\u2019 SUP name SINGLE-VALUE). For attributes  that are not specified as a single-value attribute in the schema, according to the invention, the default is a multi-value attribute.","In certain circumstances, it may not be desirable to place all multi-value attributes in the per attribute tables. For example, even though the attribute is specified as a multi-value attribute in the standard schema, the user application may only have a single value in the entry. Another problematic situation arises when the attribute is truly multi-valued, yet a significant number of entries contain more than one value for the attribute. Thus, according to the present invention, it is desirable to parse the application data to be stored in the backing store to determine an optimal configuration for populating the merged attribute table. This process is illustrated in the block diagram of FIG. .","As illustrated in this figure, application data to be stored in the backing store is first profiled by a parsing routine . The parsing routine may be any given data analysis tool, e.g., an LDIF file, a Lotus Notes NAB or a collection of database records. The output of the parsing routine is a file  that preferably comprises the following information for each attribute:\n\n","The following is an example of the output file  generated from the ldif file of representative directory data:\n\n","In the example above, it can be seen that only a relatively small number of entries have multiple values for the attributes OFFICE PHONE and MANAGER, while the NAME attribute has none (in this example). In other words, all of the people in the representative directory have only one name.","The output of the parsing routine  is then used to instruct the directory service as to the optimal way to organize the data stored in the database. In particular, after the data profiling output file  is generated, a schema generator  uses the profiling output to generate the schema file  for the LDAP server. With the example above, the following are representative attribute definitions in the schema file :\n\n","As will be described, the single value attributes (NAME, for example) preferably are stored in the merged table. For those attributes that have a small number of multiple values (OFFICE PHONE and MANAGER, for example), they are stored both in the merged table and the per attribute table. The schema file  generated by the schema generator  is used by the LDAP server daemon.",{"@attributes":{"id":"P-00076","num":"00076"},"figref":"FIG. 7","b":["76","78"]},"At step , the routine determine the optimum storage of the data based on the profile. At step , given data is stored in an attribute table. At step , other given data is stored in a merged table. As noted above, preferably the merged table is used for entries with single value attributes. Preferably, a majority of the data is stored in the merged table and a small set of additional values for the multiple value attributes are stored in the per attribute tables.","The following is a more detailed explanation of the external user schema and internal database schema according to the present invention.","User Schema","The LDAP V3 attribute schema is extended to include the following information for each attribute. For the keyword MERGETBL, the first item on the keyword list is the relational database (e.g., DB2) table name for the merged table, and the second item on the list is the DB2 column name in the merged table. For the keyword ATTRTBL, the first item on the list is the DB2 table name for the per attribute table, and the second item on the list is the DB2 column name in the attribute table. For the keyword INDEX, the character \u2018F\u2019 in the list represent regular indexes, and the character \u2018R\u2019 in the list represents reverse indexes. Of course, the particular characters used are merely exemplary.","Each attribute can exist either in the merged table, the per attribute table, or both, depending on the characteristics of the given application data. The following is an example of the extended attribute schema definition for the X.500 surname attribute, which contains the family name of a person:\n\n","This schema information preferably is included in a a distinct configuration file, in this example, a file called slapd.ext.conf. For attributes that do not show up in the extended configuration file, a per attribute table is created as has been previously described. In a representative embodiment, the merged and per attribute tables are stored in the relational database, which may be DB2. In a DB2 embodiment, if the attribute name is less than 15 characters, the DB2 table name and column name preferably are the attribute name. If, however, the attribute name is longer than 15 characters, preferably the attribute name is truncated to 15 characters and a two digit counter value is appended at the end to create a table name. If the table name exists, the counter is incremented and an attempt is then made to create the table. Preferably, the column name is the same as the table name.","DB2 Schema","The following is the schema for the merged attribute table in the preferred embodiment using DB2 as the relational database backing store.","Merged Attribute Table","The purpose of the merged attribute table is to store normalized attributes to assist during the search function. As illustrated in , a column of this table is created when the attribute is a single-value attribute and the attribute syntax is not binary. If the user does not specify whether the attribute is a single or multi-valued attribute, the merged table creates a new column in the merged table if the MERGETBL keyword appears in the slapd.ext.conf file for this attribute. A reverse column is created if the INDEX keyword appears in the slapd.ext.conf file for this attribute and the \u2018R\u2019 option is specified. A DB2 index is created for the reversed data column. A DB2 index is created if the INDEX keyword appears in the slapd.ext.conf file.","Attribute Table","The attribute table is created if the attribute does not appear in the slapd.ext.conf file, or if the attribute appears in the slapd.ext.conf file and ATTRTBL keyword is specified. The attribute table is also created when the attribute value is a truncated value. If the length of the column is longer than 240 bytes, for example, a truncated column is created for indexing. A reverse column is created if the INDEX keyword appears in the slapd.ext.conf file for this attribute and the \u2018R\u2019 option is specified. A DB2 index is created for the reversed data column.","A DB2 index also is created if the INDEX keyword appears in the slapd.ext.conf file. In particular, if the max length of the attribute is longer than 240 bytes, for example, the index is created on the truncated column. If the max length of the attribute is less than 240 bytes, for example, the index is created on the attribute column.","LDAP Filter to SQL Translation","One of the main functions of LDAP\/DB2 is to translate the LDAP filter an expression into SQLs. A filter translator (rdbm_xlfilter.c) is used to generate the equivalent SQL expression corresponding to an LDAP filter that can be used in the WHERE clause of an SQL SELECT statement. The following describes the translation that is performed to generate the SQL expressions. The LDAP filter translator also generates the list of SQL tables needed for the FROM clause.",{"@attributes":{"id":"P-d0e2623","num":"00002"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Base Level Search:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SELECT entry.EntryData,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"from ldap_entry as entry"]},{"entry":[{},"where entry.EID in ("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"select distinct ldap_entry.EID"]},{"entry":[{},"from <table list>"]},{"entry":[{},"where (ldap_entry.EID=<root dn id> )"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<sql where expressions>)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"One Level Search:"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SELECT entry.EntryData,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"from ldap_entry as entry"]},{"entry":[{},"where distinct ldap_entry.EID"]},{"entry":[{},"from ldap_entry, <table list>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ldap_entry as pchild, <list of tables>"]},{"entry":[{},"where ldap_entry.EID=pchild.EID"]},{"entry":[{},"AND pchild.PIED=<root dn id>"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"<sql where expressions>)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"Subtree Search"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"SELECT entry.EntryData,"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"from ldap_entry as entry"]},{"entry":[{},"where entry.EID in ("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"select distinct ldap_entry.EID"]},{"entry":[{},"from ldap_entry, ldap_desc, <table list>"]},{"entry":[{},"where"]},{"entry":[{},"(LDAP_ENTRY.EID=ldap_desc.DEID AND"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ldap_desc.AEID=<root dn id>)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"ldap_entry as pchild. <table list>"]},{"entry":[{},"where ldap_entry.EID=ldap_desc.EID"]},{"entry":[{},"AND ldap_desc.AEID=%d <where expressions>)."]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In the above representation, <table list> and <where expression> are the two null terminated strings returned by the SQL generator. The <root dn id> is the unique identifier of the root dn. The where clause should only be generated if <where expression> is not the empty string and no errors where detected in the parsing the LDAP filter.","The following is the detailed description of the LDAP filter to SQL translation rules. In the translation rules, the attr_tablename is the attribute table for the specified attribute and attr_columnname is the column name containing the attribute values. The tablename is the name of the merged table. The column name is the column name containing the attribute values. The filter translator invokes an attr_get_info function that returns the rdbm_attr_info data structure, which contains the fully qualified SQL tables name and column name corresponding to the specified attribute name.\n\n","If two tables exists in the rdbm_attr_info data structure, the equality type LDAP filter \u201c(attribute=value)\u201d is translated to:\n\n","If only one table exists in the rdbm_attr_info data structure, the equality type LDAP filter \u201c(attribute=value)\u201d is translated to:\n\n","If two tables exists in the rdbm_attr_info data structure, the greater or equal type LDAP filter \u201c(attribute>=value)\u201d is translated to\n\n","If only one table exists in the rdbm_attr_info data structure, the equality type LDAP filter \u201c(attribute>=value)\u201d is translated to:\n\n","If two tables exists in the rdbm_attr_info data structure, the less or equal type LDAP filter \u201c(attribute>=value)\u201d is translated to\n\n","If only one table exists in the rdbm_attr_info data structure, the equality type LDAP filter \u201c(attribute<=value)\u201d is translated to:\n\n","If two tables exists in the rdbm_attr_info data structure, the sub-string type LDAP filter \u201c(attribute=value-with-stars)\u201d is translated to\n\n","If only one table exists in the rdbm_attr_info data structure, the equality type LDAP filter \u201c(attribute=value-with-stars)\u201d is translated to:\n\n","If two tables exists in the rdbm_attr_info data structure, the sub-string type LDAP filter \u201c(attribute=*)\u201d is translated to\n\n","If only one table exists in the rdbm_attr_info data structure, the presence type LDAP filter \u201c(attribute=*)\u201d is translated to:\n\n","If two tables exists in the rdbm_attr_info data structure, the sub-string type LDAP filter \u201c(attribute\u02dc=value)\u201d is translated to\n\n","If only one table exists in the rdbm_attr_info data structure, the equality type LDAP filter \u201c(attribute\u02dc=value)\u201d is translated to:\n\n","The above translation rules can be combined into complex LDAP filters using AND, OR, and NOT operators & or | or !. The AND operator & can be used for the Boolean AND of any number of LDAP filters which can be simple or complex. The OR operator | can be used for the Boolean OR of any number of LDAP filters which can be simple or complex. The NOT operator ! can be used for the Boolean NOT of a single LDAP filter that may be simple or complex.","Basically, LDAP logic operator & is translated into SQL INTERSECT to intersect results from multiple SELECT statements. LDAP operator | is translated into SQL UNION to union results from multiple SELECT statements. The LDAP NOT operator ! is translated into SQL NOT IN to exclude results from a select statement. This process is described in more detail in copending application Ser. No. 09\/160,022, assigned to the assignee of this application, the disclosure of which is incorporated herein by reference.","A few examples (using the Nested Select function) are given below to show the equivalent SQL expressions that are generated for some typical LDAP filters. Because SQL parameter markers are used in the query, the question marks (?) in the query represent the attribute values in the LDAP filter.\n\n","A prototype has been developed to measure the performance improvements of the inventive database schema. The prototype simulates how the tables are populated in ldap_add with per attribute tables and the merged table.","For Scenario 1 above, when all indexes include 1036 entries and 10 attributes, the merged table includes 715 secs and the attribute table includes 2221 secs. For Scenario 2, in which no indexes except EID on ldap_entry are included and 1036 entries and 10 attributes are included, the merged table includes 587 secs and the attribute table includes 2081 secs.","Experiments were performed with 9000 entries. Based on these experiments, it was found that the time it takes to populate the merged table was about one third of the per attribute table.","As noted above, the invention may be implemented in any hierarchical directory service in which a relational database management system (RDBMS) is used to provide a backing store function. Thus, for example, the principles of the invention may be carried out in an X.500 directory service or hereinafter-developed LDAP implementations. The SQL query generated according to the present invention is used to access the relational database, and results are then returned in response to this query. The invention may also be implemented within a relational database management system being used as an add-on to a directory service. One of ordinary skill will appreciate that the invention can be applied to any relational database management system (RDBMS) and not simply DB\/2, the implementation described above. Thus, for example, the relational database may be Oracle, Sybase or any other third party supplied backing store. In addition, the EID sets approach can also be applied to b-tree based LDAP server implementation.","Moreover, although the preferred embodiment has been described in the context of generating a Structured Query Language (SQL) query, the inventive technique should be broadly construed to extend to any relational database query language.","One of the preferred embodiments of the routines of this invention is as a set of instructions (computer program code) in a code module resident in or downloadable to the random access memory of a computer.","Having thus described our invention, what we claim as new and desire to secure by Letters Patent is set forth in the following claims:"],"heading":["BACKGROUND OF THE INVENTION","BRIEF SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a more complete understanding of the present invention and the advantages thereof, reference should be made to the following Detailed Description taken in connection with the accompanying drawings in which:",{"@attributes":{"id":"P-00023","num":"00023"},"figref":"FIG. 1"},{"@attributes":{"id":"P-00024","num":"00024"},"figref":"FIG. 2"},{"@attributes":{"id":"P-00025","num":"00025"},"figref":"FIG. 3"},{"@attributes":{"id":"P-00026","num":"00026"},"figref":"FIGS. 4A-4B"},{"@attributes":{"id":"P-00027","num":"00027"},"figref":"FIG. 5"},{"@attributes":{"id":"P-00028","num":"00028"},"figref":"FIG. 6"},{"@attributes":{"id":"P-00029","num":"00029"},"figref":"FIG. 7"},{"@attributes":{"id":"P-00030","num":"00030"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
