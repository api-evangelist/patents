---
title: Method and apparatus for implementing packet command instructions for network processing
abstract: A method, apparatus and computer program product are provided for implementing packet command instructions for network processing. A set of packet commands is provided. Each packet command defines a corresponding packet operation. A command from the set of packet commands is issued to perform the defined corresponding packet operation. A packet buffer structure hardware is provided for performing one or more predefined packet manipulation functions responsive to the issued command.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07617332&OS=07617332&RS=07617332
owner: International Business Machines Corporation
number: 07617332
owner_city: Armonk
owner_country: US
publication_date: 20030501
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","RELATED APPLICATIONS","DESCRIPTION OF THE RELATED ART","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["The present invention relates generally to the data processing field, and more particularly, relates to a method, apparatus and computer program product for implementing packet command instructions for network processing.","Related United States patent applications assigned to the present assignee are being filed on the same day as the present patent application including:","U.S. patent application Ser. No. 10\/427,864, U.S. Pat. No. 7,240,166 issued Jul. 3, 2007, by Paul Allen Ganfield, and entitled \u201cMETHOD AND APPARATUS FOR IMPLEMENTING PACKET WORK AREA ACCESSES AND BUFFER SHARING\u201d; and","U.S. patent application Ser. No. 10\/427,886, by Kent Harold Haselhorst, Kerry Christopher Imming, and John David Irish, and entitled \u201cMETHOD AND APPARATUS FOR IMPLEMENTING VIRTUAL PACKET STORAGE VIA PACKET WORK AREA\u201d.","One of the main functions of a network processor is to take incoming packets or frames, and perform manipulations or alterations on the headers and payloads for the purpose of implementing certain network protocols as required by a particular application. These operations can be done in the core processor but results in a user application that is tightly coupled to a specific network processor implementation. Since these operations may involve the manipulation of multiple data structures, many processor instructions are involved to complete. As a result, these operations consume a significant portion of the available processing power.","A need exists for an improved mechanism for implementing network processing. A need exits for such a mechanism that enables higher performance, minimizing required processor operations.","A principal object of the present invention is to provide a method, apparatus and computer program product for implementing packet command instructions for network processing. Other important objects of the present invention are to provide such a method, apparatus and computer program product for implementing packet command instructions for network processing substantially without negative effect and that overcome many of the disadvantages of prior art arrangements.","In brief, a method, apparatus and computer program product are provided for implementing packet command instructions for network processing. A set of packet commands is provided. Each packet command defines a corresponding packet operation. A command from the set of packet commands is issued to perform the defined corresponding packet operation. A packet buffer structure hardware is provided for performing one or more predefined packet manipulation functions responsive to the issued command.","Having reference now to the drawings, in , there is shown a network processor system generally designated by the reference character  for carrying out methods for implementing packet command instructions for network processing of the preferred embodiment. As shown in , network processor system  includes a network processor  coupled to multiple network ports for communicating using known network protocols, such as, an Asynchronous Transfer Mode (ATM), Ethernet, and the like. Network processor  includes a control processor , a dataflow processor  coupled by a network processor bus to dataflow assist hardware (HW)  coupled to the network ports and an input\/output (I\/O)  coupled to peripheral devices. Network processor system  includes a system memory  including a dynamic random access memory (DRAM) .","Network processor  can be implemented with various standard processors, for example, with one of the PowerPC\u00ae line of processors manufactured by International Business Machines Corporation.","In accordance with features of the preferred embodiment, a set of commands or instructions is provided for manipulating packet data within network processor . Designated logic  performs manipulations on frames as instructed by the dataflow or core processor  enabling higher performance than conventional network processor arrangements. This logic  is controlled by the set of packet commands. These commands constitute an application programming interface (API) that provides an abstraction layer that decouples software from a specific hardware implementation. Software issues a command to perform a specific packet operation, for example, split a packet in two fragments, and dataflow assist hardware  provides the multiple operations required to find the split point and create the two resulting fragments. The abstraction enables a range of performance levels in dataflow assist hardware  and allows future implementation optimizations without impacting user software. The control structure manipulation required to complete the packet operation is performed by the dataflow assist hardware  while the processor  is free to continue processing. A command queue is provided along with hardware enforced command interlocks such that software can issue a sequence of commands without waiting for the individual commands to complete. The command set is defined to enable all packet manipulations needed to implement current network protocols. The current command set can easily be extended if any new packet manipulation functions are required in future network processors.","In accordance with features of the preferred embodiment, the packet command set allows user software to manipulate packet data in an abstract data view, decoupling user code from a specific hardware implementation. The hardware independence allows a range of performance levels and provides for future implementation optimizations without impacting user code. The hardware implementation executes these commands with pointer manipulations, eliminating any unnecessary copying of the data. Avoiding data copying conserves precious memory bandwidth, which reduces the product cost associated with providing memory bandwidth (chip pins) and the related power consumption.","This command set of the preferred embodiment is enabled by the flexible buffer structure disclosed in the above-identified patent application entitled METHOD AND APPARATUS FOR IMPLEMENTING VIRTUAL PACKET STORAGE VIA PACKET WORK AREA. The subject matter of the above-identified patent application is incorporated herein by reference.",{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 2","b":"200"},{"@attributes":{"id":"p-0023","num":"0022"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE 1"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Packet Commands"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"77pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Function","Minemonic","Operation"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Allocate Packet","PKT_allocate(PT,PoolID)","Allocate a storage"]},{"entry":[{},{},"area for packet data"]},{"entry":["Split Packet","PKT_split(PT,PS,offset)","Split packet PS at"]},{"entry":[{},{},"byte \u201coffset\u201d within"]},{"entry":[{},{},"the packet and"]},{"entry":[{},{},"append the first part to"]},{"entry":[{},{},"packet PT."]},{"entry":["Packet Tail","PKT_tail(PT,PS,offset)","Split packet PS at"]},{"entry":[{},{},"byte \u201coffset\u201d within"]},{"entry":[{},{},"the packet and"]},{"entry":[{},{},"append the tail to"]},{"entry":[{},{},"packet PT."]},{"entry":["Join Packets","PKT_join(PT,PS)","Append packet PS"]},{"entry":[{},{},"onto packet PT."]},{"entry":["Header Delete","PKT_hdr_delete(PT,N)","Delete N bytes from"]},{"entry":[{},{},"the head of packet PT"]},{"entry":["Enqueue Packet","PKT_enqueue(queue,PS)","Enqueue packet PS"]},{"entry":[{},{},"onto \u201cqueue\u201d"]},{"entry":["Enqueue Multi-","PKT_enqueue","Enqueue packet PS"]},{"entry":["cast Packet","MC(queue,PS)","onto \u201cqueue\u201d and"]},{"entry":[{},{},"keep packet PT for"]},{"entry":[{},{},"additional operations."]},{"entry":["Discard Packet","PKT_discard(PS)","Discard packet PS,"]},{"entry":[{},{},"freeing any allocated"]},{"entry":[{},{},"resources."]},{"entry":["Packet Accept","PKT_accept(PT)","Remove packet PT"]},{"entry":[{},{},"from the ordering"]},{"entry":[{},{},"queue."]},{"entry":["Dequeue Packet","PKT_dequeue","Accept the packet at"]},{"entry":[{},"(PT, group, mask)","the head of queue"]},{"entry":[{},{},"indicated by group"]},{"entry":[{},{},"and mask into PT."]},{"entry":["Link Packets","PKT_link(PT,PS,offset)","Link packet PT into"]},{"entry":[{},{},"packet PS, at byte"]},{"entry":[{},{},"\u201coffset\u201d."]},{"entry":["Copy Packet","PKT_copy(PT,PS)","Copy packet PS into"]},{"entry":[{},{},"packet PT."]},{"entry":["Synchronize","PKT_sync","Ensure that interrupts"]},{"entry":[{},{},"from any outstanding"]},{"entry":[{},{},"commands have been"]},{"entry":[{},{},"recorded."]},{"entry":["Load\/Packet Data","lw PT,offset(PWA(n)","Load packet data into"]},{"entry":[{},{},"a processor register"]},{"entry":[{},{},"from \u201coffset\u201d within the"]},{"entry":[{},{},"memory mapped"]},{"entry":[{},{},"PWA. PWA(n)"]},{"entry":[{},{},"represents a base"]},{"entry":[{},{},"register initialized"]},{"entry":[{},{},"to the origin of the"]},{"entry":[{},{},"correct PWA. Any"]},{"entry":[{},{},"valid load instruction"]},{"entry":[{},{},"and addressing mode"]},{"entry":[{},{},"can be used for lw."]},{"entry":["Store Packet Data","stw PT,offset(PWA(n))","Store data into a"]},{"entry":[{},{},"packet at \u201coffset\u201d"]},{"entry":[{},{},"within the memory"]},{"entry":[{},{},"mapped PWA."]},{"entry":[{},{},"(PWA(n))represents"]},{"entry":[{},{},"a base register"]},{"entry":[{},{},"initialized to the"]},{"entry":[{},{},"of the correct PWA."]},{"entry":[{},{},"Any valid store"]},{"entry":[{},{},"instruction and"]},{"entry":[{},{},"addressing mode can"]},{"entry":[{},{},"be used for stw."]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}},"br":{}},"Referring now to , an exemplary packet condition register generally designated by reference character  and a packet storage interrupt status register (PSISR) generally designated by reference character  are shown in .  provides an exemplary bit definition generally designated by reference character  for the packet condition register  in accordance with the preferred embodiment. Packets have an associated state that determines which type of packet operations are allowed as follows: A Normal state is the default state of a packet. A Multi-cast state for a packet is Read Only because other packets link into the packet, or because the packet is enqueued with a PKT_enqueue_MC command and is also referred to as a reference packet. A Linked state defines a packet that is linked to a multi-cast packet that cannot be used as the operand for another PKT_link command.","The Packet Condition register  allows software to query the status of a packet referenced by PSR. The packet condition register  has 4 bits, a 3-bit state and a busy bit, per PSR. CRO . . . 7 is associated with PSRO . . . 7. The packet states are Normal, Multi-Cast, Linked, Corrupt, and NULL. Loading an existing PID into a PSR causes the packet condition register  to be updated with the current state. The corresponding CR field will report busy until the state field is correct.","Packet commands appear to execute in the order they are issued by software. The implementation is required to detect any result\/operand dependencies and enforce ordering. By the same token, an implementation may reorder commands as long as the results of future commands and packet storage accesses are not affected.","A command that targets a PSR marks that packet and the associated PWA busy in the packet condition register  until the command has completed. Any future command dependent on these previous results will be stalled until the previous command completes. If the target of a command cannot be determined by the time a subsequent command is received, all potential targets must be assumed busy until the exact targets can be determined.","To prevent result\/operand interlocks from stalling commands, commands that use results from an earlier command should be separated by as much time or instructions as practical. If it is helpful in prioritizing operations, software can query the PSR status in the packet condition register  to determine if a command has completed prior to issuing a dependent command.","A Packet Storage Interrupt (PSI) occurs when a packet command or an access to the PWA cannot be completed. A command that causes a PSI will appear not to have executed. A command that causes a PSI will have no other effect on operands or facilities. An exception is the PKT_copy command which may run out of hardware resources after partially executing. Once the error condition has been corrected, restarting (re-executing) the PKT_copy command will produce correct results.","The interrupt cause is defined in the Packet Storage Interrupt Status register (PSISR) . The PKT_ID or the PWA address is recorded in a Packet Address register (PAR) (not shown). A Packet Interrupt Command register (PICR) (not shown) records the command that causes the error. The Packet Address register PAR is set to the address of the attempted access if the error was caused by a load or store to the PWA. Otherwise, if the error was caused by a packet command, the Packet Address register is set to the PKT_ID of the packet that caused the error.","Exemplary bit assignments for Packet Storage Interrupt Status register (PSISR)  are provided in the following Table 2:",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 2"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Example Bit Definitions for PSISR 310"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"0 - Set 1 if the address recorded in the PAR is a PWA address. In all other"},{"entry":"cases, the address is a PKT_ID."},{"entry":"1 - Set to 1 if the PICR was loaded with the offending packet command."},{"entry":"The PICR is loaded for every packet command that causes an interrupt."},{"entry":"PowerPC commands that generate a PSI are not captured since they do not"},{"entry":"use the PKT_Cmd register."},{"entry":"2 - Set to 1 to indicate that an execution of an invalid instruction was"},{"entry":"attempted. The PICR is loaded with the offending command."},{"entry":"3 \u2014Set to 1 to indicate that an equeue of a message PID was attempted to"},{"entry":"RX queue 0-7, a TX queue, or the discard queue."},{"entry":"4 - Set to 1 to indicate that a command was attempted with offset greater"},{"entry":"than or equal to the packet length."},{"entry":"5 - Set to 1 to indicate that an allocate or dequeue was attempted with"},{"entry":"PT != NULL."},{"entry":"6 - Set to 1 to indicate that a store was attempted to read-only packet or"},{"entry":"load or store was attempted to a NULL packet or a message PID."},{"entry":"The PWA address is captured in the PAR."},{"entry":"7 - Set to 1 to indicate that a PKT_split, PKT_tail PKT_join, or"},{"entry":"PKT_hdr_delete command was attempted to a read-only packet or that a"},{"entry":"PKT_copy was attempted with the target being Read Only."},{"entry":"8 - Set to 1 to indicate that a link command was attempted with a source or"},{"entry":"target packet in an invalid packet state, or that a PKT_enqueue_MC was"},{"entry":"attempted to a linked packet."},{"entry":"9 - Set to 1 to indicate that the length specified in the packet control area"},{"entry":"was greater than the length of the actual packet data. The PID of the"},{"entry":"offending packet is captured in the PAR."},{"entry":"10 - Set to 1 to indicate than an RX or TX queue overflow occurred."},{"entry":"11 - Set to 1 to indicate that a command failed due to internal hardware"},{"entry":"resources constraints."},{"entry":"12 - Set to 1 if a packet was lost due to a hardware fault. Examples of such"},{"entry":"a hardware fault are a parity error in an on-chip SRAM or a parity error in"},{"entry":"a buffer descriptor in external memory when ECC is not being used."},{"entry":"13 - Set to 1 to indicate that a PKT_Sync instruction has completed"},{"entry":"execution."},{"entry":"14 - Set to 1 to indicate that a second error has occurred. PICR and PAR"},{"entry":"record the command and address associated with the FIRST error that"},{"entry":"occurred. Consequently, a PSISR bit will be set for a second interrupt, but"},{"entry":"the command and address will not be captured."},{"entry":"15 - Reserved."},{"entry":"16 - Set to 1 to indicate that a PID was enqueued out-of-order. This occurs"},{"entry":"when the PID enqueued does not match the top of any ordering queues."},{"entry":"17 - Set to 1 to indicate that a packet command was attempted with PSRs"},{"entry":"containing the same PID. This can occur on any two-operated packet"},{"entry":"commands (for example, trying to PKT_join a packet to itself."},{"entry":"18 - Set to 1 to indicate that an invalid PID was detected on a write to a"},{"entry":"PSR. The PID is captured in the PAR."},{"entry":"19 - Set to 1 to indicate that a packet command was attempted using a PSR"},{"entry":"containing a message PID."},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIGS. 4-23","FIG. 2"],"b":"200"},"Referring now to , there is shown a packet allocate command format generally designated by reference character  in accordance with the preferred embodiment. In the illustrated PKT_allocate(PT, Pool_ID) command format , PT indicates a PSR target (PT). PKT_allocate allocates an empty packet by requesting a packet buffer in the specified pool, Pool_ID. A specific size of the allocated buffer is determined, for example, by the \u201cBuffer Size\u201d and \u201cAllocation Sequence\u201d fields in a Global Configuration register. A unique (PID) for the new buffer is returned in PT, the target PSR.","If no buffers are available, the NULL PID is returned in PT and a PSI is generated with PSISR bit  set. If initial [PT] !=NULL, a PSI is generated with PSISR bit  set.","PKT_allocate creates a new packet that can be used as the target of a PKT_copy, PKT_split, or PKT_tail command. The new packet can also be written to directly to create a packet from scratch.","Referring now to , a packet copy command format generally designated by reference character  in accordance with the preferred embodiment is shown in .  illustrates a packet copy command example generally designated by reference character  in accordance with the preferred embodiment. In the illustrated PKT_copy (PT, PS) command format , PS indicates a PSR source (PS). PKT_copy copies packet PS to packet PT. Both packet data and Packet Control Blocks are copied. If PS==NULL, the length of PT is set to 0. If PT==NULL, a new packet is allocated in the same memory pool as PS.","PKT_copy performs a physical copy. Data is physically moved into a new data structure versus shared buffers via pointer manipulation.","Both PS and PT are marked busy while the copy is in progress. Writes to the target packet will be delayed until the requested packet is no longer busy. The target of w=PKT_copy must not be a Read Only packet, or a PSI is generated. If PS==PT, the instruction form is invalid.","Typically, the target of a PKT_copy is a newly allocated packet. If a packet has become fragmented due to PKT_spllit and\/or PKT_join operations, the new copy of the packet will be defragmented. Software should always copy to a null packet if defragmentation is desired. In other words, if the target of a copy operation is an existing, fragmented packet, software should assume that the target packet after the PKT_copy command will also be fragmented. Future implementation may not defragment all copy operations.","Referring now to , there are shown a packet split command format generally designated by reference character  and a packet split command example generally designated by reference character  in accordance with the preferred embodiment. The packet split command, PKT_split(PT, PS, offset), splits \u201coffset\u201d bytes from the head of packet PS and appends them to packet PT. If PT==NULL, a new packet is allocated for PT in the same memory pool as PS.","PKT_split splits one packet into two packets. This can be used to repeatedly split the head fragment from a packet for functions like IP Fragmentation or Multi-Link PPP.","The PKT_split command changes the PWA to physical address mapping of the PS and PT packets, thus any cached data for these PWAs must be flushed prior to executing the command or the results will be boundedly undefined. If PS==PT, the instruction form is invalid.","In certain implementations, the PKT_split operation may cause the physical storage holding the payload data of packet PS to become shared with packet PT. In this case, a counter referred to as a Buffer Sharing Counter (BSC) is associated with the shared storage to prevent it from being discarded while it is still being used.","Referring now to , there are shown a packet tail command format generally designated by reference character  and a packet tail command example generally designated by reference character  in accordance with the preferred embodiment. The packet tail command PKT_tail (PT, PS, offset) splits the tail from packet PS at offset \u201coffset\u201d within the packet data and appends it to packet PT. If PT==NULL, a new packet is allocated in the same memory pool as PS.","PKT_tail splits one packet into two packets. This can be used as a flexible frame alteration that allows any number of bytes of data to be inserted into a packet with a series of PKT_tail and PKT_join commands.","This PKT_tail command changes the PWA to physical address mapping of the PS and PT packets, thus any cached data for these PWAs must be flushed prior to executing the command or the results will be boundedly undefined. If PS==PT, the instruction form is invalid.","In certain implementations, the PKT_tail operation may cause the physical storage holding the payload of packet PS to become shared with packet PT. In this case, a counter referred to as a Buffer Sharing Counter (BSC) will be with the shared storage to prevent it from being discarded while it is still being used.","Referring now to , there are shown a packet join command format generally designated by reference character  and a packet join command example generally designated by reference character  in accordance with the preferred embodiment. The packet join command PKT_join (PT, PS) joins packet PS to the tail of packet PT. PS is set to a zero-length packet. If PT==NULL, a new packet is allocated in the same memory pool as PS.","PKT_join concatenates two packets into one. This can be used as a flexible frame alteration that would allow any number of bytes of data to be inserted into a packet with a series of PKT_split and PKT_join commands.","The PKT_join command changes the PWA to physical address mapping of the PS and PT packets, thus any cached data for these PWAs must be flushed prior to executing the command of the results will be boundedly undefined.","Referring now to , there are shown a packet header delete command format generally designated by reference character  and a packet header delete command example generally designated by reference character  in accordance with the preferred embodiment. The packet header delete command PKT_hdr_delete (PT, N) deletes N bytes from the head of packet PT. If N>PT length, the resultant PT will be a zero-length packet.","The packet header delete command provides an accelerated header delete function which, in some implementations, is significantly more efficient than the PKT_allocate, PKT_split, PKT_discard sequence that would otherwise be required. In some implementations, PKT_hdr_delete results in a simple change to a pointer in a buffer descriptor for the common case of an unfragmented packet.","Referring now to , there are shown a packet link command format generally designated by reference character  and a packet link command example generally designated by reference character  in accordance with the preferred embodiment. The packet link command PKT_link (PT, PS, offset) links packet PS at offset \u201coffset\u201d to the tail of packet PT. Part of packet PS is now shared between packets PS and PT. If PT==NULL, a new packet is allocated in the same memory pool as PS.","PKT_link creates two packets with a common payload. This is primarily used to create multicast packets by creating a new header in packet PT and linking the payload, at \u201coffset\u201d within PS, to the new header. After a PKT_link command is executed, a counter is associated with packet PS. This counter, which is called a Multicast Counter (MCC), keeps track of the number of packets sharing the common payload. Each time the payload of packet PS is linked to a new PT, the MCC is incremented. The MCC is used by hardware to prevent the PS's payload from being discarded while it is linked to one or more packets. The MCC itself cannot be accessed directly by software.","Referring now to , there is shown a packet enqueue for multicase command format generally designated by reference character  in accordance with the preferred embodiment. The packet enqueue for multicase command PKT_enqueue_MC (queue, PS) enqueues packet PS onto the specified processing\/transmit queue. The packet is part of a multi-cast operation and is not marked for deletion.","If the packet being enqueued is zero-length, the enqueue operation completes normally but no data is transferred. If PS==NULL, the operation is no-operationed or no-op'd. If the queue specified is the discard queue, the operation is no-op'd. If PS is a linked packet, a PSI is generated.","Referring now to , there is shown a packet enqueue, packet enqueue message command format generally designated by reference character  in accordance with the preferred embodiment. The packet enqueue, packet enqueue message command PKT_enqueue[_msg] (queue, PS) enqueues packet PS onto the specified processing\/transmit queue. If PS==NULL, the operation is no-op'd. The packet is marked for automatic discard after any processing required by the target queue is complete. Bit , the high-order bit of the queue number, indicates the type of queue. For example, 0 indicates an RX queue and 1 indicates a TX queue, the scheduler queue, or the discard queue. If RX queue  is specified, this enqueue targets the message queue. Enqueuing a packet (non-message PID) to the message queue produces undefined results.","The packet enqueue message command PKT_enqueue_msg (, PS) enqueues the message in PSR PS onto the specified message queue.","Referring now to , there is shown a packet dequeue command format generally designated by reference character  in accordance with the preferred embodiment. The packet dequeue command PKT_dequeue (PT, queue_group, queue_mask) dequeues the packet from the head of the specified queue and stores the PID into PT. The requested queue is encoded into queue_group and queue_mask. If all requested queues are empty, PT is set to NULL.","The PKT_dequeue command can only dequeue from the Receive queues. In some implementations, for example, the group field must be zero. If a nonexistent queue is specified, PT is set to NULL. If initial [PT]!=NULL, a packet storage interrupt is generated.","Referring now to , there is shown a packet dequeue message command format generally designated by reference character  in accordance with the preferred embodiment. The packet dequeue message command PKT_dequeue_msg (PT, queue_mask) dequeues the message from the head of the specified queue and stores the Message PID into PT. The packet dequeue message command is a subset of the PKT_dequeue instructions with queue_group value set to 0\u00d71F. If all requests queues are empty, PT is set to NULL.","The PKT_dequeue_msg command can only dequeue from the message queues. In some implementations, for example, a single message queue is implemented, so queue_mask must=0\u00d70001. If a nonexistent queue is specified, PT is set to NULL. If initial [PT]!=NULL, a packet storage interrupt is generated.","Referring now to , there is shown a packet discard command format generally designated by reference character  in accordance with the preferred embodiment. The packet discard command PKT_discard (PS) discards packet PS by enqueueing it onto the discard queue. If PS is marked as multicast (multi-case counter (MCC) non-zero), MCC IS DECREMENTED. If PS==NULL, the operation is no-op'd. PKT_discard is a simplified mnemonic for the enqueue instruction with the queue number==x\u2018FFFF\u2019, the DISCARD QUEUE.","Referring now to , there is shown a packet accept command format generally designated by reference character  in accordance with the preferred embodiment. The packet accept command PKT_accept (PT) removes packet PT from the receive ordering queue. The packet accept command must be issued by software to keep the packet without enqueuing or discarding. PKT_accept frees up any packets that may be blocked by this packet due to packet ordering requirements. If PT==NULL, the operation is a no-op.","Referring now to , there is shown a packet synchronize command format generally designated by reference character  in accordance with the preferred embodiment. The packet synchronize command PKT_sync waits for any pending commands to complete to insure that no interrupts are possible, then sets PSISR bit .","The packet synchronize command is intended for use in the interrupt handler code to insure that all related interrupts are recorded prior to handling the interrupt. Software should clear PSISR bit  prior to executing the PKT_sync instruction. PSISR bit  can polled or tested later in code for PKT_sync completion.","Referring now to , an article of manufacture or a computer program product  of the invention is illustrated. The computer program product  includes a recording medium , such as, a floppy disk, a high capacity read only memory in the form of an optically read compact disk or CD-ROM, a tape, or a similar computer program product. Recording medium  stores program means , , ,  on the medium  for carrying out the methods for implementing packet commands of the preferred embodiment in the system  of .","A sequence of program instructions or a logical assembly of one or more interrelated modules defined by the recorded program means , , , , direct the network processor system  for packet command instructions for network processing of the preferred embodiment.","While the present invention has been described with reference to the details of the embodiments of the invention shown in the drawing, these details are not intended to limit the scope of the invention as claimed in the appended claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention together with the above and other objects and advantages may best be understood from the following detailed description of the preferred embodiments of the invention illustrated in the drawings, wherein:",{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":["FIG. 3B","FIG. 3A"]},{"@attributes":{"id":"p-0015","num":"0014"},"figref":["FIGS. 4-23","FIG. 2"]},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 24"}]},"DETDESC":[{},{}]}
