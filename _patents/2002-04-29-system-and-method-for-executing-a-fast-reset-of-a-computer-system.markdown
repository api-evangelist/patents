---
title: System and method for executing a fast reset of a computer system
abstract: A system and method for implementing a fast reset of a computer system is described. In one implementation, the fast reset is implemented by adding a new ResetType to the EFIResetSystem( ) function. In particular, a third ResetType, i.e., “EfiResetFast” (FAST option), is added, which is passed as a parameter when calling the EFIResetSystem( ) function. In another implementation, the fast reset is implemented using a new EFI function, referred to herein as “EFIResetFast( )”. In either implementation, in response to a fast reset, the firmware skips several steps typically performed, including some of the core firmware construction, single cell initialization, memory testing, memory re-initialization, and partition creation, and proceeds directly to transfer of control of the platform to a software interface disposed between an OS and firmware.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06963970&OS=06963970&RS=06963970
owner: Hewlett-Packard Development Company, L.P.
number: 06963970
owner_city: Houston
owner_country: US
publication_date: 20020429
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE DRAWINGS"],"p":["1. Technical Field of the Invention","The present invention generally relates to computer systems. More particularly, and not by way of any limitation, the present invention is directed to a system and method for implementing a fast reboot, or reset, of a computer system.","2. Description of Related Art","During development and testing of a computer system, the system will be rebooted very often. It would not be unusual for a large computer system to take 10 to 15 minutes to completely reboot. If a system is rebooted a number of times each day, which is typically the case, a considerable amount of time may be spent simply waiting for the system to reboot. For example, assuming a particular system takes 15 minutes to reboot and is rebooted 12 times a day, three hours are essentially wasted simply waiting for the system to reboot. Clearly, this is an inefficient use of valuable time and resources and adds to the overall expense of developing and testing, and therefore producing, a computer system.","The Extensible Firmware Interface (\u201cEFI\u201d) specification, developed by Intel Corporation, defines a new model for an interface between a computer's operating system (\u201cOS\u201d) and platform firmware. The interface consists of data tables that contain platform-related information, plus boot and runtime service calls that are available to the OS and its loader. Together, these provide a standard environment for booting an OS and running pre-boot applications. One service provided by EFI is an \u201cEFIResetSystem( )\u201d function, which resets the entire platform, including all processors and devices, and reboots the system. Calling the function with a ResetType of \u201cEfiResetCold\u201d (COLD option) causes a system-wide reset. This sets all circuitry within the system to its initial state. This type of reset is asynchronous to system operations and operates without regard to cycle boundaries. EfiResetCold is tantamount to a system power cycle. Calling the function with a ResetType of \u201cEfiResetWarm\u201d (WARM option) causes a system-wide initialization. The processors are reset to their initial state and pending cycles are not corrupted. As evident from the foregoing, a \u201cWARM\u201d reset is accomplished more quickly than a \u201cCOLD\u201d reset; however, neither are suitably fast to solve the problems addressed above with regard to the substantial delay caused by the multiple resets that take place during development and testing of a new system.","One solution to the aforementioned problem will be referred to herein as \u201cSpeedy Boot\u201d. The Speedy Boot specification defines certain EFI boot variables that can be used by an OS to communicate boot options to system firmware. In effect, Speedy Boot causes a system to undergo a full reset and then skips certain initialization steps as indicated by the EFI boot variables that are set by the OS. In operation, the OS writes to the EFI boot variables to set options for subsequent boots. Optionally, the user can also write to the EFI boot variables using a firmware user interface. The system firmware, EFI and option ROMs read from the EFI boot variables during Power-On Self-Test (\u201cPOST\u201d) to determine what actions to take. Hence, Speedy Boot provides a partial time-savings when a system is rebooted several times, e.g., during development; however, it may not be as significant as would be desirable in a large system.","Additionally, according to the Intel EFI specification, during early initialization of the OS, the OS is required to call an EFI function referred to as ExitBootServices( ). This function call results in some EFT functionality being disabled until the system goes through a complete reset and EFI is reinitialized. It will be recognized that there will be instances in which it may be helpful to have access to system state variables that are lost by performing a full reset, for example, for debugging purposes. Presently, there is no mechanism by which to access that data.","Accordingly, the present invention advantageously provides a system and method for implementing a fast reset function in a computer system. In general, during a fast reset, the firmware is operable to skip several steps typically performed, including some of the core firmware construction, single cell initialization, memory testing, memory re-initialization, and partition creation.","In one aspect, the invention comprises a method of implementing an expedited reset of a computer system comprising an operating system (\u201cOS\u201d), platform hardware, processor hardware, and firmware disposed between the platform and processor hardware and the OS, the method comprising the steps of receiving a fast reset request; and, responsive to receipt of the fast reset request, omitting at least a portion of setting up of a System Abstraction Layer (\u201cSAL\u201d) of the firmware and substantially immediately transferring control of the computer system to a software interface between the OS and the firmware.","In another aspect, the invention comprises a method of implementing an expedited reset of a computer system comprising an OS, platform hardware, processor hardware, and firmware disposed between the platform and processor hardware and the OS, the method comprising the steps of, responsive to a reset event, determining whether the reset event is a normal reset event; if the reset event is a normal reset event, initiating a full reset of the computer system; and if the reset event is not a normal reset event, implementing a fast reset of the computer system, wherein the fast reset comprises omitting at least a portion of setting up of a System Abstraction Layer of the firmware and instead initializing an interface disposed between the OS and the platform hardware of the computer system.","In another aspect, the invention comprises a system for implementing an expedited reset of a computer system comprising an OS, platform hardware, processor hardware, and firmware disposed between the platform and processor hardware and the OS, the system comprising means for determining whether the reset event is a normal reset event; means for initiating a full reset of the computer system if the reset event is a normal reset event; and means for implementing a fast reset of the computer system, if the reset event is not a normal reset event, wherein the fast reset comprises omitting at least a portion of setting up of a System Abstraction Layer of the firmware and instead initializing an interface between the OS and the platform hardware of the computer system.","In another aspect, the invention comprises a computer system comprising an OS; platform hardware; processor hardware; firmware disposed between the platform and processor hardware and the OS; and a software interface between the firmware and the OS, the software interface for enabling a plurality of function calls; wherein, responsive to a fast reset event, a fast reset of the computer system is executed. In one exemplary implementation, the fast reset comprises omitting at least a portion of setting up of a System Abstraction Layer of the firmware and instead immediately initializing an interface between the OS and the platform hardware of the computer system.","In the drawings, like or similar elements are designated with identical reference numerals throughout the several views thereof, and the various elements depicted are not necessarily drawn to scale.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 1","b":["100","100"]},"As illustrated in , firmware  lies between platform and processor hardware , , respectively (collectively, \u201chardware\u201d), and OS software . In one exemplary implementation, the firmware comprises three main layers, including a Processor Abstraction Layer (\u201cPAL\u201d) , a System Abstraction Layer (\u201cSAL\u201d) , and an Extensible Firmware Interface (\u201cEFI\u201d) layer . Although the terms such as PAL, SAL, et cetera, have been known in the context of the Intel Processor Family (IPF) Architecture, it should be understood by those skilled in the art that such terms can be applied to any layered hardware\/software architecture with respect to other processor families as well.","In one exemplary implementation, accordingly, the PAL  encapsulates processor model specific hardware and is part of the Intel IPF Processor Instruction Set Architecture (\u201cISA\u201d). The PAL  is the firmware layer that abstracts processor implementation-specific features and is independent of the number of processors. The PAL  is designed to initialize the processor hardware and interacts with both the SAL  and the OS  as illustrated in .","The SAL  is a platform specific firmware component that isolates the OS  and other higher level software from implementation differences in the specific platform configuration. In particular, the SAL  is responsible for initializing the platform hardware , as well as for initializing connections between processors and main memory. In the exemplary configuration of , the SAL  does not include any I\/O device drivers. Essentially, the SAL  interacts with the EFI layer  and the OS  as illustrated in .","In one embodiment, the EFI layer  is a platform-binding specific layer that provides a legacy-free Application Programming Interface (\u201cAPI\u201d) to the OS loader. The EFI layer  is primarily responsible for booting the OS  in the sense that it has I\/O device driver functionality for loading the OS\/OS loader into main memory and passing control to it. The EFI layer  interacts with the OS  as illustrated in .","The PAL  is typically provided with the processor hardware complex by the vendor. In contrast, the platform vendor has to develop or have developed the SAL  and EFI layer  for the particular platform. The PAL , the SAL , and the EFI layer  together provide system initialization, boot, and other functions that vary between platforms.","As will be described in greater detail below, in a first exemplary configuration, a fast reset function is implemented by adding a new ResetType to the EFIResetSystem( ) function. As described above, presently, the ResetTypes are EfiResetCold and EfiResetWarm. The first implementation would add a third ResetType, i.e., \u201cEfiResetFast\u201d (FAST option), which is passed as a parameter when calling the EFIResetSystem( ) function. In a second exemplary configuration, a fast reset function is implemented using a new EFI function, referred to herein as \u201cEFIResetFasto\u201d, which is unrelated to and independent of the EFIResetSystem( ) function. This second implementation would entail adding a new global unique identifier (\u201cGUID\u201d) and a new EFI service, which the OS would discover on boot. Regardless of which configuration is implemented, there are common implementation steps that are performed. In order to activate the new EFI service, a new argument is added to the reboot command. As a practical matter, this argument may be limited to internal debug kernels because of the potential instability of a computer system after a fast reset. A currently unused option is used for this purpose.","Before using the EFIResetFasto function, the OS must perform several steps to prepare to hand the computer system to firmware. The first step is to end all I\/O and memory operations (e.g., Direct Memory Access or DMA transactions) and idling the I\/O hardware. The next step is to flush all the caches of processor(s) returning to firmware. The final step is to cause all non-boot start-up processor (\u201cnon-BSP\u201d) processors to enter the idle loop and wait. The OS must ensure these steps are completed before using the EFIResetFasto option.","In the first implementation, the OS calls EFIResetSystem with ResetType EfiResetFast when reboot with the special option is called. If the call fails (because the FAST option is not supported), the OS may use one of the standard EFIResetSystem options (WARM or COLD). In the second implementation, the OS verifies that the EFIResetFasto function is supported by checking the EFI services table. If supported, it may be used. If not, it will fail back onto one of the standard EFIResetSystem( ) options (WARM or COLD). Once the firmware gets the EFIResetFast signal from the OS, the firmware will perform a reduced number of initialization steps and bring the system back up to the EFI prompt.",{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 2","FIG. 1"],"b":["100","202","204","206"]},"After SAL setup has been completed, execution proceeds to step , in which control is transferred to EFI, at which point the SAL copies the EFI program out of ROM into main memory, activates it, and passes control to it to initiate booting of the OS.","In contrast, in accordance with features of one implementation of the present invention, if the reset is not a normal reset but is instead a \u201cfast reset\u201d, execution proceeds directly to step , omitting performance of steps , , and . It will be appreciated, therefore, that a substantial time savings can be realized by using the fast reset option.","As noted above, there are at least two manners in which a fast reset function could be implemented. In a first implementation, a third ResetType, i.e., \u201cEfiResetFast\u201d (FAST option), which is passed as a parameter when calling the EFIResetSystem( ) function, is added as an option to the EFIResetSystem( ) function. In a second implementation, a new EFI function, referred to herein as \u201cEFIResetFasto\u201d, which is unrelated to and independent of the EFIResetSystem( ) function, is added to the EFI services. This second implementation would entail adding a new global unique identifier (\u201cGUID\u201d) and a new EFI service, which the OS would discover on boot.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":["FIG. 3","FIG. 3"],"b":["300","302","300","303","1","302","304"]},"At time T, EFI setup  is performed and EFI services are initialized. Specifically, EFI is prepared to run in main memory and the EFI system is set up. At time T, EFI services, as well as other RAM-resident services , are available. Time T represents the point in time at which an EFI prompt is displayed and at which an OS loader  may begin to load an OS . At time T, the OS loader  calls an ExitBootServices function. The ExitBootServices function places EFI in a mode in which certain functionality thereof is disabled. There is no means by which to \u201cundo\u201d the effect of an ExitBootServices call. Time T corresponds to the time at which the OS  is up and running.","In response to a Normal reset, as defined above with reference to , the platform  returns to the state represented by time T; in other words, a full reset of the platform  is performed. At this point, system boot proceeds as indicated by arrows . In contrast, in accordance with features of the implementations described herein, a fast reset of the computer system returns the system to the state represented by time T; all of the initialization from T to T is omitted. One result of a fast reset is that it leaves the contents of certain registers undisturbed. This can be useful for debugging and other purposes and provides a way around the effects of the ExitBootServices call.","It is worth recalling that the Speedy Boot functionality described above performs a full reset of the platform; that is, it returns the computer to the state represented by T, and then skips certain initialization steps between times T and T (in addition, the OS  may skip steps between T and T), as indicated by the EFI boot variables. Accordingly, it is typically not as fast as the fast reset function described herein. Moreover, the fast reset function eliminates the need to run all of the code that reinitializes the interactions between the PAL and the SAL, main memory, and the links between main memory and the processors and I\/O bridges. Instead, the program image is copied from ROM into main memory, which remains initialized, and is used to relaunch the OS. As an indirect result, the platform-specific state variables that are retained in hardware, or firmware, log registers are not reinitialized and may be accessed during reset of the computer. As alluded to in the foregoing, retention of these variables, but reinitialization of the computer firmware, will often provide debugging value.","It will be recognized that, in addition to the two techniques described hereinabove for invoking the fast reset function, there are numerous other methods for doing so. Three such other methods are described in greater detail below.","For example, the fast reset function may be implemented as a new SAL interface procedure. Similar to the embodiments described above, this alternative embodiment is also a procedure call mediated invocation; however, instead of calling a function built in to the EFI services portion of the firmware, the OS invokes a new SAL function that is added to the standard SAL or to an OEM extension to the SAL. If the new SAL function for implementing the fast reset feature is added to an OEM extension to the SAL, the function may be implemented as a proprietary Extensible SAL Interface (\u201cESI\u201d) function using the model defined in the Extensible SAL Specification, Version 1.0, available from Hewlett-Packard Company. The Extensible SAL Specification defines a forward-compatibility mechanism, using an EFI system table, as defined in section 4.5.1 of the EFI Specification, Version 1.02, whereby an OS may query the SAL implementation of a platform using an OEM-defined function designated \u201cSALQUERY\u201d in order to discover if that implementation supports another OEM-specific SAL extension. It will be assumed for the purposes of example that this procedure is named \u201cSALFASTRESET\u201d. An OEM vendor publishes a GUID and SAL Function ID of the SALFASTRESET procedure that the implementation contains. The OEM implements the SALQUERY procedure using the same GUID. To invoke this feature, an OS invokes SALQUERY with the GUID and passes the SAL Function ID of the SALFASTRESET extension to discover if the platform provides this feature. Such a check could be performed at boot time and its results retained for later use; alternatively, it could be deferred until the OS actually attempts to invoke the fast reset function.","The sequence of interactions between the OS and platform firmware for implementing this alternative method is very similar to the embodiments described above and will therefore not be further described in detail.","Another alternative method for implementing the fast reset function is referred to herein as a Platform Manageability Interrupt (\u201cPMI\u201d) model. As will be recognized by one of ordinary skill in the art, the IPF instruction set architecture, as defined by Intel Corporation, defines a richly-featured interrupt architecture. PMI is an asynchronous highest-priority external interrupt that encapsulates a collection of platform-specific interrupts. PMIs occur during instruction processing, resulting in control flow being passed to a PAL PMI handler. During this process, certain processor state is automatically saved by the processor hardware and the processor starts executing instructions beginning at a PALEPMI entrypoint, then transitions to SAL PMI code. When processing is completed, the SAL PMI code returns to PAL PMI code to restore the interrupted processor state and to resume execution at the interrupted instruction.","PMI messages can be delivered by an external interrupt controller or as an interprocessor interrupt (\u201cIPR\u201d) using delivery mode . Hardware events, including IPR messages, that can trigger PMI requests delivered to an IPF processor are referred to as \u201cPMI events\u201d. PMI events are the highest-priority external interrupts and are only maskable by disabling interrupt collection (setting PSR.ic=0). This will only be done when system software is processing extremely critical tasks, since it prevents the processor from saving interruption collection state necessary to resume from an interruption. There are 16 PMI interrupt vectors, or levels. Twelve of these (vectors \u2013) are reserved to Intel PAL; four (vectors \u2013) are reserved for SAL. Vector  is used to indicate a PMI pin event. The PMI pin is a signal in put on the processor that may be sourced by a PMI signal. Higher vector numbers have higher priority.","PMI is apparently intended to enable transparent processing of platform-specific system functions. IPF processors implement the PMI to enable platform developers to provide high level system functions, such as power management and security, in a manner transparent to both application software and the OS.","Resetting the system is transparent to neither the system software nor firmware, since the operation is involved only when initiated by system software; therefore, the PMI invocation model embodiment of the present invention applies PMI in a novel way; that is, to pass explicit control to firmware for the purpose of invoking a platform-specific feature-EFI fast reset. The ability to do so is based on the following assumptions:\n\n","Accordingly, in the PMI invocation model embodiment, the PMI message behaves as though it were a procedure call into firmware with an implicit argument. Normally, PMI handlers return control to the interrupted context after processing. That is true for normal firmware procedures as well. However, for the standard ResetSystem( ) firmware procedure, no return is expected. Likewise, for this PMI-delivered fast reset command, no return will be expected.","Any one (or all, depending on platform need for distinct PMI events) of the vectors , , or  could be used for the fast reset command. If a platform needed to use PMI events for more than three different operations, multiplexing of the fast reset event could be achieved in a number of ways. One is to define an EFI variable that would modulate the behavior of the shared PMI event. For example, a variable named \u201cDoFastReset\u201d, whose value is a boolean state that is set to False at every reboot, can be defined. The OS performs the EFI fast reset operation in two steps. First, system software sets DoFastReset to True. Next, system software sends the designated PMI interrupt message to any one of the processors. This event is received in the processor, resulting in the processor vectoring to the PAL PMI handler, which in turn transfers to the SAL PMI handler. The SAL handler checks the value of the DoFastReset variable, notices that it is True, and begins the processing of the fast reset operation instead of the nominal event behavior.","PMI events are distinctly hardware-dependent. To use them in this fashion (i.e., as a specific OS-to-firmware command) require platform-specific knowledge to be encoded into the OS. Having platform-specific system software that \u201cknows\u201d which PMI event corresponds to the EFI fast reset is essentially no different than having that software \u201cknow\u201d the GUID and EFI function number for an EFI procedure interface to the fast reset function.","However, including the following additional firmware functionality to describe and expose the PMI-mediated fast reset capability could enhance the portability of this portion of the system software. For example, if PMI fast reset is supported, the platform could expose an EFI variable referred to as \u201cEFTFastResetVector\u201d and a corresponding EFI GUID. An OS would then scan the EFI variable list for this variable at some point prior to attempting to initiate the EFI fast reset function. If the variable does not exist, the feature is not implemented using PMI. If the variable does exist, the integer value of the variable (i.e., 1, 2, or 3) specifies the PMI vector level to sue when using an IPR to deliver the fast reset PMI message to a system processor so that the firmware will perform the reset.",{"@attributes":{"id":"p-0049","num":"0053"},"figref":"FIG. 4","b":["1","2","3"]},"Referring now to , prior to sending a first message, represented in  by a path , an OS  returns control to firmware  of every processor , other than the one to receive the PMI message. In , a processor is designated as the one to receive the PMI message. If possible, the target processor should be the last processor, i.e., send the IPR to itself. If this is not possible, firmware  will still perform the reset and will attempt to rendezvous any processor not returned to SAL  prior to reception of a PMI event, represented in  by paths . Message  (path ) initiates the sequence. The path  represents a PMI interrupt sent to the target processor . Message , represented in  by a path , represents the processor branching into a PAL PMI handler . Message , represented in  by a path , represents the processor branching into a SAL PMI handler . Message  (path ) (one per processor) is sent only if any of the processors , , other than the target processor () (in a multiprocessor system) have not been previously rendezvoused in SAL. Message  (path ) can be implemented using either PMI interrupt messages or INIT messages. Message , represented in  by a path , is sent only when all processors are under control of SAL . Message  (path ) indicates the initialization of an EFI firmware layer  so that all boot-time services are activated again.","The remaining steps, represented by paths , , and , are identical to the final steps described above with respect to the first two embodiments. In particular, path  represents transfer of control to the EFI boot manager . Path  represents loading of an OS loader . Path  represents the passing of control to the loaded OS .","Another alternative embodiment involves invocation of an ACPI method in collaboration with a specific hardware capability built into the so-called \u201cchipset\u201d, also referred to internally by HP as the \u201cCore Electronic Complex\u201d or \u201cCEC\u201d. This embodiment is referred to herein as the \u201cACPI invocation model\u201d. Like the immediately preceding embodiment (the PMI invocation model), the ACPI invocation model utilizes PMI to signal the fast reset event, but not directly from system software. Instead, the ACPI system and platform-specific AML and hardware exist as a proxy to initiate the EFI fast reset PMI event.",{"@attributes":{"id":"p-0053","num":"0057"},"figref":["FIG. 5","FIG. 5","FIG. 4","FIG. 5","FIG. 5"],"b":["500","502","500","502","504","500","504","506","504","500","508","510"]},"For example, several types of capabilities could be implemented. One type would provide a mechanism to target individual processors and select the PMI level thereof. Another, simpler, implementation would PMI every processor, similar to SMI. A third variant might use the PMI Pin event (PMI vector ) to all or only one processor. Many more variants are possible. The fundamental additional hardware requirement is that the platform chipset  contain one or more functions that can be described as ACPI operation regions in the ACPI tables and that are capable of initiating a PMI event message to at least one working processor in the system.","A non-standard AML method is written and placed in ACPI name space. OS software is written that \u201cknows\u201d the name and function of this method. The method can be placed anywhere in the hierarchical name space, but it makes the most sense to place it under the root scope. Given these capabilities, we can now describe the sequence illustrated in .","Message , represented in  by a path , represents the OS , having (optionally) previously returned control of all processors , , other than a target processor to SAL  via the architected branch address passed to the OS in B at boot time, invoking the AML method  to initiate the EFI fast reset. In message , represented by a path , the AML method  then accesses the platform chipset  register to initiate the PMI event. Message , represented by a path , indicates the PMI event sent to the target processor . The messages and steps represented by paths , , , , , , and  correspond exactly to the respective messages and steps represented in  by paths , , , , , , and , respectively, and will therefore not be described in further detail.","The following is an explanation of implementation of a \u201csafe\u201d fast reset. In particular, while it is necessary to place each processor (in a multiprocessor IPF system) in a know state prior to invoking the EFI fast reset function, this may not always be possible using OS software. This may occur, for example, if one or more processors are \u201chung\u201d and the OS cannot regain control of them, due to software or hardware causes, or the OS simply does not want to or know how to \u201cclean up\u201d\u2014it just wants to \u201cReset Now\u201d, but it wants to try and do so using the fast reset feature.","The consequences of not cleaning up for EFI fast reset, such that processors are left hanging, is very serious, because the OS is going to be reloaded and restarted, so any processors left executing somewhere that firmware is not aware of will cause trouble. This trouble is not possible for the normal EFI ResetSystem( ) because the system will just go through a hard reset and all of the processor will begin executing in firmware at the PALERESET vector.","Accordingly, if an OS chooses not to or is not capable of rendezvousing all processors, firmware regains system sanity by forcing a rendezvous of all processors. Once a single processor enters SAL for the purpose of performing the EFI fast reset, SAL can force all processors to a known state. This is true whether the invocation enters SAL from the top through a procedure call (EFI or SAL) or from the bottom through a PMI event.","SAL only needs one processor to do this forced rendezvous using either PMI or INIT transactions sent to al remaining processors not already under SAL control. If it is not possible to regain control of every processor in the system, prior to beginning initialization of the EFI layer, SAL could perform a full (cold or warm) reset. Alternatively, SAL could enter a diagnostic mode instead of trying to load the OS into an unstable platform by continuing with the fast reset function.","The foregoing is included to specify that all embodiments of the fast reset function described herein utilize available and architected IPF mechanisms to attempt to perform a \u201cforced rendezvous\u201d before continuing with reinitialization of the EFI layer to complete the fast reset operation.","An implementation of the invention described herein thus provides a mechanism for enabling a fast reboot, or reset, of a computer system platform. It is believed that the operation and construction of the present invention will be apparent from the foregoing Detailed Description. While the system and method shown and described have been characterized as being preferred, it should be readily understood that various changes and modifications could be made therein without departing from the scope of the present invention as set forth in the following claims. For example, while specific implementation examples have been described in reference to an exemplary implementation of the present invention using Intel IPF architecture, such implementations are merely illustrative. Moreover, the exemplary multiprocessor system may be architected in any known or heretofore unknown configuration, e.g., symmetrical multiprocessing (\u201cSMP\u201d) systems, asymmetrical multiprocessing (\u201cAMP\u201d) systems, loosely-coupled MP systems, tightly-coupled MP systems, and the like. Accordingly, all such modifications, extensions, variations, amendments, additions, deletions, combinations, and the like are deemed to be within the ambit of the present invention whose scope is defined solely by the claims set forth hereinbelow."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A more complete understanding of the present invention may be had by reference to the following Detailed Description when taken in conjunction with the accompanying drawings wherein:",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
