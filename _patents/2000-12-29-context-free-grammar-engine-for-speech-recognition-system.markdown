---
title: Context free grammar engine for speech recognition system
abstract: The present invention includes a context-free grammar (CFG) engine which communicates through an exposed interface with a speech recognition engine. The context-free grammar engine, in one illustrative embodiment, handles loading and unloading of grammars, as well as maintaining a desired activation state of the grammars which are loaded. Further, the CFG engine represents all loaded grammars, and their corresponding activation states, as a single grammar to the speech recognition engine.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06957184&OS=06957184&RS=06957184
owner: Microsoft Corporation
number: 06957184
owner_city: Redmond
owner_country: US
publication_date: 20001229
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["REFERENCE TO CO-PENDING APPLICATION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE ILLUSTRATIVE EMBODIMENTS"],"p":["The present application hereby refers to, and claims priority from, the following patent applications:","U.S. Provisional Patent Application Ser. No. 60\/219,861, filed on Jul. 20, 2000; now abandoned, and","U.S. patent application Ser. No. 09\/751,836, entitled MIDDLEWARE LAYER BETWEEN SPEECH-RELATED APPLICATIONS AND ENGINES, filed on Dec. 29, 2000.","The present invention deals with speech recognition systems. In particular, the present invention relates to a context free grammar engine for use in speech recognition systems.","In speech recognition systems, a computer system attempts to identify a sequence of words from a speech signal. One way to improve the accuracy of the recognition is to limit the recognition to a set of selected phrases. This is typically done by limiting valid recognition hypotheses to phrases that are found in a context-free grammar (CFG).","In the past, applications which invoked speech recognition engines communicated directly with the engines. Because the engines from each vendor interacted with applications directly, the behavior of that interaction was unpredictable and inconsistent. This made it virtually impossible to change recognition engines without inducing errors in the application. It is believed that, because of these difficulties, speech recognition technology has not quickly gained wide acceptance.","In an effort to make such technology more readily available, an interface between engines and applications was specified by a set of application programming interfaces (API's) referred to as the Microsoft Speech API version 4.0 (SAPI4). Though the set of API's in SAPI4 specified direct interaction between applications and engines, and although this was a significant step forward in making speech recognition and speech synthesis technology more widely available, some of these API's were cumbersome to use, required the application to be apartment threaded, and did not support all languages.","The process of making speech recognition more widely available has encountered other obstacles as well. For example, many of the interactions between the application programs and the engines can be complex. Such complexities include cross-process data marshalling, event notification, parameter validation, default configuration, and many others. Conventional operating systems provide essentially no assistance to either application vendors, or speech engine vendors, beyond basic access to audio devices. Therefore, application vendors and engine vendors have been required to write a great deal of code to interface with one another.","In one particular example, where one or more applications desires to use one or more grammars with a speech recognition engine, the speech recognition engine is required to keep track of individual grammar loads and to request additional grammars to be loaded for imported rules. Further, the speech recognition engine is often required to parse recognition results to provide the application with a desired parse tree structure. This consequently requires the speech recognition engine to perform a great many tasks other than simply recognizing speech from an audio input signal (or speech signal).","The present invention includes a context-free grammar (CFG) engine which communicates through an exposed interface with a speech recognition engine. The context-free grammar engine, in one illustrative, embodiment, handles loading and unloading of grammars, as well as maintaining a desired activation state of the grammars which are loaded. Further, the CFG engine represents all loaded grammars, and their corresponding activation states, as a single grammar to the speech recognition engine.","In yet another embodiment, the CFG engine can be called, through an interface, by the SR engine to perform parsing services. This relieves the SR engine of substantially all tasks, except simply recognizing speech from an input signal.","A set of interface methods are also provided such that the speech recognition engine can query the CFG engine about new grammars, words, transitions and rules. This allows the SR engine to build an internal representation of the active grammars maintained by the CFG engine.","In still another embodiment, the CFG engine builds a rich structure from the recognition results provided by the speech recognition engine. This result is, in turn, provided to the application, through exposed interface methods.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 1","b":["100","100","100","100"]},"The invention is operational with numerous other general purpose or special purpose computing system environments or configurations. Examples of well known computing systems, environments, and\/or configurations that may be suitable for use with the invention include, but are not limited to, personal computers, server computers, hand-held or laptop devices, multiprocessor systems, microprocessor-based systems, set top boxes, programmable consumer electronics, network PCs, minicomputers, mainframe computers, distributed computing environments that include any of the above systems or devices, and the like.","The invention may be described in the general context of computer-executable instructions, such as program modules, being executed by a computer. Generally, program modules include routines, programs, objects, components, data structures, etc. that perform particular tasks or implement particular abstract data types. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote computer storage media including memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a computer . Components of computer  may include, but are not limited to, a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. By way of example, and not limitation, such architectures include Industry Standard Architecture (ISA) bus, Micro Channel Architecture (MCA) bus, Enhanced ISA (EISA) bus, Video Electronics Standards Association (VESA) local bus, and Peripheral Component Interconnect (PCI) bus also known as Mezzanine bus.","Computer  typically includes a variety of computer readable media. Computer readable media can be any available media that can be accessed by computer  and includes both volatile and nonvolatile media, removable and non-removable media. By way of example, and not limitation, computer readable media may comprise computer storage media and communication media. Computer storage media includes both volatile and nonvolatile, removable and non-removable media implemented in any method or technology for storage of information such as computer readable instructions, data structures, program modules or other data. Computer storage media includes, but is not limited to, RAM, ROM, EEPROM, flash memory or other memory technology, CD-ROM, digital versatile disks (DVD) or other optical disk storage, magnetic cassettes, magnetic tape, magnetic disk storage or other magnetic storage devices, or any other medium which can be used to store the desired information and which can be accessed by computer . Communication media typically embodies computer readable instructions, data structures, program modules or other data in a modulated data signal such as a carrier WAV or other transport mechanism and includes any information delivery media. The term \u201cmodulated data signal\u201d means a signal that has one or more of its characteristics set or changed in such a manner as to encode information in the signal. By way of example, and not limitation, communication media includes wired media such as a wired network or direct-wired connection, and wireless media such as acoustic, FR, infrared and other wireless media. Combinations of any of the above should also be included within the scope of computer readable media.","The system memory  includes computer storage media in the form of volatile and\/or nonvolatile memory such as read only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within computer , such as during start-up, is typically stored in ROM . RAM  typically contains data and\/or program modules that are immediately accessible to and\/or presently being operated on by processing unit . By way o example, and not limitation,  illustrates operating system , application programs , other program modules , and program data .","The computer  may also include other removable\/non-removable volatile\/nonvolatile computer storage media. By way of example only,  illustrates a hard disk drive  that reads from or writes to non-removable, nonvolatile magnetic media, a magnetic disk drive  that reads from or writes to a removable, nonvolatile magnetic disk , and an optical disk drive  that reads from or writes to a removable, nonvolatile optical disk  such as a CD ROM or other optical media. Other removable\/non-removable, volatile\/nonvolatile computer storage media that can be used in the exemplary operating environment include, but are not limited to, magnetic tape cassettes, flash memory cards, digital versatile disks, digital video tape, solid state RAM, solid state ROM, and the like. The hard disk drive  is typically connected to the system bus  through a non-removable memory interface such as interface , and magnetic disk drive  and optical disk drive  are typically connected to the system bus  by a removable memory interface, such as interface .","The drives and their associated computer storage media discussed above and illustrated in , provide storage of computer readable instructions, data structures, program modules and other data for the computer . In , for example, hard disk drive  is illustrated as storing operating system , application programs , other program modules , and program data . Note that these components can either be the same as or different from operating system , application programs , other program modules , and program data . Operating system , application programs , other program modules , and program data  are given different numbers here to illustrate that, at a minimum, they are different copies.","A user may enter commands and information into the computer  through input devices such as a keyboard , a microphone , and a pointing device , such as a mouse, trackball or touch pad. Other input devices (not shown) may include a joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a user input interface  that is coupled to the system bus, but may be connected by other interface and bus structures, such as a parallel port, game port or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video interface . In addition to the monitor, computers may also include other peripheral output devices such as speakers  and printer , which may be connected through an output peripheral interface .","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be a personal computer, a hand-held device, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) , but may also include other networks. Such networking environments are commonplace in offices, enterprise-wide computer networks, intranets and the Internet.","When used in a LAN networking environment, the computer  is connected to the LAN  through a network interface or adapter . When used in a WAN networking environment, the computer  typically includes a modem  or other means for establishing communications over the WAN , such as the Internet. The modem , which may be internal or external, may be connected to the system bus  via the user input interface , or other appropriate mechanism. In a networked environment, program modules depicted relative to the computer , or portions thereof, may be stored in the remote memory storage device. By way of example, and not limitation,  illustrates remote application programs  as residing on remote computer . It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.",{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 2","b":["200","200","1","200","202","204","206","208"]},"In one illustrative embodiment, speech middleware component  is implemented in the operating system  illustrated in FIG. . Speech middleware component , as shown in , includes speech recognition middleware component , context free grammar (CFG) engine  and text-to-speech (TTS) middleware component .","A detailed description of the operation of speech middleware component  is provided in the above-identified, and incorporated, co-pending patent application. For a full understanding of the present invention, however, only a short description of the operation of that component is warranted.","Briefly, in operation, speech middleware component  resides between applications  and engines  and . Applications  can be speech recognition and speech synthesis applications which desire to invoke engines  and . In doing so, applications  make calls to speech middleware component  which, in turn, makes calls to the appropriate engines  and  in order to have speech recognized or synthesized.","For example, applications  may provide the source of audio data for speech recognition. Speech middleware component  passes that information to speech recognition engine  which simply recognizes the speech and returns a recognition result to speech recognition middleware component . Speech recognition middleware component  places the result in a desired format and returns it to the application  which requested it.","CFG engine , briefly, assembles and maintains grammars which are to be used by speech recognition engine . This allows multiple applications and multiple grammars to be used with a single speech recognition engine . This is discussed in greater detail later in the specification.",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 3","FIG. 3","FIG. 3"],"b":["200","2","210","210","214","216","214","216","206","214","214","202","206","212"]},"It is also sufficient to know, for the purposes of the present invention, that the SpSite object  is the object which SR engine  calls to communicate events and recognitions, and to make other communications with, the SpRecoGrammar object .","CFG engine  is configured to maintain the grammars which are accessible by SR engine , through the interface provided by SpRecoGrammar object . In doing so, CFG engine  allows additional grammars to be loaded and made accessible to SR engine . CFG engine  also enables SR engine  to build an internal representation of the grammars which are loaded. CFG engine  also enables application  to load or unload additional grammars, implement dynamic grammars by making changes to the content of loaded grammars, and to load nested grammars. In addition, CFG engine  can be called, through the interfaces provided by the SpRecoGrammar object , by SR engine . SR engine  can request that its results be parsed by CFG engine  to alleviate SR engine  of the parsing burden. CFG engine  also creates a rich result which is returned through the interfaces provided by the SpRecoGrammar object  to application .","In order to better understand certain aspects of the present invention, it is useful to understand the general structure of grammar rules which are used by SR engine  in recognizing speech. A brief discussion of such a grammar structure is now provided with respect to .  is a state diagram showing the grammar structure for a set of grammar rules, while  is a state diagram showing the grammar structure for a single rule.","More specifically,  provides an example of a state diagram showing three top-level grammar structures, or rules, derived from a text-formatted grammar. In , the three grammar structures are <newgame>, <playcard>, and <movecard> which begin at nodes , , and , respectively.","The newgame grammar structure has a transition from starting node (or state)  to node (or state)  that is associated with the word \u201cnew\u201d. From state  to state , this structure has a second word transition associated with the word \u201cgame\u201d. After state , there are two parallel transitions  and  to a final state . Transition  is an epsilon transition indicating that word transition , which is associated with the word \u201cplease\u201d, is optional.","During speech recognition, speech recognition engine  traverses the state diagram to determine whether the speech signal it is recognizing corresponds to any of the grammar structures. For example, speech recognition engine  will identify the <newgame> structure as corresponding to the input speech signal if the word \u201cnew\u201d is found at the beginning of the speech signal followed by the word \u201cgame\u201d. Note that since the word \u201cplease\u201d is optional in the <newgame> structure, speech recognition engine  will identify the newgame structure even if the word \u201cplease\u201d is not found in the speech signal.","The <playcard> grammar structure, which starts at node , is more complex than the <newgame> structure. From starting node , the <playcard> structure has an epsilon transition  and a word transition  that both end at state . Epsilon transition  indicates that the \u201cplease\u201d associated with word transition  is optional. From state , there are two consecutive word transitions leading respectively to state  and state . These word transitions are associated with the words \u201cplay\u201d and \u201cthe\u201d, respectively.","From state  to state , the <playcard> structure has a wildcard transition . During this transition, speech recognition engine  will ignore any input provided by the user after the word \u201cthe\u201d and before words associated with a <card> grammar structure which is found at transition  from state  to state . Thus, no matter what the user says during transition , speech recognition engine  can still identify the <playcard> structure as being recognized for the speech signal.","Transition  of the <playcard> structure is a grammar structure transition. When speech recognition engine  encounters this transition, it substitutes the entire state diagram of the referenced grammar structure in place of the grammar structure transition. For example, speech recognition engine  replaces transition  with the state diagram of , which represents the <card> grammar structure. It then determines if the input speech signal can be represented by part of the complete <playcard> grammar structure including the portion of that structure provided by the <card> grammar structure.","From state  to end state  of the <playcard> structure, there is an epsilon transition  and a word transition associated with the word \u201cplease\u201d. Epsilon transition  indicates that the word \u201cplease\u201d is optional in the <playcard> structure.","The <movecard> structure associated with start node  begins with an epsilon transition  to state . Epsilon transition  is in parallel with a word transition  associated with the word \u201cplease\u201d. As such, the word \u201cplease\u201d is optional.","From state  to state , the <movecard> structure provides two parallel transitions  and  associated with the words \u201cput\u201d and \u201cmove\u201d, respectively. Thus, if the user says either \u201cput\u201d or \u201cmove\u201d, the speech recognition engine  will identify these portions of the speech signal with the <movecard> structure.","From state  to state , there is a single word transition associated with the word \u201cthe\u201d. From state  to state , the <movecard> structure provides a grammar structure transition associated with the <card> grammar structure.","From state  to state , there are two parallel word transitions  and , associated with the words \u201con\u201d and \u201cto\u201d, respectively. A word transition for the word \u201cthe\u201d extends from state  to state , which is followed by a grammar structure transition to state  for the <card> grammar structure.","An epsilon transition extends from state  to state . This epsilon transition indicates that the transitions between states , , , and , are all optional. As such, the words associated with these transitions do not need to be present in the speech signal in order for speech recognition engine  to identify the <movecard> structure from the speech signal.","From state  to end state  there is epsilon transition  in parallel with a word transition . Epsilon transition  indicates that the word \u201cplease\u201d associated with transition  is optional.",{"@attributes":{"id":"p-0059","num":"0058"},"figref":["FIG. 5","FIG. 3"],"b":["202","202","210","214","216","400"]},"Application  then indicates to SpRecoGrammar object , by calling an exposed method, that application  desires to load a grammar from a designated input. In one illustrative embodiment, SpRecoGrammar object  exposes four different methods which are used by the application, depending upon the source of the grammar. Those methods, for example, can allow the application  to load a grammar from a file, from a memory location, from a resource, or from an object. Of course, other sources could be provided as well. This is indicated by block .","The SpRecoGrammar object  then invokes CFG engine  providing it with the location of the grammar to be loaded. It should be noted that, in many embodiments, SR engine  can only operate on a binary grammar. Therefore, CFG engine  locates the grammar to be input. If it is in a binary grammar format, processing simply continues. If it is in a text format, it is illustratively compiled on-the-fly, in to a binary grammar. In any case, once the grammar is located and is in binary form, CFG engine  loads the grammar into associated memory. In loading the grammar, CFG engine  internally maintains a store which indicates where all of the rules in each loaded grammar are from. In other words, given a rule identifier, CFG engine  can determine which grammar that particular rule belongs to. Invoking CFG engine  and loading the grammar are indicated by blocks  and .","Once the grammar is loaded, CFG engine  calls SR engine  through the interfaces provide by the SpRecoGrammar object  and passes in all of the new words associated with the grammar which has just been loaded, along with handles to the new words provided by CFG engine . This is indicated by block . In response to receiving the new words, SR engine  calls back on SpSite  and provides its internal pointer (the pointer internal to SR engine ) to the new words which it has just received. This is indicated by block . Therefore each time CFG engine  calls SR engine  in relation to a given word, it identifies that word to SR engine  by providing the internal pointer which SR engine  uses for that word. Similarly, when SR engine  calls back to SpSite , in relation to any word, it provides the pointer, or handle, which CFG engine  generated for that word.","CFG engine  continues loading in new words and word handles, and receiving the internal pointer to those words from SR engine , until no new words are left to be loaded. This is indicated by block .","Once all of the new words are loaded, CFG engine  calls SR engine  through the SpRecoGrammar object  and passes in the rule information associated with the grammar which has just been loaded. Such rule information illustratively includes the rule identification number (rule ID), the rule name, the level of the rule (i.e., whether it is a top level rule) and whether the rule is active or inactive, by default. Passing in the rule info is indicated by block  in FIG. .","As with new words, SR engine  then calls back on SpSite  providing its internal pointer to the new rules which have just been identified to it. This is indicated by block . Again, each time CFG engine  refers to a rule in communicating with SR engine , it provides the internal pointer for SR engine , associated with that rule. SR engine , in turn, provides the handle or rule ID generated by CFG engine  for the associated rules as well.","Once CFG engine  has communicated all of the words in the new grammar and identified the rules in the new grammar to SR engine , SR engine  makes a series of calls to CFG engine , through SpSite  and the SpRecoGrammar object  such that SR engine  can build an internal representation of the rule structure corresponding to each of the rules in the new grammar. This is indicated by block . This process is also described in greater detail below with respect to FIG. .","Once SR engine  has built its internal representation of the new grammar rules, the application  passes in information telling CFG engine  to either activate or deactivate specified rules. In the absence of this information, CFG engine  simply activates the default rules in the new grammar. This is indicated by block  in FIG. . The CFG engine  then makes appropriate calls to the SR engine , through the SpRecoGrammar object , to active and deactivate the desired rules. This is indicated by block .","At this point, the entire new grammar has been loaded not only into CFG engine  (or its associated memory), but the appropriate grammar structures have also been created by SR engine  so that it can now begin recognition using the new grammar.","It should also be noted that grammars can be removed in substantially the reverse process as that illustrated by FIG. . In other words, application  calls CFG engine  through the SpRecoGrammar interfaces to remove a grammar. The CFG engine  calls the SR engine  through the appropriate interface to remove the words and rules associated with that grammar. Similarly, in order to add another grammar, the process illustrated by  is simply repeated. Further, if application  wishes to activate or deactivate rules in a dynamic grammar, it simply provides an indication of that, through the interfaces provided by the SpRecoGrammar , to CFG engine . CFG engine  then notes which rules have been activated or deactivated and calls SR engine , through the interfaces provided by SpRecoGrammar object , with appropriate calls to active or deactivate the specified rules.","In this way, multiple grammars can be used and loaded by application , and they are all maintained by CFG engine . CFG engine  represents all of the combined grammars as a single grammar to SR engine . SR engine  therefore need not know, and need not track, multiple grammars, dynamic grammars, etc. It simply builds an internal representation of the new rules added by CFG engine , or it deletes its representation of rules and words which are removed by CFG engine . It also simply activates or deactivates rules, as indicated by CFG engine . This significantly relieves the burden on SR engine , and leaves it to simply do speech recognition, based on an input audio signal or speech signal.",{"@attributes":{"id":"p-0071","num":"0070"},"figref":"FIG. 6","b":["206","212","414","5","206","212","216","206","212","424","6"]},"In response, CFG engine  sends back a structure describing the rule. For example, if CFG engine  is describing the <newgame> rule shown in , CFG engine  first provides the rule ID, the rule name (newgame), an indication that <newgame> is a top-level rule and an indication of whether the rule is active or inactive, by default. SR engine  then queries CFG engine , through SpSite , for more information, as indicated by block  in FIG. . In response, CFG engine  sends back an indication first indicating that the transition following state  is a word transition and the word is \u201cnew\u201d. CFG engine  also provides an indication as to the identity of the next state .","SR engine  then has a choice as to how to proceed. In accordance with one illustrative embodiment, SR engine  simply waits until it recognizes the word \u201cnew\u201d and realizes that it is potentially starting down the tree structure of the \u201cnewgame\u201d rule. In that case, SR engine  then queries CFG engine  as to any additional fanout for the rule. For instances, SR engine  may then ask what the next transition is in the rule, if there is one. At that point, CFG  engine provides an indication that the transition from state  is another word transition, the word is \u201cgame\u201d and also provides the identity of state . In this way, SR engine  only builds the internal structure of the entire rule, as the text associated that rule is being recognized.","In accordance with another illustrative embodiment, SR engine  continues to query CFG engine  to obtain the full fanout for all rules, even before recognition has begun. In this way, SR engine  can obtain all necessary information to build all the internal structures which will represent the rules, prior to beginning recognition. Having SR engine  retrieve the rule information to complete its internal structure of the rules (whether it is done prior to speech recognition, or during speech recognition) is illustrated by block  in FIG. .",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 7","FIG. 7"],"b":["212","212","206","202","206"]},"First, application  calls the interfaces provided by SpRecoGrammar object  to load a grammar G. This is indicated by block . The grammar G is then loaded by CFG engine , as indicated with respect to  above. This is indicated by block . The application  then calls an exposed method on the interface implemented by SpRecoGrammar object  to change the grammar. In making this call, application  illustratively passes in the changes in grammar G to create a new grammar G\u2032. This is indicated by block . This grammar G\u2032 is passed from the SpRecoGrammar object  to CFG engine , and CFG engine  compares the grammar G\u2032 to grammar G which is already loaded. This is indicated by block . In order to do this comparison, CFG engine  illustratively compares the word lists associated with grammars G and G\u2032 to see if any words have been changed, deleted, or added. CFG engine  also illustratively compares the rule table associated with the two grammars to see if any rule content has changed.","If CFG engine  determines that there has been no change to the content of any existing rule, as illustrated by block , CFG engine  simply calls SR engine  to add or remove rules or words from the grammar. This is done as described with respect to  above, and is illustrated by block  in FIG. .","However, if at block  it is determined that there is a change to the content of an existing rule, then CFG engine  calls SR engine  to invalidate grammar G. This is indicated by block . Once that grammar has been invalidated, SR engine  makes appropriate calls to the CFG engine  through SpRecoGrammar object , to build its internal representation of the grammar G\u2032. This is indicated by block . It should again be noted that SR engine  can build the entire grammar prior beginning speech recognition, or it can simply build enough grammar to begin speech recognition then build the remaining structures, as needed, during the recognition process.","Another aspect of the present invention involves additional referenced grammars. CFG engine  loads grammars which are referred to by other grammars. For instance, in the above example, grammar G may refer to a rule in another grammar, G. If that happens, CFG engine  locates, and loads, Grammar G such that it can represent the entire grammar as a single grammar to SR engine .  is a flow diagram which better illustrates this process.","CFG engine  first receives a grammar, G, that refers to a rule in another grammar G. This is indicated by block  in FIG. . CFG engine  then locates and loads grammar G, as indicated above with respect to FIG. . This is indicated by block . CFG engine  then calls SR engine  (through SpRecoGrammar object ) with the grammar information related to grammar G (if it has not done so already) and with the grammar information related to grammar G. This is indicated by block . It should be noted that CFG engine  can load the entire grammar G into SR engine , or it can simply load in the relevant rules from grammar G.","It should also be noted that, should grammar G refer to yet another grammar G, CFG engine  locates grammar G, loads it, and loads all, or the relevant portions, of grammar G into SR engine . All of these steps (the loading of separate grammars, the identifying of separate grammars, and the tracking of rules for those grammars) is done transparently to SR engine . SR engine  simply receives rules and words and views them as a single grammar.","CFG engine  is also illustratively configured to parse a result from SR engine  and to provide a more rich result back to application .  illustrate the parsing of a result from engine .  is a flow diagram better illustrating how the parsing operation occurs.  is a parse tree which shows a recognized phrase  with elements numbered -, and a plurality of rules , , , and  which were used to spawn the result.  illustrates a portion of a result which is generated by CFG engine .","In order to parse a phrase and generate a result, CFG engine  first needs a recognition result from SR engine . Therefore, SR engine  returns a result (such as rule ID and a transition sequence) to CFG engine , through SpSite . This is indicated by block  in FIG. . The rule ID represents the particular rule which fired to spawn the recognition result, and the transition sequence is a sequence of transition handles identifying transitions in the rule which generated the recognition result.","For example, assume that SR engine  recognized the phrase \u201cplay the ace of spades\u201d illustrated by number  in FIG. . That phrase is composed of 5 elements (numbered -). The <playcard> and <card> rules  and , respectively, are illustrated in . The \u201crank\u201d and \u201csuit\u201d rules  and  are similar rules, but have not been set out in detail.","Each of the rules - has a rule ID associated with it. Also, as shown in , each rule has a plurality of possible transition sequences which can be followed to generate phases.","After receiving the recognition results, CFG engine creates a parse tree as indicated by block  in FIG. . In constructing a parse tree, CFG engine  identifies the rules and the elements in phrase  which the rule is responsible for. In other words, it can be seen in  that the rule <playcard> is responsible for elements  and  in phrase . <Card> rule  is responsible for element  while <rank> rule  is responsible for element  and <suit> rule  is responsible for element . The rule ID's and transition sequences provided by SR engine  allows CFG engine  to internally create the parse tree identified by  for phrase .",{"@attributes":{"id":"p-0087","num":"0086"},"figref":"FIG. 11","b":["212","462","212","3","3","212","468","11"]},"Similarly, CFG engine  can provide any suitable way of indicating which elements - correspond to which rules -. One embodiment of this is shown in field  in FIG. . In that field, two integers are separated by a comma. The first integer is indicative of the element in phrase  while the second integer indicates the span of elements in phrase  corresponding to the <rank> rule identified in field . Therefore, it can be seen that the <rank> rule has generated the element number  in phrase  and only element number  (because the integer representing the span of elements is set to 1).",{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 11","b":["472","206","472","212","456","472","202"]},"A variety of other types of information can also be pulled together to provide the rich result to application , as indicated by block  in FIG. . One embodiment of such a result is that indicated by the phrase structure set out below:","Spphrase","Typedef [Restricted] Struct SPPHRASE",{"@attributes":{"id":"p-0091","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ULONG","cbSize;"]},{"entry":["LANGID","LangID;"]},{"entry":["WORD","wReserved;"]},{"entry":["ULONGLONG","ftStartTime;"]},{"entry":["ULONGLONG","ullAudioStreamPosition;"]},{"entry":["ULONG","ulAudioSizeBytes;"]},{"entry":["ULONG","ulAudioSizeTime;"]},{"entry":["SPPHRASERULE","Rule;"]},{"entry":["const SPPHRASEPROPERTY","*pProperties;"]},{"entry":["const SPHRASEELMENT","*pElements;"]},{"entry":["ULONG","cReplacements;"]},{"entry":["const SPPHRASEREPLACEMENT","pReplacements;"]},{"entry":["GUID","SREngine ID;"]},{"entry":["ULONG","ulSREnginePrivateDataSize;"]},{"entry":["const BYE","*pSREnginePrivateData;"]},{"entry":"SPPHRASE"},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":["CbSize\u2014The size of this structure in bytes.","LanqID\u2014The language ID of the current language.","WReserved\u2014Reserved for future use.","FtStart Time\u2014The start time of the recognition in the input stream.","UllAudioStreamPosition\u2014The start position of the recognition in the input stream.","UlAudioSizeBytes\u2014The size of audio information.","UlAudioSizeTime\u2014The time of audio information.","Rule\u2014The rule that spawned this result.","pProperties\u2014The pointer to the semantic properties for the rule that spawned this result.","pElements\u2014The pointer to the elements of the result.","pReplacements\u2014The pointer to the replacement elements.","SREngineID\u2014The ID of the SR engine which produced the results.","UlSREnginePrivateDataSize\u2014The size of any proprietary data sent by the SR engine.","PSREnginePrivateData\u2014The pointer to the proprietary data."]}},"Thus, it can be seen that the present invention significantly reduces the burden on both SR engine  and application . CFG engine  handles loading, unloading, activation\/deactivation and invalidation of grammars. CFG engine  also handles adding and deleting words and rules from dynamic grammars and loading multiple grammars. CFG engine  also parses results returned by SR engine  and generates a rich result which is provided to application . It will be appreciated that CFG engine  does this all substantially transparently with respect to SR engine . The SR engine simply views the information provided by CFG engine  as a single grammar which has rules and words that are intermittently added, deleted, activated, deactivated, and invalidated. In this way, SR engine  simply needs to recognize speech based on a speech signal input and need not concern itself with all of the various tasks performed by CFG engine .","Although the present invention has been described with reference to preferred embodiments, workers skilled in the art will recognize that changes may be made in form and detail without departing from the spirit and scope of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3","b":"2"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 4B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 9-11"}]},"DETDESC":[{},{}]}
