---
title: System, method, and apparatus for early culling
abstract: A method of graphics processing includes determining a non-depth conditional status and an occlusion status of a fragment. Such a method may be used in culling occluded fragments before expending resources such as processing cycles and memory bus usage. In one example, a scratchpad stores depth values of robust fragments and is used for occlusion testing. Graphics architectures, and methods that include use of representative Z values, are also disclosed.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06999076&OS=06999076&RS=06999076
owner: ATI Technologies, Inc.
number: 06999076
owner_city: Thornhill
owner_country: CA
publication_date: 20020219
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF THE INVENTION","BACKGROUND INFORMATION","SUMMARY","DETAILED DESCRIPTION"],"p":["This application claims benefit of U.S. Provisional Patent Application No. 60\/330,676, filed Oct. 29, 2001, entitled \u201cSYSTEM, METHOD, AND APPARATUS FOR EARLY CULLING\u201d.","This invention relates to video graphics processing.","Graphics rendering is an important part of many representational and interactive applications for computers. In three-dimensional (or \u20183D\u2019) graphics rendering, an image of a 3D rendering space is presented on a display frame as if the space is being viewed through a two-dimensional display plane. As shown in , the display frame  is an array of individual picture elements (or \u2018pixels\u2019) . Each pixel represents a sample of the display plane at a specified location and has a color value that corresponds to the color of the rendering space as viewed through the display plane at that location. For consumer applications, typical sizes for a display frame include 640\u00d7480, 800\u00d7600, 1024\u00d7768, 1152\u00d7864, 1280\u00d71024, and 1600\u00d71200 pixels. Computer displays and other high-resolution display devices, such as high-definition televisions (HDTVs), projectors, printers, and the like, present the pixel array to a viewer. The pixels are closely spaced, and the viewer's visual system performs a filtering of the individual pixels to form a composite image. If an image is properly partitioned into pixels that are sufficiently close together, the viewer perceives the displayed array as a virtually continuous image.","In a surface rendering scheme, three-dimensional \u2018wire frame\u2019 models of objects in the rendering space are constructed using graphics primitives (e.g. triangles or other elemental polygons). Each primitive is defined by a set of vertices that have values relating to location (e.g. in an XYZ coordinate space), quality (e.g. color and\/or texture), and\/or lighting (e.g. direction of surface normal). As the positions of the vertices with respect to the display plane include the spatial dimension of depth, or distance from the viewer (also referred to as the Z-dimension), objects may be drawn in front of or behind one another in overlapping fashion.","Some or all of the rendering of the object models into pixels for display may be performed in software. Alternatively, the sets of vertices may be presented to rendering hardware, either directly by the software application or via an application programming interface (API) such as the Direct3D component of the DirectX API suite (Microsoft Corp., Redmond, Wash.) or the OpenGL API (Silicon Graphics, Inc., Mountain View, Calif.).",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},"Rasterizer  receives a set of graphics primitives for each of the objects to be rendered in a scene. In this example, rasterizer  receives each primitive as a triangle having vertices as described above. Rasterizer  may receive the primitives from a software application such as a game, simulator, or other imaging application. Alternatively, as shown in , rasterizer  may receive the primitives from a transform and lighting engine , which may perform coordinate transform and\/or lighting operations on the primitives. Rasterizer  converts the primitives into fragments, each fragment being a bundle of values to update a particular pixel of display frame  as represented in a frame buffer . For example, a fragment may include a value for each of the components in the colorspace (e.g. RGB, HSV, YCbCr) and an opacity or \u2018alpha\u2019 value. The fragment values may also indicate a corresponding location in the rendering space as well as corresponding locations in one or more texture, lighting, or environment maps.","Rasterizer  forwards the fragments to a pixel pipeline , where their values may be modified by processing-intensive operations such as smoothing, blending, and dithering and\/or access-intensive operations such as texture and bump mapping. The particular operations that pixel pipeline  performs on a fragment may depend upon the current configuration of the pipeline (e.g. as defined by the current values of a set of pipeline state variables).","Render backend , which receives the fragments from pixel pipeline , includes a fragment culler  and a pixel combiner . Fragment culler  discards fragments according to the results of one or more culling tests. For example, fragment culler  may perform an occlusion test (or \u2018Z-test\u2019) by comparing a Z value of the fragment to a value of Z buffer  that corresponds to the same pixel. If a fragment is not discarded by the fragment culler, the corresponding pixel in frame buffer  may be updated (e.g. blended or replaced) by pixel combiner  according to the fragment's color value. Other values of a surviving fragment may be used to update corresponding locations in other display buffers as well: for example, the fragment's z-value may be used to update a corresponding location of Z buffer . When all of the objects to be rendered have been rasterized and incorporated into the display buffers, the contents of frame buffer  are modulated onto a display signal (not shown).","In order to enhance the appearance of a generated image, the pipeline may be configured to perform several operations on a fragment. For example, the color and\/or alpha values of a fragment may be altered with reference to one or more effect maps (e.g. texture, bump, and light maps). Such operations may be costly in terms of processor cycles and\/or memory bandwidth. If the fragment culler subsequently determines that the fragment is occluded and discards it, the resources expended on that fragment in the pixel pipeline (e.g. in terms of processor cycles and\/or memory bus usage) have been wasted. It is desirable to reduce such waste.","A method of graphics processing according to one embodiment of the invention includes determining a non-depth conditional status and an occlusion status of a fragment. Determining a non-depth conditional status of a fragment includes determining whether incorporation of a value (e.g. a color value) of the fragment into the pixel is conditional on a non-depth criterion. For example, this task may include determining a current configuration of a pixel pipeline (e.g. determining a value of at least one state variable) or determining whether a non-depth fragment test (such as an alpha test) is enabled. Determining an occlusion status of the fragment may include comparing another value (e.g. a Z value) of the fragment to a value of an entry of a scratchpad, where the entry is mapped to the pixel. Determining a conditional status and determining an occlusion status may occur in either order, and methods according to further embodiments may also include comparing a value (e.g. a Z value) of the fragment to a representative Z value (e.g. corresponding to a location value of the fragment).","A graphics architecture according to an embodiment of the invention includes an early culler and a scratchpad. The scratchpad is configured and arranged to store a value of an entry mapped to a pixel. The early culler is configured and arranged to receive a fragment corresponding to the pixel, to compare a first value (e.g. a Z value) of the fragment to the value of the entry, and to determine whether incorporation of a second value (e.g. a color value) of the fragment into the pixel is conditional on a non-depth criterion. Architectures according to other embodiments of the invention may also include a pixel pipeline configured and arranged to receive the fragment from the early culler.","Depth information is important to the 3D rendering process, as an object that is entirely opaque will occlude those portions of other objects that lie behind it with respect to the viewpoint. Because values of occluded fragments will not be entered into the display buffers (or will be overwritten before display), effort expended in rendering these fragments may be wasted. In some cases, processing overhead and\/or memory bus usage may be considerably reduced by avoiding operations associated with rendering occluded fragments.","In a 3D graphics architecture, it may be desirable to identify fragments that will be discarded and cull them before they reach the pixel pipeline. Specifically, it may be desirable to identify and cull fragments that will be occluded. However, it may not be feasible to determine at the pipeline entrance whether a fragment ultimately will be occluded. One reason for this uncertainty is that the survival of potentially occluding fragments that are currently being processed within the architecture may still be unknown.","In addition to a Z-test, a graphics architecture may perform one or more other tests to determine whether a fragment will be incorporated into a frame buffer or will be discarded. These tests may include a pixel ownership test, a scissor test, an alpha test, a stencil test, and\/or a chroma-key test:\n\n","Depending on the outcome of such non-depth fragment tests, a fragment may survive to be incorporated into the corresponding pixel, or it may be discarded. Until such tests are completed, it is unknown whether this fragment may occlude others.","As shown in , a graphics architecture according to an embodiment of the invention includes an early culler  that compares Z values of fragments to Z values stored in a scratchpad . Fragments that fail the comparison (i.e. fragments identified as occluded) are culled. Fragments that pass the comparison are passed to the pixel pipeline, and their Z values may also be stored to the scratchpad. (As discussed herein, fragments that are far away from the viewpoint have higher Z values than fragments that are close, although other orientations of the Z-axis are also possible.) Early culler  also performs a task of determining a non-depth conditional status of a fragment as described herein.",{"@attributes":{"id":"p-0032","num":"0036"},"figref":["FIG. 5","FIG. 5"],"b":["10","20","20"]},"In an exemplary implementation, scratchpad  is organized into lines, each line being mapped to a predetermined region (e.g. a block) of display frame , and each entry in a line being mapped to a corresponding pixel within the predetermined region. As with a cache, the mapping of scratchpad  to display frame  may be direct-mapped, fully associative, or (n-way) set-associative. In this implementation, each entry of scratchpad  has a valid flag, and each line of scratchpad  also has a valid flag.","In a system that includes a stencil buffer, a portion of each Z value may be reserved for use in stenciling operations such as shadow processing. For example, eight bits of a 32-bit Z-value, or one bit of a 16-bit value, may be reserved for one or more stencil values. It may be desirable to omit the stencil portions when storing such fragment Z values to the entries of scratchpad .","Early culler  and scratchpad  may be implemented in a single chip package integrated on a computer mainboard. Early culler  and scratchpad  may also be implemented in a video graphics card for use in a personal computer. Alternatively, scratchpad  may reside at least in part in system memory. Although it is possible for early culler  to be implemented as a dedicated unit, or as one or more processes executing on a dedicated array of logic elements, it may be more efficient for early culler  to be implemented as one or more processes executing on an array that also performs some or all of the other processing tasks of a 3D graphics architecture (e.g. tasks of transform and lighting engine , rasterizer , and\/or pixel pipeline ).",{"@attributes":{"id":"p-0036","num":"0040"},"figref":"FIG. 6","b":["120","120","120","120","130"]},"In one implementation, task T simply determines whether any of a predetermined set of non-depth fragment tests are enabled. In an OpenGL application, for example, task T may call the function gl IsEnabled with arguments GL_ALPHA_TEST, GL_SCISSOR_TEST, and\/or GL_STENCIL_TEST and test the results. In another implementation, task T also determines whether such a test as configured may actually cull any fragments. For example, while an alpha test may be enabled, it may also be configured to pass any fragment having an alpha value greater than or equal to zero. In such a case, although the test is enabled, it will not actually cull any fragments (assuming that the alpha values are constrained to be nonnegative).","Task T may also determine whether the pipeline is scheduled for a possible modification of a Z value of the fragment (e.g. as may occur in certain texture-based operations). In this case, if incorporation of the fragment into the corresponding pixel is non-depth conditional or if a modification of the fragment's Z value is possible, then task T passes the fragment to the pipeline and the method terminates.","If task T determines that the fragment is robust (i.e. not conditional on the result of a non-depth fragment test), then task T queries the scratchpad to determine whether any entry is currently mapped to a pixel that corresponds to the fragment's location value. If a scratchpad miss occurs (i.e. no entry is currently mapped to that location), task T determines whether any invalid scratchpad line may be mapped to a region (e.g. a block) that includes the pixel. If such a scratchpad line is found, task T maps the line accordingly, stores the Z value of the fragment to the appropriate entry, and marks the line and the entry as valid (the other entries of the line remain marked as invalid until fragment Z values are stored to them).","If task T fails to find an invalid scratchpad line that may be mapped to include the pixel, task T applies a predetermined replacement policy to select a scratchpad line for replacement. The selected scratchpad line is remapped, the fragment is stored to the appropriate entry, and the other entries of the line are invalidated. Task T passes the fragment to the pipeline and the method terminates.","Task T may include any appropriate cache replacement policy. For example, the replacement policy may be based at least in part on a least-recently-used (LRU) criterion. It may also be desirable for the replacement policy to account for the age of the scratchpad line. In a further implementation, the contents of the selected line are written to a miss cache or a victim cache, and task T checks the miss cache or victim cache before deciding that a scratchpad miss has occurred (for further discussion of miss caching and victim caching, see Norman P. Jouppi, \u201cimproving Direct-Mapped Cache Performance by the Addition of a Small Fully-Associative Cache and Prefetch Buffers,\u201d WRL Technical Note TN-14, Digital Equipment Corporation, Palo Alto, Calif., 1990). In an implementation where the scratchpad is direct-mapped, no selection of a scratchpad line is necessary in task T.","If a scratchpad hit occurs in task T, task T determines whether the corresponding entry is valid. If the entry is not valid, task T stores the Z value of the fragment to the entry and sets the valid flag. If the entry is valid, Z test task T compares its value to the Z value of the fragment. If the test succeeds (e.g. the Z value of the fragment is less than the value of the entry), then task T replaces the value of the entry with the Z value of the fragment (in this case, the valid flag is already set). The method passes the fragment to the pipeline and terminates in task T. If the Z test of task T fails, the fragment is culled and the method terminates in task T.","One technique for reducing Z-buffer traffic is to implement a representative Z value memory (also called a \u2018hierarchical Z buffer\u2019 or \u2018HRZ buffer\u2019) as described in copending U.S. patent applications Ser. No. 09\/140,930, entitled \u201cMETHOD AND APPARATUS FOR PROCESSING OBJECT ELEMENTS THAT ARE BEING RENDERED,\u201d and Ser. No. 09\/141,218, entitled \u201cMETHOD AND APPARATUS FOR EFFICIENT CLEARING OF MEMORY,\u201d both filed Aug. 27, 1998 and assigned to the assignee of the present application. This technique supports a conservative culling operation that uses less storage space and memory bandwidth than pixel-resolution Z buffering.","A hierarchical Z buffer that is updated only upon a Z cache miss may not contain the most current representative Z information. For example, changes that occur within a block may not be reflected in the HRZ buffer until the corresponding cache line is replaced. One effect of this latency is that a HRZ buffer test may pass fragments that a test using current representative Z information would have culled. For example, a HRZ buffer test may fail to cull fragments of a self-occluding object.","In contrast, changes that occur within a block may be reflected more quickly in a scratchpad as described herein, and a method using such a scratchpad may provide improved culling performance.  shows a flow chart of a method according to an embodiment of the invention that may be practiced in a system including a hierarchical Z buffer. In this method, task T compares the Z value of the robust fragment to the representative Z value that corresponds to the fragment's location value. If the test fails (i.e. the fragment is identified as occluded), the method terminates in task T and the fragment is culled. Otherwise, the method proceeds with task T as described above.","Although a method according to an embodiment of the invention may be practiced without such capability, a method as shown in  also includes updating the hierarchical Z buffer from valid scratchpad lines in tasks T-T as described below. In this case, each line of scratchpad  corresponds to at least the same block of pixels as a representative Z value of the hierarchical Z buffer.","After the Z value of the fragment has been stored to the scratchpad line in task T, task T determines whether all of the entries in the line are valid. If any entries are invalid, the method terminates in task T and the fragment is passed to the pipeline. Otherwise, task T identifies the backmost Z value (\u2018BMZ value\u2019) among the entries of the line and compares it to the corresponding representative Z value. If the BMZ value is no closer to the display plane than the representative Z value, the method terminates in task T and the fragment is passed to the pipeline. Otherwise, task T updates the HRZ buffer by replacing the corresponding representative Z value with the BMZ value. In a further implementation, task T also marks the line as invalid (i.e. available for the storage of values of fragments corresponding to other blocks).",{"@attributes":{"id":"p-0048","num":"0052"},"figref":["FIGS. 8 and 9","FIG. 9"],"b":"120","i":"a,b "},{"@attributes":{"id":"p-0049","num":"0053"},"figref":["FIGS. 10 and 11","FIG. 11"],"b":["200","260","200"]},"In methods according to additional embodiments of the invention, tasks of scratchpad querying (as in task T), conditional status testing (as in task T), and HRZ buffer testing (as in task T) may be performed in various sequences (e.g. according to efficiencies calculated or estimated with respect to the particular application or architecture) and with or without scratchpad entry initialization.  show flowcharts of methods according to further embodiments of the invention that include HRZ buffer testing and wherein the entries of scratchpad  are initialized to a maximum Z value (or to another initial value as described above). A method as shown in  also includes the feature (e.g. as discussed above with reference to ) wherein fragments may be tested for culling without regard to their conditional status.","The foregoing presentation of the described embodiments is provided to enable any person skilled in the art to make or use the present invention. Various modifications to these embodiments are possible, and the generic principles presented herein may be applied to other embodiments as well. For example, an embodiment of the invention may be implemented in part or in whole as a hard-wired circuit or as a circuit configuration fabricated into a video graphics integrated circuit or field-programmable gate array. Likewise, an embodiment of the invention may be implemented in part or in whole as a firmware program loaded or fabricated into non-volatile storage (such as read-only memory or flash memory) as machine-readable code, such code being instructions executable by an array of logic elements such as a microprocessor or other digital signal processing unit. Further, an embodiment of the invention may be implemented in part or in whole as a software program loaded as machine-readable code from or into a data storage medium such as a magnetic, optical, magnetooptical, or phase-change disk or disk drive; a semiconductor memory; or a printed bar code.","Additionally, an embodiment of the invention may be applied to the early culling of fragments on non-depth bases as well: for example, according to opacity, color, or window or stencil membership. Thus, the present invention is not intended to be limited to the embodiments shown above but rather is to be accorded the widest scope consistent with the principles and novel features disclosed in any fashion herein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 13"}]},"DETDESC":[{},{}]}
