---
title: State record processing
abstract: The invention provides apparatuses and methods for quickly modifying state information. Preprocessing prepares the state information to be modified. A logic unit modifies the state information. Postprocessing then puts the modified state information in proper form for output.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07307986&OS=07307986&RS=07307986
owner: Intel Corporation
number: 07307986
owner_city: Santa Clara
owner_country: US
publication_date: 20030204
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","BACKGROUND","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["This application claims priority from U.S. provisional application No. 60\/354,405 filed on Feb. 4, 2002, which is incorporated by reference herein in its entirety.","1. Field of the Invention","This invention relates to network communications, and more particularly to an efficient and adaptable system for processing packets.","2. Background of the Invention","When data packets are sent through a network, the packets often must be processed or modified between their source and destination. For example, when a packet flows from a LAN (local area network) port to an MPLS (multiprotocol layer switching) port, the packet may have to be converted into an Ethernet over MPLS format, and the traffic fields in the internal header may have to be modified. Other modifications or processing may also be necessary.","State information within a packet processor stores information that is relevant to more than just a single processed packet and thus has a stored lifetime for longer than the processing of a single packet. As packets are processed, the state information. frequently is changed to reflect what occurs during processing. What is needed is a system and method for modifying state information quickly and inexpensively.","The invention employs a table and context based architecture to provide a powerful and flexible way to process packets. Each packet that arrives at a services processor is assigned a packet context that contains information about the packet, state information related to the packet, and about the actions to be done to the packet. This context identifies the next action to be taken in processing the packet. Packet processing follows a table based scheme. Action tables contain actions to be performed on the packet. Lookup tables are used in conjunction with lookup actions as branching functions to determine the next action or action table to be used in the process, among other things. State tables contain information that is stored for longer than the time one packet is processed.","Information within the state tables is often modified in real time as packets are processed. A multiple-path state information update system is used to allow multiple modifications to stored state information to be made at once. This increases the speed at which state information can be updated, so that processing of packets is not unduly delayed. Each path within the state information update system will typically include preprocessing modules that prepare a piece of state information for modification, and arithmetic logic unit for modifying the piece of state information, and postprocessing modules for placing the modified piece of state information in proper form for output.","System Overview","Referring now to , an exemplary use of a full duplex, multiple port services processor  according to the present invention is shown.  illustrates the services processor  as part of a highly integrated Ethernet MAN access switch  with a 10 gigabit aggregate throughput. While present invention will be described in this context, those skilled in the art will recognize that the services processor  of the present invention can be designed for other data rates and has a variety of other uses including but not limited to being part of multi-service switches, metro switches, content switches, stateful firewalls, network probes enterprise routers, multi-protocol routers, Label Edge Routers (LER) and Label Switched Routers (LSR) (IP routers), wireless base stations, bandwidth managers, DSLARs and fast firewalls. As shown in , the Ethernet MAN access switch  preferably comprises a control processor , a control memory , an Ethernet switch or switch fabric , a packet memory , the services processor , a route expand module , a route memory , and associated data memory .","The control processor  is coupled to the services processor  by a packet interface and to the control memory  by a memory bus. The control processor  provides routing and switching protocol support for the services processor . The control processor  uses the packet interface for control plane functions such as configuration and event messages. Packets can also be sent to and received from the services processor  by the control processor  using the control plane. Thus, the operations and processing performed by the services processor  can be fully controlled using the control processor  and routines stored in the control memory .","The services processor  provides advanced switching functions (VPLS bridging, IP routing, fire walling, content switching including TCP termination) and feature processing (ACL and Subscriber Management) in this example. The services processor  is responsible for processing the packets to provide the appropriate routing and filtering as prescribed by the control processor . The services processor  is coupled to the Ethernet switch  for receiving and sending such packets. The services processor  is also coupled to the packet memory . The packet memory  is used to store packets prior to, during and after processing by the services processor . Finally, the services processor  is also coupled to the route expand module  that in turn is coupled to the route memory  and the associated data memory . The route expand module  is used to access large tables used by the services processor . For example, tables such as large label tables, route tables, and flow ID tables are stored in the route memory  and the associated data memory , and can be retrieved into a cache of the services processor  by the route expand module . One embodiment of this is described in patent application Ser. No. 60\/402,359, filed Aug. 8, 2002, titled, \u201cTree Data Structure With Range-Specifying Keys and Associated Methods and Apparatuses,\u201d which is incorporated by reference.","Referring now to , one embodiment for the services processor  is shown in more detail. Specifically,  shows the components of the services processor  and their coupling to the route expand module , and the main memory \/. In one embodiment, the services processor  is manufactured as a single integrated circuit with the route expand module , and a main memory \/ being separate integrated circuit chips. In the embodiment shown, the services processor  preferably comprises a packet processing controller , a packet input unit , a field extraction unit , a state access unit , an editing unit , a queue operations unit , an output scheduler , a packet output unit , a cache and memory controller , and a search processor . The packet processing controller  is coupled by a control bus  to the packet input unit , the field extraction unit , the state access unit , and the editing unit . The cache and memory controller  is coupled to the packet input unit , the field extraction unit , the state access unit , the editing unit , the queue operations unit , the output scheduler , the packet output unit  by a cache bus .","The packet processing controller  controls the operation of the services processor  in its processing and filtering of packets. The packet processing controller  is a control engine that controls the packet input unit , the field extraction unit , the state access unit , and the editing unit  as will be described in more detail below. The packet processing controller  preferably uses a table driven approach to control how packets are processed. The packet processing controller  preferably includes a table entry processor , one or more packet contexts  for each packet being processed, a low level hierarchy  and a control storage area . The low level hierarchy  and the control storage area  are part of the working memory of the packet processing controller  and provide additional areas for storing data need to process a packet.","The table entry processor  is part of the packet processing controller . The table entry processor  receives table entries retrieved by the packet processing controller , decodes the table entries, and sends commands based on the table entries to the packet processing controller . In response to commands by the table entry processor , the packet processing controller  issues control signals on the control bus  to the packet input unit , the field extraction unit , the state access unit , the editing unit , and\/or issues instructions to the search processor . Also in response to commands by the table entry processor , the packet processing controller  stores information in the packet context  and retrieves information from the packet context . Execution of the table driven program by the table entry processor  makes the packet processing controller  effectively a table driven machine capable of processing multiple types of tables including look up tables having comparison data for searching, action tables specifying parsing and action instructions, and state tables for storing any state data that has a lifetime greater than the time required to process a single packet.","A separate packet context  is used by the packet processing controller  for each packet as that packet traverses through the packet input unit , the field extraction unit , the state access unit , and the editing unit . The packet context  is a register set that keeps track of information associated with a packet while that packet is being processed. The packet context  includes several different kinds of registers. The packet context  preferably includes registers that determine which tables are currently controlling packet processing (analogous to a program counter in a CPU), and where in a packet the various protocols start (Encapsulation Pointers). For example, the packet context  includes registers with the following functions: a next instruction register that points to the next instruction to be processed for this packet context, multiple instruction registesr are used to create an instruction stack to support action and lookup tables analogous to subroutines in a CPU; a table handle register that points to the next lookup table to be processed in this packet context; a search result register that contains the result of the last search issued; a packet handle register that points to the packet associated with this packet context; one or more encapsulation pointer registers that acts as index registers for access to data in the packet pointed to by the packet handle register; one or more edit registers used by a packet editor to assemble complex edits that are applied to the packet; one or more key registers used to assemble multi-field search keys; one or more State Record Handle Registers used to access state data and a packet\/context template handle used to access a block of packet buffer memory to load multiple registers in the packet context, as the source for a create packet operation, and as the source for a add encapsulation operation.","The packet processing controller  is also coupled to search processor  to send search requests and receive search responses. The search processor  is coupled to and interfaces with the route expand module  to retrieve data stored in the memories ,  associated with the route expand module . In one embodiment, the search processor  includes resources for performing searches such as a Boundary Addressable Memory (BAM). The search processor  can search for the next table program entry to be processed by the table entry processor , a result from a lookup table stored in memory as directed by the table entry processor , or other information. One embodiment of this BAM is described in patent application Ser. No. 10\/005,986, filed Nov. 7, 2001, titled, \u201cBoundary Addressable Memory,\u201d which is incorporated by reference.","One particular advantage of the present invention is the inclusion of the cache and memory controller  in the services processor . The cache and memory controller  is coupled to main memory \/ and the cache bus . The cache and memory controller  is preferably large enough so that many applications can execute exclusively out of cache . The cache and memory controller  effectively hides the latency of memory access to the services processor . The cache and memory controller  are designed to optimize data across the memory bus and will return data out of order from memory if necessary. The cache and memory controller  may also be locked to enhance performance such as to ensure that cache includes all data structure components or locking the top of the hierarchy in cache to accelerate insertions. It should be understood that both the packet data as well as other state and control information may be stored in the cache . If lookup tables or action table program entries are stored in cache  or main memory , a memory access unit (not shown) adapted for the type of information being retrieved will be included in the services processor . The packet processing controller  will then use the memory access unit, such as a lookup table access unit or action table access unit to retrieve results from the lookup table or retrieve action entries.","The packet input unit  processes the packets as the services processor  first receives them. The packet input unit  is coupled to signal line  to receive packets from the Ethernet switch . The packet input unit  is also coupled to the cache and memory controller  by the cache bus  for storing the packets in the cache and memory controller . The packet input unit  stores the packet data into one or more free blocks in the cache . The packet input unit  is also coupled to the packet processing controller  by the control bus . The packet input unit  notifies the packet processing controller  that a new packet is being received. As soon as the first block has been filled or an end of packet is detected, the packet processing controller  assigns the packet a packet context  and initial table handle, and the other registers in the packet context  are cleared. The packet context is released for further processing by the packet processing controller .","Once a packet is released for further processing, packet processing controller  performs actions in a table specified by the initial table handle. These will typically be packet parsing operations such as extracting a field from the packet and putting the field into one or more key registers to construct a key.","The field extraction unit  is coupled to the cache and memory controller  by the cache bus  for reading data out of cache  and memory \/. The field extraction unit  is also coupled to the packet processing controller . The field extraction unit  is responsive to extract requests from the packet processing controller  and sends extract responses for further processing by the packet processing controller . The function of the field extraction unit  is to retrieve packet data from the cache, extract the portions of packets referenced or addressed by extract requests, and return the extracted data to the packet processing controller . If the packet processing controller  requests packet data from a portion of the packet that has not yet been stored in cache the processing of the requesting packet context will be suspended until the data is received.","The state access unit  processes state load and store requests from the packet processing controller . The state access unit  is coupled to the cache and memory controller  by the cache bus  for reading and writing data into and out of cache . The state access unit  is also coupled to the packet processing controller  to receive state change commands. More particularly, each packet context  preferably has a plurality of state registers and the packet processing controller  may maintain state tables. The data in the state tables is modifiable as is the data in the state registers. The state access unit  increases the processing throughput by retrieving the state information, updating and maintaining state data table information in response to instructions from the packet processing controller .","One particular advantage of the services processor  of the present invention is the ability to edit packets before they are output. The editing unit  is responsible for packet editing performed by the services processor . The editing unit  is coupled to the packet processing controller  and responsive to edit instructions received from the packet processing controller . The editing unit  is also coupled to the cache  to read and write data including packet data. For example, the editing unit  performs a variety of packet modification functions such as: inserting data in a packet, deleting data from a packet, overwriting data in a packet, adding or subtracting a constant, another piece of packet data or register value from data in a packet, recalculating checksums in a packet, performing hashing operations on fields in a packet, packet creation, packet replication, packet segmentation, and packet re-assembly. More specifically, exemplary packet modification operations that occur as part of the output process include: 1) Drop Packet\u2014The drop packet instruction recycles the buffers used for the packet; 2) Output Packet\u2014The output packet instruction causes the edit process to apply all accumulated edits and send it to the queue specified by the queue handle in the output instructions user data component; 3) Sync Edits\u2014The sync edits instruction causes the edit process to apply all accumulated edits and sends it to the head of the input overflow queue; 4) Copy and edit\u2014The copy and edit instruction creates a copy of the packet and sends it to the head of the input overflow queue, and cause the edit process to apply all accumulated edits and send it to the queue specified by the queue handle in the output instructions user data component; 5) Edit and copy\u2014The edit and copy instruction causes the edit process to apply all accumulated edits and sends it to the queue specified by the queue handle in the output instructions user data component and creates a copy of the packet and send it to the head of the input overflow queue; and 6) Copy and Output\u2014The copy and output instruction creates a copy of the packet, causes the edit process to apply all accumulated edits and sends it to the queue specified by the queue handle in the output instructions user data component. Once all packet editing has been performed on a particular packet, a queue instruction output by the editing unit  to the queue operations unit .","The queue operations unit  handles the ordering of packets before they are output. The services processor  groups or orders the packets into queues for output. The queues are preferably maintained in cache  and include a queue control block and link lists of packets. The queue operations unit  is coupled to receive queue instructions once the editing unit  has processed the packets. The queue operations unit  also has the capability to re-order packet for outputting. This helps ensure that the packets are output in the order received. The queue operations unit  is coupled to the cache  to prepare the data for output and maintain the queues in the cache . The operations unit  also manages the length of each queue to shape traffic responsive to queue instructions.","Sometime after the packets have been added to a queue by the queue operations unit , the output scheduler  removes them and sends them to packet output unit . The output scheduler  is coupled to read and write data from the cache . The output scheduler  preferably uses a hybrid list\/calendar queue to determine the priority for outputting the packets. Transmit shaping is accomplished by associating a group of queues with a scheduler. When a queue is associated to a scheduler its scheduling parameters are initialized. The output scheduler  supports multiple scheduling algorithms including: a prioritized scheduler where the scheduler serves the queues in strict priority order; a weighted fair scheduler where scheduler serves the queues in proportion to their weight; a dual token bucket scheduler; a rate limited scheduler; or a Earliest Deadline First (EDF) scheduler. Once scheduled, the packet output unit  retrieves the packets from cache and outputs then from the services processor . The packet output unit  is coupled to the cache  by the cache bus  and has its output coupled by signal line  to the Ethernet switch .","Packet Context",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 3","b":["301","204","301","301","110","210","230","200","200","204","301","204","301","230","301","204","301"]},"In these different sets of registers, the packet context  stores information related to a packet  and information used in processing of that packet  while that particular packet  is being processed. The packet context  is similar to a thread control in a processor in that the packet context  keeps track of the packet , what is being done to the packet , and what will be done to the packet . There is a separate packet context  for each packet  being processed by the services processor . In one embodiment, there are  packet contexts  in the services processor . This provides the services processor  with enough sets of packet context  registers to keep track of every packet  being processed. Other embodiments may have more or less packet contexts . When processing for a particular packet  is finished, the packet context  can be cleared and used for a new incoming packet .When a packet is received and there is no available packet context to assign to the packet, the packet will be placed in an input overflow queue. Packets in the input overflow queue can have higher, equal or lower priority than new input packets for packet context assignment.","What follows is a description of the information stored in a packet context  for each packet  in one embodiment of the present invention. In other embodiments, more, less, or different information can be stored in a packet context .","The packet context  includes information about the packet  itself. A packet handle register  stores a pointer to the location in memory of the packet  to which this packet context  relates. A packet size register  stores the size of the packet  to which this packet context  relates. In the case where packet processing starts as soon as the first cache block is full, the size of the packet may not be known when processing starts. In this case logic in the packet processing controller  and associated with the packet size register will detect references to the packet size before it becomes valid. If such an access occurs the processing of the packet will be suspended until the size is known.","A table handle register  stores a pointer to a lookup table that will be used next during packet processing. A search results register  stores the information returned from the last use of a lookup table.","A packet\/template handle register  stores a pointer to another packet or to a template in memory. The packet\/template handle register  will store a pointer to another packet in memory when, for example, an action that involves two packets is to be performed. One such example is when a concatenation of the packet  to which the packet context relates with another packet is performed. In one such an example, the packet handle register  stores a pointer that points to a first packet with a first header and a first payload. The packet\/template handle register stores a pointer that points to a second packet with a second header and a second payload. The next instruction address register  stores a pointer to an action that, when processed by the table entry processor , causes the payload of the second packet to be added on to the payload of the first packet, resulting in the packet having the header and a payload that includes both the first and second payloads. This capability can be used in conjunction with other editing operations to perform complex packet editing operations such as IP re-assembly. The packet\/template register  can also store a pointer to a template stored in memory. This is useful, for example, when the packet  is of a known type. All the information common to that type of packet can then be retrieved from the template rather than from the packet  itself. This can improve efficiency in gathering information about a packet .","Encapsulation pointer registers  store encapsulation pointers that point to locations within the packet . Encapsulation pointer registers  are used to create encapsulation relative addresses within the packet . The first encapsulation pointer register , encapsulation pointer register , has a value of 0 and points to the beginning of the packet . The other encapsulation pointer registers  point to other arbitrarily defined locations within the packet. In the illustrated embodiment, there are five encapsulation pointer registers , although in other embodiments there may be more or fewer of these registers.","The encapsulation pointers are used for simplified packet data accesses. In one embodiment, encapsulation pointer registers  are 16 bits, which allowable access to 64 kB packets. Typically, the different encapsulation pointer registers  point to the start of various protocols found within a packet. For example, if the packet  is in Ethernet packet, encapsulation pointer register  points to the start of the Ethernet header. Encapsulation pointer register  could point to the start of an MPLS label stack, encapsulation pointer register  to the start of an IP header, and encapsulation pointer register  to the start of a TCP header. These encapsulation pointer registers  make it easy to create relative addresses, for example eight bits into the TCP header, and simplifies programming.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 4","FIG. 4"],"b":["301","301","0","502","301","1","504","2","506","3","508","200","0","502","301","1","504","301"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 5","FIG. 5"],"b":["512","512","502","508","301","0","502","512","504","508","1","504","2","506","3","508","4","510","200","512","0","502","2","506","1","504","512"]},"Returning back to , the packet context  also includes a set of edit registers . When an action table indicates that an edit operation should be performed on the packet , that edit operation to be performed is stored in one of the edit registers . When control is passed to the editing unit , all of the edits stored in the edit registers  are performed on the packet . The edits are stored in the edit registers  based on where in the packet the edits will be applied. For example, edit register  contains the edit to be applied to the information in the packet  that is stored closest to the beginning of the packet . Edit register  contains the edit to be applied next closest to the beginning of the packet , and an edit stored in edit register  is applied nearest to the end of the packet .",{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 6","b":["414","602","414","604","606","608","610","610","604","610","414"]},"Returning again to , the packet context  also includes a set of key registers . The key registers  store data used as keys. For example, one use of these keys is when a lookup operation is performed with a lookup table. The keys can be used in other ways as well. In one embodiment, each key register  includes a length field that specifies the number of bits the key register  contains, and a key field that contains the key itself. In the illustrated embodiment, there are four key registers , although other numbers of key registers  can also be used in different embodiments. Parsing actions can store multiple fields in a single key register  to allow multiple field lookups. Examples of these multiple field lookups include the Cisco n-tuple, Destination Address\/Diff Serve Code Point (DA\/DSCP), and the IP fragment (IP SA\/Packet ID) table lookups.","The packet context  also includes a set of registers used as an instruction stack, known as next instruction registers . The first register of the next instruction registers  is known as the next instruction address register . This next instruction address register  stores the location of the next instruction to be executed by the packet processing controller  and effectively serves as a program counter. The rest of the registers of the next instruction registers  make up a next instruction stack. Providing a stack of next instruction registers allows implementation of subtables, similar to subroutines. When a first table (a primary table) calls another table (a subtable), the next instruction address register  identifies the next instruction in the subtable, and the next instruction stack identifies the next instruction in the primary table. This allows a process to return to the correct point in the primary table once execution of the instructions in a sub table have been completed.","Finally, the packet context  includes a set of state record handle registers . State records contain data that the services processor  stores for longer than the duration of the processing of one packet within the services processor . For example, state records can store information about a TCP session. A TCP session will span many packets, and be related to all the packets that make up that session. If a packet to which the packet context  relates is part of a TCP session, it is typically desirable to update a TCP state record with information about that packet. The state record handle registers  provide a link to the state records related to that packet so that information may be retrieved from the state record, or the state record may be modified as required. In one embodiment, the state record handle registers  can be loaded from the data extracted from the packet  in a parsing operation, from the return value of a lookup operation, or from other operations.","Table Driven Packet Processing and Tables","In one embodiment of the present invention, there are two primary types of tables used by the services processor  to process a packet: lookup tables and action tables. A third table type, a state table, may also be used or modified during packet processing.  is a block diagram that illustrates an exemplary table based program, the action tables, lookup tables, and state tables used by the program, and how these table types are used by the packet processing controller  in the services processor  to process a packet  according to the table based program. The example of  is a simple descriptive overview of one example of how a packet  can be processed. The present invention allows a programmer to specify how a particular packet  is processed by specifying the tables used in a table based program and\/or creating tables. Thus, actual processing performed on the given packet  may be different in substance and\/or complexity from the example described.","The packets  are processed using a table based processing scheme. After assignment of the packet context , the packet  is assigned an initial action table  by the services processor packet processing controller . This is done by storing the location of the first instruction in the initial action table  in the next instruction address register  in the packet context . In one embodiment, the other registers in the packet context  are cleared at this time. The location of the first instruction in the initial action table  may be determined by the port through which the packet  arrived, for example, so that a packet arriving from a set port will have a set initial action. Other schemes for determining the location of the first instruction in the initial action table  may also be used. The initial action table , as well as other action tables, are tables that contains linked lists of one or more actions to be taken to process the packet . Actions identified by the action tables can include packet parsing operations, edits that specify editing operations to be done to the packet , search operations, and other operations.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 8","b":["800","800","800","802","804","806","808","810","812","802","804","202","804","200","804","422","204","804"]},"The table handle field  allows the use of subtables. If an address of an action table or a lookup table is in the table handle field , and the program control field  is a call to another table, the table referenced in the table handle field  will be used as a subtable. If the sub table is a lookup table, information from the table handle field  will be stored in the table handle register  of the packet context . If the subtable is an action table, information from the table handle field  will be stored in the next instruction address register  of the packet context . When the information from the table handle field  is stored in the next instruction address register , the next instruction address from the next instruction address field  is \u201cpushed\u201d to the next instruction register in the next instruction stack  of the packet context . This allows the packet context  to keep track of the next instruction to be performed in the table while any actions or operations specified in the subtables are performed. When a sequence of instructions in the called subtable ends with a return action, the return will \u201cpop\u201d the instruction address stack  so that the information in next instruction stack  gets moved to the next instruction address register . This allows the packet processing controller  to return to the correct spot within the first table from which the subtable was called. Since there are multiple next instruction stack registers, subtables may also call further subtables.","The type field  indicates what type of action is to be taken. Examples of types include a parsing operation, a modification operation, and a search operation that uses one or more of the keys stored in the key registers  of the packet context . The control word field  contains the control word that tells the packet processing controller  which operation to execute. The format of the control word in the control word field  will depend on what type of action is to be taken. Finally, a user data field  contains programmer-specified information related to the action that can be used by the packet processing controller , the editing unit , or other components during processing of the packet. For example, if the action is to add a tag to a packet, the user data may contain the information that makes up the tag and is added to the packet when the tag is added. The user data field  may also specify information to be loaded into a state record handle register .","Returning to , the packet processing controller  retrieves the first action to be performed from the location specified in the next instruction address register  and sends it to the table entry processor . Next, the table entry processor  decodes the initial action and sends instructions to the packet processing controller  to perform the initial action specified by the initial action table . In the example shown in , the initial action is a packet parsing operation that extracts a field from the packet  and constructs a key from the extracted field, although other initial actions could also be specified by the initial action table . To extract the field from the packet, the table entry processor  send a command to the packet processing controller , which in response requests that the field extraction unit  extract a field from the packet  and send that field to the packet processing controller . Next, the table entry processor  constructs a key from the extracted packet field. This key is passed to the packet processing controller , which stores the key in the packet context . Note that, while the description and illustration only uses one entry in the initial action table  to extract the field and construct a key, in some embodiments, it may take multiple actions in the initial action table  to perform the field extraction and key construction operations.",{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 9","b":["810","301","902","904","910","416","204","416","416","416","416","416"]},"Returning to , the next operation in the initial action table  is a lookup operation. In a lookup operation, the table entry processor  uses a key from the key registers  in conjunction with the search processor  or memory access unit to search the lookup table  specified by the lookup operation action and return information. Lookup tables have entries that store comparand and search result data. A lookup table  includes a match type\/default rule that defines the match operation performed by the table and a search result for a no match condition, and can also include one or more classification or match rules rules. The lookup table  may be searched by the search processor  under command from the table entry processor , or may be searched by a memory access unit (not shown) under command from the table entry processor  if the lookup table is stored in cache  or main memory . Typically, the information returned from the lookup table is a value and a pointer. The value could be an argument to be used in an action, information used to edit the packet, or other information. The pointer typically points to the next action to be performed.","In the embodiment illustrated in , the information returned from the lookup table  includes an identification of an action subtable that is to be called next by the initial action table . In this example, the lookup operation is used to determine which of two different action subtables  and  are to be called by the initial action table . Thus, the information extracted from the packet was used to construct a key used with a lookup table  to determine which action subtable ,  is called. Different sub action tables ,  will be called depending on the information within the packet.","When an action subtable ,  is called, the table entry processor  causes a pointer to the first action in the sub action table ,  to be stored in the next instruction address register  of the packet context , and \u201cpushes\u201d the pointer to the next action in the initial action table  up into the next instruction stack  of the packet context . Then, the actions in the called sub action table ,  are executed by the table entry processor . The last action in each sub action table ,  is a return to the initial action table . The act of returning from the sub action table ,  causes the pointer from the next instruction stack  in the packet context to be \u201cpopped\u201d into the next instruction address register  by the table entry processor . This allows the next action in the initial action table  to be executed in its correct order.","As described above, the different values returned from the lookup table  allow a branching function, so that any one of multiple sub action tables ,  may be called. Further, since a sub action table is called, the actions in the sub action table are executed, and then the process returns to the initial action table, the sub action tables act as subroutines. While each illustrated sub action table ,  simply specifies multiple actions to be executed linearly and then return to the initial action table , more complex arrangements can also be used. For example, a sub action table ,  can specify lookup operations, make a call to another sub action table, or perform other operations.","The next action in the initial action table  is another lookup operation using a second lookup table . The key used in this lookup operation may have been generated by one of the actions in one of the sub action tables, may have been generated by another parsing action and extracting more information from the packet , or through another operation. This key is used with the second lookup table  to return information identifying a next action table to be used after the initial action table . Thus, this lookup operation action acts as another branch operation.","In the example illustrated in , there are two possible next action tables ,  that can be called. The actions identified in whatever next action table ,  was called are executed in order. For example, the actions in the action tables ,  may specify multiple edits to be performed on the packet . In this case, the table entry processor  decodes the edits to be performed, and sends a command to the packet processing controller  to store the edits to be performed in the edit registers  of the packet context  for that packet . In the illustrated embodiment, neither next action table ,  has a branch, and the final action in both of the next action tables ,  include a pointer the same third next action table .","Since both of the next action tables ,  end with a pointer to the third next action table , the possible branches that occurred with tables  and  have rejoined, so that no matter which of the first set of next action tables ,  was executed, the same third next action table  is executed next. Such divergence and convergence of process flow is possible throughout the process, depending on how the tables have been programmed by the programmer. In some cases, divergence may occur without convergence, for example, or other process flows may be programmed.","The third next action table  includes a lookup operation. In this described example, a packet parsing operation is first performed and the destination address of the packet  is used as a key. The value returned from the lookup table  is the port in the switch from which the packet  will be sent after processing. After the lookup operation, the third next action table  specifies an \u201cupdate state\u201d action. This action updates the information stored in a state table . State tables store information that is useful for more than the lifetime of one packet. In this case, the state table  stores information about the ports of the switch . One or more of the information fields in the state table  stores the number of packets that have been sent from each output port. When a packet  is to be sent out through particular output port, the state table  is updated to reflect that another packet has been sent from that port. Other types of state tables that may be useful and updated during packet processing include TCP session state tables that store information about a TCP session of which the packet being processed is a part. The records in a state table may be arbitrarily defined by a programmer.","The packet processing is then terminated by a \u201csend to edit\u201d action that passes processing control to the editing unit  to apply the editing operations specified by previous actions and stored in the edit registers  of the packet context . The editing unit  then sends the edited packet  to the queue operations unit  to be queued for output. A programmer can also specify other actions to terminate packet processing. For example, the process can be terminated by an action that drops the packet, an action that passes control to the editing unit  to apply the specified editing operations and then returns control to the packet processing controller  for further actions to be done on the packet , or another action that terminates the process.","State Record Processing","In one embodiment, state records are 32 bytes long, and a state table can have one or more state records. Objects within a state record may be 64, 32, 16, or 8 bits long. 32- and 64- bit objects are aligned with 32 bit boundaries within the state record, 16 bit objects are aligned on 16 bit boundaries, and 8 bit objects are placed anywhere in a state record. The programmer is responsible for controlling the alignment and packing of the state objects within the state records. The state records support signed and unsigned integers, and statistics. In other embodiments, state records can have other lengths with different sized objects. The objects may be placed differently within the state records, and support for different types of information may be included.","In another embodiment, the size of the state record is chosen to fit in a single cache line in the main memory \/ system of the services processor . Frequently accessed state records containing data such as port statistics will have a high probability of being in cache . Additionally, the striping of the buffer data structure across RLDRAM banks, out of order access capability, and caching will interact such that when many cache misses occur the bank accesses to the RLDRAM will occur in an order that eliminates the same bank access penalty at the cost of an increase in access latency. The cache miss will result in a stall of the packet context. The large number of packet contexts will avoid significant performance impact due to the cache miss stalls.","The state access unit  is also known as a state processing unit  and functions to add, remove, or modify information in state records in the state tables. The operations that the state access unit  performs include increment, decrement, add, subtract, and hash. Other operations may be supported in other embodiments. When an operation results in an overflow, two types of overflow may occur. If the state record is a statistic, a \u201csticky\u201d overflow occurs, where any operation that results in an overflow produces and all ones results. For a normal arithmetic overflow that occurs with integers, a wraparound overflow occurs. Other types of overflow may also be supported in other embodiments.","Typically, an action entry  is what prompts a modification to a state record. State record handles that point to the state objects of a state record to be modified are loaded into and stored in the state record handle registers  of the packet context . The state record handles may be loaded from the user data field  in an action entry , from information extracted from the packet , from the value returned as a result of a lookup operation using a lookup table, or from other sources. The same or a different action entry  then causes the table entry processor to cause the packet processing controller  to send a command to the state access unit  to modify a state record. The fields - of the action entry  also provide the information that specifies how the state record will be modified.",{"@attributes":{"id":"p-0072","num":"0071"},"figref":"FIG. 10","b":["214","110","214","1002","420","420","214"]},"The state access unit  includes four sets of input multiplexers . Each set of input multiplexers  contains one or more input multiplexors . The state record  is one input to the input mulitplexors , and information  from an action entry  provides other input to the input multiplexors . A state record format decoder  puts the information  in a form usable by the input multiplexors , and sends the correct data to the correct input multiplexor . The input multiplexors  perform premodification functions (also known as preprocessing functions) on the state record  to prepare the state record  for modification. The premodified state records  from the input multiplexors  are a first operand input to the arithmetic logic units .","There are four arithmetic logic units  that make the changes to the data within the state record . The output of the input multiplexors  is one input to each arithmetic logic unit . There are four operand multiplexors  in the state access unit . The output of each the operand multiplexors  is the other operand input to the arithmetic logic unit .","There are several data sources  that may be selected to be used as the second operand input to the arithmetic logic unit . Each of these data sources  is input to four operand multiplexors  (one for each arithmetic logic unit ). The operand multiplexors  also receive a filter input  that determines which one of the multiple possible data sources  will be used as the second operand input to the arithmetic logic unit . In the illustrated embodiment, the three operand data sources  are the information from one or more of the key registers  of the packet context , the information from the packet size registers  of the packet context , and user data  from the action entry . In other embodiments, other information can also be used as an operand data source . Information from the control word  of the action entry  is used as a filter input . Thus, the action entry  that causes the modification of the state record  also includes information that determines what data source  is used as the second operand input to the arithmetic logic unit .","The control word  of the action entry  also determines the state record  modification operation performed by the arithmetic logic unit . This operation input  is sent to the arithmetic logic unit  in addition to the two operands. The arithmetic logic unit  then performs the operation that modifies the state record.","The output of the arithmetic logic unit  as well as the input state record  are input to four sets of output multiplexors . Each set of output multiplexors  can include one or more output multiplexors . Information  from the action entry  that prompted the modification of the state record  also provides other input to the output multiplexors . The state record format decoder  also puts the information  in a form usable by the output multiplexors . The output multiplexors  perform postmodification functions (also known as postprocessing functions) to place the modified state record in proper form for output. The output from the output multiplexors  is combined and output as the modified state record .",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 11","b":["1002","214","1004","1014","1004","1102","1104","1106","1002","1102","1010","800","1002","1018","1102","1102","1002"]},"The word or words to be modified are received by the rotate right multiplexer . Information  from the action entry  also includes the byte offset that indicates the location within the word or words that will be modified. The state record format decoder  decodes this information and sends the byte offset to the rotate right multiplexer . The rotate right multiplexer  rotates the information within the word or words to be modified so that the information is in the proper position to be modified by the arithmetic logic unit . The rotate right multiplexer  then outputs the rotated word or words.","The rotate word or words are received by the mask multiplexer . Information  from the action entry  also includes the number of bytes that will be modified. The state record format decoder  decodes this information and sends the number of bytes to be modified to the mask multiplexer . The mask multiplexer  creates a mask so that the correct bytes within the word or words will be modified by the arithmetic logic unit . The mask multiplexer  also creates the inverse of this mask. The mask multiplexer  outputs the rotated word or words masked by the mask, and also outputs the rotated words or words masked by the inverse of the mask.","The arithmetic logic unit  receives the masked rotated word or words, a second operand from the operand multiplexer , and the identity of the operation to be performed from the operation input . The arithmetic logic unit  then uses the masked rotated word or words and the second operand to perform the identified operation to modify the word or words. The modified word or words is output from the arithmetic logic unit .","The output multiplexors  include a bitwise or operator  and a rotate left multiplexer . The bitwise or operator  receives the modified word or words from the arithmetic logic unit  and also receives the rotated word or words that have been masked by the inverse of the mask. The bitwise or operator  combines these two inputs to result in a word or words that includes the changes made by the arithmetic logic unit  as well as the other data in the word or words that remains unmodified. These word or words are thus the modified but rotated word or words and are output from the bitwise or operator .","The rotate left multiplexer  receives the modified rotated word or words. The byte offset received by the rotate right multiplexer  is also received by the rotate left multiplexer . The rotate left multiplexer  uses the byte offset to rotate the information within the word or words back to its original position. The result of this operation is the modified word or words from the state record . This is combined with the results from the other rotate left multiplexors  to form the modified state record .","The foregoing description of the embodiments of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise forms disclosed. Persons skilled in the relevant art can appreciate that many modifications and variations are possible in light of the above teaching. Persons skilled in the art will recognize various equivalent combinations and substitutions for various components shown in the figures. It is therefore intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
