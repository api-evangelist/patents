---
title: Performance of intermediate nodes with flow splicing
abstract: A method and apparatus for splicing a first data flow inbound to an intermediate node and second data flow outbound from the intermediate node transforms the first data flow and the second data flow into a single composite data flow originating at the source of the first data flow and terminating at the destination of the second data flow. The method allows any other data flows associated with the first or second data flow, such as other data flows associated with connections that encompass either the first or second data flow, to remain unaffected by the splice. The method allows intermediate nodes in a network to influence data flow between a pair of nodes at or above the transport layer without incurring all the overhead commonly associated with transport and higher layer processing.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07139268&OS=07139268&RS=07139268
owner: 
number: 07139268
owner_city: 
owner_country: 
publication_date: 19990129
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The invention is directed to communication via packet switched networks. It more particularly is directed to methods for improving the performance of intermediate network nodes that participate at or above the transport layer in communication between one or more node pairs.","Traditionally, internet software has been developed in accordance with the principle that very limited functionality is provided in \u201cthe network.\u201d Specifically the network provides unreliable forwarding of messages or packets. Following this model, additional functionality, such as reliable delivery and flow control, is implemented entirely at communication end points without adding any functionality to the network.",{"@attributes":{"id":"p-0004","num":"0003"},"figref":"FIG. 1","b":["101","102","101","102","103","101","102"]},"As internet technology has evolved, significant functionality has found its way into \u201cthe network.\u201d For example, it is increasingly common for a client running a web browser to connect to an intermediate node rather than directly to a web server. Such intermediate nodes include but are not limited to: SOCKS servers, fire walls, VPN (virtual private network) gateways, TCP routers or load balancers, caching proxies and transcoding proxies used with resource-constrained clients such as handheld devices.","The number and types of such intermediate nodes will continue to increase as internet technology evolves to provide additional functionality. The performance of the intermediate nodes will increase in importance as the number of internet clients continues to grow rapidly. This growth will be fueled by large numbers of handheld and pervasive devices that will require intermediate nodes capable of supporting hundreds of thousands to millions of clients simultaneously.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2","b":["201","202","203"]},"Each intermediate node influences communication between the first node  and the second node . In many instances, the interface provided by an intermediate node to the first node  resembles or is identical to the interface provided by the second node  to the intermediate node. Similarly, the interface provided by an intermediate node to the second node  is typically similar to the interface provided by the first node  to the intermediate node. Because of this similarity of interfaces, the first node may not be able to determine if is connected to an intermediate node or to the second node. Similarly there may be no way for the second node to determine if it is connected to an intermediate node or to the first node. The similarity of interfaces allows there to be any number of intermediate nodes between the first node  and the second node . This property is depicted in .","A key difference between a router and an intermediate node is that routers perform processing only at layers one through three of the ISO seven layer model, those are the physical, data link and network layers, while intermediate nodes perform processing at and possibly above the fourth or transport layer.  depicts the processing performed by a router in terms of layers. The corresponding diagram for intermediate nodes is shown in .","We define a connection to be a bi-directional communication channel between a pair of connection end points such that information written to one end of the connection can be read from the other end. A connection includes two flows. A flow is a unidirectional communication channel between a pair of flow end points such that information written to the source flow end point can subsequently be read from the corresponding destination flow end point. A connection need not necessarily be supported by a connection oriented protocol. All that is required is the identification of a pair of connection end points and propagation of data between the end points. Connections and flows reside at the fifth or session layer in the ISO model. Because routers in general do not perform processing above layer three, routers generally do not perform processing explicitly related to connections. Intermediate nodes however do generally perform processing explicitly associated with connections.","In fact, intermediate nodes can be distinguished from routers in terms of connections. In , the first node  communicates with the second node  via a single connection  whereas in  communication between the two nodes takes place via multiple connections in series , , , ,  and . The use of multiple connections provides each intermediate node with end points that can be used to influence communication between the first node  and the second node . However, intermediate nodes typically expend much of their resources simply moving data from one connection to another. In one common scenario, the intermediate node monitors the flow of information between the first node  and second node  only until a request made by the first node  can be identified. In another common scenario, the intermediate node monitors the flow of information only in one direction. The performance and capacity of an intermediate node is often determined therefore by the efficiency with which it moves data between connections.","Having a series of connections between the first and second node can cause several undesirable side-effects. Connections in series tends to deliver worse performance in terms of latency compared to a single connection and may also degrade throughput. Each node in a packet switched network introduces some delay and imposes a throughput limit. The performance of a packet switched network therefore relies on minimizing the delay introduced and maximizing the throughput supported by each node. This is accomplished, in part, by performing only minimal processing at each node. The packet forwarding performed by a router entails only a small amount of overhead, but the processing associated with connection end points performed by an intermediate node is significant.","The presence of multiple connections also alters the semantics of communication between the first node  and the second node  of . For example, with a single connection, the first node  is assured data has arrived at the second node  when it receives an acknowledgment. With multiple connections, the first node  may be led to believe data has arrived at the second node  when, in fact, it has only reached the first intermediate node.","It is therefore an object of the present invention to improve the performance of intermediate nodes using an approach called flow splicing. A flow splice transforms a pair of flows, a first flow inbound to an intermediate node and a second flow outbound from the intermediate node, into a single third composite flow that originates at the source of the first flow and terminates at the destination of the second flow. The transformation is invisible from the source node at which the first flow originated and the destination node at which the second flow terminated.","A flow splice is applied to a pair of flows in one direction between a first and second node independent of any associated flows. For example, a flow splice transforms one flow of a connection without modifying the other flow associated with the same connection. The unidirectional nature of a flow splice is an essential characteristic as techniques used to splice connections do not generally allow data flow to be spliced in one direction only. The ability to splice in one direction only greatly increases the number of scenarios in which splicing can be applied.",{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 6","b":["1603","601","602"]},"Splice Architecture","A node is any device capable of communicating via one or more communication networks or links.  depicts two nodes A  and B  communicating via a connection C. The connection C is bi-directional and includes of two flows. Flow F carries data from node A  to node B . Similarly, data flows in the reverse direction, that is from node B  to node A  along flow F. A connection therefore includes of two flows, one in each direction, between a pair of nodes.","A connection may also be denoted by a pair of end point pairs. In , connection C extends between end point pair EP at node A  and end point pair EP at node B . End point EP denotes the flow outbound from node A  via F and the inbound flow to node A  via F. Similarly, end point pair EP denotes the flow inbound to node B  via F and the flow outbound from node B  via F. The order in which the nodes linked by a connection are listed in the connection name is not significant. For example the name Cdenotes exactly the same connection as C.","The nature of a flow is that data written to the source flow end point can subsequently be read from the destination flow end point. Although boths ends of a flow can reside on the same node, flows are commonly extended between nodes through the use of transport protocols such as TCP\/IP, AppleTalk and NETBIOS.","One aspect of the present invention allows two flows, one inbound the other outbound relative to a given node, both flows being terminated at the given node, to be transformed into a single flow through the given node. The method of the present invention transforms the two flows into one flow which originates at the source of the original inbound flow and terminates at the destination of the original outbound flow. The method does not require any particular relationship between the two flows to be transformed other than that one flow be inbound the other flow be outbound at the intermediate node at which the transformation is performed. The two flows may or may not be associated with the same connection. The source of the inbound flow and destination of the outbound flow may reside on the same node or on different nodes. The term \u201cflow splice\u201d or simply \u201csplice\u201d is used herein to refer to this described transformation. Before two flows are spliced, any amount of data can be read from the inbound flow and written to the outbound flow. Subsequent to the creation of a splice, data arriving on the inbound flow is automatically sent on the outbound flow. That is, data is propagated to the outbound flow without any further action by the entity that invoked the splice operation. Except for performance considerations, a pair of spliced flows resembles a pair of flows where data is read from the inbound flow as it arrives and is immediately written to the outbound flow.","The splice operation has a wide variety of applications. For example the connections depicted in  could correspond to any of many different transport protocols including IP, UDP, TCP, IPX, OSI, NETBIOS, AppleTalk, etc. Any of several application programming interfaces (APIs) could be used to create and manipulate the flows transformed by a splice. These include the Berkeley Socket Interface, the STREAMS interface, NETBEUI and IBM's Common Programming Interface for Communication (CPI-C). Both flows transformed by a given splice may be associated with the same transport protocol or each may be associated with a different protocol. Each protocol may be either connection oriented or connection less. We proceed to describe the method of the present invention in its most general form and subsequently describe specific instances of the invention's application in more detail.","The specific details of implementing the splice operation vary somewhat depending on the particular transport protocols involved. One characteristic feature of a splice implementations is however that it \u201cshort circuits\u201d or reduces protocol processing at and above the transport layer. An obvious approach to reducing processing above the transport layer is for the splice implementation to simply modify each packet received on the inbound flow to make it suitable for transmission on the outbound flow and immediately send the packet.","Another aspect of the present invention defines an architecture for manipulating data flows that can be combined with an existing communication architecture. The only requirement of the existing architecture is that is allows the establishment of data flows.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 8","b":["801","802","803","808","809","802","801","803"],"sub":["AI ","BI "]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 9","FIG. 8","FIG. 9","FIG. 8","FIG. 9"],"sub":["AI ","IB ","AI ","IB ","AB ","I1 ","I2 "],"b":["804","806","1802","804","806","904","802","811","812"]},"By combining two flows into one, the splice eliminates two flow end points. The two are the destination end point of the inbound flow, and the source end point of the outbound flow. Note two of the so-called end point pairs in , specifically EP and EP include only a single end point. Also note  does not show any connections as previously defined. That is it does not show any flow pairs in opposite directions between the same pair of nodes. The splice depicted in  therefore eliminates the connections C and C shown in .","The splice depicted in  changes the destination of the outbound flow associated with end point pair EP on node A  and similarly changes the source of the inbound flow associated with end point pair EP on node B . Despite this, the splice is transparent to both node A  and node B . Nothing intrinsic to the splice allows an observer on node A  to detect that data sent outbound from end point pair EP ends up at node B  instead of node I . Similarly, nothing intrinsic to the splice allows an observer on node B to detect that data received on end point pair EP originates at node A  instead of node I .","The splice is, in fact, undetectable from node B  unless either the data received on the inbound flow associated with end point pair EP or the rate at which it arrives identifies the sender. Similarly the splice can not be detected from node A  unless the rate at which data is received after being sent on the outbound flow associated with end point pair EP can be detected at node A  in such a way as to identify the receiver.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIG. 10","FIG. 8","FIG. 10","FIG. 10","FIGS. 9 and 10"],"sub":["I2 ","I1 ","BA "],"b":["812","811","1006"]},{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 11","FIG. 8","FIG. 9","FIG. 10","FIG. 9","FIG. 10","FIG. 11"],"sub":["AI ","IB ","AB ","BI ","IA ","BA ","AI ","BI ","AB "],"b":["804","806","1104","807","805","1105","808","809","1106"]},"More complicated examples of flow splicing are possible.  shows an example with four nodes, A , I , B , and C  and four flows F, F, F and F. The scenario in  resulted from transforming a scenario with three connections, one from node I  to each of nodes A , B , and C  with two flow splices. Another likely scenario is the case where a series of flows from a source node to a destination through a set of network intermediaries are transformed into a single flow from the source to destination using a number of flow splices.","We now consider the use of flow splicing. The splice architecture allows a flow to be spliced after any amount of data, or no data, has been sent or received on the flow. The architecture also allows a spliced flow to revert to the unspliced state either due to termination of the inbound flow or because the splice was explicitly eliminated at the intermediate node. This flexibility allows flow splicing to be used in a variety of ways.","One potential use for flow splicing is load balancing. An intermediate node can use flow splicing to balance the load from a set of clients across a set of servers. An intermediate node can implement load balancing by establishing one or more flows with client nodes, establishing one or more flows with server nodes and splicing flows between the clients and servers.","Another use for flow splicing is content partitioning. This refers to dividing a set of content (or services) across a set of servers possibly with multiple servers providing the same content. An intermediate node can make it appear to clients that all the content is available from a single server node. A content partitioning intermediate node operates similarly to a load balancing intermediate node in terms of splicing flows between clients and servers.","As an example we consider an intermediate node that allows World Wide Web content to be partitioned across a set of servers. The web intermediate node starts by accepting a TCP connection from a client. It then reads one or more requests from the flow inbound from the client. Next the intermediate node determines an appropriate server to service the client request(s). It then establishes a connection, including of two flows one in either direction, with the selected server assuming an appropriate connection is not already available. The intermediate node then selects the inbound flow from the chosen server and the outbound flow to the client and splices the selected flows. Finally, the intermediate node writes the request that it had received from the client to the server.","The response from the server subsequently flows to the client via the splice. The client may close the connection after sending a request in which case processing for the connection is complete. The client might also send another request on the same connection in which case the intermediate node can either write the request to the same server allowing the response to flow across the established splice or resplice the outbound flow to the client to a different flow inbound from a server and send the client request on the corresponding flow outbound to that server instead.","It will be understood by those skilled in the art that the process just described can be applied to a wide variety of intermediate node functions and communication protocols. For example, the steps listed above for the web intermediate node can be used to provide load balancing and content partitioning for a list of protocols including HTTP, SOCKS, telnet, FTP, AFS, DFS, NFS, RFS, SMTP, POP, DNS, Sun RPC, and NNTP.","One significant aspect of many applications of flow splicing is that the intermediate node may decide what node to establish either the first or second connection with based on several factors. For example the intermediate node may determine what node to establish the second connection with after parsing a request read from the first connection. The intermediate node might also determine what specific port or address within the first node to establish the first connection with based on the remote address associated with the second connection. The intermediate node might do this to direct requests from certain clients to certain servers. Other factors the intermediate node may consider include estimates of bandwidth and latency for the various flows, quality of service (QoS) requirements for the various flows, the number of network hops between any of the nodes, and configuration or state information stored at the intermediate node.","In addition to determining what address a connection should be established with, the intermediate node may determine whether to perform a splice at all based on several factors. For example an intermediate node may parse requests sent by a client to a server in order to estimate the amount of data expected to flow from the server to the client and splice only flows expected to handle a lot of data. The intermediate node might also splice only flows expected to support high bandwidth and\/or low latency. Finally the intermediate node might splice only those flows associated with a specific set of clients or servers.","We now describe a method that embodies the splice operation for the specific case where both flows joined by the splice are associated with TCP connections. It will be understood by those skilled in the art that the concept of transforming two flows, one inbound the other outbound at a given point, into a single flow from the source of the original inbound flow to the destination of the original outbound flow by suitably modifying packet headers can be applied to any packet based communication protocol.","Let us now consider TCP state. Every TCP end point pair has a set of associated state information. This information is referred to in the following discussion by the name TCB which stands for TCP Control Block. The specific way in which the state information is stored in a TCB is not important to the following discussion. The discussion does however refer to some specific elements of the TCB which are described as follows.","snd_nxt\u2014The sequence number of the next byte to be sent. One greater than the greatest sequence number sent so far.","snd_una\u2014The smallest sequence number associated with any byte that has been sent, but has not yet been acknowledged. Equal to the greatest acknowledgment value received.","rcv_nxt\u2014The sequence number of the next byte of data expected to arrive. One more than the greatest sequence number received.","rcv_wnd\u2014An offset from rcv_nxt that identifies the largest sequence number a receiver is willing to receive.","Now we consider forward and reverse information.  shows the structure of a TCP packet header. The information contained in a TCP packet may be divided into two categories. The first we call forward outbound information. This includes of the packet's data payload and associated sequence number , checksum , urgent pointer , and any time stamp option value. The second category we call reverse inbound information. This includes the acknowledgment flag  and field , window size , and any time stamp option echo value. The fields of the TCP header that contain reverse inbound information are shaded in .","Certain fields of the TCP header and in the associated IP header identify the connection with which the segment is associated. These fields are the source and destination port number in the TCP header and the source and destination IP address in the IP header. Because these fields identify the connection, they are associated with both the forward outbound and reverse inbound information.","The forward information is intended for the end point pair to which data is sent on a TCP connection. The reverse information is intended for the end point pair from which data is received on the connection. Without flow splicing, these two end point pairs are identical. A splice, however, can break this equality. The ability to splice each flow associated with an end point pair independently relies on independent processing of the forward outbound and reverse inbound information. The specific details of processing forward and reverse information in TCP packets is described in further detail below.","The next aspect to consider is splice states. A flow splice joins two flows into one thus eliminating a pair of flow end points. Several factors may make it impossible for the end points to be eliminated immediately when a splice is created. A splice therefore has an associated state value that influences its operation. We now discuss various factors that influence a splice's state and the operation of a splice in each state. A state diagram showing the various splice states and the logic for transitions between them is shown in .","One consideration that can prevent spliced end points from being eliminated is the presence of data in send or receive buffers associated with the spliced flows. Each flow end point generally has an associated buffer. An inbound flow has a receive buffer that contains data that has been received but has not yet been read by the application. An outbound flow has a send buffer that contains data that has been written by the application but has not yet been successfully sent. Any data that resides in the send buffer when the splice is created is sent before packets can be forwarded via the splice. Similarly any data in the receive buffer is sent after any data in the send buffer and before any packets are forwarded.","If data resides in either the send or receive buffer when a splice is created, the splice starts in the PENDING  state. Any data residing in the receive buffer when the splice is created is appended to the contents, if any, of the send buffer. The receive buffer is then essentially eliminated as any data subsequently arriving at a splice in the PENDING  state is appended to the send buffer associated with the outbound flow instead of being appended to the receive buffer of the inbound flow as would be the case for data arriving on an unspliced flow.","Full protocol processing is performed for each end point associated with a splice in the PENDING  state. A PENDING  splice behaves similarly to a program that reads data from the inbound flow as it arrives and writes it to the outbound flow. The splice however eliminates the need to invoke a separate program, possibly saving protection domain and context switches, and also eliminates any data copies between the protocol implementation and the program.","A splice remains in the PENDING  state at least until its send buffer is empty. Additional data arriving at a PENDING  splice may thwart attempts to empty the buffer. A PENDING  splice may therefore limit the amount of data it receives by closing its receive window. The receive window is an item of reverse inbound information that informs a sender how much data a receiver is willing to receive. The TCP protocol forbids a receiver from decreasing its receive window by an amount greater than the amount of data it has received. In other words, once a receiver has indicated it is able to receive a given amount of data, it honors its commitment. However, if a receiver indicated it is capable of receiving X bytes of data and subsequently receives Y bytes it is permitted to decrease its receive window to X-Y.","A PENDING TCP flow splice could also limit the amount of data it receives by withholding acknowledgments for data that it receives. The lack of acknowledgments will discourage the sender from sending additional data. Withholding acknowledgments may also cause the sender to retransmit data that has already been sent. For this reason it may be advantageous for a PENDING splice to limit the amount of data it receives by decreasing the send window rather than by withholding acknowledgments.","Regardless of the presence of buffered data, a splice is also prevented from proceeding beyond the PENDING  state if the receive window advertised to the splice source (by the splice) is greater than the receive window advertised by the splice destination (to the splice). If this situation arises, the splice remains PENDING  until it has received enough data to allow it to eliminate the gap between the receive window sizes.","Once the last byte of buffered data if any has been sent and the receive window has been decreased to the value advertised by the receiver if need be, the splice enters the FORWARDING  state. In this state packets arriving at the splice are modified and forwarded. However, reverse inbound information associated with buffered data, as opposed to data simply forwarded through the splice, is handled in the same way as for an unspliced flow, rather than being forwarded to the sender. Once the splice is in the FORWARDING  state, full protocol processing need not be performed for the inbound flow. Processing of reverse inbound information, including performing retransmission still occurs, however, for the outbound flow.","Eventually the last reverse inbound information that refers to buffered data should be received at which point the splice enters the ESTABLISHED  state. In this state both forward and reverse inbound information is processed (modified) and forwarded.","We now consider flow termination. When a node communicating via a splice terminates its flow, the termination can be handled by the splice in either of two ways. In one embodiment the splice propagates the termination, or FIN in TCP parlance just as it propagates ordinary data. This causes both flows joined by the splice to be shut down. In another embodiment the splice itself processes the FIN. This results in only the inbound flow at the splice being shut down and causes the outbound flow to revert to the UNSPLICED  state. Having the splice propagate the FIN is desirable in situations where an intermediate node does not need to send any more data on the outbound flow after creating a splice. Having the splice process the FIN allows an intermediate node to either send additional data on the outbound flow, or resplice the flow.","Once a splice has processed a FIN and a corresponding ACK, it enters the WAITING  state. This state is identical to the ESTABLISHED  state except for the presence of a timer that causes the splice to cease to exist when it expires. The timer is set to 2*MSL, twice the maximum segment lifetime, when the splice enters the WAITING  state and reset to 2*MSL whenever a packet is forwarded through the splice. Usually no packets are forwarded through the splice once it enters the WAITING  state and the splice is eliminated 2*MSL after the FIN and corresponding ACK are processed. The purpose of the WAITING state is to account for any retransmitted packets.","The 2*MSL time-out is conservative in that the splice persists only until it can be determined that any retransmissions that might occur would have been seen at the splice. However, the retransmission time-out value used by a TCP sender is a function of both the estimated round trip time and its variance and it is difficult for the splice to accurately estimate these values as viewed by the sender.","Now consideration is given to sequence and acknowledgment number mapping. TCP is a stream oriented protocol. Although a sending client presents data to the protocol in discrete buffers and the protocol partitions transmitted data into packets, neither buffer nor packet boundaries are visible to the receiver. TCP presents data to a receiver as a continuous stream bounded only by a single pair of beginning and end points. To ensure data is presented to the receiver in exactly the same order in which it was sent, TCP assigns a 32-bit sequence number to each byte in the stream. The initial sequence number, that is the sequence number for the first byte to traverse a flow, is generally selected in a way that makes it difficult to predict and the sequence number is incremented by one for each successive byte.","Because different flows generally have different initial sequence numbers and because any amount of data can be sent on a flow before it is spliced, the sequence numbers for data flowing through a splice are mapped from the inbound to the outbound flow. For example, consider two flows shown in , F which extends from node A  to node I , and F that extend from the node I  to node B . Assume the initial sequence number for F (chosen by node A ) is 1,000, and the initial sequence number for F (chosen by the node I ) is 10,000. Further assume 200 bytes has arrived at I  on F and 300 bytes have been sent from I  on F before F is spliced to F. When the splice is created, the sequence number of the next byte to be received on F is 1,200 and the sequence number of the next byte to be sent on F is 10,300. Thus as data flows through the established splice the sequence number in each TCP packet is mapped from the inbound flow, F, to the outbound flow F by adding 9,100 (10,300\u22121,200). Acknowledgment numbers flowing in the opposite direction are mapped by subtracting 9,100.","Creating a splice between two sequence-oriented flows establishes a correspondence between the sequence space of the first flow and the sequence space of the second flow. In the case of a splice between two TCP flows, the correspondence amounts to a fixed offset between the sequence number of a byte arriving at the intermediate node on the inbound flow and the sequence number of the corresponding byte sent by the intermediate node on the outbound flow.","The correspondence established when a splice is created can be calculated in a number of ways. For example, if when a splice is created, no data resides in either send or receive buffers associated with the flows to be spliced at the intermediate node, the offset can be calculated by subtracting the sequence number of the next byte expected from the source (rcv_nxt) from the sequence number of the next byte to be sent to the destination (snd_nxt). If either the receive buffer associated with the inbound flow or the send buffer associated with the outbound flow contains data, the sequence number of the next byte to be sent on the outbound flow is adjusted to account for the buffered data that will be sent before any data is forwarded through the splice. Alternately, the calculation of the offset can be delayed until both the send and receive buffer are empty.","We refer to the inbound and outbound flows at the splice even though the splice transforms the two flows into one. Strictly speaking, we are referring to the sequence number space associated with the former flow from the splice source to the intermediate node and the sequence number space associated with the former flow from the intermediate node to the splice destination. For brevity we simply refer to the inbound and outbound flows.","Processing for a TCP to TCP Splice in the established state is now considered.  is a flow diagram that gives an overview of the logic for processing TCP segments associated with a flow splice in the ESTABLISHED  state. The initial processing is the same regardless of whether or not the segment is associated with a splice. First, in block , several preliminary checks are performed to make certain the packet contains a valid TCP segment. The state information for the end point pair with which the segment is associated is then located. If no such state information is found, the segment is discarded and processing for the segment is complete. If the outbound flow of the end point pair on which the segment arrived is the destination of a splice the reverse inbound information contained in the segment is subjected to splice destination processing. This processing is described in further detail below and is depicted in .","If a segment is subject to splice destination processing and contains neither data nor a FIN, then processing for the segment is complete. If a segment does contain either data or a FIN or the segment was not subject to splice destination processing the inbound flow of the end point pair on which the segment arrived is checked in decision block  to see if it is a splice source. If the flow is not a splice source, the segment is subjected to the remainder of ordinary TCP input processing. If the inbound flow is a splice source, the corresponding outbound flow is checked in decision block  to determine if it is not the destination of a splice and the segment is checked to see if it contains new reverse inbound information. If these two conditions are true, a copy of the reverse inbound information in the segment is made in block  so it can be subjected to the remainder of the ordinary TCP input processing. A segment is considered to contain new reverse inbound information if it contains an acknowledgment number greater than the largest acknowledgment number previously seen on this flow, or if it contains a window update. The segment is next subjected to splice source processing which is described in further detail below and depicted in . If a copy of the segment's reverse inbound information was made, that information is subjected to the remainder of ordinary TCP input processing in block . This  completes processing for a TCP segment associated with a splice.",{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 16","b":["1601","1602","1603","1604","1606","1606"],"ul":{"@attributes":{"id":"ul0001","list-style":"none"},"li":{"@attributes":{"id":"ul0001-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0002","list-style":"none"},"li":["1. Allocate packet for TCP segment,","2. Fill in fields of IP header needed for TCP checksum (packet length, protocol, source, destination IP address),","3. Fill in fields of TCP header (source, destination port, TCP header length, sequence and acknowledgment numbers, flags)."]}}}},"If the mapped acknowledgment value is not greater than the rcv_nxt field of the source TCB, the segment is checked to determine if it contains any data or a FIN . If the segment contains either data or a FIN processing for the segment is complete. If not, processing continues with formulating a TCP segment containing reverse inbound information in block .","Formulating the TCP segment begins with allocating a new packet and filling in the fields of the IP pseudo header needed for the IP checksum, specifically the packet length, protocol, and source and destination IP address. The IP addresses are copied from the source TCB. Next the fields of the TCP header are filled in. These are the source and destination port numbers, sequence and acknowledgment numbers, TCP header length and flags. The port numbers are copied from the source TCB. The only flag set is ACK. The sequence number is copied from the snd_nxt field of the source TCB. The acknowledgment field is set to the mapped acknowledgment value.","A determination is made to see if the segment contains a window update . If it does, the value for the receive window, and sequence and acknowledgment numbers are recorded in the destination TCB . Then block  is performed and the receive window field of the TCP header is copied from the destination TCB. The TCP checksum is calculated and filled in. The total length, type of service and time to live fields of the IP header are filled in. Finally the packet is passed to the IP output routine and the process ends .","In the embodiment described new reverse inbound information is propagated to the splice source immediately. The sending of reverse inbound information could also be delayed for a short period of time in the hope that it could be sent in segments containing forward data for the source instead of sending a packet containing only reverse inbound information.",{"@attributes":{"id":"p-0093","num":"0095"},"figref":"FIG. 17","b":["1702","1702"],"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":{"@attributes":{"id":"ul0003-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0004","list-style":"none"},"li":["1. Modify source and destination address in IP header","2. Modify source and destination port in TCP header","3. Map sequence number from source to destination flow","4. Set acknowledgment field from rcv_nxt field of destination TCB","5. Set window field from rcv_wnd field of destination TCB","6. Set length field in IP pseudo header","7. Calculate and fill in TCP checksum","8. Fill in IP total length, type of service and time to live fields"]}}}},"The source and destination IP addresses and port numbers are modified by copying the appropriate values from the destination TCB. The sequence number is mapped from the source flow to the destination flow. The acknowledgment number and receive window fields are set by copying the values from the rcv_nxt and rcv_wnd fields of the destination TCB respectively. The length field in the IP pseudo header is set. The TCP checksum is calculated and filled in. The total length, type of service, and time to live fields of the IP header are filled in.","If the segment's FIN flag is set TCP state processing is performed for both the source and destination end point pairs. The processing for the source pair is the same as that performed when a FIN is received on an unspliced flow. The processing for the destination pair is the same as what takes place when a FIN is sent on an unspliced flow. Finally, the segment is passed to the IP output routine.","As described above, the preferred embodiment of TCP flow splicing recomputes the TCP checksum for each packet forwarded through a splice after the packet header as been modified. Techniques in common practice allow the new TCP checksum to be calculated by referring to only the original TCP checksum value and the changes made to the packet. This can improve performance compared to computing the checksum from scratch because it eliminates the need to reference all the data in the packet.","Preliminary checks are performed on the TCP segment in block  of . These checks may or may not include TCP checksum calculation. Performing the checksum allows corrupt packets to be detected and eliminated as soon as possible which may save network bandwidth. Processing requirements are reduced, however, if the checksum calculation is eliminated from the splice. Elimination of the checksum is feasible as corrupt packets will still be detected by normal TCP processing at the destination node.","The flow splice may be defined in terms of packet sequences.  depicts an example of a sequence of packets associated with the scenario depicted in . In this scenario, each of two nodes A  and B  has established a connection with an intermediate node I . In addition to the elements explicitly depicted in , the scenario associated with  includes a program on node I  that continuously reads data from end point pair EP and immediately writes any such data on end point pair EP. This corresponds to reading data from flow F and writing it to flow F.","The packet flow depicted in  results from node A  sending 100 bytes of data on end point pair EP. These 100 bytes are contained in a single packet . Subsequent to receiving this packet , node I  sends an acknowledgment packet  to node A . The acknowledgment packet  indicates to node A  that the 100 bytes contained in the first packet  have successfully arrived at the destination of the flow on which they were sent, that is the destination of flow F which is node I .","Also subsequent to the arrival at node I  of packet , node I  sends the 100 bytes of data received from node A  on end point pair EP. Again the data happens to be conveyed in a single packet . Subsequent to the arrival at node B  of this packet , node B  sends an acknowledgment packet  to node I . This acknowledgment packet  indicates to node I  that the 100 bytes contained in packet  have successfully arrived at the destination of the flow on which they were sent, that is the destination of flow F which is node B .","Although  depicts a specific strict temporal ordering of the transmission and reception of the four packets , ,  and , certain other orderings are consistent with the depicted scenario. The only requirements on the temporal ordering are that each of packets  and  is sent from node  after packet  arrives at node I . Furthermore packet  is sent from node B  after packet  arrives at node B . Of course a packet can not arrive at its destination prior to being sent from its source.","The conclusive indication that the packet flow in  is associated with two flows that are not joined in a splice is that node  sends to node A  an acknowledgment  for the 100 bytes it received from node A  in packet  before node I  receives from node B  an acknowledgment for the corresponding 100 bytes sent to node B  in packet . This order indicates that the acknowledgment  sent by node I  is generated by normal TCP processing and not a flow splice at node I .",{"@attributes":{"id":"p-0103","num":"0113"},"figref":["FIG. 19","FIG. 9","FIG. 8","FIG. 9"],"sub":["AI ","IB ","AB "],"b":["804","802","806","802","904"]},"Like the packet sequence depicted in  the flow shown in 19 results from node A  sending 100 bytes of data on end point pair EP. Again, these 100 bytes are contained in a single packet . Subsequent to receiving this packet , node I  forwards the packet to node B  after modifying the packet headers to make it appear to node B  as if the packet had been sent from node I  on flow F. Unlike the packet exchange shown in  the exchange in  does not include an acknowledgment from node I  to node A  in response to data packet  from node A  arriving at node I .","Like ,  shows node B  generating an acknowledgment packet  in response to the arrival of a packet  from node I . As described earlier the splice mechanism creates packets containing data forwarded from node A  through node I  to node B  on flow F that are acceptable to node B  as packets that originated at node I  and were sent to node B  via flow F. When the acknowledgment packet  arrives at node I , node I  modifies the packet to make it appear to node A  that the packet originated at node I  and is associated with flow F. Node I  then forwards the modified packet  to node A .","The temporal order of the packets in  is the only one consistent with a spliced flow. That is, for a spliced flow packet  is not sent from node I  before packet  arrives at node I , and packet  is not sent from node I  before packet  arrives at node I . Packet  is not sent from node B  before packet  arrives at node B  simply to conform with the TCP protocol.","By itself this temporal ordering is not sufficient proof of a flow splice as it is also possible for this order to result without a splice. The presence of a flow splice is conclusively indicated by causality between packets received by and sent by the intermediate node I  on which the splice is performed. Specifically, in the scenario with a flow splice depicted in , the sending of acknowledgment packet  by node I  is caused by the arrival of acknowledgment packet  from node B  and not by the arrival of data packet  from node A .","This causality is refuted if node I  sends an acknowledgment to node A  for data packet  before an acknowledgment is received at node I  for the corresponding data packet  sent from node I  to node B . The causality indicative of a flow splice is confirmed if node I  fails to send an acknowledgment to node A  for packet  if it does not receive the acknowledgment packet  from node B  for the corresponding packet .","The causality indicative of a flow splice can also be confirmed a different way. In the scenario without a flow splice depicted in  the ACK number in packet  is set by node I  to one more than the greatest sequence number I  has received from A  on flow F as mandated by the TCP protocol. In the case depicted in , node I  received from A  100 bytes starting at sequence number  in packet . Packet  contains sequence numbers  through . Node I  therefore sets the ACK number in packet  to .","In the scenario with a splice depicted in  the ACK number in packet  is set by node I  to the ACK number in the corresponding packet  minus the sequence number delta value for the splice following the algorithm for splice processing. The sequence number delta value for a splice is defined as the sequence number of a byte sent by the intermediate node to the splice destination minus the sequence number of the corresponding byte when received from the splice source. For example the first of the 100 bytes in packet , sent from node I  to node B , has sequence number . The corresponding byte was sent from node A  to node I  in packet  with sequence number . This the sequence number delta for this splice is therefore  minus  or . Thus when node I  receives acknowledgment packet  from node B  it subtracts  from the ACK number  and sets the ACK number in the forwarded packet  to .","Although the ACK number in each of packets  and  are set according to distinct algorithms, both algorithms produced the same value . The flow splice processing is, in fact, required to produce the same ACK numbers as produced by normal TCP processing if it is to remain transparent to the splice source and destination. Although under normal operation the two algorithms produce the same ACK number, the specific algorithm in use at a particular intermediate node can be determined by modifying the acknowledgment packets sent to the intermediate node.","For example to determine if a flow splice has been created at node I , we simply add some amount to the ACK number in the acknowledgment packet  sent by node B . If a flow splice is not present this modification will have no effect on the ACK number in the acknowledgment packet  sent by the intermediate node I . If a flow splice is present, however, the ACK number in the acknowledgment packet  sent by the intermediate node I  will reflect the modification to the ACK number in the acknowledgment packet sent by the destination node B .","If  is added to the ACK number in the acknowledgment packet  sent by the destination node B , the presence of a flow splice is indicated if the ACK number in the corresponding acknowledgment packet  sent by the intermediate node I  is also  more than would be expected according to the TCP algorithm. It is certain the TCP algorithm did not generate the acknowledgment packet sent by the intermediate node I  if the ACK number in the packet corresponds to data not yet received by the intermediate node I .","It is noted that this invention may be used for many applications. Although the description is made for particular arrangements and applications, the intent and concept of the invention is suitable and applicable to other arrangements and applications. It will be clear to those skilled in the art that other modifications to the disclosed embodiments can be effected without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["The foregoing and other objects, aspects and advantages of the invention may be better understood by referring to the following detailed description of a preferred embodiment with reference to the accompanying drawings, in which:",{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 19"}]},"DETDESC":[{},{}]}
