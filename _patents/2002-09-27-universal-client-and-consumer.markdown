---
title: Universal client and consumer
abstract: In a network computing environment with a distributed software system utilizing Common Object Request Broker Architecture (CORBA), a Universal Client and Consumer tool that creates Client and Consumer implementations for use in interacting with any existing Servers and/or Suppliers in the system, and displaying the data resulting from the interactions for the purpose of validating the operation, functionality and performance of the Servers and Suppliers. The tool creates a graphical user interface for the user to select Servers or Suppliers to evaluate. The tool identifies the Server or Supplier IDL interface, and then creates either a Client or Consumer Implementation that uses the same corresponding IDL interface. The tool then attempts to connect to the Server or Supplier and where appropriate allow the user to invoke methods. Data received from the Servers and/or Suppliers is displayed on a video device and logged for later analysis.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07287252&OS=07287252&RS=07287252
owner: The United States of America represented by the Secretary of the Navy
number: 07287252
owner_city: Washington
owner_country: US
publication_date: 20020927
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"heading":["STATEMENT OF GOVERNMENT INTEREST","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE PREFERRED EMBODIMENT"],"p":["The invention described herein may be manufactured and used by or for the Government of the United States of America for governmental purposes without the payment of any royalties thereon or therefor.","(1) Field of the Invention","The present invention relates in general to distributed software systems, and more specifically to a method and apparatus for creating Client and Consumer Implementations in a Common Object Request Broker Architecture (CORBA) based distributed software system where the Client and Consumer Implementations interact with any existing Servers and\/or Suppliers\/event channels (Suppliers) in the system, and display the data resulting from the interactions for the purpose of validating the operation, functionality and performance of the Servers and Suppliers.","(2) Description of the Prior Art","A common data processing system design utilizes a distributed computing environment where data is managed and disseminated over two or more interconnected computers. Such an interconnection of computers with the ability to communicate information between the computers is known as a computer network, or simply a network. Such networks may include a large number of components, including various types of computers and peripheral devices, which may be configured in a variety of ways and may be characterized as \u201cLocal Area Networks\u201d (LANs) or \u201cWide Area Networks\u201d (WANs) based on the geographic area over which the components are distributed. LANs and WANs often employ standard common configurations or architectures. For example, in a standard Client\/Server configuration a certain number of the interconnected computers may function as Clients while others may function as Servers that provide services to the Clients. Such a Client\/Server configuration is a common example of one of the several available configurations of distributed computing environments (LANs and WANs) and is well known by those skilled in the art.","One manner of implementing software applications to run on a LAN or WAN is to use a vendor-independent network software architecture and infrastructure that various heterogeneous software applications can use to work together over the network. Such an implementation can be achieved using the \u201cCommon Object Request Broker Architecture\u201d (CORBA) Specification. CORBA is a vendor independent specification for an architecture and infrastructure that promotes interoperability within a distributed software system. It integrates computers from different vendors ranging in size from mainframes to desktops. CORBA provides a software bus that enables system applications to exchange and communicate information where such applications typically are distributed across a LAN or WAN. A CORBA based system relies on data abstraction to permit software applications running on the system to function unconstrained by the underlying network details, such as the types of workstations, the types of operating systems, and\/or the languages of other application implementations. One of CORBA's most important, as well as most frequent uses is in Servers that must handle a large number of Clients, at high hit rates with high reliability. Applications utilizing the CORBA infrastructure are typically implemented and configured as either providers of data (Servers and Suppliers) or users of data (Clients and Consumers). Reference to either Client or Consumer hereinafter will be understood to also include the other term unless specified otherwise.","A large-scale distributed software system utilizing CORBA based architecture may have hundreds or even thousands of Servers and\/or Suppliers. Development of such a large-scale distributed software system would ideally involve incremental integration of the system on a network. During this sort of integration the operations of the Servers and Suppliers need to be validated before the Clients and Consumers are installed on to the system. If the operations of the Servers and Suppliers are determined to be in error, the system will require debugging before integration can continue. During incremental integration, developers need to verify the initialization of Servers and Suppliers as well as connectivity and data interactions between the Servers\/Suppliers and Clients\/Consumers. They need to take relevant performance measurements such as the time to initialize, the time required for Servers to respond to Client invocations and the frequency rate of Suppliers providing data. They also need to verify that data obtained from the Servers and Suppliers is within specified ranges.","Although software tools presently exist for gathering a variety of data from Servers and\/or Suppliers in a distributed software system, they do not employ existing CORBA resources to achieve their results in real time, rather they often require additional performance monitoring code to be incorporated into each Server\/Supplier application.","There currently does not exist a method and apparatus that can non-intrusively assist a software developer in validating the operations of and debugging any of the Servers and Suppliers in a CORBA based system during incremental integration of the system that avoids incorporating performance-monitoring code into each Server\/Supplier application.","What is needed is a Universal Client and Consumer software tool that rather than incorporating additional code exploits existing CORBA resources for the purpose of validating the operation, functionality and performance of any of the Servers and Suppliers in a CORBA based distributed software system.","It is a general purpose and object of the present invention to provide a method and apparatus that allows a network user to examine any single Server, any single Supplier, or any logical combination of Servers and\/or Suppliers in a CORBA based software system for the purpose of validating the operation, functionality and performance of the chosen Servers and\/or Suppliers.","It is a further object that the user be able to choose which particular Servers and\/or Suppliers to examine by means of a graphical user interface (GUI) that displays a list of all of the Servers and Suppliers in the CORBA based system on a network video terminal connection.","It is still a further object that the GUI allows the user to issue commands to perform functions such as connect or disconnect to a specific Server or Supplier, display data, and record data.","It is yet a further object that the GUI includes a display of the actual raw data obtained from a particular Server or Supplier.","Another object is that the user be able to take measurements of timing details, data range and similar performance metrics pertaining to the Servers and Suppliers in the system.","Still another object is to provide storage of connection status information, operational status information, and raw data obtained from a particular Server or Supplier periodically in a data store for long-term statistical analysis.","These objects are accomplished with the present invention through a method and apparatus that evaluates and assimilates all of the CORBA Interface Definition Language (IDL) interfaces for Servers and Suppliers in a distributed software system and then creates corresponding Client or Consumer Implementations to interact with them. The method and apparatus creates and controls one or more Client or Consumer Implementations specific to a corresponding Server or Supplier that the user is seeking to validate. Each Client or Consumer Implementation attempts to connect to the appropriate Server or Supplier across the CORBA software bus. The success or failure of the connection is made available to the user, as is the time required to establish a connection when one is made. The Client or Consumer Implementation interacts with the corresponding Server or Supplier, invoking methods or receiving data. The Client or Consumer Implementation can then verify and measure the received data and pass the data to the GUI for the user to observe, or to a data store to be recorded. For the purposes of this invention, Suppliers are considered to include the implementation of the standard Object Management Group (OMG) CORBA Object Services (COS) Event Service. The term Supplier includes the terms producer\/event channel.","In all figures, identical components within the system carry identical numerals and letters. However, if a component in one figure is represented in other figures by various components, then different marking are used to denote each component not shown in the one figure.","The present invention is designed for use in a Client-Server Consumer-Supplier network such as the one depicted in . Referring now to  there is shown one or more Client\/Consumer computers , one or more Server\/Supplier computers , each connected to a network hub . One or more network hubs  are in turn connected to the rest of the network . Note that at times a Server\/Supplier computer  may also function as a Client\/Consumer computer , or that more than one Server\/Supplier application may be running on a Server\/Supplier computer . The Clients\/Consumers  request services or data from the Servers\/Suppliers . The requests and responses to the requests are implemented using resources found in an object oriented software architecture that implements an object request broker and an interface definition language under certain defined protocols such as CORBA resources.","The Universal Client and Consumer (UCC) as illustrated in the block diagram in  includes two main components; the UCC CORBA Control , and the UCC Display . The UCC CORBA Control  establishes the actual connections to the CORBA Server processes (Servers)  and Supplier processes (Suppliers)  in the CORBA distributed software system . In addition, it manages those connections and stores statistics and information on the connections. The statistics and information are displayed by the UCC Display  in a graphical format on video terminal . The UCC Display  includes a GUI Client  that creates and maintains a control and status display  and data displays . The UCC CORBA Control  further comprises the Control Logic\/Data Distribution module (CLDD) , the GUI Server , the Data Store , and the Specific IDL Client and Consumer Implementations , .","The Data Store , depicted in , is a permanent magnetic or optical storage medium in which to store and retrieve data files  generated by Servers and Suppliers, and the connection and status log files  which represent the status of connections between the Implementations and data sources. In a preferred embodiment of the invention, Data Store  is a series of files or a database stored on a hard disk. The contents of the Data Store can be stored over extended periods of time and used for long-term statistical analysis.","The CLDD  controls the creation and deletion of specific Client and Consumer Implementations , , and provides status from the Data Store  as necessary to respond to user control requests. The GUI Server Interface , which contains a CORBA IDL interface implemented by the UCC CORBA Control , passes control data (i.e., commands entered by the user) and status data between UCC Display  and UCC CORBA Control . The CLDD  receives commands and parameters entered by the user through the GUI Server  and performs functions associated with these commands.","The Specific IDL Client and Consumer Implementations ,  portion of the UCC CORBA Control consists of one or more implementations of classes employing the same specific IDL interfaces of the system . The UCC is configured to operate with the same specific IDL interfaces employed by the system  it is interacting with. Therefore, in order to configure the UCC to work with a particular system , the UCC is designed with a class for each one of the IDL interfaces in that system . The implementation of these classes is specific to the system . The UCC dynamically creates specific instantiations of the Implementations when it seeks to interact with a particular data source in the system . An Implementation is referred to as a Client Implementation  if the specific IDL interface it employs allows it to connect to a Server . Similarly, an Implementation is referred to as a Consumer Implementation  if the specific IDL interface it employs allows it to connect to a Supplier . The Client or Consumer Implementations correspond to any desired set of IDL interfaces as defined by the IDL of the particular system  that the UCC is configured to work with.",{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 4","b":["140","145","160","140","145","70","80","70","80","70","80","140","145","140","145","140","70","160","140","145","145","80"],"i":["a ","a","a ","a ","a ","a"]},"As stated above, the CLDD  performs functions associated with user commands. Referring to the block diagrams of  and , User commands and parameters are directed to one of two manager components of the CLDD . The Client Manager  handles any interactions with the Servers  in the system  and the Consumer Manager  handles the interactions with the Suppliers  in the system . The Client Manager  creates, controls, and deletes the Client Implementations  as requested by the user. The Consumer Manager  creates, connects, controls, and deletes the Consumer Implementations  as requested by the user.","The CLDD handles the following user requests through the appropriate Managers: requests to connect to a Server or Supplier, requests to disconnect from a Server or Supplier, requests for specific Implementations to display their data, requests for timing details (this is latency data for events), requests to see connection status logs (i.e, logs of which Servers or Suppliers are connected and which attempted connections were successful), requests to reset statistics (i.e., clear statistics on a particular Interface), and request data statistics from a particular Implementation.","The Client Manager flow diagram is shown in . The Client Manager is in charge of dynamically creating, controlling and deleting Client Implementations  as requested by the user. The Client Manager keeps track of all of the Implementations  it dynamically creates in a List of Clients  that it maintains in random access memory. The Client Manager can receive a CONNECT, DISPLAY DATA, CONNECTION LOG or a RECORD DATA command from the user.","Referring to the first step, as shown in , the Client Manager  waits to receive a user command  from the GUI Server . Receipt of the CONNECT command , from the user by the Client Manager  indicates that the user wishes to connect to a particular Server  in the system. The Client Manager  is provided with the CORBA Name Server (CNS) name of the particular Server . In the next step, the Client Manager  performs a CORBA resolve  on the CNS name. If the resolve is not successful , the Client Connection and Status Log  is updated on the Data Store  to note the resolve failure . The Manager  generates an exception to notify the user of the failure  and the Manager  awaits another user command . If the resolve is successful , then in the next step, the Client Manager  attempts a CORBA narrow  to all of the IDL interfaces in the system . If the narrow is not successful , the Client Connection and Status Log  is updated on the Data Store  to note the narrow failure . The manager  then generates an exception to notify the user of the failure  and the Manager  awaits another user command . If the narrow succeeds , then the Client Manager  creates  a new Client Implementation  that employs the specific IDL Interface needed to connect with the Server  of interest to the user. The Client Implementation  is then passed the Server Object obtained from the CORBA Name Service (not shown). The Client Manager  updates its List of Clients , and then notes the successful connection in the Client Connection and Status Log file  in the Data Store . The Manager  then waits for another user command .","When the Client Manager  receives a DISPLAY DATA command from the user , it searches for the requested Client Implementation  in the List of Clients . If the Manager  finds the Client Implementation  in the list , then it instructs the Client Implementation  to display the data it is receiving from the Server  it is connected to . If the Manager  fails  to find the Client Implementation , then it notifies the user of the error  and waits for another command .","When the Client Manager  receives a CONNECTION LOG command from the user , it obtains the Client Connection and Status Logs  of all of the Client Implementations  from the Data Store  and returns that information back to the user through the GUI . The Manager then waits for another command .","When the Client Manager  receives a RECORD DATA command from the user , it searches for the requested Client Implementation  in its List of Clients . If the Manager  finds the Client Implementation  in the list , then it instructs that Client Implementation  to record the data  it is receiving from the Server  it is connected to. If the Manager  fails  to find the Client Implementation , then it notifies the user of the error  and waits for another command .","In accordance with standard CORBA requirements in order for each specific Client Implementation  created by the Client Manager to connect with a specific Server  of interest to the user both the Client Implementation  and the Server  must employ the same specific IDL interface. Each Client Implementation  created by the Client Manager  performs the same standard functions plus specific functions as defined by that IDL interface necessary to interact with the Server  of interest to the User. There can be as many different Client Implementations  as there are IDL interfaces in the system . The Client Manager  creates the Client Implementations  dynamically whenever the user chooses to connect to a Server .","Each Client Implementation  has the same flow diagram as shown in . In the first step , the Client Implementation  initializes local data and state essentially clearing its local data store (not shown). Each Client Implementation maintains its own local data store in random access memory that keeps track of the Client's connection status and contains the data received by the Client from the Server it is interacting with.","The Client Implementation  then waits to perform a task . Upon receiving instructions from the Client Manager  to DISPLAY DATA , the Client Implementation  creates  a data display  on the UCC Display . In a preferred embodiment of the invention, when the user enters a DISPLAY DATA command, the Client Implementation  provides a MOTIF\u2122 window on the GUI Display for the user. From this window, the user can interact with the Server  and invoke any of the available methods specific to the particular Server's IDL interface that the Client Implementation  is interacting with. Once the display  is created, the Client Implementation  waits to receive instructions for its next task .","Upon receiving a USER-INVOKED METHOD , the Client Implementation  performs the method on the Server  it is interacting with . If the Client Implementation  is unable to successfully perform the method, then an exception is generated . The Client Implementation  updates its connection status , and if the display is still active updates the connection status  on the UCC Display . In a preferred embodiment, if the Client Implementation  is not able to perform a successful invocation, then the connection status is updated in the Client's local data store and if the MOTIF\u2122 window is active the error is indicated at the bottom of the window so that the user is informed of the exception or error condition.","If the Client Implementation  is able to successfully perform the method as invoked by the user, then its next step is to update its local data store with the method data it receives  from the Server . In one embodiment, the Client Implementation  could then accesses a System Configuration files (not shown) and compares the method data with the standard range for that particular data. If the Client Implementation  determines that the data is out of range  then the determination is noted in the local data store as data status . If the display is active , the new data is displayed  in the UCC Display .","The user has the option of instructing the Client Implementation  to record all of the data in its local data store in random access memory to a file in the Data Store . Where this option is active , the data is formatted and saved to the Data Store  in step .","When the user enters a DISPLAY CLOSED command  the Client Implementation  destroys the MOTIF\u2122 window that contains data display  window and recovers all resources used to create it .","When the user enters a DELETE command  the Client Implementation  deletes or closes all resources and terminates .","The Consumer Manager  is in charge of dynamically creating, controlling and deleting Consumer Implementations  as requested by the user. The Consumer Manager  keeps track of all of the Implementations  that it dynamically creates in a List of Consumers  that it maintains in random access memory. The Consumer Manager  also maintains a Table of Name Server Names and IDL Interface Names  in the form of a text file. The Names are specific to the system  that the UCC is configured to interact with. The Consumer Manager  responds to the following user commands: CONNECT, DISCONNECT, DISPLAY DATA, RESET STATISTICS, TIMING DETAILS, CONNECTION LOG or RECORD DATA.","The Consumer Manager  flow diagram is shown in . In the first step, the Consumer Manager  waits to receive a user command  from the GUI Server . If the Consumer Manager receives a CONNECT command  from the user it attempts to connect to a Supplier  in the system designated by the user. The CNS name of the Supplier  is provided to the Consumer Manager  as part of the connect command. In the next step , the Consumer Manager  cross-references the CNS name with an interface name in the Table of Name Server Names and IDL Interface Names . Cross-referencing is needed to identify the specific Supplier  that the User wishes to connect to. If the Consumer Manager  cannot find the desired Supplier  interface name  it generates an exception and passes it to the GUI Server  to display the error to the user  and waits for another command . If it finds the desired Supplier  interface name , then it creates  a Consumer Implementation  that employs the appropriate IDL Interface to connect to the Supplier . The Consumer Manager  then updates  its List of Consumers  to include this new Consumer Implementation and the Consumer Connection and Status Log  is set to \u201cCONNECTING\u201d . The Consumer Manager  then performs a CORBA resolve on the CNS Name . If the resolve is successful , then the Consumer Manager  attempts to connect  the Consumer Interface  to the user designated Supplier . If the resolve is not successful , the Consumer Manager  updates the Consumer Connection and Status Log  to \u201cNAME NOT FOUND\u201d  and attempts a resolve again . If the Consumer Manager  is successful in connecting  the Consumer Implementation  and the Supplier , it updates  the Consumer Connection and Status Log  status to \u201cCONNECTED\u201d and then waits for the next user command . If the Consumer Manager  is not successful in connecting  the Consumer Implementation  and the Supplier , it updates the Consumer Connection and Status Log  at step  and repeats steps  to  until a successful connection is made. In order to provide continuous service in the event of an unsuccessful resolve or connection, the Consumer Manager  attempts to connect all of the Consumer Implementations  in parallel. All of the steps in  that are done in parallel are shaded.","If the Consumer Manager  receives a DISCONNECT command from the user , the Consumer Manager  searches  its List of Consumers  to see if the user designated Consumer Implementation  is active. If it is not  the Consumer Manager  generates an exception and passes it to the GUI Server  to display the error to the user . The Manager  then waits for another command . If the Manager  finds the Consumer Implementation  on the list , it disconnects  the Consumer Implementation  from the Supplier , and updates  the Consumer Connection and Status Log . The Manager  then waits for another command .","If the Consumer Manager  receives a DISPLAY DATA command from the user , the Consumer Manager  searches its List of Consumers  to see if the user designated Consumer Implementation  is active . If it is not  the Consumer Manager  generates an exception and passes it to the GUI Server  to display the error to the user . The Manager  then waits for another command . If the Manager  finds the Consumer Implementation  on the list , it instructs the Consumer Implementation  to display the data  it is receiving from the Supplier  on to the UCC Display . In a preferred embodiment of the invention, the Consumer Implementation  provides a MOTIF\u2122 window on the GUI Display to display data for the user. The Manager  then waits for another command .","If the Consumer Manager  receives a RESET STATISTICS command , from the user, the Consumer Manager  searches its List of Consumers  to see if the user designated Consumer Implementation  is active . If it is not  the Consumer Manager  generates an exception and passes it to the GUI Server  to display the error to the user . If the Manager  finds the Consumer Implementation  on the list , it instructs the Consumer Implementation  to clear its Local Data and Statistics in memory  and then waits for the next user command .","If the Consumer Manager  receives a TIMING DETAILS command , from the user, the Consumer Manager  searches its List of Consumers  to see if the user designated Consumer Implementation  is active . If it is not  the Consumer Manager  generates an exception and passes it to the GUI Server  to display the error to the user . If the Manager  finds the Consumer Implementation  on the list , it obtains the timing details (e.g. whether data is being received from the Supplier at the required periodicity) from that Consumer Implementation  and then waits for the next user command .","If the Consumer Manager  receives a CONNECTION LOG command , it obtains the Connection and Status Logs  of all the Consumer Implementations  it has created. The Connection and Status Logs  are maintained in the Data Store . The Consumer Manager  then displays  the connection log information to the user on the UCC Display  and then waits for the next user command .","If the Consumer Manager  receives a RECORD DATA command , from the user, the Consumer Manager  searches its List of Consumers  to see if the user designated Consumer Implementation  is active . If it is not  the Consumer Manager  generates an exception and passes it to the GUI Server  to display the error to the user . If the Manager  finds  the Consumer Implementation  on the list , it instructs that Consumer Implementation  to record the Local Data and Statistics information it is maintaining in its memory to the Data Store  and then waits for the next user command .","In accordance with standard CORBA requirements in order for each specific Consumer Implementation  created by the Consumer Manager  to connect with a specific Supplier  of interest to the User both the Consumer Implementation  and the Supplier  must employ the same specific IDL interface. Each Consumer Implementation  created by the Consumer Manager  performs the same standard functions plus specific functions as defined by that IDL interface necessary to interact with the Supplier  of interest to the User. There can be as many Consumer Implementations  as there are IDL interfaces in the system . The Consumer Manager  creates the Consumer Implementations  dynamically whenever the user chooses to connect to a Supplier .","Each Consumer Implementation  has the same flow diagram as shown in . In the first step, the Consumer Implementation  initializes local data and state  essentially clearing its local data store (not shown). Each Consumer Implementation  maintains its own local data store in random access memory that keeps track of the Consumer Implementation's  connection status and contains the data received by the Consumer Implementation  from the Supplier  it is interacting with.","The Consumer Implementation  then waits to perform a task . Upon receiving an EVENT  from the Supplier  it is connected to, the Consumer Implementation  updates its local data store with the data that it has received and updates the data latency statistics . It then resets its internal timer  and performs a range measurement on the data it received. If the data is out of range , the Consumer Implementation  notes the range error in its local data store . If the data is in range , then the Consumer Implementation  proceeds to the next step and check to determine if a data display window  is active. If the window  is active , then the Consumer Implementation  displays  the data it has received in the data display window  and proceeds to the next step. If the window  is not active , the Consumer Implementation  checks whether the record data option is active. The user has the option of instructing the Consumer Implementation  to record all of the data in its local data store in random access memory to a file in the Data Store . Where this option is active, the data is formatted and saved to the Data Store . If the record data option is active , the Consumer Implementation  records the data in its local data store to the Data Store  and proceeds to the next step. If the record option is not active , then the Consumer Implementation  proceeds to the next step, which is to wait for the next task .","When instructed by the Consumer Manager  to DISPLAY DATA , the Consumer Implementation  creates  a data display  on the UCC Display . In a preferred embodiment of the invention, when the user enters a Display Data command, the Consumer Implementation provides a MOTIF\u2122 window on the GUI Display for the user. Once the display  is created, the Consumer Implementation  waits to receive instructions for its next task .","When the user enters a CLOSE DISPLAY command  the Consumer Implementation  destroys its active data display  and recovers all resources used to create it .","When the user enters a DELETE command  the Consumer Implementation  deletes or closes all resources  and terminates .","The UCC Display  has two primary types of displays as shown in . The first is the Control and Status Display  or GUI that is generated by the GUI Client , designed specifically for the UCC. The second type of display is the Data Display , which is generated directly from Client, and Consumer Implementations ,  created by the Client Manager  and the Consumer Manager .","In a preferred embodiment of the invention, the Control and Status Display  is structured as a window or set of windows functioning with the MICROSOFT\u00ae WINDOWS\u00ae operating system. The GUI allows the user to select the Server  or Supplier  to be monitored by displaying all available Servers  and Suppliers  and displays connection status such as \u201cCONNECTING,\u201d \u201cNAME NOT FOUND,\u201d \u201cDISCONNECTED\u201d. In a preferred embodiment, the Control and Status Display , consists of menus and displays from which the user can issue commands to the UCC CORBA Control . Through these menus, any of the various data sources can be selected individually or as a group, by some user specified basis. In one embodiment, the display window is divided according to category, reserving the top portion of the window for Suppliers , and the bottom for Servers . When a user selects a particular Server  or Supplier , the connection status and statistics are also displayed in the window as are connection logs and timing details when appropriate.","Data Displays  display the actual data being received by the various Client and Consumer Implementations ,  from Servers  and Suppliers . In a preferred embodiment of the invention, the Data Display GUI is implemented using MOTIF\u2122 widgets, and can actually display not only the data being received by the Implementations ,  but also the IDL upon which the data is based on. When the Data Display  is activated, the display  initially consists of the various method signatures for the specific Server  or Supplier  IDL interface. In one embodiment of the display , the method signatures are color-coded and initially all of them are set to blue. The user, selects a method displayed in the Data Display  and invokes that method on a Server . If the invocation is successful, the method signature on the display  is turned Green to indicate success, whereas if the method invocation fails the method signature on the display  turns Red and an indication of the error is given in the status line at the bottom of the display . In another embodiment of the display , in the case of a method being invoked by the Supplier , a successful invocation is indicated on the screen by also setting the method signature color Green. The method signatures are reset to Blue by pressing Reset on the Menu bar.","The advantages of the present invention over the prior art are that: The Universal Client and Consumer provides a novel approach for assisting a software developer in validating the operations of and debugging any of the Servers and Suppliers in a CORBA based system during incremental integration of the system while avoiding the incorporation of additional performance-monitoring code into each Server\/Supplier application. The method and apparatus provides significant advantages over prior art, in that the desired validation and debugging is done unobtrusively without having the Servers or Suppliers know that the information is being obtained by making use of existing available CORBA resources making it simpler and more efficient than the prior art.","What has thus been described is a method and apparatus that exploits existing CORBA resources for the purpose of validating the operation, functionality and performance of any of the Servers and Suppliers in a CORBA based distributed software system and provides a display of the current operational status of all the data sources in a computer network to a network user. The display graphically depicts the Server\/Supplier availability for the entire system in real time through a graphical user interface viewable at any network video connection and allows the user to interact with Servers and Suppliers to verify the initialization of Servers and Suppliers as well as connectivity and data interactions between the Servers\/Suppliers and Clients\/Consumers, performance measurements such as the time to initialize, the time required for Servers to respond to Client invocation and the frequency rate of Suppliers providing data, and verification that data obtained from the Servers and Suppliers is within specified ranges.","Obviously many modifications and variations of the present invention may become apparent in light of the above teachings. For example, implementation and use of the invention could be tailored to a closed network as on a ship, or a widely disbursed network like the Internet. The colors on the GUI display may vary, as may the detailed status messages. The status data provided by the invention can then be provided to a system manager and integrated in with network status to provide a complete picture of both the system hardware and software.","In light of the above, it is therefore understood that within the scope of the appended claims, the invention may be practiced otherwise than as specifically described."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["A more complete understanding of the invention and many of the attendant advantages thereto will be readily appreciated as the same becomes better understood by reference to the following detailed description when considered in conjunction with the accompanying drawings wherein:",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
