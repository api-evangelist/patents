---
title: Virtual resource serving of consolidated server shares
abstract: A system includes a server registry having one or more registered server names of associated network servers, an alias registry having one or more alias server names associated with each of the one or more registered server names, and a name resolution module resolving a requested server and share name to a destination server. Resolving the requested server and share names involves determining whether a requested server is registered and if the requested server is not registered, determining an alias server name corresponding to the requested server name.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07418507&OS=07418507&RS=07418507
owner: Microsoft Corporation
number: 07418507
owner_city: Redmond
owner_country: US
publication_date: 20031218
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["The described subject matter relates to network servers and more particularly to virtual resource serving.","Server computers (or servers) provide data files, and other resources, to client computers (or clients) over a network. Servers present a set of resource or file names, called a namespace, in which all the names are unique, whereby the clients can access shared resources provided by the servers. Servers are accessed by clients using a server name or other server identifier. Over time, and as network configurations change, a server can become identifiable by more than one server name. As a result, server name resolution presents challenges for accessing resources on a network.","For example, old servers are often updated by replacing them with newer, faster servers. Unfortunately, when servers are consolidated, the namespaces can change such that namespaces provided by the old servers are no longer useable by clients of the new servers. Thus, server consolidation can render resources inaccessible to clients, unless the clients are updated to recognize the new namespaces. Updating the clients with new server names can be a time consuming, expensive task that can disrupt work flow at the clients. In addition, consolidation of servers can cause collisions among share names that are common among the consolidated servers.","When multiple servers are consolidated into fewer servers, a resource that was available on one of the old servers, but not available on the other old servers, may become available to clients of the other old servers through one of the new servers. Clients of the new servers may not know that new resources are available because of the consolidation. Even if the clients know of the new resources, it may not be apparent how to access the new resources. Thus, consolidating servers may have benefits, such as economies of scope, which are not fully realized by current systems.","In addition, a server can be identified by server names as well as an internet protocol (IP) address. In some configurations, a server name is mapped to an IP address by a Domain Name System (DNS) server. However, someone who knows the IP address of a server can access the server directly. Existing legacy software may include \u2018hard-coded\u2019 IP addresses to servers. In addition, some clients may use a Network Basic Input\/Output System (NetBIOS) server naming convention that differs from a DNS server name. When server configurations change, as, for example, when a DNS server is installed, it may no longer be desirable or possible to directly access a network server using a previous IP address or a NetBIOS name. Unfortunately, identifying and updating all the clients and software that use NetBIOS names and IP addresses can be impractical.","Implementations of systems and methods described herein solve the above, and other, problems and drawbacks by providing a virtual server scheme that provides for multiple server identifiers and redirects resource requests to an appropriate server. Share names are associated with server names, such that a unique combination exists in each pair of share names and server names. The virtual server scheme allows for a share name to be applied to multiple server names by use of a wildcard. Alias server names provide transparent redirection as server names change.","In some implementations, articles of manufacture are provided as computer program products. One implementation of a computer program product provides a computer program storage medium readable by a computer system and encoding a computer program. Another implementation of a computer program product may be provided in a computer data signal embodied in a carrier wave by a computing system and encoding the computer program.","A computer program product encodes a computer program for executing a computer process on a computer system. An exemplary computer program receives a request for a network resource, wherein the request includes a server name identifying a requested server and a share name identifying the network resource. The program determines whether the requested server is registered, and, if the requested server is not registered, the program may determine an alias server name corresponding to the requested server name.","An exemplary system includes a server registration module registering a server share using a server name and a share name. The server name may include a wildcard indicating that an associated share can be provided by multiple servers. The system may further include an alias registry that associates one or more alias server names with a target server name. The system may also include a default server name identifying a server to be used if a resource request includes a server name that is not found among registered server names.","A method includes receiving a request for a network resource, the request including a requested server name and a requested share name identifying the network resource, determining whether the requested server is registered, and determining an alias server name identifying an alias server corresponding to the requested server name, if the requested server name is not found in the server registry. The method may further include sending the request to the requested server, and searching a server registry having server entries, each entry comprising an available server name and an available share name to locate the requested server name and the requested server provided by one or more available servers.","This disclosure describes a virtual resource serving scheme. The virtual resource serving scheme is described in the context of providing access to network resources a network, such as the Internet or a wireless network. However, the virtual resource serving scheme has general applicability to a wide variety of environments. Namespace alteration and\/or collision can be a major problem encountered when servers are consolidated. Also, changes to server names over time can cause problems for clients and software that use previous server names. The virtual resource serving scheme described below provides for server resolution despite changes to server names and namespaces. Thus, changes to server names due to server consolidation, or otherwise, can be performed transparently to the clients.","Exemplary System Architecture",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1","b":["100","102","104","102","102","3","106","108","3","106","102"]},"Server-  and server- , shown with dotted lines and crossed out, have been consolidated (i.e., migrated) onto server- . Prior to consolidation, server-  included one or more share(s) . Similarly, server-  included one or more share(s) . Server-  and server-  might have been consolidated onto server-  because server-  is faster, smaller, cheaper, or some other reason. In accordance with a virtual resource serving scheme, the shares  from server-  and the shares  from server-  are made available on server-  such that no changes need to be made at the client  as a result of the consolidation.","More specifically, the one or more share(s)  have been moved from server-  to shares identified as \u2018server- share(s)\u2019  on server-. The one or more share(s)  have been moved from server-  to shares identified as \u2018server- share(s)\u2019  on server-. The respective share(s)  and  are identified at server-  using both a server name (e.g., Server-, Server-) and a share name, such that resource requests by the client  to share()  and\/or  are transparently handled by server- .","The process of identifying shares on a server using both a server name and share names is referred to herein as \u2018share scoping.\u2019 Share scoping is discussed in further detail below by use of a specific example.","Turning to server-n , the name \u2018server-n\u2019 is used herein to indicate that any number of servers may actually be in communication with the client  over the network. Server-n  may be a Domain Name System (DNS) server that facilitates server name resolution. Thus, the server-n  can receive network resource requests from the client  that include a server name and share name, and the server-n  can identify a network server associated with the resource request. Advantageously, the server-n  can facilitate server name resolution despite server consolidation, server name changes, use of multiple different server names for a single server, or unrecognized server names from the client .","As illustrated, server-n  includes a registration module  whereby servers on the network , such as server- , can be registered to facilitate accessing resources on the registered servers. The registration module  can receive server registration information from a system administrator, the client , the server-  or other computing devices on the network. The registration module  uses a server registry  and an alias registry  to store server registration information. A particular implementation of the registration module  is discussed below with respect to .","In general, the server registry  maintains server and share information to facilitate server name resolution. For example, the server registry  may include a DNS server name and share name associated with a network address of the actual server associated with the server name and share name. A particular implementation of the server registry  is discussed below with regard to .","The alias registry  includes aliases for network servers. Thus, if a network server may be referred to with more than one server name or identifier, the alias registry  can include all the server names and identifiers for the network server they identify. The alias registry  may also include a default server, which identifies a network server to be used if a received server name is not recognized. An exemplary implementation of the alias registry  is illustrated in , discussed below.","A name resolution module  uses the server registry  and the alias registry  to resolve server names and share names. In a typical scenario, the server-n  a network resource request from a network device, such as the client . The network resource request may be in a Universal Naming Convention (UNC) format, or another format. The name resolution module  attempts to determine a server identified by the requested server name and requested share name and direct or redirect the resource request to the identified server.","The name resolution module  may redirect the resource request to another server. In addition, the resource request may be directed to a server on which other server shares were previously consolidated; thus, the request server name may not equate to the name of the server on which the requested share actually resides. As a result, serving resources to a client is a virtual process, because the client may not actually receive resources from the server identified by the requested server name. An exemplary implementation of the name resolution module  is shown in  and discussed below.","The server-n  may also include one or more share(s)  and one or more other resource(s) . The share(s)  and other resource(s)  may be accessed by the client  using virtual resource serving through the name resolution module . Exemplary operations for registering server names, share names, aliases, and default server names are shown and discussed in detail below with respect to . Exemplary operations for using registered names, aliases and defaults for providing virtual file serving are shown and discussed in detail below with respect to .","Referring again to share scoping, a concrete example is now presented to illustrate how share scoping can work and benefits that may be attained. One goal of share scoping is to allow a single server to represent multiple virtual servers to incoming clients. Share scoping can be effectively applied in server consolidation and clustering. The naming convention used for scoped shares follows the Universal Naming Convention (UNC). Thus, a share named \u201cSHAREA\u201d for the server name \u201cSERVER\u201d would be represented as \\\\SERVER\\SHAREA.","Assume that a company has three NT4 servers, having server names, shares, and share names shown in Table 1:",{"@attributes":{"id":"p-0032","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":"TABLE 1"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"Exemplary Servers and Shares to Illustrate Share Scoping"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["ServerName: NT4-A","ServerName: NT4-B","ServerName: NT4-C"]},{"entry":["\u2003\u2003Shares:","\u2003\u2003Shares:","\u2003\u2003Shares:"]},{"entry":["\u2003\u2003\u2003\u2003Public =","\u2003\u2003\u2003\u2003Public =","\u2003\u2003\u2003\u2003Private ="]},{"entry":["\u2003\u2003\u2003\u2003c:\\public","\u2003\u2003\u2003\u2003c:\\public","\u2003\u2003\u2003\u2003c:\\private"]},{"entry":["\u2003\u2003\u2003\u2003Docs =","\u2003\u2003\u2003\u2003Pictures =","\u2003\u2003\u2003\u2003Files ="]},{"entry":["\u2003\u2003\u2003\u2003c:\\docs","\u2003\u2003\u2003\u2003c:\\pics","\u2003\u2003\u2003\u2003c:\\files"]},{"entry":[{},"\u2003\u2003\u2003\u2003Data ="]},{"entry":[{},"\u2003\u2003\u2003\u2003c:\\data"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"The company is going to consolidate these servers NT4-A, NT4-B, and NT4-C into a single server named \u201cBlackcomb\u201d. Assume that server Blackcomb has a very large disk. Consolidation includes copying the contents of the NT4-A, NT4-B, and NT4-C servers' disks to the Blackcomb server. A system administrator may decide to use a sub-directory convention, so that directory c:\\nt4-a on Blackcomb represents directory c:\\ from NT4-A, directory c:\\nt4-b on Blackcomb represents directory c:\\ from server NT4-B, and so on.","Without using share scoping, NT4-A shares may be configured and identified on the Blackcomb server as follows:","Public=c:\\nt4-a\\public","Docs=c:\\nt4-a\\docs","Using the above configuration and identification for server shares from server NT4-A, a collision may arise between the \u2018Public\u2019 share from NT4-A and the \u2018Public\u2019 share from NT4-B. When the administrator adds another share named \u2018Public\u2019 from NT4-B, the share name \u2018Public\u2019 is no longer unique, because the share name \u2018Public\u2019 has already been configured to identify the Public share from the NT4-A server.","Another issue that arises in the scenario when share scoping is not used involves an apparent change to the namespace as viewed by a client. For example, without share scoping, when a client enumerates the shared resources on the NT4-A server may receive a list of the six shares: Public, Docs, Pictures, Data, Private, Files. From the client's perspective, there are four shares (i.e., Pictures, Data, Private, Files) that appear to be part of NT4-A, but did not exist before the consolidation. Such a result from server consolidation may cause user confusion.","To address the foregoing issues, shares are beneficially configured on the Blackcomb server using share scoping. With share scoping, when the administrator is adding the shares, the shares are qualified with a server name. Thus, for example, the shares on the Blackcomb server may be configured and identified as follows:",{"@attributes":{"id":"p-0040","num":"0039"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\\\\NT4-A\\Public = c:\\nt4-a\\public"]},{"entry":[{},"\\\\NT4-A\\Docs = c:\\nt4-a\\docs"]},{"entry":[{},"\\\\NT4-B\\Public = c:\\nt4-b\\public"]},{"entry":[{},"\\\\NT4-B\\Pictures = c:\\nt4-b\\pics"]},{"entry":[{},"\\\\NT4-B\\Data = c:\\nt4-b\\data"]},{"entry":[{},"\\\\NT4-C\\Private = c:\\nt4-c\\private"]},{"entry":[{},"\\\\NT4-C\\Files = c:\\nt4-c\\files"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"As illustrated, using share scoping, seven shares are created on Blackcomb, wherein the seven shares are identified by \\\\NT4-A\\Public, \\\\NT4-A\\Docs, \\\\NT4-B\\Public, \\\\NT4-B\\Pictures, \\\\NT4-B\\Data, \\\\NT4-C\\Private, and \u2261Thus, each of the shares has a unique share name, resulting in no name collision. In addition, the namespace remains identical to the namespace before the consolidation. Thus, a client enumerating shared resources on NT4-A will receive share names \u2018Public\u2019 and \u2018Docs\u2019. An enumeration of shared resources on NT4-B will result in the other \u2018Public\u2019 share along with \u2018Pictures\u2019 and \u2018Data\u2019.","In one implementation, enumerating the shared resources on the Blackcomb server will not return any of the consolidated shares. Shares can be added to the Blackcomb name if Blackcomb is to be added as a server. As discussed further below, a server name can be represented with a wildcard name. A wildcard name includes a wildcard symbol or set of symbols, which represent any symbol. For example, a wildcard share can be represented by a UNC share name \u2018\\\\*\\SHAREB\u2019, wherein the symbol \u2018*\u2019 represents a wildcard server name. If the server name is not specified, the server name is assumed to be a wildcard. A wildcard share is visible and accessible through any virtual server name. Thus, for example, if a wildcard name is set up for a share on the Blackcomb server, a share name will show up on all registered server names.","In an exemplary clustering scenario, assume the administrator has a 2-node cluster named NTSTRESS that is hosted by server nodes NTSTR and NTSTR. Server NTSTR is also used to store a music collection on the share \u201cWMA\u201d. The NTSTRESS node hosts two shares, \u201cRESULTS\u201d and \u201cSYMBOLS\u201d. The administrator wants the shares for NTSTRESS to only be accessible when the user accesses the server with the cluster name (NTSTRESS.) In addition, the administrator doesn't want the music collection being visible to all the users using the cluster. Using share scoping, the administrator sets up the cluster shares using qualified server names. Three shares are added, \\\\ntstress\\results, \\\\ntstress\\symbols, and \\\\ntstr1\\wma. If the cluster fails from NTSTR to NTSTR, the NTSTRESS shares are removed and added to NTSTR, but the WMA share remains. Thus, share scoping provides virtual separation between the cluster virtual server name and the physical node name that is currently handling it.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 2","b":["200","202","204","206","204","200","202","200","202","206"]},"The exemplary server registry  includes a list of one or more registered server names , a list of associated share names , and a list of associated network addresses . The server registry  may also include entries for wildcard server names , illustrated with asterisks \u2018*\u2019 in . The wildcard entries  can include any symbol or set of symbols, which are preferably unlikely to be used for actual server names.","The alias registry  includes a list of one or more alias server names  and a list of associated target or destination server names . The alias registry  may also include a \u2018default\u2019 entry , which identifies a default server name to be used if an unrecognized server name is requested. The alias registry  and the server registry  may be implemented in software, hardware, firmware, or any combination thereof. For example, the server registry  and the alias registry  may comprise one or more data structures in random access memory (RAM). A registration application programming interface (API)  in the registration module  receives server registration information and updates the server registry  and\/or the alias registry  accordingly.","For adding a new share to the server registry , or querying or enumerating the server registry  for share information, the data structure shown below can be used. The data structure is called \u2018SHARE_INFO\u2019.",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"typedef struct _SHARE_INFO{"]},{"entry":[{},"\u2003\u2003LMSTR\u2003\u2003netname;"]},{"entry":[{},"\u2003\u2003DWORD\u2003\u2003type;"]},{"entry":[{},"\u2003\u2003LMSTR\u2003\u2003remark;"]},{"entry":[{},"\u2003\u2003DWORD\u2003\u2003permissions;"]},{"entry":[{},"\u2003\u2003DWORD\u2003\u2003max_uses;"]},{"entry":[{},"\u2003\u2003DWORD\u2003\u2003current_uses;"]},{"entry":[{},"\u2003\u2003LMSTR\u2003\u2003path;"]},{"entry":[{},"\u2003\u2003LMSTR\u2003\u2003passwd;"]},{"entry":[{},"\u2003\u2003LMSTR\u2003\u2003servername;"]},{"entry":[{},"\u2003\u2003DWORD\u2003\u2003reserved;"]},{"entry":[{},"\u2003\u2003PSECURITY_DESCRIPTOR \u2002security_descriptor;"]},{"entry":[{},"} SHARE_INFO, *PSHARE_INFO, *LPSHARE_INFO;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Most relevant to this discussion is the data field labeled \u2018servername\u2019. In one implementation, the \u2018servername\u2019 field can be set to a designated wildcard symbol, such as NULL or \u201c*\u201d to signify a wildcard share. Otherwise, the \u2018servername\u2019 should be a textual name representing the name of the virtual server. In one implementation, if the \u2018servername\u2019 is a DNS name, the server name can be truncated at its first leftmost period (i.e., \u201c.\u201d). In this or another implementation, an IP address can be setup as an allowable name and may or may not be truncated.","An exemplary implementation of the resolution API  uses a server name as a simple text field in a lookup into the server registry . For example, when a client requests a share on a server, the resolution API  looks up the requested server name in the server registry . The resource request is sent to the requested server if the requested server name is found in the registry. Using share scoping, discussed above, both the requested server name and the requested server share can be combined to identify the proper registered share; that is, the share name can be qualified with the server name to identify the correct share in the server registry.","With more specific reference to the alias registry , the alias registry  includes associations between one or more aliases and one or more server names. For example, assume a server has server name JSMITH-DEV. Aliases \u201cjsmith-dev.ntdev.corp.microsoft.com\u201d and \u201cjsmith-dev.dns.microsoft.com\u201d could be registered in the alias registry  and thereby associated with server JSMITH-DEV. As another example, an Internet Protocol address \u201c157.59.254.232\u201d can be registered as an alias to JSMITH-DEV in the alias registry . This way, access by any of those names would be referred to the name \u201cJSMITH-DEV\u201d.","Continuing with the example, when a client requests \u201cjsmith-dev.ntdev.corp.microsoft.com\u201d, \u201cjsmith-dev.dns.microsoft.com\u201d, or \u201c157.59.254.232\u201d, the name resolution API  can resolve any of these names to server name JSMITH-DEV, using the alias registry . Thus, the alias registry  allows for the handling of cases where DNS and Network Basic Input\/Output System (NetBIOS) names are different, and also allows for IP addresses to be mapped to the appropriate server name.","An exemplary server alias structure for setting server aliases is:",{"@attributes":{"id":"p-0054","num":"0053"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"typedef struct SERVER_ALIAS_INFO {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"LMSTR","srvai_alias;"]},{"entry":[{},"LMSTR","srvai_target;"]},{"entry":[{},"BOOLEAN","srvai_default;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"} SERVER_ALIAS_INFO, *PSERVER_ALIAS_INFO,"]},{"entry":[{},"*LPSERVER_ALIAS_INFO;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In the above exemplary structure, the field \u201csrvai_alias\u201d represents an alias server name, the field \u201csrvai_target\u201d represents a target or destination server name corresponding to the alias, and the \u201csrvai_default\u201d field indicates whether a default server can be used if no alias exists. In an implementation of the SERVER_ALIAS_INFO structure, the alias is a unique name. The alias name or target name can be a NetBIOS name, such as \u201cJSMITH-DEV\u201d, a Domain Name System (DNS) name, such as \u201cJSMITH-DEV.NTDEV.CORP.MICROSOFT.COM\u201d, or an IP address, such as \u201c127.0.0.1\u201d.","In one implementation of the SERVER_ALIAS_INFO structure, the target should be a NetBIOS-style name. The default (i.e., \u2018srvai_default\u2019) bit can be set on any mapping, and that mapping can be used if an alias is not found to match the requested server name. In this implementation, it is legal to set up an alias with a NULL alias name and a non-null target name if default is set to TRUE, but only one such alias can be established.","As discussed, a server name can be established as a \u201cdefault\u201d server. A default entry in the alias registry  identifies a server name that will be presented when a client requests an unrecognized server name. A default server is separate from the wildcard shares because wildcard shares represent share names valid on all server names. By contrast, a default server is a server that will be selected if the requested server name is not found in the server registry , there is no wildcard server name for the requested share, and the requested server is not an alias for an actual server.","One implementation of the registration API  includes one or more computer-executable functions for registering servers, shares, and aliases. Exemplary functions are shown and described as follows:",{"@attributes":{"id":"p-0059","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NetServerAliasAdd"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NET_API_STATUS NET_API_FUNCTION"]},{"entry":[{},"NetServerAliasAdd("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IN\u2003LMSTR","servername,"]},{"entry":[{},"IN\u2003LPBYTE","alias"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The NetServerAliasAdd function can be called to add an alias to the alias registry . The \u2018servername\u2019 parameter identifies the server where the resource request will be processed. The \u2018alias\u2019 parameter should be a valid PSERVER_ALIAS_INFO structure as described above.",{"@attributes":{"id":"p-0061","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NetServerAliasDel"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NET_API_STATUS NET_API_FUNCTION"]},{"entry":[{},"NetServerAliasDel("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IN\u2003LMSTR","servername,"]},{"entry":[{},"IN\u2003LPBYTE","alias"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The NetServerAliasDel function can be called to delete an alias server name from the alias registry . The \u2018servername\u2019 parameter identifies the server handling the resource request. The \u2018alias\u2019 parameter should be a PSERVER_ALIAS_INFO structure as described above. The only required field in the PSERVER_ALIAS_INFO structure is the srvai_alias field, as the \u2018srvai_target\u2019 and \u2018srvai_default\u2019 parameters can be ignored.",{"@attributes":{"id":"p-0063","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"NetServerAliasEnum"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"182pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NET_API_STATUS NET_API_FUNCTION"]},{"entry":[{},"NetServerAliasEnum("]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"IN\u2003LMSTR","servername,"]},{"entry":[{},"OUT LPBYTE","*bufptr,"]},{"entry":[{},"IN\u2003DWORD","prefmaxlen,"]},{"entry":[{},"OUT LPDWORD","entriesread,"]},{"entry":[{},"OUT LPDWORD","totalentries,"]},{"entry":[{},"IN OUT LPDWORD","resumehandle"]},{"entry":[{},");"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"The function NetServerAliasEnum can be called to enumerate a list of all server shares that have alias entries in the alias registry . The \u2018servername\u2019 parameter identifies the server where the resource request will be processed. The \u2018bufptr\u2019 parameter is a pointer that points to an array of SHARE_ALIAS_INFO structures. A buffer that will be of share information structures will be allocated for the caller. The \u2018prefmaxlen\u2019 parameter indicates the largest size buffer the caller would like, or 0xFFFFFFFF (Hexadecimal) for no preference.","The \u2018entriesread\u2019 parameter indicates how many entries are returned to the caller. The \u2018totalentries\u2019 parameter indicates the total number of entries that should be returned. The \u2018resumehandle\u2019 parameter should be 0 for a first call to the function, and can be incremented for subsequent calls to the function.","Exemplary Operations to Facilitate Virtual Resource Serving","The operations illustrated in  and  can be implemented in computer-readable executions, stored on computer readable media and executed by a microprocessor. The operations need not be performed in the order shown in  and ; the operations themselves serve to illustrate one possible way for one skilled in the art to implement a virtual resource serving scheme. As such, the order of the operations may be changed in a particular implementation without departing from the spirit of the claimed subject matter.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 3","FIG. 2"],"b":["300","300","204","222","300","300"]},"A receiving operation  receives registration information from a source of registration information. The registration information contains server name, share name, alias, wildcard, default server, server network address, and other server configuration information. In one implementation, the registration information is read from a memory, such as a magnetic disk, which permanently stores the registration information, and stored in a random access memory (RAM) during operation. The registration information can be updated automatically or manually. For example, a new server on the network can register by claiming a server name and identifying its configuration information, including share names and network address. Alternatively, a system administrator can manually add and\/or delete server configuration information from the registration information.","A first registering operation  registers one or more servers and share of the servers. The server's name is received and checked against other server names in a server registry. If the received server name has not already been used, the server name is stored in the registry in a server name field. One or more share names corresponding to shares provided by the server may be stored in share name fields in the server registry. A network address associated with the server may be stored in a network address field in the registry.","A second registering operation  registers one or more alias server names and target or destination server names. The alias server names are stored in alias fields in an alias registry along with a target server name that corresponds to the alias. As discussed, the alias can be any unique symbol or set of symbols that represent a server.","A third registering operation  registers a default server name that identifies a server to default to in the event that a requested server name is unrecognized in the server registry and the alias registry. The default server name can be stored along with the target server name in the alias registry or some other data structure. The registration operation flow  ends at return operation .",{"@attributes":{"id":"p-0072","num":"0071"},"figref":["FIG. 4","FIG. 2","FIG. 2","FIG. 4"],"b":["400","400","400","206","224"]},"A receiving operation  receives a resource request. In one implementation, the resource request  is received over a network from a client. The resource request identifies a resource on a server that the client is attempting to access. The resource request includes a server name and a share name, wherein the server name identifies a server providing the requested resource, and the share name identifies the requested resource. The resource request may be received in a number of formats, including, but not limited to, the Universal Naming Convention (UNC) format.","In the receiving operation , the requested server name may be in a number of formats, including, but not limited to, a network address (e.g., IP address), a DNS name, or a NetBIOS name. In addition, the server name may not correspond directly to the actual server that provides the requested resource. Due to changes, such as server configuration or protocol changes, or server identity changes or multiple server identities, the server that the client is requesting may not be the actual server that provides the requested share. As such, the name resolution operation  attempts to resolve the requested server and share to a destination server that provides the requested share.","A looking up operation  looks up the requested server name and the requested share name in a server registry. The looking up operation  attempts to determine a network address for the requested server. The looking up operation  can be carried out as a search on ASCII text in a table that associates server names with network addresses. Alternatively, the looking up operation  may includes a mapping from the requested server\/share name to a network address. The looking up operation  outputs a status indicating whether the look up operation successfully identified a network address.","A determining operation  determines whether the looking up operation  successfully identified a network address associated with the requested server\/share. If so, a \u2018YES\u2019 path is taken to a designating operation , wherein the destination server is set to the server identified in the request. That is, the network address determined in the looking up operation  is used as the destination server address. The resource request is forwarded to the network address determined from the looking up operation .","In a retrieving operation , the destination server receives the resource request and uses both the server name and the share name to retrieve the requested share. Through share scoping, discussed above, the path to the requested share may have been qualified with a server name. Thus, both the server name and the share name are used to determine the path to the share at the destination server. As discussed above, by using both the server name and the share name to retrieve the requested share, issues such as namespace conflicts can be avoided.","Referring again to the determining operation , if it is determined that the looking up operation  did not successfully identify a network address for the requested server, a \u2018NO\u2019 path is taken to a second determining operation . The second determining operation  determines whether an alias has been registered for the requested server name. In one implementation, the second determining operation  looks up the requested server name in an alias registry that associates alias server names with actual servers. If the requested server name is determined to be an alias for another server name, the other server name is retrieved from the alias registry and a network address is determined for the other server.","If the second determining operation  determines that the requested server name is an alias for another server, a \u2018YES\u2019 branch is taken to the designating operation . As discussed, the designating operation  designates a destination address as the network address that was determined for the requested server.","If the second determining operation  determines that the requested server name is not an alias for another server, a \u2018NO\u2019 branch is taken to a third determining operation . The third determining operation  determines whether the requested share name matches a registered share name and the requested share name is associated with a wildcard server name. If the third determining operation  determines that the requested share name is registered with a wildcard server name, a \u2018YES\u2019 branch is taken to a second designating operation .","The second designating operation  sets the destination server to a registered server based on the wildcard share. The designating operation  chooses one of the registered servers associated with the share name provided in the request. The designating operation  then sends the resource request to the destination server. In the retrieving operation , the destination server uses both the server name and the share name to retrieve the requested resource.","Referring again to the third determining operation , if the requested share is not registered with a wildcard server name, the name resolution operation  branches \u2018NO\u2019 to a fourth determining operation . The fourth determining operation  determines whether a default server has been registered. One implementation of the fourth determining operation  looks up a default server name in a registry, such as the server registry or the alias registry.","If the fourth determining operation  determines that a default server has been registered, the name resolution operation  branches \u2018YES\u2019 to a designating operation . The third designating operation  sets the destination server to the registered default server. The resource request is sent to the registered default server. The retrieving operation  then retrieves the requested resource as discussed above.","If the fourth determining operation  determines that no default server has been registered, the name resolution operation  branches \u2018NO\u2019 to a generating operation . The generating operation  generates an error indicating that the requested server or requested share are unidentified. A returning operation  returns the requested resource if the requested resource was identified and retrieved. The returning operation  also returns a status to the requesting client, wherein the status indicates whether the requested resource was successfully retrieved.",{"@attributes":{"id":"p-0085","num":"0084"},"figref":"FIG. 5","b":["500","500"]},"In addition, scoping the share enumeration on server name can preserve the logical separation of shares from a client's perspective. Many applications that may interact with shared resources may be designed to treat virtual servers as separate. In such applications, the fact that multiple virtual servers are hosted on the same physical server should be made transparent to the applications. The enumeration algorithm  can provide such transparency. The exemplary enumeration algorithm  receives an enumeration request from an application that specifies a server name.","A resolving operation  resolves the alias or default server name to obtain an actual server name as discussed above. After the server name has been resolved, an identifying operation  identifies all the shares specified for the requested server name. The identifying operation  includes the identified shares in an enumeration to be returned to the requesting application. A wildcard identifying operation  identifies all the wildcard shares corresponding to server names that do not conflict with the alias, default, or actual server names in the resolving operation . The shares identified in the identifying operation  and the wildcard identifying operation  are combined and returned to the requesting application.","Exemplary Computer and\/Computing System",{"@attributes":{"id":"p-0088","num":"0087"},"figref":["FIG. 6","FIG. 6"],"b":["610","610","620","621","622","623","621","621","620","620"]},"The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory may also be referred to as simply the memory, and includes read only memory (ROM)  and random access memory (RAM) . A basic input\/output system (BIOS) , containing the basic routines that help to transfer information between elements within the computer , such as during start-up, is stored in ROM . The computer  further includes a hard disk drive  for reading from and writing to a hard disk, not shown, a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD ROM or other optical media.","The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical disk drive interface , respectively. The drives and their associated computer-readable media provide nonvolatile storage of computer-readable instructions, data structures, program modules and other data for the computer . It should be appreciated by those skilled in the art that any type of computer-readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories (RAMs), read only memories (ROMs), and the like, may be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk, magnetic disk , optical disk , ROM , or RAM , including an operating system , one or more application programs , other program modules , and program data . At least one of the application programs  includes computer executable instructions for performing virtual resource serving.","A user may enter commands and information into the personal computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner, or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port, or a universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor, computers typically include other peripheral output devices (not shown), such as speakers and printers.","The computer  may operate in a networked environment using logical connections to one or more remote computers, such as remote computer . These logical connections may be achieved by a communication device coupled to or a part of the computer , or in other manners. The remote computer  may be another computer, a server, a router, a network PC, a client, a peer device or other common network node, and typically includes many or all of the elements described above relative to the computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local-area network (LAN)  and a wide-area network (WAN) . Such networking environments are commonplace in office networks, enterprise-wide computer networks, intranets and the Internal, which are all types of networks.","When used in a LAN-networking environment, the computer  is connected to the local network  through a network interface or adapter , which is one type of communications device. When used in a WAN-networking environment, the computer  typically includes a modem , a type of communications device, or any other type of communications device for establishing communications over the wide area network . The LAN  and\/or the WAN  can include wired networks, wireless networks, or any combination of wired or wireless networks.","The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It is appreciated that the network connections shown are exemplary and other means of and communications devices for establishing a communications link between the computers may be used.","Although some exemplary methods, devices and exemplary systems have been illustrated in the accompanying Drawings and described in the foregoing Detailed Description, it will be understood that the methods and systems are not limited to the exemplary embodiments disclosed, but are capable of numerous rearrangements, modifications and substitutions without departing from the spirit set forth and defined by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
