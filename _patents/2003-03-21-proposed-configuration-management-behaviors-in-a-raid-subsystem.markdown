---
title: Proposed configuration management behaviors in a raid subsystem
abstract: A technique forecasts the behavior of a RAID subsystem when processing a proposed configuration management request that modifies a topology or attribute configuration, e.g., RAID groups and volume layout, of a storage array managed by the subsystem. In response to the proposed request, the RAID subsystem returns a set of projected result data instead of committing the request to the storage array configuration. An operator issues the proposed request in accordance with a novel view-only mode of a configuration management command. The view-only mode is manifested as an “-n” option that instructs a configuration thread of the RAID subsystem to return pre-committed results without actually committing the modification.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07143235&OS=07143235&RS=07143235
owner: Network Appliance, Inc.
number: 07143235
owner_city: Sunnyvale
owner_country: US
publication_date: 20030321
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF AN ILLUSTRATIVE EMBODIMENT"],"p":["The present invention relates to storage systems and, more specifically, to a technique that forecasts the behavior in a RAID subsystem of a storage system.","A storage system typically comprises one or more storage devices into which data may be entered, and from which data may be obtained, as desired. The storage system includes a storage operating system that functionally organizes the system by, inter alia, invoking storage operations in support of a storage service implemented by the system. The storage system may be implemented in accordance with a variety of storage architectures including, but not limited to, a network-attached storage environment, a storage area network and a disk assembly directly attached to a client or host computer. The storage devices are typically disk drives organized as a disk array, wherein the term \u201cdisk\u201d commonly describes a self-contained rotating magnetic media storage device. The term disk in the context is synonymous with hard disk drive (HDD) or direct access storage device (DASD).","Storage of information on the disk array is preferably implemented as one or more storage \u201cvolumes\u201d, defining an overall logical arrangement of disk space. The disks within a volume are typically organized as one or more groups, wherein each group is operated as a Redundant Array of Independent (or Inexpensive) Disks (RAID). Most RAID implementations enhance the reliability\/integrity of data storage through the redundant writing of data \u201cstripes\u201d across a given number of physical disks in the RAID group, and the appropriate storing of redundant information with respect to the striped data. The redundant information may thereafter be retrieved to enable recovery of data lost when a storage device fails.","In the operation of a disk array, it is anticipated that a disk can fail. A goal of a high performance system is to make the mean time to data loss as long as possible, preferably much longer than the expected service life of the system. Data can be lost when one or more disks fail, making it impossible to recover data from the device. Typical schemes to avoid loss of data include mirroring, backup and parity protection. Mirroring stores the same data on two or more disks so that if one disk fails, the \u201cmirror\u201d disk(s) can be used to serve (e.g., read) data. Backup periodically copies data on one disk to another disk. Parity schemes are common because they provide a redundant encoding of the data that allows for loss of one or more disks without the loss of data, while requiring a minimal number of disk drives in the storage system.","Parity protection is used in computer system to protect against loss of data on a storage device, such as a disk. A parity value may be computed by summing (usually modulo 2) data of a particular word size (usually 1 bit) across a number of similar disks holding different data and then storing the results on the disk(s). That is, parity may be computed on 1-bit wide vectors, composed of bits in predetermined positions on each of the disks. Addition and subtraction on 1-bit vectors are an equivalent to exclusive-OR (XOR) logical operations; these addition and subtraction operations can thus be replaced by XOR operations. The data is then protected against the loss of any one of the disks, or of any portion of the data on any one of the disks. If the disk storing the parity is lost, the parity can be regenerated from the data. If one of the data disks is lost, the data can be regenerated by adding the contents of the surviving data disks together and then subtracting the results from the stored parity.","Typically, the disks are divided into parity groups, each of which comprises one or more data disks and a parity disk. The disk space is divided into stripes, with each stripe containing one block from each disk. The blocks of a stripe are usually at equivalent locations on each disk in the parity group. Within a stripe, all but one block contain data (\u201cdata blocks\u201d) with the one block containing parity (\u201cparity block\u201d) computed by the XOR of all the data. If the parity blocks are all stored on one disk, thereby providing a single disk that contains all (and only) parity information, a RAID-4 implementation is provided. If the parity blocks are contained within different disks in each stripe, usually in a rotating pattern, then the implementation is RAID-5. The term \u201cRAID\u201d and its various implementations are well-known and disclosed in (), by D. A. Patterson, G. A. Gibson and R. H. Katz, Proceedings of the International Conference on Management of Data (SIGMOD), June 1988.","The storage operating system of the storage system typically includes a RAID subsystem that manages the storage and retrieval of information to and from the disks of a storage array in accordance with input\/output (I\/O) operations. In addition, the storage operating system includes administrative interfaces, such as a user interface, that enable operators (system administrators) to access the system in order to implement, e.g., configuration management decisions. Configuration management in the RAID subsystem generally involves a defined set of modifications to the topology or attributes (i.e., configuration) associated with a storage array, such as a disk, a RAID group, a volume or set of volumes. Examples of these modifications include, but are not limited to, disk failure handling, volume splitting, volume online\/offline, changes to (default) RAID group size or checksum mechanism, and disk addition.","Typically, configuration management requests are issued through a user interface oriented towards operators that are knowledgeable about the underlying physical aspects of the system. That is, the interface is often adapted towards physical disk structures and management that the operators may manipulate in order to present a view of the storage system on behalf of a client. Often, it is desirable to know the outcome of a proposed configuration operation prior to issuing a configuration management request and being forced to live with the results. For example, it is desirable to understand disk allocation and placement decisions that will be made by the RAID subsystem when a request is made to add one or more disks to a volume. Once the disks have been added to the volume, it is difficult to \u201cundo\u201d the addition without taking drastic measures.","The present invention overcomes the disadvantages of the prior art by providing a technique for forecasting the behavior of a RAID subsystem when processing a proposed configuration management request that modifies a topology or attribute configuration, e.g., RAID groups and volume layout, of a storage array managed by the subsystem. In response to the proposed request, the RAID subsystem returns a set of projected result data instead of committing the request to the storage array configuration. An operator (user) issues the proposed request in accordance with a novel view-only mode of a configuration management command. The view-only mode is manifested as an \u201c-n\u201d option that instructs a configuration thread of the RAID subsystem to return pre-committed results without actually committing the modification.","The inventive technique takes advantage of transactional semantics associated with configuration management in the RAID subsystem to allow an operation to proceed to a pre-committed state containing result data. The result data is copied for a response to the user prior to destroying (aborting) the pre-committed state. Specifically, the result data is returned to the user as a proposed configuration response on a command line or other encapsulated form of the original request that can be reissued upon confirmation by the user. The user then views the results (which may be integrated with graphical management applications) for acceptance and\/or a likelihood of committing the proposed response to the storage array configuration. Alternately, the user may make changes in the results and issue a new proposed request to the configuration thread.","Advantageously, the inventive technique utilizes transaction semantics to allow a proposed operation to complete without intricate special casing of the behaviors. The present invention also provides benefit to system operators\/users, allowing for iterative configuration proposals. Moreover, the inventive technique avoids \u201cback-out\u201d scenarios associated with committing sub-optimal or undesired disk placement decisions.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","120","130","160","120","122","124","126","128","125","120","200"]},"In the illustrative embodiment, the memory  comprises storage locations that are addressable by the processor and adapters for storing software program code and data structures associated with the present invention. The processor and adapters may, in turn, comprise processing elements and\/or logic circuitry configured to execute the software code and manipulate the data structures. Storage operating system , portions of which are typically resident in memory and executed by the processing elements, functionally organizes the system  by, inter alia, invoking storage operations executed by the storage system. It will be apparent to those skilled in the art that other processing and memory means, including various computer readable media, may be used for storing and executing program instructions pertaining to the inventive technique described herein.","The network adapter  comprises the mechanical, electrical and signaling circuitry needed to connect the storage system  to a client  over a computer network , which may comprise a point-to-point connection or a shared medium, such as a local area network. Illustratively, the computer network  may be embodied as an Ethernet network or a Fibre Channel (FC) network. The client  may communicate with the storage system over network  by exchanging discrete frames or packets of data according to pre-defined protocols, such as the Transmission Control Protocol\/Internet Protocol (TCP\/IP).","The client  may be a general-purpose computer configured to execute applications . Moreover, the client  may interact with the storage system  in accordance with a client\/server model of information delivery. That is, the client may request the services of the storage system, and the system may return the results of the services requested by the client, by exchanging packets  over the network . The clients may issue packets including file-based access protocols, such as the Common Internet File System (CIFS) protocol or Network File System (NFS) protocol, over TCP\/IP when accessing information in the form of files and directories. Alternatively, the client may issue packets including block-based access protocols, such as the Small Computer Systems Interface (SCSI) protocol encapsulated over TCP (iSCSI) and SCSI encapsulated over Fibre Channel (FCP), when accessing information in the form of blocks.","The storage adapter  cooperates with the storage operating system  executing on the system  to access information requested by a user (or client). The information may be stored on any type of attached array of writable storage device media such as video tape, optical, DVD, magnetic tape, bubble memory, electronic random access memory, micro-electro mechanical and any other similar media adapted to store information, including data and parity information. However, as illustratively described herein, the information is preferably stored on the disks , such as HDD and\/or DASD, of array . The storage adapter includes input\/output (I\/O) interface circuitry that couples to the disks over an I\/O interconnect arrangement, such as a conventional high-performance, FC serial link topology.","Storage of information on array  is preferably implemented as one or more storage \u201cvolumes\u201d that comprise a collection of physical storage disks  cooperating to define an overall logical arrangement of volume block number (VBN) space on the volume(s). Each volume is generally, although not necessarily, associated with its own file system. The disks within a volume\/file system are typically organized as one or more groups, wherein each group is operated as a Redundant Array of Independent (or Inexpensive) Disks (RAID). Most RAID implementations, such as a RAID-4 level implementation, enhance the reliability\/integrity of data storage through the redundant writing of data \u201cstripes\u201d across a given number of physical disks in the RAID group, and the appropriate storing of parity information with respect to the striped data. Although a RAID-4 level implementation is illustratively described herein, it should be understood that other types and levels of RAID implementations may be used in accordance with the inventive principles described herein.","To facilitate access to the disks , the storage operating system  implements a write-anywhere file system that cooperates with virtualization modules to \u201cvirtualize\u201d the storage space provided by disks . The file system logically organizes the information as a hierarchical structure of named directories and files on the disks. Each \u201con-disk\u201d file may be implemented as set of disk blocks configured to store information, such as data, whereas the directory may be implemented as a specially formatted file in which names and links to other files and directories are stored. The virtualization modules allow the file system to further logically organize information as a hierarchical structure of blocks on the disks that are exported as named logical unit numbers (luns).","In the illustrative embodiment, the storage operating system is preferably the NetApp\u00ae Data ONTAP\u2122 operating system available from Network Appliance, Inc., Sunnyvale, Calif. that implements a Write Anywhere File Layout (WAFL\u2122) file system. However, it is expressly contemplated that any appropriate storage operating system including, for example, a write in-place file system may be enhanced for use in accordance with the inventive principles described herein. As such, where the term \u201cWAFL\u201d is employed, it should be taken broadly to refer to any storage operating system that is otherwise adaptable to the teachings of this invention.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2","b":["200","210","212","214","216","218","220","222","224","226","218"]},"An iSCSI driver layer  provides block protocol access over the TCP\/IP network protocol layers, while a FC driver layer  receives and transmits block access requests and responses to and from the storage system. The FC and iSCSI drivers provide FC-specific and iSCSI-specific access control to the blocks and, thus, manage exports of luns to either iSCSI or FCP or, alternatively, to both iSCSI and FCP when accessing the blocks on the storage system. In addition, the storage operating system includes a storage device manager embodied as a RAID subsystem  that manages the storage and retrieval of information to and from the volumes\/disks in accordance with I\/O operations, and a disk driver subsystem  that implements a disk access protocol such as, e.g., the SCSI protocol.","Bridging the disk software layers with the integrated network protocol stack layers is a virtualization system that is implemented by a file system  interacting with virtualization modules illustratively embodied as, e.g., vdisk module  and SCSI target module . The vdisk module  is layered on the file system  to enable access by administrative interfaces, such as a user interface (UI) , in response to a user (system administrator) issuing commands to the storage system. The SCSI target module  is disposed between the FC and iSCSI drivers ,  and the file system  to provide a translation layer of the virtualization system between the block (lun) space and the file system space, where luns are represented as blocks. The UI  is disposed over the storage operating system in a manner that enables administrative or user access to various layers and subsystems, such as the RAID subsystem .","The file system is illustratively a message-based system that provides volume management capabilities for use in access to the information stored on the storage devices, such as disks. That is, in addition to providing file system semantics, the file system  provides functions normally associated with a volume manager. These functions include (i) aggregation of the disks, (ii) aggregation of storage bandwidth of the disks, and (iii) reliability guarantees, such as mirroring and\/or parity (RAID). The file system  illustratively implements the WAFL file system having an on-disk format representation that is block-based using, e.g., 4 kilobyte (kB) blocks and using index nodes (\u201cinodes\u201d) to identify files and file attributes (such as creation time, access permissions, size, and block location). The file system uses files to store metadata describing the layout of its file system; these metadata files include, among others, an inode file. A file handle, i.e., an identifier that includes an inode number, is used to retrieve an inode from disk.","Operationally, a request from the client  is forwarded as a packet  over the computer network  and onto the storage system  where it is received at the network adapter . A network driver (of layer  or layer ) processes the packet and, if appropriate, passes it onto a network protocol and file access layer for additional processing prior to forwarding to the file system layer . Here, the file system generates operations to load (retrieve) the requested data from disk  if it is not resident \u201cin core\u201d, i.e., in the memory . If the information is not in memory, the file system  indexes into the inode file using the inode number to access an appropriate entry and retrieve a logical VBN. The file system then passes a message structure including the logical VBN to the RAID subsystem , which maps that logical number to a disk block number (DBN) and sends the latter to an appropriate driver (e.g., SCSI) of the disk driver subsystem . The disk driver accesses the DBN from disk  and loads the requested data block(s) in memory  for processing by the storage system. Upon completion of the request, the storage system (and operating system) returns a reply to the client  over the network .","It should be noted that the software \u201cpath\u201d through the storage operating system layers described above needed to perform data storage access for the client request received at the storage system may alternatively be implemented in hardware. That is, in an alternate embodiment of the invention, a storage access request data path may be implemented as logic circuitry embodied within a field programmable gate array (FPGA) or an application specific integrated circuit (ASIC). This type of hardware implementation increases the performance of the storage service provided by storage system  in response to a request issued by client . Moreover, in another alternate embodiment of the invention, the processing elements of adapters ,  may be configured to offload some or all of the packet processing and storage access operations, respectively, from processor , to thereby increase the performance of the storage service provided by the system. It is expressly contemplated that the various processes, architectures and procedures described herein can be implemented in hardware, firmware or software.","As used herein, the term \u201cstorage operating system.\u201d generally refers to the computer-executable code operable to perform a storage function in a storage system, e.g., that manages data access and may, in the case of a file server, implement file system semantics. In this sense, the ONTAP software is an example of such a storage operating system implemented as a microkernel and including the WAFL layer to implement the WAFL file system semantics and manage data access. The storage operating system can also be implemented as an application program operating over a general-purpose operating system, such as UNIX\u00ae or Windows NT\u00ae, or as a general-purpose operating system with configurable functionality, which is configured for storage applications as described herein.","In addition, it will be understood to those skilled in the art that the inventive technique described herein may apply to any type of special-purpose (e.g., file server or filer) or general-purpose computer, including a standalone computer or portion thereof, embodied as or including a storage system . Moreover, the teachings of this invention can be adapted to a variety of storage system architectures including, but not limited to, a network-attached storage environment, a storage area network and disk assembly directly-attached to a client or host computer. The term \u201cstorage system\u201d should therefore be taken broadly to include such arrangements in addition to any subsystems configured to perform a storage function and associated with other equipment or systems.","The present invention is implemented in the context of a configuration management framework used to implement the RAID subsystem  in the storage operating system . In a preferred embodiment, the configuration management framework provides an object-oriented approach to RAID configuration management, as described herein with respect to an implementation of the RAID subsystem.  is a schematic block diagram illustrating one or more modules or processes and threads of the RAID subsystem , wherein each process has, among other things, a (virtual) memory address space, executable code and data. A process is started with a single thread, but can create additional threads from any of its threads. The threads execute in the same memory address space and can therefore work concurrently on shared data. For example, an instantiator module implements a configuration (config) thread  adapted to maintain relationships among and invoke behaviors of decomposed software components (\u201cRAID objects\u201d) that collectively form the behaviors associated with a collection of (RAID) volumes on the storage system. In addition, an I\/O manager module implements an I\/O thread  configured to issue I\/O transaction requests from the RAID subsystem to the disk driver subsystem and, upon completion, process the results.","A finite state machine (FSM) module or engine  is used to arbitrate a set of events and states that a process or thread of the RAID subsystem may encounter. Transactional semantics isolate the behavior of state changes in the RAID subsystem from concurrent I\/O operations. The framework provides a two-phase commit procedure, coordinated with updates to on-disk configuration data (\u201clabels\u201d). Errors during disk label updates are handled by aborting the transaction, releasing partially committed data and unwinding any pending state transitions. A state notification mechanism integrated with the FSM engine  propagates state changes through the threads in order to provide a coordinated behavior.","According to the configuration management framework, a volume comprises the aggregate behavior of a number of RAID objects. Each RAID object (\u201cobject\u201d) comprises operational code and static state, such as configuration information, relating to the topology of the underlying physical storage devices, e.g., disks , contained in disk array . The objects are organized into a configuration tree with configuration interfaces defining a set of services provided by one or more processes of the RAID subsystem. Although the objects may be implemented in accordance with an object-oriented programming paradigm, the present invention is not limited to such an implementation. More broadly, the objects of the configuration tree refer to abstract entities representing a logical combination\/configuration of the disks. That is, the objects are used to present a view of the underlying topology of the storage array managed by the RAID subsystem.",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 4","b":["400","400"]},"Objects have an associated type, with each object type providing its own implementation of the configuration interfaces. A volume is organized into a hierarchical configuration tree of objects that includes a tree object  responsible for coordinated behavior with the file system and a volume object  responsible for managing the RAID aspects of volume management. Specifically, the volume object  represents the (WAFL) file system at the highest level (i.e., root node) of the configuration tree . To that end, the volume object  stores metadata that describes a volume\/file system, wherein the metadata includes information such as the name of the volume and address range (in physical blocks) of the volume. The name of the volume resides in a volume namespace that is exported by the UI  of the storage operating system . The logical address space of the file system is mapped to the physical (block) address space in the RAID subsystem .","The configuration tree  and, in particular, the volume object  represent a logical disk that is presented to the file system by the RAID subsystem as a \u201ccontainer\u201d for the file system to store its data. That is, the objects of the configuration tree are organized to create an address space that resembles a single logical disk but, in reality, comprises a plurality of physical disks. In this context, the volume object  is equivalent to the tree object , wherein the tree object stores additional metadata about the logical volume that is presented to the file system. This additional metadata includes the type (level) of parity implementation configured for the particular volume (e.g., RAID-4, RAID-0, mirror_RAID-4, mirror RAID-0, row-diagonal parity). Since the tree object is a one-to-one representation of the volume, the additional metadata stored in the tree object includes redundant information about the volume, such as its name and physical address\/block range.","A next object level comprises a mirror object  that is responsible for coordinating one or more copies of the volume (termed \u201cplexes\u201d) in support of data mirroring. In synchronous data mirroring, two \u201cmirror\u201d copies are provided that are at all times synchronized. That is, changes to the data in one mirrored copy are immediately reflected in the other mirrored copy. The two identical mirrored copies have matching address spaces that are within the volume address space and that provide identical synchronized full copies of the data in the volume.","A plex object  is responsible for managing an instance of a copy of volume data and thus represents each mirrored copy within another object level of the configuration tree. Whereas the mirror object  stores metadata that is used to coordinate one or more copies (or plexes) of the volume in support of data mirroring, each plex object  stores metadata that is used to manage an instance of a copy of volume data. The plex object may include an ordinal placement (e.g., 1, 2) indicating that, for example, a first part (1) of the address space is associated with a particular RAID group and that a second part (2) of the address space is associated with another RAID group.","A next object level comprises one or more RAID group objects  per plex object. Each RAID group object  contains metadata that provides data protection and I\/O coordination over a set of disks. The metadata of the RAID group object includes information such as the number of disks within the RAID group and the address (block) range of each disk within the RAID group. In this context, a RAID group is defined as a number of disks and the address\/block space associated with those disks. Finally, there is another object level comprising one or more disk objects  per RAID group object, wherein each disk object  contains metadata that provides data access to the physical disks .","The configuration tree  is constructed in the memory  of the storage system  by a label assimilation process  of the RAID subsystem . According to the assimilation process, each disk associated with a volume includes a disk label structure that describes its placement and association with that volume. The on-disk label is, in essence, self-describing information for each disk that is actively attached to the storage system . The labels are used to dynamically assemble the disks into a volume and to construct an in core configuration tree  for that volume, starting from the disk object level up to the volume object level. Therefore, a label on a disk identifies that disk's participation in a RAID group and, furthermore, that group's association with plex, mirror and, ultimately, volume objects in the configuration tree. The label is located in a well-known location of the disk so that it can be queried by the RAID subsystem in accordance with, e.g., a discovery process during a boot operation.","Each object type instance of the configuration tree  comprises the following components: service interfaces, committed transactional state, pre-committed transactional state and non-transactional state. The service interfaces comprise an application programming interface (API) that the object exports to other software components. In the illustrative embodiment, the service interfaces include initialization and destruction, child object management (add, replace), online\/offline, transaction management (join, commit, abort, label I\/O, state change notify), virtual block management, and I\/O handling (context creation\/deletion, resource management, I\/O throttling). Each object type defines the commit, pre-committed, and non-transactional state that it holds. The transaction management interfaces are provided as a mechanism to create and modify transactional state in a manner that is coordinated across all objects in a volume.","The basic flow of control starts with a configuration management operation issued by, e.g., the file system  and received by the RAID subsystem . The file system passes the configuration management operation in the form of a message request that specifies a target volume and defines a named operation with specific parameters. The configuration thread  of the RAID subsystem receives the request and determines the object (e.g., volume, RAID group) of the configuration tree  for the volume to which the request is directed. The configuration thread then locates the tree object  for the volume and invokes relevant configuration operations using service interfaces of the appropriate object. When a service interface is invoked, the object is transparently \u201cjoined\u201d to the request prior to activation of the interface. Joining of an object to a request results in copying of the currently committed state into a pre-committed state area (called the \u201ctrans\u201d area of the object). The trans area is a portion of memory that records changes to the object that are pending commitment. The service interface makes its changes to the trans area. If the changes to the object result in a change of the state of the object, the FSM engine  is invoked.","The FSM engine  provides a critical component in managing the interrelationship between objects in a RAID volume. Specifically, the FSM engine defines the state\/event pairs that are \u201clegal\u201d and, for each state\/event, provides a mechanism to implement the invocation and determine any subsequent state transitions. In addition, the FSM engine provides tracing mechanisms to track the set of transitions that have occurred and provides object notification for pre-committed and committed state transitions. More specifically, the FSM engine  is responsible for determining the new state of the object (based upon a per object type state\/event table) and invoking the state notification interface of its \u201csuperior\u201d object in the volume hierarchy. The FSM engine includes an upward notification mechanism (e.g., from child to parent object) to notify the parent object about a state change in the child object.","When the configuration request completes all service interface invocations, it requests a label commit operation to persistently store the modified state. The label commit \u201cpulls\u201d data from the trans area in order to construct its new version of the label data. Label commit is deemed to be successful only if all labels in a plex can be successfully written. Once all labels have been successfully written, each object that has been joined to the request is responsible for copying its trans area data back to the committed state portion of the object. If labels are not successfully written, the trans area is discarded, any disk failures are identified and resulting configuration changes are initiated, the successfully written labels are re-written with the previous state, and the original configuration request is retried.","In the illustrative embodiment, there are several configuration management commands that are used to modify the topology or attribute configuration associated with a storage array, such as a disk, a RAID group, a volume or set of volumes. These configuration commands include, but are not limited to, create volume, create plex, add disks and split volume. The configuration management commands are entered into the storage system  by a user (operator) through, e.g., a command line interface (CLI) or similar administrative interface of the UI  to thereby effect configuration changes to the underlying topology configuration of the storage devices (disks ). For example, creation of a volume is effected by the operator entering a vol create CLI command that forms a configuration tree in memory  of the storage system. The format of the vol create CLI command is illustratively:\n\n","wherein vol create denotes the volume create operation specified in the command, foo is the name of the new volume and 6 is the number of disks to be contained in that new volume. In response to the vol create CLI command, the RAID subsystem allocates 6 spare disks and organizes them into a new volume or file system called foo. In other words, the RAID subsystem selects 6 disks from a spare pool and, for a RAID-4 level implementation, converts those 6 disks from spare types to five data disk types and one parity disk type. The selection and conversion of spare disks to data\/parity disks is performed in accordance with a disk addition technique, an example of which is described in U.S. patent application Ser. No. 10\/394,810 titled Technique for Managing Addition of Disks to a Volume of a Storage System, which application is hereby incorporated by reference.","However, the user is unaware as to exactly which disks are selected by the RAID subsystem in connection with the disk addition technique when responding to the vol create command. If the user wants to specify the exact disks to be selected, a -d option is provided in connection with the vol create CLI command. Yet, if the user has no knowledge of the types of disks in the spare pool, it would be desirable to allow the RAID subsystem to select the disks, while still having an understanding of what disks will be selected before actually committing the operation to the RAID subsystem.","According to the present invention, a technique is provided that forecasts the behavior of the RAID subsystem when processing a proposed configuration management request that modifies a topology or attribute configuration, e.g., RAID groups and volume layout, of the storage array managed by the subsystem. As noted, examples of configuration management command requests that support the novel view-only mode are create volume, create plex and add disks. In response to the proposed request, the RAID subsystem returns a set of projected result data instead of committing the request to the storage array configuration. An operator (user) may issue the proposed request in accordance with a novel view-only mode of a configuration management command. The view-only mode is manifested as an \u201c-n\u201d option that instructs the configuration thread of the RAID subsystem to return pre-committed results without actually committing the modification.","The inventive technique takes advantage of transactional semantics associated with configuration management in the RAID subsystem to allow an operation to proceed to a pre-committed state containing result data. The result data is copied for a response to the user prior to destroying (aborting) the pre-committed state. Specifically, the result data is returned to the user as a proposed configuration response on a command line or other encapsulated form of the original request that can be reissued upon confirmation by the user. The user then views the results (which may be integrated with graphical management applications) for acceptance and\/or a likelihood of committing the proposed response to the storage array configuration. Alternately, the user may make changes in the results and issue a new proposed request to the configuration thread.","The -n option associated with the configuration management CLI command instructs the configuration thread to return pre-committed results without actually committing the change. That is, the -n option enables a user to determine what would have been done in response to a CLI command for a configuration operation without actually performing (committing) that operation to the subsystem. For example, in response to the user entering the command vol create foo 6 -n at the UI  of the storage system, the RAID subsystem returns the following information to the user:\n\n","wherein the parameters 7a.1, 7a.2, . . . indicate disk names for the selected disks within disk shelves attached to the storage system. In essence, the RAID system cooperates with the UI to display a command line indicating a proposed configuration change in response to the CLI command.","The -n option of a CLI command is a feature of the configuration management framework of the RAID subsystem. It should be noted that an -n flag is used in connection with a make command associated with compiler management in UNIX operating system environments. The conventional compiler management make command is used to keep track of changes\/updates to source files in a UNIX operating system so as to only compile those files that have changed. The technique of the present invention extends the utility of configuration management framework in the RAID subsystem by providing the -n option for use with configuration management operations issued to RAID subsystem.","In the illustrative embodiment, the configuration thread  interacts with a configuration client of the UI  to provide support for the view-only request\/response model.  is a schematic block diagram illustrating the interaction  between the configuration client  and the configuration thread  when invoking the -n option of the present invention. The configuration client  is responsible for interpreting a CLI command entered by a user into the UI . In particular, the configuration client  parses the CLI command text into various parameters that are converted into a message and passed to the configuration thread . The message comprises a proposed configuration management operation with a setting of \u201cview-only\u201d (i.e., the -n option). Note that the configuration client includes code that distinguishes various CLI commands with respect to issuing messages to either the RAID subsystem  or file system  of the storage operating system . The configuration thread performs the proposed operation and loads pre-committed state changes as result data into a per transaction buffer of memory . The result data are copied into a configuration response buffer of the memory and the proposed operation is aborted, resulting in releasing of the pre-committed state.","For example, in the case of the vol create command, the configuration client  passes the following pairs of parameters to the configuration thread :\n\n","wherein the commit parameter is an indication of the -n option. All of these parameters are \u201cmarshaled\u201d (assembled) into a message and passed to the configuration thread. The configuration thread then processes the parameters by, e.g., selecting 6 spare disks in accordance with criteria of a disk selection\/placement policy.","Once processing of the parameters is completed, the configuration thread  returns a proposed configuration change response to the configuration client  instead of committing the operation. The proposed configuration change may include the names of the requested disks or, possibly, a failure indication if the selection\/placement criteria cannot be met. For example, if the RAID subsystem can only select five disks instead of six disks, a failure indication (rather than a proposed configuration change) may be returned to the client for display to the user. This aspect of the present invention provides the user with more information and flexibility when determining an outcome of an operation without actually committing that operation to the system.","Another example of a CLI configuration command used to add disks to a volume is the vol add command, the format of which is illustratively:\n\n","wherein foo specifies the name of the existing volume and 1 indicates the number of disks that are added to the existing volume. Therefore, the vol add command adds one disk to the existing volume foo.","In general, once a disk is added to a volume, there is no easy way to remove (delete) that disk. A typical solution is to copy the data onto a smaller volume (minus the particular disk) and then destroy the old volume. Clearly, this is a time and resource consuming process. Use of the novel -n option gives a user an indication as to which disk would be used\/selected by the RAID subsystem when adding a disk to the existing volume. If the selected disk is unacceptable to the user, then the user can utilize the vol add command with, e.g., the -d option specifying the particular disk to be added to the volume. When utilizing the -d option, the user is substituting his knowledge for an elaborate disk selection\/placement policy executed by the RAID subsystem of the storage system.","Another example of a CLI command that supports the -n option is a command directed to creating a plex. Creation of a plex denotes that it is desirable to create a mirrored volume from an existing unmirrored volume. The format of the CLI command directed to creating a plex is:\n\n","wherein foo denotes the name of the existing unmirrored volume. With reference to configuration tree , the vol mirror foo command creates a second plex object and a second RAID group object, and then selects two disks for placement into that second RAID group. Note that the number of disks does not have to be specified in the vol mirror command because that parameter is dictated by the number of disks that are in the first plex of the unmirrored volume. The vol mirror command is thus another example of a spare disk selection command that accepts the -n option, along with the -d option specifying a list of desired disks. In this respect, the vol mirror CLI command is similar to the vol create CLI command.","Advantageously, the -n option saves time and resources if unexpected results are returned in response to a particular CLI command. That is, if the user did not specify the -n option as part of, e.g., the vol create CLI command and thereafter does not agree with the disks chosen by the RAID subsystem, a relatively time and resource consuming process is needed to \u201cback-out\u201d from this configuration change. Specifically, the volume would have to be \u201cdestroyed\u201d and then recreated using, e.g., the -d option specifying the exact disks desired. Once the volume is destroyed, those disks in that volume become non-zeroed spares that have to be zeroed in accordance with a time consuming zeroing process.",{"@attributes":{"id":"p-0068","num":"0074"},"figref":"FIG. 6","b":["600","602","604","606","608","610","612"]},"Here it should be noted that there is a discrete period of time between return of the response and issuance of a subsequent command; it is possible that the proposed configuration change may be altered because of intervening events during that time period. Assuming nothing changes in the interim, the same result is achieved; yet as noted above, the possibility of the same result occurring is not guaranteed. If he decided not to increase the likelihood of committing the proposed results, the user reissues the CLI command without the -n option at Step .","However, to increase the likelihood that the same results are achieved or, alternatively, if the proposed configuration response is not acceptable (Step ), the user reissues the CLI command with the -d option at Step , wherein the -d option enables the user to specify either the proposed configuration changes included in the response or his own details of the configuration management command. For example, if the vol create foo 6 -n CLI command results in a response that proposes a set of disks acceptable to the user, then the user may issue a vol create foo 6 -d CLI command that specifies those disk names returned in the proposed configuration response. As noted, this feature of the invention saves time and resources if an unexpected result is instituted by the RAID subsystem. In any event, the configuration client converts the command to a configuration management operation in Step  and passes the operation to the configuration thread at Step . In Step , the configuration thread processes the operation and commits the result at Step . The sequence then ends at Step .","While there has been shown and described an illustrative embodiment for forecasting the behavior of a RAID subsystem when processing a proposed configuration management request that modifies the topology or attributes of a storage array managed by the subsystem, it is to be understood that various other adaptations and modifications may be made within the spirit and scope of the invention. For example, although the illustrative embodiment has described specific CLI commands that may be used with the -n option, it is understood that the novel -n option may be used with other CLI commands supported by the storage system. Moreover, the configuration client  of the UI may have additional functionality to that of a CLI command text parser; that is, the configuration client may be embodied as a graphical user interface (GUI) that displays a proposed configuration change in graphical (rather than textual) form.","A preferred embodiment of the invention has been described herein with reference to a file server having a storage operating system with a file system layer and a RAID subsystem (among other components), which manages file semantics in order to access data organized in files. It should be understood, however, that the invention can be practiced in any system or device that forecasts the behavior of a RAID subsystem, particularly in light of configuration management changes. One type of system or device in which the invention can be embodied is designed to perform a data storage function, and if so, may perform data-related operations, e.g., in response to data access requests. Such requests may use file-based and\/or block-based semantics, depending on the implementation and, correspondingly, the system or device may organize data in files or in another manner. Moreover, such systems and devices may or may not incorporate features and functions described herein, such as, for example, a file system layer or a RAID subsystem, or may combine or otherwise modify their operation, without departing from the principles of the invention. Finally, the invention has been described herein using nomenclature such as \u201c-n option\u201d which may appear to be specific to implementations of the invention providing RAID functionality; however, the invention in its broader sense is not so limited.","The foregoing description has been directed to specific embodiments of this invention. It will be apparent, however, that other variations and modifications may be made to the described embodiments, with the attainment of some or all of their advantages. For instance, it is expressly contemplated that the teachings of this invention can be implemented as software, including a computer-readable medium having program instructions executing on a computer, hardware, firmware, or a combination thereof. In addition, it is understood that the data structures described herein can include additional information while remaining within the scope of the present invention. Accordingly this description is to be taken only by way of example and not to otherwise limit the scope of the invention. Therefore, it is the object of the appended claims to cover all such variations and modifications as come within the true spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The above and further advantages of the invention may be better understood by referring to the following description in conjunction with the accompanying drawings in which like reference numerals indicate identical or functionally similar elements:",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
