---
title: Resource management in a multicore architecture
abstract: A method and apparatus for resource management in a multicore processor is disclosed. A system management controller () provides omnipresent scheduling, synchronization, load balancing, and power and memory management services to each processing resource () within in a multicore processor (), via a plurality of system management clients () implemented in hardware or software. The controller () allocates the tasks executing in each processing resource () by means of interrupt control signals, which interact directly with the system management clients (), enabling processing resources () to autonomously create, execute and distribute tasks around a parallel system architecture whilst monitoring and policing the use of shared system resources ().
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08533716&OS=08533716&RS=08533716
owner: Fujitsu Semiconductor Limited
number: 08533716
owner_city: Kanagawa
owner_country: JP
publication_date: 20040331
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["1. Field of the Invention","This invention relates to a method and apparatus for resource management in a multicore architecture.","2. Description of the Related Art","Today, semiconductor devices incorporating complex heterogeneous multicore architectures are put to use in a wide variety of systems and devices, from the ubiquitous desktop computer, to the latest in modern electronic devices, such as mobile telephones, Personal Digital Assistants and high speed telecoms or network switching equipment.","Whatever the intended use of any computer processor, the processor manufacturers continue to strive to increase the performance of current processors, whilst maintaining or reducing their unit \u201ccost\u201d.","The \u201ccost\u201d of a processor can be measured using a variety of parameters. Although in many cases, the cost will be a purely financial one, in many applications, especially in the embedded processor market, the cost calculation also includes ancillary considerations such as power consumption, cooling requirements, efficiency and time to bring to market.","The absolute capacity for any processor to perform useful functions may be characterised in terms of the MIPS (millions of instruction per second) ratio achievable, and thus the \u201cprice-performance\u201d ratio of any processor may be characterised in terms of the MIPS\/mm, MIPS\/$, or MIPS\/mW, for example.","In practice however, not all instructions achieve the same amount of useful work, therefore \u201cpure\u201d MIPS ratings are not easily comparable. Thus, while a Digital Signal Processor (DSP) is well suited to solving the mathematically intensive processing near the wireless interface of a mobile phone, it is very inefficient at running the web browser that runs on the phone's screen. Effectively this means that processors can be more usefully classified in terms of \u201capplication available\u201d price-performance.","Furthermore, an additional reduction in the effective performance can be caused by the inefficiency of the programming, i.e. software, tools that must be used to control and customise the processor to implement a particular application. The final level of performance that can be extracted from a processor for a particular application can thus be viewed as the level of usable or \u201cachievable application available\u201d price-performance.","In the semiconductor companies' drive to improve processor application available price-performance, a new class of processor, the multicore device, has been developed. Multicore devices are highly integrated processors that are built from a variety of elements (cores), each of which may be highly specialised, in order to provide the maximum level of useful price performance for a particular aspect of an application that can be executed by the processor. Such devices may be \u201cheterogeneous\u201d, i.e. incorporating multiple, dissimilar cores, or \u201chomogenous\u201d, i.e. incorporating multiple similar cores.","Most multicore devices may also be classified as System on Chip (SoC) devices, since the integration includes not only the multiple processing cores, but also the memory, IO and other system \u201ccores\u201d that are required to handle most (if not all) of the hardware requirements for any particular product. Although not all SoC devices have multiple processing cores, the terms multiple core and SoC are often interchanged. A good example of a multicore SoC can be found in many mobile phones, where one will find a single processor containing one or more DSPs to run the wireless interface, and a general purpose processor to run the user applications on the phone.","The emergence of multicore devices has been enabled by Moore's Law, which states that the number of transistors that can be fitted into any given area of silicon will double every 18 months due to improvements in the manufacturing process. Moore's Law therefore allows for more individual transistors to be fitted into any given area on the silicon die, making it technically and economically viable to manufacture ever more complex devices on a single piece of silicon. Equally, by reducing the size of the transistors, they are capable of being switched at ever higher speeds.","Historically, Moore's Law was used to manufacture a new generation of processors at smaller sizes which were faster or more cost effective in terms of silicon used, without any major changes to the underlying architecture (i.e. the improvements were improvements in manufacturing process and the device's physical micro-architecture rather than of device's logical macro-architecture).","Effectively, the trend towards multicore\/SoC processors can be seen as a macro-architectural shift to higher levels of integration which first started with the introduction of IO (communications) functionality onto the silicon die itself; now the IO the memory, and the functionality of multiple processing units, DSPs and co-processors can be integrated onto the same silicon die. These processors should reduce the manufacturing costs of end products by providing the lowest cost, highest performing processor for a particular class of application. Also, by integrating most of the system components onto a single processor, the part count can be reduced, therefore increasing reliability and lowering power consumption. A key problem is how the use of the underlying hardware in such multicore devices can be optimised, in order to achieve the highest possible \u201capplication available\u201d price-performance.","There are many ways in which processor and system designers may leverage parallelism within the application software (application level parallelism), and within the instruction stream (instruction level parallelism). The various manifestations differ in where the parallelism is managed and whether it is managed when the system is executing\/at \u201crun-time\u201d (dynamic systems), or when the application software is being compiled\/at compile time (static systems). In practice, the partition between dynamic and static systems and hardware intensive and software intensive solutions is not distinct and techniques from one discipline are often borrowed by the other.","At the level of the individual processing core, the concept of multiple issue processors, or machines which operate on many instructions from a single stream in parallel, is well established in the art. They come in two basic types; superscalar and Very Long Instruction Word (VLIW) processors. Superscalar processors issue varying numbers of instructions per clock cycle identified either at run-time (dynamically scheduled) or at compile time (statically scheduled). VLIW processors issue a fixed number of instructions, forming a very long instruction word, as defined by the compiler. Typically, the programmer is completely unaware of this process as the programming model of the system is a standard, single processor abstraction.","Super-threading and Hyper-threading are both technologies which emulate multiple processors by multiplexing multiple threads of execution amongst multiple virtual processors. Typically, these virtual processors share certain resources which, statistically, would not be used by a single thread all of the time. Super and Hyper-threading architectures appear as multiple independent processors and therefore require a level of application parallelism to be present in order to work efficiently. Typically hardware limitations in the processor core limit the number of threads which may be supported to substantially less than 100.","Furthermore, several system-architectural options exist for the exploitation of the inherent parallelism in many applications. Multiple Instruction Multiple Data (MIMD) machines, where each processor executes its own instructions and operates on its own set of data whilst cooperating with its peers through some shared resource (for example memory and\/or interconnect), have become popular due their ability to address a wide variety of applications.","As performance demands increase, embedded systems are increasingly making use of multicore MIMD architectures, using multiple dissimilar or similar processing resources, to deliver the required level of silicon efficiency. Typically, these are a class of MIMD machine called centralised shared memory architectures, i.e. a single address space (or a proportion thereof) is shared amongst the multiple processing resources, although more application specific hybrid architectures are also commonly found.","Although each processing resource of a MIMD array may exploit Instruction Level Parallelism (ILP), MIMD machines may also take advantage of Thread Level Parallelism (TLP) to realise the potential performance of the underlying hardware. In contrast to ILP, which is identified at run-time (by specific hardware) or compile-time (by optimising compile tools), TLP is defined within high-level programming software at application design time.","Threading is a concept that has been used within the software community for many years, as a high level expression of parallelism. A thread defines an autonomous package of work containing an execution state, instruction stream and dataset, which, by definition, may execute concurrently with other threads. The complexity of the instruction stream is unimportant. A thread may describe anything from a simple transfer of data to a complex mathematical transform.","Traditionally, operating systems have assisted in the provision of system management, including thread allocation functions, which enable an application to be run on a certain configuration of a multicore architecture without the software engineer requiring detailed understanding of the underlying device architecture. However, existing software techniques for thread management within a uni-core device cannot be readily adapted to multicore architectures in a consistent way. Solutions to date have been proprietary, requiring bespoke solutions on a design by design basis and have typically compromised performance and scalability.","Historically, in the case of heterogeneous multi-core systems (that is, systems having broadly dissimilar processing resources), many varying approaches have been employed to enable the disparate processing resources to work together. However, broadly these may be split into two categories, \u201cproxy host\u201d and \u201cco-operative\u201d (also known as \u201cpeer to peer\u201d). In the former case, a designated general purpose host processor (which in a bus-based system is often referred to as a CPU) governs the system overall, brokering tasks across the system and synchronising access to resources such as memory and devices. Such system supervision is typically operated in an operating system kernel and competes for slices of time with the system application and the processing of asynchronous events on the host processor. In other words, this general purpose processor must act as a centralised proxy thread manager for all the processing resources on the multicore device, as well as act as a key application processor.","When used in this configuration, the general processor must maintain queues of threads ready for execution for each processing resource, depending on a predefined scheduling policy, i.e their priority (i.e. dispatch or ready queues), as well as queues of threads awaiting some event, or the return of another thread's results, before they can themselves start to be executed (i.e. pending and timing queues). These are in addition to other system overheads, such as processor configuration prior to thread execution.","Whenever the general purpose processor diverts its processing time from a thread it is currently executing, to the administration of the system (including thread management), for example, as a result of an interrupt issued due to the completion of a thread (and therefore the freeing up of the processing resource that has just completed that thread), the general processor must make a context change.","A context change involves storing the current progress of the thread being halted into memory, fetching instructions relevant to the administration routines for the servicing of the other threads\/processing resources, then carrying out those instructions, including any configuration requirements. A further context change must be carried out to return to the original, halted thread. These context changes are typically executed on receipt of an interrupt, and in embedded systems, these interrupts are often both frequent and asynchronous to the application code executing on the general purpose processor. Therefore, the system as a whole exhibits significant degradation of performance. Context switches also have a negative impact upon the effectiveness of host processor caches (the so-called \u201ccold-cache\u201d effect)","In the case of a co-operative system, each processing resource runs a separate instance of an operating system, part of which enables inter-resource communications. Such an arrangement accordingly has a relatively rigid architectural partitioning, as a result of a specific routing of interrupts between peers. Although this type of system offers the primitives required to produce an application, the performance of the implementation still suffers from frequent context switches associated with operating system kernel activity.","In summary, current designs and methodologies for the realisation of system management in traditional architectures (general purpose processors, software executives etc.) are inappropriate for the system and thread management of complex heterogeneous multi-core architectures. Indeed the general purpose processor is poorly optimised at both the micro (instruction set) and a macro (caches, register file management) architectural level. Although the interconnect of a multicore processor provides a physical medium for interoperation between the separate processing resources, there is no system wide task management and communication layer shared amongst all the processing resources enabling a coherent approach to system management. In the worst case this may lead to a distinct problem associated with every possible communication channel between every processing resource, each of which must be traditionally separately solved in software on an ad-hoc basis.","Thus, there is a need for an efficient method of system management of these very complex multicore architectures. Software abstraction alone cannot provide the requisite level of performance of complex multicore architectures.","According to a first aspect of the present invention, there is provided a resource management and task allocation controller for a multicore processor as defined in claim .","In a preferred embodiment, the controller of claim  is dedicated to resource management and task allocation and does not provide further processing resources.","By providing a separate resource management and task allocation controller, the invention provides an improved task allocation and management system for a multicore processor, enabling the more efficient allocation of tasks between the available processing resources. The controller abstracts the elements of system management and exception handling into a dedicated, efficient, hard-coded embodiment.","Embodiments of the invention employ controller clients along with the controller, rather than enforcing the role of a \u201cproxy agent\u201d. The controller clients may be implemented in hardware or software. Such an arrangement efficiently masters the \u201crun-time\u201d activities of the underlying system. In particular, the controller continually (\u201cgreedily\u201d) maintains the correctness of the system thread states and scheduling decisions based upon the range of pre-defined allocation parameters.","The architecture of preferred embodiments accordingly provides significant benefits in terms of the division of work between the constituent components and the autonomy of individual processing resources, regardless of complexity. All processing resources become slave devices, which are by default \u201clazy\u201d, i.e. they wait to be explicitly instructed by the resource management and task allocation controller to perform tasks, via, in preferred embodiments, dedicated interrupts.","In systems employing the controller of the present invention, all asynchronous events instigated from outside the architecture, either directly through a pin or indirectly through external manipulation of one of the processing resources (i.e. an IO device), are in preference routed to the controller, where they are compared using a set of scheduling policies, configured at \u201cboot-time\u201d, with the currently executing task on the target processing resource. The processing resource is only interrupted if an interrupt service thread (IST) associated with the external event presides over the currently executing transaction (thread or task), thereby obviating unnecessary context switching in any processing resource as was a problem in the art. Furthermore, the controller clients of preferred embodiments enable processing resources of arbitrary complexity to perform basic system management operations on shared resources and the controller itself (create thread, issue synchronisation primitive, delete thread, memory copy etc), avoiding the need for an instruction set based machine to execute these tasks by proxy.","In a further aspect of the invention, there is provided a multicore processor comprising such a controller.","The invention also extends to a method of controlling and allocating resources in a multicore processor as defined in claim .","Further advantages and features are defined in the dependent claims appended hereto.",{"@attributes":{"id":"p-0065","num":"0064"},"figref":"FIG. 1","b":["10","10","150","150","140","160","140","150"]},"The system framework also comprises a centralised task allocation and management system  in accordance with an embodiment of the present invention. The centralised task allocation and management system  includes a system management controller  and a dedicated tightly coupled memory interface , connected to a dedicated tightly coupled memory . Each processing resource  is able to access the controller  via an interconnect . It is to be understood that no particular interconnection strategy (that is, the arrangement by which the controller  communicates with each processing resource  and vice versa, and the arrangement by which each processing resource  communicates with the system memory ) is required in the implementation of the arrangement of ; in particular, point to point links, a central system bus or even a pipelined architecture may equally be employed, save only that each of the processing resources should be able to communicate directly or indirectly (i.e. via other processing resources or otherwise) with the controller .",{"@attributes":{"id":"p-0067","num":"0066"},"figref":["FIG. 2","FIG. 1","FIG. 2","FIG. 2"],"b":["150","160","150","160","130","100","110","160","150","130","140","140"]},"As seen in , each of the multiple processing resources  has an associated system management controller client  configured to receive control information from the central controller , and to administer the processing resources  in accordance with the control information received. The function and purpose of the controller clients  is described in more detail in connection with  below. Each processing resource also has an associated interconnect agent  for communication with the controller  via the system interconnect . The interconnect agent  provides a generic interface to the controller client , which is independent of the underlying interconnect protocol in use on the system interconnect , i.e., it provides protocol translation between the communication protocols in use on the system interconnect  and the communication protocol in use by the controller client . Due to the use of an interconnect agent , the controller clients  of embodiments of the present invention may be used with any system interconnect protocol currently available.","The multicore processor, as a whole, is configured to execute a target application, which may be broken down into a number of individual tasks, called threads. Each processing resource  is allocated a suitable thread by the controller , according to a number of parameters, including, but not limited to, the priority of the thread in question, the availability of each processing resource  and the suitability of a particular processing resource to the execution of a particular thread.","This will again be described in more detail below.","It is however to be understood that the addition of the system management controller  and its dedicated memory  do not otherwise require a redesign of the layout of the processor .","In one embodiment, system management controller  comprises control logic to allocate executable transactions within the multicore processor to one of the processor elements in accordance with one of a range of pre-defined allocation parameters. In one exemplary embodiment, at least one of the processor elements is a master processor element. The control logic is in communication with each of the plurality of interconnected processor elements via a plurality of controller clients. Each of the controller clients is associated with a corresponding interconnected processor element and each controller client is configured to control communication between each associated interconnected processing element and the rest of the multicore processor. The control logic may be separate from a master processor element.","Each executable transaction to be allocated can include threads, each of which form part of an application being executed upon the multicore processor. In one embodiment, at least some of the threads are independent threads capable of execution independently of other events, and at least some of the threads are dependent threads, whose execution is dependent upon the existence of a predetermined event.","In one embodiment, the control logic further comprises an executable transaction manager and a dedicated memory manager. The dedicated memory manager controls access by the executable transaction manager to a dedicated memory. The executable transaction manager can further comprise an executable transaction input manager, configured to maintain an indication of available memory within the dedicated memory. The executable transaction input manager can be configured to maintain a list of available memory locations within the dedicated memory. The executable transaction input manager can maintain the indication of available memory as a result of updated instructions from the dedicated memory manager. The control logic can further comprise a time manager configured to provide timer functions to the executable transaction manager.","In another embodiment, the executable transaction manager further comprises an executable transaction synchronisation manager, configured to maintain at least one pending queue list within the dedicated memory, indicative of dependent threads awaiting the occurrence of a predetermined event, and at least one timer queue list within the dedicated memory, indicative of threads awaiting a timing event.","In one embodiment, the executable transaction manager further comprises an executable transaction output manager configured to maintain a plurality of dispatch queue structures within the dedicated memory, indicative of the threads awaiting execution on an associated one of the processor elements, and to maintain a plurality of ready queue structures within the dedicated memory, indicative of threads awaiting allocation to a one of the processor elements for execution there.","In another embodiment, the executable transaction manager further comprises an executable transaction schedule manager, configured to provide and maintain scheduling decisions for prioritising the dispatch of threads from within the ready queues to the dispatch queue for each processor element.","In one embodiment, the control logic further comprises a system interface manager, in communication with the executable transaction manager, and configured to manage access by the controller to the multicore processor. The system interface manager can be arranged to provide interconnect interfacing and configuration and run-time access to the executable transaction manager.","In another embodiment, the control logic further comprises a system interrupt manager, for converting system interrupts in a first format employed within the multicore processor, into controller interrupts in a second, different format, which second format is understandable by the executable transaction manager.","One specific arrangement is shown in  which shows a typical System on Chip (SoC) architecture, in block diagram form, and which illustrates the various processing resources that might be placed under the resource management of the controller  in a practical application. It will be noted that the processing resources may in particular be of relatively general capability, such as a DSP, or may of relatively limited functionality, such as a peripheral IO.","System Management Controller Interface Groups",{"@attributes":{"id":"p-0081","num":"0080"},"figref":"FIG. 4","b":["130","200","250","130"]},"The system control group  comprises the two system input signals required to ensure the correct operation of the system management controller . The two system inputs comprise a CLK input, which is connected to the system clock, and a RST input. All output signals from the system management controller  are synchronous to the system clock and all input signals to the system management controller  are sampled using this clock. The RST input is a synchronous reset signal, for resetting the system management controller .","The external interrupt group  consists of a group of synchronous external interrupts sourced from outside the system management system. These signals must be synchronised to CLK prior to their attachment to the system management controller  periphery. Signals in the external interrupt group  may be driven from, for example, input interfaces with the outside world or directly from outside the multicore processor via pins. The number of external interrupt inputs is defined during the multicore processor  design phase.","The internal control group  consists of a group of two synchronous interrupts for each controller client  and its associated processing resource . Therefore the number of groups of signals will typically correspond with the number of processing resources  within the system and will be defined during the multicore processor  design phase. The internal interrupt signals include:\n\n","The tightly coupled memory interface group  interfaces the system management controller  to its own dedicated tightly coupled memory resource .  shows a typical structure of the dedicated tightly coupled memory . The width of the address path and the datapath are defined during the multicore processor  design phase. The dedicated tightly coupled memory interface includes a memory address bus , a memory read data bus , a memory write data bus  and write  and read  enable signals.","The attached memory is assumed to be a synchronous SRAM device. The dedicated tightly coupled memory  contains an integer number of controller memory elements , as defined during the multicore processor  design phase, according to the needs of the target application. In the currently preferred embodiment, each controller memory element  consumes 256 bits of memory space. Again in the currently preferred embodiment, the controller supports a maximum of 65536 controller memory elements (i.e. a 16 Mb memory). Although queue descriptors, as described later, do consume controller memory elements , in a typical system the number of controller memory elements  required would be dominated by thread support requirements. For example, a system capable of supporting  threads simultaneously within the system management controller  would require approximately 128 kb of attached memory.","The interconnect interface group  of  conforms to the chosen interconnect protocol used in the multicore processor , and the interconnect agent , which is defined during the multicore processor design phase.","Controller Subblock Description and Functions",{"@attributes":{"id":"p-0088","num":"0089"},"figref":"FIG. 6","b":["130","130"],"ul":{"@attributes":{"id":"ul0003","list-style":"none"},"li":["1. A Thread Input Manager (TSIM) , configured to maintain a list of free controller memory elements  within the dedicated tightly coupled memory , and to oversee controller memory element  recovery.","2. A Thread Synchronisation Manager (TSPM) , configured to maintain Pending lists and a timer queue within the dedicated tightly coupled memory  and to perform synchronisation between threads, and to perform promotion of threads to Ready queue structures within the dedicated tightly coupled memory , as required. The Thread Synchronisation manager  maintains the integrity of the pending and timer queue structures via insertion and extraction of pending thread descriptors within the dedicated tightly coupled memory .","3. A Thread Output Manager (TSOM) , configured to maintain Ready queue structures within the dedicated tightly coupled memory , and Dispatch queues for each processing resource  within the dedicated tightly coupled memory . The Thread Output Manager (TSOM)  is further configured to perform processing resource  power management, and to generate the interrupts  sent to the controller clients . Maintenance of the integrity of the ready queue structures is performed by insertion and extraction of thread descriptors held in controller memory elements , within the dedicated tightly coupled memory .","4. A Thread Schedule Manager (TSSM) , configured to provide scheduling decisions for each processing resource  within the ready queue structures located within the dedicated tightly coupled memory ."]}},"Additionally a number of secondary processing subblocks provide support functions:\n\n","There now follows a detailed description of the interaction of the above primary and secondary processing subblocks within the system management controller .","Each sub-block presents a set of functions to other sub-blocks, enabling each to instruct its peers to execute manipulations on their respective maintained structures within the dedicated tightly coupled memory . Functions are called by a particular subblock, on receipt of a similar command received at a controller software Application Programming Interface (API).","Thread Input Manager Functions:","The thread input manager  provides three public functions to other sub-blocks within the system management controller .","The FreeListStatus function returns the head pointer and number of elements within the controller memory element  free list. The free list is a list of the controller memory elements  that are currently unused. This function can only be called by the system interface , on receipt of a similar command at the controller  software API","The PushFreelndex function is used to push a liberated controller memory element  index back onto the free list. This function can only be called by either the system interface , on receipt of a similar command at the controller  software API, or the thread Schedule Manager .","The PopFreelndex function is used to pop a free controller memory element  index from the free list. It is typically called from within the API call service routine within the system interface .","Thread Synchronisation Manager Functions:","The Thread Synchronisation Manager  provides seven public functions to the other sub-blocks within the system management controller .","The following five functions can only be called by the system interface , in response to similar commands received by the controller  software API.","The PushPendingDescriptor function is used during the boot process to add a pending queue descriptor to the list of pending queue descriptors.","The PushThread function is used during runtime to add a dependant thread to a given pending queue.","The TimerStatus function returns the head pointer and number of elements within the timer queue.","The SetPendingStatus function sets the status of the pending queue descriptor list.","The GetPendingStatus function returns the head pointer and number of elements within the pending descriptor queue.","The SyncEvent function is used to issue a synchronisation primitive to a given pending queue. This function is only called by the thread interrupt manager .","The TimeEvent function is used to issue a timer based synchronisation primitive to the timer queue. This function is only called by the time manager .","Thread Output Manager Functions:","The Thread Output Manager  provides five public functions to the other sub-blocks within the system management controller .","The Push function places a thread descriptor within the ready queue structure. The method may be called with high priority to expedite processing speed (for example, to handle interrupts). Where threads are independent (immediately ready) the call will be made from the system interface , where the thread descriptor originally had dependencies the call is made from the thread synchronisation manager .","The following three functions can only be called by the system interface , in response to the receipt of a similar command at the controller  software API","The GetDispatchQueueStatus function returns the head pointer and number of elements within the dispatch queue list.","The SetDispatchQueueStatus function sets the head pointer and number of elements within the dispatch queue list.","The DispatchQueuePop function pops a thread descriptor from a the head of a dispatch queue.","The DispatchWorkQueuePush function pushes a dispatch queue onto the thread output manager  work queue. This function can only be called by the thread schedule manager , which uses this function to inform the output manager  of changes required within the dispatch queue as a result of schedule updates.","Thread Schedule Manager Functions:","The Thread Schedule Manager  provides two public functions to the Thread Output Manager , located within the system management controller .","The PushPushWorkEvent function is called by the thread output manager , immediately after it adds a thread descriptor to a ready queue structure.","The PushPopWorkEvent function is called by the thread output manager , immediately after it removes a thread descriptor from a ready queue structure.","Controller Client","As described earlier, the term processing resource  is applied to any resource that may execute an instruction, regardless of how rudimentary the instruction may be. Therefore resources that have a fixed function, such as an input\/output module, are also included. Depending on the type of processing resource , the connection between the system interconnect  and the processing resource , via the system management core client  may be either uni-directional or bi-directional.",{"@attributes":{"id":"p-0116","num":"0125"},"figref":"FIG. 7","b":["120","130"]},"On appropriate processing resources , for example general purpose processors or Digital Signal Processors, the controller client  will typically be implemented in software. However, where the processing resource  is of limited function, the controller client  will require a hardware component.","When a hardware component is used, the controller client  still interfaces to the processing resource  using the same interface. That is to say, the controller client presents an identical interface to the interconnect agent  as that of the processing resource  to the controller client. In some cases, it is appropriate to treat the data path into the processing resource as distinct from the data path out of the processing resource, for example in the case of an Input\/Output device.","In addition to the main interface, the controller client  also provides out of band interfaces for use as outputs for run-time and debug events. Where a software controller client  is used, these are provided using standard interrupts, calling appropriate service routines.","Controller Client Mode of Operation:","Each controller client  is fully interrupt driven. Upon receipt of an internal interrupt from the controller , the controller client  pops the thread descriptor from the head of the dispatch queue associated with that particular processing resource , which is held in the dedicated tightly coupled memory . The unique reference within the thread descriptor is then used to read further thread control information, the Thread Control Block (TCB), from the main memory resource . The information contained within the TCB may be any of:\n\n","There are three distinct phases of operation of the controller client :\n\n","As mentioned previously, the controller client  may be implemented in software. In this case some of the functionality of the controller client , for example shared resource usage policing, will typically make use of existing hardware components which may already be present in the processing resource  hardware (for example, a memory management unit (MMU)).","Consequently, the software controller client  architecture and implementation is processing resource  specific.","Hardware controller clients  may also have specialist requirements according to the idiosyncrasies of the associated processing resource . The following section describes a generic architecture which will be suitable in the majority of cases.","General Example of a Hardware Controller Client","The basic structure of the hardware controller client  is shown in . At the functional heart of the design is the controller client Finite State Machine (FSM) . This Finite State Machine (FSM)  may be active during all three phases. The controller client FSM  is activated by an interrupt  from the controller .","Firstly the controller client FSM  masters the system interconnect  to read the TCB from the shared memory resource , which contains a reference to its own instructions. During the configuration phase the controller client  may master the processing resource interface, interpreting configuration commands and translating them into write cycles issued to the processing resource . Furthermore, the controller client  configures its own resource policing. The manner in which the transition from the configuration state to the executing state is processing resource  specific, but may be marked by an explicit execute primitive or merely an entry into a data transferral state.","From a controller client  perspective the simplest architecture has an identical interface protocol on both the processing resource  and the system side. In this case, during the execution phase, processing resource  read and write cycles are simply mapped across to the system interface with checking where appropriate.","The simplest controller client  implementation would require a FIFO style interface in both the system to processing resource  and processing resource to system  paths. During the execution phase of a controller client  of this nature, data can be presented to a processing resource  by message or streaming modes. Message mode, where the entire dataset is accumulated locally within the controller client  prior to processing, engenders a more coarse grain blocky interconnect behaviour which may facilitate more complex interconnect arbiters. Streaming mode, where data is streamed directly from the system memory into the processing resource , presents a more silicon efficient solution requiring more careful consideration of hand-shaking and exhibiting fine grained interconnect transactions and tight coupling to interconnect performance.","The transition from the execution to the completion phase may be inferred, by measuring the presentation of data to the processing resource , or explicitly signalled by the processing resource  itself. During the completion phase, the controller client  once again executes from the set of instructions provided by the original thread control block.","Note that, in some cases, it is appropriate to treat the datapath into the processing resource  (for example an input\/output device) and the path out of the processing resource  as distinct. In contrast it will be natural in some cases (for example, algorithmic accelerators such as DSPs) to couple the consumer and the producer of data within the same controller client  framework.","In order to provide a level of decoupling between the processing resource  and the other system resources, a number of additional facilities may also be provided by the controller client :\n\n","Instances of datatypes used within the system management controller  are divided into public (visible from and manipulated by the system at large) and private visibility (visible only within the system management controller  and manipulated only by the system management controller  sub-blocks). To ensure portability of the design across multiple end applications, all thread, queue and aggregated queue descriptors are stored within the dedicated tightly coupled memory  using a common base class, the controller memory element .","Controller Memory Elements","Each controller memory elements  may represent any of seven descriptor types:\n\n","These descriptors are described in greater detail in the following sections.","The various forms of the Controller Memory Elements , and their respective are shown in to ","Thread Representation","Where a descriptor requires initialisation or run-time manipulation, operations are done through the controller  API. The centralised task allocation and management system is designed to ensure that real-time interaction is suitable\/simplistic enough for a hardware implementation.",{"@attributes":{"id":"p-0137","num":"0163"},"figref":["FIG. 10","FIG. 10","FIG. 10"],"b":["130","150","140","130","140","125","145","135"]},"However, according to the application and\/or target processing resource  the complexity of the controller client control block  may vary. In particular, note that further levels of indirection may be included which, given appropriate \u201ccontrol\u201d instruction code and corresponding \u201cdatapath\u201d code, may enable disparate processing resources  to execute the same functions on the same data under certain circumstances.",{"@attributes":{"id":"p-0139","num":"0165"},"figref":["FIG. 11","FIG. 11"],"b":["150","150","125","120","145","145","125"],"i":["a ","b","a ","b"]},"This feature may be useful, for example, in conjunction with the power-down feature of certain processing resources. In the case where the optimal processor for a given task is powered down, it may be desirable for a sub-optimal processor to execute the task rather than incur a costly reboot cycle.","Furthermore, under exceptional loads it may enable a lightly loaded general purpose processor, for example, to relieve the burden on a heavily loaded DSP.","When a processing resource  is ready to deal with a thread, it is popped from the appropriate dispatch queue uniquely associated with that processing resource . The pop operation returns an object containing pReference, the scheduler metrics that resulted in the scheduling event, and a set of flags including an indication of whether the thread became Ready due to a timeout or a synchronisation primitive. The controller memory element  used for the thread descriptor is automatically returned to the free list for use by future thread descriptors.","Public Objects","This section describes the objects visible to the system through the controller  API. Typically these objects are manipulated by the centralised task allocation and management system, comprising the controller  and the clients  and their associated processing resources , at runtime.","The runtime controller  API enables the application to introduce new threads, introduce new dynamic scheduler elements, issue synchronisation primitives, pop scheduled threads, push preempted threads or remove threads.",{"@attributes":{"id":"p-0145","num":"0171"},"figref":"FIG. 12","b":"130"},"Thread Primitives","The format of a thread primitive is shown in and . According to its dependencies, a thread descriptor may be placed in the pending queue structure or directly into the Ready queue structure. If a thread is to be placed within the pending queue structure the application must define the dependencies of the thread. Dependence upon an external event manifests itself as a dependency reference. The controller  does not interpret this dependency reference; it is maintained for comparison to the incoming synchronisation primitives to determine when to transition the thread descriptor into the Ready queue structure.","For dependant threads a timeout may be specified, in conjunction with a null dependency reference this facility may be used as a thread based hardware-timing facility. Regardless of the dependency reference, timeouts cause the thread to be scheduled at a particular time.","Threads are tagged according to the synchronisation event (timer or primitive) that causes them to be promoted to the Ready queue structure.","Synchronisation Primitives","Synchronisation primitives interface with the pending queues and may cause the transition of one or more thread descriptors from the pending queue structure to the Ready queue structure.","Each synchronisation primitive contains a unique reference which is compared with the dependency reference stored within each thread descriptor in the identified pending queue. The comparison continues in the order of priority identified by the thread primitives.","According to its type, a synchronisation may wake either the highest priority matching thread descriptor or all matching thread descriptors within a pending queue. Furthermore, a special broadcast primitive wakes all matching thread descriptors within all pending queues.","Interrupt Processing","An Interrupt Service Thread (IST) methodology provides a valuable means of minimising the load imposed on processing resources  by asynchronous events. Furthermore, the accelerated real-time response in systems based on the present invention enables more widespread use of ISTs with minor system modifications.","The controller  automatically creates synchronisation primitives from external interrupt inputs  on the controller periphery. Preconfigured interrupt service thread descriptors within the pending queues will be promoted to a Ready queue structure upon reception of these interrupt synchronisation primitives.","The application will normally configure the thread descriptor associated with the external interrupt  at system initialisation and again within each execution of the associated interrupt service thread.","This facility effectively removes the need for any other dedicated interrupt servicing processing resource  within the system. Furthermore it processes these external interrupts  through the same priority structure and according to the same policies used for all processor tasks, precluding the need for context switches within processing resources already executing higher priority tasks. An arbitrary number of nested interrupts are supported by the ability to push the currently executing thread back onto the head of the dispatch queue using the normal pre-emption routines.","Timer based interrupts (watchdogs and periodic events) are handled in a similar manner. Time based tasks (periodic or one-shot) must be inserted onto the timer queue and are handled in a similar manner to threads with a timeout dependency. By design, this methodology precludes time based exceptions with no useful processing requirement.","Interrupt priority may be set such that interrupt routines are allowed to pre-empt currently executing tasks for fast response times.","Private Objects","Private objects are typically configured at boot-time, i.e. during system initialisation after a power down cycle. Processing resources  rarely interact directly with internal objects during runtime.","The internal objects are primarily queuing structures. The system management controller  administers four primary types of queue: Pending Queues, a Timer Queue, Ready Queues and Dispatch Queues.","Additional secondary queues exist within the system management controller  to facilitate internal operations. Movement of thread descriptors between queues takes place with pointer manipulations only. Thread descriptors are never copied.","Pending Queue Structure","Threads may be promoted from a pending queue structure to the ready queue structure through either a synchronisation event or a timer event. A thread may be sensitive to both, or just one of these classes of events. In the case where a thread is sensitive to both, the thread is present in both the pending and the timer queues.","Pending queues hold dependent threads awaiting a synchronisation event. Threads are removed from these structures through either a synchronisation primitive, from a processing resource , or by a timer event internally generated by the time manager . A configurable number of pending queues are available to the application programmer to support multiple contention scopes and interrupt service threads; elements within each pending queue must be processed according to their priority. There are two alternatives to processing according to priority, sort on insertion and sort on extraction. Sort on insertion defines a process by which the pending list is stored in strict priority order and new threads are inserted into a position within the list according to their priority. Sort on extraction makes an arbitrary choice of where to insert a new thread and performs priority based sorting of eligible thread descriptors after synchronisation. The preferred embodiment of the present invention employs the sort on insertion technique.",{"@attributes":{"id":"p-0163","num":"0189"},"figref":["FIG. 13","FIG. 14"]},"As previously stated, threads may be blocked awaiting synchronisation or timer events. Some threads will be exclusively awaiting a synchronisation event and similarly, some threads will be exclusively awaiting a timer event. In each case, the thread will only be present in a single queue. Each thread contains two sets of pointers, nominally associated with both the pending and timer queues. In these cases the provisioned timer queue and pending queue pointers respectively are spare. Skip lists may take advantage of these spare pointers\u2014for example, if the thread does not appear in the timer queue, these pointers may be reused to indicate a possible jump ahead in the pending queue. This enables an otherwise sequential search to jump blocks of thread descriptors whilst iteratively approaching a correct insertion point for a new dependant thread.","An alternative is a skip node descriptor and one example of this is shown in , along with its associated fields (). The skip node descriptor may periodically be inserted into the pending and timer queue structures according to a predefined metric. Skip node descriptors are inserted according to a defined maximum observed number of thread descriptors between skip node descriptors or participating thread descriptors. Skip node descriptors may simultaneously form a part of a pending queue and a timer queue skip list.","Each new dependant thread must be inserted according to its priority. The process will typically commence by traversing the skip list until the new thread's priority is higher than that of the skip list node. Thereafter, the search will continue, from that skip list node, on a thread descriptor by thread descriptor basis until the correct insertion point is found. This enables the otherwise linear search to skip blocks of pending threads when homing in on the correct insertion point for a new dependant thread.","Synchronisation Events Have Three Distinct Types:","Unicast: The synchronisation event triggers a state transition on the first (highest priority) appropriate dependant thread found in the specified pending queue.","Multicast: The synchronisation event triggers state transitions on all appropriate dependant threads in the specified pending queue.","Broadcast: The synchronisation event triggers state transitions on all appropriate dependant threads in all pending queues.","Pending queues are defined by pending queue descriptors, as shown in and . Pending queue descriptors are configured once during system initialisation and consume a single controller memory element . Pending queues only contain dependant thread descriptors and skip list nodes.","Timer Queue Structure","A single system wide timer queue is provided, which stores thread descriptors awaiting a timeout event.  shows an exemplary embodiment of a timer queue.","Skip lists are also used to expedite the insertion of threads into the timer queue structure as described above. However, in this case it is threads that only have temporal dependency (if any) which are used for skip lists.","The timer queue descriptor is stored within registers, enabling a concurrent compare to proceed between the head of the timer queue and the current time. This greatly reduces the impact of timer ticks on memory bandwidth.","Ready Queue Structures","Ready queue structures hold threads that are ready for execution. These threads were created with independent thread primitives, or they have received the synchronisation primitive upon which they were dependant. Synchronised threads have previously transitioned from a pending queue structure.","The Ready queue structures may contain scheduler node descriptors and independent and synchronised thread descriptors. The structure is largely defined during system initialisation although thread descriptors and dynamic scheduler tier descriptors are allowed to come and go in real time.","Ready queues may schedule threads to a specific processing resource , or a pool of processing resources . This enables load balancing across multiple processing resources  whilst maintaining the ability to target specific tasks at specific processing resources , for example hardware accelerators or IO devices.",{"@attributes":{"id":"p-0177","num":"0203"},"figref":"FIG. 16","b":["150","2","130","2","150","1","2"]},"Scheduler Tiers","Scheduler tiers define the hierarchy used to schedule thread descriptors. Each scheduler tier typically defines a scheduling algorithm, some metrics used to determine scheduling decisions and a list of child elements that may be further scheduler tiers or thread descriptors. There are three types of scheduler tier descriptor; root, static and dynamic. The format of scheduler tier memory elements is shown in and ","Root scheduler descriptors have a one-to-one mapping with dispatch queues. They represent the ultimate node in the Ready queue structure. Since root tiers neither have parents nor sibling nodes with which to compete, it is not necessary to specify scheduling metrics for root descriptors. Scheduler root descriptors are configured during system initialisation and exist in perpetuity.","Static Scheduler Descriptor exist beneath root nodes in the scheduling hierarchy. The parents of static scheduler descriptors may be other static scheduler descriptors or root descriptors. They compete with sibling nodes according to their parents' defined scheduler algorithm and their scheduler metrics. Static scheduler descriptors are configured during system initialisation and exist in perpetuity. During operation, the system management controller  maintains the scheduler metrics according to the selected scheduling algorithm, for example Round Robin scheduling.","Dynamic Scheduler Descriptors exist beneath root and possibly static nodes in the scheduling hierarchy. The parents of dynamic scheduler descriptors may be either static scheduler descriptors or root descriptors. They compete with sibling nodes according to their parents' defined scheduler algorithm and their own scheduler metrics. Dynamic Scheduler descriptors may be configured at any time and may be retired under specific circumstances. This enables the system to support a far higher number of scheduling tiers than would be possible with a purely static provision. The system management controller  achieves this by capitalising on the likelihood that, although over all time a large number and diversity of threads and dynamic scheduler tiers are used, during a finite period, the transient demand is smaller. For example, in a networking system with attached memory supporting a maximum of 4000 dynamic elements (threads and dynamic scheduler descriptors) it may be possible to support 16000 connections as at any instant in time, dataunits from only a fraction of the overall connection space will be resident in the controller. This flexibility is achieved with a small penalty in performance, since, if a dynamic scheduler descriptor is not present, it must be created prior to the addition of child thread descriptors.","During operation, the system management controller  maintains the scheduler metrics according to the selected scheduling algorithm. Under certain circumstances the dynamic scheduler descriptors will be released back to the controller memory element  free list. This is achieved by storing the pReference from the last thread to be processed within that tier within the dynamic scheduler tier descriptor. The controller  API supports the interrogation of controller memory elements  to determine whether a dynamic scheduler descriptor has persisted between subsequent similar threads.","Dispatch Queues","Dispatch queues hold scheduled thread descriptors in a First In First Out (FIFO) queue awaiting service from the associated processing resource . A maximum of 32 dispatch queues are allowed, in the currently preferred embodiment. Dispatch queues are defined by dispatch queue descriptors, shown in and . Dispatch queue descriptors are configured during system initialisation.","The process of transitioning a thread descriptor from a Ready queue structure to a dispatch queue structure is performed in hardware and requires no controller  API interaction.",{"@attributes":{"id":"p-0185","num":"0211"},"figref":"FIG. 17"},"Elements are removed from the dispatch queue via a pop operation called through the controller  API by a processing resource.","A priority field is included in the dispatch queue descriptor. When a thread is popped from the dispatch queue, the priority field is populated with the priority of the now-executing thread. A further API call enables the priority to be reset to another value by the executing processor, in order to avoid priority inversions. Priority inversion involves at least 3 threads of differing priority and describes a conflict between synchronisation and scheduling requirements. Priority inversion allows a lower priority thread to block a higher priority thread indefinitely. For example, a low priority thread locks a shared resource, and is then pre-empted by a higher priority thread. The higher priority thread then blocks on the resource that is locked by the low priority thread. Since the high priority thread is now blocked, normally the low priority thread would resume, were it not for the third medium thread, which is independent of the locked resource and is now free to run. The low priority thread never gets the opportunity to unlock the shared resource and therefore the high priority thread is blocked indefinitely. \u201cPriority ceiling\u201d protocol means that while a thread owns a shared resource, it runs at a specified priority. This ensures that the \u201clow\u201d priority thread as defined above, assumes a \u201chigh\u201d priority whilst it owns the resource shared with the high priority thread.","Thread bundles describe a group of thread descriptors that originate from the same scheduler tier. A parameter is present in each scheduler descriptor defining the number of threads that may be transitioned from that tier of the ready queue to the dispatch queue before the scheduling decision is forced to update. By making use of this capability, and arranging that members of scheduler tiers share commonality, the processing resources  can be presented with blocks of threads that exhibit significantly higher cache locality than would otherwise be observed, resulting in a reduction in cache-misses and an increase in system performance.",{"@attributes":{"id":"p-0189","num":"0215"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0190","num":"0216"},"figref":"FIG. 18(","i":"a","b":"150"},{"@attributes":{"id":"p-0191","num":"0217"},"figref":"FIG. 18(","i":"b"},"It is likely that the bursty nature of thread bundling will be most undesirable where the system interacts with the outside world. However, thread bundling is only a benefit where the target processing resource  uses caches, therefore specialist processing resources , that interact with the outside world, for example an IO device, are unlikely to use cache technology and therefore will not make use of thread bundling.","Returning to , elements are removed from the dispatch queue via a pop operation called through the controller  API by a processing resource . Elements may be pushed back onto the head of the dispatch queue in the event of preemption.","A priority field is included in the dispatch queue descriptor that enables implementation of the priority ceiling protocol, preventing priority inversions with shared data. Each processing resource  has a unique dispatch queue.","Scheduling","The requirements of scheduling for applications and systems vary widely and, indeed, may only become clear after testing in real operating environments. To accommodate this, the system management controller  delivers flexibility in both scheduling policy and the scheduling algorithms used, which may be modified and tuned throughout the multicore processor design phase.","Scheduling Policies May be Split into Three Types:",{"@attributes":{"id":"p-0196","num":"0000"},"ul":{"@attributes":{"id":"ul0009","list-style":"none"},"li":["1. A cooperative scheduler relies on currently executing tasks to release the processing resource  prior to scheduling a new one. Although this type of system is consistent with minimisation of cold-cache effects (e.g. where the cache local to the processing resource  does not contain the required instruction, therefore must load the missing instruction in from a slower higher level memory), and fixed-function hardware accelerators it may not be suitable for more complex embedded applications.","2. A static priority-driven scheduler can pre-empt the currently executing task in order to execute a task of higher priority. The highest priority ready thread is always the executing thread in these systems. The priority of any given task is fixed before the system begins execution.","3. A dynamic priority-driven scheduler can redefine priorities at run-time. As before, the currently running process is still the highest priority, but the priority may have been changed since the task commenced execution."]}},"The system management controller  caters for all three scheduling policies via appropriate configuration and run-time interaction with the target application.","The system management controller  supports many scheduling algorithms found within both the operating system and communications communities. For example, first in first out queuing, priority queuing or weighted fair queuing. An appropriate choice of scheduling algorithm will exhibit demonstrable advantages, particularly where subjective quality metrics are involved.","Two scheduler metrics are provided within thread descriptors to support the scheduling behaviour within the system management controller . The first represents the priority of the thread in all cases and is used within a pending queue structure, priority based schedulers and a dispatch queue structure. Where necessary, the second is used to select between the individual thread and its peers. Furthermore either metric may be used to update metrics within the parent descriptor. The value placed within the second primitive of a thread descriptor must reflect the types of scheduling encountered in its scheduler hierarchy.","These two scheduler metrics are used in both the scheduler descriptors, and the thread descriptors. However, although thread metrics are calculated within the processing resources , this is not possible for scheduler tiers. Subsequently, sufficient parameters must be passed from a given tier's scheduled thread to enable the scheduler tier to update its own metric. A set of instructions is defined for each scheduler tier which define how the metrics are propagated from child to parent.","With some attention to the overall scheduler hierarchy, complex combinations of scheduler algorithms may be easily created to provide sophisticated traffic and task management capabilities in application systems.","Parameter Inheritance Example",{"@attributes":{"id":"p-0202","num":"0230"},"figref":"FIG. 19"},"For WFQ the Following Variables are Required:",{"@attributes":{"id":"p-0203","num":"0000"},"ul":{"@attributes":{"id":"ul0010","list-style":"none"},"li":{"@attributes":{"id":"ul0010-0001","num":"0000"},"ul":{"@attributes":{"id":"ul0011","list-style":"none"},"li":["P\u2014Fraction of pipe bandwidth allocated to the connection","I\u2014Length of packet","B\u2014Overall pipe bandwidth","c\u2014Connection bandwidth","d\u2014Scheduler tier deadline"]}}}},"The equation for calculating the connection bandwidth, c, is:\n\n\n\nIf we normalise the channel to a bandwidth of 1, then p becomes equal to c.\n","The finish time of the processing of the packet, t, is then given by:",{"@attributes":{"id":"p-0206","num":"0238"},"maths":{"@attributes":{"id":"MATH-US-00001","num":"00001"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mrow":{"mfrac":{"mn":"1","mi":"p"},"mo":"*","mi":"l"},"mo":"=","mi":"t"}}},"br":{}},{"@attributes":{"id":"p-0207","num":"0239"},"maths":{"@attributes":{"id":"MATH-US-00002","num":"00002"},"math":{"@attributes":{"overflow":"scroll"},"mrow":{"mi":"d","mo":"=","mrow":{"mi":"d","mo":"+","mrow":{"mo":["(",")"],"mrow":{"mfrac":{"mn":"1","mi":"p"},"mo":"*","mi":"l"}}}}}},"br":{},"b":"330"},"Whilst a specific embodiment of the invention has been described, it is to be understood that this is by way of example only and that various modifications may be considered. Moreover, the invention is of general application in any device or application that employs a multicore processor, such as, but not limited to, a mobile telephone or voice over Internet Protocol (VoIP) for example. Therefore, the specific embodiment is not to be seen as limiting of the scope of protection which is to be determined by the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention may be put into practise in a number of ways, and some embodiments will now be described by way of example only and with reference to the accompanying drawings, in which:",{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 3","FIG. 2"]},{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 4","FIGS. 1"],"b":["2","3"]},{"@attributes":{"id":"p-0045","num":"0044"},"figref":["FIG. 5","FIGS. 2 and 3"]},{"@attributes":{"id":"p-0046","num":"0045"},"figref":["FIG. 6","FIGS. 2"],"b":["3","4"]},{"@attributes":{"id":"p-0047","num":"0046"},"figref":["FIG. 7","FIGS. 2 and 3"]},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIGS. 9","i":["a ","b "],"b":"9"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIGS. 9","i":["c ","d "],"b":"9"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIGS. 9","i":["e ","f "],"b":"9"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIGS. 9","i":["g ","h "],"b":"9"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIGS. 9","i":["i ","j "],"b":"9"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIGS. 9","i":["k ","l "],"b":"9"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 11","FIG. 10"]},{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 12","FIG. 4"]},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 19"}]},"DETDESC":[{},{}]}
