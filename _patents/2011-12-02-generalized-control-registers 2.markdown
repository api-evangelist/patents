---
title: Generalized control registers
abstract: Methods, systems, and computer readable media generalize control registers in the context of memory address translations for I/O devices. A method includes maintaining a table including a plurality of concurrently available control register base pointers each associated with a corresponding input/output (I/O) device, associating each control register base pointer with a first translation from a guest virtual address (GVA) to a guest physical address (GPA) and a second translation from the GPA to a system physical address (SPA), and operating the first and second translations concurrently for the plurality of I/O devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09606936&OS=09606936&RS=09606936
owner: ATI Technologies ULC
number: 09606936
owner_city: Markham, Ontario
owner_country: CA
publication_date: 20111202
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATIONS","BACKGROUND OF THE INVENTION","SUMMARY OF EMBODIMENTS OF THE INVENTION","DETAILED DESCRIPTION OF EMBODIMENTS OF THE INVENTION"],"p":["This application claims priority under 35 U.S.C. 119(e) to Provisional Application No. 61\/423,828, filed Dec. 16, 2010, which is incorporated by reference herein in its entirety.","Field of the Invention","The present invention is generally directed to computing systems. More particularly, the present invention is directed to computer registers in the context of memory address translations.","Background Art","The desire to use a graphics processing unit (GPU) for general computation has become much more pronounced recently due to the GPU's exemplary performance per unit power and\/or cost. The computational capabilities for GPUs, generally, have grown at a rate exceeding that of the corresponding central processing unit (CPU) platforms. This growth, coupled with the explosion of the mobile computing market (e.g., notebooks, mobile smart phones, tablets, etc.) and its necessary supporting server\/enterprise systems, has been used to provide a specified quality of desired user experience. Consequently, the combined use of CPUs and GPUs for executing workloads with data parallel content is becoming a volume technology.","However, GPUs have traditionally operated in a constrained programming environment, available primarily for the acceleration of graphics. These constraints arose from the fact that GPUs did not have as rich a programming ecosystem as CPUs. Their use, therefore, has been mostly limited to two dimensional (2D) and three dimensional (3D) graphics and a few leading edge multimedia applications, which are already accustomed to dealing with graphics and video application programming interfaces (APIs).","With the advent of multi-vendor supported OpenCL\u00ae and DirectCompute\u00ae, standard APIs and supporting tools, the limitations of the GPUs in traditional applications has been extended beyond traditional graphics. Although OpenCL and DirectCompute are a promising start, there are many hurdles remaining to creating an environment and ecosystem that allows the combination of a CPU and a GPU to be used as fluidly as the CPU for most programming tasks.","Existing computing systems often include multiple processing devices. For example, some computing systems include both a CPU and a GPU on separate chips (e.g., the CPU might be located on a motherboard and the GPU might be located on a graphics card) or in a single chip package. Both of these arrangements, however, still include significant challenges associated with (i) efficient scheduling, (ii) providing quality of service (QoS) guarantees between processes, (iii) programming model, (iv) compiling to multiple target instruction set architectures (ISAs), and (v) separate memory systems\u2014all while minimizing power consumption.","For example, the discrete chip arrangement forces system and software architects to utilize chip to chip interfaces for each processor to access memory. While these external interfaces (e.g., chip to chip) negatively affect memory latency and power consumption for cooperating heterogeneous processors, the separate memory systems (i.e., separate address spaces) and driver managed shared memory create overhead that becomes unacceptable for fine grain offload.","In another example, the GPU, along with other peripherals (e.g., input\/output (I\/O) devices) may need to access information stored in memory of a computer system. For enhanced performance, the computer system can provide virtual memory capabilities for the I\/O device. Accordingly, multiple I\/O devices may request information based on corresponding virtual addresses, and the computer system translates the virtual addresses to a physical addresses corresponding to memory. An input\/output memory management unit (IOMMU) may provide address translation services between the multiple I\/O devices and memory.","The computing system can also provide multiple virtualized systems, including virtualized guest operating systems (OSes) managed by a hypervisor. In order to provide access to the I\/O devices, the computer system can virtualize I\/O devices for each guest OS. That is, the hypervisor manipulates memory by coordinating conversions from virtual memory addresses to physical memory addresses for each of the I\/O devices for each of the virtualized guest OSes. This process is performed so that each virtualized system can access the I\/O devices as though each guest OS was the only OS accessing the I\/O devices.","Thus, the hypervisor can become a bottleneck as it executes software routines to accommodate all of the requests for address translations. Since each of these translations is associated with accessing the IOMMU, the software based operation of the hypervisor represents significant overhead. This overhead can degrade performance. Additional overhead is associated with organizing and manipulating memory structures in memory for efficient and concurrent access to memory translations to accommodate multiple I\/O devices.","What is needed, therefore, is the ability to provide concurrently accessible address translation for multiple I\/O devices and guest OSes that enhances performance and reduces overhead.","Although GPUs, accelerated processing units (APUs), and general purpose use of the graphics processing unit (GPGPU) are commonly used terms in this field, the expression \u201caccelerated processing device (APD)\u201d is considered to be a broader expression. For example, APD refers to any cooperating collection of hardware and\/or software that performs those functions and computations associated with accelerating graphics processing tasks, data parallel tasks, or nested data parallel tasks in an accelerated manner compared to conventional CPUs, conventional GPUs, software and\/or combinations thereof.","More specifically, embodiments of the present invention relate to methods, systems, and computer readable media for generalized control registers (such as, for example, control register 3 (CR3)\u2014in x86 microprocessors which is used by an x86 microprocessor processor to translate physical addresses from virtual addresses by locating both the page directory and page tables for a current task) in the context of memory address translations for I\/O devices. An exemplary method includes maintaining a table including a concurrently available control register, e.g., guest control register 3 (GCR3), base pointers each associated with a corresponding input\/output (I\/O) device. Each control register base pointer is associated with a first translation from a guest virtual address (GVA) to a guest physical address (GPA), and a second translation from the GPA to a system physical address (SPA). The first and second translations are operated concurrently for the I\/O devices.","Additional features and advantages of the invention, as well as the structure and operation of various embodiments of the invention, are described in detail below with reference to the accompanying drawings. It is noted that the invention is not limited to the specific embodiments described herein. Such embodiments are presented herein for illustrative purposes only. Additional embodiments will be apparent to persons skilled in the relevant art(s) based on the teachings contained herein.","In the detailed description that follows, references to \u201cone embodiment,\u201d \u201can embodiment,\u201d \u201can example embodiment,\u201d etc., indicate that the embodiment described may include a particular feature, structure, or characteristic, but every embodiment may not necessarily include the particular feature, structure, or characteristic. Moreover, such phrases are not necessarily referring to the same embodiment. Further, when a particular feature, structure, or characteristic is described in connection with an embodiment, it is submitted that it is within the knowledge of one skilled in the art to affect such feature, structure, or characteristic in connection with other embodiments whether or not explicitly described.","The term \u201cembodiments of the invention\u201d does not require that all embodiments of the invention include the discussed feature, advantage or mode of operation. Alternate embodiments may be devised without departing from the scope of the invention, and well-known elements of the invention may not be described in detail or may be omitted so as not to obscure the relevant details of the invention. In addition, the terminology used herein is for the purpose of describing particular embodiments only and is not intended to be limiting of the invention. For example, as used herein, the singular forms \u201ca\u201d, \u201can\u201d and \u201cthe\u201d are intended to include the plural forms as well, unless the context clearly indicates otherwise. It will be further understood that the team \u201ccomprises,\u201d \u201ccomprising,\u201d \u201cincludes\u201d and\/or \u201cincluding,\u201d when used herein, specify the presence of stated features, integers, steps, operations, elements, and\/or components, but do not preclude the presence or addition of one or more other features, integers, steps, operations, elements, components, and\/or groups thereof.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 1A","b":["100","102","104","102","100","102","104","104","102","102","104"]},"In one example, system  also includes a memory , an operating system , and a communication infrastructure . The operating system  and the communication infrastructure  are discussed in greater detail below.","The system  also includes a kernel mode driver (KMD) , a software scheduler (SWS) , and a memory management unit , such as input\/output memory management unit (IOMMU). Components of system  can be implemented as hardware, firmware, software, or any combination thereof. A person of ordinary skill in the art will appreciate that system  may include one or more software, hardware, and firmware components in addition to, or different from, that shown in the embodiment shown in .","In one example, a driver, such as KMD , typically communicates with a device through a computer bus or communications subsystem to which the hardware connects. When a calling program invokes a routine in the driver, the driver issues commands to the device. Once the device sends data back to the driver, the driver may invoke routines in the original calling program. In one example, drivers are hardware-dependent and operating-system-specific. They usually provide the interrupt handling required for any necessary asynchronous time-dependent hardware interface.","Device drivers, particularly on modern Microsoft Windows\u00ae platforms, can run in kernel-mode (Ring ) or in user-mode (Ring ). The primary benefit of running a driver in user mode is improved stability, since a poorly written user mode device driver cannot crash the system by overwriting kernel memory. On the other hand, user\/kernel-mode transitions usually impose a considerable performance overhead, thereby prohibiting user mode-drivers for low latency and high throughput requirements. Kernel space can be accessed by user module only through the use of system calls. End user programs like the UNIX shell or other GUI based applications are part of the user space. These applications interact with hardware through kernel supported functions.","CPU  can include (not shown) one or more of a control processor, field programmable gate array (FPGA), application specific integrated circuit (ASIC), or digital signal processor (DSP). CPU , for example, executes the control logic, including the operating system , KMD , SWS , and applications , that control the operation of computing system . In this illustrative embodiment, CPU , according to one embodiment, initiates and controls the execution of applications  by, for example, distributing the processing associated with that application across the CPU  and other processing resources, such as the APD .","APD , among other things, executes commands and programs for selected functions, such as graphics operations and other operations that may be, for example, particularly suited for parallel processing. In general, APD  can be frequently used for executing graphics pipeline operations, such as pixel operations, geometric computations, and rendering an image to a display. In various embodiments of the present invention, APD  can also execute compute processing operations (e.g., those operations unrelated to graphics such as, for example, video operations, physics simulations, computational fluid dynamics, etc.), based on commands or instructions received from CPU .","For example, commands can be considered as special instructions that are not typically defined in the instruction set architecture (ISA). A command may be executed by a special processor such a dispatch processor, command processor, or network controller. On the other hand, instructions can be considered, for example, a single operation of a processor within a computer architecture. In one example, when using two sets of ISAs, some instructions are used to execute x86 programs and some instructions are used to execute kernels on an APD compute unit.","In an illustrative embodiment, CPU  transmits selected commands to APD . These selected commands can include graphics commands and other commands amenable to parallel execution. These selected commands, that can also include compute processing commands, can be executed substantially independently from CPU .","APD  can include its own compute units (not shown), such as, but not limited to, one or more SIMD processing cores. As referred to herein, a SIMD is a pipeline, or programming model, where a kernel is executed concurrently on multiple processing elements each with its own data and a shared program counter. All processing elements execute an identical set of instructions. The use of predication enables work-items to participate or not for each issued command.","In one example, each APD  compute unit can include one or more scalar and\/or vector floating-point units and\/or arithmetic and logic units (ALUs). The APD compute unit can also include special purpose processing units (not shown), such as inverse-square root units and sine\/cosine units. In one example, the APD compute units are referred to herein collectively as shader core .","Having one or more SIMDs, in general, makes APD  ideally suited for execution of data-parallel tasks such as those that are common in graphics processing.","Some graphics pipeline operations, such as pixel processing, and other parallel computation operations, can require that the same command stream or compute kernel be performed on streams or collections of input data elements. Respective instantiations of the same compute kernel can be executed concurrently on multiple compute units in shader core  in order to process such data elements in parallel. As referred to herein, for example, a compute kernel is a function containing instructions declared in a program and executed on an APD compute unit. This function is also referred to as a kernel, a shader, a shader program, or a program.","In one illustrative embodiment, each compute unit (e.g., SIMD processing core) can execute a respective instantiation of a particular work-item to process incoming data. A work-item is one of a collection of parallel executions of a kernel invoked on a device by a command. A work-item can be executed by one or more processing elements as part of a work-group executing on a compute unit.","A work-item is distinguished from other executions within the collection by its global ID and local ID. In one example, a subset of work-items in a workgroup that execute simultaneously together on a SIMD can be referred to as a wavefront . The width of a wavefront is a characteristic of the hardware of the compute unit (e.g., SIMD processing core). As referred to herein, a workgroup is a collection of related work-items that execute on a single compute unit. The work-items in the group execute the same kernel and share local memory and work-group barriers.","In the exemplary embodiment, all wavefronts from a workgroup are processed on the same SIMD processing core. Instructions across a wavefront are issued one at a time, and when all work-items follow the same control flow, each work-item executes the same program. Wavefronts can also be referred to as warps, vectors, or threads.","An execution mask and work-item predication are used to enable divergent control flow within a wavefront, where each individual work-item can actually take a unique code path through the kernel. Partially populated wavefronts can be processed when a full set of work-items is not available at wavefront start time. For example, shader core  can simultaneously execute a predetermined number of wavefronts , each wavefront  comprising a multiple work-items.","Within the system , APD  includes its own memory, such as graphics memory  (although memory  is not limited to graphics only use). Graphics memory  provides a local memory for use during computations in APD . Individual compute units (not shown) within shader core  can have their own local data store (not shown). In one embodiment, APD  includes access to local graphics memory , as well as access to the memory . In another embodiment, APD  can include access to dynamic random access memory (DRAM) or other such memories (not shown) attached directly to the APD  and separately from memory .","In the example shown, APD  also includes one or \u201cn\u201d number of command processors (CPs) . CP  controls the processing within APD . CP  also retrieves commands to be executed from command buffers  in memory  and coordinates the execution of those commands on APD .","In one example, CPU  inputs commands based on applications  into appropriate command buffers . As referred to herein, an application is the combination of the program parts that will execute on the compute units within the CPU and APD.","A plurality of command buffers  can be maintained with each process scheduled for execution on the APD .","CP  can be implemented in hardware, firmware, or software, or a combination thereof. In one embodiment, CP  is implemented as a reduced instruction set computer (RISC) engine with microcode for implementing logic including scheduling logic.","APD  also includes one or \u201cn\u201d number of dispatch controllers (DCs) . In the present application, the term dispatch refers to a command executed by a dispatch controller that uses the context state to initiate the start of the execution of a kernel for a set of work groups on a set of compute units. DC  includes logic to initiate workgroups in the shader core . In some embodiments, DC  can be implemented as part of CP .","System  also includes a hardware scheduler (HWS)  for selecting a process from a run list  for execution on APD . HWS  can select processes from run list  using round robin methodology, priority level, or based on other scheduling policies. The priority level, for example, can be dynamically determined. HWS  can also include functionality to manage the run list , for example, by adding new processes and by deleting existing processes from run-list . The run list management logic of HWS  is sometimes referred to as a run list controller (RLC).","In various embodiments of the present invention, when HWS  initiates the execution of a process from RLC , CP  begins retrieving and executing commands from the corresponding command buffer . In some instances, CP  can generate one or more commands to be executed within APD , which correspond with commands received from CPU . In one embodiment, CP , together with other components, implements a prioritizing, and scheduling of commands on APD  in a manner that improves or maximizes the utilization of the resources of APD  and\/or system .","APD  can have access to, or may include, an interrupt generator . Interrupt generator  can be configured by APD  to interrupt the operating system  when interrupt events, such as page faults, are encountered by APD . For example, APD  can rely on interrupt generation logic within IOMMU  to create the page fault interrupts noted above.","APD  can also include preemption and context switch logic  for preempting a process currently running within shader core . Context switch logic , for example, includes functionality to stop the process and save its current state (e.g., shader core  state, and CP  state).","As referred to herein, the term, state can include an initial state, an intermediate state, and\/or a final state. An initial state is a starting point for a machine to process an input data set according to a programming order to create an output set of data. There is an intermediate state, for example, that needs to be stored at several points to enable the processing to make forward progress. This intermediate state is sometimes stored to allow a continuation of execution at a later time when interrupted by some other process. There is also final state that can be recorded as part of the output data set.","Preemption and context switch logic  can also include logic to context switch another process into the APD . The functionality to context switch another process into running on the APD  may include instantiating the process, for example, through the CP  and DC  to run on APD , restoring any previously saved state for that process, and starting its execution.","Memory  can include non-persistent memory such as DRAM (not shown). Memory  can store, e.g., processing logic instructions, constant values, and variable values during execution of portions of applications or other processing logic. For example, in one embodiment, parts of control logic to perform one or more operations on CPU  can reside within memory  during execution of the respective portions of the operation by CPU .","During execution, respective applications, operating system functions, processing logic commands, and system software can reside in memory . Control logic commands fundamental to operating system  will generally reside in memory  during execution. Other software commands, including, for example, kernel mode driver  and software scheduler  can also reside in memory  during execution of system .","In this example, memory  includes command buffers  that are used by CPU  to send commands to APD . Memory  also contains process lists and process information (e.g., active list  and process control blocks ). These lists, as well as the information, are used by scheduling software executing on CPU  to communicate scheduling information to APD  and\/or related scheduling hardware. Access to memory  can be managed by a memory controller , which is coupled to memory . For example, requests from CPU , or from other devices, for reading from or for writing to memory  are managed by the memory controller .","Referring back to other aspects of system , IOMMU  is a multi-context memory management unit.","As used herein, context can be considered the environment within which the kernels execute and the domain in which synchronization and memory management is defined. The context includes a set of devices, the memory accessible to those devices, the corresponding memory properties and one or more command-queues used to schedule execution of a kernel(s) or operations on memory objects.","Referring back to the example shown in , IOMMU  includes logic to perform virtual to physical address translation for memory page access for devices including APD . IOMMU  may also include logic to generate interrupts, for example, when a page access by a device such as APD  results in a page fault. IOMMU  may also include, or have access to, a translation lookaside buffer (TLB) . TLB , as an example, can be implemented in a content addressable memory (CAM) to accelerate translation of logical (i.e., virtual) memory addresses to physical memory addresses for requests made by APD  for data in memory .","In the example shown, communication infrastructure  interconnects the components of system  as needed. Communication infrastructure  can include (not shown) one or more of a peripheral component interconnect (PCI) bus, extended PCI (PCI-E) bus, advanced microcontroller bus architecture (AMBA) bus, advanced graphics port (AGP), or other such communication infrastructure. Communications infrastructure  can also include an Ethernet, or similar network, or any suitable physical communications infrastructure that satisfies an application's data transfer rate requirements. Communication infrastructure  includes the functionality to interconnect components including components of computing system .","In this example, operating system  includes functionality to manage the hardware components of system  and to provide common services. In various embodiments, operating system  can execute on CPU  and provide common services. These common services can include, for example, scheduling applications for execution within CPU , fault management, interrupt service, as well as processing the input and output of other applications.","In some embodiments, based on interrupts generated by an interrupt controller, such as interrupt controller , operating system  invokes an appropriate interrupt handling routine. For example, upon detecting a page fault interrupt, operating system  may invoke an interrupt handler to initiate loading of the relevant page into memory  and to update corresponding page tables.","Operating system  may also include functionality to protect system  by ensuring that access to hardware components is mediated through operating system managed kernel functionality. In effect, operating system  ensures that applications, such as applications , run on CPU  in user space. Operating system  also ensures that applications  invoke kernel functionality provided by the operating system to access hardware and\/or input\/output functionality.","By way of example, applications  include various programs or commands to perform user computations that are also executed on CPU . CPU  can seamlessly send selected commands for processing on the APD . In one example, KMD  implements an application program interface (API) through which CPU , or applications executing on CPU  or other logic, can invoke APD  functionality. For example, KMD  can enqueue commands from CPU  to command buffers  from which APD  will subsequently retrieve the commands. Additionally, KMD  can, together with SWS , perform scheduling of processes to be executed on APD . SWS , for example, can include logic to maintain a prioritized list of processes to be executed on the APD.","In other embodiments of the present invention, applications executing on CPU  can entirely bypass KMD  when enqueuing commands.","In some embodiments, SWS  maintains an active list  in memory  of processes to be executed on APD . SWS  also selects a subset of the processes in active list  to be managed by HWS  in the hardware. Information relevant for running each process on APD  is communicated from CPU  to APD  through process control blocks (PCB) .","Processing logic for applications, operating system, and system software can include commands specified in a programming language such as C and\/cm in a hardware description language such as Verilog, RTL, or netlists, to enable ultimately configuring a manufacturing process through the generation of maskworks\/photomasks to generate a hardware device embodying aspects of the invention described herein.","A person of skill in the art will understand, upon reading this description, that computing system  can include more or fewer components than shown in . For example, computing system  can include one or more input interfaces, non-volatile storage, one or more output interfaces, network interfaces, and one or more displays or display interfaces.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 1B","FIG. 1A","FIG. 1B","FIG. 1A","FIG. 1B"],"b":["104","124","124","124","124","124","125","0","124","162","1","2","124","124","160","166","128"],"i":["a","b","c","a","b ","c"]},"In , graphics pipeline  can include a set of blocks, referred to herein as ordered pipeline . As an example, ordered pipeline  includes a vertex group translator (VGT) , a primitive assembler (PA) , a scan converter (SC) , and a shader-export, render-back unit (SX\/RB) . Each block within ordered pipeline  may represent a different stage of graphics processing within graphics pipeline . Ordered pipeline  can be a fixed function hardware pipeline. Other implementations can be used that would also be within the spirit and scope of the present invention.","Although only a small amount of data may be provided as an input to graphics pipeline , this data will be amplified by the time it is provided as an output from graphics pipeline . Graphics pipeline  also includes DC  for counting through ranges within work-item groups received from CP pipeline . Compute work submitted through DC  is semi-synchronous with graphics pipeline .","Compute pipeline  includes shader DCs  and . Each of the DCs  and  is configured to count through compute ranges within work groups received from CP pipelines and ","The DCs , , and , illustrated in , receive the input ranges, break the ranges down into workgroups, and then forward the workgroups to shader core .","Since graphics pipeline  is generally a fixed function pipeline, it is difficult to save and restore its state, and as a result, the graphics pipeline  is difficult to context switch. Therefore, in most cases context switching, as discussed herein, does not pertain to context switching among graphics processes. An exception is for graphics work in shader core , which can be context switched.","After the processing of work within graphics pipeline  has been completed, the completed work is processed through a render back unit , which does depth and color calculations, and then writes its final results to memory .","Shader core  can be shared by graphics pipeline  and compute pipeline . Shader core  can be a general processor configured to run wavefronts. In one example, all work within compute pipeline  is processed within shader core . Shader core  runs programmable software code and includes various forms of data, such as state data.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 2","FIG. 1A"],"b":["200","100","200","100","200","200"]},"A memory mapping structure can be configured to operate between memory , memory controller , IOMMU , and I\/O devices A, B, and C, represented by numerals , , and , respectively, connected via a bus . IOMMU  can be a hardware device that operates to translate direct memory access (DMA) virtual addresses into system physical addresses. IOMMU  can construct one or more unique address spaces and use the unique address space(s) to control how a device's DMA operation accesses memory.  only shows one IOMMU for the sake of example. Embodiments of the present invention, however, can include more than one IOMMU.","Generally, an IOMMU can be connected to its own respective bus and I\/O device(s). In , a bus  can be any type of bus used in computer systems, including a PCI bus, an AGP bus, a PCIe bus (which is more accurately described as a point to point protocol), or any other type of bus whether presently available or developed in the future. Bus  may further interconnect interrupt controller , kernel mode driver , SWS , applications , and operating system  with other components in system .","The I\/O device C can include memory management I\/O (MMIO) maps and host data path (HDP) , device processing complex , private memory management unit (MMU) , and input output translation lookaside buffer (IOTLB) . The I\/O device C can also include address translation service (ATS)\/page request interface (PRI) request block , local memory , local memory protection map , and multiplexers , , , , and .","Embodiments of IOMMU  can be set up to include device table base register (DTBR) , command buffer base register (CBBR) , event log base register (ELBR) , control logic , and peripheral page request register (PPRR) . Further, IOMMU  can include guest control register table selector  to invoke I\/O page table walker  to traverse the page tables, e.g., for address translations. Also, the IOMMU  can be associated with one or more TLBs  for caching address translations that are used for fulfilling subsequent translations without needing to perform a page table walk. Addresses from a device table can be communicated to IOMMU via bus .","Embodiments of the present invention provide for the IOMMU  to use I\/O page tables  to provide permission checking and address translation on memory accessed by I\/O devices. Also, embodiments of the present invention, as an example, can use I\/O page tables designed in the AMD64 long format. The device tables  allow I\/O devices to be assigned to specific domains. The I\/O page tables also may be configured to include pointers to the I\/O devices' page tables.","Memory  also includes interrupt remapping table (IRT) , command buffers , event logs , and a virtualized system  (discussed in greater detail below). Memory  also includes a host translation module, such as hypervisor . Memory  also includes one or more concurrently running guest operating systems such as, but not limited to, guest operating system , represented by element number , and guest operating system , represented by element number .","Further, IOMMU  and the memory  can be set up such that DTBR  points to the starting index of device tables . Further, CBBR  points to the starting index of command buffers . The ELBR  points to the starting index of event logs . PPRR  points to the starting index of PPSR tables .","IOMMU  can use memory-based queues for exchanging command and status information between the IOMMU  and the system processor(s), such as CPU . CPU  can include MMU .","In accordance with one illustrative embodiment, IOMMU  can intercept requests arriving from downstream devices (which can be communicated using, for example, HyperTransport\u2122 link or a PCI based bus), perform permission checks and address translation for the requests, and send translated versions upstream to memory  space. Other requests may be passed through unaltered.","I\/O devices A, B, and C, represented by numerals , , and , respectively, can request address translations from the IOMMU  such that the IOMMU  receives multiple address translation requests concurrently. System overhead may be associated with a need for software manipulation and maintenance (e.g., using hypervisor  and\/or guest O\/Ses  and ) of address table pointers and associated software construct support.","Accordingly, the IOMMU  can minimize overhead by efficiently providing concurrent hardware-based address translation services for multiple I\/O devices. IOMMU  can service multiple I\/O devices by providing concurrently accessible address translation services for each I\/O device. Thus, each I\/O device is not required to serially share a single control register to access GVA-to-GPA address translations.","The acronym GVA can refer to a virtual address, e.g., a guest virtual address. The acronym GPA can refer to a first type of physical address, e.g., a guest physical address for a virtual system. However, a GPA can be viewed as a type of virtual address relative to the underlying system hosting the virtualized system\/guest OS. Thus, GPA can refer to a system virtual address (SVA), which is a virtual address for the underlying system hosting the virtual system. The acronym SPA can refer to a second type physical address, e.g., a system physical address.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":["FIG. 3","FIG. 2"],"b":["300","300","304","306"]},"By way of example, I\/O devices  can include graphics processing device(s). The I\/O devices  interact with the memory  in the virtualized system  via a table of generalized control register pointers enabled by an IOMMU.","In the virtualized system , GVAs for address translation are provided to the IOMMU  by the I\/O devices  using address translation transactions. Thus, the GVAs are associated with a guest virtual address space . The IOMMU provides a first layer of translation, multiple concurrent IOMMU guest translations , to convert the GVAs to GPAs associated with guest physical address space . The multiple concurrent IOMMU guest translations  may be managed by a guest OS operating in the virtualized system .","The IOMMU  also provides a second layer of translation, IOMMU nested translation , to convert the GPAs to SPAs associated with system physical address space . The IOMMU nested translation  can be managed by a hypervisor operating in the virtualized system . The SPAs can be used to access information in the memory .","Accordingly, the IOMMU provides concurrent virtual address translation for multiple I\/O devices . The IOMMU provides a hardware solution with improved performance for concurrent address translations, including translations involving peripherals and virtualized guest OSes. Hardware can automatically load entries to\/from the page tables using a table of generalized guest control register pointers. This loading occurs without needing software intervention that would otherwise be needed to manage access to a single control register in the absence of multiple concurrently accessible generalized guest control register pointers provided by the present embodiments. Virtualized systems involving address translations among multiple guest O\/Ses and multiple I\/O devices can benefit greatly from the speed associated with a hardware-based implementation of generalized control register pointers. This hardware-based implementation facilitates concurrent access to address translation information for multiple O\/Ses and\/or I\/O devices.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":["FIG. 4","FIG. 2"],"b":["400","216","206","216","241","241","404","226","404","408","408","224","206"]},"DTE  may include a system pointer  pointing to a root of a system address translation table structure , and a guest pointer  pointing to a root of guest control register table . Guest control register table  includes a plurality of guest control register table entries . Each guest control register table entry  includes a guest control register base pointer  that points to a corresponding guest address translation table structure .  illustrates one guest address translation table structure , although a plurality of guest address translation table structures  can be used, corresponding to the plurality of guest control register table entries . Accordingly, the IOMMU  can concurrently access a plurality of system\/guest address translation table structures  and , including concurrently available guest control register table entries  corresponding to multiple I\/O devices, for address translation.","Thus, any number of control registers, e.g., guest CR3 \u201cregisters\u201d (pointers\/table entries ) can be implemented using the guest control register table . An embodiment can include more than 64,000 guest control register table entries  for example, all active concurrently without needing to deactivate any of them or switch contexts\/threads\/hyperthreads. The IOMMU  can select from any of the guest control register table entries  at any point in time without incurring software overhead (e.g., hypervisor intervention).","For performing GVA-to-GPA translations, the IOMMU  may access the guest address translation table structures  using guest pointer  to obtain a GPA. A GPA address may concurrently be used to perform GPA-to-SPA translations by accessing the system address translation table structures  using system pointer . The IOMMU  may perform multiple address translations concurrently and\/or independently, for multiple I\/O devices and\/or guest O\/Ses. IOMMU  may also perform single-layer translation using DTE  including a system pointer  pointing to a root of a system address translation table structure .",{"@attributes":{"id":"p-0105","num":"0104"},"figref":["FIG. 5","FIG. 2","FIG. 2","FIG. 2"],"b":["500","254","522","250","522","522","522"]},"Additionally, device identifiers A and C may be used to identify one physical device (e.g., the graphics processing device), with hardware virtualized for different guest O\/Ses such that each virtualized device has a corresponding unique device identifier. The device identifiers therefore can be used to identify to which guest O\/S a virtualized I\/O device is assigned. Device identifiers A and C may be a bus, device, function DF) designation used in PCIe interfaces.","The I\/O device C  issues an address translation transaction C C (e.g., a request from the I\/O device C  using ATS according to the PCI-SIG specification) via bus . The address translation transaction C C may include a GVA C C that the I\/O device C  needs to have translated. The address translation transaction C C can also include the device identifier C C and a process address space identifier C C. The process address space identifier C C may be used to identify an application address space within a guest virtual machine (VM), and may be used on I\/O device C  to isolate concurrent contexts residing in shared local memory. Together, device identifier C C and process address space identifier C C may uniquely identify an application address space.","I\/O device A  similarly issues an address translation transaction A A including GVA A A, device identifier A A and process address space identifier A A. I\/O device C  and I\/O device A  may issue address translation transactions concurrently to the IOMMU  for translation.","The address translation transactions A and C are received by the IOMMU . IOMMU  accesses device table  based on the device table base register  containing a root pointer that points to the root of device table .","The device table  is indexed using device identifiers. Device identifier A A from the address translation transaction A is used to access DTE A A, and device identifier C C from the address translation transaction C is used to access DTE C C. DTE A A contains guest pointer A A and system pointer A A, and DTE C C contains guest pointer C C and system pointer C C (see, e.g., guest pointer  and system pointer  in ). System pointers A and C are used to walk system address translation table structures A and C, respectively.","Guest pointers A and C are used to access the root of guest control register table . The guest control register table  is indexed using process address space identifiers A and C from address translation transactions A and C to access guest control register table entries A and C, respectively. Guest control register table entries A and C include guest control register base pointers A and C pointing to the guest address translation table structures A and C corresponding to the address translation transactions A and C, respectively. The guest address translation table structures A and C are walked using GVA A A and GVA C C from the address translation transactions A and C, respectively.","The guest control register table  has multiple guest control register table entries including guest control register table entries A and C. The guest control register table entries are concurrently available to the IOMMU , along with concurrently available system address translation table structures A and C. Thus, the IOMMU  can service concurrent address translation transactions A and C from multiple I\/O devices  and . Guest control register table entries in the guest control register table  do not have to be explicitly managed by software (e.g., overwritten\/swapped out) when translating addresses for multiple I\/O devices. The IOMMU  has hardware access to all entries concurrently.",{"@attributes":{"id":"p-0113","num":"0112"},"figref":["FIG. 6","FIGS. 4 and 5"],"b":["600","408","255","0","650","650","51","12","408","611","411","127","107","95","80","408","613","413","611","408","613","408"],"i":["a ","b"]},"Guest pointer  (guest control register table root pointer ) may reference guest address translation table structures A and C (see ) having various structures, as indicated by bits : of DTE  (a field to store a value, e.g., GLX ). GLX  may be used to indicate what type of guest address translation table structure is referenced by the DTE . GLX  specifies the type of guest control register lookup performed by the IOMMU  for an I\/O device ,  when the I\/O device presents an address with a valid process address space identifier. For example, one-, two-, or three-level guest address translation table structures may be used, as identified via GLX .","For an I\/O device using process address space identifier values up to 9 bits, GLX  is used to indicate a one-level guest address translation table structure. For I\/O devices using process address space identifier values between 9 bits and 19 bits, GLX  is used to indicate a two-level guest address translation table structure. For I\/O devices using process address space identifier values of 19 bits or 20 bits, GLX  is used to indicate a three-level guest address translation table structure.","Embodiments may use arbitrary levels to represent the guest address translation table structures A and C, and the form of the structures may be arbitrary. For example, the structure may be instantiated as a table, a hash tree, a long linear list, or a tree of nested lists (e.g., each list being a page 4K in length) that reference each other. Two exemplary guest address translation table structures are described below with reference to .",{"@attributes":{"id":"p-0117","num":"0116"},"figref":["FIG. 7A","FIG. 4","FIG. 7A","FIG. 4","FIG. 7A","FIG. 7A"],"b":["700","415","1","710","404","408","413","415","415","416","416","417","710"]},"The guest page table A includes a plurality of entries, e.g., PMLE A. PMLE A is a GPA corresponding to the GVA requested to be translated as indicated in the address translation transaction  sent to the IOMMU . PMLE A may be further translated by invoking a GPA-to-SPA translation, e.g., using system address translation table structures  (see ). Thus, the PMLE, corresponding to the GPA resulting from a GVA-to-GPA address translation, is obtained after traversing the one level guest control register table .",{"@attributes":{"id":"p-0119","num":"0118"},"figref":["FIG. 7B","FIG. 4","FIG. 7B","FIG. 7A","FIG. 7B","FIG. 4","FIG. 7B","FIG. 7B"],"b":["700","1","710","2","710","415","2","1","730","710","404","408","413","415","415","416"]},"Each guest control register table entry  includes a guest control register base table pointer  pointing to a root of guest control register level- table . The guest control register level- table  includes guest control register base pointers  pointing to a root of a guest page table B. The guest page table B, includes a plurality of entries, e.g., PMLE B. As in , each PMLE B is a GPA corresponding to the GVA requested to be translated as indicated in the address translation transaction  sent to the IOMMU . PMLE B may be farther translated by invoking a GPA-to-SPA translation, e.g., using system address translation table structures  (see ).","Thus, the PMLE, corresponding to the GPA desired from a GVA-to-GPA address translation, is obtained after traversing two levels, the guest control register table  and the guest control register level- table .",{"@attributes":{"id":"p-0122","num":"0121"},"figref":"FIGS. 7A and 7B","b":["414","408","408"]},{"@attributes":{"id":"p-0123","num":"0122"},"figref":"FIG. 8","b":["800","810"]},"In step , each guest control register pointer is associated with a GVA-to-GPA translation and a GPA-to-SPA translation. Translation tables of various structures may be used, and may be identified according to a field in the device table entry associated with the guest control register pointer. For example, a two-level nested tree can be used to associate the guest control register pointer to a GVA-to-GPA translation.","In step , the GVA-to-GPA and GPA-to-SPA translations are operated concurrently for the I\/O devices. Thus, an IOMMU may perform multiple concurrent address translations for multiple I\/O devices, including virtualized I\/O devices\/processes, providing high concurrency for I\/O traffic and DMA jobs.","The Summary of Embodiments of the Invention and Abstract sections may set forth one or more but not all exemplary embodiments of the present invention as contemplated by the inventor(s), and thus, are not intended to limit the present invention and the appended claims in any way.","The present invention has been described above with the aid of functional building blocks illustrating the implementation of specified functions and relationships thereof. The boundaries of these functional building blocks have been arbitrarily defined herein for the convenience of the description. Alternate boundaries can be defined so long as the specified functions and relationships thereof are appropriately performed.","The foregoing description of the specific embodiments will so fully reveal the general nature of the invention that others can, by applying knowledge within the skill of the art, readily modify and\/or adapt for various applications such specific embodiments, without undue experimentation, without departing from the general concept of the present invention. Therefore, such adaptations and modifications are intended to be within the meaning and range of equivalents of the disclosed embodiments, based on the teaching and guidance presented herein. It is to be understood that the phraseology or terminology herein is for the purpose of description and not of limitation, such that the terminology or phraseology of the present specification is to be interpreted by the skilled artisan in light of the teachings and guidance.","The breadth and scope of the present invention should not be limited by any of the above-described exemplary embodiments, but should be defined only in accordance with the following claims and their equivalents."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS\/FIGURES","p":["The accompanying drawings, which are incorporated herein and form part of the specification, illustrate the present invention and, together with the description, further serve to explain the principles of the invention and to enable a person skilled in the pertinent art to make and use the invention. Various embodiments of the present invention are described below with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 1B","FIG. 1A"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7A"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7B"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
