---
title: Asynchronous bad block management in NAND flash memory
abstract: Methods for receiving data from a file system and storing it in a flash storage medium, wherein a bad block management process comprises queuing, at a bad block manager, one or more write requests, and receiving data associated with each of the one or more write requests and storing the received data in the bad block manager buffer; and performing cache management of data in the bad block manager buffer and subsequently returning a success status to the file system; and executing the one or more queued write requests in a separate task, wherein the executing comprises programming the received data to the flash storage medium during the bad block management process. Corresponding devices are also provided.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09483395&OS=09483395&RS=09483395
owner: ST-ERICSSON SA
number: 09483395
owner_city: Plan-les-Ouates
owner_country: CH
publication_date: 20110601
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","DESCRIPTION OF THE RELATED ART","DISCLOSURE OF THE INVENTION"],"p":["The present invention in general, relates to storage devices and more particularly to a NAND Flash.","Generally, the NAND memory or variants of NAND memory are commonly known to be used as storage devices on embedded platforms. As known in the state of the art, the NAND flash is divided into blocks and blocks in turn are divided into pages. Some part within a block is reserved for some spare bytes on a per page basis to store the ECC (error correction code) and some other metadata of the file system. Each block of NAND flash has limited program or erase cycle. Hence, software using NAND flash ensures that the program or erase cycle is evenly distributed across all the blocks in NAND flash to ensure that NAND flash has maximum life time. Such technique is generally known as wear levelling.","The NAND flash may also have bad blocks. NAND flash manufacturer does not guarantee any reliability of the data stored in bad blocks. NAND flash manufacturer guarantees that when the program or erase cycle is below the maximum allowed program or erase cycle of NAND, only a certain percentage of blocks may become bad. A NAND block becomes bad, when a program or erase operation on the block fails.","Apart from wear levelling and bad block management, the data stored in NAND flash pages may encounter bit flips. So, the data stored in the NAND flash pages need to be protected with ECC. For single level cell NAND, 1 bit ECC is sufficient, while for multi level cell NAND, 4 bit ECC or even higher ECC is required.","A storage architecture using NAND is illustrated in . The File system is responsible for wear levelling and file management within the NAND flash. The file system provides POSIX compliant file API to applications. A Bad block manager is responsible for bad block management and provides read, write, erase Application Programming Interface (API) to file system. The Bad block manager handles any program or erase error from a driver as bad block and copy the pages from bad block to a good block. The driver is responsible for implementing a NAND protocol as suggested by a NAND manufacturer. The driver layer provides read, write, and erase API to the bad block manager.","The most common method of the bad block management involves reserving a group of good blocks and replacing the bad blocks, which are encountered at run time with the reserved good blocks. The other method of bad block management involves skipping the bad blocks, which are encountered and using the next good block available. All the known bad block management system\/algorithms are synchronous. Hence the bad block management systems blocks the file system till the write, read or erase request is handled. Any bad block occurred during the write or erase request is handled in the context of the file system.","In some implementation, the bad block manager is part of the file system. In some other implementation, the bad block manager is part of the NAND driver.",{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 2"},"With higher NAND capacity the NAND programming time is increased. This slows down the write throughput at application. The first known solution to the problem is by introducing a queue buffer between the application and the file system.  illustrates the sequence of action done when copying a buffer from MMC or SD to NAND.","With the existing solution, there is no good overlap between MMC read, file system operation and NAND write. Typically, on a 52 MHz clock with 4 bit MMC, the read for a 2 KB page happens in \u02dc125 \u03bcs. The overhead of the file system during write (e.g. searching for a free page, updating meta data etc) and the driver overhead of copying the buffer to non-cacheable region, during write is \u02dc100 \u03bcs. The overhead of the NAND transfer and programming for 2 KB pages is \u02dc400 \u03bcs. In the existing solution, \u02dc125 \u03bcs time spent in MMC read is overlapped with 500 \u03bcs of the file system overhead and the NAND programming.","The subject matter disclosed herein is not limited to embodiments that solve any disadvantages or that operate only in environments such as those described above. Rather, this background is only provided to illustrate one exemplary technology area where some embodiments described herein may be practiced.",{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},"However, since the NAND can return error on a bad block from erase or program operation, the bad block manager needs to do a bad block management on the queued data and map it to a good block. The file system and the application can prepare the next write request when the bad block manager is programming the previous page. According to method of the present invention, the bad block management is not done synchronously blocking the file system till write and the bad block management is complete. The bad block management happens in a separate task.","After file system queues the request at the bad block manager queue, it can perform housekeeping operations on the request buffer containing both the page and spare area content. The housekeeping operations performed are cache management (e.g. in case of write, cleaning of cache lines holding the buffer to write back any dirty data to memory. In case of read, invalidate of the cache lines holding the buffer). In case of write, housekeeping operation includes the calculation of ECC and copy ECC to the buffer area containing the spare content. These operations are done in parallel to bad block manager programming the buffer from the previous request. As a result of this, after bad block manager completes a NAND page programming, it can immediately start with the transfer of the next page. If the host supports multiple NAND planes, then, bad block manager can start transfer of next buffer immediately after transferring the current buffer without waiting for the programming to finish. There is no limit on the amount of requests which can be queued at bad block manager.","Cache management typically includes cleaning of cache lines holding the bad block manager buffer to write any dirty data to a random access memory.","Accordingly, a first aspect of the invention provides a method for transferring data from a file system to a flash storage medium is provided, in which a bad block management process comprises:\n\n","According to an embodiment of the present invention, a queue is added at the bad block management module. The Bad block manager queues the write requests received from the file system and later programs to the NAND flash with the bad block management. When the bad block manager received a write request, it copies the write buffer to its private queue buffer and queues the write request. the bad block manager returns back success to file system immediately.","According to an embodiment, if a bad block is encountered during the programming of the flash storage medium, then the method further comprises:\n\n","According to some embodiments, the one or more write requests further comprise content for a spare area of a block of the flash storage medium.","According to some embodiments, in connection with the performing of the cache management, an error correction code corresponding to the one or more write requests and associated data is calculated from the bad block manager buffer and added to corresponding spare area of the bad block manager buffer.","According to some embodiments, when a queued write request is being actively executed, executing a further read request, write request, or erase request in the bad block manager buffer is blocked until the actively executed write request has finished.","According to some embodiments, when a size of an empty space in bad block manager is insufficient for receiving a write request, the bad block manager buffer is blocked for queuing further write requests.","According to some embodiments, if the bad block manager buffer contains a write request, then a read request or erase request following the write request is blocked from being queued in the bad block manager buffer.","According to some embodiments, if a number of bad blocks encountered exceeds a critical threshold, then disabling the bad block manager buffer and signaling a recoverable error to file system.","In another aspect, the invention provide a memory device for receiving data from a file system.","The memory device comprises:\n\n","Various embodiments of the device are configured to perform the further steps disclosed in relation to the first aspect of the invention.",{"@attributes":{"id":"p-0037","num":"0045"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0038","num":"0046"},"figref":"FIG. 6"},"When the bad block manager is handling a queued write request, if there is any other read, write or erase request then the request is blocked till the queued write request is handled completely. Such an example of a read request getting blocked is illustrated in .","If the number of bad blocks encountered by bad block manager exceeds a threshold (typically the maximum bad block defined by NAND manufacturer or reserved number of blocks) then bad block manager disables the queue feature. Any program or erase error from NAND after this point is reported as EIO error to file system, which in turn makes the storage as read-only.","According to an embodiment, the present invention is independent of the way bad block management system\/algorithm is implemented and it can be applied to any bad block management system\/algorithm.","According to yet another embodiment of the present invention, the placement of bad block manager within file system or driver or as an independent entity is not relevant and the present invention applies whichever way bad block management is done","The present invention achieves better overlap of application, file system operation with NAND programming. In the case of MMC to NAND throughput, it provides a throughput gain over 20%. In case of a streaming write, i.e. when continuously writing to file system from RAM, the throughput gain was more than 40%.","It should be appreciated that the invention is illustrated assuming that the system is a multi-tasking or multi-processor system. If the underlying system does not support this then the sequence chart may differ. However, the invention is valid for any type of system."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The features of the present invention will become better understood when the following description is read with reference to the accompanying drawings, wherein",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
