---
title: Data detection
abstract: An apparatus for processing a sequence of tokens to detect predetermined data, wherein each said token has a token type, and the predetermined data has a structure that comprises a predetermined sequence of token types, including at least one optional token type. The apparatus comprises a processor arranged to: provide a tree for detecting the predetermined data, the tree comprising a plurality of states, each said state being linked with at least one other state by a respective condition, the arrangement of linked states forming a plurality of paths; and compare the token types of the sequence of tokens to respective conditions in the tree to match the sequence of tokens to one or more paths in the tree, wherein the predetermined data can be detected without using an epsilon reduction to take account of said at least one optional token type.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09275169&OS=09275169&RS=09275169
owner: Apple Inc.
number: 09275169
owner_city: Cupertino
owner_country: US
publication_date: 20121106
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE DESCRIPTION","DETAILED DESCRIPTION"],"p":["This application is a continuation of co-pending U.S. application Ser. No. 12\/240,671 filed on Sep. 29, 2008, which claims the benefit of U.S. Provisional Patent Application No. 61\/059,722, filed on Jun. 6, 2008, which is herein incorporated by reference.","The present invention relates to the field of processing sequences of characters and, in addition, to detecting data included in such sequences of characters.","The processing of sequences of characters to analyze their grammatical structure is well-known, both for analyzing natural languages and computer languages. In the case of natural languages, the sequences of characters are broken down into words, each word forming a part of speech, such as noun, verb, adjective, adverb, preposition and no on. Thus, each word can be allocated a class according to its function in context.","For the processing of computer languages, it is well known to process the sequence of characters in a lexer to break the characters into a sequence of tokens and then to parse the tokens to create some form of internal representation, which can then be used in a compiler or an interpreter.","Such processing has previously been used to analyze sequences of characters to extract useful information from the sequence. For example, techniques have been developed to analyze blocks of text, such as e-mails or other data received by or input to a computer, to extract information such as e-mail addresses, telephone and fax numbers, physical addresses, IP addresses, days, dates, times, names, places and so forth. In one implementation, a so-called data detector routinely analyses incoming e-mails to detect such information. The detected information can then be extracted to update the user's address book or other records.","Conventionally, such data detection is performed using a layered engine as shown in . The engine is embodied in a processor  and comprises a lexical analyzer or lexer  and a parser . The lexer  receives as its input a sequence of characters, such as the characters in an e-mail message. Note that the characters are not limited to letters or even numbers, but may include any other characters, such as punctuation.","The lexer  stores a vocabulary that allows it to resolve the sequence of characters into a sequence of tokens. Each token comprises a lexeme (analogous to a word) and a token type (which describes its class or function). One token type is provided for each predetermined function. As an example, a simple lexer  may include the following vocabulary:\n\n","The lexer  would break down the string of characters \u201cThere are 2 books and 15 magazines\u201d into the following tokens:",{"@attributes":{"id":"p-0010","num":"0013"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"126pt","align":"center"}}],"thead":{"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Lexeme","Token Type"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"THERE","WORD"]},{"entry":[{},"ARE","WORD"]},{"entry":[{},"\u20022","DIGIT"]},{"entry":[{},"BOOKS","WORD"]},{"entry":[{},"AND","WORD"]},{"entry":[{},"15","NUMBER"]},{"entry":[{},"MAGAZINES","WORD"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}}},"The parser  receives the sequence of tokens from the lexer . The parser  includes a grammar, which it uses to analyze the tokens to extract predetermined data. For example, if the engine  is intended to detect all quantities, the parser 's grammar may be that:\n\n","Commonly, both the lexer  and the parser  use a decision tree. An example of such a decision tree for a further example of a lexer  is shown in . In this case, the lexer  includes the following vocabulary:\n\n","For example, if the lexer  is presented with the sequence of characters \u20181984\u2019, it will process the character \u20181\u2019 first. State S only allows the processing to proceed if the first character is \u20181\u2019. This condition is met so character \u20181\u2019 is consumed and processing proceeds to state , where the next character in the sequence (\u20189\u2019) is compared with the available conditions. It should be noted that state  is represented using a dotted circle. This is indicative that processing may not end at this state without the branch dying, as will become apparent later.","The only available condition at state  is that the next character is \u20189\u2019. This condition is met, so character \u20189\u2019 is consumed and processing proceeds to state .","The conditions at state  are that processing should proceed to state  if the next character is \u20185\u2019, or that it should proceed to state  if the next character is any one of 0, 1, 2, 3, 4, 6, 7, 8 or 9. Again, state  is represented using a dotted circle and processing may not end at this state.","The next character is \u20188\u2019, which meets the condition for processing to proceed to state , which is also represented by a dotted circle. Accordingly, the \u20188\u2019 is consumed and processing continues. Since the next character in the sequence (\u20184\u2019) meets the only available condition from state , processing proceeds to state .","State  is represented by a solid circle, indicating that processing may end there. As shown in , state  has the property of reducing the consumed characters to a token of token type \u2018a\u2019. In our example, since all the characters have been used up and there are no more characters, processing ends at state  and the consumed sequence of characters is reduced to a token comprising the lexeme \u20181984\u2019 and the token type \u2018a\u2019.","Similarly, the lexer  in  would process the sequence of characters \u2018195\u2019 as set out below. First, characters \u20181\u2019 and \u20189\u2019 would be consumed in the same manner as described above. However, at state , the next character is \u20185\u2019. This meets the condition for proceeding to state , which has the property of reducing the consumed characters to a token of token type \u2018b\u2019. In this case, since all the characters have been used up and there are no more characters, processing ends at state  and the consumed sequence of characters is reduced to a token comprising the lexeme \u20181985\u2019 and the token type \u2018b\u2019.","By contrast, the lexer  in  would process the sequence of characters \u20181955\u2019 as set out below. First, characters \u20181\u2019, \u20189\u2019 and \u20185\u2019 would be consumed in the same manner as described above. However, at state , not all the characters have been used up. Rather, a further \u20185\u2019 remains, which meets the condition for proceeding to state , where the consumed sequence of characters is reduced to a token comprising the lexeme \u20181955\u2019 and the token type \u2018a\u2019.","Now consider a parser  including the following grammar:\n\n","A decision tree for this grammar is shown in  and includes start state S, finish state F, and processing states -. As the parser  processes a sequence of tokens, it checks the first token in the sequence against the options available at the start state S and proceeds according to the result.","For example, if the parser  is presented with the sequence of tokens comprising a token having token type c, followed by a token having token type e, the parser  must process the token-type sequence \u2018ce\u2019. The following table represents the processing that takes place.",{"@attributes":{"id":"p-0023","num":"0031"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Current state","Sequence to process","Previous states"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["S","ce",{}]},{"entry":["0","e","S"]},{"entry":["1",{},"S, 0"]},{"entry":["S","E",{}]},{"entry":["F",{},"S"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Put simply, proceeding from the start state S, the parser  consumes a \u2018c\u2019 and proceeds to state , and then consumes an \u2018e\u2019 and proceeds to state . State  allows processing to finish with the reduction to go back two states and replace the consumed letters by an \u2018E\u2019. Processing then returns to the start state S, where the E is processed. The E is consumed as processing proceeds to the finish state F. Thus, the token type sequence c followed by e is parsed as having the grammatical or data type E.","Similarly, the token sequence \u2018acd\u2019 is processed using the parsing tree shown in  as shown in the following table:",{"@attributes":{"id":"p-0026","num":"0034"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Current state","Sequence to process","Previous states"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["S","acd",{}]},{"entry":["5","cd","S"]},{"entry":["S","Acd",{}]},{"entry":["2","cd","S"]},{"entry":["3","d","S, 2"]},{"entry":["4",{},"S, 2, 3"]},{"entry":["S","E",{}]},{"entry":["F",{},"S"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Here, the first token type to be parsed is \u2018a\u2019. Starting at start state S, the \u2018a\u2019 is consumed and processing proceeds to state , which has the reduction to go back one state and replace the consumed items with an \u2018A\u2019. Thus, the sequence is changed from \u2018acd\u2019 to \u2018Acd\u2019 and processing returns to state S, where the A is consumed and processing proceeds to state . Next, as processing proceeds along the middle branch of the tree to states  and , the c and the d are consumed. At state , the consumed sequence Acd is replaced by an E and processing returns to state S, where the E is processed. The E is consumed as processing proceeds to the finish state F. Thus, the token type sequence a followed by c followed by d is also parsed as having the grammatical or data type E.","Similarly, the token sequence \u2018cd\u2019 is processed using the parsing tree shown in  as shown in the following table:",{"@attributes":{"id":"p-0029","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Current state","Sequence to process","Previous states"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["S","cd",{}]},{"entry":["S","Acd",{}]},{"entry":["2","cd","S"]},{"entry":["3","d","S, 2"]},{"entry":["4",{},"S, 2, 3"]},{"entry":["S","E",{}]},{"entry":["F",{},"S"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Here, the first token type to be parsed is \u2018c\u2019. Starting at start state S, the \u2018c\u2019 is consumed and processing proceeds to state . The next token type to be parsed is a \u2018d\u2019, but state  does not provide an option for proceeding with this token type. Moreover, state  is represented by a dotted circle, indicating that processing cannot finish at that state. Accordingly, this branch is a \u201cdead\u201d branch and processing reverts with the entire sequence intact to the start state S. This state is provided with the reduction that an \u2018A\u2019 must be placed at the front of the sequence. Thus, the sequence to be parsed is now \u2018Acd\u2019. This is the same sequence as is generated during processing of the sequence acd above, and processing proceeds in exactly the same way. Thus, the token sequence c followed by d is also parsed as having the grammatical or data type E.","In particular, the example illustrates how the epsilon symbol is handled. Specifically, an additional path is provided, the additional path comprising a link between the start state S and state . This path is taken when the first token is an \u2018a\u2019, which is consequently consumed and replaced with an \u2018A\u2019.","Importantly, the when all of the conditions of the start S lead to a dead branch, the reduction associated with the start state S is performed. This reduction involves producing a new token (in this case an \u2018A\u2019) and adding it to the front of the sequence of tokens without first consuming a token. Put another way, in this reduction the sequence of tokens is revised by adding a token to the beginning and then comparing the revised sequence with the conditions of the same state. This type of reduction is known as an epsilon reduction.","In this way, it can be seen that the parsing tree shown in  is consistent with the grammar:\n\n","In more detail, the lexer  will output a sequence of a letter from A to Z followed by another letter from A to Z as a token having a lexeme of the two letters and having the token type INTIALS. It will also output the letters AM and PM as a token having the token type MERIDIAN. In this notation \u2018?\u2019 indicates that the preceding character(s) may or may not be present. Thus, the lexer  will also output the letter A alone, or the letter P alone as a token having the token type MERIDIAN.",{"@attributes":{"id":"p-0035","num":"0051"},"figref":["FIG. 4","FIG. 5","FIG. 4"],"b":["10","20","10","10","20"]},"As noted above, the two tokens both have the lexeme AM and the respective token types INITIALS and MERIDIAN. Accordingly, when the character string AM occurs, two sequences of tokens are processed by the parser  using the decision tree shown in . One sequence of tokens meets the first condition of the starting state, while the other sequence of tokens meets the other condition. Accordingly both conditions or branches are investigated, either in turn or in parallel.","In the case of the left-hand INITIALS branch, the processing proceeds to state  and then states  and , since the next two tokens have the token type DIGIT. However, the parser  then runs out of tokens to parse and so cannot proceed to state . Since state  is represented by a dotted circle, processing cannot end there and so a BUG_ID is not detected.","In the case of the right-hand MERIDIAN branch, the processing proceeds to state  and then states  and , since the next two tokens have the token type DIGIT. At state  it is determined that the sequence of tokens MERIDIAN followed by DIGIT and DIGIT represents TIME. In this way, a time is detected.","In some cases, in real life situations it is possible to detect two different types of information (eg TIME and BUG_IDENTIFICATION) from the same sequence of characters, for example where the results are overlapping. For instance in the BUG_ID\/TIME example, consider the character sequences \u201cAM12\u201d in \u201cAM123\u201d. Within \u201cAM123\u201d we could recognize both a time (characters 1 to 4), and a bug identification code (characters 1 to 5). In such an event, it is common practice to provide an additional filter to determine which of the two detected types of information is more likely to be the correct one. One commonly-used heuristic that has proven efficient is to keep only the longest result\u2014in this case, the bug identification code.","As another example, the parser may be provided with the grammar\n\n","Accordingly, to detect an address, it is only necessary for a street to be present, a name and\/or a company in front of the street being optional. Thus, an epsilon reduction is required for both the name and company. Using the tokens a, b and, c, the grammar can be rewritten as\n\n",{"@attributes":{"id":"p-0042","num":"0063"},"figref":"FIG. 6","b":["20","1","1","2","5","5","2"]},"Such a methodology can be applied to many different types of grammar and data structures and has previously been found to be particularly successful in extracting predetermined types of data from sequences of characters. However, in view of the increasing calls on the processors of user and server computers to carry out numerous tasks (including data detection), combined with the increasing volume of information that needs to be scanned and the increasingly complex and numerous types of information it is desired to detect, it is desirable to increase the speed with which such data detection can be carried out.","Method, systems and machine-readable storage media for processing a sequence of tokens are described. In one embodiment, a method for processing a sequence of tokens includes providing a tree for detecting predetermined data that has a structure that includes a predetermined sequence of token types and comparing the token types of the sequence of tokens to respective conditions in the tree to match the sequence of tokens to one or more paths in the tree. The predetermined data can, in one embodiment, be detected without an epsilon reduction to take into account of at least one optional token type. The tree includes a plurality of states, each being linked with at least one other state by a respective condition, and the arrangement of linked states form a plurality of paths. Other methods are also described, and systems and machine-readable storage media which perform these methods are also described.","The present invention is generally related to lexing and parsing sequences of characters. In particular, some embodiments of the present invention related to the removal of epsilon reductions in lexing and parsing characters in order to improve the overall efficiency.","It is noted that where an optional token type is included, processing for that optional token will always use the same branch or path. Accordingly, in the example in , a path including the link S- (path S---) is followed both when an \u2018a\u2019-type token is included in the sequence of tokens being processed (acd) and when an \u2018a\u2019-type token is not included (cd). Similarly, in  a path including the link S- (path S---) is always followed both when the optional \u2018name\u2019 token type is included in the sequence (name company street; name street) and when it is not (company street; street). Again, in  a path including the link - (path S---) is always followed both when the optional \u2018company\u2019 token type is included in the sequence (name company street; company street) and when it is not (name street; street). This appears an elegant and efficient way of processing data.","However, processing is particularly wasteful when the data to be detected does not exist within the sequence. For example, consider using the decision tree shown in  to attempt to detect an E in the sequence \u2018ged\u2019. Since g is the first token type, none of the conditions of the starting state S is met. Accordingly, the epsilon reduction for the starting state S is used and an \u2018A\u2019 is added to the front of the sequence, so that the current sequence becomes \u2018Aged\u2019. Subsequently, the \u2018A\u2019 is consumed and processing proceeds from state S to state . The condition for state  is not met and state  is represented by a dotted circle, which means that processing cannot end with at state. The branch therefore dies uselessly. It will be apparent that when scanning a large block of text, such wasted processing will occur a large number of times just to handle a single epsilon reduction in a query for a single, simple type of predetermined data. In real life examples, a huge amount of processing capacity is wasted in investigating such dying branches.","Moreover, even when the type of data to be detected exists within the sequence of tokens being processed, processing is inefficient. In particular, it is necessary to convert the token from \u2018a\u2019 to an \u2018A\u2019, requiring the path from state S to state  and the reduction for state , and it is also necessary to provide the epsilon reduction at state S to pop up an \u2018A\u2019 in front of the current sequence according to the conventional approach. In either case, two lots of processing must take place\u2014the initial processing to cope with the fact that the token type is optional, by revising the sequence to include an \u2018A\u2019 in it, and the subsequent processing to detect the data using the revised sequence. Thus, the conditions of state S must be checked against twice in the processing.","Where two or more epsilon reductions are included in a conventional decision tree, as shown in , the reduction in efficiency is significantly compounded.","Some embodiments of the present invention provide a solution to improve the efficiency of lexing and parsing, which are described below by way of example.","In some embodiments, the solution provided by the present invention is to remove epsilon reductions from the decision tree. More particularly, states are removed from the decision tree that produce an additional token without reverting to an earlier state (that is, without a token being consumed) when all of the conditions of that state are unmatched or lead to dying branches. This is achieved by instead providing an additional path in the tree, so that one path can directly be used to detect the required data when the token sequence includes the optional token type and another, separate path can directly be used to detect the required data when the token sequence does not include the optional token type.","As an example, the decision tree of  modified in accordance with some embodiments of the present invention is shown in . Here it can be seen that the epsilon reduction for the starting state has been removed and instead a new path has been provided in the tree. The new path is formed by new state  and the link between it and state . To reach state , a new condition has been added to state . Moreover, the starting state is now represented by a dotted circle, indicating that processing cannot end there.","For example, if the decision tree used in  is used to process the token-type sequence \u2018cc\u2019, the following table represents the processing that takes place.",{"@attributes":{"id":"p-0067","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Current state","Sequence to process","Previous states"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["S","ce",{}]},{"entry":["0","e","S"]},{"entry":["1",{},"S, 0"]},{"entry":["S","E",{}]},{"entry":["F",{},"S"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Similarly, the token sequence \u2018acd\u2019 is processed using the parsing tree shown in  as shown in the following table:",{"@attributes":{"id":"p-0069","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Current state","Sequence to process","Previous states"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["S","Acd",{}]},{"entry":["5","Cd","S"]},{"entry":["S","Acd",{}]},{"entry":["2","Cd","S"]},{"entry":["3","D","S, 2"]},{"entry":["4",{},"S, 2, 3"]},{"entry":["S","E",{}]},{"entry":["F",{},"S"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"However, the token sequence \u2018cd\u2019 is processed using the parsing tree shown in  as shown in the following table:",{"@attributes":{"id":"p-0071","num":"0092"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"70pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"84pt","align":"center"}}],"thead":{"row":[{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Current state","Sequence to process","Previous states"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["S","cd",{}]},{"entry":["0","d","S"]},{"entry":["6",{},"S, 0"]},{"entry":["S","E",{}]},{"entry":["F",{},"S"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"Here, proceeding from the start state S, the parser  consumes a \u2018c\u2019 and proceeds to state , and then consumes a \u2018d\u2019 and proceeds to state  rather than state . State  allows processing to finish with the reduction to go back two states and replace the consumed letters by an \u2018E\u2019. Processing then returns to the start state S, where the E is processed. The E is consumed as processing proceeds to the finish state F. Thus, the token sequence \u2018ce\u2019 is parsed as having the grammatical or data type E.","It can immediately be seen how processing is made more efficient by the above embodiments of the present invention. In particular, for each possible sequence of tokens that can form the structure of data E, a path is provided that leads directly to the data being detected. Accordingly, it is not necessary to produce an additional \u2018A\u2019 at the front of sequence in order to allow for the fact that an \u2018a\u2019-type token can but need not be included in the sequence. Note that where the sequence of tokens makes up the data to be detected, the data is detected much faster.","Importantly, where the sequence of tokens does not include the data to be detected, since there is no epsilon reduction at the starting state, it is immediately detected that the data is not present. For example, if the sequence \u2018gcd\u2019 is processed, the first token in the sequence (\u2018g\u2019) does not match any of the conditions of the starting state and so is discarded. Starting state S is now represented by a dotted line and no longer has a reduction associated with it. Accordingly, none of previous processing (of performing the epsilon reduction for the starting state S to add an \u2018A\u2019 to the front of the sequence, proceeding from state S to state , and recognizing that the condition for state  is not met) takes place. Consequently, a huge amount of processing is saved by avoiding the investigation of dying branches.","In some embodiments, the removal of the epsilon reduction from the starting state allows further efficiency gains. Specifically, the path from the starting state S to state  and the reduction of state  can be removed simply by changing the condition associated with the path from state S to state  to require an \u2018a\u2019 instead of an \u2018A\u2019. Once state  and its associated reduction are removed from the decision tree shown in , it can be seen that the total number of states is 8 (including states S and F) and the total number of reductions is 3. This compares with 8 states and 4 reductions in . Accordingly, in this example, not only is data detection considerably faster, the size of the cache required to store the tree is also reduced.",{"@attributes":{"id":"p-0076","num":"0097"},"figref":["FIG. 8","FIG. 6","FIG. 8"],"b":["2","1","7","5"]},"In the same way, at least two paths are provided for the case where the \u2018company\u2019 token is present\u2014a path including the link S- and a path including the link -. Moreover, at least two paths are provided for the case where the \u2018company\u2019 token is not present\u2014a path including the link S- and a path including the link -. It will be apparent that several of the paths provided to handle the optionality of the \u2018company\u2019 token correspond with the paths provided to handle the optionality of the \u2018name\u2019 token.","In common with the previous example, no state has an epsilon reduction and if data type E is included in a sequence of characters, it will always be detected by taking a single path straight through the tree according to some embodiments of the present invention. Again, if none of the conditions of the start state is matched, processing immediately ceases. This processing is highly efficient and extremely rapid compared with the prior art.","However, the present invention is not limited to the removal of epsilon reductions from all states, or even from the starting state. As an example,  shows a different way in which the decision tree in  can be improved in line with some embodiments of the present invention. In , the epsilon reduction for the optional \u2018name\u2019 token is removed. Thus, a path is provided for the case where a \u2018name\u2019 token is present\u2014a path including the link S- followed by any other states. Moreover, since the \u2018company\u2019 token is optional, two paths are provided for the path where the \u2018name token\u2019 is not present\u2014a path including the link S- and a path including the link S-. However, in this example the epsilon reduction for the optional \u2018company\u2019 token is maintained. Indeed, two \u2018company\u2019 epsilon reductions are provided\u2014one for the case where the \u2018name\u2019 token is present and one for the case where the \u2018name\u2019 token is not present.",{"@attributes":{"id":"p-0080","num":"0101"},"figref":["FIG. 10","FIG. 6","FIG. 10"],"b":["2","4","2","3"]},"In summary, in some embodiments of the present invention, at least one epsilon reduction is removed for the case where a data structure includes at least one optional token type. Furthermore, an epsilon reduction at the starting state may be removed. In this case, if one of the starting state conditions is not met, it is immediately determined that the sequence does not include the type of data being searched for.","In some embodiments, for a data structure having a predetermined sequence of token types, at least one of which is optional, a path is provided in the tree for the predetermined sequence including the optional token type and a separate path is provided for the predetermined sequence without the optional token type. Thus, it is possible to detect predetermined data in a sequence of tokens without adding a token to the sequence to take account of an optional token type.","In some embodiments, where the sequence is revised by adding a token to the beginning of the sequence and then comparing the revised sequence with the condition or conditions of the same state, the association of a reduction with any state is prohibited.","Embodiments of the present invention has a wide variety of applications. For example, it may be used in scanning e-mails and blocks of text, such as those created in word processing packages. Moreover, it can be used in any application where sequences of characters are processed, such as in compilers and interpreters. Embodiments of the present invention may be implemented using any suitable apparatus. Such an apparatus may include, but is not limited, to data processing machines and devices, for example laptop or notebook computers, other user and server computers, and mobile communications devices, such as mobile telephones, personal digital assistants and so forth.","As an example,  shows an arrangement comprising a user computer , a notebook computer , and a cell phone , where one, some or all devices may have a processor  adapted to operate in accordance with the present invention. In the present example, at least the notebook computer  and the cell phone  have such a processor . A first user may compose a message and send it by e-mail to a second user. The second user may retrieve the message over the Internet  using his notebook computer . Upon retrieval of the message, an application embodying one embodiment of the present invention may automatically scan the message to detect whether it includes predetermined data, such as a time, a date, a name, an address and so forth. On detection of a time and a date, the application may notify the second user and provide him with the option of updating his calendar. Similarly, on detection of names, addresses, phone numbers and so forth, the application may notify the second user and provide him with the option of updating his address book. In addition, the second user may retrieve the message using his mobile phone  via the Internet  and a telecommunications base station . Again, an application embodying the present invention may detect predetermined data and provide the option of updating the user's records with the detected data.","It is also conceived that the present invention may be embodied using two or more different devices in some embodiments. For example, one device could carry out the lexing function and the other the parsing function.","The present invention may also be used to extract data included in mobile phone messages, such as SMS text message and MMS messages, in some embodiments.","The present invention may also be embodied in software causing a data processing device to carry out the invention, as well as in computer-readable media on which such software is stored. Moreover, the present invention may be embodied in dedicated hardware or general-purpose hardware.","The present invention can relate to an apparatus for performing one or more of the operations described herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general-purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a machine (e.g. computer) readable storage medium, such as, but is not limited to, any type of disk including floppy disks, optical disks, CDROMs, and magneticoptical disks, readonly memories (ROMs), random access memories (RAMs), erasable programmable ROMs (EPROMs), electrically erasable programmable ROMs (EEPROMs), flash memory, magnetic or optical cards, or any type of media suitable for storing electronic instructions, and each coupled to a bus.",{"@attributes":{"id":"p-0090","num":"0111"},"figref":"FIG. 12"},"In some embodiments, the computer system  may be used as a server computer system or as a client computer system or as a web server computer system. It will be appreciated that such a computer system may be used to perform many of the functions of an Internet service provider, such as ISP . The computer system  interfaces to external systems through a modem or network interface . It will be appreciated that the modem or network interface  may be considered part of the computer system . This network interface  may be an analog modem, an ISDN modem, a cable modem, a token ring interface, a satellite transmission interface (e.g. \u201cDirect PC\u201d), or other interfaces for coupling a digital processing system to other digital processing systems. The computer system  includes a processor  which may be a conventional microprocessor, such as a Motorola PowerPC microprocessor or an Intel Pentium microprocessor. Memory  is coupled to the processor  by the bus . Memory  may be dynamic random access memory (DRAM) and may also include static RAM (SRAM). The bus  couples the processor  to the memory  and also to mass memory  and to display controller  and to the I\/O (input\/output) controller . Display controller  controls in the conventional manner a display on the display device  which may be a CRT or a liquid crystal display device. The input\/output devices  may include a keyboard, disk drives, printers, a scanner, a digital camera, and other input and output devices, including a mouse or other pointing device. The display controller  and the I\/O controller  may be implemented with conventional well known technology. The mass memory  is often a magnetic hard disk, an optical disk, or another form of storage for large amounts of data. Some of this data is often written, by a direct memory access process, into memory  during execution of software in the computer system . It will be appreciated that the computer system  is one example of many possible computer systems which have different architectures. For example, Macintosh or Wintel systems often have multiple busses, one of which may be considered to be a peripheral bus. Network computers may also be considered to be a computer system which may be used with the present invention. Network computers may not include a hard disk or other mass storage, and the executable programs are loaded from a network connection into the memory  for execution by the processor . A Web TV system, which is known in the art, may be considered to be a computer system according to the present invention, but it may not include certain features shown in , such as certain input or output devices. A cell phone having a suitable display and a processor and memory may also be considered to be a digital processing system or a computer system, which may be used with the present invention. A typical computer system usually include at least a processor, memory, and a bus coupling the memory to the processor. It will also be appreciated that the computer system  is typically controlled by an operating system, which includes a file management system, such as a disk operating system, which is part of the operating system software.","A machine-readable medium includes any mechanism for storing or transmitting information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium includes read only memory (\u201cROM\u201d); random access memory (\u201cRAM\u201d); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, or other form of storage systems.","It will be apparent from this description that aspects of the inventions may be embodied, at least in part, in software. That is, the techniques may be carried out in a computer system or other data processing system in response to its processor or processing system executing sequences of instructions contained in a memory, such as RAM, etc. In various embodiments, hardwired circuitry may be used in combination with the software instructions to implement the present inventions. Thus, the techniques are not limited to any specific combination of hardware circuitry and software, nor to any particular source for the instructions executed by the data processing systems.","The foregoing description has been given by way of example only and it will be appreciated by a person skilled in the art that modifications can be made without departing from the spirit and scope of the present invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["Embodiments of the present invention will now be described by way of further example only and with reference to the accompanying drawings, in which:",{"@attributes":{"id":"p-0046","num":"0067"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0047","num":"0068"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0048","num":"0069"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0049","num":"0070"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0050","num":"0071"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0051","num":"0072"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0052","num":"0073"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0053","num":"0074"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0054","num":"0075"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0055","num":"0076"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0056","num":"0077"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0057","num":"0078"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
