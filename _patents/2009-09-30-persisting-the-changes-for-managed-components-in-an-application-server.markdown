---
title: Persisting the changes for managed components in an application server
abstract: A method and a system maintain a change to a component in an application server after the application server is re-started. The application server can be a Java-based application server that runs on a computer coupled to a management console. Through the management console, the application server receives an updated value of a component during runtime of the component. A profile service in the application server associates the component to a deployment descriptor that refers to an original value of the components. A representation of the component is then created and stored in a persistence data format in non-volatile data storage. The representation includes the updated value and indicates an association of the component with the deployment descriptor. When the application server is re-started, the representation is applied to the deployment descriptor to override the original value with the updated value.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08499294&OS=08499294&RS=08499294
owner: Red Hat, Inc.
number: 08499294
owner_city: Raleigh
owner_country: US
publication_date: 20090930
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","DETAILED DESCRIPTION"],"p":["Embodiments of the present invention relate to computer programming, and more specifically, to a Java-based application server.","An application server is a software engine that delivers applications to client computers or devices. An application server typically bundles middleware to enable applications to intercommunicate with dependent applications, like web servers, database management systems, and chart programs. Middleware is computer software that connects and integrates software components (\u201ccomponents\u201d) or applications. Middleware is used most often to support complex, distributed applications.","Managing the components in an application server can be a complex task. Conventional techniques do not provide an efficient mechanism for managing the properties of a component. A system administrator may wish to modify a component at runtime to satisfy a specific service requirement. However, performing the modification can be cumbersome and the modification may not survive a restart of the application server.","Described herein is a method and system for maintaining a change to a component in an application server after the application server is re-started. In one embodiment, the application server is a Java-based application server that runs on a computer coupled to a management console. Through the management console, the application server receives an updated value of a component during runtime of the component. A profile service in the application server associates the component to a deployment descriptor that defines deployment specific values. A representation of the component is then created and stored in a persistence data format in non-volatile data storage. The representation includes the updated value and indicates an association of the component with the deployment descriptor. When the application server is re-started, the representation is applied to the deployment descriptor to override the original value with the updated value.","An advantage of the profile service described herein is that an update made during the runtime of a component can persist a restart of the application server. The term \u201ccomponent\u201d refers to a reusable software program that can be developed and assembled easily to create sophisticated applications. An application server generally runs a component that has been compiled into an archive, e.g., .jar files, .ear files, etc. The component can have a number of properties, with each property having a value that comes with the archive (referred to as \u201can original value). Some of the properties are called \u201cmanaged properties,\u201d which can be managed by a system administrator through a management console. The components having the managed properties are called \u201cmanaged components.\u201d The value of a managed property can be updated by the system administrator at runtime. The update does not modify the archive. Instead, the update is stored persistently in non-volatile data storage, and can automatically be applied to the component at runtime, as well as when the application server is re-started. Direct updating of the archive is undesirable, because the archive would first need to be uncompressed, updated with the changes, and then re-packed. The persistence operations to be described herein not only manage the persistence of the changes, but also automatically map the data format of the update to a persistence data format that is compatible with the type of the container in the application server and the requirement of the service provider.","In the following description, numerous details are set forth. It will be apparent, however, to one skilled in the art, that the present invention may be practiced without these specific details. In some instances, well-known structures and devices are shown in block diagram form, rather than in detail, in order to avoid obscuring the present invention.","Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise, as apparent from the following discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201creceiving\u201d, \u201cassociating\u201d, \u201cstoring\u201d, \u201capplying\u201d, \u201cdispatching\u201d, or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","The present invention also relates to an apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), EPROMs, EEPROMs, magnetic or optical cards, or any type of media suitable for storing electronic instructions, each coupled to a computer system bus.","The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear as set forth in the description below. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.","The present invention may be provided as a computer program product, or software, that may include a machine-readable medium having stored thereon instructions, which may be used to program a computer system (or other electronic devices) to perform a process according to the present invention. A machine-readable medium includes any mechanism for storing or transmitting information in a form readable by a machine (e.g., a computer). For example, a machine-readable (e.g., computer-readable) medium includes a machine (e.g., a computer) readable storage medium (e.g., read only memory (\u201cROM\u201d), random access memory (\u201cRAM\u201d), magnetic disk storage media, optical storage media, flash memory devices, etc.), a machine (e.g., computer) readable transmission medium (electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.)), etc.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","120","100","120","120","140"]},"The term \u201ccomponent model\u201d refers to a collection of components and the interactions among these components. Components are reusable software programs that can be developed and assembled easily to create sophisticated applications. For example, JMX MBeans is a component model and MBeans are the components. With JMX MBeans, interactions among the MBeans include executing MBean operations, referencing attributes, setting attributes and declaring explicit dependencies between named MBeans. Interactions among the components of other component models can be similarly described.","In one embodiment, the application server  includes a container, such as a microcontainer , to support the services . The term \u201ccontainer\u201d herein refers to a software construct (e.g., class) that holds or organizes software objects (e.g., Java objects). A container also includes methods for adding and removing objects, as well as methods for iterating the addition and removal of the objects. The microcontainer  processes the components from various component models through a sequence of deployment stages to generate fully installed components that run on a Java Virtual Machine (JVM) . The components can be plug-in components. At runtime, the microcontainer  integrates the components and applies dependencies and aspects across the components. Thus, the microcontainer  serves as an integration spine for the various components of various component models. Although the microcontainer  is shown, it is understood that the container in the application server  can include a JMX container, an EJB3 container, or a container for a different component model.","In one embodiment, the application server  also includes a profile service , which is a module that provides a runtime infrastructure for dynamically configuring deployed components (also referred collectively as a deployment). The profile service  can be software, hardware, or a combination of both. The profile service  is responsible of finding or discovering deployments in a repository or a folder of the file system. The profile service  aggregates metadata generated by deployers when the components are deployed. The metadata describes the structure and dependencies of the deployments, as well as the configuration settings of the deployments. Based on the information, the profile service  manages lifecycles of the deployments, e.g., when to start and end a deployment, and determines the objects to instantiate when the deployments start. The profile service  also manages updates to the deployments. For example, if a property of a deployment is changed, the profile service  will propagate the change to the components of the deployment that uses the property.","There are many ways a change can be made to a deployment. For example, an update can be made to a managed property of a deployment through a management interface . An update can also be made by adding plug-ins to a deployment at runtime. In one embodiment, the management interface  includes a user application programming interface (API) for an administrator to access managed properties of a deployment. The user API can provide a view (e.g., a management view ) of the managed properties and their values via a management console . In one embodiment, the management console includes a display coupled to the computer system , either directly or via a network (e.g., a local network or a wide-area communication network). The functionalities of the management interface  and the management view  provide the system administrator with the ability, for example, to configure the value a managed property (also referred to as \u201cmanaged value\u201d), remove a bug and add missing interfaces.","For example, a managed property of a component can be \u201cmin-pool-size,\u201d which is a configurable property specific to a type of a component. The \u201cmin-pool-size\u201d defines the initial size of a connection pool to a data source, such as a database. A system administrator can change the value of the \u201cmin-pool-size\u201d via the management view .","When a system administrator updates a component, e.g., by updating a component, adding a component, or removing a component, the change overrides the existing values of the component. The change is also recorded by a persistence module  of the profile service , such that when the application server  is re-started, the change persists the re-start and will be automatically applied to the component.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 2","b":["120","120","210","110","210","220","160"]},"In one embodiment, the profile service  includes the management interface  and the persistence module . The profile service  further includes a persistence store , a persistence factory , a component mapper  and a value mapper . The persistence store  manages the changes to a component made by a system administrator during the runtime. The persistence store  calls the persistence factory  to perform persistence changes to the component, creates a representation of the change to the component, and stores the representation into storage  (e.g., disks or other non-volatile storage). In one embodiment, the representation is an Extensible Markup Language (XML) representation .","In one embodiment, the end user API (e.g., the management view ) is wrapped in the persistence factory . The persistence factory  exposes persistence operations, including addComponent, updateComponent, removeComponent. To perform these operations, a number of parameters need to be identified, which include: the persistence root associated with the component, which points to the XML representation  of the component, a deployment descriptor associated with the component, and the component that is being modified. Further, the persistence factory  also exposes a restore operation restorePersistenceRoot to restore the updated value from the original value of the component after a restart of the application server .","The component mapper  can be used to identify a changed component for a give component model. The component mapper  can also be used to identify a component after a restart of the application server  or after a \u201cname\u201d (unique identifier) change to the component. The container of each component model can have a different unique name for its components. For example, a JMX container uses an ObjectName, a microcontainer uses a normal String by default, and an EJB3 container uses the deployment name plus the deployment descriptor name. The component mapper  is usually bound to a specific component type (component model), and then identifies the component based on its specific identifier; e.g., the bean name, the ObjectName or a set of properties which build the unique identifier. After a component is identified, the persistence module  can properly map the component to its deployment descriptor and create the XML representation  including the mapping or an association describing the mapping.","The value mapper  may be plugins that map the value entered by a system administrator to a pre-defined persistence data format. The persistence data format can be the format of the deployment descriptor associated with the component, and is defined by a service provider or the container. For example, the persistence data format can include String, Integer, Collections, Arrays, etc. In one embodiment, both of the component mapper  and value mapper  are used when a change is made to a component. The results produced by the mappers  and  are used to create the XML representation . It is understood that each of the persistence store , the persistence factory , the component mapper  and the value mapper  can be implemented by software, hardware, or a combination of both.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 3","FIG. 6","FIGS. 1 and 2"],"b":["300","300","626","300","160"]},"Referring to , in one embodiment, the method  begins when the profile service  is invoked, via the management interface , by a system administrator to display the management view  on the display of the management console  (block ). The management interface  receives original values of the components (block ), and determines whether any of the original values is to be replaced by a previous change (block ). The original values of the components are pre-defined managed values in the compiled archive (e.g., a jar file, an ear file, etc.) of an application that is running on the application server  for providing a business service. If an update to an original value has been made previously, the update overrides the original value and is displayed as the current value of the component. If there has been no change to the original value, the original value is displayed as the current value of the component. The management view  thus exposes (e.g., displays) the managed components in a deployment and their current values on the display.","During the runtime, the system administrator may enter an updated value to replace a current value of a component, or may add a component or remove a component (block ). The change can be entered via the management view . The management interface  receives the change from the management view , and dispatches the change to the runtime component (block ). In a scenario where the container uses the changed value as part of the container implementation and the change also affects the runtime component, the change can be dispatched at runtime and takes effect immediately. Otherwise, the change can be applied when the application server  is restarted the next time. Additionally, the persistence module  also receives the change and passes the change to the persistence store , which calls the persistence factory  to perform a persistence update (block ). Operations of the persistence module  will be described in greater detail in connection with .",{"@attributes":{"id":"p-0035","num":"0034"},"figref":["FIG. 4","FIG. 6","FIGS. 1 and 2"],"b":["400","400","626","400","150"]},"Referring to , in one embodiment, the method  begins when the persistence store , upon receiving an indication of a change to a component, provides the persistence root associated with the component (block ). The persistence root provides a reference (e.g., a pointer) to the XML representation  of the component. The XML representation  identifies whether any previous changes have been made to the component. The persistence store  then calls the persistence factory  to perform a persistence update (block ). The persistence factory  calls the component mapper  to identify the name of the updated component (block ). The persistence factory  further calls the value mapper  to map the changed value to a pre-defined persistence data format (block ). The persistence factory  then creates a representation (e.g., an XML representation) of the updated component including the recently-changed value and previous changes (if any) (block ). The representation also includes an association between the updated component and a deployment descriptor to which the update can be applied to persist the change. The persistence store  then writes the representation into storage (e.g., disks or other non-volatile data storage) (block ).",{"@attributes":{"id":"p-0037","num":"0036"},"figref":["FIG. 5","FIG. 6","FIG. 1"],"b":["500","500","626","500","120"]},"Referring to , in one embodiment, the method  begins when the application server  is re-started (block ). The application server  may be re-started after a maintenance shutdown or a failure. To resume the services offered by the application server , the application server  starts one or more deployers in the deployment layer  () to deploy the components of the services (block ). During the deployment process, the persistence module  obtains the persistence root of each component (block ), and determines whether persisted information is available; that is, whether a change has been made to the component before the re-start (block ). The persistence module  may determine whether persisted information is available by checking to see whether a stored representation associated with the component includes an update. If the persisted information is available, the persistence module  applies the persisted information to the original deployment descriptor associated with the component (block ). The original deployment descriptor associated with the component is the metadata generated by the deployment layer  during deployment of the component. Thus, the component will be deployed with the persisted information (e.g., the updated value). The component having the updated value will be installed in the application server  and can be viewed by a user via the management view  (block ).",{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 6","b":"600"},"The exemplary computer system  includes a processor , a main memory  (e.g., read-only memory (ROM), flash memory, dynamic random access memory (DRAM) such as synchronous DRAM (SDRAM) or Rambus DRAM (RDRAM), etc.), a static memory  (e.g., flash memory, static random access memory (SRAM), etc.), and a secondary memory  (e.g., a data storage device), which communicate with each other via a bus .","The processor  represents one or more general-purpose processing devices such as a microprocessor, central processing unit, or the like. More particularly, the processor  may be a complex instruction set computing (CISC) microprocessor, reduced instruction set computing (RISC) microprocessor, very long instruction word (VLIW) microprocessor, processor implementing other instruction sets, or processors implementing a combination of instruction sets. The processor  may also be one or more special-purpose processing devices such as an application specific integrated circuit (ASIC), a field programmable gate array (FPGA), a digital signal processor (DSP), network processor, or the like. The processor  is configured to execute the processing logic  for performing the operations and steps discussed herein.","The computer system  may further include a network interface device . The computer system  also may include a video display unit  (e.g., a liquid crystal display (LCD) or a cathode ray tube (CRT)), an alphanumeric input device  (e.g., a keyboard), a cursor control device  (e.g., a mouse), and a signal generation device  (e.g., a speaker).","The secondary memory  may include a machine-readable storage medium (or more specifically a computer-readable storage medium)  on which is stored one or more sets of instructions (e.g., software ) embodying any one or more of the methodologies or functions described herein. The software  may also reside, completely or at least partially, within the main memory  and\/or within the processing device  during execution thereof by the computer system , the main memory  and the processing device  also constituting machine-readable storage media. The software  may further be transmitted or received over a network  via the network interface device .","The machine-readable storage medium  may store the profile service , the management interface  and\/or the persistence module  (). While the machine-readable storage medium  is shown in an exemplary embodiment to be a single medium, the term \u201cmachine-readable storage medium\u201d should be taken to include a single medium or multiple media (e.g., a centralized or distributed database, and\/or associated caches and servers) that store the one or more sets of instructions. The term \u201cmachine-readable storage medium\u201d shall also be taken to include any medium that is capable of storing or encoding a set of instructions for execution by the machine that cause the machine to perform any one or more of the methodologies of the present invention. The term \u201cmachine-readable storage medium\u201d shall accordingly be taken to include, but not be limited to, solid-state memories, and optical and magnetic media.","It is to be understood that the above description is intended to be illustrative, and not restrictive. Many other embodiments will be apparent to those of skill in the art upon reading and understanding the above description. Although the present invention has been described with reference to specific exemplary embodiments, it will be recognized that the invention is not limited to the embodiments described, but can be practiced with modification and alteration within the spirit and scope of the appended claims. Accordingly, the specification and drawings are to be regarded in an illustrative sense rather than a restrictive sense. The scope of the invention should, therefore, be determined with reference to the appended claims, along with the full scope of equivalents to which such claims are entitled."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, and can be more fully understood with reference to the following detailed description when considered in connection with the figures in which:",{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":["FIG. 2","FIG. 1"]},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 6"}]},"DETDESC":[{},{}]}
