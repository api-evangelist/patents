---
title: Application response monitor
abstract: A computer-based method of formatting rules for monitoring application responsiveness, the method including defining a collection of resources, each such resource being a source of application events; and defining a first transaction as a timeframe for measuring application responsiveness. The first transaction includes a pattern of application events from resources in the collection of resources, the pattern being defined as a block of constructs, wherein each construct in the block of constructs is selected from a group of construct syntaxes consisting of an event construct syntax, a choice construct syntax, a sequence construct syntax, and a last construct syntax. The the event construct syntax specifies a category of application events for the pattern to accept; the choice construct syntax specifies an option set of constructs from the group of construct syntaxes, any one of which is acceptable to the pattern; the sequence construct syntax specifies a sequence of constructs from the group of construct syntaxes, for the pattern to accept sequentially; and the last construct syntax specifies a final set of constructs from the group of construct syntaxes, such that the final set of constructs must be satisfied for the pattern to be matched.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07072800&OS=07072800&RS=07072800
owner: Computer Associates Think, Inc.
number: 07072800
owner_city: Islandia
owner_country: US
publication_date: 20030919
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This invention relates to network monitoring systems, and more particularly to application response monitoring.","Application response monitoring systems measure and report on the performance of computer applications, especially as regards procedures or transactions initiated by user input. Such systems measure the delay between a user issuing an instruction to an application to perform a given action, and the application being ready to receive a next instruction from the user. Some systems also measure stages within the transaction and can report how much of the delay is due to each stage. Application response monitoring systems are used professionally by both developers of applications and by administrators of computing environments in which applications are used.","\u201cPoint-and-click\u201d describes a style of graphical user interface (GUI) for computers. Microsoft's Windows, Apple's MacOS, many UNIX variants, and other operating systems feature point-and-click GUIs. In one common configuration, a computer includes a display screen, a mouse, and a keyboard. The operating system (OS) renders a pointer on the display screen and moves the pointer in response to movements of the mouse by a human user. The pointer acts a virtual tool within the GUI to indicate areas to interact with. The mouse includes a button that is clicked by the user. The user's keystrokes from the keyboard are still another form of user interaction.","Typically, some software applications running on the computer have visible windows in the GUI. At any given time, one of the windows has \u201cfocus\u201d, i.e., is the default recipient of keystrokes. The user can interact with controls in a window, such as buttons, icons, menus, and so forth, or can change the focus to a different window. A similar notion of focus exists among controls within a window, i.e., the \u201cactive\u201d control is the default destination for keystrokes when multiple controls are present.","In general, in one aspect the invention features a computer-based method of formatting rules for monitoring application responsiveness. The method involves defining a collection of resources, each such resource being a source of application events; and defining a first transaction as a timeframe for measuring application responsiveness. The first transaction includes a pattern of application events from resources in the collection of resources, wherein the pattern is defined as a block of constructs and each construct in the block of constructs is selected from a group of construct syntaxes consisting of an event construct syntax, a choice construct syntax, a sequence construct syntax, and a last construct syntax. Also, the event construct syntax specifies a category of application events for the pattern to accept; the choice construct syntax specifies an option set of constructs from the group of construct syntaxes, any one of which is acceptable to the pattern; the sequence construct syntax specifies a sequence of constructs from the group of construct syntaxes, for the pattern to accept sequentially; and the last construct syntax specifies a final set of constructs from the group of construct syntaxes, such that the final set of constructs must be satisfied for the pattern to be matched.","Other embodiments include one or more of the following features. The step of defining the first transaction includes associating the transaction with a module of one or more transactions. The method also involves defining a second transaction based on the collection of resources.","In general, in another aspect, the invention features another computer-based method of monitoring networked application responsiveness. In this case, the method involves detecting an application instance that has a stream of application events; instantiating a finite state machine to recognize transactions in the stream of application events for the application instance, the finite state machine including a collection of states and a collection of transitions, each such transition having criteria for events that qualify to transition between a source state for the transition and a destination state for the transition, the source state and the destination state being among the collection of states; associating a first token with an initial state in the collection of states; processing the stream of application events sequentially, including, for each such event, comparing the event to a processed transition in the collection of transitions and associating an event token with the destination state of the processed transition if the event satisfies the criteria of the processed transition; and recognizing a transaction if a final state in the collection of states is associated with the event token for a candidate event in the stream of application events.","In general, in yet another aspect, the invention features another computer-based method of monitoring networked application responsiveness. In this case, the method involves receiving a message that specifies a responsiveness measure, a client, a server, and a networked service; selecting from a database a path corresponding to the client and the server, and a client set corresponding to the client; and adding the responsiveness measure to an aggregate sample of a plurality of clients, the aggregate sample selected according to the set, the path, and the networked service.","Other embodiments of this invention include one or more of the following features. The method also involves formulating a predicted responsiveness profile based on the aggregate sample; and if the responsiveness measure deviates from the predicted responsiveness profile by an amount given by a predetermined formula, creating an alert condition for the deviation.","In general, in still another aspect, the invention features a computer-based method of identifying user interface objects in a windowing environment. The method involves constructing a collection of string descriptions of window properties, including generating a base string description for a base window having an ancestry hierarchy of parent windows, and recursively generating subsequent string descriptions of the parent windows by following the ancestry hierarchy; calculating a hash of the collection of string descriptions; identifying the base window with an object identifier that combines an application name for an application associated with the base window, a numeric length of the collection of string descriptions, and the hash.","Other embodiments of this invention include one or more of the following features. The object identifier includes string separators separating the application name, the numeric length, and the hash.","In general in still yet another aspect, the invention features a computer-based method of monitoring networked application responsiveness. The method involves receiving a message that specifies a responsiveness measure, a client, a server, and a networked service; selecting from a database a path corresponding to the client and the server, and a client set corresponding to the client; and adding the responsiveness measure to an aggregate sample of a plurality of clients, the aggregate sample selected according to the set, the path, and the networked service.","Other embodiments of this invention also involve formulating a predicted responsiveness profile based on the aggregate sample; and if the responsiveness measure deviates from the predicted responsiveness profile by an amount given by a predetermined formula, creating an alert condition for the deviation.","The details of one or more embodiments of the invention are set forth in the accompanying drawings and the description below. Other features, objects, and advantages of the invention will be apparent from the description and drawings, and from the claims.","Referring to , in functional overview, an application response monitoring system  (or \u201csystem\u201d) measures the responsiveness of GUI applications  used by a human user . Measuring responsiveness includes measuring the duration of transactions initiated by user , where a transaction is a collection of events that fits a predetermined pattern. For a given application , system  monitors events in order to detect such a pattern. For example, a pattern could specify both a first event of a user clicking on a dialog to submit a database query to an inventory application, and a second, terminal event of the application beginning to display results to the user. The time it takes for this pattern to transpire, i.e., for this transaction to complete, is a measure of the responsiveness of the application.","System  includes facilities for an administrator to define the transactions that system  monitors. A ruleset  is an information structure that defines a transaction in system . Studio application  is a software program that allows a user to demonstrate a transaction by carrying out sample user interactions with an application , while system  automatically captures events from the demonstration. The events are stored in a script which can be replayed repeatedly, allowing a user to perform iterative cycles of testing and refining a ruleset, each time against identical input. Studio application  also generates rulesets  according to a ruleset syntax , which describes a textual format for rulesets .","During operation, a terminal agent  monitors an application  in a session  corresponding to user . As will be explained in more detail, terminal agent  uses information from a transaction agent  to characterize applications in terms of sources of events. Terminal agent  includes specialized event source objects to monitor various sources of event information. For example, terminal agent  includes a Windows hook  that monitors an event source of an operating system  of client device , where operating system  is one of the Microsoft Windows family of operating systems. Windows hook enables terminal agent  to monitor events in a message stream exposed by the operating system.","When terminal agent  detects an eligible event, it forwards a application event object  representing the event to transaction agent . Application event object  contains information describing the transaction, such as data on the user , the session , the corresponding application , and the time and duration of the transaction.","Transaction agent  receives a stream of application event objects  over time and examines the stream for transaction patterns. A ruleset engine  in transaction agent  reads rulesets  and uses them to recognize transactions among application events passed to transaction agent by terminal agent . Ruleset engine  includes a rule graph , which acts as a state machine for each actively monitored application .","Upon recognizing a transaction, transaction agent  sends a transaction event object  to monitor server , which is a software process that centralizes responsiveness data. Often, multiple terminal agents  and transaction agents  are distributed over multiple devices to monitor client sessions , each transaction agent  reporting to a shared monitor server .","Monitor server  also includes a naming service  that identifies transaction agents  robustly, even when the corresponding agents change identity under logical network address schemes such as DNS (domain name service) or IP (internet protocol) addressing. A proxy  associated with transaction agent  ensures that messages are sent to monitor server  at least at regular intervals. The messages include the current logical network address of the transaction agent , helping naming service  maintain a valid address for transaction agent .","Monitor server  includes features to store and retrieve responsiveness information for use by administrator . For example, pathset aggregation  supports real-time statistical analysis of event streams from clients, even in cases where the event stream from an individual client is so sparsely active that variance over short periods of time (for example, an hour or less) is not statistically significant, compared to any sample based on an individual stream. Pathset aggregation treats event streams from multiple clients as a single stream, allowing system  to measure statistically significant deviations from baseline behaviors over a time frame measured, for example, in minutes rather than hours.","Referring to , system  includes a number of event streams. A transaction specifies a pattern of application events over time. Typically, a transaction represents a related set of application operations\u2014in particular, a set of operations whose rate of execution or response time is being monitored by system . System  uses at least two levels in its representation of the workings of an application . First, as will be explained in more detail, the application operations are represented by raw application events  exposed within a session . Raw application events  are the raw data that terminal agent  gleans. For example, Windows hook  gathers raw application events  from operating system . Second, some raw application events  are in turn represented by application event objects . Terminal agent  monitors raw application events  and generates a stream of application event objects  representing the subset of application operations which transaction agent  is currently configured to sample, based on loaded rulesets  ().","The stream of application event objects  is transformed into a different event stream by transaction agent , which adds a transaction event object  to an event stream informing monitor server  of recognized transactions.","Physical Configuration","Referring to  and , the architecture of system  supports multiple physical configurations, such that sessions can be monitored while running on standalone devices  or on terminal client devices .","Referring to , in one physical configuration, system  includes a monitor server device  and one or more client devices , such as standalone devices . Users , such as users and , interact with applications running locally on standalone devices . One example of a standalone device  is a conventional personal computer running Microsoft Windows 98, with applications  in a session  executing locally ().","Monitor server device  executes instructions that encode the software process of monitor server . Typically, an administrator has privileged responsibilities for maintaining monitor server device  and monitor server , as well as other components of system .","Monitor server device  and standalone devices  communicate with one another over a network . For example, application event objects  follow a response path  from standalone devices  across network . Standalone devices  also communicate with network services  such as web server and application server ","Referring to , in another physical configuration, system  includes monitor server device , terminal server device , and one or more client devices  such as terminal client devices . Terminal client devices  are user-interface front ends (also known as \u201cthin clients\u201d) for application logic that executes on terminal server device . In general, users  interact with terminal client devices , but software on terminal server device  chooses the automated responses. Thus, for terminal client devices , the response path  for user actions first goes to terminal server device , then proceeds to monitor server device .",{"@attributes":{"id":"p-0078","num":"0077"},"figref":["FIG. 2C","FIG. 2B"],"b":["10","62","58","62","58","54","58","62","50"]},"The physical configurations shown in  are not mutually exclusive. That is, system  can include a combination of the described configurations, for example both standalone devices  and terminal client devices . Throughout this description, the term \u201cclient device\u201d applies to both standalone devices  and terminal client devices .","Logical Configuration","The configuration of logical components, e.g., software, can vary according to the physical configuration of system . The logical architecture and operation of system  will now be explained with regard to .","Referring to , which reflects the physical configuration shown in , a standalone device  runs a collection of application instances , in a session  for a user . An application instance  is an active, independent copy of the machine-executable instructions that encode a software application . For a given application , it is possible for a user  to start multiple application instances  running simultaneously in the same session . The state of each simultaneous application instance  is independent of the other application instances . Typically, each instance is derived from a single collection of code. As will be explained, system  handles responsiveness data for each application instance  separately.","Standalone device  also runs an agent , which is a distributed software entity that monitors application instances  and reports on their activity when detected events conform to predefined transactions. In particular, each agent  reports to monitor server .","In the configuration shown in , agent  includes a terminal agent  and a transaction agent . Terminal agent  detects events for a collection of application instances . For each such event, terminal agent  passes an event object to transaction agent , which analyzes the events over time to detect transactions. Transaction agent  notifies monitor server device  of each detected transaction.","Referring to , which reflects the physical configuration shown in , terminal server device  has a collection of terminal client devices . Terminal server device  maintains a distinct session  for each terminal client device  in the collection. Each such session  has a collection of application instances . In this configuration, terminal server device  runs an agent  that is common to all the sessions . Terminal agent  gathers events across multiple sessions . Transaction agent  analyzes each event in the context of its corresponding session .","Referring to , which reflects the physical configuration shown in , a terminal server device  has a terminal agent , which gathers events across multiple sessions  of the terminal server device . Terminal agent  passes the events to transaction agent , which runs on a transaction server device , remote relative to terminal server device . Furthermore, in this example, a given transaction agent  is shared by two terminal agents  on two distinct terminal server devices . In general, a given transaction agent  can support one or more terminal agents , regardless of whether they are local or remote.","Resources and Resource Instances","Terminal agent  monitors events that occur for various facilities of session \u2014for example, windowing processes, TCP connections to servers, and web browsers. Typically, the facility to be monitored provides an API (application programming interface) that exposes the necessary events to inspection. For example, the Microsoft Windows operating system has an API that notifies subscribing objects when a window is created, is destroyed, receives focus, loses focus, updates its title, and so forth.","Referring to , a resource  is a dynamic source of raw application events , monitored by an event source object in terminal agent . A raw application event  indicates a change of state for a monitored resource . For instance, each GUI process running on a client device  would be represented by a separate resource , and a separate raw application event  would originate from one of these resources  for each button press, dialog pop-up, etc. Each application instance  uses one or more resources .","Each resource  has a resource category , according to which terminal agent  categorizes raw application events  from that resource . In general, for each different resource category , terminal agent  uses a different event source object to monitor raw application events .","A resource category  is persistent, in the sense that it is stably defined until terminal agent  is reconfigured. In contrast, a resource  has a dynamic existence over time. When a resource  exists, it is a \u201clive\u201d source of raw application events , but a resource  can terminate. For example, when a GUI process terminates, its corresponding resource  terminates, too.","System  includes resource categories  for OS session, windowing, networking, DNS, browser, email, and OS process. An OS session resource  represents a session . A windowing resource  represents a GUI process for a window or control. A networking resource  represents a non-DNS networking entity such as a TCP connection; DNS resources  representing DNS servers. Resource categories  exist for applications, too. For example, a browser resource  represents a web browser, and an email resource  represents an email client. An OS process resource  represents a generic process in the OS.","Within the architecture of system , an application instance  is a collection of resources . Like resources , an application instance  is dynamic, i.e., comes into and goes out of existence. Often, in practice, an application instance  corresponds to an executable, which is a collection of machine instructions that encode a software application. From this perspective, an application instance  represents an active, evolving example of the executable's instructions in action, with states and properties associated with carrying out the instructions. When the operating system allows, one set of instructions can be the basis for multiple such examples in a session. Each such example would be represented by independent application instances . Note, however, that application instance  is customizable, and in the general case a single application instance  can correspond to multiple executables. For example, for a user process that involves data entry into a database form, after which an automatic email is sent describing the data in the form via an email program, an administrator could define an application instance  that encompasses both the executable for the database form and the executable for the email program. An application prototype  represents the template from which a given application instance  is created in system . As will be explained in more detail, the definition of an application prototype  and its derived application instance  is encoded in a ruleset.","In the example of , which shows three application instances  and a variety of resources  at a moment in time, an application prototype is the basis for two application instances . Another application prototype , shown on the right, is the basis for a single application instance . The application prototype in the center has no currently associated application instance .","Each application instance  has a collection of resources . Each of the resource categories  in the example has an active resource , except for the category for email. Each of the resources  in this example is associated with an application instance , except for a connection resource .","A given resource  can be shared by multiple application instances . In the example of , the application instance  at the center and the application instance  at the right both use the DNS server resource .","Event Streams and Transactions","Referring to , the stream of raw application events  from any resource  is independent of the streams from any other resources . An example client\/server application instance  includes two resources : a client GUI process and a TCP connection to an application server. Raw application events  for each resource are depicted along a timeline. The transaction agent  sees two independent streams of raw application events , one from the client GUI process (events for window creation, button press, etc.) and one from the network connection (events for outgoing requests and incoming responses, for example). There is no inherent relationship between these streams, even though they originate from the same application instance .","A transaction  specifies a pattern of application operations over time, as reflected by events corresponding to the operations. A transaction definition includes criteria that select which application event objects  will satisfy the pattern. A transaction definition also optionally includes time ordering among the criteria, indicating an order in which application event objects  must occur to satisfy the pattern.","Transactions  can be nested or can overlap. In the example shown in , a first transaction extends from a \u201ccreate window\u201d event to a \u201cdestroy window\u201d event, while a second transaction occurs within the first, extending from a \u201cbutton press\u201d event to a \u201cstatus message\u201d event.",{"@attributes":{"id":"p-0101","num":"0100"},"figref":"FIG. 6","b":["80","14"]},"1. Window gets focus. Window name is \u201cCorrection-Personal Data\u201d.","2. Button is pressed. Button name is \u201cOK\u201d.","3. Window appears. Window name is \u201cAdminister Workforce (U.S.)-Use-Personal Data\u201d.","4. Menu command is invoked. Command is \u201cFile->Save\u201d.","5. Status message appears. Message is \u201cRecord Saved\u201d.","Ruleset Syntax","Referring to , a ruleset syntax  governs the textual format for rulesets. The format includes the name of the application, the application's resource definitions, and some number of transaction recognition rules. That is, for a given application, multiple transactions can be defined via ruleset syntax .","Ruleset syntax  allows for portions of the text to be ignored by transaction agent  when the compliant ruleset  is parsed, for example so that human-readable explanations can be added. In particular, the hash sign \u201c#\u201d and all subsequent characters on a line are ignored. For clarity of explanation, the following description of ruleset syntax  will assume that no comments are present.","Ruleset syntax  begins with a ruleset statement , which defines the boundaries of the ruleset being defined. Ruleset statement includes the static keyword \u201capplication\u201d, followed by a name for the ruleset, followed by a block of text encased in curly braces (i.e., \u201c{ }\u201d). The rest of the ruleset is nested within this block of text.","Ruleset syntax  next includes a resources statement , which specifies resources  that will provide events for the associated transaction. Resources statement includes the static keyword \u201cresources\u201d, followed by resource definitions block , which is another block of text encased in curly braces. Resource definitions block  lists resources  to be monitored.","After the resources statement , ruleset syntax  includes one or more transaction statements . A transaction statement tells the ruleset engine  how to recognize the operations and transactions  that are occurring within a running application . Transaction statement includes the static keyword \u201ctransaction\u201d, followed by a transaction name, which is followed by the static keyword \u201cmodule\u201d, a module name, and a rule body block  encased in curly braces. Rule body block  is a block of text that specifies a pattern of events that characterizes the transaction.","Optionally, an alternate ruleset statement follows transaction statement . An alternate ruleset statement allows the definition of additional transactions for a given application  within the same ruleset. As will be explained in more detail, system  can monitor such transactions independently. Therefore, the transactions can have different scope. For example, the transactions can be nested.","Resource Definitions","Referring to , a resource definitions block  tells the ruleset engine  how to recognize a running instance of an application  in terms of resources .","Resource definitions block  includes a required resource section , which identifies resources  that must exist in order for the application  to be running. Often, this includes the processes of the application . In general, though, any number of resources can be specified.","A required resource section is designated by the static keyword \u201crequire\u201d, followed by a selection kind that identifies how many of the specified resources must exist before the application is considered to be running. Selection kind  can be selected from the qualifier keywords \u201cone\u201d, \u201cany\u201d, or \u201call\u201d. The keyword \u201cone\u201d indicates that each resource  matching one of the resource specifications should be considered a separate running application instance  (e.g., an application with one or more GUI executables). The keyword \u201cany\u201d indicates that any resource  matching one of the resource specifications should be considered part of a single application instance , although resources matching all of the specifications need not be active at the same time (e.g., an application with multiple processes that come and go out of existence). The keyword \u201call\u201d indicates that resources  matching all of the specifications must simultaneously exist in order for the application  to be considered to be running (e.g., an application with separate GUI and networking executables).","Required resource section further includes a curly-braced block that lists resource specifications . For each resource to be monitored for an application, an event source is specified in a resource specification , which begins with the static keyword \u201cresource\u201d, followed by a name (shown as \u201cevent-source\u201d in ), and a bracketed parameter list (shown as \u201cparameter-list\u201d in ) that specifies any number of parameters that further qualify the desired resource. Resource specifications are explained in more detail with regard to .","Resource definitions block  also optionally includes an additional resource section that identifies any further resources that should be monitored as part of the application. This can include transient resources (those that come and go out of existence during the lifetime of the application) as well as the types of activity to monitor for the \u201crequired\u201d processes (network connections, windowing activity, web (URL) activity, etc.). Additional resource section is designated by the static keyword \u201cadditional\u201d, followed by a curly-braced block of resources formatted as resource specifications ","Even if an application's transaction definitions do not explicitly reference the application's networking activity events, a \u201cConnection\u201d resource definition is often included in application resource definitions so that the networking activity is monitored by the agent and exposed to subsequent analysis as a distinguishable factor affecting response time.","Referring to , an example resource definition for an installation of a PeopleSoft application includes the application's GUI executables along with their windowing activity and database connections. Because each GUI process operates independently, the \u201cone\u201d keyword is used.","Referring to , another example resource definition for an installation of an SAP application uses the \u201call\u201d keyword because both the GUI process (\u201cfront\u201d) and networking process (\u201csapgui\u201d) must be running for the application to be executing.","Rule Body Block","Whereas resource definitions tell the ruleset engine  how to recognize a running instance  of an application, transaction definitions tell the engine how to recognize the operations that are occurring within the application after it is running. This involves telling the engine the one or more sequences of events to look for that characterize the transaction.","Referring to , transaction statement includes rule body block , which includes a list of one or more event specifications . Often, an event specification is for a single event, i.e., is \u201catomic\u201d. However, as will be explained in more detail, an event specification can include collections of event specifications , with recursive structure. An atomic event specification identifies an event source from which the event originates, the kind of event (button press, SQL request, etc.), and any event-specific parameters that further qualify the event.","Referring to , in an atomic form, event specification includes a static keyword \u201cevent\u201d , an event name , an event source , an event kind , and a curly-braced parameter list . Event source specifies a type of event source object for terminal agent  to use to gather raw application events . Event kind specifies a kind of event produced by the event source, for instance for specificity in case the event source produces multiple kinds of objects. Parameter list  provides parameters that further qualify the events to look for; the parameter list syntax is typically specific to each event. Parameter list  may be empty. Parameter list  is explained in more detail with regard to .","Event name is also part of the syntax for event specification . Event name is ignored by ruleset engine  but acts as a debugging aid, allowing a human ruleset developer using studio application  to easily correlate the behavior of the ruleset engine  with the actual steps supplied in the transaction definition. Any name may be supplied here and does not need to be a unique identifier.","Referring to , rule body block  permits nested event specifications , i.e., constructs that include lists of event specifications , such as a choice construct , a sequence construct , and a last construct . The choice and sequence constructs can be mutually nested and can be nested recursively to create still more involved constructs.","Referring to , choice construct allows multiple, alternative event sequences to be specified for a transaction. Ruleset engine  considers choice construct to be satisfied if any one of the specified event specifications is observed. Each event specification can itself be an atomic event specification , a choice construct , or a sequence construct ","Referring to , sequence construct allows a series of events to be specified for a transaction. Ruleset engine  considers sequence construct to be satisfied if all of the specified event specifications are observed to occur in order within the application (albeit with possibly other events interspersed, or \u201cinterrupting\u201d the series). Each event specification can itself be an atomic event specification , a choice construct , or a sequence construct ","Ruleset syntax  treats the main rule body block  of a transaction statement as an implicit sequence construct . Thus, ruleset engine  requires entities of rule body block  to occur in sequence in order to satisfy rule body block .","Referring to , last construct allows an iterative series of events (of indeterminate number) to be specified for a transaction. Ruleset engine  considers last construct to be satisfied if an uninterrupted series of events (each of which matches some event specification in the list) is observed to occur. More specifically, the last such matching event is considered to satisfy the construct . Note that this contrasts with sequence construct , at least in that sequence construct allows unspecified events to interrupt the specified series, while last construct does not.","Each event specification in the last construct must be atomic. Choice constructs , sequence constructs , and last constructs  are not permitted to be nested inside a last construct ","Referring to , an example ruleset encodes the example transaction  discussed with regard to . This example includes a sequence of five atomic events.","Referring to , an example ruleset encodes a transaction  that can be performed in either of two ways. A user of the application can create a new employee record by either manually entering the employee's data into a screen, or by importing it from a file.","Referring to , an example ruleset encodes a transaction  for a calendar management application. The ruleset characterizes the scheduling of an appointment by the user first pressing the \u201cschedule\u201d button, followed by several exchanges with a database server. A last construct identifies the network activity occurring at the end of the transaction. The last construct is useful here because the number of Request\/Response events may vary with each appointment scheduled.","Parameter Lists","Both resources statement and transaction statements involve parameter lists that help to qualify the resource or event being specified. Ruleset syntax  includes a generalized syntax for parameter lists.","Referring to , a parameter list  includes zero or more parameter entries . Each entry includes a parameter name , an operator , and a parameter value . Name is the name of the parameter, value is a value for that parameter, and operator is a comparison operator such as \u201c=\u201d. The syntax supports both string and numeric values. For string values, special embedded characters such as quotation marks and backslashes are prefaced with the backslash (\u2018\\\u2019) character.","The syntax for parameter entries also supports a pattern-matching notation. This can be useful, for example, in order to recognize a window title that contains some varying component (e.g. an employee ID number). Pattern matching allows the window title to be selected based on the invariant portion of the title. Accordingly, entry optionally further includes a comparison qualifier and a delimiter . Comparison qualifier can be selected from the static keywords \u201cexact\u201d, \u201ccontains\u201d, and \u201cregexp\u201d. The \u201cexact\u201d keyword is the default when comparison qualifier is absent. The \u201cexact\u201d keyword requires the value supplied by the resource or event to match the specified value exactly (though without sensitivity to case). The \u201ccontains\u201d keyword specifies a sub-string search. The \u201cregexp\u201d keyword indicates that value is a regular expression, to be evaluated accordingly.","Referring to  and , two ruleset samples each feature a parameter entry portion. Both rulesets identify a window that contains the text \u201cUpdate Employee\u2014\u201d followed by the employee ID number.","Substitution Parameters","Rulesets  can be designed to monitor several types of applications. Examples include a \u201cWindows\u201d ruleset to monitor basic window-to-window transitions within an application, and a \u201cWeb\u201d ruleset to monitor page downloads of selected URLs. There can be a large (or total) degree of overlap between rulesets used by different user populations, perhaps only differing in certain parameter values for resources or events such as the name of the GUI executable, or the identity of the URL being monitored. Ruleset syntax  supports the development and deployment of generic rulesets  that are portable between such environments.","Referring to  and , placeholders indicate parameters that should be filled in with customized values. Parameter entry can have a placeholder variable instead of parameter value . The placeholder variable is encased in parentheses. When the placeholder variable is a string data type, a dollar sign precedes the encased placeholder variable ; when the placeholder variable is a numeric data type, a percentage sign precedes it.","Referring to , an example ruleset definition for the generic \u201cWindows\u201d application type names no specific GUI executable. Instead, the placeholder \u201c$(Application Executable)\u201d indicates that one or more \u201cApplication Executable\u201d names must be supplied.","Referring to , when configuring the ruleset  of , system  will prompt the user to supply one or more values for the \u201c$(Application Executable)\u201d placeholder. (The user can edit the values in studio application  later, as well). Upon receiving values for the placeholder, the system will expand the resources statement to include the values. For example, if \u201cCERNER\u201d and \u201cCERNADV\u201d were supplied as values for this parameter, the resources statement would be expanded to reflect both values, as shown in .","The event specification containing the placeholder remains within the expanded ruleset to indicate that the subsequent definitions represent substituted values. If the placeholder definition is removed, then the parameter values will no longer be editable via studio application . However, the placeholder definition has no impact on the recognition of transactions. Ruleset engine  ignores placeholders and uses only the expanded definitions (with the substituted values) to recognize transactions .","Referring to , when parameter values specify a set, any one of which is sufficient to satisfy the parameterized event specification , a choice construct is in order. An example ruleset  contains a placeholder value for URL(s) to be monitored. The placeholder value is inside text that uses the syntax of a choice construct . When configuring this ruleset , system  prompts the user to supply one or more values for the URL parameter. Because potentially multiple values can be supplied for the parameter, the choice construct is needed to provide the correct semantics once the definition is expanded. If the user supplied the values \u201cwww.concord.com\u201d and \u201cwww.irs.ustreas.gov\u201d for the URLs parameters, then the transaction definition should expand into the form shown in . Without the syntax of the choice construct , the transaction definition would have expanded into an incorrect definition where the transaction required both the URL events to occur, and in a sequential order, as shown in .","Referring to , system  treats substitutable parameters somewhat differently when the parameters are for resources  involving networking, such as resources  from resource categories  () \u201cConnection\u201d and \u201cDNS\u201d. The values for such parameters are automatically taken from the definitions of servers affiliated with the application. In the example shown in , a portion of an example ruleset that uses a \u201cConnection\u201d resource is automatically expanded at runtime using the hostname\/port specifications of servers affiliated with to the application. As a result, the corresponding terminal agent  only monitors the network activity of such servers when monitoring the \u201cCERNER\u201d application, ignoring network activity to other servers.","Alternate Ruleset","It can be useful to monitor an application using two different rulesets simultaneously. For example, an application could be monitored both at a user transaction level while at the same time being monitored at a more granular, networking response time level. The transactions that occur will differ between the levels, but will overlap in time (the user level transactions will be comprised of the networking transactions as well as other activity). The discussion with regard to  provides another example of overlapping transactions.","Transaction agent  supports several approaches to monitoring an application using multiple rulesets. In one approach, multiple rulesets  can be created using identical resource definitions. The same application activity will then be independently analyzed for evidence of transactions using each application's ruleset. However, for reporting and administrative purposes, the separate rulesets are independent. There is no correlation between the monitored data for them.","A second approach to multiple rulesets is to embed the alternate transaction definitions within the same overall application definition, using the alternate ruleset statement . Transaction agent  analyzes an application's activity for transactions using each alternate ruleset defined, independently. However, the transactions recognized under each alternate definition (and their corresponding response information) are recorded under the same overall ruleset. Note that alternate rulesets cannot be nested, and that all transaction definitions that occur outside the scope of an alternate ruleset construct are treated as if they belong to a single alternate ruleset definition.","Referring to , for an example ruleset , the transaction agent will monitor the application (embodied in the EmplMgmt.exe executable) looking for occurrences of \u201cNewEmployee\u201d and \u201cEmployeeUpdate\u201d transactions, while simultaneously recording a transaction for each window transition that occurs within the application (\u201cAR Window Transition\u201d).","Modules","Referring again to , each transaction has transaction name and a module name in the corresponding transaction statement . Each transaction name is unique. Module names provide a mechanism for grouping individual transactions into a single unit for reporting purposes on monitor server . If a transaction should not be grouped with other ones for reporting, then its module name should be unique\u2014for instance, identical to its transaction name.","In the examples discussed with regard to  and , both the \u201cUpdateEmployeeRecord\u201d and \u201cAddNewEmployee\u201d transactions shared the \u201cPrimaryOperations\u201d module name. Monitor server  would therefore collect the response data for these two transactions together and would report it under the single module name.","Transaction Agent","The transaction agent  sorts through resources and events in order to recognize the application operations (transactions) that occur. This is done in two parts: recognizing the applications that are running, and recognizing the transactions that occur. As resources come into and go out of existence, the ruleset engine determines when an instance of a monitored application is running. In addition, once a running application instance is recognized (and only after it is recognized), the event streams from the application's resources are analyzed to recognize the transactions that occur.","Application Recognition","Application event object  is the basis for two special event objects, START and STOP, which signal resource availability. In particular, a START event from a given resource indicates that the resource is available and active, while a STOP event signals resource termination.","Referring to , an application lifecycle  describes stages of availability that an application instance  passes through. In the is case, availability is a function of resources. Broadly, as each resource  comes into existence, as signaled by its initial START event, the resource is matched against the definitions of all applications in its session . Both \u201crequired\u201d and \u201cadditional\u201d resource definitions are included in the comparison. The matching is subject to selection kinds () of each resource definition, such as \u201cone\u201d, \u201cany\u201d, or \u201call\u201d. The matching is also subject to resource dependencies. For example, a Connection resource will not be added to an application instance unless the Process resource on which the connection depends is present.","When a sufficient set of \u201crequired\u201d resource definitions have been matched (as indicated by the selection kind ), the application instance transitions from a potential instance to a recognized instance, and transaction recognition activity begins. Transaction recognition activity continues until the \u201crequired\u201d resource definitions and qualifier are no longer satisfied, for example due to resource terminations as signaled by STOP events.","Application lifecycle  applies to a given application instance . Initially, the instance does not exist (stage ). A resource is recognized that does not match an existing resource\u2014for example, perhaps user starts a second copy of a web browser (transition ). Transaction agent  creates an object for application instance , including a collection of resources. The resource is added to the collection. The application instance  is now in a \u201cpotential\u201d state (stage ), between creation and full availability.","While the application instance  is in its potential state, resources come and go, with at least three possible results. One result is that the instance remains potential (transition ). For example, the application instance  may require three resources, only two of which are yet available. Another possible result is that all of the require resources become available, in which case the instance becomes (transition ) an active instance (stage ). A third possible result is that every resource in the collection of resources terminates, causing the instance to move (transition ) to a termination state (stage ). In this case, transaction agent  destroys the associated object. Such an instance is an example of a false start.","Once the instance is active (stage ), changes to its resources produce at least two possible outcomes. When resources defined to be \u201cadditional\u201d terminate or become available, the instance remains active (transition ). However, when a required resource terminates, the instance also terminates, moving (transition ) to a termination state (stage ).","Transaction Recognition","Referring to , a ruleset engine  includes processes such as a ruleset compiler  and a transaction recognition process . In general, ruleset compiler  constructs a rule graph, which functions as a state machine, from a ruleset. Transaction recognition process  uses a rule graph to detect transactions within a stream of events. Upon detecting a transaction, transaction recognition process  sends a transaction event object  to monitor server .","Transaction event object  describes the transaction, the related application instance, the time and duration of the transaction, and additional event data describing stages within the transaction, along with time and duration for the stages as well. Transaction event object  also includes reporting data such as the module associated with the transaction.","Ruleset Compilation","Referring to , a rule graph  is an internal representation of the application's transaction rule definitions. Ruleset engine  uses a rule graph  to recognize transactions, maintaining a separate rule graph for each recognized application instance.","A rule graph for a ruleset has exactly one initial state (state zero, labeled \u201c0\u201d in ), a separate terminal state for each transaction rule for the ruleset, and zero or more intermediate states . An arc is a transition between states. An arc represents an atomic event specification () within a transaction rule. Thus, each transition in rule graph  accepts a category of application events  (). A series of transitions corresponds to a pattern of accepted events. In particular, a series of transitions from an initial state to terminal state corresponds to a pattern of events for a recognized transaction.","Each arc has an arc condition that characterizes the events that the transition accepts. Each arc also has an arc direction that specifies the transition from a source state for the arc to a destination state.","Referring to  and , a ruleset compiler  is a process that translates the transaction statements of a ruleset  into a rule graph . Ruleset compiler  recursively processes the transaction statements. At each level in the recursion, ruleset compiler  selects starting and ending states, and adds appropriate intermediate states and arcs to reflect the syntactic constructs of the transaction statements.","For the top level of a transaction statement, the starting state is the initial state , and the ending state is the terminal state that represents the recognition of the transaction. Ruleset compiler  recursively processes the body of the transaction definition\u2014i.e., the rule body block \u2014using sub-processes specialized to the particular syntactical construction. These sub-processes include event translation , choice translation , sequence translation , and last translation . Each such sub-process receives a reference to a starting state, a reference to an ending state, and a syntactical construct of the ruleset (such as an atomic event specification , shown in ; a choice construct , shown in ; a sequence construct , shown in ; or a last construct , shown in ). Note that the notions of \u201cstarting state\u201d and \u201cending state\u201d are defined from the frame of reference of the sub-process; they are not static or universal, but can vary with each instance of the sub-process and its position within the recursion stack.","Event translation translates an atomic event specification . Event translation creates an arc between the starting and ending states. The arc condition corresponds to the event source , event kind , and parameter list  of the event specification.","Choice translation translates a choice construct . For each event specification in the choice construct, choice translation adds to rule graph  a separate subgraph between the starting and ending states. Choice translation recursively invokes sub-processes of ruleset compiler  to construct the subgraph as appropriate, depending on the type of event specification. For example, when the event specification is atomic, choice translation invokes event translation , passing the same starting and ending states as were passed to choice translation . When the event specification is a sequence construct (i.e., one nested inside the choice construct), choice translation invokes sequence translation . The invoked sub-process can itself recurse, constructing subgraphs within subgraphs.","Sequence translation translates a sequence construct . The sequence construct contains an interruptible series of event specifications. For each pair of adjacent event specifications in the series, sequence translation adds to rule graph  a separate subgraph, such that the subgraph connects adjacent states ordered like the adjacent event specifications. Similar to choice translation , sequence translation recursively invokes sub-processes of ruleset compiler  to construct the subgraph as appropriate, depending on the type of event specification.","Recall that the main body of a transaction rule is an implicit sequence construct ().","Last translation translates a last construct . Last translation adds an intermediate state to the rule graph . The last construct contains an non-interruptible series of event specifications. For each event specification in the series, last translation adds a transition from the starting state to the new intermediate state. Last translation also adds a special \u201cvoid\u201d transition from the new intermediate state to the ending state, to indicate when the series of matching activity events has ended. The arc for the void transition has a special arc condition that requires no input. During processing, this void transition is not followed until all of the incoming transitions to the intermediate state have been satisfied.","Referring to , ruleset compiler  compiles each transaction statement to begin at the same shared initial state and end at a distinct terminal state , regardless of the alternate ruleset in which it is contained. The rule graph for an application may therefore contain a mix of sub-graphs (each corresponding to a transaction) from different alternate ruleset constructs. Each sub-graph is compiled with information about the identity of the alternate ruleset that contains it. Note that transaction definitions that occur outside of an explicit alternate ruleset construct are implicitly considered to be part of their own alternate ruleset (i.e. the \u201cprimary ruleset\u201d).","State Machine in Operation","Referring still to , transaction recognition process  uses a rule graph  as a state machine to recognize transactions for an application instance  (). Transaction recognition process  associates tokens  with states of the rule graph. For simplicity of explanation, this discussion often refers to a token being \u201cplaced on\u201d a state to indicate this association with a state, using a physical metaphor for the rule graph. It should be understood that in practice, rule graph  is a data structure in the memory of a computing device.","A token  represents the progress of a path through the rule graph, from the initial state . The path corresponds to a recognized series of events. When a token is placed on a terminal state , the path represents a series of events that satisfies a transaction. Multiple tokens can be placed on the same rule graph at once, allowing the ruleset engine to track multiple paths simultaneously. In , tokens  are illustrated as numbered diamonds, while states of the rule graph  are numbered circles.","Referring to , transaction recognition process  has a rule graph to operate on (step ). Transaction recognition process  places a single token  on state zero of the graph (step ). As application event objects  are received (step ), transaction recognition process  evaluates the tokens currently on the rule graph (loop beginning at and iterating through ). For each such token, transaction recognition process  considers each of the arcs that depart it (step , and loop at through ). If the event matches the condition of the arc (result of step ), transaction recognition process  adds a new token to the destination state of the arc (step ). Otherwise (result of step ), transaction recognition process  continues to loop through arcs for the current token (step ).","Note that the current token is not normally moved, but a new token is added to the destination state. One reason for this is that the new state may represent a dead-end path, i.e., a transaction that whose pattern is partially matched to the current event stream but which ultimately fails to match. Transaction recognition process  leaves original tokens in place as a historical record, to continue evaluating other alternative paths through the graph.","If multiple tokens are added to the same state of the graph, then transaction recognition process  discards all but the one representing the potential transaction with the most recent starting time. A later section entitled \u201cTRANSACTION SELECTION\u201d gives further information about tie-breaking procedures in transaction recognition process , below.","After adding new tokens, transaction recognition process  tests whether any of the destination states is a terminal state (step ). For each such terminal state found (result ), transaction recognition process  considers the corresponding transaction recognized (step ). Otherwise, if no tokens were newly placed on terminal states (result of step ), transaction recognition process  loops back to process the next event (step ).","If terminal states are reached for transactions from different alternate ruleset constructs, then transaction recognition process  selects a single transaction for reporting from each of the alternate ruleset constructs.","Once a transaction (or set of transactions) is recognized, transaction recognition process  purges outstanding tokens from the rule graph (step ), then begins anew to look for the next transaction (step ). The purging of outstanding tokens includes the following operations. For the token located on the initial state, transaction recognition process  leaves the token in place. Tokens that have reached terminal states (i.e. recognized transactions) are removed. Tokens located on intermediate states may either be preserved or removed, as follows.","Tokens from a subgraph that represents an alternate ruleset construct in which a transaction was recognized are generally removed from the rule graph. One exception is that tokens just created as a result of transitions from the initial state are preserved. This allows an application activity event that ends a transaction occurrence to also serve as the first event of a new transaction (e.g. window-to-window transitions).","Tokens from other alternate ruleset constructs, in which no transaction was just recognized, are also preserved during purging . Thus, transaction recognition process  evaluates transaction rules from different alternate ruleset constructs independently of each another.","Referring again to , an example rule graph  includes an upper and a lower alternate ruleset. Several tokens  have been placed on the rule graph, reflecting a series of events that has led transaction recognition process  to recognize transaction A (as indicated by the presence of token  on state ). After the recognition of this transaction, all of the tokens for the upper alternate ruleset will be removed (i.e. tokens , , , and ). However, all of the tokens for alternate ruleset  will remain in place (i.e. tokens  and ). Transaction C can be recognized in as little as two more events\u2014namely, an event that places a token on step , followed by an event that places a token on step .","Transaction Selection","It is possible for multiple transactions to be recognized simultaneously as a result of processing a single application activity event. This could be the result of alternate ruleset definitions or of ambiguous transaction rules. When multiple transactions from the same alternate ruleset are recognized, transaction recognition process  applies a tie-breaking algorithm to select a single transaction for reporting. First, transaction recognition process  discards transactions older than a predetermined threshold. This avoids mixing and matching events from different real transaction occurrences. Next, transaction recognition process  gives first preference to the transaction with the most recent starting time. Earlier starting times may represent transactions that were cancelled, and that now only appear to be completing due a mixing of events with the newer transaction occurrence. Third, if two or more transactions share the most recent starting time, transaction recognition process  gives preference to the transaction with the most specific transaction rule definition, i.e., the rule with the most state transitions.","By reporting only one of the transactions, transaction recognition process  avoids \u201cdouble-counting\u201d problems. Moreover, this serves as a mechanism to reset the engine and purge the states of incompletely recognized transactions, such as transactions that were not really occurring or were cancelled.","Handling the \u201cLast\u201d Construct","The \u201clast\u201d language construct requires special handling, since the last matching activity event of a series is not known until the subsequent (non-matching) event is received. First, transaction recognition process  forms a list of the token transitions that apply to the new event, but does not perform those transitions immediately. Then, if the final event of a series occurred for a \u201clast\u201d construct, transaction recognition process  transitions the corresponding token from the intervening state to the final state for the construct. From there, transitions may apply for the new activity event. Finally, transaction recognition process  performs all token transitions that match the new activity event.","When the series of matching events has ceased, the single token on the intervening event is copied to the destination state indicated by the special \u201cvoid\u201d transition and the token on the intervening state is removed. Unlike other transitions, the original token is removed in this case because it cannot represent an alternate evaluation path in the rule graph (i.e., there cannot be another last event in the series).","Object Identifiers","Referring again to , terminal agent  includes a Windows hook  that monitors an event source of a Microsoft Windows operating system  on client device. Windows hook enables terminal agent  to monitor events in a Windows messaging stream exposed by the operating system. The messaging stream contains raw application events  () generated by GUI objects such as windows, menus, buttons, and other controls.","For example, when a user clicks on a button in a window, the operating system adds an event  describing the click to the stream. The event  includes information about the button, which in the Microsoft Windows model is a form of window. The button has a parent window\u2014perhaps a dialog of a larger application. In this case, the button's parent (the dialog) has a parent of its own (the application window). This chain of parentage forms an object hierarchy for the session, back to some root window object. Every active window object (including controls) has a place within an object hierarchy.","As another example, a raw application event  in the Windows messaging stream could represent a window being opened or moving \u201cto the front\u201d, i.e., receiving focus. In other words, the messaging stream also includes events that are not tied to user interactions.","Windows hook  uses a naming scheme for GUI objects within the Windows object model. The naming scheme helps Windows hook  detect similar GUI objects over time. For example, a data entry application might have a form to collect user input. The form includes a save button for saving the form to a database. A different dialog in the application would alert the user that the data saved successfully. The form, the save button, and the dialog would each have a distinct object identifier under the naming scheme. Moreover, when the user opened the form again to submit new data, the second instance of the form\u2014and its accompanying second instance of the save button\u2014would each have object identifiers that matched the first instances. Thus, the object identifiers allow terminal agent  to detect recurrent instances of GUI objects. Among other uses, object identifiers offer one way that rulesets  can select a particular GUI object\u2014such as form or button\u2014in the rules that characterize transactions.","The name assigned to each GUI object is based in part on stylistic properties of the object and on the object's position within the hierarchy of GUI objects active in the current session. The naming scheme includes a syntax and a process for generating names according to the syntax. In general, the naming scheme has sufficient specificity that, within a given session  at a given moment, the scheme uniquely identifies each object. The naming scheme also has sufficient generality over time that when a GUI object comes into being within the session, expires, and later recurs in a second instance, the scheme assigns the same name to both instances of the GUI object. This combination of specificity and generality allows the naming scheme to identify recurrent instances of a GUI object over time.","The naming scheme is based on data that is dynamically available as properties of a raw application event  () as it exists natively within the Windows messaging stream. The naming scheme identifies a GUI object without, for instance, requiring pre-existing information about the class libraries that define the object.","The naming scheme for GUI objects is also independent of the human-readable titles that are associated with GUI objects for display. One benefit of this is that a GUI object can be dynamically re-titled (for example, to incorporate the name of a newly-opened file in the title of a window for a word processor application) without affecting the object's identity within the scheme. Also, the scheme is portable between internationally localized versions of the Microsoft Windows. For example, moving from an English version to a French version of Windows would not alter the object identifiers.","Also, the naming scheme is independent of the GUID (globally unique identifier) of windows objects. When a second instance of a window or control recurs after a first instance, the two instances have different GUID's. The GUID's in themselves do not give the two instances a common identifier.","Referring to , Windows hook  employs an object identifier syntax  in its naming scheme for GUI objects. Object identifier syntax  specifies the format of an OID (object identifier) tag , which is an instance of a name within the naming scheme.","OID tag includes an application name and properties of a window path , such as a length and a checksum . Application name is a property of a GUI object as it exists natively within the Microsoft Windows object model, wherein each GUI object is affiliated with an application instance  (). Window path is a text string, discussed with regard to . Length expresses the number of characters in window path . Checksum is a numeric hash of the text of window path , for example into approximately ten digits. OID tag includes a concatenation of application name , length , and checksum , separated by hyphens.","Referring to , window path is a text string generated from properties of a GUI object native to the Microsoft Windows GUI object model. In particular, window path is a concatenated list of derived string properties . The list reflects the position of the GUI object within the object hierarchy for the session discussed above. The list includes an entry for the GUI object in question, as well as an additional entry for each of the object's ancestors within the object hierarchy. A backslash character (\u201c\\\u201d) is the list delimiter.","Referring to , a derived string property for a GUI object (which is a window object in Microsoft parlance) includes a class name , a list of class styles , a list of window styles , a list of extended styles , and a child identifier . These components of derived string property are concatenated together, delimited by hyphens. They are available as properties of the raw application event  associated with the window object in the Windows messaging stream. In general, class name specifies an object class for the window object, while class styles , window styles , and extended styles are hexadecimal parameter values that affect the particular visual presentation of the window object, according to conventions of the Microsoft Windows GUI. (For example, two related dialogs, one modal and one not, might share the same class name but differ in their style parameters.) Child identifier distinguishes the window object from \u201csibling\u201d window objects that have the same parent object. The child identifier is Microsoft Windows convention. Within the scope of a given parent window, each child window is uniquely identified by its child identifier.","Note that in practice, dynamic styles are excluded from class styles , window styles , and extended styles . By forming OID tags that are independent of dynamic styles, matches are more likely between different instances of similar objects over time. Different instances of a similar window can vary in their dynamic styles without affecting the object identifier that the naming scheme assigns.","For the most part, the naming scheme has sufficient specificity that, within a given session  at a given moment, the scheme uniquely identifies each object. However, one exception to this specificity occurs for objects from simultaneous similar application instances, i.e., ones that share the same application profile. For example, the main window for each instance will have the same application name and window path . Thus, each instance will have the same object identifier value.","Here is an example of an application name and window path ","MSDEV-\\\u201c(AfxWndClass)\u201d-8-cf0000-100-0\\\u201c(AfxWndClass)\u201d-8-40000000-0-3ea\\\u201c(AfxWndClass)\u201d-8-40800000-0-7310\\\u201c(AfxWndClass)\u201d-8-40000000-0-7310\\\u201c(AfxWndClass)\u201d-8-4000000-200-0","The application name has the value MSDEV. The text between the first two backslashes in the example is the derived string property of a top window: \u201c(AfxWndClass)\u201d-8-cf0000-100-0. This parses into a value of \u201c(AfxWndClass)\u201d [the quote characters are part of the value] for class name, a value of 8 for class style, a value of cf0000 for window styles, a value of 100 for extended styles, and a value of 0 for child identifier. The text contains derived string properties for four other windows. The corresponding OID tag is:","MSDEV-165-1322699925","In this example, the value 165 is the length of the window path, while the value 1322699925 is the checksum.","Referring to , Windows hook  uses an identifier process  to generate an OID tag for a window object described by a raw application event . Windows hook  detects the event  in the Microsoft Windows messaging stream.","Identifier process  receives a reference to a window object described by a raw application event  (step ). This window object will be referred to as the \u201cbase\u201d window object, as distinct from its parent objects in the object hierarchy. Identifier process  creates a window path for the base window object, beginning with a derived string property for the base window object (step ). Identifier process  iterates up the object hierarchy to the root window object (loop at step  through ). For each successive parent, identifier process  adds a hyphen delimiter (step ) and a derived string property for the current parent window (step ) to the front of the window path text. Dynamic styles are excluded from derived string properties in steps and ","After identifier process  finishes iterating, window path is complete. Identifier process  calculates the length of the window path and a checksum , then forms an OID tag according to object identifier syntax  (step ).","Studio Application","Referring to , broadly, studio application  is a software tool for use by administrators () in developing rulesets  that characterize transactions. Studio application  includes a recording process , which allows an administrator to put studio application  into a recording mode while the administrator interacts with applications\u2014for example, carrying out actions that are representative of a transaction. While in the recording mode, studio application  captures raw application events  that describe real-time user interaction with application instances  and saves a script of the events into an event log . The script includes timestamps that locate each event in time. A playback process  can play the event log back.","Studio application  also provides a debugging process  that guides a user through a repeated cycle of testing a ruleset, inspecting the results, and editing the ruleset. Studio application  allows the administrator to replay a scripted series of events from an event log repeatedly and identically, producing the same events and timings on each playback. This repeatable playback provides a testing environment in which multiple recognition attempts, based on the ruleset, can each be tested against identical inputs, eliminating uncertainty due to changing or differently-timed user input. Furthermore, once such a script is recorded, repeatable playback automates the process of providing input to the recognition engine, which can save considerable human effort during the iterative development of a ruleset.","Referring to , initially, a recording process  receives one or more application prototypes  () describing application instances  to monitor (step ). Recording process  activates terminal agent  (), which gathers raw application events  from the resources associated with the application prototypes , and arranges for terminal agent  to pass such events to recording process  (step ). For example, recording process  registers a recipient object with terminal agent  as a consumer of message objects that reference the raw application events . In software terms, the message objects are a derived class of the raw application event class, enabling them to be used in place of standard raw application events . That is, message objects implement a raw application event interface. Message objects also contain additional data such as a timestamp and, when applicable, an OID tag for the GUI object associated with the raw application event . As part of the activation process (step ), recording process  also instructs terminal agent  to monitor the application prototypes , which characterize resources  () to focus on. Thus, terminal agent  only forwards events to recording process  that are appropriate to the application prototypes .","Next, recording process  waits until receiving user input to begin a demonstration time period, which is a time in which the user can demonstrate interactions to be recorded (step ). For example, recording process  presents the user with a button to click in the GUI, indicating the beginning of the demonstration.","Recording process  concludes the demonstration time period upon receiving user input to that effect (step ). For example, recording process  presents the user with a button to click in the GUI to indicate the end of the demonstration. In the interim between steps and , recording process  designates message objects from terminal agent  for recording (step ). Recording process  writes the designated message objects into an event log  in chronological order (step ), then ends.","Referring to , initially, a playback process  opens an event log , which contains a series of text-formatted translations of message objects (step ). Each message object includes a raw application event interface and a timestamp . When the raw application event originates from a GUI object, the message object also includes an OID tag ","Playback process  opens event log  at specified position in the series of log entries. By default, the opening position is the beginning of the series.","Playback process  loops through the event log, from the first translation of a message object (step ) to the last (step ). The last position is given by length , which is an offset from position . By default, length is the full length of the series. For each translation, playback process  instantiates a raw application event object  (step ) and adds the event object to an event stream, using the timestamp (step ). More specifically, playback process  instantiates an object that implements an interface that acts as raw application event .","Playback process  directs the stream of instantiated events to a ruleset engine  () for recognition (step ). When all logged events have been added to the stream, playback process  terminates.","Referring to , a debugging process  takes an event log  and a ruleset  as input (step ). Debugging process  activates a ruleset engine  () and passes it the ruleset (step ). Debugging process  then uses playback process  to play back the event log (step ). Depending upon configurations and user input, debugging process  can play back the entire event log or just a portion. Playback process  derives an event stream from the event log and directs the stream to ruleset engine  configured with ruleset .","Debugging process  outputs results from ruleset engine  of the playback of the event log, such as the recognition of (or failure to recognize) a transaction (step ). In particular, when event log  contains a pattern of events that demonstrates a known transaction , the results output of step indicates whether the ruleset  causes ruleset engine  to recognize the known transaction. In this case, the results of step indicate the accuracy of the ruleset  at recognizing the demonstrated transaction. Alternatively, when ruleset  encodes a set of rules that are known to cause ruleset engine  to recognize a certain transaction, the results output of step indicates whether the event log contains a pattern of events that satisfy the transaction.","Debugging process  decides whether to edit ruleset  by soliciting input from a user (step ). If the ruleset is to be edited (result ), the debugging process provides a user interface, such as a text editing window, for the user to make changes to the ruleset (step ). The user interface includes a control, such as a button, for the user to indicate the changes are complete, at which point debugging process  passes the updated ruleset  to ruleset engine . Otherwise, if the user declines to edit the ruleset (result ), the debugging process bypasses the editing step ","Debugging process  next decides whether to perform another playback of the event log, again by soliciting user input (step ). If the user chooses playback (result ), the debugging process loops back to step to play at least a portion of the event log using playback process  against ruleset engine . This allows the user to iterate repeatedly through a cycle of playing a recorded event log, inspecting the results, and modifying the ruleset, for example to improve the ruleset engine's recognition of a transaction demonstrated in the event log.","If the user declines playback (result ), the debugging process decides whether to save ruleset  after soliciting user input (step ). If the user chooses (result ), the debugging process saves the ruleset, i.e., commits any changes (step ) before ending; otherwise (result ), debugging process ends without saving the ruleset.","Naming Service and Proxy","Referring to , monitor server  maintains a logical network address, such as an IP address, for each known transaction agent . Monitor server  uses the logical network address to communicate with transaction agent , for example to manage the configuration of transaction agent . Monitor server  can also use the logical network address when analyzing performance data associated with transaction agent , for instance to correlate responsiveness data reported by transaction agent  with network performance data. The logical network address can help identify the transaction agent  with network elements such as a logical or physical path in the network, or with other network elements such as a router or switch.","Monitor server  often maintains contact with a transaction agent  over continuous timeframes of several days. Over such periods, the logical network address, such as an IP address, of the transaction agent can change. For example, when the configuration of network  allows, transaction agent can acquire its IP address via a DHCP (Dynamic Host Configuration Protocol) lease. DHCP is a protocol that allows a node on an IP network to acquire an IP address dynamically, for example from a shared pool of IP addresses, none of which is permanently allocated to nodes. A DHCP server process allocates an IP address to the node using a lease, which specifies a time period during which the allocation is valid. The lease often includes an expiration time, for example 24 or 48 hours after the lease is initiated, depending on the particular policy chosen by network administrators. Under some implementations of DHCP, once the lease expires, a node can renew the lease and retain its IP address, but under other implementations, renewals are not necessarily guaranteed. That is, the request for a renewal can in some cases be denied, resulting instead in the node receiving a lease on a different IP address. Also, again depending again on network policy and implementations, a node that reboots can lose its lease on its logical address. Thus, monitor server  can encounter situations in which the logical network address it has been maintaining for a transaction agent  becomes invalid or obsolete. Furthermore, although technologies exist for resolving other logical addressing schemes to IP addressing, such as DNS (Domain Name System) or WINS (Windows Internet Naming Service), in the general case, it is possible that such services will not be installed on network , or will be inoperative. Moreover, some such technologies (for instance, WINS) are specific to particular operating systems or network protocols, and thus have classes of clients to which they do not extend (for instance, UNIX).","When active, transaction agent  gathers batches of updates to send to monitor server  and transmits the batches at a minimum rate given by an active interval, for example every five minutes. Administrators select the active interval to suit the acceptable latency of updates to monitor server . A shorter active interval decreases the average delay between the time transaction agent  has a piece of information ready to send and the time the information is actually sent. However, over time, a shorter active interval also increases the average number of communications from transaction agent  to monitor server  over the network.","Transaction agent  can be inactive. This inactivity can be a deliberate choice of network administrators. For example, an administrator can install transaction agents  on a first number of client devices  and only activate the transaction agents  on a fraction of the client devices . Such a strategy conserves computing resources of monitor server , or could conserve the number of software licenses that must be purchased if transaction agent  is a commercial product. Alternatively, the inactivity of transaction agent  can be accidental, perhaps due to a software problem or a hardware failure.","Referring to , broadly, for a given transaction agent  that uses a logical network address of client device , a proxy  includes a heartbeat process  which repeatedly sends messages to a naming service  of monitor server , describing the current logical network address of transaction agent . As will be explained in more detail, proxy  sends the messages at intervals  whose length depends on the state of transaction agent . Intervals  include an active interval () and an inactive interval ","Naming service  has a cache table in which it maintains a latest logical network address for transaction agent . Naming service  updates cache table based on the messages sent from proxies . In particular, for each transaction agent , naming service  maintains a cache entry . Each cache entry includes an agent key that uniquely identifies cache entry within cache table ; an agent address that stores the last logical network address known to the monitor server for the transaction agent ; and an agent status , which stores information about the last transmission received from the transaction agent , such as the time of transmission and the interval  that was in effect. Naming service  periodically checks the status of cache entries . Naming service  can purge a cache entry , for example after detecting that a sufficiently long time period has elapsed without communication from transaction agent  or corresponding proxy .","Referring to , at client device  running transaction agent  and proxy , heartbeat process  tests whether transaction agent  is active (step ). If so (result ), heartbeat process  tests whether a latest transmission occurred within an active interval , among transmissions informing monitor server  of the logical network address for transaction agent . By default, active interval is 5 minutes. In general, transmissions such as batches of transaction event objects  from transaction agent  or proxy  to monitor server  include the logical network address for transaction agent . That is, batch transmissions perform at least two functions, reporting transactions as well as reporting the logical network address. Proxy  monitors such transmissions to monitor server , ensuring that the current operative interval  between transmission is not exceeded.","If a time period greater than or equal to active interval has elapsed without sending a transmission of the logical network address to monitor server  (result ), heartbeat process  sends a message to naming service , describing the current logical network address (step ). Otherwise (result ), heartbeat process  loops back to step , repeating indefinitely.","If the transaction agent  that corresponds to proxy  is inactive (result ), heartbeat process  sends a message to naming service , describing the current logical network address, approximately at an inactive interval (step ). Here too, heartbeat process  loops back to step , repeating indefinitely.","By default, inactive interval is six hours. Administrators can change the values of active interval and inactive interval . Typically, however, inactive interval is greater than active interval , so that the overall rate of messages from proxy  is lower when transaction agent  is inactive.","Proxy  is installed on client device  such that proxy  runs automatically as part of the boot procedure of client device . Thus, as client machine powers up after a shutdown, proxy  activates heartbeat process . Similarly, proxy  also runs if client device  reboots. In general, proxy  is active whenever client device  is operational, regardless of the status of transaction agent .","Monitor server  has a static logical network address. Proxy  and transaction agent  are given this address as a parameter during installation and store it persistently on client device .","Pathset Aggregation","Monitoring system  provides data to analytical software (not shown) that detects alarm conditions for a network service or application by generating baseline statistical profiles of the service, then raising alarms when measured performance deviates from the profiles. The analytical software operates in approximately real-time, for example, with delays of zero to 5, 10, or 20 minutes. Such short time frames are important to administrators , for instance, who often have professional responsibility for the operation of the service, application, or underlying network. One challenge to the performance of such systems is that they require a statistically significant amount of data to occur within the window of detection time, in order that the deviation can be predicted with good statistical confidence. If the sample is too sparse, statistical models fail. What is more, the window of detection time often cannot be enlarged enough to compensate for sparse sample streams while still offering real-time or near-real-time alarms.","Data streams from events driven by individual human users can be sparse. As a particular user  interacts with a client device, engaging in operations that generate transactions to be sent to monitor server , the average rate of transactions performed can be quite variable. For example, activity rates can depend upon the user, the type of transaction, and contextual factors such as the time of day. A given client device may go through periods of idleness for several minutes, hours, or even days if the user is away. By the time a single user generates enough activity to characterize a problem condition, the problem may be several hours hold. Also, intermittent problems, such as network traffic blockages, might occur and disappear so rapidly that the detection window on a sparse data stream would not detect them.","Referring to , pathset aggregation  includes pathset aggregation data  and pathset aggregation process . Pathset aggregation data  is a database of information about the network environment in which monitor server  monitors application response. The database stores information about network elements , including clients , servers , and network infrastructure elements such as switches and routers. A client record represents both a client device  and its sessions . A server record represents network services  such as web server or application server ().","Pathset aggregation data  also stores client sets , which are collections of clients, for instance grouped by physical proximity or by function. Thus, a client set could represent a collection of client devices  at a branch office, or all the client devices  in a marketing department of a corporation. Client sets are customizable. Administrators define their semantic meaning and associate each client record with a client set ","Pathset aggregation data  also keeps module records that describe predetermined types of activities between clients and servers over the network. For instance, one module record could specify email traffic, while another specifies DNS services and a third specifies a database application. Module records correspond to values referenced by the \u201cmodule\u201d portion of transaction statement (). Module records can thus describe several type of applications.","In addition, pathset aggregation data  stores pathset records . A pathset record collects aggregate responsiveness data based on a client set and a module. In particular, a pathset record includes a collection of responsiveness samples ; a client set reference that specifies a client set ; and a module reference that specifies a module record . The responsiveness samples collect response data from transaction event objects .","Referring to , a pathset aggregation process  receives a transaction event object  (step ). Pathset aggregation process  retrieves client and module information from transaction event object  and finds a matching pathset record in pathset aggregation data  (step ). Pathset aggregation process  adds transaction statistics from transaction event object  to responsiveness samples of the pathset record (step ).","Periodically, monitor server  passes responsiveness samples of the pathset records to the analytical software for reporting and alarming, for example by writing a file out to shared storage and by sending a message to the analytical software that the file is available for retrieval. The aggregation of transaction statistics according to client set and module provides a sample for a statistical baseline profile of service to clients\u2014in particular, to clients in the client set that consume services of the type described by the module. Moreover, the aggregate data stream for multiple clients is less sparse than the data streams for the clients individually, allowing more rapid detection of deviations from the profile.","Devices","Referring to , standalone device  includes a processor that operates on data stored in memory and executes machine-readable instructions stored in storage . Standalone device  renders visual information on a display device and receives input from users via one or more input devices , such as a mouse and keyboard. Storage includes an operating system that uses a point-and-click GUI. Network interface connects standalone device  to network . Bus carries information between components of standalone device . Similarly, components of monitor server device , terminal server device , and transaction server device  are comparable in general structure and function to their like-named counterparts in standalone device .","It should be understood that the above-described functionality is implemented on one or more digital processors programmed appropriately. These one or more digital processors have whatever input and output interfaces and devices are required to implement the described functionality (including keyboards, display units, modems, cable interfaces) and they include data storage, both internal and external, for storing the program and the data that are discussed herein.","Also a number of embodiments of the invention have been described. Nevertheless, it will be understood that various modifications may be made without departing from the spirit and scope of the invention. For example, in described embodiments, operating system  is a member of Microsoft's Windows family, for example Windows 98. In alternative embodiments, operating system  could belong to another operating system family, for example Macintosh or Unix, including Linux. Furthermore, client device  could be a device other than a traditional personal computer, for example a handheld device or cell phone, with a correspondingly adapted operating system . Accordingly, other embodiments are within the scope of the following claims."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":["FIG. 2C","FIG. 2B"]},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 3C"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 8A"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIGS. 8B and 8C"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 9A"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 9B"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 9C"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 9D"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 9E"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIGS. 9F","b":["9","9"]},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIGS. 10B and 10C"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIGS. 11A and 11B"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 11C"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 11D","FIG. 11C"]},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 11E"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIGS. 11F and 11G","FIG. 11E"]},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 11H"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 15A"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 15B"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 15C"},{"@attributes":{"id":"p-0050","num":"0049"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0051","num":"0050"},"figref":"FIG. 17A"},{"@attributes":{"id":"p-0052","num":"0051"},"figref":"FIG. 17B"},{"@attributes":{"id":"p-0053","num":"0052"},"figref":"FIG. 17C"},{"@attributes":{"id":"p-0054","num":"0053"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 19A"},{"@attributes":{"id":"p-0056","num":"0055"},"figref":"FIG. 19B"},{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIG. 19C"},{"@attributes":{"id":"p-0058","num":"0057"},"figref":"FIG. 20A"},{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 20B"},{"@attributes":{"id":"p-0060","num":"0059"},"figref":"FIG. 21A"},{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 21B"}]},"DETDESC":[{},{}]}
