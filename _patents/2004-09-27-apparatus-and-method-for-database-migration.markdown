---
title: Apparatus and method for database migration
abstract: Systems and methods consistent with concepts of the present embodiment of the inventive concept provide mechanisms for database migration from one database (source database platform) platform to another (target database platform). The target and source databases can be any relational databases including, without limitation, Oracle, SQL Server (Microsoft), DB2 UDB (IBM), Sybase, MySQL, PostgreSQL, and the like. The inventive methodology will work well for migration of any relational database that implements SQL language from one platform to another. A feature of the invention is the provision of a virtual engine enabling the running of an original application on a migrated database.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07664795&OS=07664795&RS=07664795
owner: Microsoft Corporation
number: 07664795
owner_city: Redmond
owner_country: US
publication_date: 20040927
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["1. RELATED APPLICATIONS","2. FIELD OF THE INVENTION","3. DESCRIPTION OF THE RELATED ART","4. SUMMARY","6. DETAILED DESCRIPTION"],"p":["This application claims priority from, and is a Continuation of, U.S. Provisional Application Ser. No. 60\/506,810, filed Sep. 26, 2003.","The present invention relates generally to migrating a database, and more particularly, to migrating a database code between a source server and a target server, while the source and destination database may be of different platforms or provided by different vendors.","Software applications using databases usually contain client SQL code (that runs in the application process space), stored procedures (that run inside the database) and the data stored in the database. The database itself may also contain the schema, which describes the tables' structure, keys and relationships.","The typical software application that works with the database has client\/server or multi-tier architecture. SQL code can appear in the client, interleaved with the application code written in Java, C\/C++, C# etc. Stored procedures (functions loaded into the database and running in its process space) are all written in SQL. The scripts that create the database (the schema and the code) are written in SQL as well.","There are multiple products on the market delivering different flavors and technologies in schema and data migration. However, the SQL code conversion from one dialect to another is a major challenge. Today, most of the migrations are executed manually which leads to multiple human errors, longer time and higher costs. Recently, IBM introduced a product that helps to automate conversion of SQL code from other platforms to IBM's DB2 UDB. However, the IBM product cannot be used for migration between other vendors' platforms. Also, Oracle introduced their Migration Workbench that helps to automate the conversion of SQL from other platforms to PL\/SQL (Oracle SQL dialect). Again, this product cannot be used for migrating between other platforms. For example, currently there is no solution to migrate to SQL Server and Sybase platforms. The solution for a back-and-forth migration from one platform to another is also lacking.","This is a very challenging problem for businesses that want to run their products on multiple database platforms. Today, it is also nearly impossible to migrate the application with embedded SQL code without manually rewriting the application. Consequently, when performing database migration, one must also rewrite the application. Conversely, an application vendor must write several versions of the application to enable running on different platforms.","Migrating the database from one vendor platform to another is useful for a number of reasons. Here is a list of such real life examples:\n\n","The following is provided to assist the reader in understanding the problems associated with database migration. The language used for interfacing with relational databases is SQL. Each database platform implements its own flavor of SQL, although all these dialects stem from the early standard ANSI SQL-92.  illustrates the examples of SQL divergence between the dialects.  demonstrates the examples taken from Oracle PL\/SQL and Microsoft SQL Server T-SQL language. Similar kind of differences can be found between DB2, Sybase, MySQL and PostgreSQL dialects.","To make the diagram more readable, appropriate syntax differences are in bold. Statement # demonstrates the syntax difference for local variables. Statement # demonstrates the syntax difference of SELECT statement. Statement # demonstrates the syntax difference using the local variables and calling the procedure for execution. Statement # demonstrates the semantic differences. In this case, Oracle and SQL Server use different functions with different parameter number to implement the same functionality. Statement # demonstrates the differences in handling the outer join feature of SQL. The conversion of this SQL code from one dialect to another, together with the schema migration imposes a substantial challenge to a database migration process.","Systems and methods consistent with concepts of the present embodiment of the inventive concept provide mechanisms for database migration from one database (source database platform) to another (target database platform). The target and source databases can be any relational databases including, without limitation, Oracle, SQL Server (Microsoft), DB2 UDB (IBM), Sybase, MySQL, PostgreSQL, and the like. The inventive methodology will work well for migration of any relational database that implements SQL language from one platform to another.","According to an aspect of the invention, source database at platform A is converted into a target database at platform B, which performs the same functionality as the source database at platform A. The conversion process comprises the steps detailed as follows. The first step is source meta-database creation and loading to the memory. This meta-database is presented in the form of a tree and represents the essence of the data model. The next step is conversion of the schema by migrating the source database objects into the destination ones. During this conversion the objects like tables, columns, indexes, sequences etc. can change their parameters because of the inconsistency in the data types in source and destination databases. This follows by extracting the SQL code of the stored procedures and then parsing of the SQL code and presenting it in the internal tree structure. Declaration point references are setup for local identifiers. This follows by conversion of the parsed tree into the destination platform tree. The tree is transformed appropriately to express the actual SQL code conversion. Then a \u201cpretty printer\u201d components prints the converted code with the proper tabulation, emphasizing correct language components. The converted schema tree then produces the script. This script is loaded to create the target database objects. Finally, the converted SQL stored procedures are loaded into previously converted target database.","Another aspect of the invention is the provision of a virtual engine enabling the running of an original application on a migrated data. This particular feature of the inventive concept demonstrates how to run a client application that was designed for a database platform A to run against a database platform B without rewriting the application code. Using this embodiment of the inventive method introduces an additional innovation that enables run time switching of the application from platform A to B without any code change in application software.","According to yet another aspect of the invention, a system including an application converter is provided. The system receives as input an application which is capable of working only with a database at Platform A (uses SQL dialect A in the client code). A database is provided at Platform B, which performs the same functionality as the source database at Platform A. This state may be achieved after completion of conversion of the database schema and stored procedures to convert database from Platform A to Platform B. The system then provides an application which runs against database on Platform B and performs the same functionality as with the Platform A. Notably, the application code is not changed\u2014only the database driver is replaced.","In a related aspect of the invention, a database driver used by the application is identified and replaced with an SQL Converter Wrapper. The application is run against the target database through all major use case scenarios in order to populate the cache. This kind of a \u201cdry run\u201d can be done during the final testing and doesn't introduce additional overhead to the application performance after deployment.","Another feature of this invention is database virtualization technology that builds upon database migration technology. Database virtualization is a software middleware, which allows client application developed for one database vendor to run on another database vendor system. All discrepancies that stem from database vendors systems are handled by the middleware so that the client software doesn't need to change in any way. This is a unique approach, which differs a lot from existing technologies in this field.","Additional application of the inventive concept allows the database developer to write code for database platform A and automatically convert it to the database B, C and D. This process shortens time to market for many software products.","This embodiment of the inventive concept provides a method of migrating the database schema and SQL code that enables back-and-forth database conversion between various platforms without losing original functionality.",{"@attributes":{"id":"p-0035","num":"0039"},"figref":["FIG. 2","FIG. 2"],"b":["200","250","205","255","210","260","215","265","220","270"]},"The first aspect of database migration according to an embodiment of the invention is moving the schema from one platform to another. This usually involves migration of the tables, database objects and data types. The types that exist on both platforms and represent exactly the same concept are very easy to convert. However, certain data types don't exist on the target database platform. These data types are converted to the closest matching data types in the target platform. This mapping is very important and may later be used in other embodiments of the inventive concept.","The process for schema conversion is depicted in  and is accomplished using following steps. In Step , the method proceeds to connecting to the source database (Platform X in ) and querying for all database objects (tables, stored procedures, cursors, sequences, triggers, etc.). All these objects are stored in memory (Step ) in the form of a tree structure, and later referred to as the meta-database model. Each object in the meta-database model has attributes and references to other objects. This is required in order to keep all needed database information for an accurate conversion to the target platform. Most of the objects like tables, stored procedures, indexes etc. are converted using the information from the source meta-database (Step ). This is accomplished by simply copying the object over to the destination meta-database with some obvious changes.","An example of database object conversion, in this case from Oracle or DB2 UDB to SQL or Sybase, is depicted in . On the left hand of  are the object structure of the source database, in this example of Oracle or DB2 UDB; while on the right hand side are the object structure of the target database, in this example, SQL Server or Sybase. Arrow  depicts an example of a conversion that doesn't modify the source object structure. For example, in this case the object func1, remains as func1 in the target database.","Arrow  depicts an example of handling a packaged function, which is not supported in the target database. In this example, neither SQL Server or Sybase supports packages. Therefore, in the conversion, pkg1_func1 is transformed into the target database independently of any package and, consequently, a new unique name is given to the function, in this case pkg1_func1. Additionally, every call to the original packaged function should be changed in the converted database to a call to the newly named function. Similarly, arrow  depicts an example of a packaged variable pkg1_var1 that needs to be converted into the target database, which doesn't support packaged variables. In this example, the packaged variable is emulated by a new table and a table variable entry. The table is given a name, in this case generated_var_table, and the entire row is dedicated to the value of the original variable.","Arrows  depict another type of object conversion. In this example, the source database has two triggers designated to the same table, of the same type (shown as t1_trigger1 and t1_trigger2_\u2014t1 being the designation of the table). Such a designation is not allowed in target databases, such as SQL Server and Sybase. Therefore, the two triggers need to be converted into a single trigger (shown as t1_trigger). Target trigger t1_trigger will perform both functions of original triggers 1 and 2.","Some objects exist in the source database platform, but not in the destination one. For example, sequence objects in Oracle don't have a parallel structure in SQL Server. They are implemented as an entry in the specifically created table. Arrow  depicts an example of conversion of a sequence seq1 from the source into a table in the target. A more detailed explanation of this process is shown in  and will be explained in more details below.","Returning to , after the source meta-database is converted to the target one, the SQL script is generated by each meta-database object in the tree (Step ). Thus, an overall script for the database creation is generated. This script is all that is required to create a database on the target platform, which is equivalent to the source database. This result script is loaded to the target database platform to create a new database (Step ).","After the schema is migrated, the stored procedure code ( in ) is to be converted to the target SQL dialect. An embodiment of the inventive concept provides a method for automating this process so that approximately 80% of SQL code is converted automatically. This component of the solution is called and further related to as \u201cSQL Converter\u201d. There are many challenges in stored procedure conversion. The short list of them includes, without limitation:\n\n","Most of the developed SQL code used in the stored procedures and client applications uses the system functions (or packages of functions and procedures like in Oracle and DB2) of the source database platform. That is why the step of the system functions conversion is required. In this step the differences between the source and destination system function are identified and the package of newly created functions is generated.","This step insures that the system function called by the source stored procedure\/function or client application will work at the target platform. This step is closely integrated with the SQL Converter, which takes the decision of how each language component should be converted. SQL Converter will recognize the reserved words, which refer to the system function and will know how to translate them correctly using the converted system function package.","While converting the SQL code from a source dialect to a target one, many system functions need to be migrated as well. For example, most mathematics and string manipulation functions are present at both platforms. An example of system function migration, in this case from Platform X being Oracle to Platform Y being SQL Server, is depicted in . In this example, various pre-existing functions of the target database are used to provide an equivalent results obtained from the source system functions. Arrow  depicts an example of combination of functions, e.g., \u201cSYSDATE\u201d (i.e., current date), \u201cNVL\u201d (compares to null), \u201cconcat\u201d (concatenation of two strings), \u201csubst\u201d (substring) and \u201cmod\u201d (modulo, i.e., returns the remainder). During conversion various SQL Server system functions are used to provide the utility of these source functions. In this example, the target system functions used are \u201cgetdate,\u201d \u201cisnull,\u201d \u201c+,\u201d substring,\u201d \u201c%,\u201d respectively. Arrow  depicts an example of the source system function \u201cadd_month\u201d, which adds the stated number of months to the current date. During conversion, the target system function \u201cDATEADD\u201d is used to provide the same functionality. Arrow  depicts an example of a source system functions \u201cto_char,\u201d \u201cto_date,\u201d and \u201cto_number,\u201d to obtain the three exemplary values shown; while during conversion the target system function \u201cCAST\u201d is used three times return the corresponding values. Arrow  depicts an example of an Oracle system function \u201cextract,\u201d which returns year, month, day, hours, minute and second from the system's date, which is the current date. In the conversion, an SQL Server system function \u201cDATEPART\u201d is used to obtain the same results. Arrow  depicts an example of an Oracle \u201cDecode\u201d system function which, depending on the value of the variable, returns a corresponding city name. In converting to SQL Server, the \u201cCASE\u201d system function of SQL Server is used to obtain the same result.","However, many such functions differ in syntax and might have a slightly different logic. For example, an empty string is handled differently by Oracle and SQL and, therefore, selecting an existing target system function may return different value than that returned by the source system function. Accordingly, according to an embodiment of the inventive concept, a step where a library of mapped system functions is provided. Specifically, for each potential target database a tailored function library is created. This library is loaded as the packaged module to the corresponding target database.","According to a further embodiment of the invention, conversion of stored procedures' SQL code (e.g., see business logic  in ) is done using following process:\n\n","In , a piece of code \u201cSELECT customer.name, cutomer.address, FROM customer, oner WHERE customer.id=owner.id ORDER BY 3\u201d is being converted. First the code is parsed and then a tree representation is constructed. The relationships of the various elements (shown as solid lines) and various declaration point references and identifier scope (shown as broken arrow) are maintained in the tree representation.  shows another example, wherein the code contains a procedure. In , the code \u201cCREATE PROCEDURE global_proc @a1 numeric, @a2 char AS BEGIN declare @a3 SET @a3=@a1 END,\u201d is first parsed and then stored in a tree representation. As in the example of , the relationships of the various elements (shown as solid lines) and various declaration point references and identifier scope (shown as broken arrow) are maintained in the tree representation.",{"@attributes":{"id":"p-0050","num":"0063"},"figref":["FIG. 11","FIGS. 9 and 10","FIG. 3"]},"Another aspect of the invention is making a client application work with a target database platform without changing the source application's code. Generally this feature is beneficial for various situations. For example, a company may need to migrate to a new database platform, but wishes all users to be able to use the database without learning a new application. Similarly, an application provider may be able to write one version of its application and use this feature to run that version on any database platform.","Client application usually uses database drivers (special software components) that provide connection to the database through a well-defined interface. This embodiment of the inventive concept will show how the modification of this component combined with the technology of SQL code conversion enables the application to work with the different platform.","The general structure of an embodiment enabling a source application to run on a target database is depicted in . In , a source data  has been migrated to target data ; source schema  has been migrated to target schema ; source business logic  has been migrated to target business logic ; and source stored procedures  have been migrated to target stored procedures . This can be done using the method of the invention as described herein, or any other conventional method. On the other hand, source database driver  and source application  have not been migrated. Rather, target Platform Y incorporates its own database driver  and applications .","A feature of this embodiment of the invention is the inclusion of Converter Wrapper  in target Platform Y. According to this embodiment, when a user uses target application , SQL statements from target application  are issued in SQL dialect Y and, therefore, are sent to database driver  for execution on target Platform Y. On the other hand, when a user executes a command on source application , SQL statements are issued in dialect X. These statements are intercepted by Converter Wrapper  and are translated to SQL statements in dialect Y, which are then sent to target driver  for execution. In this manner, a user can use source application  to run queries on target database without having to migrate to target application .","The construction and operation of the embodiment depicted in  will now be explained with respect the following process. For the sake of simplicity below let's assume that the application is written in Java language and is using JDBC driver to connect to the database. The same conceptual process will work with other languages and ODBC\/OLEDB\/OCI drivers.\n\n","The database driver wrapper implements the following features:\n\n","Steps #3 and #4 can introduce insignificant performance hit for an application. Step #3 will require only 2 additional execution calls so this performance hit is unnoticeable. Step #4 can be more time consuming and depends on the complexity of the incoming call. However, this additional calculation is only performed once for each new type of incoming SQL statement.",{"@attributes":{"id":"p-0058","num":"0080"},"figref":"FIG. 13","b":["1300","1310","1320","1330","1340","1320"]},"Important: while discussing SQL Converter component we mentioned that sometimes only 80% of automatic conversion is achievable because of SQL dialects discrepancies. This can introduce the problem while converting the real time SQL statement. To solve this problem the following solutions are proposed:\n\n",{"@attributes":{"id":"p-0060","num":"0084"},"figref":"FIGS. 16","i":["a","b"],"b":["16","17"]},{"@attributes":{"id":"p-0061","num":"0085"},"figref":["FIG. 16","FIG. 16","FIG. 12"],"i":["a ","b "]},{"@attributes":{"id":"p-0062","num":"0086"},"figref":["FIG. 16","FIG. 16"],"i":["a ","b "],"b":["1600","1610","1620","1630","1640","1600","1650","1640","1650","1600","1610","1620","1630","1660","1620","1675","1665","1670","1680","1660","1660","1690"]},"In the new configuration of , when a call is issued by the client application , it is sent to the driver . The call is then communicated to the middleware  for conversion. Once the call is converted, the converted call is sent back to the driver  and, from the driver , to the database . In this manner, the calls are not communicated to the database from the converter, but rather from the driver.",{"@attributes":{"id":"p-0064","num":"0088"},"figref":["FIG. 17","FIG. 16"],"b":["1700","1710","1720","1740","1705","1750","1755","1760","1765","1770","1700","1701","1702","1703","1704","1706","1707","1708","1700","1780"],"i":"b"},"In the example of , when a call is issued from the server application, , it is sent by the driver  to the middleware . The middleware  is configured to the appropriate database by the configuration console . When the call is received by the API , the conversion engine  checks the cache to see if such a call has already been converted. If so, the converter  fetches the corresponding converted call and sends it to the appropriate database. If such a call has not been previously converted, the conversion engine  converts the call (according to the appropriate meta-database) and sends the converted call to the appropriate database. The conversion engine  also stores the received call and the converted call in the cache .","An overall process of migrating a source database and enabling a source application to work with the newly migrated target database is illustrated with reference to . The system input is source database at platform A, and the output is target database at platform B, which performs the same functionality as the source database at platform A. The precise steps are the following:","Step 1: source meta-database creation, loading to the memory. This meta-database is presented in the form of the tree and represents the essence of the data model.","Step 2: conversion of the schema by migrating the source database objects into the destination ones. During this conversion the objects like tables, columns, indexes, sequences etc. can change their parameters because of the inconsistency in the data types in source and destination databases.","Step 3: extracting the SQL code of the stored procedures; parsing of the SQL code and presenting it in the internal tree structure; declaration point reference are setup for local identifiers; conversion of the parsed tree into the destination platform tree. The tree is transformed appropriately to express the actual SQL code conversion. Finally, \u201cpretty printer\u201d component prints the converted code with the proper tabulation, emphasizing correct language components.","Step 4: the converted schema tree, produces the script. This script is loaded to create the target database objects.","Step 5: the converted SQL stored procedures are loaded into previously converted target database.","In order to enable the source application to function with the migrated target database, the following steps may be performed:","Step 6: The source database driver is replaced so as to work with the converter wrapper.","Step 7: The application is deployed, working with the target database B.","The invention is described herein with reference to particular embodiments thereof which are exemplified in the drawings. It should be understood, however, that the various embodiments depicted in the drawings are for illustration only and may not limit the invention as defined in the appended claims. Additionally, while the invention has been described with reference to particular embodiments thereof, it is not limited to those embodiments. Specifically, various variations and modifications may be implemented by those of ordinary skill in the art without departing from the invention's spirit and scope, as defined by the appended claims."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"5. BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0022"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0023"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0024"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0025"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0026"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0027"},"figref":"FIGS. 6","i":["a ","b "],"b":"6"},{"@attributes":{"id":"p-0024","num":"0028"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0029"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0030"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0027","num":"0031"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0028","num":"0032"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0029","num":"0033"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0030","num":"0034"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0031","num":"0035"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0032","num":"0036"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0033","num":"0037"},"figref":"FIGS. 16","i":["a","b"],"b":["16","17"]}]},"DETDESC":[{},{}]}
