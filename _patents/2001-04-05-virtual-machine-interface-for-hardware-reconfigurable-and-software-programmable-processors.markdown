---
title: Virtual machine interface for hardware reconfigurable and software programmable processors
abstract: The present invention provides a virtual machine interface (VMI) and an application programming interface (API) usable in conjunction with a reconfigurable wireless network communication apparatus. The reconfigurable wireless network communication apparatus comprises a plurality of hardware kernels. The apparatus can be reconfigured to support different or modified communication protocols over time. The VMI comprises a library of software objects. By configuring VMI software objects, a programmer selects the communication protocol used by the reconfigurable wireless network communication apparatus. The API of the present invention provides higher level management of the communication protocol used by a reconfigurable wireless network communication apparatus. The API comprises a library of high level software objects that further abstract hardware details of the apparatus.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07703107&OS=07703107&RS=07703107
owner: Infineon Technologies AG
number: 07703107
owner_city: Neubiberg
owner_country: DE
publication_date: 20010405
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"p":["This application claims priority to the U.S. Provisional Patent Application VIRTUAL MACHINE INTERFACE AND APPLICATION PROGRAMMING INTERFACE FOR HARDWARE RECONFIGURABLE AND SOFTWARE PROGRAMMABLE PROCESSOR, Ser. No. 60\/195,096 that was filed Apr. 6, 2000.","Related applications incorporated herein by reference are as follows:\n\n","A microfiche appendix entitled \u201cAppendix A, Cellular Basestation Modem Engine (CBME) Virtual Machine Interface Specification, Document Version 2.01, \u201d is included in the present application. The microfiche appendix includes 2 microfiche cards.","This invention relates generally to application programming interfaces. More particularly, this invention relates to a virtual machine interface and\/or application program interface.","A cellular communication system is a wireless communication network in which geographical areas are divided into a number of smaller areas or cells in order to provide scalability of coverage for multiple users with minimal intercell interference. A mobile cellular communication system is a cellular communication network in which the terminal devices (users, mobiles) may be in motion from one location to another relative to a basestation.","In a typical digital wireless communication system, multiple basestations are provided to perform switching and connection services between users or terminal devices.  illustrates typical cellular wireless communication system architecture. Basestation - provides wireless communication system to mobile stations  and . Similarly, basestation - provides wireless communication system to mobile stations  and . Basestation - is connected to the basestation - via network .","Referring to , a basestation (BS) provides basic connection service to terminal devices by terminating the radio path and connecting the terminal devices to network . A mobile station (MS) terminates the radio path on the user side and enables the user to gain access to services from the network. Network  typically comprises a mobile switching center (MSC). The MSC is an automatic system that interfaces the user traffic from the wireless network with the wireline network or other wireless networks. The basestations exchange messages with the MSC.","A variety of communication protocols can be used to operate and control a wireless communication system such as the system shown in . Representative protocols include, but are not limited to, the TDMA (time division multiple access) and CDMA (code division multiple access) protocol families. Among other adoptions, TDMA protocol is used by GSM (Global System for Mobile Communication) which comprises GPRS (General Packet Radio Service), ECSD (Enhanced Circuit Switched Data), and EDGE (Enhanced Data rates for Global Evolution) systems. The CDMA protocol is adopted by cdma2000, wideband CDMA (WCDMA), IS-95 CDMA, IS-95B CDMA, CDMA TIA IS2000, TIA IS 2000A, WIMS W-CDMA, ARIB WCDMA, 1Xtrem, 3GPP-FDD, 3GPP-TDD, TD\/SCDMA, as well as several other multi-carrier CDMA systems. Additional 2G and\/or 3G CDMA protocols may be found in , Holma and Toskala eds., John Wiley & Sons. Inc., New York, (2000); and -95 2000, Garg ed., Prentice Hall PTR, Upper Saddle River, N.J., (2000).","Although TDMA and CDMA are the most widely used communication protocols, they each have unique system requirements. Prior art communication systems dedicated to supporting TDMA or CDMA protocols exist. However, the prior art has failed to provide a communication system that is capable of supporting several different protocols, including both TDMA and CDMA, in a satisfactory manner. This failure is in part due to the fact that the hardware necessary to support TDMA is typically not compatible with the hardware necessary to support CDMA. For example, typical TDMA systems require maximum likelihood sequence estimation (MLSE) equalization whereas CDMA systems do not. In contrast, typical CDMA systems require RAKE receivers whereas TDMA systems do not.","Even within the same protocol family, there are variations in the hardware necessary to support the protocol. For example, although both the global positioning system (GPS) and IS-95 are CDMA protocols, GPS and IS-95 have distinctly different hardware requirements. For example, an IS-95 system requires a convolutional decoder whereas GPS does not.","Because of the unique hardware requirements necessary to support each of the existing communication protocols, substantial expense is required to modify a basestation so that it supports a new communication protocol. Indeed, such a modification requires a complete or partial overhaul of a basestation. In prior art systems, the modification of a basestation to support a new communication protocol requires the installation of new equipment as well as significant modification of existing software throughout the network. In addition, new terminal devices are required in order to be compatible with the modified basestation. Thus, modification of a communication protocol used by a basestation  is an expensive and time-consuming task that results in service interruptions. For these reasons, conventional wireless communication systems suffer from a lack of flexibility and adaptability, and cannot provide timely and efficient adaptation to meet the ever-changing needs of the wireless communication field.","Further, in conventional wireless communication systems, preparing an application program to run a particular communication protocol requires a programmer to know or understand the complex details and specifics of the underlying communication hardware. Thus, every time there is a change in communication protocol, the programmer has to first understand what changes are to be made at the hardware level and rewrite application programs accordingly. Such dependence on specific architecture of the underlying hardware makes it even more difficult and expensive to change and maintain wireless communication systems.","In view of the foregoing, it is highly desirable to provide an adaptable and flexible wireless communication system. Also, it is desirable to provide a hardware architecture-independent communication platform on which a programmer can write application programs capable of modifying the communication protocol used by a reconfigurable wireless network communication apparatus without understanding underlying hardware requirements necessary to affect such a modification.","The present invention provides an object-oriented reconfigurable multi-protocol communication system comprising a virtual machine interface (VMI) and an application programming interface (API) for use in a wireless communication network. The wireless communication network includes a reconfigurable wireless network communication apparatus having a plurality of hardware kernels and an interconnect structure. The wireless network communication apparatus is configurable in accordance with a designated communication protocol. The VMI is disposed between an application translation layer and a software virtual machine, and comprises a library of software procedures or objects.","In one embodiment, the software objects of the VMI are hierarchically related. Software objects of the VMI have static attributes and\/or have dynamic attributes. The static attributes are adjustable when the reconfigurable wireless network apparatus, or components thereof, is off-line. The dynamic attributes are adjustable regardless of whether the reconfigurable wireless network apparatus is off-line or on-line.","The software objects of the VMI are associated with hardware kernels in the underlying reconfigurable wireless network communication apparatus, so that manipulation of VMI software objects regulate operations in the respective associated hardware kernels of the reconfigurable wireless network communication apparatus. Therefore, by appropriate manipulation or programming of the VMI software objects, a programmer can control essential functionality within the underlying reconfigurable wireless network communication apparatus without delving into the details and specifics of the reconfigurable wireless network communication apparatus.","A unique advantage of the present invention is that basestation conversion from one communication protocol to another is possible without expensive hardware changes. Rather, such changes are made by appropriate programming or manipulation of the VMI or API.","One embodiment of the invention is directed to CDMA (code division multiple access) applications. In this embodiment, the VMI provides the following software objects: a CDMA basestation engine, a searcher, a code generation unit (CGU), a finger, an uplink and a downlink. In turn, the reconfigurable wireless network communication apparatus provides a searcher kernel, a CGU kernel, a finger kernel, an uplink kernel and a downlink kernel. Each of these kernels are associated with corresponding software objects within the VMI. For example, a VMI finger object is associated with a finger kernel, a VMI searcher object is associated with a searcher kernel, and so forth.","The present invention further provides an application program interface (API) to manage utilization, scheduling, and resource allocation. The API of the present invention comprises a library of higher-level software objects that further abstract the details and specifics of the VMI so that the application programmer can change the communication protocol used by a reconfigurable wireless network communication apparatus using very simple application programs. Indeed, in some embodiments, the API allows a programmer to change the communication protocol used by an apparatus by selecting an option in a simple menu of options. In one embodiment of the present invention, the API provides a standard uniform platform through which the programmer changes the wireless communication protocol used by a reconfigurable wireless network communication apparatus without having to understand the VMI, the details of the underlying hardware of the apparatus, or the requirements and specifications of the selected wireless communication protocol.","In another aspect of the present invention, the API has (i) a parsing routine for parsing an application program that designates a communication protocol and (ii) a machine instruction generation routine for producing machine readable data capable of reconfiguring a wireless network communication apparatus in accordance with a communication protocol designated by the application program. In some embodiments, in accordance with this aspect of the present invention, the machine readable data comprise VMI objects.","Like reference numerals refer to corresponding parts throughout the drawings.","Reference will now be made in detail to the preferred embodiments of the invention, examples of which are illustrated in the accompanying drawings. While the invention will be described in conjunction with preferred embodiments, it is understood that the description is not intended to limit the invention to these embodiments. Rather, the invention is intended to cover alternatives, modifications and equivalents, which may be included within the spirit and scope of the invention, as defined by the appended claims. Additionally, in the following detailed description of the present invention, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it will be apparent to one of ordinary skill in the art that the present invention may be practiced without these specific details. In other instances, well-known methods, procedures, components, and circuits have not been described in detail so as not to obscure important aspects of the present invention. Furthermore, while the present invention may be implemented in a reconfigurable wireless network communication apparatus such as a digital wireless communication system, the methods of the present invention are also well suited for other applications and devices.","Representative reconfigurable wireless network communication apparatuses include, but are not limited to, fixed wireless, unlicenced (FCC) wireless, local area network (LAN), cordless telephony, cellular telephony, personal basestation, and telemetry. Other applications include navigation, encryption, and other digital data processing applications.","The present invention provides an application program interface (API) and a virtual machine interface (VMI) to abstract details of the underlying reconfigurable wireless network communication apparatus so that an application programmer can prepare and modify an application program without requiring knowledge about the configuration, control or management of the underlying communication hardware. Combined with an API, the VMI gives a programmer the ability to adapt to the various communication protocols by invoking specific API and VMI software objects or programs without the need to directly program the hardware of the underlying reconfigurable wireless network communication apparatus. For example, a mobile station programmer can program a mobile station so that it communicates using a new or altered communication protocol by use of the VMI and API rather than directly accessing the registers of the mobile station hardware.",{"@attributes":{"id":"p-0043","num":"0049"},"figref":["FIG. 2","FIG. 2"],"b":["105","205","203","205","207","210","205","203","205"]},"In a preferred embodiment, both the VMI and API are implemented as software procedures or objects. It will be apparent to one skilled in the art that in alternate embodiments of the invention, the VMI and API can also be implemented as hardware. For instance, VMI and API implementations can be implemented as logic on a programmable chip.","In alternate embodiments of the present invention, the VMI and API may be used in conjunction with a basestation and its base transceiver station (BTS) engine. Serving as an interface between the BTS engine and network , the VMI and API enable the programmer to manipulate the reconfigurable BTS hardware by manipulating the VMI and API instead of directly controlling and modifying the BTS hardware. In such embodiments, the BTS hardware comprises multiple hardware kernels, which are configurable into several modes of operation, and parameterizable according to the demands of particular communication protocols such as TDMA and CDMA (code division multiple access). For example, the BTS engine may comprise one or more searchers, fingers, code generation units (CGUs), searcher dwell state machines (DSMs), combiners, uplinks, matched filters, matched filter antennas, downlinks, and transmit multicode channel kernels. Each of these kernels is interconnected by a reconfigurable interconnect structure having flexible bandwidth characteristics. Such a reconfigurable BTS engine is described in U.S. patent application Ser. No. 09\/772,584.","While the methods of the present invention advantageously regulate the communication protocol(s) used by a base station or mobile, it will be apparent to one skilled in the art that the VMI and\/or API of the present invention may also be used in conjunction with hardware units other than a mobile station or basestation as long as the underlying hardware unit has a reconfigurable architecture. Indeed, the VMI and\/or API of the present invention may be used with any reconfigurable wireless network communication apparatus.","Turning to the details of the invention,  illustrates one embodiment of the VMI and the API constructed in accordance with the present invention. API  is disposed between an application translation layer  and an application program . VMI  is disposed between the application translation layer  and a virtual machine layer , which, in turn, is connected to a reconfigurable wireless network communication apparatus . The reconfigurable wireless network communication apparatus  may comprise basestation hardware, mobile station hardware, or any other suitable hardware.","Specifically, API  abstracts details and specifics of the lower level functionality and implementation of the communication system from the programmer. Such details and specifics include application translation layer , VMI , virtual machine  and reconfigurable wireless network communication apparatus . Thus, the programmer can prepare and modify a program without having to worry about the configuration, control or management of the underlying reconfigurable wireless network communication apparatus.","In one embodiment of the invention, API  provides an interface for writing high level programs that are translated by application translation layer  into programs that may include VMI commands. The translated programs, in turn, affect the communication protocol used by reconfigurable wireless network communication apparatus . As a result, API  abstracts information as to the types and numbers of VMI objects necessary to effect a given communication protocol as well as parameter values associated with VMI objects used to implement the given wireless communication protocol. Thus, in one embodiment, the programmer only has to provide application program  with information as to the type of communication protocol of interest. An example of an application program in accordance with the embodiment is provided by illustrative code line .",{"@attributes":{"id":"p-0050","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(401) Set_Communication_Protocol = WCDMA;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":"401"},"In other embodiments in accordance with the present invention, Application programming interface  and application translation  are not used. Rather, a programmer writes a program in a language such as ANSI C that includes program calls to specific VMI objects. In this way, the programmer is able to modify or change the communication protocol or the usage of a communication protocol by reconfigurable wireless network communication apparatus .","From the perspective of the programmer, by abstracting the details and specifics as to the types and numbers of the VMI objects and relevant parameters, API  provides a communication protocol-independent interface through which the programmer can control and operate the underlying reconfigurable wireless network communication apparatus . This convenience makes it possible to standardize the wireless communication architecture because an API can be developed as a uniform, standard platform on which the user can operate and control various wireless communication protocols.","VMI , in turn, abstracts from the user details and specifics of the lower level implementation\u2014virtual machine  and reconfigurable wireless network communication apparatus . In one embodiment of the present invention, VMI  provides a library of software calls for application program . VMI  contains information as to the types and numbers of objects as well as the parameter values associated with the objects necessary to implement a selected wireless communication protocol.","VMI  gives the programmer complete access to and control of reconfigurable wireless network communication apparatus  without the need to directly control or access the apparatus. For example, when used to implement a CDMA basestation, VMI  provides a hierarchical command structure including commands that control mobile and sector allocation of resources of the underlying reconfigurable wireless network communication apparatus . VMI  also provides commands that control datapath interconnection, as well as hardware kernel parameters.","In operation, a particular communication protocol is selected, and the application program  makes the appropriate calls to software routines of API . Application program  is then translated by application translation layer . The software routines of application translation layer  have the information as to the types and numbers of the objects required to perform the particular communication protocol.","In alternate embodiments, the methods and apparatuses of the present invention are practiced without API . In such embodiments, application program  makes calls to necessary software objects of VMI . For example, when the user selects a communication protocol and prepares an application program  to execute the communication protocol, application program  makes calls directly to software objects in VMI . The programmer can instantiate and use any object available from VMI  to perform necessary functions according to the selected communication protocol. After instantiating a particular object, the programmer assigns relevant parameter values to the instantiated objects in accordance with the particular communication protocols selected.","In one embodiment, after application program  is translated into a program readable by virtual machine , virtual machine  issues machine readable instructions and commands to the reconfigurable wireless network communication apparatus  for execution. Unlike application program  and API , virtual machine  requires general knowledge and information associated with underlying reconfigurable wireless network communication apparatus . Using such knowledge, virtual machine  translates the application program into lower level machine code that is required to control the underlying reconfigurable wireless network communication apparatus . Typically, virtual machine  comprises a memory manager, thread scheduler, interpreter, as well as a compiler in order to control and coordinate the performance and execution of the underlying reconfigurable wireless network communication apparatus .","Typically, the reconfigurable wireless network communication apparatus  includes a resource allocator that receives and processes instructions and commands from the virtual machine  to allocate and reconfigure the necessary hardware resources of the reconfigurable wireless network communication apparatus . Thus, the scheduling and resource allocation of the underlying hardware  are transparent to the user. The resource allocation and hardware reconfiguration of the reconfigurable wireless network communication apparatus  is described in U.S. patent application Ser. No. 09\/772,584.","One advantage of including VMI  between virtual machine  and any user program is to use the VMI to abstract details and specifics of the underlying hardware, such as register values. The specifics and details of the underlying reconfigurable wireless network communication apparatus  are handled by virtual machine . Thus, regardless of the type of communication protocol used, the programmer can instantiate and use the Cellular Basestation Modem Engine (CBME), searcher, CGU, uplink, and matched filter objects available within VMI . In one embodiment of the present invention, the programmer does not have to handle any level lower than VMI  in order to program a particular reconfigurable wireless network communication apparatus. Specifically, the user can control the underlying reconfigurable wireless network communication apparatus  by manipulating the objects in VMI  instead of directly controlling and accessing the underlying hardware of the reconfigurable wireless network communication apparatus .","In one embodiment of the present invention, there is at least one hardware kernel assigned to reconfigurable wireless network communication apparatus  for each instantiated software object of VMI . For example, if CBME, searcher, CGU, uplink, and matched filter objects are instantiated from VMI , there is at least one CBME engine, searcher, CGU, uplink, and matched filter kernel assigned in the reconfigurable wireless network communication apparatus . This relationship between the VMI and the underlying hardware makes it easier for a user to prepare and analyze an application program, and shortens the time for the user to convert from one communication protocol to another. For example, in order to convert from W-CDMA protocol to IS-2000, the user instantiates additional objects as necessary, deletes unnecessary objects, and assigns parameter values as appropriate for the new protocol, thereby effectively modifying the underlying reconfigurable wireless network communication apparatus .",{"@attributes":{"id":"p-0061","num":"0067"},"figref":["FIG. 4","FIG. 4","FIG. 4"],"b":["307","307","401","403","413","1","413","2","421","1","421","2","533","1","417","1","2","417","2","411","567","571","401","401"]},"Although certain software objects have been described with respect to  for the purpose of illustration, one of skill in the art will appreciate that other suitable software objects may be created and utilized as the system requires. For example, an encoder\/decoder object may be added.","Turning attention to , each object within VMI  may comprise one or more associated functions or objects. Each of the objects within VMI  is associated with one or more hardware kernels so that changes in the object affect the state of the associate hardware kernel. In some embodiments, each object within VMI  is assigned to a unique or different hardware kernel. However, one of skill in the art will appreciate that many other configurations are possible, including configurations where one or more VMI objects are assigned to the same hardware kernel, or the inverse configuration, in which one or more hardware kernels are assigned to the same VMI object. Each of the software objects illustrated in  will now be described. In this description, both the purpose of the software object and the function of the underlying hardware to which the software object is associated are provided.","Cellular Basestation Modem Engine ","A cellular basestation modem engine (CBME) kernel is a reconfigurable wireless network communication apparatus which itself is composed of a plurality of kernels to facilitate wireless communication. In one embodiment, CBME is a Morphics cellular base transceiver system (BTS). CBME object  is a software object within VMI  that regulates various aspects of the underlying CBME hardware. CBME object  includes associated functions CBME_new  and CBME_set_user-data . CBME_new  is invoked to allocate a new CBME object. CBME_set_user_data  is used to write user data to a CBME object.","Code Generation Unit ","The CBME kernel includes one or more code generation unit (CGU) kernels. The on-chip CGU kernels are object-specific in that each on-chip CGU kernel only works with one type of VMI object. In one embodiment of the present invention, a particular CGU kernel only works with an Uplink , Searcher , a preamble detection engine antenna object, or a downlink object . Illustrative CGU kernels in accordance with various embodiments of the present invention are disclosed in \u201cA configurable code generator system for spread spectrum applications,\u201d U.S. patent application Ser. No. 09\/751,782, filed Dec. 29, 2000; \u201cApparatus and method for calculating and implementing a Fibronacci mask for a code generator,\u201d U.S. patent application Ser. No. 09\/751,776, filed Dec. 29, 2000; \u201cUniversal code generation,\u201d U.S. Ser. No. 60\/222,829, filed Aug. 3, 2000; and \u201cA Wireless Spread Spectrum Communication Platform Using Dynamically Reconfigurable Logic,\u201d U.S. patent application Ser. No. 09\/772,584, filed Jan. 29, 2001.","In some embodiments of the present invention, the CGU unit kernel provides all required codes among a set of standards, including but not limited to IS-95, cdma2000, IS2000, ARIB, and 3GPP. Various codes are generated for both uplink and downlink requirements. In some embodiments of the present invention, CGU kernels contain timing information for a modem and for each individual finger of a RAKE receiver. In additional embodiments of the present invention, the CGU contains a mask generation unit, which is used to transform a given code offset into a set of code dependent parameters. Such parameters are used in the reassignment of a code's phase. The output of a CGU kernel is a pseudo-random noise code sequence for the downlink and each RAKE finger.","Code generation unit (CGU) object  includes functions such as CGU_new  and CGU_set_user_data . CGU_new  is invoked to allocate a new CGU object  and object CGU_set_user_data  is used to write user data to a CGU object .","Searcher ","In a spread spectrum system, basestations as well as some handsets transmit a standardized pilot signal having a known sequence of binary digits to aid in communication of data signals. These pilot signals can have a wide variety of codes, as determined by a specific communication protocol. For example, in one protocol a pilot signal has a length of 2(32,768) bits (or chips). This known sequence is referred to as a short pseudonoise (PN) sequence in IS-95 CDMA.","A searcher kernel is designed to search for new multi-paths by correlating a received code sequence such as a short PN sequence having an unknown phase with a second code sequence that is a locally generated PN sequence with a known phase. Once a searcher kernel finds a multi-path, a finger kernel is assigned to the multipath. Searcher kernels in accordance with the present invention are disclosed in \u201cA Fast Initial Acquisition and Search Device for a Spread Spectrum Communication System,\u201d U.S. patent application Ser. No. 09\/751,777, filed Dec. 29, 2000; \u201cA Configurable Multimode Despreader for Spread Spectrum Applications,\u201d U.S. patent application Ser. No. 09\/751,785, filed Dec. 29, 2000; \u201cA Configurable All-Digital Coherent Demodulator System For Spread Spectrum Applications,\u201d U.S. patent application Ser. No. 09\/751,783, filed Dec. 29, 2000.","Referring to , a Searcher object  provides a software object for controlling a searcher kernel. In a typical embodiment, a Searcher object  is associated with a searcher kernel and thereby processes correlation results, performs peak detection, threshold comparison, and controls a multi-standard multi-dwell search engine.","Searcher object class  includes Searcher_new . When Searcher_new  is called by VMI , a number of processing steps are automatically performed for the user programmer in order to look for conflicts and to properly initialize resources for the underlying searcher kernel. Use of an object such as Searcher_new  is advantageous because it allows the programmer to request a Searcher kernel without painstaking hardware level programming, such as board and chip programming, and conflict management. The processing steps that are performed for the programmer by Searcher_new  in one embodiment in accordance with the present invention are illustrated in .","Turning attention to , the processing steps performed by one embodiment of Searcher_new  begin with processing step . In processing step , a particular searcher object  is identified. All subsequent processing steps either check to determine whether attributes of the searcher  identified in step  are in the appropriate state and\/or set particular attributes of the searcher  identified in processing step .","In processing step , a check is made to see if error checking is enabled. If error checking is enabled (-Yes) then a number of checks are performed. It will be appreciated that the order of many of the checks that are performed is not important. Additionally, one of skill in the art will appreciate that several additional checks that are not disclosed in  could be performed and all such checks are within the scope of the preset invention.","In a first check, a determination is made as to whether the searcher  that has been obtained by a call to Searcher_new  is of the right type. In some embodiments of the present invention, there are two types of searchers, those that are dedicated to finding new mobiles and those that are dedicated to existing mobiles. If the searcher  that has been obtained by a call to Searcher_new  is not dedicated to finding new mobiles (-No) the process ends with return error . If the searcher  is dedicated to finding new mobiles (-Yes) then check  is performed. In processing step , a check is performed to see whether a function call has been made to a routine that sets cellular basestation modem engine (CBME) mobile resources. If the routine has not been called (-No), CBME  () is not in the appropriate state and the process ends with return error . If the routine has been called (-Yes) check  is performed. In check , a determination is made as to whether the time period for the searcher  identified in processing step  has been set. Check  returns an error if the time period for the searcher  has not been set (-No) and the process ends with error condition . If a time period has been set for the searcher , the process continues with check .","In processing step , a check is made to determine whether the fimction CGU_new has been called. CGU_new  allocates a new CGU kernel. Illustrative CGU kernels in accordance with one embodiment of the present invention are disclosed in \u201cA Configurable Code Generator System for spread spectrum applications,\u201d U.S. patent application Ser. No. 09\/751,782, filed Dec. 29, 2000. If CGU_new  has not called (-No), the process ends with return error . If a CGU_new  has been called (-Yes), a determination  is made as to whether the CGU kernel fetched by CGU_new  is the right type. In one embodiment of the present invention there are four types of CGU kernels, a searcher CGU, an uplink CGU, a Preamble Detection Engine (PDE) Antenna CGU, and a downlink CGU. Check  will return an error (-No; ) if the CGU type for Searcher  is any type other than a Searcher CGU.","If the CGU kernel called by CGU_new  is a valid type (-Yes), check  is performed to determine whether the CGU fetched by CGU_new  and the Searcher are assigned to the same CBME  (). If the CGU and the searcher are not assigned to the same CBME  (-No) the process ends with error . If the CGU and the searcher are assigned to the same CBME (-Yes), the process continues with check . In check , a determination is made as to whether the maximum number of Searchers have already been committed to CBM. . If the maximum number of Searchers have already been committed to CBME  (-Yes), then Searcher_new  will fail and the process ends with error code . If the maximum number of Searchers have not already been committed to CBME  (-No) the process continues with processing steps  through , which are designed to initialize Searcher  and the associated Searcher kernel to the proper state. Although  refers to each error code as error , one of skill in the art will appreciate that each error code  could in fact be a unique error code. For example, a different return value for Searcher_new  could be assigned for each different type of error encountered during processing steps  through .","Attention now turns to processing steps  through  in . Processing step  is reached if all error checks are performed satisfactorily (-No) or if error checking is disabled (-No). In processing step , the searcher type of the searcher is designated as \u201cNEW.\u201d In one embodiment of the present invention, VMI  flags Searcher  as new using illustrative code line .",{"@attributes":{"id":"p-0081","num":"0087"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(101) p_searcher\u2212>searcher_type = M_New_Mobile_Searcher;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["101","413","1202","1222","413","1224","102"],"figref":"FIG. 12"},{"@attributes":{"id":"p-0082","num":"0088"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(102) ++p_cgu\u2212>attach_count;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["102","507","413","1202","1226","413","1228","413","413","413","413"]},"In processing step , the mobile random access memory (RAM) linear feedback shift register (LFSR) associated with Searcher  is zeroed out. In processing step , the mobile RAM DSP memory is zeroed. In processing step , the attribute that tracks the number of searchers assigned to CBME  is incremented by \u201c1\u201d. In processing step , Searcher  is added to the searcher list of CBME  using the SFCM element assigned to Searcher  as an index. In one embodiment, processing step  is performed using illustrative code line .",{"@attributes":{"id":"p-0084","num":"0090"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"196pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(103)","p_cbme\u2212>p_searcher_list"]},{"entry":[{},"[p_searcher\u2212>p_sfcm_data\u2212>sfcm_index] = p_searcher;"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["103","401","401","413","1238","1238","104","109"],"figref":"FIG. 4"},{"@attributes":{"id":"p-0085","num":"0091"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(104) p_searcher\u2212>p_sfcm_data\u2212>p searcher = p_searcher;"]},{"entry":[{},"(105) p_searcher\u2212>p_sfcm_data\u2212>active = M_FALSE;"]},{"entry":[{},"(106) p_searcher\u2212>pdp_read M_TRUE;"]},{"entry":[{},"(107) p_searcher\u2212>new_searcher_called = M_TRUE;"]},{"entry":[{},"(108) p_searcher\u2212>p_cbme = p_cbme"]},{"entry":[{},"(109) p_searcher\u2212>state = M_SEARCHER_STOPPED;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["104","413","413","1202","105","309","106","301","307","301"],"figref":["FIG. 12","FIG. 3","FIG. 3"]},"In illustrative code line , the attribute \u201cnew_searcher_called\u201d is set to \u201cM_TRUE.\u201d This attribute is used to indicate that Searcher_new  has been properly called for \u201cp_searcher.\u201d In illustrative code line , \u201cp_searcher\u201d is associated with CBME . Finally, in illustrative code line , the attribute \u201cstate\u201dis set to \u201cM_SEARCHER_STOPPED\u201d to indicate that the searcher kernel associated with \u201cp_searcher\u201d is not currently in search mode. In processing step , Searcher_New ends with an error free return to the calling program.","Review of the flowchart in  reveals a number of advantages of VMI . The VMI  programmer can use VMI  to request a Searcher  and associated Searcher kernels without need, for instance, to resolve complex hardware conflicts and board level programming.","Returning attention to , Searcher  further includes functions such as Set_searcher_static_attributes , Set_searcher_dynamic_attributes , Searcher_start , Searcher_stop , and Assign_DSM_to_searcher . Set_searcher_static_attributes  is used to set searcher static attributes such as system parameters, antenna data port, and despread mode. The finction Set_searcher_dynamic_attributes  is used to set searcher_dynamic attributes such as channel type and number. Searcher_start  is used to start a Searcher . Searcher_stop  is used to stop a Searcher . Assign_DSM_to_searcher  is used to assign a searcher DSM to a Searcher .","Searcher Dwell State Machine ","Each Searcher  must be assigned to a dwell state machine (DSM). A DSM is used to configure the Searcher algorithm. Searcher_DSM  includes Searcher_DSM_new  and Set_DSM_state_attributes . Searcher_DSM_new  is invoked to allocate a new DSM and Set_DSM_state_attributes  is used to set the integration length and threshold for a specific state of a searcher_DSM. Functionally, a searcher VMI object  is used to control the corresponding searcher kernel hardware for mobile channels, and a searcher_DSM  is used to configure the searcher algorithms. Further details of the searcher hardware kernel are found in U.S. patent application Ser. No. 09\/751,777, filed Dec. 29, 2000.","A searcher PDP (power delay profile) is a data type used to store results returned from the searcher. In one embodiment of the invention, each searcher has one DSM and one PDP.","Preamble Detection Engine ","A Preamble Detection Engine (PDE) kernel detects the presence of access bursts from new mobiles. A PDE is associated with one or more antennas. An access burst signal is used by a mobile to attempt access to a basestation, its time of transmission is random. In the methods of the present invention, a PDE object  is associated with a PDE kernel. The PDE object class  includes PDE_new , for allocating a new PDE, as well as PDE_add_antenna , for adding an antenna to a PDE .","Finger ","A finger kernel is a component of a RAKE receiver kernel. Each finger kernel of the RAKE receiver kernel is used to track an individual multipath signal over time. Multipath signals are caused when the signal emitted from a transmitter \u201cbounces\u201d off an object and arrives at the receiver through an alternate, delayed path. In a typical environment, multipaths are very dynamic in nature since a mobile is moving relative to reflecting objects. A RAKE receiver kernel is used to collect echos (multipath signals), align them in time, then accumulate the energy to produce the best possible signal strength. Each finger locks onto and tracks a particular multipath signal and demodulates the data associated with the signal for later combining with other multipaths. In addition to the fundamental demodulation of the incoming multipath, each finger kernel is required to continually update an estimate of channel quality in order to test for a minimum level of quality across the channel. Further details of finger kernels that are associated with the finger object class  of the present invention may be found in U.S. patent application Ser. No. 09\/772,584.","A finger object  is used to control the corresponding finger kernel. In one embodiment of the present invention, each finger kernel used is associated with a different Finger object  using an association process such as the one described below in conjunction with . The fingers can be combined using combiner object , or can remain independent. Finger object class  includes Finger_new . Finger_new  is invoked to allocate a new finger.","When Finger_new  is called by a VMI application, a number of processing steps are performed by VMI .  is a flowchart that illustrates one embodiment of Finger_new  in accordance with the present invention. The process begins at start . In processing step  a query is made as to whether error checking is to be performed. If error checking is to be performed (-Yes), a number of checks are performed before associating a new finger with a CBME.","In check , VMI  determines whether an instance of CBME_new  has been called. The purpose of CBME_new  is to create a CDMA basestation modem engine object . Thus, by barring allocation of a finger unless CBME_new has been called (-No; ), check  insures that fingers are not allocated to a nonexistent CDMA basestation modem engine object .","In check , VMI  determines whether CBME_set_mobile_resources has been called. CBME_set_mobile_resoures configures the CDMA basestation modem engine object  for (a) the number of mobiles that can be supported and (b) the tracking finger block size for each mobile. CBME_set_mobile_resoures is called by VMI  after calling CBME_get_resource_attributes, which returns the maximum number of fingers (max_fingers) that may be associated with the CBME as well as the maximum number of tracking fingers supported by the CBME at its input clock rate. Using max_fingers, a determination can be made, based on system requirements, on how many mobiles to support, and for each mobile, what will be the initial number of tracking fingers available to it. By barring allocation of a finger unless CBME_set_mobile_resources been called (-No; ), check  insures that fingers are not allocated to a CDMA basestation modem engine object that has not been properly initialized.","Once CBME_set_mobile_resources and CBME_get_resource_attributes have been called, the CBME is properly initialized. Therefore, the maximum number of fingers that may be associated with the CBME is determined. Check  insures that this maximum is not exceeded. If a request is made to associate a finger to a CBME that already has the maximum number of fingers associated with it (-Yes), an error code  is returned.","If error checking is disabled (-No) or all error checks are satisfied (-Yes; -Yes; -No), then normal processing steps  through  are performed by Finger_new . In processing step , the CBME finger count is incremented. The CBME finger count tracks the number of fingers that have been associated with the CBME. In processing step , the finger that is to be associated with the CBME (\u201cparent CBME\u201d) is set a known default state. In one embodiment, processing step  resets the state of the finger in accordance with lines () through () of the following exemplary code.",{"@attributes":{"id":"p-0099","num":"0105"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"(201) memset(p_finger, 0\u00d700, sizeof(FINGER));"]},{"entry":[{},"(202) p_finger\u2212>legal_static_attrib = M_FALSE;"]},{"entry":[{},"(203) p_finger\u2212>toa_delay_valid = M_FALSE;"]},{"entry":[{},"(204) p_finger\u2212>state = M_FINGER_STOPPED;"]},{"entry":[{},"(205) p_finger\u2212>p_comb = NULL;"]},{"entry":[{},"(206) p_finger\u2212>new_finger_called = M_FALSE;"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}},"br":{},"b":["201","206","1126","201","202","203","204","205","417","206"],"figref":"FIG. 11"},"In processing step , the attribute \u201cnew_finger_called\u201d is set to \u201cM_TRUE\u201d to indicate that a new finger has been called. Finally, in processing step , the finger object  is associated with a parent CBME. In one embodiment, processing step  is performed by setting an attribute termed \u201cp_cbme\u201d to the address of the parent p_cbme. Such a command could be performed using line () of the exemplary code.",{"@attributes":{"id":"p-0101","num":"0107"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(207) p_finger\u2212>p_cbme = p_cbme;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}},"br":{},"b":["207","417","401","207","417","401"]},"Returning attention to , the Finger object class  further includes Finger_set_static_attributes , Finger_set_dynamic attributes , Finger_start , and Finger_stop . Set_finger_static_attributes  as well as the VMI object Set_finger_dynamic_attributes  are used to set static and dynamic attributes for a finger, respectively. Finger_start  and Finger_stop  are used to start and stop a finger object , respectively.","Combiner ","A combiner kernel combines the outputs of one or more finger kernels and sums them in accordance with a combining rule. In some embodiments, a combiner kernel is associated with one to sixteen finger kernels. In one embodiment of the present invention, each finger kernel is assumed to track a single multi-path and a set of finger kernels are set up for combining using VMI  ().","After time alignment of each stream, the outputs of the set of finger kernels are combined by arithmetically summing the outputs. In non-coherent IS-95 mode, for example, a combination operation such as a Hadamard Transform results in arithmetic summation of the outputs before entry into a soft decision device. In coherent-mode, each finger kernel provides an estimate of instantaneous channel energy and each is selected for combining based on a sufficiently large SIR. In one embodiment, the largest and smallest instantaneous estimate is recorded for each finger kernel over a window of size K. The finger kernel is selected for combining if the following condition is true:\n\n()\u2267max{()\u00b710()\u00b710}\n\nwhere,\n\n","In CDMA, logical channels include the control and traffic channels. The traffic channels are used to carry user information, along with signaling traffic, between the basestation and the mobile station. The control channels comprise downlink channels and uplink channels. Accordingly, VMI  provides an uplink object  and a downlink object .","Uplink object  is used to group Combiners  along with their respective attached Fingers  as well as Searchers  that are common to a mobile uplink. Typically, Combiners  and Searchers  are added to an Uplink. In some embodiments of VMI , there is no limit to the number of Uplink objects  that can be declared. Uplink object class  includes Uplink_new , which is used to allocate a new uplink. Downlink object class  includes Downlink_new , which is used to allocate a new downlink.","Tx Multicode Channel ","Transmit multicode channel object  includes MTX_new . MTX_new  is used to allocate a Transmitter channel.","Static versus Dynamic Attributes","In some embodiments, objects Set_searcher_static_attributes  and Set_finger_static_attributes  are called to set static_attributes when the underlying hardware is not running or is off-line. For example, static_attributes of a searcher object may be set by calling Set_searcher_static_attributes  upon a power-up or reboot of the system or if the pertinent objects are not running. On the other hand, objects Set_finger_dynamic_attributes  and Set_searcher_dynamic_attributes  are called regardless of whether the underlying hardware is running or not, allowing the dynamic attributes to be set \u201con the fly.\u201d","Additional VMI  Objects","In addition to the VMI objects illustrated in , VMI  includes additional software objects such as a matched filter. The matched filter VMI object is used to control the corresponding matched filter kernel. The matched filter is a faster version of a searcher kernel, but the matched filter kernel is not as configurable as the searcher kernel. In one embodiment of the invention, the matched filter is used when the underlying reconfigurable wireless network communication apparatus  () is configured for 3GPP mode. In another embodiment of the present invention, a matched filter may be used in either a multi-standard CDMA traffic channel receiver or a RACH-type receiver (3GPP) and both coherent and noncoherent accumulation modes are allowed.","Although certain methods and objects have been described with respect to , it will be apparent to one skilled in the art that other objects and methods may be defined and used as appropriate in conjunction with the invention. Further, some objects may be combined or divided. For example, the searcher and finger objects may be combined to form a single object. In another embodiment, the searcher and finger may be further divided into multiple objects.","The VMI of the present invention is designed to synchronize respective hardware kernels with corresponding software objects so that a manipulation of VMI objects within the VMI causes an analogous change in the hardware. To this end, each software object has one or more corresponding hardware components in the underlying hardware CBME. For example, CBME  corresponds to and controls a CBME (CDMA BTS engine). Uplink  corresponds to and controls the uplink hardware components and searcher  corresponds to and controls a hardware searcher in the CBME. Thus, in one embodiment, there is at least one hardware module for each VMI software object. In alternate embodiments of the invention, there may be a many-to-one correspondence between software objects and the counterpart hardware kernel. This is possible when one hardware kernel is configured to support multiple counterpart software objects in a time-sliced fashion. For example, one hardware searcher kernel may support many software searcher objects if the latter can be serviced by the hardware kernel in a time multiplexed fashion. In still other embodiments, there may be a many-to one correspondence between hardware kernels and a VMI software object.",{"@attributes":{"id":"p-0112","num":"0120"},"figref":["FIG. 6","FIG. 6"],"b":["601","2","603","605","607","609","1","611","2","613","615","617","619","621","623"]},"As  illustrates, there is a hierarchical relationship among VMI objects in one embodiment of the present invention. On the hardware side, hardware kernels, , , ,  and  are coupled to each other via a reconfigurable interconnect . As  illustrates, there is at least one hardware kernel for each instantiated object in the VMI in some embodiments of the present invention. For example, the CGU , combiner , and matched filter  are each supported by hardware counterparts: CGU , combiner  and matched filter . However, it is also possible for one hardware kernel to support a plurality of VMI objects. For example, in , searcher objects  and  are supported by a single searcher kernel . Such single-kernel-to-multiple-object correspondence is possible if searcher objects  and  can be serviced by the single searcher kernel  in a time multiplexed fashion.","As discussed above, the VMI objects illustrated in  are designed to synchronize the corresponding hardware kernels so that a manipulation of the VMI objects causes an analogous change in the hardware components. For example, if the user changes a parameter in a searcher object , for instance the sub-chip resolution value of the searcher object , that change will be reflected in the corresponding hardware kernel  within the appropriate time interval.","Although a searcher, finger, combiner, code generation unit and matched filter are shown in , it will be appreciated by one skilled in the art that as many hardware kernels and corresponding software objects may be created and utilized according to the needs and requirements of a particular communication system as may be permitted by the available resources. Various VMI objects can be instantiated, parameterized and reconfigured to accommodate and adapt to the unique requirements of various communication protocols. For example, when a CDMA protocol is used, a MPSK (multiple phase shift keying) demodulator object, a convolutional decoder object, and a rake receiver object are instantiated and parameterized to configure the corresponding hardware modules. On the other hand, when a TDMA protocol is used, an MPSK demodulator object, a convolutional decoder object, and an MLSE equalization object are instantiated and parameterized according to TDMA system specifications.",{"@attributes":{"id":"p-0116","num":"0124"},"figref":"FIG. 7(A)","b":["701","311","701","703","701","705","309","701","703","309","311"]},"After the resource allocation and configuration are performed in steps  and , the actual allocation and configuration of the hardware resources are performed by the resource allocator of the reconfigurable wireless network communication apparatus , based on the machine-readable instructions provided by the virtual machine .",{"@attributes":{"id":"p-0118","num":"0126"},"figref":["FIG. 7(B)","FIG. 7(B)","FIG. 7(B)","FIG. 7(A)"],"b":["707","707","311","707","709","711","713","309","709","711","309","311"]},{"@attributes":{"id":"p-0119","num":"0127"},"figref":"FIG. 8","b":["801","801","311","307"]},"In step , the programmer determines what objects to instantiate and use for the protocol determined in step . In step , the programmer instantiates an object, and continues until all necessary objects have been instantiated. In step , the programmer parameterizes each object instantiated according to the system specification of the protocol. When the parameterization is complete in step , the programmer continues to the next task.","Alternatively, the programmer may combine instantiation and parameterization in step . In other words, the programmer may instantiate and parameterize each object in step , instead of performing a separate parameterization step in . Thus, the present invention provides the ability to instantiate different VMI objects in steps  through  and to give different parameters to the instantiated objects in steps  through  in order to accommodate different protocols. Once instantiated, VMI objects control and coordinate functions of the corresponding hardware kernels in order to perform a given task. Reconfiguration and parameterization of corresponding hardware kernels are described in U.S. patent application Ser. No. 09\/772,584.",{"@attributes":{"id":"p-0122","num":"0130"},"figref":"FIG. 9","b":["803","811","901","503","903","515","905","517","519","907","565"]},{"@attributes":{"id":"p-0123","num":"0131"},"figref":["FIG. 10","FIG. 10"],"b":["413","1001","1003"]},"In one embodiment of the invention, a searcher can be optimized in different ways. For example, in order to minimize dropped phone calls in a wireless terminal application, a programmer may decide to allocate the majority of search resources to detecting new multi-paths for existing calls at the expense of detecting new calls. The present invention allows such dynamic reallocation of search resources and parameterization at  and , performed by a searcher VMI object. For example, at a peak number of callers, the searchers can be prioritized for minimum dropped calls whereas at a lower number of callers, the searchers can be prioritized to minimize the detection time of new callers.","In the embodiment shown in , blocks  through  are implemented by a VMI searcher object . Hardware\/software interface  provides an interface between the VMI searcher object  and BTS modem .","Now that the basic operation of various VMI  objects has been described, a detailed example of an Application program  will be described to further illustrate the advantages of the present invention. In this example, a CBME  is created, a searcher  is created and associated with the CBME and then the searcher is started.",{"@attributes":{"id":"p-0127","num":"0135"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"252pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["(301)","void DFS_Pre_Simulation Hook(void)"]},{"entry":["(302)","{"]},{"entry":["(303)","UINT16 i;"]},{"entry":["(304)","UINT16 fcount, scount;"]},{"entry":["(305)","UINT16 cgu index = \u22121;"]},{"entry":["(306)","UINT16 stat 0;"]},{"entry":["(307)","UINT16 delay = 0;"]},{"entry":["(308)","UINT16 fractional_delay = 0;"]},{"entry":["(309)","UINT16 cgu_counter = 0;"]},{"entry":["(310)","\/* open the PDP output file *\/"]},{"entry":["(311)","ppdp file = fopen(pdp filename, \u201cw\u201d);"]},{"entry":["(312)","\/* first set up a CBME *\/"]},{"entry":["(313)","p_cbme = malloc(sizeof(CBME));"]},{"entry":["(314)","stat |= CBME_new(p_cbme, DEFAULT_CBME_ADDR, M_MERGE_INT);"]},{"entry":["(315)","stat |= CBME_Set_Mobile_Resources(p_cbme, VMI_FOUR_FING_BLK,"]},{"entry":["(316)","\u2003\u2003\u2003\u2003\u2003VMI_SIXTY_FOUR_MOBS);"]},{"entry":["(317)","\/* perform CBME self test 0, not effect for now . . . *\/"]},{"entry":["(318)","stat |= CBME_Perform_Self_Tests(p_cbme, VMI_TEST0); \/** VMI call **\/"]},{"entry":["(319)","\/* set up a CGU for the uplink *\/"]},{"entry":["(320)","stat |= CBME_Get_CGU_List(p_cbme, &cgu_list);"]},{"entry":["(321)","for (i=0; i<cgu_list.num_on_chip_cgus; i++)"]},{"entry":["(322)","{"]},{"entry":["(323)","\u2003if (cgu_list.cgu_attributes[i].cgu_object_type == M_UPLINK_CGU)"]},{"entry":["(324)","\u2003\u2003{"]},{"entry":["(325)","\u2003\u2003\u2003cgu_index = cgu_list.cgu_attributes[i].cgu_index;"]},{"entry":["(326)","\u2003\u2003}"]},{"entry":["(327)","}"]},{"entry":["(328)","if(cgu_index == \u22121)"]},{"entry":["(329)","{"]},{"entry":["(330)","\u2003fprintf(stderr, \u201cerror: Unable to find CGU type in CGU list\\n.\u201d);"]},{"entry":["(331)","}"]},{"entry":["(332)","p_ul_cgu = malloc(sizeof(CGU));"]},{"entry":["(333)","stat |= CGU_new(p_cbme, p_ul_cgu,"]},{"entry":["(334)","\u2003\u2003\u2003\u2003\u200310 cgu_index, VMI_CGU_CODE_NUMBER);"]},{"entry":["(335)","\/* set up an uplink *\/"]},{"entry":["(336)","p_ul = malloc(sizeof(UPLINK));"]},{"entry":["(337)","stat |= Uplink_New(p_cbme, p_ul, p_ul_cgu);"]},{"entry":["(338)","\/* set up an combiner *\/"]},{"entry":["(339)","p_comb = malloc(sizeof(COMBINER));"]},{"entry":["(340)","stat |= Combiner_New(p_cbme, p_comb);"]},{"entry":["(341)","\/* add combiner to the uplink *\/"]},{"entry":["(342)","stat |= Uplink_Add_Combiner(p_ul, p_comb);"]},{"entry":["(343)","\/* set up 1 finger *\/"]},{"entry":["(344)","for (fcount = 0; fcount < num_fingers; fcount++)"]},{"entry":["(345)","{"]},{"entry":["(346)","\u2003p_fing = malloc(sizeof(FINGER));"]},{"entry":["(347)","\u2003stat |= Finger_New(p_cbme, p_fing);"]},{"entry":["(348)","\u2003\/* set up the finger in the combiner *\/"]},{"entry":["(349)","\u2003stat |= Finger_Set_Static_Attributes(p_fing, &fing_stat_attrib);"]},{"entry":["(350)","\u2003stat |= Finger_Set_Dynamic_Attributes(p_fing, &fing_dynamic_attrib);"]},{"entry":["(351)","\u2003stat |= Add_Finger_To_Combiner(p_comb, p_fing);"]},{"entry":["(352)","\u2003\/* set finger position *\/"]},{"entry":["(353)","\u2003stat |= Finger_Set_Offset(p_fing,"]},{"entry":["(354)","\u2003\u2003\u2003\u2003\u2003fing_offset[fcount], fing_frac_offset[fcount]);"]},{"entry":["(355)","}"]},{"entry":["(356)","stat |= Combiner_Start(p_comb);"]},{"entry":["(357)","assert(stat 0);"]},{"entry":["(358)","\/* set up a searcher *\/"]},{"entry":["(359)","stat |= CBME_Set_Searcher_Energy Scaling(p_cbme,"]},{"entry":["(360)","\u2003\u2003\u2003\u2003\u2003\u2003\u2003M_SEARCHER_SCALE_19_8);"]},{"entry":["(361)","stat |= CBME_Set_Search_Time_Period(p_cbme, TIMER_CONSTANT);"]},{"entry":["(362)","p_searcher = malloc(sizeof(SEARCHER));"]},{"entry":["(363)","stat |= Searcher_New(p_cbme, p_searcher,"]},{"entry":["(364)","\u2003\u2003\u2003\u2003\u2003\u2003\u2003M_EXISTING_MOBILE_SEARCHER, NULL);"]},{"entry":["(365)","stat |= Searcher_Set_Existing_Mobile_Static_Attributes(p_searcher,"]},{"entry":["(366)","\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003&searcher_static_attrib);"]},{"entry":["(367)","assert(stat == 0);"]},{"entry":["(368)","\/* set up a searcher DSM *\/"]},{"entry":["(369)","stat |= CBME_Set_DSM_Subchip_Phase(p_cbme, VMI_DSM_HP_LOW,"]},{"entry":["(370)","\u2003\u2003\u2003\u2003\u2003\u2003\u2003VMI_DSM_HP_HIGH,"]},{"entry":["(371)","\u2003\u2003\u2003\u2003\u2003\u2003\u2003VMI_DSM_1QP_LOW,"]},{"entry":["(372)","\u2003\u2003\u2003\u2003\u2003\u2003\u2003VMI_DSM_1QP_HIGH,"]},{"entry":["(373)","\u2003\u2003\u2003\u2003\u2003\u2003\u2003VMI_DSM_2QP_LOW,"]},{"entry":["(374)","\u2003\u2003\u2003\u2003\u2003\u2003\u2003VMI_DSM_2QP_HIGH);"]},{"entry":["(375)","p_dsm = malloc(sizeof(SEARCHER_DSM));"]},{"entry":["(376)","stat |= Searcher_DSM_New(p_cbme, p_dsm,"]},{"entry":["(377)","\u2003\u2003\u2003\u2003\u2003\u2003\u2003M_DSM_HALF_CHIP, num_dsm_states);"]},{"entry":["(378)","assert(stat == 0);"]},{"entry":["(379)","\/* set up each state of the DSM *\/"]},{"entry":["(380)","for (scount = 0; scount < num_dsm_states; scount++)"]},{"entry":["(381)","{"]},{"entry":["(382)","stat |= Searcher_DSM_Set_State_Attributes(p_dsm,"]},{"entry":["(383)","\u2003\u2003\u2003\u2003\u2003\u2003\u2003scount,VMI_DSM_INT_LEN,"]},{"entry":["(384)","\u2003\u2003\u2003\u2003\u2003\u2003\u2003VMI_DSM_PDI_LEN,"]},{"entry":["(385)","\u2003\u2003\u2003\u2003\u2003\u2003\u2003VMI_DSM_THRESHOLD);"]},{"entry":["(386)","\u2003\u2003\u2003\u2003\u2003\u2003\u2003assert(stat == 0);"]},{"entry":["(387)","}"]},{"entry":["(388)","\/* assign the DSM to the searcher *\/"]},{"entry":["(389)","stat |= Searcher_Assign_DSM(p_searcher, p_dsm);"]},{"entry":["(390)","assert(stat == 0);"]},{"entry":["(391)","\/* add searcher to the uplink *\/"]},{"entry":["(392)","stat |= Uplink_Add_Searcher(p_ul, p_searcher); assert(stat == 0);"]},{"entry":["(393)","\/* start the searcher *\/"]},{"entry":["(394)","stat |= Searcher_Start(p_searcher);"]},{"entry":["(395)","assert(stat == 0);"]},{"entry":["(396)","}\/* end DFS_Pre_Simulation *\/"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"Lines 301 through 396 will now be described in detail.","Step 1: (lines 301-311) In Step 1, the procedure \u201cDFS_Pre_Simulation_Hook\u201d is defined. This procedure will create a CBME  and start a searcher . Further, in lines 301 through 311, various variables that are used by the procedure are defined. Finally, a file for writing out a power delay profile (PDP) is opened.","Step 2: (lines 313-316) VMI  object CBME_new  is used create a CBME . The mobile resources for the newly created CBME  are defined using the VMI  object CBME_set_mobile_resources.","Step 3: (lines 317-318) The VMI  object CBME_Perform_Self_Tests is executed to test the newly created CBME .","Step 4: (lines 319-334) VMI  objects are used to obtain a code generation unit  for an uplink. First, the list of possible CGUs available is obtained. For each available CGU, a check is performed to insure that the CGU has the object type \u201cM_UPLINK_CGU.\u201d When a CGU having this attribute is found, it is initialized and assigned to the newly created CBME  using the VMI  object CGU_new .","Step 5: (lines 335-337) An uplink  is associated with the newly created CBME  using VMI  object Uplink_new .","Step 6: (lines 338-342) A Combiner  is assigned to the newly created CBME  using the VMI  objects Combiner_new  and Uplink_Add_Combiner.","Step 7: (lines 343-357) VMI  objects Finger_New , Add_Finger_To_Combiner , and Finger_Set_Offset are buried in a loop so that \u201cnum_finger \u201d fingers can be created, added to the newly created CBME  and set to an appropriate position. In one embodiment, the value of num_finger is set to \u201c1\u201d so that only one finger is added during step 7. Once the combiner has been appropriately populated with one or more fingers, the Combiner  is started with the VMI  command Combiner_start .","Step 8: (lines 358-367) A searcher is defined. First, the VMI  object CBME_Set_searcher_energy scaling is run. Internally, CBME  generates a 32-bit search result value. However, in some embodiments of the present invention, only 12bits are reported to the microprocessor. CBME_set_searcher_energy_scaling sets the range of energy bits to report to the microprocessor. Next, the VMI  object CBME_Set_Search_Time_Period is executed. This function sets the search period for all searchers under a CBME . The search period is nominally 50 milliseconds and is defined by the following formula:\n\ntimer_constant=(input_chipping_rate*search_period)\/256\n\nAs an example, presume that the desired search period is 50 milliseconds and that the input chipping rate is 3.84 Mcps. Then:\n\ntimer_constant=(3.84E6*50E\u22123)\/256=750\n\nThe minimum duration for the timer setting should be such that it does not restart a new search before the completion of the previous search.\n","Once the time period has been set, the VMI  command Searcher_New  is used to assign a Searcher to the newly created CBME  and the static_attributes of the searcher are defined using VMI  object Searcher_set_existing_mobile_static_attributes. In one embodiment, because the Searcher is set up as an \u2018existing mobile\u2019 searcher the following conditions must be satisfied before a Searcher is started: (i) Searcher_set_existing_mobile_static_attributes must be called, (ii) the Searcher  must be added to an uplink , and (iii) a Combiner , with at least one Finger  must have been added to uplink  and the Combiner  must have been started.","Step 9: (lines 368-392) Once a Searcher  has been defined, a Searcher DSM  is created and assigned to the Searcher. Using VMI  objects, a Searcher DSM  is created and assigned to a Searcher in three stages (i) setting up the Searcher DSM  (lines 368-378), (ii) setting up the state of Searcher DSM  (lines 379-387), and (iii) assigning the Searcher DSM  to the Searcher  (lines 388-390). More specifically, in order to set up a Searcher DSM , the VMI  object CBME_set_DSM_subchip_phase is used to configure the DSM subchip phase. Then, the VMI  object Searcher_DSM_new is used to obtain a searcher DSM  on lines 376 and 377 of the illustrative code. Each state of the Searcher DSM  is then set up using the VMI  object Searcher_DSM_set_state_attributes on lines 382 through 386 of the illustrative code. Once each state of the Searcher DSM  has been set, the Searcher DSM is assigned to the searcher  that was defined in step 8. Further, in lined 392 of the illustrative code, the Searcher  is added to the Uplink  that was associated in step 5 with the newly created CBME .","Step 10: (lines 393-396) In the final step of this illustrative example, Searcher  is started with VMI  object Searcher_start . The process ends on line 396 of the illustrative code with a return to the calling function.","A sophisticated virtual machine interface (VMI) has been described. Further, the function of several VMI objects or procedures in accordance with one embodiment of the present invention have been introduced. In addition, the detailed processing steps performed by two such VMI objects, Finger_new  () and Searcher_new  () have been described. From these examples, one of skill in the art will appreciate that the VMI  of the present invention facilitates the rapid adaptation of a reconfigurable wireless network communication apparatus from supporting one communication protocol, such as CDMA, to supporting another communication protocol, such as a different form of CDMA or, indeed, even TDMA.","The VMI  of the present invention is an example of an approach to providing high level programming support for a reconfigurable wireless network communication apparatus. Such high level programming frees a programmer from the intricacies of setting the appropriate state for each of the hardware kernels as is otherwise necessary to support a given communication protocol. Referring to , a programmer uses VMI  by writing Application programs  which include VMI function calls.","As shown in , the methods of the present invention provide an even higher level of programming control over an apparatus . For instance, Application programs  are in general higher level programs for configuring an apparatus  than Application programs . Application translation mechanism  translates Application program  into a language recognized by virtual machine . In some embodiments, Application Translation  translates Application program  into instructions that are recognized directly by reconfigurable wireless network communication apparatus  and a virtual machine  is not used. In other embodiments, Application Translation translates Application program  into instructions that include VMI instructions. Exemplary codes lines 301 through 396, above, detail an exemplary Application program  whereas Exemplary code line 401, below, illustrates an exemplary Application program .","In , the relationship between an Application program  and an underlying object-oriented, reconfigurable wireless network communication apparatus , in accordance with one embodiment of the present invention, is detailed. One characteristic of Application program  is that it uses a limited instruction set to reconfigure the communication protocol used by the associated reconfigurable wireless network communication apparatus . For example, in one embodiment, a representative Application program  that requests a mobile station to communicate using wideband CDMA (WCDMA) protocol has the form of illustrative code line 401:",{"@attributes":{"id":"p-0144","num":"0152"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"(401) Set_Communication_Protocol = WCDMA;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"A comparison of illustrative code lines 301 through 396, which represents a program of format  (), to the program represented by illustrative code line 401, which represents a program of format , provides one example of how usage of an application translation  layer can be used to simplify the task of a programmer who is reconfiguring a reconfigurable wireless network communication apparatus  to support a different communication protocol.","While  distinguishes between an Application program  and , the present invention contemplates any number of variants of Application program  and . For example, in some embodiments, Application translation  uses VMI objects  as well as a scan chain binary to support an Application program . In other embodiments, Application translation  uses VMI objects  and does not use a scan chain binary.","Reference will now be made to  in order to illustrate the advantage of one embodiment of the present invention in which an Application program  () is used to set the communication protocol for a basestation. In particular,  details the processing steps that are performed in response to the execution of an Application program  such as the one provided by illustrative code line 401 above.","In processing step , application translation  allocates a CBME object  using a software routine such as CBME_new . In processing step  the RAM scan chain is sent to the basestation using a VMI  software routine such as CBME_scan_chain_write. Processing step  is used to initialize a number of on-board CBME RAMs within the basestation. Each of these RAMs can be of a different bit width and word depth. In the embodiment shown in , the RAM CBME scan chain is separated from writing from other scan chains because writing from the RAM scan chain corrupts the data from other scan chains. In processing step , all other scan chains are written to the CBME.","The scan chains that are written to the basestation are summarized in . In , CBME Config Tools  are used to write a scan chain binary  based on appropriate parameterization of lDSP parameters , DLL early\/late settings , \u03bcDSP code , types of code generation , slot formats , and antenna modes . Scan chain binary  therefore consists of microcode for CBME processor elements and parameters for CBME RAM which set items such as decimator taps, interpolator taps, DLL taps, DLL microcode, rate selection, PDE vs. FHT, bypass decimator mode selection, enable\/disable TFCI input, PDEs antenna selection, CGU polynomials, and CGU microcode as well as many other hardware settings.","In processing step , the resources available within reconfigurable wireless network apparatus are determined using a querying routine such as VMI  object CBME_Get_Resource_Attributes. Processing step  will return the maximum number of fingers available to CBME  at the input clock rate supplied by the basestation. In processing step  a determination is made on how many mobiles to support. This decision is based on the number of fingers available to CBME  that was calculated in processing step . Further, in processing step , for each mobile station that will be supported by CBME , a decision is made on the initial number of tracking fingers available to the mobile. In one embodiment, processing step  is executed using VMI  object CBME_set_mobile_resources.","In processing step , the search periodicity of each searcher that will support CBME  is set using a routine such as VMI  object CBME_set_search_periodicity. Further, in processing step , the energy range limits that each searcher will be allowed to report is defined using a routine such as VMI  object CBME_set_searcher_energy_scaling. In processing step  the subchip phase of the searcher DSM associated with each searcher that will support the CBME is set using a routine such as VMI  object CBME_set_DSM_subchip_phase.","In processing step , Preamble Detection Engine (PDE) parameters are defined. Each PDE is assigned a specific mode of operation and an access slot within the basestation. In some basestations in accordance with the present invention, a PDE can be associated with one to eight antennas depending on its mode. In some embodiments, the VMI  fuinction CBME_Set_PDE_Num_Slots configures the total number of access slots for the specific communication standard requested by application program  () as well as the number of PDE time slots.","In processing step , the number of CGUs that are available in the basestation is obtained using a command such as VMI  object CBME_get_CGU_list. Then, in processing step , the list of downlink slot formats that are available on the CBME is retrieved. In processing step , the list of multiplexed transmission fields available within the basestation is retrieved using a routine such as VMI  object CBME_get_downlink_field_list. Finally, in processing step , the uplink slot formats that are available are retrieved using a routine such as VMI  object CBME_get_uplink_slot_format_list.","The VMI of the present invention may be implemented in conjunction with any suitable operating system: real time operating system (RTOS) or non-RTOS. For example, in one embodiment of the invention, the VMI is integrated with a real time operating system (RTOS). In RTOS environment, any preemptive, multi-tasking operating system that supports counting semaphores may be used to support the VMI. A typical example of non-RTOS integrated with the VMI of the present invention is a round robin based operating system.","While reference was made to a Cellular Basestation Modem Engine (CBME) object  when describing VMI , it will be appreciated that VMI  may be used not only for changing or modifying the attributes of one or more communication protocols used by a basestations, but in fact, the communication protocol used by any reconfigurable wireless network communication apparatus including a mobile. Accordingly, in such alternative embodiments, parameters within the CBME object  may be modified, added or deleted in order to adopt to the specific hardware attributes of a particular reconfigurable wireless network communication apparatus.","While VMI  objects were typically referred to as objects such as those found in an object oriented language, it will be appreciated that this representation serves merely as an example. In various embodiments, the VMI  software objects (objects) of the present invention are defined as objects, object classes, sets of objects, sets of object classes, procedures, sets of procedures, functions, sets of functions, or related software routines. What is common to all VMI  software objects of the present invention is that they run to a completed state when called. This feature is advantageous because it allows the software VMI  objects of the present invention to be operated in an operation system free environment. As used herein, a completed state comprises either a successful operation, such as the acquisition of a finger kernel by Finger_new , or an error code upon failure to achieve a task.","A VMI and API have been described in conjunction with a reconfigurable wireless network communication apparatus. Unlike conventional wireless communication apparatuses, the present invention provides a flexible and efficient platform that can easily adapt to various wireless communication protocols. Also, the VMI and API of the present invention abstract the details and specifics of the underlying communication hardware so that a programmer can prepare an application program without having to change or know the specific configuration requirements of the underlying hardware.","As described above, the VMI of the present invention provides a programmer interface to the underlying CBME hardware kernel, providing reconfigurability and flexibility necessary to take advantage of the reconfigurability and flexibility of the underlying CBME kernel. The VMI of the present invention synchronizes the hardware kernels, which comprise the CBME, with corresponding software objects so that a manipulation of the VMI objects causes an analogous change in the hardware. In one embodiment, each software object has one or more corresponding hardware components in the underlying hardware CBME.","The foregoing description, for purposes of explanation, used specific nomenclature to provide a thorough understanding of the invention. However, it will be apparent to one skilled in the art that the specific details are not required in order to practice the invention. In other instances, well known components and devices are shown in block diagram form in order to avoid unnecessary distraction from the underlying invention. Thus, the foregoing descriptions of specific embodiments of the present invention are presented for purposes of illustration and description. They are not intended to be exhaustive or to limit the invention to the precise forms disclosed, obviously many modifications and variations are possible in view of the above teachings. Obviously, the embodiments were chosen and described in order to best explain the principles of the invention and its practical applications, to thereby enable others skilled in the art to best utilize the invention and various embodiments with various modifications as are suited to the particular use contemplated. It is intended that the scope of the invention be defined by the following claims and their equivalents."],"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","MICROFICHE APPENDIX","BRIEF DESCRIPTION OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Application Translation","Alternative Embodiments","CONCLUSION"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["For a better understanding of the invention, reference should be made to the following detailed description taken in conjunction with the accompanying drawings, in which:",{"@attributes":{"id":"p-0023","num":"0029"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0024","num":"0030"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0025","num":"0031"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0026","num":"0032"},"figref":"FIG. 4","b":"307"},{"@attributes":{"id":"p-0027","num":"0033"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0028","num":"0034"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0029","num":"0035"},"figref":"FIG. 7(A)"},{"@attributes":{"id":"p-0030","num":"0036"},"figref":"FIG. 7(B)"},{"@attributes":{"id":"p-0031","num":"0037"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0032","num":"0038"},"figref":["FIG. 9","FIG. 7"],"b":["703","713"]},{"@attributes":{"id":"p-0033","num":"0039"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0034","num":"0040"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0035","num":"0041"},"figref":"FIG. 12"},{"@attributes":{"id":"p-0036","num":"0042"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0037","num":"0043"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0038","num":"0044"},"figref":"FIG. 15"}]},"DETDESC":[{},{}]}
