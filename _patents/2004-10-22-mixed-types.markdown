---
title: Mixed types
abstract: The present invention provides a system and/or method that facilitates programming within Common Language Runtime (CLR) for a C++ programmer by employing a mixed type. An inheritance component creates the mixed type from received code such that the mixed class type is allocated into memory into a pure native part and a pure managed part. Furthermore, construction, destruction and function calls for mixed types are provided facilitating programming within Common Language Runtime (CLR).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07730465&OS=07730465&RS=07730465
owner: Microsoft Corporation
number: 07730465
owner_city: Redmond
owner_country: US
publication_date: 20041022
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["TECHNICAL FIELD","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DESCRIPTION OF THE INVENTION"],"p":["The present invention generally relates to computer systems, and more particularly to a system and method to employ a mixed type that facilitates programming such that cross type inheritance (e.g., cross inheritance to create a mixed type) is facilitated.","As computer science has evolved, object oriented programming has become one of many familiar models designers and programmers utilize to implement functionality within computer systems. The object model generally is defined by a class structure that includes class members providing both methods and associated data elements belonging to the class. The class members thus provide\/define desired functionality within a computer program, wherein an object is declared as an instance of a particular class. As is commonplace, objects often must exchange data and\/or invoke other objects operating on the same platform and\/or communicate with objects belonging to remote platforms. In order to communicate between objects, interface systems and standards have been developed to define how objects may communicate and\/or interact with one another.","A familiar system for communicating and interfacing between objects is known as the Component Object Model (COM), wherein another similar system is referred to as the Common Object Request Brokers Architecture (CORBA). Still yet other communication interfaces may be defined in languages such as JAVA within an operating framework of a Java Virtual Machine, for example. As these and other systems have been developed however, two common object architectures or models generally have emerged and may generally be defined in terms of managed and unmanaged object systems, for example.","Managed objects may be allocated from a heap within a managed software or execution environment and are generally not responsible for managing associated object lifetimes. Managed objects may be described in terms of a data type (e.g., metadata) and automatically collected (e.g., reclaimed) by a managed environment \u201cgarbage collector\u201d that removes the object from memory when the object is no longer being accessed. In contrast, unmanaged objects may be allocated from a standard operating system heap, wherein the object itself is responsible for freeing memory it employs when references to the object no longer exist. This may be accomplished through well-known techniques such as reference counting, for example.","As described above, managed objects may be allocated from a managed heap and automatically garbage collected. In order to achieve this, references to managed objects are traced. In one example, reference counting can be used wherein a last reference to an object is removed, the garbage collector reclaims the memory occupied by the object mitigating the need to reference count managed objects. Yet in a Common Language Runtime (CLR), memory is not reclaimed until a garbage collector is run (e.g., which normally happens with a triggering of low resource conditions). Thus in general, a managed environment essentially handles garbage collection internally. Tracing is possible within managed code because the managed environment keeps track of outstanding references that exist on an object. As each new object reference is declared within managed code, the managed environment adds the reference to a list (e.g., building the list on the fly). At any given time, the managed environment, rather than the object itself, is thus aware of live references that exist on a given object. As references fall out of scope or change value, the list (built on the fly) is determined by knowing a combination of stack walking and how to inspect areas of memory owned by the garbage collector, and as long as a reference remains within managed code, the managed environment is able to trace it. Unfortunately, object references originating from unmanaged code present difficulties when interacting with a managed environment.","One difficulty associated with unmanaged references operating in a managed environment relates to that there is substantially no straightforward way for managed environments to trace references from unmanaged code to managed objects. Even if the managed environment were aware of these references, generally, no information is maintained indicating whether a reference is active or inactive. Thus, since unmanaged clients, for example, are written in unmanaged code, presently, there is not a process for tracing references that unmanaged objects may hold on managed objects executing within a managed environment. Similarly, originating calls from managed environments to unmanaged environments also presents problems relating to managing object lifetimes. For example, unmanaged objects expect to be reference counted, but in a managed environment reference counting is not required for managed objects. It would thus be very confusing if developers that design managed code had to handle references to managed and unmanaged objects differently.","Along with object lifetime management problems described above, managed and unmanaged object systems generally differ in many other significant ways. These differences may include how the object systems provide object interfaces within the respective object systems, how data is structured and\/or defined, and how errors and exceptions are handled, for example. Due to these and other differences between managed and unmanaged object systems, it is presently difficult, time consuming, and expensive in terms of development costs to have objects from an unmanaged system interface and interact with objects from a managed system and visa versa. Moreover, it is generally difficult for managed objects designed according to one object system framework to communicate with objects from an architecturally different managed system framework. This also applies to unmanaged object communications between diverse unmanaged system frameworks.","A classic paradigm relating to managed and unmanaged systems originates from a programming standpoint. Each programming language provides certain characteristics wherein strengths and weaknesses are exposed by, for example, programmers, critics, hackers, and other program languages themselves. Therefore, a programmer must take good with bad when choosing to program for a managed system and\/or unmanaged system. Common Language Runtime (CLR) and C++ Standard are examples of a managed and unmanaged systems respectively, wherein each system delivers tailored benefits and detriments to the individual programmer. Thus, programmers have diverged based upon programming preferences (e.g., type instantiation in memory areas, garbage collection, pointing and reference to types, . . . ) in relation to managed systems or unmanaged systems.","In particular, an unmanaged system allows a programmer to have freedoms not available in a managed system such as freedom with user defined types being instantiated anywhere (e.g., heap or stack), yet does not provide garbage collection. For example, a standard C++ program provides a class template in which \u201cpolicy\u201d controls where an instance of a type is instantiated\u2014yet the definition of the type itself does not control this instantiation. Thus, a C++ environment provided users with certain idioms controlling where or where not a type is instantiated.","On the other hand, various compilers and other tools expose a managed system's functionality that enable designers to write code that benefits from a managed execution environment. Thus, code that is developed with a language compiler that targets a managed system such as, for example, a Common Language Runtime (CLR) is referred to as managed code. This type environment employs features such as, for example, garbage collection based on type, reflection, and handles to reference whole objects.","Managed and unmanaged systems have developed a divergence in programming preference based upon the individual strengths and weakness of managed and unmanaged systems such as, for example, C++ and Common Language Runtime (CLR). In view of the above, there is a need to integrate C++ and Common Language Runtime (CLR) such that strengths are provided wherein weaknesses are concurrently complimented.","The following presents a simplified summary of the invention in order to provide a basic understanding of some aspects of the invention. This summary is not an extensive overview of the invention. It is intended to neither identify key or critical elements of the invention nor delineate the scope of the invention. Its sole purpose is to present some concepts of the invention in a simplified form as a prelude to the more detailed description that is presented later.","The subject invention relates to systems and\/or methods that facilitate programming utilizing a mixed type wherein the mixed type allows consistent treatment of managed types and native types in a plurality of contexts. In particular, benefits within C++ are incorporated into a Common Language Runtime (CLR), and the benefits of a Common Language Runtime (CLR) are incorporated into C++. Mixed types allow C++ features for managed types such as auto storage duration and\/or deterministic finalization for reference and value types. Additionally, the Common Language Runtime's (CLR's) features such as garbage collection and finalization for native types are available utilizing the mixed type.","In accordance with one aspect of the subject invention, a system is provided that creates a mixed type utilizing an inheritance component to facilitate programming. The inheritance component receives code, wherein the code is distinguished as pure native, pure managed, and mixed native\/managed. The pure native classes are allocated by a compiler such that no members are added or changed. The pure managed classes are allocated by a runtime such that no members are added or changed. Inheritance component creates a mixed type wherein the mixed native\/managed portions are allocated in two parts of memory, a pure native part (e.g., npart) and a pure managed part (e.g., mpart). More particularly, a system in accordance with the invention includes a component that receives code to be utilized by a compiler, the code having: pure native portion(s), pure managed portion(s) and mixed native\/managed portion(s). An inheritance component designates respective sections of the mixed native\/managed portion(s) as pure native parts (npart) and\/or pure managed parts (mpart) to facilitate compiling of the code.","In accordance with another aspect of the subject invention, a system is provided that restricts a compiler in order to create the mixed type. The inheritance component does not require the compiler to add an additional Normal GCHandle to a gcnew'd mixed object as an internal object model implementation detail beyond the user-defined members of the class. Moreover, the inheritance component does not require the compiler to implement a ^ as a Normal GCHandle or otherwise physically placing the implementation of a handle (^) such that the garbage collection cannot be done.","In yet another aspect in accordance with the subject invention, the inheritance component interacts with a construction component and a compiler in order to construct a mixed type. The construction component facilitates utilizing the mixed type for a user such that construction of virtual bases, native bases, and managed bases is regulated. Moreover, the inheritance component interacts with a destruction component, wherein destruction of virtual bases, native bases, and managed bases is regulated. Furthermore, the destruction of a mixed type is provided such that the native and managed part are destroyed in accordance with the subject invention.","In another aspect in accordance with the subject invention, the inheritance component further utilizes a function component wherein function calls for mixed types are employed. The function component facilitates calling functions for a mixed class type such that name lookup occurs as if the class where not split into two parts (e.g., an npart and an mpart).","The following description and the annexed drawings set forth in detail certain illustrative aspects of the invention. These aspects are indicative, however, of but a few of the various ways in which the principles of the invention may be employed and the present invention is intended to include all such aspects and their equivalents. Other. advantages and novel features of the invention will become apparent from the following detailed description of the invention when considered in conjunction with the drawings.","The present invention relates to systems and methods that facilitate dynamic programming language execution in a managed code environment. A runtime code generator is provided within the framework of a managed object environment. The code generator includes a class allocator that reserves one or more method slots for a dynamic method call. A dynamic method builder then employs the method slots to generate an intermediate language stream that forms a method description. The method description is then fed to a Just-In-Time (JIT) compiler that returns at least one dynamically generated pointer to facilitate execution of the dynamic method call at runtime. A set of application programming interfaces (APIs) are provided to give users a managed \u201chook\u201d or entry point into the compiler and associated managed execution environment, wherein various other applications for dynamically generated pointers are also supported. By using runtime-code generation, dynamic calls can be compiled at runtime, and if so desired in combination with memorization, the cost of dynamic code can be brought down close to that of ordinary method calls.","As used in this application, the terms \u201ccomponent,\u201d \u201cclass,\u201d \u201callocator,\u201d \u201csystem,\u201d \u201cbuilder,\u201d and the like are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component may be, but is not limited to being, a process running on a processor, a processor, an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components may reside within a process and\/or thread of execution and a component may be localized on one computer and\/or distributed between two or more computers.","The present invention is described with reference to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding of the present invention. It may be evident, however, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form in order to facilitate describing the present invention.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 1","b":["100","104","102","102","100","100","102"]},"The inheritance component  facilitates programming, for example, within a.NET platform wherein the programmer is a C++ developer. By combining C++ qualities to .NET and the Common Language Infrastructure, a powerful programming model exists with multiple benefits. One benefit is that all types in a code can be conceptually instantiated in all memory areas (e.g., managed heap, native heap, and\/or stack). The definition of a type no longer affects where that type can be allocated. Additionally, all types can be garbage collected whether or not the type is allocated on the managed heap. Garbage collection is per-object, providing garbage collection on some but not objects of a given type. Another benefit is the inheritance component  allows *, &, and ^ to refer to all types. Additionally, * has consistent meaning regardless on the type it points.","Furthermore, the system  provides any native or managed (e.g., reference or value) class can have at least one of the following: a destructor and\/or finalizer; inheritance from multiple virtual or nonvirtual base classes and implement multiple interfaces; instances placed on the stack, static storage, raw storage, native heap, and\/or managed heap; and pointer or reference type that points to any type and behaves similarly regardless of the where the location is pointed.","The pure native type distinguished by the inheritance component  is laid out in memory on the native heap. The inheritance component  allows objects to be allocated on the native heap by the command \u201cnew.\u201d Furthermore, objects on the native heap are referred to by utilizing native pointers (*). For example, the code as follows allocates a native object on the native heap:",{"@attributes":{"id":"p-0038","num":"0037"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"N* n1 = new N;","\/\/ allocate a native object on the native heap"]},{"entry":[{},"N* n2 = n1;","\/\/ n1 and n2 point to the same object"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}}},"br":{}},{"@attributes":{"id":"p-0039","num":"0038"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"class C {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"98pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int x;"]},{"entry":[{},"double y;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"Furthermore, the pure managed type distinguished by the inheritance component  is laid out in memory on the managed heap (e.g., garbage collection heap). Objects can be allocated on the managed heap by the command \u201cgcnew.\u201d Moreover, objects can be referred to utilizing handles (^). For example:",{"@attributes":{"id":"p-0041","num":"0040"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["R{circumflex over (\u2009)} r1 = gcnew R;","\/\/ allocate a managed object on the managed heap"]},{"entry":["R{circumflex over (\u2009)} r2 = r1;","\/\/ r1 and r2 point to the same object"]},{"entry":{"@attributes":{"namest":"1","nameend":"2","align":"center","rowsep":"1"}}}]}}}}},"The managed heap provides garbage collection that reclaims memory for the program whether or not the delete command is used. The managed heap provides advantages such as, reflection, security, and as stated supra, garbage collection. It is to be appreciated compacting garbage collection is provided within the managed heap. For example, runtimes are garbage collected because object allocation changes, thus mitigating memory leaks. Compacting garbage collection makes memory more efficient by utilizing locality of reference (e.g., keeping allocated frequently used items together) and locality of time (e.g., referencing the same items).","The inheritance component  employs a mixed type by laying out a pure native part (e.g., npart) and a pure managed part (e.g., mpart) in memory. Utilizing a mixed type allows C++ programmers to treat managed types and native types consistently in all contexts. The inheritance component  requires the compiler  to insert underlying code such that the two families of types appear to be unified to a C++ user. Thus, the C++ user is free to use the types as necessary independent of how the type is defined. Furthermore, the inheritance component  provides pointer operators to C++ such as, a ^ \u201chandle\u201d and a % \u201ctracking reference.\u201d The \u201chandle\u201d is a whole object pointer to a managed object. The \u201ctracking reference\u201d is a reference to any object or subobject.","In order to treat managed types and native types consistently in all contexts, the inheritance component  does not require the compiler  to add an additional \u201cNormal GCHandle\u201d to a mixed object that has been created utilizing \u201cgcnew\u201d as an internal object model implementation detail beyond the user-defined members of the class. For example, a design can require the compiler  to physically split an object's layout across noncontiguous pieces of memory. Extra pointer information is required in at least one of the pieces to enable internal navigation to another piece(s). Additionally, the compiler  must add that additional internal navigation information using only native pointers or non-Normal GCHandles if the object is allocated via gcnew.","Moreover, the inheritance component does not require the compiler  to implement a ^ as a Normal GCHandle or otherwise enable physically placing the implementation of a handle (^) in a place that a garbage collector cannot locate. It is to be appreciated that ^ must always be implemented as a normal ISO CLI object reference, and if a ^ appears as a member of a class type, the object layout ensures ^ member is physically placed on the managed heap or stack.","By restricting the compiler , the inheritance component  provides a user the appearance of unified types within C++ and Common Language Infrastructure (CLI). The inheritance component  utilizes the requirements above in order to prevent the garbage collector to collect free cycles of ^'S including a Normal GCHandle. Thus, using a GCHandle in the implementation of the object layout model or in the implementation of the ^ handle is anathema.","For example, a pure reference class is as follows:",{"@attributes":{"id":"p-0048","num":"0047"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"ref struct R {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"R{circumflex over (\u2009)} next;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"void NoLeak( ) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"R{circumflex over (\u2009)} r = gcnew R;"]},{"entry":[{},"r\u2212>next = r;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{}},"In another example, a native class is as follows:",{"@attributes":{"id":"p-0050","num":"0049"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"struct N {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"N{circumflex over (\u2009)} next;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"void NoLeak( ) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"N{circumflex over (\u2009)} n = gcnew N;"]},{"entry":[{},"n\u2212>next = n;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["102","104"]},"Now turning to , a system  is illustrated that facilitates utilizing a mixed type, which allows C++ programmers to treat managed types and native types consistently in a plurality of contexts. An inheritance component  receives a code in which a separation of pure native, pure managed and mixed native and managed types occurs. A pure native class is a native class type having no user defined members or base classes of managed type or ^ type. A pure managed class is a managed class type having no user-defined members or base classes of native type, *, or &. A mixed type is a managed or native class type that is not a pure managed class or a pure native class. The inheritance component  requires a compiler  to implement underlying actions in order to give the appearance of types to be unified with the interaction between memory such as, but not limited to, a native heap , a stack , and a managed heap . The allocation of objects between the native heap , the stack , and the managed heap  are distinguished based upon code semantics. For example, an object programmed in a native code is allocated on the native heap and an object programmed in managed code is allocated on the managed heap (e.g., garbage collection heap).","An analyzer component  analyzes code such that a pure native type, a pure managed type and a mixed native and managed type are determined. Once determined, the inheritance component  lays out pure native classes by the compiler  on the native heap. In addition, the inheritance component  lays out pure managed classes on the managed heap. However, a mixed native and managed type determined utilizes underlying code in order to provide a programmer to treat types consistently in all contexts.","A restriction component  incorporates restrictions on the compiler  to facilitate creating a mixed type within the system . The restriction component  does not require the compiler  to add an additional Normal GCHandle to a gcnew'd mixed object as an internal object model implementation detail beyond the user-defined members of the class. Additionally, the restriction component  does not require the compiler  to implement a ^ as a Normal GCHandle or otherwise physically placing the implementation of a handle (^) in a place that the garbage collector cannot collect.","The system  further includes a mixed type component  that creates the mixed type in order to facilitate incorporating C++ programming into Common Language Runtime (CLR). A mixed type component  lays out the mixed native and managed type in memory as a pure native part (e.g., npart) and a pure managed part (e.g., mpart). By employing a mixed type, the inheritance component  facilitates coding that relates to garbage collection and type instantiation. For reference class types and native class types, the inheritance component  lays out the mpart such that it physically exists on the managed heap. Moreover, the inheritance component  allocates the mpart for value types such that it physically exists on the managed heap or the stack.","The mixed type component  creates the mpart such that mpart is a pure managed class obeying ISO CLI rules. The mpart inherits from any base class of managed type or from the mpart of any base class of mixed type, and inherits from (e.g., implements) any interface base classes. The mpart contains all members of managed and ^ type. It is to be appreciated the mpart can contain members of simple value type if this is a managed class type. Moreover, mpart contains a native pointer named, for example, _nimpl to its corresponding npart. The _nimpl member is added at the end of the introducing base class (e.g., the class that first introduces the mpart such as the first managed or mixed class) subobject. The mpart also includes full metadata. It is to be appreciated layout of mpart is done by the runtime. Furthermore, the name of the mpart's type is the same as the fully decorated name of the class.","Furthermore, the mixed type component  creates the npart as a pure native class obeying the ISO C++ rules governing native classes. The npart can inherit from base classes of native type, and from the npart of any base class of a mixed type. The npart contains members of native type and a GCHandle (e.g., Normal or WeakTrackResurrection) named, for example, _mimpl to the corresponding mpart. It is to be appreciated the npart can additionally contain members of simple value type if this is a native class type. The mixed typed component  adds the _mimpl member at the end of an \u2018introducing base\u2019 class (e.g., the one that first introduces the mpart such as, the first managed or mixed class) subobject. It is to be appreciated the programmer can utilize a pointer to any pure native base subobject and pass as an argument to a function in an existing dynamic linked library (DLL) without disruption to the system . Mixed type component  creates the npart such that npart includes full program database (PDB) information. Moreover, mixed type component  allows npart to be laid out by compiler  similar to a pure native class type containing the members. Additionally, the name of the npart's type is X_n wherein X is the decorated name of the class. The npart is allocated into memory with the command new. It is to be appreciated that static members of the npart are unique in each application domain (e.g., appdomain).","Furthermore, the mixed type component  can receive code containing simple value types that are mixed native and managed. A simple value type is a value class type having no members of type T^ for any T and no members of type R (or any pointer or reference type referring to R) for any reference class type R. It is to be appreciated built-in types wherein native type and the corresponding unboxed ISO CLI value type are the same type (e.g., int and int32) are simple value types. The mixed type component  provides members of simple value type to appear in the mpart when it is a managed class type. Additionally, the mixed type component  provides members of simple value type to appear in the npart if this is a native class type.","Within the mixed type component , the class being defined within the received code can be a managed class. If the class being defined is a managed class, the mixed type component provides managed functions for all declared functions, including overrides. It is to be appreciated that if the function is virtual, the declared functions are in the in the mpart's vtable. Yet, if the class is a native class within the received code, the declared functions are native functions. When the functions within the native class are virtual, the declared functions are in the npart's vtable.","The mixed type component  creates the mixed class type such that inheritance is simplified. For example, if a managed type inherits from a native type then in the implementation the native part inherits from that type. In other words, the programmer need not program additional or special code based upon the inheritance component  creating the mixed types and associated compiler requirements.","The mixed class type created implements the appropriate N_interface interface. The native part of a mixed type utilizes traditional inheritance to inherit from any and all native bases. Moreover, the npart holds an _mimpl GCHandle to the mpart within the mixed type. The GCHandle can be, for example, Normal or WeakTrackResurrection, based at least upon the allocation technique utilized. GCHandles can be Normal, Weak, WeakTrackResurrection, or pinned. For example, if an instance is allocated with new, the GCHandle is Normal; if an instance is allocated with gcnew or with stack-based semantics, the GCHandle will be WeakTrackResurrection. Furthermore, the mpart within a mixed type holds an _nimpl pointer to the native part. A most-base mixed type owns the GCHandle and the pointer based at least in part upon the native and managed parts that are controlled. Thus, no further pointers or GCHandles are necessary since the mpart derives from the base mpart and the npart is the primary base of the npart.","It is also to be appreciated that additional base interfaces can be added regardless of derivation distance from a mixed type. Yet, additional base interfaces cannot be added with new managed or mixed base classes. Therefore, the mixed type component  selects a base managed type other than Object to define most-base mixed type.","Referring to , a layout for a managed class X with native members for possible types of members is illustrated. It is to be appreciated members that are of mixed type (e.g., RN or NR, where RN is a mixed reference type declared as ref class RN having members or base classes of native * or & type; and NR is a mixed native type declared as class NR having members or base classes of managed type or ^ type) exists in two parts (e.g., the mpart and the npart). The mpart contributes the enclosing class's mpart and the npart contributes to the enclosing class's npart. As seen in , the mixed type is created such that a pure managed class Xrelates to the managed code. Similarly, the mixed type created contains a native class X.","Turning to , a layout for a native class X with managed members for possible types of members is illustrated. The layout differs from the managed class X in that simple value type appears in the npart rather than the mpart. The mixed type is received from the code and the mixed type is created into a pure managed class and a pure native class. The pure managed class X has an Xand the pure native class X_n has a X.",{"@attributes":{"id":"p-0064","num":"0063"},"figref":"FIG. 5","b":["500","504","502"]},"When the inheritance component  determines the received code that contains a mixed type, the mixed type is broken into two parts\u2014a pure native part (e.g., npart) and a pure managed part (e.g., mpart). The mpart is a pure managed class obeying ISO CLI rules governing managed classes. Moreover, the mpart inherits from bases class of managed type or from the mpart of any base class of mixed type and inherits from interface base classes. It is to be appreciated the mpart contains all members of managed and ^ type and a native pointer to a corresponding npart. For example, the pointer can be named _nimpl wherein it is added to the end of the introduced base class subobject.","Additionally, the npart is a pure native class that obeys ISO C++ rules governing native classes. The npart inherits from base classes of native type, and from the npart of any base class of mixed type. It is to be appreciated the npart contains all members of native type and a GCHandle to a corresponding mpart. For example, the GCHandle can be specified as _mimpl wherein it is added at the end of the introducing base class subobject.","Furthermore, the inheritance component  implements restrictions upon the compiler  such as, for example, not requiring the compiler  to add an additional Normal GCHandle to a gcnew'd mixed object as an internal object model implementation detail beyond the user-defined members of the class and not requiring the compiler  to implement a ^ as a Normal GCHandle or otherwise physically placing the implementation of a handle (^) in a place that the garbage collector cannot collect.","It is to be appreciated the inheritance component  creates mixed types such that advantages of C++ are incorporated into a NET environment and the advantages of .NET are incorporated into C++. For example, the system  provides any native or managed (e.g., reference or value) class can have at least one of the following: a destructor and\/or finalizer; inheritance from multiple virtual or nonvirtual base classes and implement multiple interfaces; instances placed on the stack, static storage, raw storage, native heap, and\/or managed heap; and pointer or reference type that points to any type and behaves similarly regardless of the where the location is pointed.","The system  further includes a construction component  wherein construction of any class type T is ensured. For example, any class type T has user-declared constructors, T::T( ). It is to be appreciated in a mixed type created by the inheritance component  that there are two different virtual dispatch mechanisms (e.g., the native vtable and the managed class' virtuals). The construction component  initializes native bases before managed bases. Additionally, the virtual behavior inside the native bases remains unchanged by the construction component  since native vtables are utilized. The virtual behavior inside the managed base also remains unchanged since it used the managed virtual mechanism.","As stated supra, the inheritance component  creates the mixed type containing an npart and mpart, wherein the npart of the mixed type has a GCHanIdle _mimpl set based upon allocation. If the allocation utilized is new, then GCHandle is Normal GCHandle. If the allocation with gcnew, the GCHandle is a WeakTrackResurrection GCHandle. Internally, the _mimpl GCHandle held by the npart is allocated prior to executing the managed base's constructor. Furthermore, the _nimpl npart pointer in the managed part is set prior to calling the native constructors. Construction component  determines whether a Normal or WeakTrackResurrection GCHandle is necessary based at least upon a hidden parameter indicating whether native new was used or not. The construction component  creates the constructor for each external accessible constructor provided and an additional constructor without the additional hidden parameter that forwards to the constructor with the added parameter. It is to be appreciated the mixed class's constructors (e.g., created by the construction component ) that take the additional parameter have restrictive accessibility of their declared accessibility or internal (e.g., the forwarding constructors have accessibility originally specified).","Once the constructor component  provides the native base classes and managed base classes to be initialized, the initializers of all members are executed in order of specified by members in class definition. For example, the following code has constructor call ordering:",{"@attributes":{"id":"p-0072","num":"0071"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":"ref class R2 : NBase1, RBase1 {"}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\/\/..."]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"ref class R3 : R2, NBase2, virtual NBase3 {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"245pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NMember1;"]},{"entry":[{},"MMember1;"]},{"entry":[{},"NMember2;"]},{"entry":[{},"R3( ) : R2( ), NBase2( ), NBase3( ), NMember1( ), NMember2( ), MMember( ) { }"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"259pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"};"},{"entry":"R3 r3;"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}},"br":{},"b":["506","506"]},"The system  further includes a destruction component  that ensures destruction for any class type T with a user-declared destructor such as T::\u02dcT( ). For example, the following code is user-declared destructors:",{"@attributes":{"id":"p-0074","num":"0073"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class N {","ref class R {","value class V {"]},{"entry":[{},"public:","public:","public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"~N( );","~R( );","~V( );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"4"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"21pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"70pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};","};","};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"3","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["508","508"]},"The destruction component  destroys members and base subobjects of a class in the inverse order of construction by the construction component . Otherwise, it is to be appreciated ISO C++ destructor rules are utilized by the destruction component , which includes reference types. With a native class, if a destructor is not defined, the destruction component  implicitly defines one within the compiler . This implicitly defined destructor calls destructors on embedded members of the class. Furthermore, the destruction of a mixed type is provided such that the native and managed part are destroyed in accordance with the subject invention.","In one example, a transitive closure of the generated destructor can end up not destructing members; in that case, an optimizer removes the call to the destructor. It is to be appreciated that reference and value classes have compiler  supplied destructors. Absence of a destructor in the type is interpreted as a destructor where transitive closure does not destruct members. The destructor component  interprets this as the types in the base class library contain only trivial destructors. When dealing with non-trivial destructors, compiler  emits a method definition for the destructor. Furthermore, the class implements the IDisposable interface defined as follows:",{"@attributes":{"id":"p-0077","num":"0076"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"interface class IDisposable {"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void Dispose( );"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["508","502"]},"In another aspect in accordance with the present invention, the compiler  and destruction component  can statically determine a type that implements a destructor. Once determined, the compiler  calls the destructor directly. Yet, if no determination is made whether a dynamic type implements a destructor statically, code is injected at runtime based upon the compiler  and destruction component  such that the object is deleted.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 6","b":["600","602","604","602","602","602"]},"In one aspect in accordance with the subject invention, the inheritance component  restricts the compiler  in order to create the mixed types (e.g., mixed native and managed type). For example, the inheritance component  does not require the compiler  to add an additional Normal GCHandle to a gcnew'd mixed object as an internal object model implementation detail beyond the user-defined members of the class and does not require the compiler  to implement a ^ as a Normal GCHandle or otherwise physically placing the implementation of a handle (^) in a place that the garbage collector cannot collect. Utilizing the restrictions on the compiler  further facilitate creating mixed types for a C++ programmer within a NET environment.","The system  further includes a function component  interacting with the compiler  that facilitates calling functions for mixed types. The function component  and compiler  look up member names for a mixed type as if not split into two parts (e.g., npart and mpart). For example, an object m of mixed class type Mixed, two code contexts call a member function Mixed::f, one from an mpart context and another from an npart context. With mpart context, the call is made form a managed member function of Mixed (or one of Mixed's base classes), which exists in m's mpart, or from outside code that accesses the m object as a Mixed (e.g., m\u2192f( )) or via one of Mixed's managed or mixed base classes. For example, ManagedOrMixedBase^ b=m; b\u2192f( );), which means the access is done via m's mpart. When dealing with the npart context, the call is made from a native member function of Mixed (or of one of Mixed's base classes), which exists in m's npart, or from outside code that is accessing the m object via one of Mixed's native base classes. For example, NativeBase^ b=m; b\u2192f( );), which means the access is done via m's npart.","In order to call the member function f, the compiler  and function component  utilize the name f in the symbol tables of both X (e.g., the mpart) and X_n (e.g., the npart). If no f is found, the program is ill-formed. Yet, if one or more viable functions f is found, and overload resolution and access checking both succeed identifying an unambiguous and accessible matching function f, the compiler  then generates the code to call f utilizing the function component .","In one aspect in accordance with the subject invention, a this-tracking-pointer conversion is required. For example, if the calling context is an mpart context and function f is found in the symbol table for X_n (npart) the compiler  needs to adjust the this-tracking-pointer such that the this-tracking-pointer is converted to a this-pointer, wherein the this-pointer is the address that is stored in _nimpl.","In yet another aspect in accordance with the subject invention, the calling context is an npart context such that the this-pointer is adjusted by the lookup component . For example, the function is found in the symbol table for X (mpart) the compiler  needs to adjust the this-pointer such that the this-pointer is converted to a this-tracking-pointer wherein the this-tracking-pointer is what is stored in _mimpl.","Once the appropriate conversions and adjustments are made by the compiler  utilizing the function component , the compiler  can generate the call to member function f on the appropriate object (e.g., X or X_n). Inside the member function f, the this-pointer is a pointer to the correct native or managed type in relation to the programmer and compiler . Thus, no special or additional code is necessary since the compiler  deals with a regular native or managed object.","For example, the following code can be written:",{"@attributes":{"id":"p-0087","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"class B {"]},{"entry":[{},"public:"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"void f( ) { i_ += 1; }"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"private:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"int i_;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"};"]},{"entry":[{},"ref class D : public B {"]},{"entry":[{},"};"]},{"entry":[{},"int main( ) {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"D{circumflex over (\u2009)} d = new D;"]},{"entry":[{},"d\u2212>f( );"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}},"br":{},"b":["604","606","604","604","606","604","604"]},{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIGS. 7-9"},{"@attributes":{"id":"p-0089","num":"0088"},"figref":"FIG. 7","b":["700","702","704"]},"Then at , the distinguished code is allocated. The compiler lays out the pure native such that no members are added or changed in the native heap. The pure managed code is laid out by the runtime such that no members are added or changed in the managed heap (e.g., garbage collected heap). The mixed native and managed are laid out in memory into two parts. At , the mixed type is created containing a pure native part (npart) and a pure managed part (mpart). The mpart is a pure managed class obeying ISO CLI rules governing managed classes. The mpart contains all members of managed and ^ type and a native pointer corresponding to npart. Conversely, the npart is a pure native class obeying ISO C++ rules governing native clases. The npart contains all members of native type and a GCHandle corresponding to its mpart. Lastly at , the mixed type is utilized to facilitate programming for a C++ user within a NET environment.",{"@attributes":{"id":"p-0091","num":"0090"},"figref":"FIG. 8","b":["800","802","804","806","808","810"]},{"@attributes":{"id":"p-0092","num":"0091"},"figref":"FIG. 9","b":["900","902","904","906","908","910"]},"At , if the call to the function is generated in the npart, the method proceeds to . If the function call is generated in the mpart, the method proceeds to . At , if the function is in the symbol table for X, then the this-tracking-pointer is adjusted at . For example, the this-tracking-pointer is converted to a this-pointer wherein the this pointer is the address that is stored in _nimpl. Once the this-tracking-pointer is adjusted, the method awaits a function call for a mixed class type at . Yet, if the function is not found in the symbol table for X, the method awaits the next function call for a mixed type at . When the function call is generated in the mpart at , the symbol table for X_n is searched seeking the function. If the function is not found, the method awaits the next function call for the mixed type at . However, if the function is found in the symbol table for X_n, the this-pointer is adjusted at . For example, the this pointer is converted to a this tracking-pointer wherein the this-tracking-pointer is the address that is stored in _mimpl. Once the this-pointer is adjusted, the method awaits the next function call for the mixed class type at .","In order to provide additional context for implementing various aspects of the present invention,  and the following discussion is intended to provide a brief, general description of a suitable computing environment in which the various aspects of the present invention may be implemented. While the invention has been described above in the general context of computer-executable instructions of a computer program that runs on a local computer and\/or remote computer, those skilled in the art will recognize that the invention also may be implemented in combination with other program modules. Generally, program modules include routines, programs, components, data structures, etc., that perform particular tasks and\/or implement particular abstract data types.","Moreover, those skilled in the art will appreciate that the inventive methods may be practiced with other computer system configurations, including single-processor or multi-processor computer systems, minicomputers, mainframe computers, as well as personal computers, hand-held computing devices, microprocessor-based and\/or programmable consumer electronics, and the like, each of which may operatively communicate with one or more associated devices. The illustrated aspects of the invention may also be practiced in distributed computing environments where certain tasks are performed by remote processing devices that are linked through a communications network. However, some, if not all, aspects of the invention may be practiced on stand-alone computers. In a distributed computing environment, program modules may be located in local and\/or remote memory storage devices.",{"@attributes":{"id":"p-0096","num":"0095"},"figref":"FIG. 10","b":["1000","1000","1010","1010","1000","1020","1020","1020"]},"One possible communication between a client  and a server  can be in the form of a data packet adapted to be transmitted between two or more computer processes. The system  includes a communication framework  that can be employed to facilitate communications between the client(s)  and the server(s) . The client(s)  are operably connected to one or more client data store(s)  that can be employed to store information local to the client(s) . Similarly, the server(s)  are operably connected to one or more server data store(s)  that can be employed to store information local to the servers .","With reference to , an exemplary environment  for implementing various aspects of the invention includes a computer . The computer  includes a processing unit , a system memory , and a system bus . The system bus  couples system components including, but not limited to, the system memory  to the processing unit . The processing unit  can be any of various available processors. Dual microprocessors and other multiprocessor architectures also can be employed as the processing unit .","The system bus  can be any of several types of bus structure(s) including the memory bus or memory controller, a peripheral bus or external bus, and\/or a local bus using any variety of available bus architectures including, but not limited to, Industrial Standard Architecture (ISA), Micro-Channel Architecture (MSA), Extended ISA (EISA), Intelligent Drive Electronics (IDE), VESA Local Bus (VLB), Peripheral Component Interconnect (PCI), Card Bus, Universal Serial Bus (USB), Advanced Graphics Port (AGP), Personal Computer Memory Card International Association bus (PCMCIA), Firewire (IEEE 1394), and Small Computer Systems Interface (SCSI).","The system memory  includes volatile memory  and nonvolatile memory . The basic input\/output system (BIOS), containing the basic routines to transfer information between elements within the computer , such as during start-up, is stored in nonvolatile memory . By way of illustration, and not limitation, nonvolatile memory  can include read only memory (ROM), programmable ROM (PROM), electrically programmable ROM (EPROM), electrically erasable ROM (EEPROM), or flash memory. Volatile memory  includes random access memory (RAM), which acts as external cache memory. By way of illustration and not limitation, RAM is available in many forms such as synchronous RAM (SRAM), dynamic RAM (DRAM), synchronous DRAM (SDRAM), double data rate SDRAM (DDR SDRAM), enhanced SDRAM (ESDRAM), Synchlink DRAM (SLDRAM), and direct Rambus RAM (DRRAM).","Computer  also includes removable\/non-removable, volatile\/non-volatile computer storage media.  illustrates, for example a disk storage . Disk storage  includes, but is not limited to, devices like a magnetic disk drive, floppy disk drive, tape drive, Jaz drive, Zip drive, LS-100 drive, flash memory card, or memory stick. In addition, disk storage  can include storage media separately or in combination with other storage media including, but not limited to, an optical disk drive such as a compact disk ROM device (CD-ROM), CD recordable drive (CD-R Drive), CD rewritable drive (CD-RW Drive) or a digital versatile disk ROM drive (DVD-ROM). To facilitate connection of the disk storage devices  to the system bus , a removable or non-removable interface is typically used such as interface .","It is to be appreciated that  describes software that acts as an intermediary between users and the basic computer resources described in the suitable operating environment . Such software includes an operating system . Operating system , which can be stored on disk storage , acts to control and allocate resources of the computer system . System applications  take advantage of the management of resources by operating system  through program modules  and program data  stored either in system memory  or on disk storage . It is to be appreciated that the present invention can be implemented with various operating systems or combinations of operating systems.","A user enters commands or information into the computer  through input device(s) . Input devices  include, but are not limited to, a pointing device such as a mouse, trackball, stylus, touch pad, keyboard, microphone, joystick, game pad, satellite dish, scanner, TV tuner card, digital camera, digital video camera, web camera, and the like. These and other input devices connect to the processing unit  through the system bus  via interface port(s) . Interface port(s)  include, for example, a serial port, a parallel port, a game port, and a universal serial bus (USB). Output device(s)  use some of the same type of ports as input device(s) . Thus, for example, a USB port may be used to provide input to computer , and to output information from computer  to an output device . Output adapter  is provided to illustrate that there are some output devices  like monitors, speakers, and printers, among other output devices , which require special adapters. The output adapters  include, by way of illustration and not limitation, video and sound cards that provide a means of connection between the output device  and the system bus . It should be noted that other devices and\/or systems of devices provide both input and output capabilities such as remote computer(s) .","Computer  can operate in a networked environment using logical connections to one or more remote computers, such as remote computer(s) . The remote computer(s)  can be a personal computer, a server, a router, a network PC, a workstation, a microprocessor based appliance, a peer device or other common network node and the like, and typically includes many or all of the elements described relative to computer . For purposes of brevity, only a memory storage device  is illustrated with remote computer(s) . Remote computer(s)  is logically connected to computer  through a network interface  and then physically connected via communication connection . Network interface  encompasses wire and\/or wireless communication networks such as local-area networks (LAN) and wide-area networks (WAN). LAN technologies include Fiber Distributed Data Interface (FDDI), Copper Distributed Data Interface (CDDI), Ethernet, Token Ring and the like. WAN technologies include, but are not limited to, point-to-point links, circuit switching networks like Integrated Services Digital Networks (ISDN) and variations thereon, packet switching networks, and Digital Subscriber Lines (DSL).","Communication connection(s)  refers to the hardware\/software employed to connect the network interface  to the bus . While communication connection  is shown for illustrative clarity inside computer , it can also be external to computer . The hardware\/software necessary for connection to the network interface  includes, for exemplary purposes only, internal and external technologies such as, modems including regular telephone grade modems, cable modems and DSL modems, ISDN adapters, and Ethernet cards.","What has been described above includes examples of the present invention. It is, of course, not possible to describe every conceivable combination of components or methodologies for purposes of describing the present invention, but one of ordinary skill in the art may recognize that many further combinations and permutations of the present invention are possible. Accordingly, the present invention is intended to embrace all such alterations, modifications, and variations that fall within the spirit and scope of the appended claims.","In particular and in regard to the various functions performed by the above described components, devices, circuits, systems and the like, the terms (including a reference to a \u201cmeans\u201d) used to describe such components are intended to correspond, unless otherwise indicated, to any component which performs the specified function of the described component (e.g., a functional equivalent), even though not structurally equivalent to the disclosed structure, which performs the function in the herein illustrated exemplary aspects of the invention. In this regard, it will also be recognized that the invention includes a system as well as a computer-readable medium having computer-executable instructions for performing the acts and\/or events of the various methods of the invention.","In addition, while a particular feature of the invention may have been disclosed with respect to only one of several implementations, such feature may be combined with one or more other features of the other implementations as may be desired and advantageous for any given or particular application. Furthermore, to the extent that the terms \u201cincludes,\u201d and \u201cincluding\u201d and variants thereof are used in either the detailed description or the claims, these terms are intended to be inclusive in a manner similar to the term \u201ccomprising.\u201d"],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
