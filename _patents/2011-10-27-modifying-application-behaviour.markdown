---
title: Modifying application behaviour
abstract: A data processing system comprising: an operating system providing an application programming interface; an application supported by the operating system and operable to make calls to the application programming interface; an intercept library configured to intercept calls of a predetermined set of call types made by the application to the application programming interface; and a configuration data structure defining at least one action to be performed for each of a plurality of sequences of one or more calls having predefined characteristics, the one or more calls being of the predetermined set of call types; wherein the intercept library is configured to, on intercepting a sequence of one or more calls defined in the configuration data structure, perform the corresponding action(s) defined by the configuration data structure.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08763018&OS=08763018&RS=08763018
owner: Solarflare Communications, Inc.
number: 08763018
owner_city: Irvine
owner_country: US
publication_date: 20111027
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["This application relates to data processing systems having an intercept library configured to intercept calls to an application programming interface (API) so as to allow actions to be performed in response to those calls without requiring modification of the application or API itself. The application also relates to an improved mechanism for filtering received messages suitable for use with a data processing system having such an intercept library.","Generally, applications supported by an operating system will be configured to interact with the operating system and other user-level entities by means of software libraries that are configured to provide an application programming interface (API) to the application. Thus, an API defines a standard set of calls by means of which an application can interact with its software environment. For example, a socket library providing a Berkeley sockets API is typically offered by an operating system in order to facilitate high-level communications to and from an application.","Over time, many APIs have become standardised such that an application installed at an operating system will expect to be able to interact with its environment using a set of standard APIs. This presents the problem that the set of functions provided by an API cannot be modified without breaking the API or requiring that the application is itself modified to utilise a modified set of functions. Thus, whilst standardised APIs have the advantage of widespread compatibility with applications, they make it difficult to accommodate changes to the underlying structure of a data processing system\u2014changes, for example, that might provide significant performance improvements were an API able to present an appropriate set of functions.","This problem is well illustrated by a Berkeley socket library which does not provide a mechanism by which received messages can be filtered by an application prior to the receive processing of those messages at the network protocol stack. Conventionally, in order to avoid received messages having to traverse the network protocol stack prior to filtering, one or both of the application and the socket library would have to be modified in order to accommodate a modified receive mechanism, or filtering would have to be performed at the kernel.","The Solarflare OpenOnload user level network stack uses intercept libraries in order to perform certain fixed socket-related functions, but these intercept libraries do not provide the flexibility to allow the behaviour of an application through an API to be readily modified without requiring modification to the application or API. The Solarflare OpenOnload intercept libraries do not, for example, allow filtering of received messages to be performed at the receive queue without modification to the application and socket API.","There is therefore a need for mechanisms by which an application can take advantage of modifications to the operation of its data processing system without requiring modification of the application itself or one or more APIs defining its software environment. In particular there is a need for mechanisms by which the filtering of messages received for an application can be performed without those messages having to first traverse the network protocol stack and without requiring modification of the application itself or the sockets API.","Roughly described, according to a first aspect of the first invention there is provided a data processing system comprising: an operating system providing an application programming interface; an application supported by the operating system and operable to make calls to the application programming interface; an intercept library configured to intercept calls of a predetermined set of call types made by the application to the application programming interface; and a configuration data structure defining at least one action to be performed for each of a plurality of sequences of one or more calls having predefined characteristics, the one or more calls being of the predetermined set of call types; wherein the intercept library is configured to, on intercepting a sequence of one or more calls defined in the configuration data structure, perform the corresponding action(s) defined in the configuration data structure.","The predefined characteristics of a sequence of one or more calls can include the type of call(s) and the parameters of the call(s).","The configuration data structure could include a plurality of specifications each defining a sequence of one or more calls having predefined characteristics and the corresponding action(s) to be performed by the intercept library on a sequence of one or more calls having those predefined characteristics being identified by the intercept library.","The configuration data structure could be a code module that includes code of a particular programming language and the intercept library includes an interpreter configured to interpret that programming language. Preferably the code module includes a handler function for each of at least some of the predetermined set of call types such that, on a sequence of one or more calls being intercepted by the intercept library, the intercept library is configured to call the respective handler function and perform the corresponding action(s) defined in that handler function. Suitably at least some of the handler functions invoke routines of the intercept library in order to effect the corresponding action(s). Preferably the action(s) are performed in the context of the last call in the sequence.","The configuration data structure could include object code arranged to provide a plurality of functions and at least some of the action(s) defined in the configuration data structure use the functions defined in the object code. Suitably at least some of the actions defined in the configuration data structure are arranged to cause the intercept library to directly invoke functions of the object code.","At least some of the handler functions of the code module could be arranged to invoke a function of the object code.","The action(s) to be performed for a sequence of one or more calls having predefined characteristics could include one or more of: forwarding the last call in the sequence of one or more calls to the application programming interface with unmodified or modified parameters; suppressing the last call in the sequence of one or more calls such that it is not delivered to the application programming interface; making one or more additional calls to the application programming interface or another application programming interface; writing entries to a log; pinning a thread executed in consequence of the sequence of one or more calls to a particular processor core of the data processing system; and enabling spinning for a thread arranged to execute at the data processing system.","Suitably the application programming interface is a socket library. The predefined characteristics could include characteristics of one or more of the following types: socket identifier; network protocol type; destination address; port number; and source address. The action(s) to be performed for a sequence of one or more calls having predefined characteristics could include one or more of: applying configuration options to a user level network stack; and applying tuning options to a socket in respect of which at least some of the sequence of one or more intercepted calls were made.","Suitably the configuration data structure is further configured to identify the predetermined set of call types and, if the set of call types that the intercept library is configured to intercept does not match the predetermined set of calls types, a script is configured to, prior to initialising the intercept library, cause the intercept library to be recompiled so as to arrange that the set of call types that the intercept library is configured to intercept matches the predetermined set of call types identified in the configuration data structure.","Preferably the configuration data structure is supplied by a user.","Preferably the intercept library is a shared object or dynamic linked library.","According to a second aspect of the first invention there is provided a method of modifying the operation of calls to an application programming interface comprising: intercepting calls of a predetermined set of call types from an application to the application programming interface; matching in the intercepted calls one of a plurality of sequences of one or more calls having predefined characteristics, the plurality of sequences of one or more calls being defined by a configuration data structure; and in response to matching a sequence of one or more calls, performing a set of at least one corresponding actions defined in the configuration data structure.","According to the second invention there is provided a data processing system comprising: an operating system providing a socket library; an application supported by the operating system and configured to receive messages at a socket established by means of the socket library; a user level network protocol stack operable to perform receive processing of messages held at a receive queue corresponding to the said socket; and a callback function operable to determine on behalf of the application whether to discard a message held at the receive queue; wherein the application is operable to make a plurality of different calls of a first type to the socket library that cause state of the receive queue of the said socket to be revealed and the callback function is registered with the user level network protocol stack such that, in response to calls of the first type, the user level network protocol stack invokes the callback function in respect of each message held at the receive queue so as to cause the callback function to indicate to the user level network protocol stack whether each respective message at the receive queue is to be discarded.","Preferably the socket library is configured to offer a set of functions in accordance with a standard Berkeley sockets API. Preferably the first type of calls includes: recv( ), recvfrom( ), recvmsg( ), select( ), pselect( ), poll( ), ppoll( ), epoll_wait( ), epoll_pwait( ), read( ), readv( ), pread( ), getsockopt( ), and ioctl( ).","Preferably the user level network protocol stack is configured to, in response to an indication from the callback function that a message is to be discarded, cause that message to be discarded.","Suitably the state of the receive queue includes one or more of: whether the receive queue is empty, the number of messages held in the receive queue, and the messages themselves.","Preferably the callback function is configured to return a value indicating whether the message in respect of which the callback function was invoked is to be discarded.","Preferably the user level network protocol stack is configured not to invoke the callback function if the receive queue is empty.","Preferably the receive queue comprises an unfiltered queue and a filtered queue, the unfiltered queue initially receiving all messages for the socket, and the user level network protocol stack is configured to move from the unfiltered queue into the filtered queue only those messages that are not indicated to be discarded. Preferably the user level network protocol stack is configured to not invoke the callback function if there are messages in the filtered queue.","Alternatively the user level network protocol stack is configured to, in response to an indication that a message is to be discarded, set a flag for that message in the receive queue indicating that the message is to be discarded.","The call of the first type could be a recv( ) call and the user level network protocol stack would be configured to provide to the socket only those messages that are indicated not to be discarded.","Suitably the application is configured to register the callback function for a socket in response to making a call to create that socket. The callback function could be provided by the application.","Preferably the data processing system further comprises: an intercept library configured to intercept calls made by the application to the application programming interface; and a configuration data structure arranged to cause the intercept library to register the callback function in response to intercepting a sequence of one or more calls having predefined characteristics defined in the configuration data structure. Preferably the sequence of one or more calls is a single call to create a new socket, and the callback function is registered in respect of the newly created socket.","Suitably the configuration data structure includes object code and the callback function is provided by the object code. Alternatively the callback function could be provided by the intercept library.","Suitably the callback function is further operable to, on performing filtering of a message in the receive queue, return data by means of the callback function indicating one or more sub-messages within that message that are to be delivered to the socket, the remaining parts of the message to be discarded. The one or more sub-messages could be indicated by means of byte ranges of the message in the receive queue.","Suitably the callback function is further configured to, on performing filtering of a message in the receive queue, modify that message so as to bring the message into accordance with a predetermined network protocol.","Suitably the callback function is further configured to receive an indication of the number of filtered messages in the receive queue and, if the number of filtered messages exceeds a predetermined threshold, cause the rate of delivery of messages into the receive queue to be reduced and\/or an error state to be indicated to the application.","The socket library could be arranged to support one or more of: inter-process communications at the operating system; inter-process communications at processes supported at different operating systems of the data processing system; and communications between remote processes at different data processing systems connected by means of a network.","According to a second aspect of the second invention there is provided a method of filtering messages at a receive queue of a data processing system, the receive queue being configured to receive messages for a socket of an application and the socket being established by means of a socket library, the data processing system further comprising a user level network protocol stack operable to perform receive processing of messages held at the receive queue, the method comprising: registering a callback function such that, in response to calls from the application to the socket library that cause state of the receive queue of the socket to be revealed, the user level network protocol stack invokes the callback function in respect of each message held at the receive queue, the callback function being arranged to indicate to the user level network protocol stack whether each respective message at the receive queue is to be discarded; and discarding those messages indicated the user level network protocol stack as being for discarding.","The following description is presented to enable any person skilled in the art to make and use the inventions, and is provided in the context of a particular application. Various modifications to the disclosed embodiments will be readily apparent to those skilled in the art.","The general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the present inventions. Thus, the present inventions are not intended to be limited to the embodiments shown, but is to be accorded the widest scope consistent with the principles and features disclosed herein.","The first invention relates to an intercept library configured to intercept calls from an application to an application programming interface (API) and perform user-defined actions in response to calls having predetermined characteristics without requiring modification of the application itself.",{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 1","b":["101","121","103","104","105","105","101","106","104","105"]},"In the example shown in , API  is a network socket API by means of which an application  can send and receive data. Such data communication could be between a process of application  and another process supported by operating system , between a process of application  and a process supported at another operating system of the data processing system, or between a process of application  and a remote process accessible over network  by means of network interface device . However, an intercept library as described herein is not limited to being used with a socket API and the first invention finds general application to APIs of all kinds.","The behaviour of intercept library  will now be described by reference to . Intercept library  is configured to intercept certain function calls made by application  to socket API  and identify sequences of one or more intercepted function calls having predetermined characteristics that are defined in a configuration data structure  accessible to the intercept library. The configuration data structure further defines one or more predetermined actions that are to be performed by the intercept library in response to it intercepting such a sequence of one or more function calls. Thus, the configuration data structure defines sequences of one or more function calls having predetermined characteristics that are to be matched by the intercept library and, for each such sequence, one or more predetermined actions that are to be performed by the intercept library in response to that sequence of one or more function calls being intercepted The configuration data structure could be any kind of data structure, such as a flat file or database.","The set of calls that the intercept library is configured to intercept is typically determined prior to compilation of the library. It can therefore be advantageous to arrange that the intercept library can be recompiled prior to its initialisation so as to intercept a predetermined set of calls indicated in the configuration data structure. This can be arranged by having a script check the set of calls that the intercept library is configured to intercept and, if the set of calls that the intercept library is configured to intercept does not match the predetermined set of calls indicated in the configuration data structure, cause the intercept library to be recompiled so as to update the intercept library to intercept the predetermined set of calls indicated in the configuration data structure.","A sequence of one or more function calls defined in the configuration data structure could be, for example: a single send( ) call to a TCP socket, such that an action is performed for each TCP send( ) call that is intercepted; calls to a particular socket, such that an action is performed for all intercepted calls to that socket; a socket( ) call to create a UDP socket, such that an action is performed for all intercepted calls to create UDP sockets; a set of n or more calls to a particular socket, such that an action is performed in respect of each such set of n intercepted calls.","These are merely examples and, more generally, any sequence of one or more function calls having any characteristics could be specified in the configuration data structure. A sequence comprising a plurality of calls need not be a set of consecutive calls and might instead be, for example, a sequence of calls to the same socket (i.e. there could be additional calls between calls to that socket which do not form part of the sequence because they are not directed to that socket).","Once a sequence of one or more intercepted calls has been identified, the intercept library performs the one or more actions specified in the configuration data structure for that sequence. The actions could be, for example: invoking the intercepted call(s) with the original or modified parameters so as to cause the call(s) to be passed to API ; suppressing the intercepted call(s) so as to prevent the call(s) being passed to API ; causing additional calls to be made before or after the intercepted call to API  or other APIs of the system; writing entries to a log describing one or more aspects of the intercepted call(s); accumulating statistics relating to one or more aspects of the intercepted call(s); pinning a thread to a particular CPU core or set of CPU cores, the thread being one that is to execute as a consequence of the intercepted call(s); causing a socket to be associated with a particular user level network stack  of the system; applying tuning options to a thread that is to execute as a consequence of the intercepted call(s)\u2014e.g. spinning could be enabled\/disabled for a lock of the thread; applying tuning options to user level network stack  that is to perform processing as a consequence of the intercepted call(s)\u2014e.g. disabling or enabling interrupt-based processing for the user level stack; applying tuning options to a socket in respect of which the intercepted call(s) is raised\u2014e.g. enabling the TCP_NODELAY option of a socket so as to disable Nagle's algorithm for the socket; invoking code defined in the configuration data structure (see the second and third embodiments below).","Typically, function calls to socket library  will cause kernel network protocol stack  or user level network protocol stack  to process data to be transmitted from or received at a socket of the system, or to in some more general manner handle data flows associated with one or more sockets of the system. A user level network protocol stack could itself be configured to intercept certain calls to API  so as to cause data flows in respect of the intercepted socket calls to be handled at the user level network protocol stack. Thus, an intercept library causes certain calls from application  to socket API  which conventionally pass straight through to the socket library:\n\napplication\u2192libsocket.so\n\nto be intercepted at the intercept library:\n\napplication\u2192libintercept.so\u2192libsocket.so\n\nthough the calls could be further intercepted by a library of the user level network stack :\n\napplication\u2192libintercept.so\u2192libuserstack.so\u2192libsocket.so\n","In a first embodiment of the first invention, configuration data structure  comprises sets of specifications, each specification specifying (a) characteristics that are to be identified by the intercept library  in a sequence of one or more intercepted function calls and (b) one or more actions to be performed by the intercept library on those characteristics being identified. For example, the configuration data structure could contain specifications of the following form:\n\nsocket(PF_INET,SOCK_DGRAM,*):protocol_stack=userlevelstack\n","A specification consists of two parts: a match specification that defines the sequence and characteristics of the socket calls that are to be matched, and an action specification that defines what should be done when a match is found. The example specification above causes the intercept library to match calls to the socket( ) function call to create UDP sockets and, when a match is found, directs the intercept library to cause the new socket to be created in the user level network protocol stack . A sequence of two or more calls could be specified by a match specification that defines the characteristics of each of the series of socket calls that are to be matched. It is envisaged that the intercept library is configured to perform matching of function calls on the basis of call parameters using wildcard operators as is well known in the art.","In a second embodiment of the first invention, intercept library  includes an interpreter and configuration library  is a code module configured for execution by the interpreter. For example, the intercept library could include a Python interpreter and the configuration library could be a Python code module.","The intercept library intercepts those calls for which a handler function is specified in code module  and, for each sequence of one or more intercepted calls, the interpreter of the intercept library is invoked to execute the respective handler function of the code module. For example, if a handler is supplied for a socket( ) function call then when the intercept library intercepts socket( ) calls it executes the respective handler function defined in the code module. A handler function could, for example, perform any of the actions described above in relation to the first embodiment and, since a handler function can include arbitrary code, a handler function can further perform any action that can be effected by means of the particular programming language in the software environment of the data processing system.","A handler function of the code module  can be configured to invoke library routines of the intercept library itself so as to cause the required actions to be performed for a given sequence of one or more intercepted calls. For example, the intercept library could be configured to provide one or more standard functions that a handler might wish to call, with a handler function being configured to invoke a standard function of the intercept library with those parameters necessary to cause the respective action to be performed for a given sequence of one or more intercepted calls. Those calls for which no handler function is defined in the code module are forward onto socket library .","A configuration data structure configured in accordance with the first or second embodiments could further include object code (e.g. machine code) that can be executed directly without requiring the intercept library to include an interpreter for the code. For example, the object code could be a compiled C library. By including a code library, the configuration data structure can provide a set of functions that can be invoked as actions by the intercept library on intercepting a sequence of one or more calls to API . A configuration data structure could include object code in a single file along with a set of specifications (of the first embodiment) or a code module (of the second embodiment), or the configuration data structure could include object code in one or more separate object code libraries identified by the configuration data structure.","Thus, in accordance with the first embodiment, actions defined in a specification held in the configuration data structure could include causing the intercept library to invoke a function of the object code. For example, a specification could include a reference to a function of a user-supplied object code library that is to be invoked as an action if the match part of the specification is satisfied by a sequence of one or more intercepted calls. And, in accordance with the second embodiment, actions defined in the code module could include function calls to the object code so as to cause the intercept library to invoke a function of the object code on running the interpreted code. Functions of the object code would typically be identified through a combination of the name of the library comprising the object code and the name of the entry-point (i.e. function) within the library.","The first invention therefore provides an arrangement by which the behaviour of an application with respect to an API can be modified without requiring modification of the application itself. This is achieved through the use of an intercept library configured to intercept calls to an API and one or more configuration data structures in dependence on which the intercept library (a) matches certain sequences of one or more intercepted calls and (b) performs certain actions in dependence on matching those sequences of one or more calls. A configuration data structure is preferably provided by a user so as to allow the user to control the behaviour of the application with respect to the API\u2014for example, by applying tuning to calls made to a socket library in order to improve the performance of transmitting and receiving data over sockets of the data processing system. It is advantageous if the configuration data structure is provided as a code module and the intercept library with an interpreter so as to allow the user to specify any arbitrary code as actions to be performed on intercepting a call. It is most preferable that the configuration data structure includes an object code library defining one or more functions that can be called as actions by the intercept library\u2014compiled object code is generally less limited in what it can achieve within a given software environment than interpreted code, and the performance of object code is higher.","The second invention relates to an improved mechanism for filtering received messages and will now be described with reference to .","Messages for an endpoint of data processing system  are delivered into receive queues . Such messages could be received over network  by means of network interface device , or could be received from processes supported at the same data processing system\u2014whether at the same or a different operating system (e.g. inter-process communications or communications over virtual networks). The second invention relates to messages received at a queue and it is not important where the message originated.","It is often the case that not all messages received at a queue will be wanted by the endpoint to which they are directed (e.g. application ). Applications will therefore conventionally filter messages and discard those that are unwanted. All work expended on the message up to the point of discard is effectively wasted. The second invention, however, teaches that some of this wasted work can be avoided by registering a callback function  with a user level network stack  such that message filtering is performed in the context of the network stack whilst the message is located in the receive queue. Such a callback is registered on any sockets for which filtering is to be performed by the mechanism described herein.","The callback function could be provided by application  or in separate object code (for example in the object code of the configuration data structure or intercept library of the first invention). If the callback function is separate to the application, it is configured to perform filtering of messages at a receive queue  on behalf of the application\u2014this requires that the callback function understands the usage scenario of the application and can perform filtering accordingly. Importantly, the socket API provided by the operating system does not require any modification in order for filtering to be performed at user level because the callback is registered at the user level protocol library such that the callback is invoked for a socket as a consequence of standard API calls that reveal the state of the receive queue of that socket. For example, a standard recv( ) call to the socket API is arranged to cause the user level network stack to invoke the callback on performing receive processing as a consequence of the recv( ) call. Calls that reveal the state of a receive queue cause the state of the receive queue to be touched by threads\/processes executing at the data processing system. Calls that reveal the state of a receive queue can reveal the number of messages at the receive queue, and\/or whether the receive queue is empty or not. Calls that reveal the state of a receive queue need not reveal all of the state associated with that queue and may reveal only some of the state of a receive queue\u2014i.e. the calls reveal state of the receive queue.","This arrangement has significant performance advantages since the overhead of providing the message to the application buffer by means of socket library  is avoided. Receiving a message at an application incurs significant overheads associated with the socket library API and synchronisation, and also involves copying the message from the receive queue (generally a DMA buffer) into the application buffer. Inspecting each message via a callback avoids the copy step and can amortise the socket API and synchronisation overheads over multiple messages. This reduces CPU burden and reduces pollution of the processor caches.","Network stack  is arranged to invoke the callback function prior to messages being copied from the receive queue of a socket into the application buffer. This is preferably achieved by invoking the callback function in response to calls to the socket library that cause messages to be delivered into the application buffer\u2014for example, recv( ), read( ) or recvfrom( )\u2014or reveal the state of the receive queue of a socket\u2014for example, poll( ). Alternatively this could be achieved by invoking the callback function in response to notification of the arrival of messages at the stack.","A value returned by the callback function indicates to the network stack whether the message in respect of which the callback function was invoked should be discarded. If the value returned by the callback function indicates that the respective message should be discarded then the user level network stack  discards the message at the receive queue so as to prevent the message being delivered to the application .","A preferred mechanism by which the user level network stack can discard unwanted messages is illustrated in . Each receive queue  for which the callback filtering mechanism described herein is used actually comprises two queues: an unfiltered queue  into which messages are initially received, and a filtered queue  into which only those messages that are not to be discarded are moved. The user level network stack  is arranged to provide messages in filtered queue  but not messages in unfiltered queue  to application buffer . Unwanted messages in the unfiltered queue can be marked for deletion.","Alternatively, a receive queue of a socket can be a single queue in which filtered messages that are unwanted are marked as such by means of a flag written to those messages.","By registering a callback at the user level protocol library such that the callback is invoked for a socket as a consequence of standard API calls that reveal the state of the receive queue of that socket, the second invention can be used with a conventional sockets API  (e.g. a standard BSD sockets API). Thus, filtering is transparent to the application and received messages are delivered to the application in the same manner with and without filtering\u2014the only difference being that unwanted messages never reach the application.","For example, an application can use a poll( ) call to socket library  to determine whether a socket's receive queue is empty or not. Since a poll( ) call reveals the state of the receive queue of a socket, the poll( ) call could return an incorrect result to the application indicating that there are messages for the application when in fact those messages are to be discarded (i.e. are present in an unfiltered queue or are flagged as discarded). The second invention addresses this problem by registering a callback function with the user level network protocol stack such that the callback is invoked when a call to the socket library is made that reveals the state of a socket's receive queue. Thus, the callback function is invoked when a poll( ) call is made so as to ensure that unfiltered messages are filtered in order to identify whether any filtered messages remain. Preferably the callback is only invoked if required\u2014i.e. it is not invoked if the receive queue for the socket is empty, or if filtering of the receive queue has already been completed. Thus, in the particular case of a poll( ) call, the callback is also preferably only invoked if there are no filtered messages and the receive queue is not empty, since in both these cases the correct response to the poll( ) call is known. When the callback function is invoked for a receive queue in consequence of a poll( ) call being made, the function is invoked for successive unfiltered messages until a message is found that is not to be discarded.","Two mechanisms by which the second invention can be achieved will now be described. Firstly, application  can be configured to register the callback function with the user level network stack  for one or more sockets of the system. This requires that the application is modified to perform this step on creation of a socket. Under this mechanism, the callback function could be provided by the application itself.","Secondly, and preferably, the first and second inventions are combined and the intercept library  is configured to register the callback function with the user level network stack  for those sockets of the system to which the filtering mechanism is to be applied. Thus, an intercept library is provided to intercept calls made by the application to the application programming interface in dependence on a configuration data structure. The configuration data structure is arranged to cause the intercept library to register the callback function as an action in response to intercepting a sequence of one or more calls having predefined characteristics defined in the configuration data structure. Preferably, the configuration data structure is configured to cause the intercept library to intercept calls to the socket library  that cause a new socket to be created (e.g. socket( ) calls) and register the callback function as an action in respect of the new socket. Alternatively, the registration could be performed at a later point for an existing socket. The registration links the callback function to the receive path of stack  such that the callback function is invoked prior to messages being dequeued from the receive queue and to any other code paths of the stack  that would be executed as a consequence of calls being made to the API that reveal the state of the receive queue. The callback function  could be provided at object code of the configuration data structure.","By registering the callback function in all code paths of the stack  that would be executed as a consequence of calls being made to the API that reveal the state of the receive queue, all calls to the socket library are handled correctly for sockets for which filtering is enabled without requiring modification to the socket library or application. In other words, the application can make the same standard calls to the socket library and the socket library can be the same standard socket library that is conventionally provided by the operating system, yet, through the use of the novel intercept library arrangement described herein, message filtering can be performed at user level and not in the kernel. The configuration data structure is preferably arranged to cause the intercept library to register the callback function with stack  as an action on a call to create a new socket being intercepted.","Callback function  function could be further configured to modify the messages held at receive queue , in addition to performing filtering of those messages. For example, the callback function could be configured to reform a message held at the receive queue in accordance with a predetermined protocol so as to render the message into a format understood by the application.","The callback function could be extended so as to provide in data returned by the function information indicating which byte ranges within a received message at the receive queue are to be delivered to the application. This allows filtering of sub-messages within each message held at the receive queue. For example, a message at the receive queue may include two or more application-level messages or parts of messages; by providing data indicating byte ranges within the messages, the callback function can indicate which sub-messages of a message are wanted by the endpoint application.","It can also be useful if the number of filtered (and optionally unfiltered) messages in the receive queue is provided to the callback function. This allows the callback function to determine whether the application is keeping up with the incoming message rate and, if it is not keeping up, to respond accordingly\u2014for example, by causing the rate of delivery of messages into the receive queue to be throttled back (this can be achieved by several well-known mechanisms, including various quality of service protocols). This can be useful if the application performs electronic trading: the information provided to by means of the callback function allows the callback function to cause the trading application to stop trading if it is not keeping up with the influx of messages into its receive queue so as to avoid the application making trades based on out-of-date trading data.",{"@attributes":{"id":"p-0078","num":"0077"},"figref":"FIG. 3","b":["310","312","314"]},{"@attributes":{"id":"p-0079","num":"0078"},"figref":"FIG. 4","b":["410","412","414","416"]},"A data processing system could be any kind of computing device such as a server, personal computer or handheld device. The present inventions find general application to operating systems that utilise sockets and any references to Berkeley sockets or BSD are not to be taken as limiting the scope of the present invention to the Berkeley Software Distribution (BSD) operating system.","The applicant hereby discloses in isolation each individual feature described herein and any combination of two or more such features, to the extent that such features or combinations are capable of being carried out based on the present specification as a whole in the light of the common general knowledge of a person skilled in the art, irrespective of whether such features or combinations of features solve any problems disclosed herein, and without limitation to the scope of the claims. The applicant indicates that aspects of the present inventions may consist of any such individual feature or combination of features. In view of the foregoing description it will be evident to a person skilled in the art that various modifications may be made within the scope of the inventions."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"DESCRIPTION OF THE DRAWINGS","p":["The present inventions will now be described by way of example with reference to the accompanying drawings, in which:",{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 4"}]},"DETDESC":[{},{}]}
