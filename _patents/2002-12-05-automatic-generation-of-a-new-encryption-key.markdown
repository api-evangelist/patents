---
title: Automatic generation of a new encryption key
abstract: A device (such as a printer or a network device that may be connected to the printer) that is connected to a network and which performs secure operations using an existing encryption keypair maintained within the device, generates a new encryption keypair within the device by receiving a request from another device on the network to provide an encryption key of the existing encryption keypair to the another device. In response to the request, the device determines whether an encryption key of the existing encryption keypair within the device is valid. In a case where it is determined that the encryption key of the existing encryption keypair is invalid, the device automatically deletes each key of the existing encryption keypair from the device, generates a new encryption keypair within the device and stores the new encryption keypair in the device. The device then provides a new encryption key corresponding to the requested encryption key of the new encryption keypair to another device.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07111322&OS=07111322&RS=07111322
owner: Canon Kabushiki Kaisha
number: 07111322
owner_city: Tokyo
owner_country: JP
publication_date: 20021205
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["INCORPORATION BY REFERENCE","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS"],"p":["U.S. patent application Ser. No. 10\/010,974, filed on Dec. 5, 2001, entitled \u201cSecure Printing With Authenticated Printer Key\u201d is hereby incorporated by reference as if set forth in full herein.","1. Field of the Invention","The present invention concerns automatic generation of a new encryption keys when existing keys are found to be corrupt. More particularly, the present invention concerns a device determining whether an existing encryption keypair is valid, and if not, automatically deleting the existing encryption keypair from the device, generating a new encryption keypair within the device itself, and notifying another device on a network that a new encryption keypair has been generated.","2. Description of the Related Art","The use of encryption keys for secure network printing applications is known. For example, it has been known to use public\/private keypairs for secure printing. With this technique, a public\/private keypair for the printer is generally created during the manufacturing process of the printer. The private key is generally maintained within the printer and is not divulged outside of the printer. The public key, on the other hand, is both maintained within the printer and is made available to the general public for use in transmitting secure print jobs to the printer. The printer's public key can be provided to users via any of a number of means including a public key infrastructure (PKI) or by a printer driver simply requesting the public key from the printer itself or from a secure print server. Once the printer's public key has been obtained, a printer driver uses the public key to encrypt a symmetric key, which is used to encrypt print data and transmits the encrypted print job to the printer. Upon receiving the encrypted print job, the printer uses its private key of the public\/private keypair to decrypt the public key and to obtain the symmetric key, which the printer then uses to decrypt the print data.","While this system has worked somewhat well, problems arise when the printer's public and\/or private keys have become corrupt. In a case where the printer's public key has become corrupt in the printer, the printer will no longer be able to provide the public key to additional clients. While clients already in possession of the printer's original public key will still be able to use it to encrypt future jobs, which the printer will be able to successfully decrypt, no additional clients will be able to obtain the key and thus encrypt print jobs directed to this printer. In a case where the printer's private key has become corrupt, the printer driver may not be aware that the key is corrupt and may send a print job to the printer using the printer's public key, which is associated with the corrupt private key. In this case, the printer will be unable to decrypt the print job using the corrupt private key and as a result, the print job generally fails.","It is also possible that the printer's public key, after having been obtained by a client and stored locally in the client, may become corrupt in the client. To address the concern, it has been proposed to validate the locally stored public key in the client before submitting the print job to the printer. In this case, the printer driver in the client retrieves the locally stored public key and performs a validation (integrity) check on the public key by performing a hashing algorithm over the key and comparing the resultant hash value with a hash value of the key that was generated and stored locally in the client when the key was first created. If the printer driver is unable to validate the printer's public key, the print job is terminated by the printer driver and the user is notified of a printing error. As a result, the printer driver cannot process secure print jobs.","However, in the case where either the printer's public or private key becomes corrupt in the printer, it is generally assumed that a hardware failure has occurred within the printer and that the security hardware needs to be replaced. Of course, it may also be possible for an administrator to correct the problem by installing a new keypair in the printer rather than replacing the hardware, and notifying the public that the printer's public key has changed. However, both of the foregoing correction processes involve relatively significant printer downtime to either replace the printer's hardware or to install new keys. Thus, the printer is unusable, particularly for printing secure print jobs, until the error can be corrected.","The present invention addresses the foregoing by determining if an existing key in a device is valid, and if not, automatically generating a new encryption keypair within the device itself. According to the invention, the device (which will hereinafter be referred to as a \u201cprinter\u201d) receives a request from, for example, a host computer for an encryption key of an existing encryption keypair, and in response, determines whether the requested encryption key is valid. The determination preferably comprises running a hashing algorithm on the requested encryption key and comparing the result to a stored hash value. It may also be preferable to validate the corresponding key of the existing keypair as well. If it is determined that the requested key of the existing keypair is invalid (i.e., has been corrupted), the printer automatically deletes each key of the existing encryption keypair and generates a new encryption keypair within the printer itself. Then, the printer transmits the new encryption key to the host computer. Thus, the host computer can then validate the new key and use it for submitting an encrypted print job to the printer. It should be noted that while the device has been referred to above as a \u201cprinter\u201d, the device may be a stand alone network device instead that provides encryption functionality to a printer.","As a result of the foregoing, rather than assuming that a hardware failure has occurred in the device and replacing the hardware, new encryption keys are generated instead so as to attempt to salvage the hardware. However, if too many failures occur within a specified time, then it may be assumed that a hardware failure has actually occurred and further attempts to generate new encryption keys may not be performed. Additionally, since new encryption keys are automatically generated rather quickly and within the device itself, there is no need to wait for an administrator to install new keys and the device can remain online for processing encrypted jobs with little downtime.","Thus, in one aspect, the invention generates a new encryption keypair within a device that is connected to a network and which performs secure operations using an existing encryption keypair maintained within the device by receiving a request from another device on the network to provide an encryption key of the existing encryption keypair to the another device, and in response to the request, determining whether an encryption key of the existing encryption keypair within the device is valid. In a case where it is determined that the encryption key of the existing encryption keypair is invalid, the device automatically deletes each key of the existing encryption keypair from the device, generates a new encryption keypair within the device and stores the new encryption keypair in the device, and provides a new encryption key corresponding to the requested encryption key of the new encryption keypair to the another device.","The determination may comprise performing an integrity check on the requested encryption key. Moreover, the determination may be performed on each key of the existing encryption keypair, rather than merely the requested key. In this manner, the integrity of both keys can be determined and successful printing of a secure print job can be more readily assured.","The device maintaining the encryption keys and which generates the new encryption keypair may be a printer, and the another device may be a host computer. The request for the existing encryption key may be issued by the printer driver in the host computer to printer. When the host computer receives the new encryption key from the printer, the host computer may perform an operation to validate the new encryption key. The validation operation may comprise issuing a request for the printer to print out a key validation page for the new encryption key, a user inputting into the host computer a key validation code printed on the key validation page, and the host computer validating the new encryption key utilizing the input key validation code. Alternatively, the new encryption key may be validated utilizing a public key infrastructure.","In generating the new encryption keypair, the request issued by the host computer preferably includes random data generated within the host computer as a source of entropy for encryption key generation. The printer generates the new encryption keypair utilizing, as sources of entropy for the new encryption keypair generation, the random data included with the request and random data generated within the device itself.","In another aspect, the invention prints a secure print job by a host apparatus submitting a request to a network device for the network device to provide the host apparatus with an existing encryption key of a printer. The network device, in response to receiving the request, determines whether the requested encryption key of the existing encryption keypair of the printer is valid. In a case where the requested existing encryption key is determined to be invalid, the network device automatically deletes the existing encryption keypair from the network device, generates a new encryption keypair within the network device, stores the new encryption keypair in the network device, and transmits a new encryption key corresponding to the requested encryption key of the new encryption keypair to the host apparatus. The host apparatus receives the new encryption key from the network device, and in response thereto, performs an operation to validate the new encryption key. The host apparatus then generates an encrypted print job utilizing the new encryption key and transmits the encrypted print job to the network device. The network device utilizes a corresponding encryption key of the new encryption keypair to decrypt the encrypted print job, and processes the decrypted print job for printout by the printer.","Thus, with this aspect, each time a user selects an option to submit a secure print job to a printer, the printer's public key is validated in the printer before being submitted to the printer driver. If the key is determined to be invalid, the printer merely generates a new encryption keypair and transmits the new encryption key to the printer driver. As a result, although the encryption key may be corrupt, an uninterrupted secure printing job can be obtained since the new key generation process is relatively seamless.","This brief summary has been provided so that the nature of the invention may be understood quickly. A more complete understanding of the invention can be obtained by reference to the following detailed description of the preferred embodiments thereof in connection with the attached drawings.","The following description will be made with regard to a secure printing system in which print jobs are processed by a printer using a public\/private keypair of the printer. Thus, while the focus of the following description will be made with regard to a secure printing system, the invention is not limited to such and can be employed in other environments where encryption keys are generated and utilized.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 1","FIG. 1"],"b":["10","20","30","35","1","1","10","20","1","1"]},"Client computer  is preferably a personal computer or workstation having a windowing operating system environment such as Microsoft Windows 2000 or Microsoft Windows NT, although other operating systems may also be used. As is typical with PC-type computers, client computer  preferably has a display (monitor), keyboard, and a mouse or other type of pointing device so that a user can operate the computer to perform various operations, including submission of a print job to a printer or print server.","Printer  communicates with client computer  via connection  and is preferably a laser or an ink-jet printer which is capable of printing images on a recording medium based on received print data. Preferably, printer  is a Canon ImageRunner 5000 (iR5000) printer. Printer  may also have a fixed storage medium, which is preferably a fixed disk, but can be a computer memory such as ROM or EEPROM. Printer  also includes a connection with NEL  such that printer  and NEL  can communicate with one another. While NEL  is shown as being an external stand-alone device, NEL  may be incorporated within printer  instead, thus forming an embedded device within the printer.","Server  may also be connected to connection  and is preferably a print server. It should be noted that server  is not a necessary component needed for practicing the invention and is merely depicted for a more thorough description. Server  preferably comprises a PC-compatible computer having a windowing operating system environment such as Microsoft 2000 server or Microsoft NT server. Of course, server  could be any other type of server running other server-type operating systems such as Novell, Unix, Sun Microsystems, etc. Server  preferably has a fixed disk which is preferably a large fixed disk for storing numerous files, applications and data. Server  can therefore be utilized by other devices on connection , such as client computer , as a file server or other type of server, such as a print server. Server  may also act as a gateway for other devices on connection  to access another network such as the Internet.","Also shown in  is NEL device . NEL stands for \u201cNet Extend Lite\u201d and the device, although shown as being an external device connected to printer , could be embedded within printer  instead. Thus, throughout the course of the following description, reference to an \u201cembedded device\u201d refers to the NEL in general. NEL device  provides functionality for printer  to process encrypted print jobs, as well as other functionalities that are beyond the realm of the present application. With regard to encryption functionality, NEL device  includes a mechanism to accumulate entropy (i.e., random data associated with the NEL and printer ) for use in generating encryption keys, algorithms for generating the encryption keys and decrypting the encryption keys, as well as for validating the encryption keys, etc. The process of generating encryption keys within the NEL itself comprises the present invention and a more detailed description of this process will be provided for below. Thus, NEL device  provides the ability for printer  to receive and process encrypted print jobs.","Utilizing the computing environment shown in , a user at computer  can submit a print job to printer  (optionally, via print server ) using a Windows application. Upon selecting a print option in the Windows application, a print dialog appears and the user can select an option for submitting a secure print job to the printer. Briefly stated, this process comprises the printer driver rendering print data for the print job in a printer definition language, encrypting the rendered print data, packaging the encrypted print data in the secure file format, and sending the print job to the printer for printing. Part of the process of packaging the print job involves obtaining and validating encryption keys and this process has been described by the inventors herein in co-pending U.S. patent application Ser. No. 10\/010,974, filed on Dec. 5, 2001, entitled \u201cSecure Printing With Authenticated Printer Key\u201d, the contents which are hereby incorporated by reference as if set forth in full herein. The secure print job, having been submitted to the printer, is received by the NEL, whereby the NEL decrypts the print job and passes cleartext of the print job to the printer for printout.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 2","FIG. 2","FIG. 2","FIG. 2"],"b":["10","32","11","13","14","10","12","10"]},"Client workstation  is also seen to include User Mode Print Driver , which for the present invention, is preferably a Canon secure printer driver installed in client workstation  for a Canon printer, such as an ImageRunner 5000 series printer. That is, the client-resident portion of a secure printing software is preferably implemented in the printer driver, using a Common Core Driver (CCD) architecture with Secure Print specific features being implemented in an associated user-mode printer driver. A secure file format for packaging the secure print job is preferably generated by User Mode Print Driver  and the details of such will be provided below.","The client software also preferably uses a Windows Cryptographic Application Programming Interface (CAPI), where possible. CAPI is a product available with Microsoft Windows operating systems. Note that differences exist between the availability of certain CAPI features among the different Windows operating systems and therefore, the client software should be implemented such that compatibility is ensured on all targeted OS platforms. The cryptographic algorithms and functions utilized on the Windows client are preferably RC4 (\u201cRon's Code #4\u201d for symmetric key encryption\/decryption), RSA (\u201cRivest, Shamir and Adelman\u201d, an asymmetric public key encryption algorithm), using PKCS #1 (Public Key Cryptography Standard) version 1.5 (asymmetric key encryption\/decryption; digital signatures\/verification), HMAC (Hashing Message Authentication Code), SHA-1 (Secure Hash Algorithm), and a Random Data Source (for generation of symmetric keys).","NEL  is seen to include operating system (OS)  and NEL Core software , which provide NEL  with the ability to communicate over the network and to preform various operational functions. As seen in , operating system  is preferably Linux, although it can be appreciated that other types of operating systems could also be used. A Secure Printing Application (SP)  is also included in NEL . One function of SP application  is to provide cryptographic functionality for NEL , such as generation of cryptographic keys, decryption of print jobs, etc., and makes use of the following cryptographic algorithms and functions: RC4 (symmetric key encryption\/decryption), RSA, using PKCS #1, version 1.5 (asymmetric key encryption\/decryption; digital signatures\/verification), HMAC (message authentication code), SHA-1 (hashing algorithm), and a Random Data Source (for local generation of asymmetric key pairs). NEL  also includes Printing Proxy  (which may be, for example, an LPR proxy for UNIX or Windows applications, or a Windows proxy for Windows applications) for communicating with print spooler  of client workstation  (or a print spooler contained in print server ), and for communicating with printer .","Printer  is seen to include NEL interface  for communication with NEL , and print engine . Of course, printer  could be virtually any network printer that can receive print jobs over a network, but in a preferred embodiment of the invention, printer  is a Canon ImageRunner 5000 series printer. It should be noted that, while NEL  is depicted as a separate device connected to the network, with the device being external to printer , NEL  could be fully implemented within printer  instead. In this case, NEL  within printer  may be referred to as an embedded device (i.e., the device being embedded within the printer), or the functionality of the NEL could be implemented in firmware within printer  instead. However, as seen in , NEL  is depicted as an external (stand alone) device which can be connected to an existing printer that does not have an embedded device. Thus, while the description that follows may refer to the external device NEL , it is to be understood that reference to an embedded device is to the NEL in general.","In utilizing the secure printing system of the present invention, encryption keys for the printer are required. The encryption keys are preferably a private\/public keypair for the printer. The printer's keypair is preferably generated within NEL  by SP application . Of course, the keypair may also be generated outside of NEL  and installed in NEL  during the manufacturing process, but the present invention aims to reduce various shortcomings described above with regard to this conventional process by generating the encryption keys within NEL . The process of generating encryption keys within NEL  according to the invention will now be described with regard to .","In step S, a process is initiated in the printer driver to obtain the printer's public key. This process may be initiated by the printer driver during installation and configuration of the printer driver on the client, wherein the client configuration software obtains the printer's public key directly from the printer. In a case where the printer driver has already been installed and configured in the client, the process to obtain the printer's public key is initiated by a user selecting a secure printing option in the printer driver for submitting a secure print job to the printer. It should be noted that in the latter case, a request for the printer's public key is preferably issued by the printer driver to the printer each time a user selects the secure printing option. In either case, the printer's public key is obtained directly from the printer by the printer driver issuing a request using a Secure Printer Management Protocol, which will now be described in more detail with regard to , A and B.","In the Secure Printer Management Protocol (SPMP) of the present invention, requests are communicated between the client and the NEL using standard TCP\/IP protocol. The request message format is shown in , which consists of a series of fields. As seen in , the request consists of a message type field , an operation identifier field , a length field  and a data payload field . The message type field  is preferably a 16-bit field which denotes the basic message type that is being sent. Some possible message types are (00=Invalid, 01=Request). Operation identifier field  is preferably a 16-bit field which denotes the specific operation that is being proformed. Possible types of operation identifiers are (00=Invalid, 01=PUBLIC_KEY, 02=KEY_VALIDATION_PAGE). Data length field  contains the length, in bytes, of the data payload contained in data payload field . Data payload field  contains data that is transferred with the request and is preferably randomly generated data that, as will be described below, is used as a source of entropy by the receiving device (NEL) to generate encryption keys.  depicts an example of a public key request message which is accompanied by a block of random data . The accompanying random data is obtained by the printer driver in the client (step S). The random data is preferably data that is accumulated within the client by the Windows CAPI and thus, the random data is specific to the client. In other words, the random data is data that has been collected by the Windows CAPI over the lifetime of the client workstation and is data that relates to specific operations, etc. performed in the client workstation. Having formed the public key request message, the client transmits the request message to NFL  in step S (or printer  if the NEL is embedded).","The NEL (or printer) receives the key request message (which includes the random data) (step S) and based on the message type (key request), determines whether or not the public key is already present in the NEL (step S). It should be noted that the printer's public key may not be present in the NEL where the NEL is relatively newly installed on the network and where the printer's keypair was not installed in the NEL during manufacturing. It should also be noted that, once the NEL is installed on the network, SP application  collects random data generated within the NEL during operation and stores the random data within SP application  for future use as a source of entropy in generating encryption keys. Such random data may be generated where the printer is utilized for printing non-secure print jobs and the random data may comprise data relating to network timings, time for printing the non-secure print jobs, number of pages printed, temperature variations within the printer, etc.","Returning to step S, if the printer's public key is already present in NEL , then the public key is obtained from its secure storage location, together with a hash value that was generated when the public key was installed or previously generated in the NEL (step S). While  depicts retrieval of the printer's public key, it may be preferred to retrieve both the public key and the printer's private key, as well as their respective associated hash values, so that the integrity check steps described below can be performed to confirm the integrity of both keys at the same time. In this regard, SP application  performs an integrity check on the public key (and optionally the private key as well) by, for example, performing a SHA-1 hashing algorithm on the public key to obtain a hash value (step S). The hash value obtained in the integrity check is then compared with the integrity check value (hash value) retrieved in step S to determine whether or not the public key (and possibly the private key) is valid (i.e., has not been corrupted or changed) (step S). If the key is determined to be valid, then the random data received with the key request message can be discarded and the public key is transmitted to the client as a public key response (step S), which will be described in more detail below. Alternatively, rather than discarding the random data, it can be stored in the NEL with the random data generated within the NEL itself for possible future use in generating new encryption keys.","Referring again to step S, if it is determined that no public key is present in the NEL, then a new encryption keypair (public\/private keypair) is generated within the NEL by SP application  (step S). The process of generating encryption keys preferably mixes the random data generated within the NEL itself, and the random data received by the NEL with the key request message. Virtually any known technique for generating a public\/private keypair can be used so long as the process mixes the random data from the NEL and the random data received with the key request to seed the key generation process.","Once the new encryption keypair is generated, an integrity check is performed on each key, where the integrity check preferably comprises performing an SHA-1 hashing algorithm over the key to obtain a hash value (step S). The hash value obtained for each key and the keys themselves are then stored in the NEL (step S), and the public key is transmitted to the client as a public key response (step S). It should be noted that the request for the NEL's public key may be transmitted from the client to the NEL in plaintext with no encryption required. Likewise, the NEL may return its public key in plaintext format.","Returning again to step S, if the NEL determines that a public key is already present in the NEL (YES in step S), but the key (either the public or the private key) is found to be invalid (NO in step S), flow proceeds to step S to generate a new encryption keypair. This process is the similar to that described above, but includes some additional steps as seen in . In , when the key is found to be invalid in step S, the key generation process is notified of such (step S) and the key generation process is initiated on this basis. In the process described above, where it is determined in step S that no public key is present, the determination in step S would be NO and the key generation process described above for step S is performed. However, where the existing key is found to be invalid, a counter is incremented in step S to count the number of times that a keypair has been found to be invalid (corrupt). It is then determined whether the keypair has been found to be corrupt more than a predetermined number of times (X), which may be, for example, 3 (step S). If the key has been found to be corrupt more than the predetermined number of times, then the user is notified of a hardware error. This may comprise a light, buzzer or other indicia being provided on the NEL (or printer) itself, as well as providing the printer driver in the client with a message that a hardware failure has occurred (step S). If the predetermined number of times has not been exceeded in step S, then the current (corrupt) keypair and their associated hash values are deleted from the NEL (step S), and a new encryption keypair is generated in step S. The new encryption keypair is generated as described above utilizing the source of entropy accumulated within the NEL itself and the random data included with the key request.","In accordance with the foregoing process, if a printer's public key is not present in the NEL, an encryption keypair (public\/private keypair) of the NEL (or its associated printer) is generated within the NEL device itself when the NEL receives a request from the client for the NEL to provide the client with the printer's public key. The encryption key generation process utilizes the two different sources of entropy to seed the key generation process. If the public key is already present, it is validated and, if found to be valid, transmitted to the client. If the public key is present and found to be invalid, a new encryption keypair is generated within the NEL with the new public key being transmitted to the client. A more detailed description will now be provided of the public key response provided by the NEL to the client, and processing within the client upon receiving the public key response.","Referring to  for the public key response,  depicts source code (i.e., cleartext) for a public key response transmitted from NEL  to client workstation , while  depicts a block diagram of the format of the public key response. As seen in , the response includes four portions: header , public exponent , modulus , and terminator . It should be noted that, while  shows each portion of the response as being separate blocks, the response is actually a single message, with each block appended to one another. Each of the four portions of the public key response will now be described in more detail.","As shown in , header  is a group of fields that contain general information, such as the public key algorithm used and other formatting information. The first four bytes (\u2013) contain a Public Key Response Identifier, 4B, 45, 59, 00(\u201cKEY\u201d), identifying the formatting as a Public Key Response. Version field  contains a 16-bit value identifying the version of the Public Key Response format used to transfer the key. Compatibility Mask field  contains a 16-bit value identifying the minimum version of the Public Key Response format that a recipient must support to be able to recover the data from the message. For example, if the Version field contains \u201c3\u201d and the Compatibility Mask field contains \u201c2,\u201d the file was formatted in Public Key Response format version 3, but it is compatible with, and can be recovered by clients that support, version 2 or greater. A value of zero in this field indicates that the recipient version must be at least as high as the version indicated in the Version field. Key Type field  contains a 16-bit value identifying the algorithm that is being used. Flags field  contains optional flags. Total Response Length  is a 32-bit field that contains the length of the entire Public Key Response message, in bytes, from the beginning of the Public Key Identifier () through the end of the Check Value field (). Header Length  is a 32-bit field that contains the length of the header section of the Public Key Response message, in bytes, from the beginning of the Public Key Identifier () through the end of the Header Length field . This value can be used to locate the beginning of the Public Exponent portion .","The Public Exponent  is a group of fields that are used to support the transfer of the RSA public exponent. It includes the public exponent itself, and other formatting information. As seen in , the public exponent  includes a Public Exponent Identifier, which comprises the first four bytes (\u2013), 45, 5850, 00(\u201cEXP\u201d), identifying the beginning of the Public Exponent block. Public Exponent Length  is a 32-bit field that contains the length of the Public Exponent section of the Public Key Response message, in bytes, from the beginning of the Public Exponent Identifier () through the end of the Public Exponent data field . This value can be used to locate the beginning of the Modulus block . The Public Exponent Data  is a variable-length field that contains the RSA public exponent. The exponent is constructed as a block of bytes, in network order, most-significant-bit first.","Modulus  is a group of fields that are used to support the transfer of the RSA modulus. It includes the RSA modulus itself, and other formatting information. The first four bytes (\u2013) contain the Modulus Identifier, 4D, 4F44, 00(\u201cMOD\u201d), identifying the beginning of the Modulus block. Modulus Length  is a 32-bit field that contains the length of the Modulus section of the Public Key Response message, in bytes, from the beginning of the Modulus Identifier () through the end of the Modulus Data field . Modulus Data  is a variable-length field that contains the RSA modulus.","Finally, Terminator  is a field that is used to identify the end of the Public Key Response. The terminator value consists of a fixed ASCII identifier, \u201cEOF\u201d, immediately following the Modulus Data . The Terminator comprises four bytes (\u2013) that contain the Terminator, 45, 4F, 46, 00(\u201cEOF\u201d), identifying the end of the Public Key Response.","Referring now to , the printer driver receives the public key response in step S and determines, based on the received encryption key, whether or not to transmit the secure print job to the printer. The purpose for this determination is confirm that the printer has the ability to process a secure print job (i.e., includes the NEL's functionality) and that the printer has the appropriate encryption keys, such that the printer will not needlessly print out garbled data if a secure print job is transmitted to the printer and the printer is not able to properly process the job. Briefly stated, the determination comprises determining whether or not the received encryption key matches an expected value such that if the key does not match, the print job is not transmitted to the printer and the user is alerted that the printer's public key has changed. In more detail, a determination is made whether the printer's public key is already present in the client workstation (step S). This may the case where a request for the printer's public key was previously issued by the printer driver, either during installation of the printer driver or a previous secure printing request. If the printer's public key is already present in the client, then the printer driver retrieves the stored public key and its associated hash value from within the client (step S) and validates the received public key (step S). The validation process may comprise performing a hashing algorithm on the received public key and comparing the resultant value with the hash value retrieved from within the client to validate the received public key, or other means such as that described in co-pending U.S. application Ser. No. 10\/010,974. Alternatively, the client workstation may perform a hashing algorithm over both the public key retrieved from within the client as well as the public key received from the NEL and compare the resultant values to validate the public key. The purpose of validating the public key received from the NEL by the client is to ensure that the public key has not been changed. Thus, if the key if found to be valid, the received public key is utilized to generate a secure print job, as will be described in more detail below. If however, the received public key is found to be invalid (i.e., the public key has changed), or if it is determined in step S that the public key is not present in the client (i.e., this is an installation and configuration process of the printer driver), then the process proceeds to step S.","In step S, the user is notified that the public key needs to be validated. If the printer driver is being installed and configured, the notification may merely comprise part of the installation procedures. If however, the printer driver has already been installed and configured, and the printer's public key is found to have changed, then the notification may more specifically inform the user that the printer's public key has changed and that the new public key needs to be validated. In either case, the user agrees to validate the public key (step S) and a key validation request message is transmitted to the NEL (or the printer) to print out a key validation page. As an alternative, rather than the printer driver issuing a key validation request message to the NEL or the printer, a user may initiate printout of a key validation page at the printer by, for example, pressing a button on the printer, thereby issuing a key validation request.  is an example of such a message that is used to cause the printer to print a key validation page, containing a human-readable validation string, derived from a hash of the printer's public key. In this regard, the hash of the printer's public key (stored in the NEL) is also accessible, in human-readable format, as a field in a test page, which is initiated by user input from a control panel on the printer and in performing the verification, the user obtains a test page directly from the printer, which includes the SHA-1 hash of the printer's public key. The user then enters the hash value that was obtained in this manner into a configuration dialog provided by the printer driver. The printer driver's setup utility computes a hash on the key that it obtained directly from the printer and compares the result to the hash value that was obtained by the user from the printer's test page. If the hash values are identical, the printer's public key has been verified and is permanently installed in the client system (step S). After verification, the key is digitally signed by the driver, using native Windows features, to prevent tampering. If the hash value calculated over the received public key does not match the hash value displayed on the test page and entered by the user, an error message is presented to the user and the installation process fails. If such a failure occurs, the printer's public key is not installed into the client system and the printer driver will not allow secure print jobs to be sent to the printer. Ideally, printing of the validation code should be initiated locally at the printer, with the printer in the offline state. However, the validation code may be generated by the NEL, with the NEL then generating a test page containing the validation code. This validation code page is then transmitted to the printer, using a local network interface between the NEL and the printer, as LPR data. In order to provide flexibility in the choice of hash algorithms, a single-byte field (referred to as an \u201cAlgorithm Designator\u201d), indicating the hash algorithm in use, is preferably prepended to the actual hash result. Using this implementation, when the user enters the value obtained from the test page into the client's installation dialog, the algorithm in use will be known to the client. The actual key validation code is created by combining the Algorithm Designator with the hash value, and then applying an alphanumeric transform to the result. The printed values on the test page are then displayed as a series of alphanumeric characters, as shown in , with the Algorithm Designator corresponding to box .","The validity of the key may also be ensured using a public key infrastructure (PKI). In this implementation, the printer's key is delivered within a cryptographic certificate, signed by a trusted certification authority. In that case, the installation program verifies the integrity of the key by verifying the signature and other information contained in the certificate. In the absence of a functional public key infrastructure (PKI), however, the implementation described above is preferred. Further enhancements to the key distribution process may also include administrative tools that allow the printer's public key and hash to be installed into the client driver from a floppy disk or a secure website. Such tools may improve the ease of installation, but can also pose added security risks.","Once the printer's public key has been properly validated in the client workstation, the user is able to submit a secure print job for printing (step S). When a user selects an option for a secure print job, another, encryption key (referred to as a \u201csession\u201d or \u201csymmetric\u201d key) is generated by the user mode print driver. As is known in the art, symmetric keys are generated using what is referred to as a source of entropy (i.e., randomly generated data). In the present invention, entropy for use in generating the symmetric key is preferably obtained using standard Windows Cryptographic Application Programming Interface (CAPI) methods. The symmetric key obtained in this manner is preferably only used for a single print job, after which it is destroyed. All remnants of the symmetric key are destroyed by overwriting, such that the symmetric key cannot be recovered from the client system by any means. Remnants of the key, as well as any cleartext data buffers in system memory, are overwritten with a pattern, using at least one pass. Remnants of cleartext data buffers that exist on hard disk are overwritten using a technique corresponding to DOD 5220.22-M, \u201cclear\u201d level, or better. It should be noted that another possible source of unexpected leakage is the system's virtual memory mechanism. Some or all of an application's memory can be unexpectedly swapped out and stored in a swap file at any time. Therefore, techniques are preferably used that temporarily store sensitive material, including keys, in an area of memory that cannot be swapped.","Thus, the client, having received the public key response in the foregoing format, is provided with various information needed to generate a secure file in a secure file format, a detailed description of which will now be provided. Briefly, however, a secure file, and as will be described below, a secure file for a print job, is generated by generating a secure client header and appending encrypted print data thereto. As an enhancement, the encrypted print data appended to the secure client header may be processed further for additional security by performing integrity checks in a chaining fashion on the encrypted print data.","Referring now to , a process of generating a secure client header will be described. It should be noted that  depicts a block diagram of various portions of a secure file format according to the invention, including the foregoing enhancement of the print data, while  focuses on the process steps for generating the secure client header. As seen in , when a user selects an option to submit a secure print job (step S) from, for example, a print option in an application program of client computer , the print driver obtains the printer's public key (step S) and preferably (although optional) validates the printer's public key. As described above, the printer's public key and a hash value thereof are preferably installed and configured in the print driver of the client computer when the print driver is first installed. In this case, the printer's public key may be obtained from a local storage medium in client computer  and a hashing algorithm (such as SHA-1) may be performed on the obtained key. The hash value that results from the foregoing process may then be compared with the hash value stored in the client computer to validate the printer's public key. As an alternative, the print driver may submit a request to the printer (or the NEL) to obtain the printer's public key directly from the printer (or the NEL). The printer's public key is then provided to the print driver, where it is validated by performing a hashing algorithm on the received public key and comparing the resultant value with the hash value stored in the client computer. After having obtained the printer's public key, or simultaneous thereto, the print driver generates a symmetric (session) key (step S) for use in generating the secure client header. The foregoing process has also been described by the inventors herein in co-pending application Ser. No. 10\/010,974, the contents of which are hereby incorporated by reference, and the process described therein could also be applied in the present invention.","In generating the secure client header, the user mode print driver first generates a client header (step S), which as seen in , client header  comprises a lead-in block , a public header block , a private header block  and a routing header block . The contents of each of blocks , , , and  will be described in more detail below. It should be noted that routing header  is optional and may be included within client header  where a print job is designated as being destined to a particular recipient, or where the identity of the sender of the recipient is desired. That is, if the print job requires some type of recipient authentication before the print job is to be printed out, or if it is necessary to identify the sender of the print job, routing header  may be included, but otherwise can be omitted.","Having generated client header , the private header portion  thereof (or as will be described below, at least some portion of the private header) is encrypted using the printer's public key (step S), thereby resulting in encrypted private header . Additionally, routing header  (or at least some portion thereof) is encrypted using the symmetric (session) key (step S), thereby resulting in encrypted routing header . Thus, once the foregoing encryption processes have been performed, client header  is transformed into encrypted client header .","Continuing with the process for generating a secure client header, encrypted client header  is subjected to an integrity check (step S). The integrity check performed is preferably a Hashing Message Authentication Code (HMAC) algorithm, although any other type of integrity check could be used instead. The integrity check result value (HMAC value ) is then appended to the encrypted client header  (step S), thus transforming header  into secure client header .","To complete one embodiment of a secure file format, print data payload  is encrypted with the symmetric (session) key, thereby resulting in encrypted print data payload . The encrypted print data payload  is appended to the secure client header  to form the secure print file . The secure print file  is then transmitted to the NEL via connection . As briefly stated above, an enhancement may be performed on the encrypted print data payload  and this process will be described in more detail below. However, first, a more detailed description of the contents of client header , and in particular, the contents of lead-in block , public header block , private header block , and routing header block  will be provided.","Referring now to , Lead-In block  is a group of fields that contain general information identifying the file as a Secure Print format and providing necessary information such as the version of Secure Print file format used and other formatting information. Lead-In block  is seen to include a Secure Print File Identifier (blocks  to ). The first four bytes (\u2013) contain the Secure Print File Identifier, x43, 0x53 0x50, 0x00 (\u201cCSP\u201d), identifying the formatting as a Secure Print file format. Version block  is a field that contains a 16-bit value identifying the version of Secure Print format used to prepare this file. Compatibility Mask  is a field that contains a 16-bit value identifying the minimum version of the Secure Print format that a recipient must support to be able to recover the data from this file. For example, if the Version field contains \u201c3\u201d and the Compatibility Mask field contains \u201c2,\u201d the file was formatted in Secure Print format version 3, but it is compatible with, and can be recovered by clients that support version 2 or greater. A value of zero in this field indicates that the recipient version must be at least as high as the version indicated in the version field. Total Header Length  is a 32-bit field that contains the length of the entire Secure Print header, in bytes, from the beginning of the Secure Print File Identifier () through the end of the header hash (reference numeral  of ). This value can be used to locate the beginning of the Payload Data. Lead-In Length  is a 32-bit field that contains the length of the lead-in section of the Secure Print header, in bytes, from the beginning of the Secure Print File Identifier () through the end of Payload Data Length field . This value can be used to locate the beginning of the Public Header. Option Mask  contains a 32-bit field that identifies any options that were selected when this file was generated. Each bit (or bit field) is used to select a separate option. The contents of this field inform the receiving device (printer) which options were selected when the file was constructed by the sending client. Some values that may be used in the options mask field are shown in . Payload Data Length  is a field that contains an optional 32-bit value that describes the total size of the Payload Data section of the Secure Print file. It contains the total number of bytes, beginning with the Payload Data Identifier (44, 41, 54, 00) and ending with the End of File Identifier (45, 4F, 46, 00), inclusive (these will be described in more detail below). This field is optional. Where it is possible for the sending client to do so, this field can be used to provide size information to the receiving entity (such as a printer). Printer drivers that are not aware of the total data payload size at the time the header is transmitted, and thus cannot make use of this field, must set all the bits in this field to zero and must also set the Payload Data Length Present bit to \u201c0.\u201d",{"@attributes":{"id":"p-0087","num":"0086"},"figref":["FIG. 10B","FIG. 12","FIG. 13","FIG. 14","FIG. 15","FIG. 16","FIG. 17","FIG. 18","FIG. 19"],"b":["520","521","524","525","521","529","526","526","527","527","528","528","529","529"],"sub":["x","x","x","x"],"i":["b","a ","b ","a ","b ","a ","b ","a ","b "]},{"@attributes":{"id":"p-0088","num":"0087"},"figref":"FIG. 10C","b":["530","532","525","536","532","537","537","530","531","527","529"],"sub":["x","x","x","x"],"i":["b","b"]},"The \u201cSymmetric Key\u201d field is the symmetric key that is used to encrypt the data payload. This same key is used to decrypt and recover the original plaintext data. The length of the symmetric key is contained in the Symmetric Key Length () field of the Public Header. The \u201cHash Key\u201d field is the HMAC or other hash key that is used to calculate the message authentication code (MAC) that follows each block of the encrypted payload data (this process will be described in more detail below). This same key is used by the receiving entity to validate the data in each block. The length of the hash key is contained in the Hash Key Length () field of the Public Header.","Referring now to , Routing Header  is a group of fields that contain information identifying the sender and the recipient of the Secure Print file. The first four bytes (\u2013) contain the Routing Header Identifier, (52, 54, 45, 00) (\u201cRTE\u201d), identifying the beginning of the Routing Header. This field is not required for function purposes, but may be included to facilitate manual examination of a Secure Print file. Routing Header Length  is a 32-bit field that contains the length of the Routing Header, in bytes, from the beginning of the Routing Header Identifier () through the end of the Header Hash field (). This value can be used to locate beginning of the Payload Data. Sender ID Length  is a 32-bit field that contains the length of the Sender ID field , in bytes. If the Sender ID Encrypted bit in the Option Mask field is set to \u201c1,\u201d this field is encrypted with the symmetric (session) key. Sender ID field  contains identifying information that can be used to uniquely identify the sender of the Secure Print data, including any padding bytes. Depending on the application, this field may contain a relatively short ASCII or Unicode identifier, such as a user's login name, a numeric user ID or even a more lengthy, fully-qualified user name. If the Sender ID Encrypted bit in the Option Mask field is set to \u201c1,\u201d this field is encrypted with the symmetric (session) key.","Recipient ID Length  is a 32-bit field that contains the length of the Recipient ID field , in bytes, including any padding bytes. If the Recipient ID Encrypted bit in the Option Mask field is set to \u201c1,\u201d this field is encrypted with the symmetric (session) key. Recipient ID field  contains identifying information that can be used to uniquely identify the intended recipient of the Secure Print data. Depending on the application, this field may contain a relatively short ASCII identifier, such as a user's login name, a numeric user ID, or even a more lengthy, fully-qualified user name or even a signed certificate. Note that it may be desirable to maintain the sender information in cleartext, so that a recipient can obtain a signature-verification key for the sender, without having to perform a costly RSA decryption to obtain the symmetric key and then use the symmetric key to obtain the user information. If the Recipient ID Encrypted bit in the Option Mask field is set to \u201c1,\u201d this field is encrypted with the symmetric key.","Password\/PIN Length  is a 32-bit field that contains the length of the Password\/PIN field , in bytes, including any padding bytes. This field is preferably, although optionally, encrypted with the symmetric key. Password\/PIN field  contains a password or PIN (Personal Identification Number), which is used to authenticate a user who attempts to release a Secure Print job for printing. It will typically be entered by the user on a keypad at the printer. In this regard, it is desirable to provide the capability to use an alphanumeric password on the printer, where those characters can be supported by the user interface on the printer. It is also desirable to support extended (non-ASCII) characters for international applications. For that reason, the PIN, before encrypting, is stored in a series of 32-bit fields, using two bytes to represent each digit as a UCS-2 (16-bit) Unicode value. The data is stored in network order. Unused bytes are filled with Unicode null (NUL) characters. For example, a cleartext PIN value of \u201c1234\u201d (before encryption) may be constructed as shown in . For use with printers that can support alphanumeric passwords, a case-sensitive password (or PIN), before encrypting, may be stored as a null-terminated Unicode string. For example, a cleartext password value of \u201cHello World\u201d (before encryption) may be constructed as shown in . In order to accommodate a Password\/PIN field of variable length, the length of the password is indicated in the Offset to Key field that precedes the Password\/PIN. The total length of the password field, including the terminating NULL and any additional padding bytes, should preferably be a multiple of 32 bits. If a password is used that does not fall exactly on a 32-byte boundary, it should be padded with extra nulls to fill out the remaining 32 bits. The \u201cPassword\/PIN\u201d field is preferably encrypted, using the randomly-generated symmetric key. This field is preferably always encrypted and this encryption constitutes the encryption of step S that transforms routing header  into encrypted routing header .","Job ID Length  is a 32-bit field that contains the length of the Job ID field , in bytes, including any padding bytes. This field is optionally encrypted using the symmetric key. Job ID field  contains the name of the printed document or other information used to identify the job in the printer's queue. This field is preferably encrypted using the symmetric key, and like the encryption of field , constitutes the encryption that transforms routing header  into encrypted routing header .","Signed Header Hash , while shown in , is not part of the routing header, but actually represents integrity check value  shown in . This field contains a hash (or HMAC) of the entire Secure Print header, optionally signed by the sender. The signing key will typically be the RSA private key of the sender, but the use of other signing algorithms, such as the federal Digital Signature Algorithm (DSA), as specified in the federal Digital Signature Standard (DSS) may be used instead. The length of the signing key is contained in the Signature Length field of the Public Header.","Thus, the file format depicted in  makes up a secure client header according to the invention. However, as stated above, the routing header is optional and may be included where the print job is targeted for a specific recipient or where the identity of the sender is desired. To complete one embodiment of the secure file format according to the invention, print data is appended to the secure client header and a description of the print data payload will now be provided.","Referring back to , secure file format  is seen to include the secure client header , with encrypted print data payload  appended thereto. The format for the encrypted print data payload  is depicted in . As seen in , the first four bytes (\u2013) contain a Payload Data Identifier, (44, 41, 54, 00) (\u201cDAT\u201d), identifying the beginning of the Payload Data. This field is not required for functional purposes, but is included to facilitate manual examination of a Secure Print file.","Block Descriptor  is a field that contains a 32-bit block descriptor, which describes the current encrypted data block. A layout of Block Descriptor  is shown in . The lower 31 bits () of the block descriptor contain the length of the current block, in bytes. Note that this length does not include the block hash that follows the data block itself. The upper bit () is defined as \u201cContinue,\u201d and indicates whether or not more data blocks will follow this block. A \u201c1\u201d in this bit indicates that more data blocks will follow, and a \u201c0\u201d in this bit indicates that this is the final data block. It should be noted that the data payload is preferably sectioned into multiple blocks to facilitate processing on devices with limited storage and memory resources. This sectioning is represented in  by data blocks , , , etc. Thus, the Block Descriptor identifies each of the multiple blocks, and as seen in , Block Descriptor  represents the first block of the encrypted data payload, and Block Descriptor  represents the last block of the encrypted data payload. Of course, additional block descriptors would be included to represent each of any other encrypted data payload blocks. Additionally, if the print data payload is small enough, or if the printing device can handle large data payloads, only one data payload block may be included and it may not be necessary to break-up the data payload into multiple blocks.","The actual data payload is contained in Data Payload block  and is preferably encrypted using the symmetric (session) key generated by the client, thus forming the encrypted data payload.","Data Block HMAC  is a field that contains an integrity check result (hash) value, and in this case, an HMAC (Hashing Message Authentication Code) value. A hash or HMAC is provided for each block to allow the target device (printer) to determine that errors have occurred before reaching the end of a potentially large file. The use of a keyed hash, such as HMAC, allows the device to immediately determine that a block was damaged or tampered with, allowing the device to immediately terminate the job. The Data Block HMAC  is calculated over the previous HMAC (the header HMAC  in the case of the first data block, or the previous data block HMAC, in the case of the remaining data blocks), the current Block Descriptor and the ciphertext data for the current data block. A graphical representation of this chaining type of integrity checking is depicted in , wherein, for the first data block , an integrity check (HMAC) is run over the secure client header HMAC  and the first data block  to obtain a hash value . It should be noted that reference to data block  is merely a generalization and data block  includes the data descriptor field and the data payload as described above. The hash value  of  is placed in the Payload Data portion of the secure file format as block  of . An integrity check (HMAC) is then run for the second data block , with the HMAC being run over the previous HMAC (in this case, HMAC  of the first data block) and the second data block . The process continues in this chain fashion until an integrity check value (HMAC hash) has been obtained for each data block. Thus, in order to cause the final HMAC result to represent the integrity of the entire job, each preceding HMAC is combined with each subsequent data field, such that the last hash is a representation of the entire job.","The foregoing process is also depicted in a flowchart of . As shown in , when a user selects an option for a secure print job (S), the print driver obtains and validates the printer's public key (S) and generates a symmetric key (S). The print driver then commences rendering the print job data into a page description language (such as PCL or PostScript) based on the selected printer (S). The rendered print data is then encrypted with the symmetric key (S), and the encrypted data is divided into a plurality of data blocks (where n represents the number of data blocks). As an alternative, rather than processing the entire job (i.e., rendering the entire print job, encrypting the entire job and then dividing the job into a plurality of blocks), a dynamic approach may used where the print job is dynamically processed in a series of blocks, with each block being rendered, encrypted and, as will be described in more detail below, processed with an HMAC. The print driver also generates the secure client header as previously described with regard to , and in particular, steps S to S. Of course, the secure client header may be generated prior to processing of the data payload and the secure client header transmitted to the printer ahead of the data payload. Once the secure client header is generated, an integrity check (preferably an HMAC) is run over the first of the n data blocks and the integrity check result value appended to the secure client header (S). The integrity check result value (HMAC) that results from step S is appended to the first data block and appears in the secure file format as block  as described above with regard to . Then, it is determined whether all of the data blocks have been processed (i.e., whether any more of the n data blocks are present) (S). If additional data blocks are present, then the integrity check result value appended to the immediately preceding data block is obtained (S) and an integrity check (HMAC) is run over the obtained value and the next data block (S). The integrity check value that results from step S is appended to the next data block (S) and flow returns to step S to determine whether any additional data blocks are present that have not yet been processed. The process continues until all of the data blocks have been processed, at which point the end of file has been reached (S).","Thus, having processed the encrypted data payload according to the foregoing, a secure file format can be comprised of, not only the secure client header in conjunction with commonly encrypted payload data (i.e., data merely encrypted with the symmetric key but not divided and hashed), but the secure client header as described above in conjunction with the divided and hashed encrypted data payload.","Finally, the last portion of the secure file is an End-of-File Identifier. This field consists of four bytes (\u2013) which comprise the End-of-File Identifier, (45, 4F, 46, 00) (\u201cEOF\u201d). This is the final field in a Secure Print File, designating the end of the Secure Print job.","While the foregoing described how a secure file format may be generated according to the invention, it can be understood that print data is formatted by a client's printer driver, using a number of successive steps, before it is finally delivered to the printer. First, an application's print data is rendered by the client printer driver in a format that is understood by the printer engine. This is typically done using Postscript, PCL or other printer languages. Next, the driver packages the rendered data in the secure print file format, as described above. This step applies encryption and proprietary headers to the rendered data. Finally, the data is formatted for delivery to the printer, adding fields that describe the printer language that is used and other optional printer control parameters. This latter step may be accomplished using an additional Printer Job Language (PJL) command, paired with a terminating Universal Escape Language (UEL) field. In other words, after the print data is prepared in the secure file format as described above, it may be encapsulated using an additional PJL-UEL command pair, which indicates that it is a secure file. An example format of this packaging is shown in . The NEL recognizes this command and processes the print data such that the plaintext, rendered print data is recovered and printed.","Of course, the invention is not limited to use with secure print jobs submitted to a printer, either directly or via the NEL. Rather, the secure file format of the present invention could be implemented in a number of embodiments other than secure print jobs. For example, rather than submitting a print job to a printer, a user can choose an option to print to a file using a virtual printer. In this case, the print file would be packaged as a secure file as described above, with the secure file then being stored in a designated location. Such a location may be, for example, on a local hard disk of client workstation , print server , on a removable storage medium such a floppy disk or CD-ROM, or any other storage area. In like manner, the secure file is not limited to a print file that is submitted to a virtual printer, but rather, could be a file that is saved in an application program as a secure file. In this regard, a user may merely select an option in an application program to save a file as a secure file. The software in the client computer packages the file in a secure file format according to the invention and the secure file is saved to a designated location.","The secure file format could also be implemented in facsimile transmissions or e-mail messages. In either of these embodiments, data being transmitted via facsimile or e-mail may be packaged in the secure file format according to the invention, with a device at the receiving end performing the functions of the NEL.","Thus, the secure file format of the present invention could be implemented in virtually any environment where secure transmission of data is involved, and in particular, where data is transmitted via the use of public\/private keypairs.","The invention has been described with particular illustrative embodiments. It is to be understood that the invention is not limited to the above-described embodiments and that various changes and modifications may be made by those of ordinary skill in the art without departing from the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 10A"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 10B"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 10C"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 10D"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 11","FIG. 12"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 13"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 14"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 15"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 16"},{"@attributes":{"id":"p-0038","num":"0037"},"figref":"FIG. 17"},{"@attributes":{"id":"p-0039","num":"0038"},"figref":"FIG. 18"},{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 19"},{"@attributes":{"id":"p-0041","num":"0040"},"figref":"FIG. 20"},{"@attributes":{"id":"p-0042","num":"0041"},"figref":"FIG. 21"},{"@attributes":{"id":"p-0043","num":"0042"},"figref":"FIG. 22"},{"@attributes":{"id":"p-0044","num":"0043"},"figref":"FIG. 23"},{"@attributes":{"id":"p-0045","num":"0044"},"figref":"FIG. 24"},{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 25"},{"@attributes":{"id":"p-0047","num":"0046"},"figref":"FIG. 26"},{"@attributes":{"id":"p-0048","num":"0047"},"figref":"FIG. 27"},{"@attributes":{"id":"p-0049","num":"0048"},"figref":"FIG. 28"}]},"DETDESC":[{},{}]}
