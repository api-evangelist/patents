---
title: Speaker-buffer management for voice-over-internet-protocol (VoIP) triggered by microphone-buffer arrival
abstract: A Voice-over-Internet-Protocol (VoIP) system has improved audio-buffer control. Voice captured by a microphone (mic) is loaded into mic buffers by the sound card and sent to a VoIP application. When a mic buffer arrives from the sound card, a speaker buffer manager is activated. Voice data extracted from incoming VoIP packets is loaded into a speaker buffer and sent to a speaker queue on the sound card for playback. A speaker-buffer count is kept and increased as each speaker buffer is sent to the sound card, and decreased as each empty speaker buffer is recycled from the sound card back to the VoIP application. As each mic buffer arrives, the speaker buffer manager compares the speaker-buffer count to upper and lower limits and sends zero, one, or two speaker buffers when the speaker-buffer count is above, between, or below the limits. Speaker-buffer latency and playback timing irregularities are reduced.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08537811&OS=08537811&RS=08537811
owner: Google Inc.
number: 08537811
owner_city: Mountain View
owner_country: US
publication_date: 20111219
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF INVENTION","DETAILED DESCRIPTION","ALTERNATE EMBODIMENTS"],"p":["This invention relates to voice-over-Internet-Protocol (VoIP) systems, and more particularly to control of audio data flow to and from a sound card.","Telephone calls can now use the Internet rather than traditional telephone lines. Voice-over-Internet-Protocol (VoIP) applications capture a user's voice, digitize and compress the voice, and transmit the coded voice as data inside Internet-protocol (IP) packets that can be sent over the Internet.","VoIP applications can be installed on personal computers (PC's), other devices connected to the Internet, or on translation servers such as Internet-to-Telephone gateways or Protocol Converters. Each party to a call runs a local copy or client of the VoIP application. When a PC is used, the VoIP application typically uses the existing sound card installed on the PC to play the remote caller's voice on a speaker, and to capture the local users voice from a microphone plugged into the sound card.",{"@attributes":{"id":"p-0005","num":"0004"},"figref":"FIG. 1","b":["10","12","10","10","16","12"]},"VOIP application B on PC  receives these IP packets, extracts and de-compresses the voice data, and sends the voice data to a sound card on PC  which generates audio signals to drive a speaker that plays the voice as audio to user B. User B's voice is then captured by a microphone attached to the sound card, converted to digital signals and coded, compressed, and fitted into IP packets by VOIP application B on PC . The IP packets containing user B's voice are also routed over Internet  back to VOIP application A on PC  for playback to user A, achieving a full-duplex voice call.","A wide variety of sound cards from many different manufacturers may be installed on any given PC. These sound cards often are controlled and driven from the PC by standard software interfaces such as Windows multi-media input-output (MMIO) wave drivers by Microsoft Corp. Originally sound cards were designed for basic (half-duplex) tasks such as playing sound effects in early PC games. Simultaneously capturing voice while playing the speaker was not a design priority. More recently, VoIP applications need full-duplex audio, yet the sound cards and their interfaces are not optimized for such full-duplex tasks.",{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2","b":["30","20","26","20","26","26","38","26","32","22"]},"Once all the voice data in a buffer has been played to speaker , then the empty buffer  can be recycled to the PC and re-loaded with more recent voice data from the remote user. Buffers could be destroyed (deleted) and new buffers generated on the PC, but typically operation of the Windows MMIO re-uses the buffers after playback. The voice data is typically still in the buffer, but it is overwritten with new voice data from VoIP application \u2032. Alternately, pointers to the buffers may be transferred between VoIP application \u2032, and the Windows MMIO sub-system.","Microphone  captures the local users voice and writes the digitized microphone (mic) data \u201cM\u201d into a current mic buffer  on sound card . Sound card  has an inventory of empty buffers  ready to be filled with microphone data. Once buffer  is filled with mic data, buffer  is passed back to the Windows MMIO on the PC and VoIP application \u2032 reads the mic data from buffer \u2032, and processes the mic data and sends it over the Internet to the remote caller using IP packets.","Once the mic data has been read from buffer \u2032 (or a copy of buffer \u2032 made), then the empty buffer \u2033 can be sent back to sound card  and added to the inventory of empty mic buffers. Thus full and empty microphone buffers and voice (speaker) buffers are passed and recycled between the PC and sound card .","Most sounds on PC's are produced by loading a digital representation of the sound onto the sound card in large (or entire) chunks, and then the sound card produces the requested sound. Buffers , ,  each typically contain 60-200 milli-seconds (ms) or more of audio data. Similarly, sounds captured by the microphone are often buffered into large chunks (60-200 ms buffers , , ) that can be stored on disk whenever convenient. While such large buffers may be efficient for the PC, the large audio length may cause timing issues such as latency, alignment of incoming and outgoing audio, and clock accuracy, as audio is aligned at the boundaries of lengthy buffers. The MMIO interface is limited in its ability to determine the exact timing that the sound card is using in playing buffers of audio. Applications hand buffers to the MMIO layer, and at some future time the MMIO layer hands buffers back to be recycled. There is no query in MMIO to determine which buffer is currently being played back, or to determine the number of buffers on the sound card. There is no mechanism to signal when the speaker queue on the sound card is about to go empty that can reliably operate in very small time increments (below 60 to 100 mSec). Other, more sophisticated interfaces do exist, but are not supported as widely. For example DirectX 8.0 has more alignment and buffer signal choices, but can only be used on Windows XP.","There may be a significant delay from the time when a buffer \u2033 of the remote caller's voice data is loaded into the top of the playback queue and when the buffer \u2033 is finally played by the speaker, since other buffers ,  must be played first, and these can be long buffers. For example, when 5 buffers of 200 ms of voice data are waiting to be played, the total queue delay is 1 second. A one-second delay in playback can be noticeable and quite annoying in a phone call. The general goal for VOIP is a total delay of no more than 125 to 250 mSec for the entire trip from one user to the other including all the delays across the Internet.","Since the microphone data buffers tend to be sent back to the PC immediately once filled, delays in mic data are less of a problem. The mic queue has empty buffers while the speaker queue has buffers full of voice data, so the speaker queue is especially a problem as it can add audio delays to playback. These delays can be significant when large buffers are used since the worst-case latency includes the delay to fill the mic buffer.","Issues of timing, clock accuracy, full-duplex (using both microphone and speaker feeds at the same time), latency, and alignment are not important for many computer sound tasks, and thus the interfaces and designs of sound cards and their drivers on many personal computers do not lend themselves to efficient low latency full-duplex streaming. Software drivers, operating systems, and other components can further alter timing. The use of large audio buffers compound these timing problems.","Sound cards vary widely in actual performance. Erratic behavior is sometimes observed in playback rates and trans-fer timing of the speaker buffers. Empty speaker buffers may be recycled after varying delays rather than precisely in sync with the audio playback timing. If the inventory of speaker buffers becomes empty, playback will pause, noticeably degrading the audio quality heard by the user. Thus the sound card is normally passed all speaker buffers as soon as possible, keeping the inventory of speaker buffers on the sound card as full as possible. This large inventory of speaker buffers increases latency as a large queue is used. Empty speaker buffers are then re-filled and returned to the sound card as soon as possible by the VoIP application.","What is desired is a VoIP system that more efficiently buffers audio to and from the sound card. Improved reliability and performance of streaming full duplex audio to and from the multi media sound subsystem of a computer such as a Windows PC is desirable. Reduction of the number of buffers in the speaker queue and the use of smaller audio buffers to the speaker queue is also desirable. A more tightly-coupled and adaptive full-duplex audio-buffer management scheme is desired.","The present invention relates to an improvement in VoIP audio buffering. The following description is presented to enable one of ordinary skill in the art to make and use the invention as provided in the context of a particular application and its requirements. Various modifications to the preferred embodiment will be apparent to those with skill in the art, and the general principles defined herein may be applied to other embodiments. Therefore, the present invention is not intended to be limited to the particular embodiments shown and described, but is to be accorded the widest scope consistent with the principles and novel features herein disclosed.",{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3","b":["24","20","20","30","42","20"]},"The mic data contains user A's voice and is stored as digitized voice data  once extracted or copied from the mic buffers by microphone buffer processor . Codecs  are one or more voice encoders that compress and encode the raw digitized voice using a variety of algorithms. Some algorithms may be more bandwidth-efficient than others but have lower voice quality. Standard as well as proprietary codecs can be used. Packetizer  forms the outgoing IP packets by adding headers and catalogs of the voice data to the encoded voice data from codecs .","Incoming packets with user B's voice data are received and stored by jitter buffer . Variable Internet transit delays and variations in packet reception times are accommodated by jitter buffer , and packets can be re-ordered by sequence number if received out of order. The packets are sent to core manager  of VOIP application , which extracts the voice data from the packets, examines the voice catalog, and selects the specified codec to decode and decompress the voice data. The final decoded, decompressed voice data is loaded into an empty speaker buffer by speaker buffer manager  and sent to sound card . The audio in the speaker buffer received by sound card  is played by speaker  as audio output to local user A.","The inventor has discovered that a tight coupling between the audio input and audio output buffering can improve buffer management. Rather than have speaker audio buffer management be completely isolated from microphone buffer management, the inventor has discovered that the microphone buffer management can be used to control speaker buffer management. When a new microphone buffer is received from sound card , microphone buffer processor  generates a \u201cmicrophone event\u201d signal to speaker buffer manager . This microphone event activates speaker buffer manager , which then can send one or more speaker buffers to sound card .","Thus microphone buffer timing is used to control timing of speaker buffers sent to the sound card. An arrival of a new microphone buffer activates speaker buffer manager . More careful control of the number of speaker buffers on sound card  can also improve buffering. Latencies can be reduced by reducing the number of speaker buffers stored on sound card . Using smaller size buffers can further reduce latencies. Smaller-size speaker buffers require more accurate timing, which can be more easily measured from the arrival of microphone buffers than from the timing of the recycled speaker buffers themselves. Some sound cards may accumulate \u201cempty\u201d speaker buffers before recycling them back to the PC, adding to timing inaccuracies.","Since the microphone data has not yet traversed the Internet, it does not have the variable delays that the speaker data contains after having passed through the Internet. Thus the microphone data is much more accurately timed than the speaker data. The microphone data arrives from the sound card at regular intervals as each mic buffer fills up. These mic intervals are not varied by Internet delays since the mic data can only be delayed by the local PC being busy with some other task. Since the sound card can often interrupt tasks on the local PC within a short time, the mic buffers are loaded onto the local PC with little delay. In contrast, speaker data passes from the remote user's PC through many routers and paths on the Internet, and can have widely varying delays. Thus the speaker data can have much larger delays and variations in delay than the does the mic buffers.",{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 4","b":["20","24","134","134","128","20","30"]},"The newly arrived mic buffer \u2032 is processed by microphone buffer processor , which extracts or makes a copy of the mic data, and passes this data to other components of VoIP application  for coding, compression, and packetization before being sent over the Internet to the remote VoIP application. The empty mic buffer \u2033 is recycled back to sound card , which contains a queue of empty mic buffers  waiting to be filled with microphone data.","Speaker Buffers Managed in Response to Microphone Buffer Arrival","When microphone buffer processor  receives a full mic buffer from sound card , microphone buffer processor  sends a mic event to speaker buffer manager . This mic event activates speaker buffer manager  to perform management of the speaker buffers. Speaker buffer manager  examines the number of full speaker buffers in the speaker queue on sound card  and decides how many, if any, speaker buffers to fill and send to sound card .","When the number of full speaker buffers \u2033,  in the speaker queue on sound card  waiting to be played on speaker  is within a desired range, speaker buffer manager  can fill and send one speaker buffer \u2032 with speaker data extracted form the incoming IP packets. Speaker buffer \u2032 is filled and sent to sound card  and placed at the top of the speaker queue as speaker buffer \u2033.","When too many full speaker buffers \u2033,  are in the speaker queue on sound card  waiting to be played on speaker , speaker buffer manager  can skip filling and sending any speaker buffers. This allows more time for speaker  to play the speaker data from the speaker buffers \u2033,  already in the speaker queue on sound card . Not sending a speaker buffer allows the number of full speaker buffers in the speaker queue to be reduced.","When too few speaker buffers are present in the speaker queue on sound card , two or more speaker buffers \u2032 may be filled and sent to sound card . This replenishes the speaker queue on sound card .","As speaker buffers are played by speaker  and emptied, the empty (played) speaker buffers  are recycled back to speaker buffer manager  on the PC. These empty speaker buffers may be filled and sent back to sound card  at the next microphone event, or may be kept in an inventory of empty speaker buffers  on the PC by speaker buffer manager .","The size of the mic and speaker buffers can be much smaller than for the prior art of . More active management of buffer queues allows for smaller buffer sizes and smaller amounts of audio data to be queued. For example, rather than use audio buffers containing contain 60-200 milli-seconds (ms) of audio data, smaller audio buffers of only 20 ms of audio data can be used. These smaller buffers reduce latencies since a smaller amount of audio needs to be played to clear the speaker queue, or to finish the current audio buffer.","When some kind of timing error occurs, speaker buffer manager  may decide to skip ahead and delete some of the speaker data when the timing is off. This can be better accomplished by deleting some of the incoming voice data before it is loaded into a speaker buffer. Deleting filled speaker buffers is difficult, especially when the speaker buffers have already been sent to audio card . Thus recovery from timing problems is faster when the amount of speaker data already sent to sound card  is minimized. Latency is reduced.","Mic Buffer Arrival Triggers Speaker Buffer Transfer\u2014",{"@attributes":{"id":"p-0043","num":"0042"},"figref":["FIG. 5","FIG. 5"],"b":"70"},"When the Windows MMIO driver receives a mic buffer from the sound card, it activates the flow of , starting with step . A copy of the voice data in the mic buffer is made, and the voice data is coded, compressed, and fitted into one or more IP packets, step . These IP packets are sent over the Internet to the remote caller's PC. The empty mic buffer can be sent or recycled back to the top of the sound card's microphone buffer queue once the voice data is copied, step .","The buffer management software or speaker buffer manager keeps track of the number of speaker buffers in the speaker queue on the sound card. Since the buffer manager running on the PC usually cannot directly examine the number of buffers on the sound card, the buffer manager keeps a running count of the number of buffers on the sound card. The running count can be increased each time a full speaker buffer is passed from the PC to the sound card, and decreased each time an empty speaker buffer is returned from the sound card to the PC. This running count or speaker-buffer count kept by the speaker buffer manager on the PC is examined, step , to determine how many speaker buffers need to be sent to the sound card.","The speaker-buffer count can be compared to an upper limit (high water mark) and to a lower limit (low water mark). When the speaker-buffer count is between the upper and lower limits, step , then clock rates are well-matched and one speaker buffer is filled with voice data from the remote caller and sent from the PC to the top of the speaker queue in the sound card, step . The speaker-buffer count is increased by one, step , and the speaker buffer manager waits for the next event, step .","When the speaker-buffer count is below the lower limit, step , then negative clock drift is detected. The microphone clock rate is a little faster than the speaker clock rate. Some sound cards use separate clocks for speaker and microphone audio sections, and these clocks may differ by a fraction of one percent, or even by several percent, even when both clocks are set to the same sampling\/playback rate.","To compensate for the slower speaker clock rate, two speaker buffers are filled with voice data from the remote caller and sent from the PC to the top of the speaker queue in the sound card, step . This helps to replenish the speaker-buffer queue on the sound card. The speaker-buffer count is increased by two, step , and the speaker buffer manager waits for the next event, step .","When the speaker-buffer count is above the upper limit, step , then positive clock drift is detected. The speaker clock rate is a little faster than the microphone clock rate. To compensate for the faster speaker clock rate, no speaker buffers are filled and sent to the sound card, step . This allows more time to reduce the speaker-buffer queue on the sound card. The speaker-buffer count is no changed, step , and the speaker buffer manager waits for the next event, step .","When the speaker-buffer count remains above the upper limit for longer periods of time, voice data may need to be deleted entirely rather than just delayed. The VoIP application can decide what data to delete, such as by searching for quite period of time to delete rather than active speaking times.","When an empty speaker buffer arrives from the sound card, the speaker buffer manager decreases the speaker-buffer count by one. However, the empty speaker buffer is not immediately re-filled and sent back to the sound card. Instead, the empty speaker buffer is kept in the inventory of the speaker buffer manager at the PC. This process (not shown) is independent from the process of , which is activated by the arrival of a mic buffer from the sound card.","Ideally, the speaker buffer queue on the sound card can be kept as small as possible. The speaker queue may have only one full speaker buffer in addition to the current speaker buffer that is being played. Alternately, a more aggressive implementation may have only the current speaker buffer being played in the speaker queue, and no full speaker buffers. The lower limit may be set to just 1 or 2 buffers, but may be increased if problems occur, such as if the speaker buffer becomes depleted too often. The upper limit can be a larger value such as 12, or to values between 4 and 24. The limits can be fine-tuned to improve performance. These limits could be userchangeable, such as by settings in the VoIP program that can be adjusted by the user.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 6","FIG. 5"]},"The microphone could be muted for a short period of time, such as when the person's manager interrupts, walks in, and talks to the local user. The local user may hit a \u201cmute\u201d button on the PC to prevent audio from being sent to the remote user while the local user is being interrupted by his manager.","Other problems could occur that delay or block arrival of mic buffers from the sound card. The process of  is activated by the timer event when the mic buffers do not arrive for whatever reason. The speaker-buffer count kept by the speaker buffer manager on the PC is examined, step , to determine how many speaker buffers to send to the sound card.","When the speaker-buffer count is between the upper and lower limits, step , the clock rates are well-matched and one speaker buffer is filled with voice data from the remote caller and sent from the PC to the top of the speaker queue in the sound card, step . The speaker-buffer count is increased by one, step , and the speaker buffer manager waits for the next event, step .","When the speaker-buffer count is below the lower limit, step , then negative clock drift is detected. To compensate for the slower speaker clock rate, two speaker buffers are filled with voice data from the remote caller and sent from the PC to the top of the speaker queue in the sound card, step . This helps to replenish the speaker-buffer queue on the sound card. The speaker-buffer count is increased by two, step , and the speaker buffer manager waits for the next event, step .","When the speaker-buffer count is above the upper limit, step , then positive clock drift is detected. To compensate for the faster speaker clock rate, no speaker buffers are filled and sent to the sound card, step . This allows more time to reduce the speaker-buffer queue on the sound card. The speaker-buffer count is no changed, step , and the speaker buffer manager waits for the next event, step .",{"@attributes":{"id":"p-0059","num":"0058"},"figref":"FIG. 7","b":["140","140"]},"Telephony\/Audio Services Interface (TASI)  is a development environment that provides an application programming interface (API) for using library features or functions called by application . TASI  can have a variety of services such as call control (detecting, placing, and terminating calls between clients) and audio stream control and formatting.","Interchange services  corresponds to the OSI-model transport layer. Interchange services  provides packet transport using IP packets. Communication sockets in Windows socket sub-system  can be opened by Interchange services  to send and receive IP packets containing audio or video data to a remote caller over the Internet. Of course, socket sub-systems other than Windows can be substituted.","Multi-function resource  can be implemented in hardware or software or both. Multi-function resource  provides a host-based software layer that performs a variety of functions. Multi-function resource  can perform digital-signal processor (DSP) functions, such as voice compression, echo cancellation, bad frame interpolation for late or lost packets, silence compression, voice activity detection, and comfort noise generation. In addition, multi-function resource  provides the ability to play wave files on multimedia subsystem . Multi-function resource  can have three main subsystems: the voice compression subsystem, the packetization sub-system, and the voice quality sub-system.","Windows multimedia I\/O subsystem  (Windows MMIO) contains the operating system sound-card wave interfaceimplementation drivers and low-level components that communicate with audio hardware , such as a sound card or audio subsystem. Speakers and a microphone, or other multi-media devices can be connected to audio hardware  controlled by multimedia subsystem .","Adaptive MMIO flow control  may be inserted above Windows multimedia I\/O subsystem  and below multi-function resource  if present, or other higher-level components such as the transport layer.","Adaptive MMIO flow control  contains lower-level components of the speaker buffer manager. Adaptive MMIO flow control  can activate higher-level components of the speaker buffer manager to help manage the speaker buffers by sending events or calling routines in voice-call application  or TASI . Thus the speaker buffer manager can have low-level components in adaptive MMIO flow control  and higher-level components in voice-call application  or TASI .","Not all layers need to be present in all embodiments. Some layers such as , ,  and  are optional and can be deleted or replaced by other components.",{"@attributes":{"id":"p-0067","num":"0066"},"figref":"FIG. 8","b":["250","202"]},"The speaker-buffer count rises above the upper limit during period . When mic buffers arrive from the sound card, no speaker buffers are sent during period . Empty speaker buffers recycled to the PC are not returned to the sound card, but are kept by the PC. Eventually, the number of speaker buffers on the sound card falls below the upper limit, and in period  one speaker buffer is sent to the sound card as each mic buffer arrives.","The speaker-buffer count has fallen below the lower limit during period . Two speaker buffers are filled and sent to the sound card for each mic buffer that arrives.",{"@attributes":{"id":"p-0070","num":"0069"},"figref":"FIG. 9","b":["260","260"]},"Rather than compare the speaker-buffer count to upper and lower limits, the speaker-buffer count is compared to the moving average in this alternate embodiment. When the speaker-buffer count is near the moving average, such as being between 80% and 150% of the moving average, one speaker buffer is sent to the sound card as each mic buffer arrives from the sound card. This occurs during periods  and .","During period , the speaker-buffer count has risen far above its moving average. For example, the speaker-buffer count may be more than double the moving average, well above the 80-150% desired range. Then no speaker buffers are sent, even when a mic buffer arrives, until the speaker-buffer count falls below the 150% threshold. The speaker-buffer count is reduced as the sound card recycles empty speaker buffers during period .","Several other embodiments are contemplated by the inventor. Core manager , speaker buffer manager , microphone buffer processor , and other components may contain a variety of software modules including user interfaces and may call other modules, library, or operating system routines. The components of the software may be partitioned or combined in a wide variety of ways using modules, libraries, instances, procedures, etc.","The microphone and speakers may be combined on a headset or handset rather than be separate devices. The same duplexing problems may arise on non-physical sound card devices such as for telephone applicationsprogramming interface (TAPI\/WAVE) devices, where a sound-card style of interface is used for a network audio stream or external device.","This invention is may be useful not only for an actual physical sound card, but also for a software application that simply uses the sound card style interface. The term sound card has been used, but the \u201csound card\u201d is often not a true plug-in card, but can be integrated with other components, such as when the sound card is an audio controller integrated on the PC motherboard. A secondary audio device may be used on the PC with an attached headset or handset, but this device is still typically treated as a sound card on the PC even if it plugs in via USB, audio jacks, or even wireless links such as BlueTooth or 802.11.","The audio buffers may contain data having the same audio play time, but may differ in the number of bytes due to differences in audio coding formats. Headers and other information may also differ in size. One speaker buffer has been described as being sent for each microphone buffer received from the sound card at steady-state conditions. This is true when the audio play time of the speaker and microphone buffers are about the same. Two speaker buffers that have half the audio time of the arriving microphone buffer could be sent instead. Other numbers of buffers could be sent in response to different relative playback sizes of the speaker and microphone buffers. Sound cards may not physically accept buffers smaller than 60 ms, such as the 20 ms buffers. Their drivers may actually send groups of three 20 ms buffers when the buffer size is set to 20 ms for these kinds of sound cards.","Speaker buffers could be pre-filled by speaker buffer manager  or by another software component before the mic event occurs, but then sent to the sound card in response to the mic event. \u201cEmpty\u201d audio buffers may still contain the old audio data that has been played or copied. In most cases, delivery of the buffers from the MMIO driver layer to the physical sound card is done by copying the contents across a bus (such as PCI, ISA, USB, etc) and creating a replica of the buffer at the sound card or sound device. The sound-card driver is responsible for getting the buffers to and from the sound card, and variations in the implementation from one vendor to the next do cause variations in the timing of buffer shipment from the VOIP application to the sound card, and in the rate that recycled buffers are returned. When using large prior-art style buffers, the affect of these variations is minimized, but at the cost of very large latency.","Audio buffers can be small storage areas in computer memory which hold sampled audio data to be conveyed from one device to another, such as from a microphone or to a speaker. A buffer is typically identified as a contiguous memory space with a known starting memory address and a known length. A queue or collection of buffers is used to keep a steady stream of audio data going to and from a device such as a sound card and the computer which is communicating to it. The buffers can be filled by the sound card and the PC signaled when the buffer is ready, then the PC can access the buffer, copy the data out of it and put the data to use. The section of memory which represents the buffer can then be handed back and re-used by the sound card for another load of audio data in the future so that memory is not continuously used up over time. For the MMIO interface, buffers to hold the audio data are typically created ahead of time by the application, and are prepared (handed to) the MMIO sub-system so that the MMIO layer can use the buffers for exchanges of data to and from the application and the sound-card or sound device.","On the PC the buffers could be stored in the PC's memory, such as a main-memory DRAM, hard disk, or a flash memory, while when on the sound card the buffers could be stored in a DRAM, SRAM, or flash memory on the sound card, or even be transferred among several memories. When the sound card is integrated with the PC motherboard, the sound card's memory can be mapped into the address space of the PC motherboard, or a driver can be responsible for replicating buffers of data from the memory on the PC motherboard to the memory on the sound card in a manner which makes it appear to the higher layers of software on the PC that the sound card's memory is visible locally on the PC motherboard. The same is true of USB audio devices. Other future hardware innovations may convey the overall MMIO buffer passing interface using new physical mechanisms, but resulting in the same behavior from the application's perspective, which is that it writes speaker data to a local buffer of memory and then hands ownership of that buffer to the MMIO layer, and conversely the MMIO layer periodically presents the application with microphone data contained in buffers that upon presentation belong to the application and are in its local memory since the application typically created the buffers at the start of the process.","Various combinations of software, hardware, or firmware implementations are possible and various routines can be called and executed sequentially or in parallel. While the VoIP packets have been described as being routed over the public Internet, packets may be routed over other networks or combinations of networks such as Ethernets, Intranets, wide-area networks, wireless networks, satellite links, etc. Unmanaged networks can be used or networks with some management. The audio packets can also include multi-media data such as images, video, or text. The voice data can be audio data that is often voice, but could include other audio data such as songs, music, traffic noise, etc.","The amount of voice data in packets can vary from packet to packet rather than be the same for all packets as described in the simplified examples. The jitter buffer may perform other functions, such as detecting and processing duplicate and missing packets.","Additional filtering of the speaker-buffer count could be performed. Many kinds of moving averages can be used, such as a simple arithmetic moving average, weighted moving averages that increase weighting of more recent data points, exponential moving averages, etc. Multiple limits could be used to further increase the number or audio playback time of audio buffers sent to the speaker queue when above a second upper limit. Negative counts and inverse counting could be substituted where a count is \u201cincreased\u201d by reducing the count value. The upper and lower limits can also be adaptively determined for a given PC and sound card combination. The Speaker Buffer Manager could measure the average number of speaker buffers which reside on the sound card and then set low and high limits slightly above and slightly below that typical range so that periodic variations from the usual timing on that particular sound card do not result in drop outs or hiccups.","Speaker Buffer Manager  and Microphone Buffer Manager  can be implemented as a single Audio Manager with a single execution context while still performing both jobs and accepting both audio-out and audio-in events from the MMIO layer.","In certain timing situations, or to handle unusual audio devices, the Speaker Buffer Manager can be allowed to send an arbitrary number of buffers to the sound card rather than the usual 0, 1 or 2. This might typically happen where microphone data is for some reason not arriving and the speaker data must be delivered based on failsafe timeout events which might happen each 100 mSec and need to send, for example, 5 20 mSec speaker buffers to keep the speaker operational while microphone data has been suspended.","VOIP calls may be between two users on personal computers, or may consist of one user on a personal computer talking to a computer server or gateway, which converts the call from VOIP to telephone or PBX or private IP phone system formats. The call could also be between two telephone or private IP-phone users with a VOIP segment somewhere in the middle carrying the call from one location to another over the Internet or similar unmanaged network but terminating the call at each end on a telephone or PBX or IP phone. Calls could also involve a conversation between one user on a PC or telephone or IP phone, and at the other end an automated voice response system such as a banking application, voicemail, auto attendant, talking yellow pages or other automated voice service. More than two parties may exist in multi-way calling.","The abstract of the disclosure is provided to comply with the rules requiring an abstract, which will allow a searcher to quickly ascertain the subject matter of the technical disclosure of any patent issued from this disclosure. It is submitted with the understanding that it will not be used to interpret or limit the scope or meaning of the claims. 37C.F.R. \u00a71.72(b). Any advantages and benefits described may not apply to all embodiments of the invention. When the word \u201cmeans\u201d is recited in a claim element, Applicant intends for the claim element to fall under 35 USC \u00a7112, paragraph 6. Often a label of one or more words precedes the word \u201cmeans\u201d. The word or words preceding the word \u201cmeans\u201d is a label intended to ease referencing of claims elements and is not intended to convey a structural limitation. Such means-plus-function claims are intended to cover not only the structures described herein for performing the function and their structural equivalents, but also equivalent structures. For example, although a nail and a screw have different structures, they are equivalent structures since they both perform the function of fastening. Claims that do not use the word means are not intended to fall under 35 USC \u00a7112, paragraph 6. Signals are typically software messages or electronic signals, but may be optical signals such as can be carried over a fiber optic line.","The foregoing description of the embodiments of the invention has been presented for the purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. It is intended that the scope of the invention be limited not by this detailed description, but rather by the claims appended hereto."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":[{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0021","num":"0020"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0022","num":"0021"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 9"}]},"DETDESC":[{},{}]}
