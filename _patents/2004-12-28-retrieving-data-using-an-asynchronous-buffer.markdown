---
title: Retrieving data using an asynchronous buffer
abstract: A mechanism for retrieving data over a network using an asynchronous buffer is described herein. According to one embodiment, an exemplary process includes, in response to a request for first data from a client via a first thread, determining whether a local circular buffer contains the requested first data, the local circular buffer having a head region and a tail region for identifying a head and a tail of the local circular buffer respectively, and the local circular buffer containing a portion of a data file maintained by a server over a network, generating a second thread to the server over the network to request the first data, if the local circular buffer does not contain the requested first data, and returning the first thread to the client while waiting for a result of the second thread from the server. Other methods and apparatuses are also described.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08239447&OS=08239447&RS=08239447
owner: SAP AG
number: 08239447
owner_city: Walldorf
owner_country: DE
publication_date: 20041228
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The present invention relates generally to network computing. More particularly, this invention relates to retrieving data over a network using an asynchronous buffer.","Logging is employed within virtually all data networks. \u201cLogging\u201d refers generally to recording network-related and\/or application-related information in response to one or more predefined network\/application events. For example, when an end-user opens a TCP connection to a server, or unsuccessfully attempts to gain access to network resources (e.g., by attempting to log in to a particular server), this information is typically recorded as an entry within a log file. Similarly, if a variable within an application rises above a specified threshold value, a log entry indicating the value and the date and time that the threshold value was exceeded may be stored within a log file. Logging techniques may be employed to record any specified network\/application event. Network administrators may then review the log files to identify security issues and\/or troubleshoot network problems.","Java 2 Enterprise Edition (J2EE) is a tool commonly used in software development today for developing enterprise applications. Generally, J2EE reduces the costs and complexity associated with developing multi-tier enterprise services. Another advantage of J2EE is that it can be relatively rapidly deployed and enhanced as the need arises. J2EE is currently used in many large-scale application development projects for these reasons.","As application development projects grow larger, logging becomes increasingly more important and complicated. Typically, a log file can be viewed by a client, such as an administrator using a viewing graphical user interface (GUI). However, the viewing GUI can only display a portion of the log file. As a result, the clients have to perform their own buffer management. In addition, it may take a long time in order to retrieve the log data over a network. Hence, a minimal amount of data should be transmitted over the network.","In an enterprise computing environment, such as J2EE environment, a Java swing table model is typically used. However, such implementation is limited to the Java swing table and the Java swing table is carried in a synchronous manner which may hold up the client's operation.","A mechanism for retrieving data over a network using an asynchronous buffer is described herein. According to one embodiment, an exemplary process includes, in response to a request for first data from a client via a first thread, determining whether a local circular buffer contains the requested first data, the local circular buffer having a head region and a tail region for identifying a head and a tail of the local circular buffer respectively, and the local circular buffer containing a portion of a data file maintained by a server over a network, generating a second thread to the server over the network to request the first data, if the local circular buffer does not contain the requested first data, and returning the first thread to the client while waiting for a result of the second thread from the server.","Other features of the present invention will be apparent from the accompanying drawings and from the detailed description which follows.","A mechanism for retrieving data over a network using an asynchronous buffer is described herein. In the following description, numerous details are set forth to provide a more thorough explanation of the present invention. It will be apparent, however, to one skilled in the art, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form, rather than in detail, in order to avoid obscuring the present invention.","Some portions of the detailed descriptions which follow are presented in terms of algorithms and symbolic representations of operations on data bits within a computer memory. These algorithmic descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. An algorithm is here, and generally, conceived to be a self-consistent sequence of steps leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussion, it is appreciated that throughout the description, discussions utilizing terms such as \u201cprocessing\u201d or \u201ccomputing\u201d or \u201ccalculating\u201d or \u201cdetermining\u201d or \u201cdisplaying\u201d or the like, refer to the action and processes of a computer system, or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","The present invention also relates to apparatus for performing the operations herein. This apparatus may be specially constructed for the required purposes, or it may comprise a general purpose computer selectively activated or reconfigured by a computer program stored in the computer. Such a computer program may be stored in a computer readable storage medium, such as, but is not limited to, any type of disk including floppy disks, optical disks, CD-ROMs, and magnetic-optical disks, read-only memories (ROMs), random access memories (RAMs), erasable programmable ROMs (EPROMs), electrically erasable programmable ROMs (EEPROMs), magnetic or optical cards, or any type of media suitable for storing electronic instructions, and each coupled to a computer system bus.","The algorithms and displays presented herein are not inherently related to any particular computer or other apparatus. Various general purpose systems may be used with programs in accordance with the teachings herein, or it may prove convenient to construct more specialized apparatus to perform the required method steps. The required structure for a variety of these systems will appear from the description below. In addition, the present invention is not described with reference to any particular programming language. It will be appreciated that a variety of programming languages may be used to implement the teachings of the invention as described herein.","A machine-readable medium includes any mechanism for storing or transmitting information in a form readable by a machine (e.g., a computer). For example, a machine-readable medium includes read only memory (\u201cROM\u201d); random access memory (\u201cRAM\u201d); magnetic disk storage media; optical storage media; flash memory devices; electrical, optical, acoustical or other form of propagated signals (e.g., carrier waves, infrared signals, digital signals, etc.); etc.","According to one embodiment, a mechanism for retrieving data using an asynchronous buffer is implemented using a log buffer model. A log buffer model (LBM) is an implementation of a buffer to hold data. In one embodiment, the LBM holds the log records from the logs of a server. A buffer is used to hold log records because a log on the server can contain thousands of records. It is very inefficient to fetch all the data at the client all together. Instead, the buffer tries to look ahead (e.g., anticipate) and calculates if the user might want to view certain data and prefetches a small chunk of data from the logs that may reside on the server over a network.","In one embodiment, the log buffer model is based on a circular buffer that wraps around itself in both directions (e.g., start and end directions). Once the buffer contains the maximum number of records it can hold (e.g., exceeding a buffer size), it starts to write over the oldest data in the buffer. This provides a quick and effective paging mechanism. The overhead to calculate new positions to write into is minimized because the calculations to determine the location for currently retrieved records are minimized. According to one embodiment, the buffer can \u201cgrow\u201d in either direction (e.g., growing from the top or bottom of the buffer), dependent upon whether the user is scrolling upwards or downwards.","According to one embodiment, the buffering tries to give an effect of seamless scrolling through the logs. The log records are remotely fetched over the network and therefore are not immediately available. Instead, one or ore fake log records may be returned as one or more placeholders. In addition, an asynchronous and non-blocking request for the requested data may be placed on the server, for example, via a separate thread. When the actual records arrive from the server, the placeholders may be replaced by actual records. In one embodiment, the log buffer model is asynchronous and event based. That is, when it makes requests to fetch data and is in a wait state, the client program is not held up. The client may continue to perform other functionality. The client is notified via events when the requested data arrives. To receive these events, the client may register as listener(s) for listening to the events generated by the log buffer model. Similarly, the log buffer model may register as listener(s) to the server to receive notifications from the server indicating that the requested data is ready to be fetched. As a result, the user does not experience any delay while scrolling since the scrolling is not held up by the fetch process, which may take some time depending on the number of logs being merged and the traffic conditions of the network.","According to one embodiment, a concept of relative indexing is used, which may be manipulated to return the requested data or records to the user. However, it is transparent for the client API (e.g., GUI interface), which may simply request for a record at a certain position. This indexing mechanism is similar to how a swing lookup table works. Therefore, the log buffer model may be used in a variety of GUIs.","According to one embodiment, the buffer is exposed as an API (application programming interface). The client of the API is not exposed to the underlying complexity. This makes the client functionality clean and intuitive, while making the log buffer model more useful. The clients simply request for a record at a certain position based on the table. If the log buffer contains the requested record, the record is returned immediately. Otherwise, a request is placed for the requested record. The request may be carried out through another and independent thread. The main thread was left to be free to accept new requests from the client. When this command is executed, the command consumer informs the registered listener that it has returned with a result set. The listener then updates the GUI with these records and the fake log records returned as placeholders early may be replaced by the received actual records.",{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 1","FIG. 1"],"b":["100","101","102","101","103","104","106","107","102","105","103","105","102","101","102"]},"The GUI  may display a portion of data in the data buffer , which may be implemented as a part of a log buffer model (LBM). Since the GUI buffer is typically small comparing to the data stored in the data files , only a portion of the data stored in the data files  may be displayed in GUI . Thus, when a user scroll up or down from the GUI , the GUI  may periodically fetch data from the server . In order to reduce a number of transactions between the client  and the server  over a network, a buffer  may be used to temporarily hold a relatively large portion of data from the data files , for example, as shown in .","According to one embodiment, when GUI  requests for a record via a first thread , processing logic may examine the data buffer  to determine whether the requested record is stored within the data buffer . If the buffer  contains the requested record, the requested record may be fetched from the buffer  and returned to the GUI  via the first thread  substantially immediately.","GUI  may be a client with respect to buffer . Further, GUI  and the data buffer  may be implemented on different nodes on the network dependent upon the network configuration. The data buffer  may be implemented as a part of log buffer model described above. Furthermore, the data buffer  may be implemented as multiple buffers used by the GUI . Alternatively, GUI  may include multiple clients that share the data buffer . Other configurations may exist.","If the requested data is not contained in the buffer , according to one embodiment, the processing logic may generate a second thread  to the server  to retrieve the requested data. The new request may be put in a command queue , which may be controlled or monitored by a command executor . Once the new request has been put in the command queue , the processing logic may return the first thread  back to the client  while waiting for the result of the new request queued in the command queue .","Meanwhile, command executor  fetches each of the commands from the command queue  and executes each command. In this case, the new request is fetched by the command executor  from the command queue  and transmitted to the server  for the requested data via the second thread .","In one embodiment, the first and second threads - are executed independently and asynchronously. As a result, while the processing logic is waiting for a result of the second thread , the first thread  is completed and the control is returned back to the client . Thus, the client  would not be held up by the thread  and the client  may perform its own functionality, while thread  is still pending.","According to one embodiment, the communications between GUI , buffer , and server  may be implemented as event based communication manners. For example, according to one embodiment, GUI  may register, as a client, to data buffer  as a listener to listen certain events published by the data buffer . Similarly, buffer  may register as a client to server  as a listener to listen certain events. Thus, when buffer  makes a new request to the server  for data, which may take a while before receiving a result from the server  dependent upon the traffic condition of the network, buffer  may return or complete the thread  back to the client  with an indication (e.g., via a fake record) that the request is pending. Therefore, the client  would not be held up and can perform its own operations.","When the requested data is returned from the server , the data may be stored in the buffer . In addition to those requested by GUI , according to one embodiment, the returned data from the server  may further include additional data based on an anticipation or prediction what data the GUI  may want in the future. In one embodiment, since GUI  has registered as a listener to buffer , buffer  may simply call a callback routine provided by GUI . GUI  may then retrieve the request data from buffer . Alternatively, buffer  may directly transmit the requested data to a predetermined storage location specified by GUI .","According to one embodiment, buffer  may be a circular buffer having a head region and a tail region. Depending upon whether a user scrolls up or down, the circular buffer may \u201cgrow\u201d in either direction. Once the amount of data stored in buffer  exceeds the size of the buffer , the buffer may wrap around and the oldest data may be overwritten by the new data received from the server. The head and tail regions of the circular buffer  may be maintained using various indexes. Similarly, GUI  may also maintain a set of indexes, which may be updated dependent upon the operations of the user (e.g., scrolling up\/down of the GUI ).",{"@attributes":{"id":"p-0042","num":"0041"},"figref":["FIGS. 2A-2C","FIG. 2A"],"b":["103","104","105","104","103","104"]},"Initially, when the buffer is empty as shown , the TopUsrIdx and the BottomUsrIdx of GUI  are all zero, as well as the HeadUsrIdx and TailUsrIdx of buffer , which indicates that there is no data in the circular buffer and no data is displayed in GUI .","As the data is filled in the circular buffer , for example, up to half of the circular buffer is filled as shown as the shadow area in , the TopUsrIdx\/BottomUsrIdx of GUI  and HeadUsrIdx\/TailUsrIdx of circular buffer  are updated accordingly. For example, for the purposes of illustrations, it is assumed that the circular buffer  has a size of 200 while the GUI  has a size of 20. In this example, the HeadUsrIdx and TailUsrIdx of circular buffer  are 100 and 0 respectively. Further, it is assumed that GUI  is displaying records from 40-60 of the circular buffer. As a result, the TopUsrIdx and BottomUsrIdx of GUI  are 40 and 60 respectively. Note that the sizes set forth above are for illustration purposes only. It will be appreciated that other sizes or configurations may also be applied.","As more data is filled, the HeadUsrIdx of circular buffer  keeps moving up, for example, from 100 to 200, until the buffer is full. In which case, the HeadUsrIdx of buffer  reaches 200 which points to the origin (e.g., zero). If more data is filled after the circular buffer  is full, a portion of the circular buffer will be overwritten. For example, if there 10 more records are filled, the HeadUsrIdx will be 210 while the TailUsrIdx will be 10. In which case a portion (e.g., original records from 0 to 10) will be overwritten (e.g., lost), similar to the situation shown in .",{"@attributes":{"id":"p-0046","num":"0045"},"figref":"FIG. 2D","b":"250"},"Referring to , at block , a request for data is received from a client (e.g., client  of ) via a first thread. In one embodiment, the request is identified via a request index. In response to the request, at block , the processing logic examines whether a local circular buffer (e.g., buffer  of ) contains the requested data, where the local circular buffer includes a head region and a tail region, which may be identified by, for example, a head index and a tail index. In one embodiment, the request index may be compared with the head index and\/or tail index. If the local circular buffer contains the requested data, at block , the requested data is returned substantially immediately via the first thread.","If the local circular buffer does not contain the requested data, at block , a new request is sent to the server (e.g., server  of ) over a network via a second thread. The second thread may be launched independently and asynchronously with respect to the first thread. At block , the first thread is returned while waiting for a result of the second thread, such that the client would not be held up by the first thread. Once the result of the second thread is returned from the server, at block , the client may be notified and the requested data may be retrieved or alternatively, the requested data may be transmitted to the client directly. Other operations may also be performed.",{"@attributes":{"id":"p-0049","num":"0048"},"figref":["FIGS. 3A and 3B","FIG. 3A","FIGS. 2A-2C"],"b":["103","104","105","105","104","104","104","302","104","301","104"]},"In this example, as shown in , the buffer  is full. As a result, the HeadUsrIdx is 200 while he TailUsrIdx is 0. Since the buffer size of the circular buffer  is 200, in fact, both HeadUsrIdx and TailUsrIdx are pointing to the same location as shown in . Also, in this example, the GUI  is displaying the first 20 records (e.g., the newest 20 records) of the circular buffer . Thus, the TopUsrIdx is 0 while the BottomUsrIdx is 20. Dependent upon how the data is being read from the data file , the file pointer may be pointing to either location  or , which represents the boundary of the data corresponding to the data stored in the buffer .","In one embodiment, GUI  sends a request for a record from buffer on a record by record basis. In a particular embodiment, GUI  specifies a record by providing a request index (\u201cReqIdx\u201d) to the buffer . For example, if GUI  wishes to retrieve record , GUI  may pass ReqIdx having a value of 15 as a parameter when requests for a record from buffer . The request may be carried out via a thread, such as first thread  of .","In response to the request received from GUI , the buffer  determines whether the buffer  contains the requested record based on the ReqIdx received from GUI . In one embodiment, buffer  determines whether the ReqIdx is within either a head region or a tail region of the buffer. For example, buffer  may compare the ReqIdx with the HeadUsrIdx and the TailUsrIdx. In this case, since the ReqIdx is 15 and ReqIdx is less than the HeadUsrIdx (e.g., within the head region), it is considered that the buffer  contains the requested record identified by the ReqIdx. As a result, the requested record is returned immediately without having to access the data file  stored in the server over the network. That is, the log buffer model may simply return the requested record via the same thread without having to launch another thread to request data from the server.","A user of GUI  may view the 20 records displayed within GUI . The user may also scroll up and down on a line by line (e.g., record by record) basis. Alternatively, the user may scroll page up and down (e.g., every 20 record step). Further, the user may reset to top or bottom of the buffer  (e.g., records - or records -). In response to the user actions set forth above, TopUsrIdx\/BottomUsrIdx and HeadUsrIdx\/TailUsrIdx may be adjusted accordingly.","Dependent upon the specific implementations, the TailUsrIdx may be maintained as 0 or \u22121 to identify whether there is valid data within the tail region. For example, according to one embodiment, if the circular buffer \u201cgrows\u201d in a positive direction, such as scrolling down of the GUI by a user, the HeadUsrIdx may be increased while the TailUsrIdx remains the same as \u22121, where a value of \u22121 indicates that there is no valid data between the origin 0 and \u22121, as described as the tail region. The actual tail of the circular buffer may be derived from the adjusted HeadUsrIdx and the buffer size (e.g.,  as an example shown in ) as:\n\nActual Tail Position=HeadUsrIdx\u2212Buffer Size\n","Alternatively, according to an alternative embodiment, the TailUsrIdx may be maintained as 0 initially. When the HeadUsrIdx is adjusted due to the user actions (e.g., scrolling up\/down), the TailUsrIdx is also adjusted accordingly. As a result, the head and tail regions of the circular buffer is determined based on both the HeadUsrIdx and the TailUsrIdx, as shown, for example, in  according to one embodiment.","Referring to , in this embodiment, a user keeps scrolling down on GUI  to the bottom of the buffer  (e.g., the oldest records in the buffer ). In this case, the TopUsrIdx and the BottomUsrIdx of GUI  are adjusted respectively as  and . Since the TopUsrIdx and the BottomUsrIdx are still within the head region or tail region of the circular buffer , the HeadUsrIdx and the TailUsrIdx remain unchanged as 200 and 0\/\u22121.","As a user keeps scrolling down, the circular buffer  may not contain the requested data or records, for example, as shown in  according to one embodiment. Referring to , for example, it is assumed that the user keeps scrolling down and exceed the original bottom of GUI  by 10 records. In this example, GUI  is displaying records associated with indexes from 190 to 210. As a result, the TopUsrIdx and the BottomUsrIdx may be adjusted as 190 and 210. The GUI  may have to request new records from buffer  by asking for records associated with indexes from 201 to 210. The request may be issued record by record, or alternatively, by a chunk of record (e.g., a page of GUI ).","When buffer  receives such requests, buffer  may examine whether the buffer  contains the requested records based on the ReqIdx provided by the request. In one embodiment, the ReqIdx is compared with the HeadUsrIdx and\/or the TailUsrIdx to determine whether the requested record(s) is within the head region and\/or tail region of buffer .","For example, when the GUI  requests for a record associated with a request index as 201 (e.g., ReqIdx=201, also referred to as record ), the buffer  compares the ReqIdx with the HeadUsrIdx and\/or the TailUsrIdx. At this point, the HeadUsrIdx is 200 and the TailUsrIdx is 0\/\u22121 dependent upon a specific implementation. In this example, the ReqIdx is clearly beyond the head region (e.g., ReqIdx>HeadUsrIdx) of buffer . Thus, buffer  does not contain the requested record . As a result, buffer  has to request the requested record from the data file , which may be stored in a server over a network as shown in .","According to one embodiment, if buffer  determines that the requested record is not in the buffer, an application software module associated with the buffer  (simply referred to as herein buffer ) may generate a second thread to a server associated with the data file  (e.g., server  of ) for the requested record (e.g., record ), independent and separated (e.g., asynchronously) from a first thread received from GUI . Dependent upon the traffic condition of the network, since the result of the second thread may take a while, the buffer  may return or terminate the first thread immediately by returning to the client a status or a fake record indicating the requested record is pending. As a result, the GUI  is not held up by a request sent to the server.","In addition, before launching the second thread, buffer  may further examine whether the requested record has been previously requested from the server (e.g., via another thread) and a result of the previous request is still pending. If the result of the previous request is still pending, buffer  may simply return the first thread substantially immediately without launching the second thread. Once the result of the previous request arrives from the server, buffer  may notify GUI  or simply transmit the requested record to GUI . Thereafter, the HeadUsrIdx and TailUsrIdx are adjusted accordingly. The HeadUsrIdx may be adjusted from 200 to 210, while the TailUsrIdx may be adjusted from 0 to 10 or alternatively, remain the same as \u22121, dependent upon the specific implementation.","In a particular embodiment, in order to keep track a previous request, a previous request start index (\u201cRequestedStartIdx\u201d) and a previous request end index (\u201cRequestedEndIdx\u201d) are maintained to store the starting and ending position of the previously requested record(s). According to one embodiment, when it is determined that the ReqIdx is beyond the head region, the ReqIdx may be compared with RequestedStartIdx and RequestedEndIdx to determine whether a previous request that covers the requested record has been made and is still pending. The second thread is launched only if the previous request on the same region has not been made.","Similarly, once the second thread has been launched and is still pending, the RequestedStartIdx and RequestedEndIdx are updated to reflect the pending request to the server to determine whether a subsequent request to the server is needed.","According to a further embodiment, a request sent to the server via the second thread may include additional data or records other than the requested record. The additional records may be requested based on an anticipation of the user's future action. For example, referring to , when the user requests record , it is anticipated that the user may keep scrolling down further in a near future. For example, the request from buffer  to data file  may include additional records (e.g., 20 or 40 additional records). As a result, subsequent requests between buffer  and data file  may be avoided if the subsequent requests from the user are within the requested range and the network traffic between buffer  and the server may be reduced.","Similarly, a user of GUI  may scroll the other direction of the GUI  (e.g., scrolling up). The scrolling up action may be performed from the configuration of  or configuration of . In the examples discussed throughout above, it is assumed that the newest records are placed on the tail region identified by the tail user index TailUsrIdx. When the user of GUI  keeps scrolling up to the top of the GUI , as shown in , further scroll-up operations may cause buffer  to request additional records from the server since buffer  does not contain such records, for example, as shown in .","For example, referring back to , in this example, the GUI  is displaying the newest 20 records maintained by buffer , which is identified by the TailUsrIdx. If the user keeps scrolling up, for example, by 10 more records, buffer  may not contain such scrolled-up 10 more records. As a result, buffer  may have to make a new request (via another thread) to server for such new records. Dependent upon whether the data file  contains any new records since the original requests made by buffer . If there is no new records stored in the data file  since the last request on the same region, the server return a status for such indication.","If the data file contains more newer records since the original request, as shown in , buffer  may retrieve those newer records from the server and the GUI may display the newer records in response to the user's scroll-up action, for example, from the configuration as shown in .","Referring  and A-B, for the illustration purposes, it is assumed that after the initial fetch from the buffer , new records  has been stored in the data file . Meanwhile, the user of GUI  keep scrolling up from the configuration of , for example, by 10 more records up. As a result, the TopUsrIdx and BottomUsrIdx are updated as \u221210 and 10 respectively as shown in . In response, buffer  has to make a new request (via another thread) to data file  from the new records . The new request may request for only the 10 new records . Alternatively, additional records may be requested based on the anticipation or prediction of the user's actions.","After the new request has been received, the HeadUsrIdx and the TailUsrIdx may be updated as 190 and \u221210, which point to positions  and  of data file  respectively, while the previous HeadUsrIdx and the previous TailUsrIdx were pointing to positions  and  respectively. Alternatively, according to another embodiment, when the user scrolls up the GUI , only the TailUsrIdx is updated as \u221210 while the HeadUsrIdx remains unchanged as 200, dependent upon the specific implementation. The actual head of the circular buffer  may be derived from the TailUsrIdx and the size of the circular buffer as follows:\n\nActual Head=TailUsrIdx+Buffer Size\n","According to a further embodiment, a file pointer of the data file  may be adjusted before making a new request for the new records to avoid acquiring duplicated data or records, particularly when the user of GUI  changes the scrolling directions. According to one embodiment, if the current request is in the tail region and if the previous request was in the head region, the file pointer may be adjusted to the position corresponding to the current TailUsrIdx. Likewise, according to another embodiment, if the current request is in the head region and the previous request was in the tail region, the file pointer may be adjusted to a position corresponding to the current HeadUsrIdx.","For example, referring back to , after the initial fetch from the buffer , the file pointer of the data file  may be positioned at position . If the user of GUI  scrolls all the way down and may exceed the BottomUsrIdx, the next fetch from the buffer  to the data file will be from position  and up towards to the top of the data file. As a result, the file pointer which currently pointing at position  (corresponding to the HeadUsrIdx) does not have to be adjusted.","However, if the user keeps scrolling up instead exceeding the TopUsrIdx, for example, by 10 records, referring to , at least additional 10 new records  starting from position  (e.g., the original TailUsrIdx or the original end of file indication) have to be fetched. Since the buffer  already contains 190 records from positions  to , there is no need to refetch these records again. Therefore, according to one embodiment, the file pointer initially pointing to position  may be adjusted to the position  corresponding to the current TailUsrIdx. Thereafter, a new request including the 10 records  may be fetched based on the adjusted file pointer pointing to position . Similar operations may be performed if the current transaction is in the head region and the previous request was in the tail region.",{"@attributes":{"id":"p-0073","num":"0072"},"figref":["FIG. 7","FIG. 7"],"b":["700","701","702","707"]},"Otherwise, if the request index is not within the head index and\/or tail index, at block , the processing logic determines whether a previous request has been made to the server that covers the requested data. In one embodiment, a requested start index (e.g., RequestedStartIdx) and\/or a requested end index (e.g., RequestedEndIdx) may be maintained when the previous request is made. The determination may be performed by comparing the request index with the requested start index and\/or requested end index. If the previous request has not been made, at block , a second thread may be launched to the server for the requested data. Otherwise, at block , the first thread is returned to the client, while waiting for a result of the second thread or a result of the previous request of another thread. Once the result is received, at block , the client is notified or alternatively, the requested data is sent to the client directly. Other operations may also be performed.",{"@attributes":{"id":"p-0075","num":"0074"},"figref":["FIG. 8","FIG. 7"],"b":["800","800","703"]},"Referring to , when a request for a record is received from a client, at block , the processing logic determines whether a request index associated with the request is beyond a tail region of a circular buffer, where the circular buffer includes a head index and a tail index for identifying the head and tail regions. If the request index is beyond the tail region of the circular buffer, at block , the processing logic determines whether a previous request has been made in the head region. In one embodiment, the request index is compared with a requested start index and a requested end index representing the starting and ending positions of the previous request to determine whether the previous request was made in the head region, which are maintained when the previous request was made. If the previous request was made in the head region, at block , a file pointer of the data file stored in the server may be adjusted to a position corresponding to the current tail index of the circular buffer. At block , a second thread is generated to acquire the requested records. Thereafter, at block , the first thread is returned while the second thread is pending. Other operations may also be performed.",{"@attributes":{"id":"p-0077","num":"0076"},"figref":["FIG. 9","FIG. 7"],"b":["900","900","703"]},"Referring to , when a request for a record is received from a client, at block , the processing logic determines whether a request index associated with the request is beyond a head region of a circular buffer, where the circular buffer includes a head index and a tail index for identifying the head and tail regions. If the request index is beyond the head region of the circular buffer, at block , the processing logic determines whether a previous request has been made in the tail region. In one embodiment, the request index is compared with a requested start index and a requested end index representing the starting and ending positions of the previous request to determine whether the previous request was made in the head region, which are maintained when the previous request was made. If the previous request was made in the tail region, at block , a file pointer of the data file stored in the server may be adjusted to a position corresponding to the current head index of the circular buffer. At block , a second thread is generated to acquire the requested records. Thereafter, at block , the first thread is returned while the second thread is pending. Other operations may also be performed.",{"@attributes":{"id":"p-0079","num":"0078"},"figref":["FIG. 10","FIG. 10"],"b":["1000","1001","1002","1002","1006","1005","1005","1007","1006","1002","1005","1006","1002"]},"In one embodiment, client  may include one or more log buffers , which may be circular buffer similar to those described above. Client  may also include a log viewer  including a GUI to view at least a portion of log records maintained by the log buffer(s) . For example, log viewer  may be implemented as GUI  of  and log buffer(s)  may be implemented as buffer  of , while log file(s)  may be implemented as data file(s)  of .","According to one embodiment, similar those described above, in response to receiving a request for a record via a first thread from log viewer , the log circular buffer  determines whether the circular buffer  contains the requested record. If the log circular buffer  contains the requested record, the requested record is returned substantially immediately to the client via the same thread. If the log circular buffer  does not contain the requested record, a second thread may be launched to retrieve the requested record from log file(s) . While a result of the second thread is pending, the log circular buffer  returns the first thread to the client, such that the client would not be held up. Furthermore, before firing the second thread, the log circular buffer determines whether a previous request has been made for the requested record. If the previous request has been made, there is no need to launch the second thread. Instead, the log circular buffer simply returns the first thread and waits for a result of a thread associated with the previous request to return from the server. The first and second threads are executed independently and asynchronously. Once the result of the second thread is returned from the server , the client  is notified.","The operating system running within either the client  and the server  may be a Windows operating system from Microsoft Corporation or a MacOS operating system from Apple Computer. Alternatively, the operating system may be a Unix, a Linux, or an embedded operating system from a variety of vendors. The enterprise engine  may be implemented within a data processing system, such as, for example, exemplary system  of , which will be described in detail further below. Other configurations may exist.",{"@attributes":{"id":"p-0083","num":"0082"},"figref":["FIG. 11","FIG. 11","FIG. 1","FIG. 10"],"b":["1100","101","102","1001","1002"]},"Note that while  illustrates various components of a computer system, it is not intended to represent any particular architecture or manner of interconnecting the components, as such details are not germane to the present invention. It will also be appreciated that network computers, handheld computers, cell phones, and other data processing systems which have fewer components or perhaps more components may also be used with the present invention. The computer system of  may, for example, be a J2EE engine or a .NET framework engine.","As shown in , the computer system , which is a form of a data processing system, includes a bus  which is coupled to a microprocessor  and a ROM , a volatile RAM , and a non-volatile memory . The microprocessor , which may be a PowerPC microprocessor from Motorola, Inc. or IBM, is coupled to cache memory  as shown in the example of . Alternatively, processor  may be a Pentium Processor from Intel Corporation.","The bus  interconnects these various components together and also interconnects these components , , , and  to a display controller and display device , as well as to input\/output (I\/O) devices , which may be mice, keyboards, modems, network interfaces, printers, and other devices which are well-known in the art. Typically, the input\/output devices  are coupled to the system through input\/output controllers .","The volatile RAM  is typically implemented as dynamic RAM (DRAM) which requires power continuously in order to refresh or maintain the data in the memory. The non-volatile memory  is typically a magnetic hard drive, a magnetic optical drive, an optical drive, or a DVD RAM or other type of memory system which maintains data even after power is removed from the system. Typically the non-volatile memory will also be a random access memory, although this is not required. While  shows that the non-volatile memory is a local device coupled directly to the rest of the components in the data processing system, it will be appreciated that the present invention may utilize a non-volatile memory which is remote from the system, such as a network storage device which is coupled to the data processing system through a network interface such as a modem or Ethernet interface. The bus  may include one or more buses connected to each other through various bridges, controllers, and\/or adapters, as is well-known in the art. In one embodiment, the I\/O controller  includes a USB (Universal Serial Bus) adapter for controlling USB peripherals.","According to one embodiment, in response to a request for deploying an enterprise component, a log configuration service (e.g., log configuration service ) may be executed from the memory  to cause processor  to perform logging and tracing configurations illustrated by one or more processes set forth above. Other operations may be performed as well.","Thus, a mechanism for retrieving data over a network using an asynchronous buffer has been described herein. In the foregoing specification, the invention has been described with reference to specific exemplary embodiments thereof. It will be evident that various modifications may be made thereto without departing from the broader spirit and scope of the invention as set forth in the following claims. The specification and drawings are, accordingly, to be regarded in an illustrative sense rather than a restrictive sense."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example and not limitation in the figures of the accompanying drawings in which like references indicate similar elements.",{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIGS. 2A-2D"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIGS. 3A and 3B"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIGS. 4A and 4B"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIGS. 5A and 5B"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIGS. 6A and 6B"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 11"}]},"DETDESC":[{},{}]}
