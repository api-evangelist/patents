---
title: Flexible hierarchical settings registry for operating systems
abstract: Various embodiments include methods and systems provide a distributed settings registry with access protection definable by application developers. Distributed settings registry may be implemented across different technologies with customizable privileges and the dynamic ability to plug different nodes into the registry tree. The settings registry may exist under a registry interface so the applications invoking the registry need not be concerned with where or how the settings data is stored. Each node in the tree of the registry may define its own privilege requirements and storage technology. Nodes may be “native” (i.e., fully supported within the setting registry system software) or “non-native” (i.e., defined by developers for specific applications).
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08667512&OS=08667512&RS=08667512
owner: QUALCOMM Incorporated
number: 08667512
owner_city: San Diego
owner_country: US
publication_date: 20090831
---

{"@attributes":{"id":"description"},"RELAPP":[{},{}],"heading":["RELATED APPLICATIONS","FIELD OF INVENTION","BACKGROUND","DETAILED DESCRIPTION"],"p":["This application claims the benefit of priority to U.S. Provisional Patent Application No. 61\/109,380 entitled \u201cFlexible Hierarchical Settings Registry for Operating Systems\u201d filed Oct. 29, 2008, the entire contents of which are hereby incorporated by reference.","This invention generally relates to computer operating systems, and more particularly to registry systems implemented on operating systems for mobile computing devices.","A registry is a directory for storing settings and options for software operating within an operating system. For example, the Windows\u00ae operating systems by Microsoft Corporation includes a directory file known as the Windows registry which contains the information and settings that are required by hardware, operating system software, and application software, as well as storing user preferences and settings. A registry file serves to locate all program and hardware settings and constant values in a single file structure.","The Windows registry contains two basic elements: keys and values. Registry keys are similar to file folders. In addition to values, each key can contain subkeys which may contain further subkeys. Keys are referenced in a syntax similar to Windows path names using backslashes to indicate levels of hierarchy. Registry values are name\/data pairs stored within keys. Values are referenced separately from keys. In the Windows registry, values can be string values, binary data, unsigned 32-bit integers, UNICODE values, multi-string values, lists and 64-bit integer values (in Windows 2000 and later). The Windows registry is constructed as a database offering database-type functions.","The various embodiments will be described in detail with reference to the accompanying drawings. Wherever possible, the same reference numbers will be used throughout the drawings to refer to the same or like parts. References made to particular examples and implementations are for illustrative purposes, and are not intended to limit the scope of the invention or the claims.","In this description, the terms \u201cexample\u201d and \u201cexemplary\u201d are used to mean \u201cserving as an example, instance, or illustration.\u201d Any implementation described herein as an \u201cexample\u201d or \u201cexemplary\u201d is not necessarily to be construed as preferred or advantageous over other implementations.","As used herein, the terms \u201cmobile handsets\u201d and \u201cmobile devices\u201d are used interchangeably and refer to any one of various cellular telephones, personal data assistants (PDA's), palm-top computers, laptop computers with wireless modems, wireless electronic mail receivers (e.g., the Blackberry\u00ae and Treo\u00ae devices), cellular telephones, and multimedia Internet enabled cellular telephones (e.g., the Blackberry Storm\u00ae), and similar personal electronic devices. A mobile device may include a programmable processor and memory as described more fully below with reference to .","Modern mobile devices can store vast quantities of digital information and users typically use their mobile devices as information and entertainment appliances. Consequently the complexity and sophistication of applications developed for mobile devices now rivals those developed for personal computers. The various embodiments facilitate the development of mobile device applications by providing a flexible settings registry with definable access protection.","The various embodiments provide a distributed settings registry with access protection definable by application developers. Distributed settings registry provides across different technologies with customizable privileges and the dynamic ability to plug different nodes into the registry tree. The settings registry may exist under a registry interface so the applications invoking the registry need not be concerned with where or how the settings values are stored. Each node in the tree of the registry may define its own privilege requirements and storage technology. Nodes may be \u201cnative\u201d (i.e., fully supported within the setting registry system software) or \u201cnon-native\u201d (i.e., defined by developers for specific applications). Settings objects register themselves with the settings registry via the module information file (mif) which is referred to herein as the .mif file.","As is well known, applications resident on mobile devices may be defined by two files; the module information file, with extension .mif, and the module file, with extension .mod. If the application requires settings information, such settings values may be stored within the settings registry for access by the application when it is started or running. As an example, settings may be stored in an initialization file with a .ini file extension. In such an implementation, a developer must provide the .mod file containing the compiled application code, the .mif file containing the compiled module information (including the settings registration information), and the .ini file containing the settings values.","The various embodiments provide an application programming interface (API), sometimes referred to herein as ISettings, and a settings registry implementation of the API, sometimes referred to herein as \u201cSettingsReg,\u201d which enable getting\/setting named keys with string values, support hierarchical key structures, allow enumerating over trees of keys, and support notifications when values change. Data may be stored in the settings registry as text files which simplifies read, write and enumeration operations. An embodiment of the SettingsReg provides two types of functionality, public settings and private settings. Public settings are setting files that an application or component wishes to make available to the rest of the system via a global settings registry. Public settings are generally available to all applications running within the operating system. Private settings are setting files that are available to selectively identified applications, or types or classifications of applications.","The settings registry of the various embodiments utilizes a URI-based settings tree, e.g. \u201c\/path\/to\/a\/setting.\u201d Instead of being a large, monolithic registry such as is the case for the Windows registry, the settings registry of the various embodiments is comprised of several smaller sub-registries provided by any number of modules that simply \u201cplug in\u201d to the top-level registry, where each sub-registry \u201cowns\u201d a specific part of the tree. This structure enables the settings registry to be easy to maintain as each sub-registry manages its own data store in a customizable manner. The structure also allows various types of data storage mechanisms to be scalable as it is easy to add new sub-registries. The structure also provides for definable security as each sub-registry can manage its own privileges convention. Further, the structure supports change notifications across apps\/domains.","The settings registry has the notion of native and non-native data stores. Native stores are those for which the ISetings registry has built-in support. For example, in an embodiment, the settings registry supports .ini file based data stores, which are settings that live in .ini files and are persisted in the extended file systems (EFS), and heap based data stores, which are settings that live in heap memory and are not persisted across power (i.e., system on\/off) cycles. Non-native stores are standalone implementations that use a different storage technology or file type than those supported by native settings object data stores. Developers are free to define non-native settings objects including enforcement of privileges for those objects.","With native stores, components claim ownership of a particular node of the tree in their .mif file, where they also provide some information to the registry about their store (e.g. for a .ini file-based store, the component would specify the store type\u2014in this case .ini-based\u2014and the EFS path to the .ini file). The registry will manage all operations on the data store (in the case of a .ini file, the registry is the only component that ever reads\/writes the file), so there is a separate mechanism, such as a settings access control list (ACL) by which a component may define privileges to allow or deny access to their store. A settings ACL (access control list) works exactly the same as a file system (FS) ACL.","With native stores there is no code to write to define\/manage the store. In a native store, the registry process has the ability to create and interact with the store. A developer can simply register the store in the .mif file and provide the storage media (e.g. an .ini file). In other words modules \u201cregister\u201d themselves with the settings registry via the .mif file. Applications using the store can then use the ISettings interface along with the defined keys to access the data (assuming the application has the privilege to do so). All accesses to individual native settings objects are then performed by a singleton service  (see ). In other words, the same service accesses all native settings objects  are accessed by the same service in a process that is separated by a process boundary from the application ,  and the API ,  called to obtain the information.","Setting data are stored as setting objects. An object generating API, referred to herein as a settings store factory may be used to create a native setting registry object around a particular storage technology. For example, in a first embodiment two settings store factories are provided, one for generating .ini file setting objects, and one for generating heap storage setting objects. As is well known, .ini files are initialization files which are used by applications to store configuration data that is read as the program is starting, and heap storage are files stored in temporary memory which are deleted whenever the mobile device is powered down.","Settings store factories may be used in particular when the information to be stored is to be given limited access, i.e., is \u201cprivate,\u201d with access limited to named applications, or types or families of applications. As used herein, the term \u201cpublic\u201d refers to any setting that is available in the setting registry, regardless of the access privileges, is considered public, and the term \u201cprivate\u201d refers to settings or objects that are created in an application using the factory. In this regard, \u201cprivate\u201d settings refer to an instance of an object that is created in the context of a single application, which is then a \u201cprivate\u201d instance to that application. So if two applications both open the same .ini file using the settings .ini factory, each application now has a private instance of that object (in this case the applications that have access to the file may be defined by some mechanism other than the settings registry, e.g. a file system ACL). When one application makes a change, there may be no way of notifying the other application that a change has occurred. On the other hand, if that .ini file was registered with the settings registry, which makes it \u201cpublic,\u201d then both applications could access the data in that .ini file by going through the settings registry, and when one application makes a change, the other application could be notified. Thus, there may be three classifications of settings objects: public, available to all; public, with limited access; and private.",{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1","b":["2","4"]},"During the generation of the native settings object the developer can also designate whether the object is private or public, as those discussed above. If the developer designates the object as private, the developer may also designate the object's access privileges, i.e., the particular applications or application types that may access the settings object. In example code illustrated in , the line of code \u201cISettings_Get(pSettings, \u2018Genera\/name\u2019, buf, sizeof (buf), NULL)\u201d will return the data stored in the foo.ini file at node \u201cname\u201d, which in this example is \u201cMike.\u201d Such .ini files may be subject to FS ACLs which are privileges specified in the settings object in the form of a list of applications to which the registry system can permit access to the settings value. Privileges can be specified within a settings object such that some settings values within the object are public (i.e., accessible by any application) while other settings values within the same object are private and accessible only by applications or application types identified in the corresponding ACL.","Having generated a native node setting object using the script shown in , a developer can register the object  with the settings registry by implementing the script shown in the .cif file block  in . The .cif file is compiled to generate the .mif file for an application. Thus, the code in block  defines the information that will be present in the .mif file for application \u201cfooApp\u201d which defines the settings object \u201cfoo.ini\u201d that will hold the initialization settings including the word \u201cMike\u201d in the \u201cname\u201d node. The system can enumerate the .mif files stored on the mobile device to determine the key for the settings file. In particular, the .mif file (defined by the code in the .cif file ) needs to define the owner, the key and the file (see the third through fifth lines in block ). Once the object is registered, the information can be accessed by an application by implementing the script shown in block  in .","As mentioned above and as illustrated in , the settings registry implements a singleton service  for accessing all native settings objects . This enables the establishment of a process boundary (illustrated as a dashed line) between the processing of applications ,  and registry ,  (above the dashed line) and the accesses to the settings objects . The native settings access API ,  called by applications ,  need not specify the file location or include specifics related to the file structure implemented with the settings objects; such details are handled by the singleton service .","Non-native stores are data storage mechanisms for which the registry does not have native support (i.e., there is no settings factory provided and the singleton service  is not configured to access the settings object file type). The various embodiments of the settings registry allow non-native stores to install themselves into the tree and handle any operations that occur on the nodes within that tree. Depending on the non-native store implementation, the operations on the store may be performed in-process or across a process boundary.","Like native stores, non-native stores register in their .mif file to \u201cown\u201d a particular node of the tree. The difference is that non-native stores provide a class ID for a custom ISettings class. With non-native stores, the caller first instantiates the registry class. When an operation is made on a key in the tree owned by the non-native store, the custom class is instantiated (assuming the caller has the appropriate privilege) and the operation is delegated to it. In this case, the registry essentially operates as a \u201cpass-through.\u201d Technically, the caller could get the same functionality by instantiating the custom class directly instead of the registry, but using the registry simplifies the usage, especially when the caller is interested in both native and non-native stores.","A developer can register a non-native node by implementing scripts such as the example illustrated in  for the non-native \u201cBMPSettings.\u201d A non-native settings object can be defined in a .cif file such as illustrated in the code in block . The processing for the defined non-native settings object may be implemented by including code such as illustrated in block . Upon instantiation, the registry process in an embodiment (e.g., SettingsReg) builds a list of registered non-native nodes in the system. Once defined and implemented, a non-native settings object can then be accessed within an application by including code similar to that illustrated in block . Upon an access call to a non-native node, the implementation is created and the operation delegated to that implementation.","Since non-native settings objects are defined by developers and thus cannot be handled by the settings registry, their access calls may be handled in-process or across a process boundary, depending on the non-native store implementation. This is illustrated in . When any application ,  calls the settings API ,  for a non-native settings object ,  (e.g., BMPSettings), the API implements the non-native objects access code ,  to obtain the requested information in-process (i.e., within the same process boundary without implementing the registry's singleton service ). In this manner, developers have full freedom to define new settings objects in whatever manner and file type desired for particular applications.","Processing of application calls for settings information under the various embodiments is illustrated in . During initialization (or any other time) an application may request settings information by performing an operation on the settings registry via the ISettings API, step . For example, as illustrated in , the application may access \u201cSettingsReg\u201d via the ISettings API as illustrated in  code block  and , code block . SettingsReg determines whether the requested settings object is to a native or non-native node, test . If the request is for information at a native node (i.e., test =\u201cYes\u201d), SettingsReg passes the operation to the singleton service, step , which accesses the indicated settings object and returns the data to SettingsReg, step . In an embodiment the singleton service may compare the access privileges specified in the called settings object to determine if the calling application is authorized to access the settings information, test . If the calling application does not satisfy the settings object privileges list (i.e., the application or application type does not match the privileges specified in the settings object and thus test =\u201cNo\u201d), the singleton service may return an \u2018access denied\u2019 or similar message to the caller, step . If the calling application satisfies the settings object privileges list (i.e., test =\u201cYes\u201d), SettingsReg then returns the requested data to the application, step . However, if the request is for information at a non-native node (i.e., test =\u201cNo\u201d), the SettingsReg creates the setting object for the called non-native node in-process by passing the operation to the non-native ISettings implementation, step , which returns the requested data, step . SettingsReg then returns the requested data to the application, step .","Developers can use the various embodiments to simplify the development of applications. The following paragraphs describe steps and example code that developers can include in applications to implement the various embodiments of setting registry.","In order to differentiate the sub-registries at the root level of the registry, each must have a unique string identifier. This simplest way to achieve this is to require a class ID, e.g.","\u201c\/\u02dc0x12345678\/foo\/ . . . \u201d<- - - settings sub-registry for component 1","\u201c\/\u02dc0xdeadbeef\/bar\/ . . . \u201d<- - - settings sub-registry for component 2","However, class IDs are not required; more human-readable Uniform Resource Identifiers (URIs) are allowed as well, though care must be taken to avoid overlap. If overlap occurs, the behavior may be undefined.","\u201c\/component1\/foo\/ . . . \u201d","\u201c\/component2\/bar\/ . . . \u201d","Private settings are settings that are available to an application or component on a per-instance basis. These settings are not exposed to any other component in the system. The ISettings support for private settings simply provides a convenient mechanism for organizing settings.","Private settings are created using a factory. The caller specifies some information about the medium from which to create the settings and the factory returns an ISettings object that can be used to access the settings.","For private settings, no modification to the .mif file is required. The component simply uses the factory to create the ISettings object of interest at run time.","In an embodiment, the settings registry includes factories that return ISettings objects which do not support the ISettings_OnChange( )method.","To add a public store of a public .ini file developers can perform the following steps to add and access a public .ini file-based settings store to their component. First developers can copy the following into a file called mysettings.ini and place it into their component's module directory in EFS:\n\n","Second, developers can register the store with the system by adding the following to the component's .cif file using script such as:",{"@attributes":{"id":"p-0049","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"local s = require \u2018SettingsCIFHelpers\u2019"]},{"entry":[{},"-- register the settings at \u201c\/myApp\/myIniSettings\/...\u201d"]},{"entry":[{},"s:RegisterIniFile {"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"\u2003\u2003\u2003owner = 0x12345678,","-- class ID of the component"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003key = \u201c\/myApp\/myIniSettings\u201d,"]},{"entry":[{},"\u2003\u2003\u2003file = \u201cmysettings.ini\u201d,"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"98pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"\u2003\u2003\u2003acls = { . . . }","-- optional"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]}]}}]}}},"Third, developers can, optionally, define ACLs to allow other apps access to the settings:",{"@attributes":{"id":"p-0051","num":"0052"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"acls = {"},{"entry":"\u2003\u2003\u2003{\u2003\u2003 -- grant everyone read access to my settings but write"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003-- access to only those modules belonging to the"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u20030xdeadd00d group "},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003groups = { 0},"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003perms = \u201cr\/r\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003},"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003groups = { 0xdeadd00d},"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003perms = \u201crw\/rw\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003},"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003path = \u201c\/myApp\/myIniSettings\u201d"},{"entry":"\u2003\u2003\u2003},"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Fourth, developers can use the following code within an application to access the setting:",{"@attributes":{"id":"p-0053","num":"0054"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003ISettings *piSettings = NULL;"]},{"entry":[{},"\u2003\u2003\u2003if (SUCCESS == IEnv_CreateInstance(piEnv,"]},{"entry":[{},"AEECLSID_SettingsReg, (void**) &piSettings)) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003char outbuf[ 32];"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003int result;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003result = ISettings_Get("]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003piSettings,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201c\/myApp\/myIniSettings\/section1\/setting1\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003outbuf,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003sizeof(buf),"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003NULL"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003if (SUCCESS == result) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ outbuf will contain \u201cvalue1\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003ISettings_Release (piSettings);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003pSettings = NULL;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"The steps that developers take to add and access a public heap-based settings store to a component is very similar to the .ini file-based store. The main difference is the absence of the .ini file. Instead, heap-based settings require a quota value that determines the maximum amount of heap that may be used by the store. First, developers may register the store with the system by adding the following to a component's .cif file:",{"@attributes":{"id":"p-0055","num":"0056"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"local s = require \u2018SettingsCIFHelpers\u2019"]},{"entry":[{},"-- register my settings at \u201c\/myApp\/myHeapSettings\/...\u201d"]},{"entry":[{},"s:RegisterHeap {"]},{"entry":[{},"\u2003\u2003\u2003owner = 0x12345678, \u2003\u2003-- class ID of my component"]},{"entry":[{},"\u2003\u2003\u2003key = \u201c\/myApp\/myHeapSettings\u201d,"]},{"entry":[{},"\u2003\u2003\u2003quota = 0x1000,"]},{"entry":[{},"\u2003\u2003\u2003acls = { ... }"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Optionally developers may define ACLs to allow other apps access to their settings as follows:",{"@attributes":{"id":"p-0057","num":"0058"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"acls = {"},{"entry":"\u2003\u2003\u2003{ -- grant everyone read access to my settings but write access to"},{"entry":"\u2003\u2003\u2003\u2002 -- only those modules belonging to the 0xdeadd00d group"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003groups = { 0},"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003perms = \u201cr\/r\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003},"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003{"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003groups = { 0xdeadd00d},"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003perms = \u201crw\/rw\u201d,"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003},"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003path = \u201c\/myApp\/myHeapSettings\u201d"},{"entry":"\u2003\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"Third, developers can use the following code within an application to access setting. Note that a heap-based setting does not exist until ISettings_Set( ) is called on it.",{"@attributes":{"id":"p-0059","num":"0060"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003ISettings *piSettings = NULL;"]},{"entry":[{},"\u2003\u2003\u2003if (SUCCESS == IEnv_CreateInstance(piEnv,"]},{"entry":[{},"AEECLSID_SettingsReg, (void**) &piSettings)) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003char outbuf[ 32];"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003int result;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003(void) ISettings_Set(piSettings,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u201c\/myApp\/myIniSettings\/foo\u201d, \u201cbar\u201d);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003result = ISettings_Get("]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003piSettings,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201c\/myApp\/myIniSettings\/foo\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003outbuf,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003sizeof(buf),"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003NULL"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003if (SUCCESS == result) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ outbuf will contain \u201cbar\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003ISettings_Release (piSettings);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003pSettings = NULL;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In an embodiment developers can define a custom setting for an application that is public (i.e., accessible by all allocations) by perform the following to add a custom ISettings implementation into the settings registry: First, developers write a component that implements the embodiment registry. Second, developers register the component with the system by adding the following to the component's .cif file:",{"@attributes":{"id":"p-0061","num":"0062"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"local s = require \u2018SettingsCIFHelpers'"]},{"entry":[{},"s:RegisterClass {"]},{"entry":[{},"\u2003\u2003\u2003class = 0xdeadbeef,"]},{"entry":[{},"\u2003\u2003\u2003key = \u201c\/myApp\/myCustomSettings\u201d,"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Next, developers use the following code in the application to access the setting. Note that any ISettings operations performed on the registry class will be delegated to the custom class.",{"@attributes":{"id":"p-0063","num":"0064"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003ISettings *piSettings = NULL;"]},{"entry":[{},"\u2003\u2003\u2003if (SUCCESS == IEnv_CreateInstance(piEnv,"]},{"entry":[{},"AEECLSID_SettingsReg, (void**) &piSettings)) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003int nChildren = 0; int result;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003result = ISettings_GetNumChildren(piSettings,"]},{"entry":[{},"\u201c\/myApp\/myCustomSettings\u201d, &nChildren);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003if (SUCCESS == result) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ do something"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003ISettings_Release (piSettings);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003pSettings = NULL;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In an embodiment developers can define a private .ini file setting store for an application (i.e., accessible only be allocations specifically given permission to access the file) by perform the following. First developers copy the following into a file called mysettings.ini and place it into the component's module directory in EFS:\n\n","Second, developers include the following code in the application to enable it to access the setting:",{"@attributes":{"id":"p-0066","num":"0069"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003ISettingsStoreFactory *piSSF = NULL;"]},{"entry":[{},"\u2003\u2003\u2003if (SUCCESS == IEnv_CreateInstance(piEnv,"]},{"entry":[{},"AEECLSID_SettingsIniFactory, (void**) &piSSF)) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003ISettings *piSettings = NULL;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003int result;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003result = ISettingsStoreFactory_Create("]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003piSSF,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cowner=0x12345678,path=mysettings.ini\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003&piSettings"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003if (SUCCESS == result) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003char outbuf[ 32];"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003result = ISettings_Get("]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003piSettings,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201csection1\/setting1\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003outbuf,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003sizeof(buf),"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003NULL"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (SUCCESS == result) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ outbuf will contain \u201cvalue1\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ISettings_Release (piSettings);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003pSettings = NULL;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003ISettingsStoreFactory_Release (piSSF);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003piSSF = NULL;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"Note that unlike public settings, access to the private store does not require the prefix \u201c\/myApp\/myIniSettings\u201d.","The steps that developers take to implement a private heap-based settings store in an application component are very similar to the .ini file-based store except that there is no reference to an .ini file. Instead, heap-based settings require a quota value that determines the maximum amount of heap storage that may be used by the store. Developers can use the following code in an application to access the setting. Note that a heap-based setting does not exist until ISettings_Set( )is called on it.",{"@attributes":{"id":"p-0069","num":"0072"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"{"]},{"entry":[{},"\u2003\u2003\u2003ISettingsStoreFactory *piSSF = NULL;"]},{"entry":[{},"\u2003\u2003\u2003if (SUCCESS == IEnv_CreateInstance(piEnv,"]},{"entry":[{},"AEECLSID_SettingsHeapFactory, (void**) &piSSF)) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003ISettings *piSettings = NULL;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003int result;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003result = ISettingsStoreFactory_Create("]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003piSSF,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cquota=0x1000\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003&piSettings"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003if (SUCCESS == result) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003char outbuf[ 32];"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003(void) ISettings_Set(piSettings, \u201cfoo\/bar\u201d,"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u201cHello world\u201d);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003result = ISettings_Get(piSettings, \u201cfoo\/bar\u201d,"]},{"entry":[{},"outbuf, sizeof(buf), NULL);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003if (SUCCESS == result) {"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ outbuf will contain \u201cHello world\u201d"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003ISettings_Release (piSettings);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003pSettings = NULL;"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003}"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003ISettingsStoreFactory_Release (piSSF);"]},{"entry":[{},"\u2003\u2003\u2003\u2003\u2003\u2003piSSF = NULL;"]},{"entry":[{},"\u2003\u2003\u2003}"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}}}},"In an embodiment developers can define a private custom setting store by performing the following to access a custom ISettings implementation. First, developers write a component that implements ISettings. Second, developers include the following code in an application to access the private custom setting.",{"@attributes":{"id":"p-0071","num":"0074"},"tables":{"@attributes":{"id":"TABLE-US-00011","num":"00011"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"{"},{"entry":"\u2003\u2003\u2003ISettings *piSettings = NULL;"},{"entry":"\u2003\u2003\u2003if (SUCCESS == IEnv_CreateInstance(piEnv, <classid>, (void**)"},{"entry":"&piSettings)) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003int nChildren = 0;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003int result;"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003result = ISettings_GetNumChildren(piSettings,"},{"entry":"\u201c\/path\/to\/my\/settings\u201d, &nChildren);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003if (SUCCESS == result) {"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\u2003\/\/ do something }"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003ISettings_Release (piSettings);"},{"entry":"\u2003\u2003\u2003\u2003\u2003\u2003pSettings = NULL;"},{"entry":"\u2003\u2003\u2003}"},{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}}}},"The embodiments described above may be implemented on any of a variety of mobile devices, such as, for example, cellular telephones, personal data assistants (PDA) with cellular telephone, mobile electronic mail receivers, mobile web access devices, and other processor equipped devices that may be developed in the future. In addition, the embodiments described above may be implemented on any of a variety of computing devices, including but not limited to desktop and laptop computers.  depicts various components of a mobile device  capable of supporting the various embodiments disclosed herein. A typical mobile handset  includes a processor  coupled to internal memory  and a user interface display . The mobile handset  may include an antenna  for sending and receiving electromagnetic radiation that is connected to a wireless data link and\/or cellular telephone transceiver  coupled to the processor . In some implementations, the transceiver , and portions of the processor  and memory  used for cellular telephone communications are referred to as the air interface since the combination provides a data interface via a wireless data link. Mobile handsets typically include a key pad  and menu selection buttons or rocker switches  for receiving user inputs.","The processor  may be any programmable microprocessor, microcomputer or multiple processor chip or chips that can be configured by software instructions (applications) to perform a variety of functions, including the functions of the various embodiments described above. In some mobile devices, multiple processors  may be provided, such as one processor dedicated to wireless communication functions and one processor dedicated to running other applications. Typically, software applications may be stored in the internal memory  before they are accessed and loaded into the processor . In some mobile devices, the processor  may include internal memory sufficient to store the application software instructions. For the purposes of this description, the term memory refers to all memory accessible by the processor , including internal memory  and memory within the processor  itself. The memory  may be volatile or nonvolatile memory, such as flash memory, or a mixture of both.","The hardware used to implement the foregoing embodiments may be processing elements and memory elements configured to execute a set of instructions, wherein the set of instructions are for performing method steps corresponding to the above methods. Alternatively, some steps or methods may be performed by circuitry that is specific to a given function.","Those of skill in the art will appreciate that the various illustrative logical blocks, modules, circuits, and algorithm steps described in connection with the embodiments disclosed herein may be implemented as electronic hardware, computer software, or combinations of both. To clearly illustrate this interchangeability of hardware and software, various illustrative components, blocks, modules, circuits, and steps have been described above generally in terms of their functionality. Whether such functionality is implemented as hardware or software depends upon the particular application and design constraints imposed on the overall system. Skilled artisans may implement the described functionality in varying ways for each particular application, but such implementation decisions should not be interpreted as causing a departure from the scope of the present invention.","The steps of a method or algorithm described in connection with the embodiments disclosed herein may be embodied directly in hardware, in a software module executed by a processor, or in a combination of the two. The software module may reside in a processor readable storage medium and\/or processor readable memory both of which may be any of RAM memory, flash memory, ROM memory, EPROM memory, EEPROM memory, registers, hard disk, a removable disk, a CD-ROM, or any other tangible form of data storage medium known in the art. Moreover, the processor readable memory may comprise more than one memory chip, memory internal to the processor chip, in separate memory chips, and combinations of different types of memory such as flash memory and RAM memory. References herein to the memory of a mobile handset are intended to encompass any one or all memory modules within the mobile handset without limitation to a particular configuration, type or packaging. An exemplary storage medium is coupled to a processor in either the mobile handset or the theme server such that the processor can read information from, and write information to, the storage medium. In the alternative, the storage medium may be integral to the processor. The processor and the storage medium may reside in an ASIC.","The foregoing description of the various embodiments is provided to enable any person skilled in the art to make or use the present invention. Various modifications to these embodiments will be readily apparent to those skilled in the art, and the generic principles defined herein may be applied to other embodiments without departing from the spirit or scope of the invention. Thus, the present invention is not intended to be limited to the embodiments shown herein, and instead the claims should be accorded the widest scope consistent with the principles and novel features disclosed herein."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The accompanying drawings, which are incorporated herein and constitute part of this specification, illustrate exemplary embodiments of the invention, and, together with the general description given above and the detailed description given below, serve to explain features of the invention.",{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 7"}]},"DETDESC":[{},{}]}
