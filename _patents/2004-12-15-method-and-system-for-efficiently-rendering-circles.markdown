---
title: Method and system for efficiently rendering circles
abstract: A graphics processor method and system for rendering a circle. The method includes the step of accessing an instruction to render a circle. A square is defined using at least one graphics primitive, and a circle is defined within the square, wherein a center of the circle corresponds to a center of the square and wherein a radius of the circle is defined by a width of the square. The circle is rasterized into at least one pixel and a coverage value is determined for each pixel of the circle by comparing a distance from the pixel to the center of the circle with the radius of the circle. Each pixel is then shaded in accordance with the coverage value.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09105113&OS=09105113&RS=09105113
owner: NVIDIA CORPORATION
number: 09105113
owner_city: Santa Clara
owner_country: US
publication_date: 20041215
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION","Embodiments of the Invention"],"p":["This application is related to the commonly assigned U.S. Pat. No. 7,081,902 entitled APPARATUS, SYSTEM, AND METHOD FOR GAMMA CORRECTION OF SMOOTHED PRIMITIVES, by Crow et al., filed on Sep. 24, 2003, which is incorporated herein in its entirety.","The present invention is generally related to hardware accelerated graphics computer systems.","Recent advances in computer performance have enabled graphic systems to provide more realistic graphical images using personal computers and home video game computers. In such graphic systems, a number of procedures are executed to \u201crender\u201d or draw graphic primitives to the screen of the system. A \u201cgraphic primitive\u201d is a basic component of a graphic picture, such as a vertex, polygon, or the like. All graphic pictures are formed with combinations of these graphic primitives. Many procedures may be utilized to perform graphic primitive rendering.","Specialized graphics processing units (e.g., GPUs, etc.) have been developed to optimize the computations required in executing the graphics rendering procedures. The GPUs are configured for high-speed operation and typically incorporate one or more rendering pipelines. Generally, a typical GPU's rendering pipeline comprises a number of hardware-based functional units that are optimized for high-speed execution of graphics instructions\/data, where instructions are fed into the front end of the pipeline and the computed results emerge at the bottom of the pipeline.","Graphics processing is typically performed using graphics application program interfaces (API's) that provide a standard software interface that can be run on multiple platforms, operating systems, and hardware. Examples of graphics API's include the Open Graphics Library (OpenGL\u00ae) and D3D\u2122. In general, such open graphics application programs include a predetermined, standardized set of commands that are executed by associated graphics pipeline hardware. For example, in a computer system that supports the OpenGL\u00ae standard, the operating system and application software programs can make calls according to that standard without knowing any of the specifics regarding the system hardware. Application writers can use graphics APIs to design the visual aspects of their applications without concern as to how their commands will be implemented.","Graphics APIs are particularly beneficial when they are supported by dedicated graphics hardware. To improve graphics processing performance and overall graphics rendering speed, it is desirable that a large percentage of the graphics processing work is performed by the hardware of a graphics pipeline as opposed to software. For example, for high performance, graphics processing should be executed in hardware, wherein large portions of the processing work is executed on a per clock basis. In comparison, software can take hundreds of clock cycles to perform some graphics processing operations. For example, modern GPUs are designed and configured to rapidly and accurately process graphics commands with little impact on other computer system resources.","Problems exist, however, in those cases where graphics commands of the graphics API do not map efficiently to the functions and capabilities of a given GPU architecture. For example, Open GL includes a high level command that instructs the graphics hardware to render a circle (e.g., draw a filled circle at some location on screen, having some color\/texture, etc.) to represent an antialiased point. Conventionally, the GPU's driver (e.g., software routines which interface with the hardware functionality of the GPU) has to perform a number of time consuming tasks in order to draw the specified circle.","In one prior art method for rendering an API requested circle, the specified circle is approximated with geometric primitives (e.g., polygons). This method is problematic due to the fact that polygon approximation adds a considerable amount of geometric primitives (e.g., triangles) to the graphics data stream. This would cause a considerable amount of additional work. In another prior art method, as opposed using a plurality of polygons to model a circle, a square (e.g., quadrilateral, two triangles, etc.) is defined and a texture is mapped onto the square. The texture is the image of a circle. For example, the texture mapped area within the circle is opaque and the area outside the circle is transparent. This solution is problematic due to the fact that pixels within the area that is outside the circle (e.g., in the corners of the square) must still be rasterized and shaded. This causes a significant amount of wasted work and overhead. Additionally, this solution consumes a certain amount of texture memory to store the picture of the circle. With both methods, the resulting circle should be anti-aliased in order to preserve the quality of the rendered image.","Another problem with both of the above conventional methods is the fact that the interpreting of the API request for the circle and the translation of this request into the graphics commands for the GPU causes an excessive amount of software branching. The excessive amount of software interpretation and branching tends to bog down the GPU pipeline until the constituent software can be executed. For example, for a typical application, a large number of graphics instructions execute rapidly (e.g., on a per clock basis), hence a graphics data stream can be efficiently processed by the GPU, with the GPU moving through the graphics data stream on a per clock basis until the OpenGL circle request is encountered, whereupon an exception is caused, and the software for handling the specified circle is invoked. There are a large number of conditions and parameters the software must set up. The setup process consumes multiple cycles, and imposes an excessive amount of software execution overhead on the driver. The exception can thus bog down the GPU pipeline for hundreds of clock cycles or more. Thus, what is needed is a more efficient way to render circles requested by a graphics API.","Embodiments of the present invention provide a method and system for efficiently rendering circles request by a graphics API using the hardware of a graphics processor unit (GPU). Embodiments of the present invention provide fast and efficient GPU hardware rendering support for graphics API instructions that specify circles of varying sizes, positions, colors, etc.","In one embodiment, the present invention is implemented as a circle rendering method supported by the hardware of a GPU of a computer system. The method includes the step of accessing an instruction to render a circle. This instruction is typically a graphics API instruction (e.g., OpenGL) received from an application executing on the computer system. In response to the instruction, a square is defined using at least one graphics primitive (e.g., quadrilateral), and a circle is defined within the square. Alternatively, the square can be defined using two triangle polygons. The center of the circle corresponds to the center of the square and the diameter, and thereby the radius, of the circle is defined by the width of the square. The circle is rasterized into pixels and a coverage value is determined for each pixel of the circle by comparing a distance from the pixel to the center of the circle with the radius of the circle. This comparison determines which pixels are within the circle and which pixels are partially covered by the circle. Each pixel is then shaded in accordance with the coverage value.","In one embodiment, the GPU accesses a lookup table by using the difference comparison (e.g., the distance from the pixel to the center of the circle and the radius of the circle). A corresponding coverage value is read from the lookup table, and each pixel is shaded in accordance with the coverage value to render a smooth anti-aliased edge of the circle. In one embodiment, the rendering includes blending a partially covered pixel with a background pixel, with a respective weight of the partially covered pixel and the background pixel assigned in accordance with the coverage value.","Reference will now be made in detail to the preferred embodiments of the present invention, examples of which are illustrated in the accompanying drawings. While the invention will be described in conjunction with the preferred embodiments, it will be understood that they are not intended to limit the invention to these embodiments. On the contrary, the invention is intended to cover alternatives, modifications and equivalents, which may be included within the spirit and scope of the invention as defined by the appended claims. Furthermore, in the following detailed description of embodiments of the present invention, numerous specific details are set forth in order to provide a thorough understanding of the present invention. However, it will be recognized by one of ordinary skill in the art that the present invention may be practiced without these specific details. In other instances, well-known methods, procedures, components, and circuits have not been described in detail as not to unnecessarily obscure aspects of the embodiments of the present invention.","Notation and Nomenclature:","Some portions of the detailed descriptions, which follow, are presented in terms of procedures, steps, logic blocks, processing, and other symbolic representations of operations on data bits within a computer memory. These descriptions and representations are the means used by those skilled in the data processing arts to most effectively convey the substance of their work to others skilled in the art. A procedure, computer executed step, logic block, process, etc., is here, and generally, conceived to be a self-consistent sequence of steps or instructions leading to a desired result. The steps are those requiring physical manipulations of physical quantities. Usually, though not necessarily, these quantities take the form of electrical or magnetic signals capable of being stored, transferred, combined, compared, and otherwise manipulated in a computer system. It has proven convenient at times, principally for reasons of common usage, to refer to these signals as bits, values, elements, symbols, characters, terms, numbers, or the like.","It should be borne in mind, however, that all of these and similar terms are to be associated with the appropriate physical quantities and are merely convenient labels applied to these quantities. Unless specifically stated otherwise as apparent from the following discussions, it is appreciated that throughout the present invention, discussions utilizing terms such as \u201cprocessing\u201d or \u201caccessing\u201d or \u201cexecuting\u201d or \u201cstoring\u201d or \u201crendering\u201d or the like, refer to the action and processes of a computer system (e.g., computer system  of ), or similar electronic computing device, that manipulates and transforms data represented as physical (electronic) quantities within the computer system's registers and memories into other data similarly represented as physical quantities within the computer system memories or registers or other such information storage, transmission or display devices.","Computer System Platform:",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1","b":["100","100","100","100","100"]},"In general, computer system  comprises at least one CPU  coupled to a system memory  and at least one graphics processor unit (GPU)  via one or more busses as shown. Access to the system memory  is implemented by a memory controller . The GPU  is coupled to a display . System  can be implemented as, for example, a desktop computer system or server computer system, having a powerful general-purpose CPU  coupled to a dedicated graphics rendering GPU . In such an embodiment, components would be included that are designed to add peripheral buses, specialized graphics memory and system memory, IO devices, and the like.","It should be appreciated that although the GPU  is depicted in  as a discrete component, the GPU  can be implemented as a discrete graphics card designed to couple to the computer system via a graphics port (e.g., AGP port, PCI Express port, or the like), as a discrete integrated circuit die (e.g., mounted directly on the motherboard), or as an integrated GPU included within the integrated circuit die of a computer system chipset component (e.g., integrated within a Northbridge chip). Additionally, a local graphics memory can be included for the GPU  (e.g., for high bandwidth graphics data storage). It should be noted that although the memory controller  is depicted as a discrete component, the memory controller  can be implemented as an integrated memory controller within a different component (e.g., within the CPU , GPU , etc.) of the computer system . Similarly, system  can be implemented as a set-top video game console device such as, for example, the Xbox\u00ae, available from Microsoft Corporation of Redmond, Wash.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":["FIG. 2","FIG. 2"],"b":["110","110","110"]},"GPU  includes a geometry processor  to generate primitives and a rasterizer  to rasterize primitives, e.g., to convert points, lines, and polygons to fragments, each fragment corresponding to a single pixel of a frame buffer (e.g., frame buffer ). It should be noted that the frame buffer  can be implemented in a local graphics memory, in system memory (e.g., system memory ), or the like. A pixel coverage processor  determines the coverage value of fragments of the primitive with respect to a pixel grid. Pixel coverage processor  may, for example, use a sampling technique to sample points within each pixel, determine a coverage value based on the angle of the primitive with respect to the pixel grid, or other algorithms known in the art to calculate a coverage value by estimating the overlap of a fragment with an individual pixel.","An anti-aliasing (AA) lookup table  is used to obtain blending weights for a smooth blending processing. For example, in one embodiment, the lookup table  is indexed using the coverage value determined by the pixel coverage processor  and the corresponding blending weight is retrieved. Lookup table  may be stored as a single table or as sub-tables for each color. In one embodiment, lookup table  is stored in a memory of GPU  to permit the graphics hardware of GPU  to facilitate high-bandwidth, low latency access.","A square root lookup table  is used to determine square roots of terms used in computing dimensions of graphics primitives. For example, the square root table  can be used to compute Euclidean distances between points of interest in a 3D scene or between pixels and different graphics primitives.","A blending processor  uses the blending weight corresponding to the pixel coverage value (e.g., from pixel coverage processor  and lookup table ) to determine weights used to blend partially-covered pixels with background pixels stored in the frame buffer  during an anti-aliasing process. Such a blending process allows the representation of partially covered pixels and permits the apparent position of edges of circles, lines, dots, polygons, and the like, to be controlled to sub-pixel precision.","Referring still to , embodiments of the present invention provide a method and system for efficiently rendering circles requested by a graphics API using the hardware of a GPU, or analogous type of graphics processor. In so doing, embodiments of the present invention provide fast and efficient GPU hardware rendering support for graphics API instructions that specify circles of varying sizes, positions, colors, etc.","In one embodiment, the GPU  receives, or otherwise accesses, an instruction to render a circle. This instruction is typically a graphics API instruction (e.g., OpenGL) received from an application executing on the computer system (e.g., computer system  of ). In response to the instruction, a square is defined using one or more graphics primitives. For example, a single quadrilateral can be used to define the square, or two triangles can be used.","The circle is defined within the parameters of the square. For example, the center of the circle (e.g., in x,y coordinates) corresponds to the center of the square and the diameter of the circle is defined by the width (e.g., in x direction or y direction) of the square. Inherently, one half the diameter of the circle is the circle's radius.","The circle is then rasterized (e.g., by the raster processor ) into pixels and a coverage value is determined for each pixel of the circle. This coverage value is determined by comparing a distance (e.g., Euclidean distance) from the pixel to the center of the circle with the radius of the circle. This comparison determines which pixels are within the circle and which pixels are partially covered by the circle. Each pixel is then shaded in accordance with the coverage value.","In one embodiment, the GPU accesses the lookup table  by using the difference comparison (e.g., the Euclidean distance from the pixel to the center of the circle and the radius of the circle). A blending weight corresponding to a coverage value is read from the lookup table, and each pixel is shaded in accordance with the blending weight to render a smooth anti-aliased edge of the circle. In one embodiment, the rendering includes blending (e.g., using the blending processor ) a partially covered pixel with a background pixel, with the respective weights of the partially covered pixel and the background pixel assigned in accordance with the coverage value.","In this manner, embodiments of the present invention provide fast and efficient hardware support for rendering circles as requested by graphics API instructions. The rendering performance of the present invention is much greater than prior art methods. This is due in part to the fact that a conventional polygon engine must use either geometry (e.g., triangles, quadrilaterals, etc.) to approximate points and filled circles, or add a transparent texture to a square to give the effect of a filled circle. Such approximation adds a considerable amount of extra geometry, and texturing requires those parts of the square that are not covered by the filled circle be rasterized and shaded. Furthermore, texturing consumes a certain amount of texture memory. In contrast, embodiments of the present invention use the same edge structure that would describe a square to draw filled circles. This edge structure facilitates a neat fit into a graphics pipeline architecture without requiring substantial changes the rest of the pipeline's hardware, imposes minimal additional overhead, and consumes no texture memory.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 3","b":["301","302","301","303","302","301","301","110","240","302","301","301"]},"Similarly, the axis-aligned distance (e.g., x distance or y distance) to the center  is given by the difference to opposing edges of the bounding square , divided by 2. At the center , the distances are equal so their difference is zero. At one of the bounding edges, the difference is equal to the diameter so half is equal to the radius (e.g., the distance to the center ). The sign of the difference is inconsequential since this value is squared before use.","In one embodiment, the \u201ctrue distance\u201d (e.g., Euclidean distance) to the center  is found by squaring the axis-aligned distances and taking the square root of the sum of the results. In one embodiment, the squares and square root can be determined efficiently by a table lookup (e.g., using square root lookup table ) since high precision is not necessary in such operations.",{"@attributes":{"id":"p-0040","num":"0039"},"figref":"FIG. 4","b":["302","240","302","302"]},"In one embodiment, sample positions within a pixel may be used to determine what portion of the pixel is inside or outside the circle. In those implementations where GPU hardware exists for computing sample positions within a pixel, the slope and position of an edge of the circle  through the pixel may be computed from the x and y distances used to compute the \u201ctrue distance\u201d to the center . This edge may then be used to compute the samples.","In one embodiment, an OpenGL-compatible smooth (e.g., anti-aliased) edge for the circle  can be rendered. In this embodiment, a smooth edge which rolls off correctly at the circle boundary can be computed by using a threshold to determine when the pixel is within a \u201croll-off zone\u201d around the circle's edge. By subtracting the radius at the inside of the roll-off zone from the true distance and using a lookup table (e.g., the lookup table ) to control the roll-off profile, a smooth circle edge is obtained. In such an implementation, the lookup table  comprises a coverage lookup table or an antialiasing lookup table.","For example, in one embodiment, for each pixel covered by the circle , the pixel coverage processor  indexes the lookup table  using the difference between the true distance and the radius for each pixel. A corresponding coverage value is read from the lookup table, and each pixel is shaded in accordance with the coverage value to render a smooth anti-aliased edge of the circle. In this manner, the coverage value read from the lookup table  corresponds to a blending weight. Using this blending weight, the color of a partially covered pixel is blended with the color of a background pixel. Thus, in a case where the circle  is completely black and the background color is completely white, pixel  would be dark gray, pixel  would be medium gray, and pixel  would be light gray.",{"@attributes":{"id":"p-0044","num":"0043"},"figref":["FIG. 5","FIG. 5","FIG. 5"],"b":["250","501"]},"In one embodiment, to represent circles less than one pixel in diameter, coverage values for a one-pixel circle are computed then scaled by the pixel size. Accordingly, a circle of diameter one-half pixel should have \u00bc the coverage of a one-pixel circle. This allows smaller circles to fade out gracefully instead of popping on or off. A linear fade wherein a circle of one-half pixel in diameter has half the coverage of a one-pixel circle is also effective, if not as correct.","In one embodiment, the square root table  is extended to a wider range by shifting large values back to within the range of the table and then shifting up the results half as far. This allows the square root table  to cover a much wider range by gracefully degrading precision as the numbers increase in magnitude.","In one embodiment, larger circles can be drawn by a method configured to take advantage of the fact that high precision is typically required only near the edge of the circle. For example, in those cases where a large circle is needed, the cost of a square root table (e.g., in memory) and the time taken to access it (e.g., in processor cycles) can be prohibitive. In such cases, an alternative method can be used which avoids use of the square root table.","In one embodiment, the square root table  is avoided by taking advantage of a property of the difference of two squares. In such an embodiment, only the squares of the radius and distance to the circle are used in operation, which are easier to calculate. For example, in a case where r and d are the radius and distance to the center of the circle respectively, it should be noted that r\u2212d=(r+d)(r\u2212d). Thus, r\u2212d=(r\u2212d)\/(r+d). The value of r\u2212d needs to be found in order to determine how close to the edge of the circle a given pixel is. Near the edge of the circle r and d are near equal. Generally, precise comparisons are only needed near the edge of the circle, and this property can be used to approximate r+d with 2*r, which is constant for the entire circle. Now the difference between the true distance and the radius for each pixel is given by (r\u2212d)\/(2*r). This difference is then used to obtain the blending weight for the pixel. The value of rneeds to be calculated only once for each circle, as does 2*r. A low-precision divide can be used since typically only a few bits of precision are needed to determine a coverage level for each pixel. Additionally, only a low-precision calculation of dis needed for each pixel since typically only the first few significant digits matter.","In one embodiment, a low-precision divide is realized by deleting the leading zeroes in the divisor, shifting the quotient down by the same number of bits then using a lookup table to compute the reciprocal of the next few bits of the divisor. A quick short multiply then yields an adequate approximation to the difference of r and d.","In one embodiment, the methods above can be used to draw anti-aliased circles both filled, and as curved lines. For filled circles, all pixels are treated as fully covered where d is less than r. For curved lines, the coverage lookup table  is used on the absolute difference so that pixels where d is less than r are treated just as pixels where d is greater than r. The thickness of the line can be adjusted by a threshold or by adjusting the values stored in the coverage lookup table .","Additional descriptions of the use of a lookup table to render smooth anti-aliased pixels can be found in commonly assigned U.S. Pat. No. 7,081,902 entitled APPARATUS, SYSTEM, AND METHOD FOR GAMMA CORRECTION OF SMOOTHED PRIMITIVES, by Crow et al., filed on Sep. 24, 2003, which is incorporated herein in its entirety.","In this manner, embodiments of the present invention provided advantages in that their implementation fits within an existing polygon rasterizing pipeline with insubstantial changes to the rest of the pipeline. No information about the circle (e.g., radius, center point, etc.) need be transmitted down the pipeline as this is all recovered from the conventional edge descriptions of the square. The precision of the arithmetic used, and thus the silicon area required for its implementation, can be determined by the size limits on the circles to be drawn in the case of those embodiments using the square root table, or determined by the precision desired for those embodiments using the \u201cdifference of squares\u201d and can therefore be quite small.","Additionally, including circle-drawing hardware within the GPU  allows a number of functions for conversion of circles to triangles, textured squares, or other intermediate forms to be deleted from the software supporting the hardware functions, making for a simpler complete system when ready for the end user. The software simplification eliminates many of the expensive (e.g., GPU clock cycle intensive) set up instructions required for rendering circles, which reduces the amount of software branching in a graphics data stream. The reduced amount of software interpretation and branching reduces bottlenecks in the GPU pipeline and helps the graphics instructions execute rapidly (e.g., on a per clock basis)."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The present invention is illustrated by way of example, and not by way of limitation, in the Figures of the accompanying drawings and in which like reference numerals refer to similar elements.",{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 5"}]},"DETDESC":[{},{}]}
