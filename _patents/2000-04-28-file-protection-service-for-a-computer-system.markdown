---
title: File protection service for a computer system
abstract: A method and system that protects selected system and other files, by preventing changes to those files. In an asynchronous alternative, the change is prevented by copying back the original file when a protected file is changed, as known via an asynchronous notification. In an alternative synchronous embodiment, the change to the file is prevented from occurring. In the asynchronous notification alternative, a directory change notification notifies a file protection service whenever a file that has possibly changed is closed, providing the file identity as part of the notification. The file protection service determines from the file identify whether the file has been deemed protected. If protected, the file protection service prevents any actual change by verifying whether the protected file changed, such as by analyzing the file's contents against known valid contents. If not valid, the file protection service restores a saved copy that is itself verified.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=06971018&OS=06971018&RS=06971018
owner: Microsoft Corporation
number: 06971018
owner_city: Redmond
owner_country: US
publication_date: 20000428
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION OF THE INVENTION"],"p":["The invention relates generally to computer systems, and more particularly to files stored on a computer system.","In contemporary operating systems such as Microsoft\u00ae Corporation's Windows\u00ae operating systems, applications rely on system files, including those in the form of dynamic link libraries (DLLs) or the like, for various features and\/or application programming interfaces (APIs). To ensure that an operating system is stable, the operating system code and system files are exhaustively tested, debugged and verified, resulting in particular versions of system files known to be highly stable. Those particular versions of system files are then shipped with the operating system.","However, because applications rely on system files, of which hundreds of thousands may be available, applications often ship versions of system files (e.g., DLLs) therewith that the application is known to work with, often because the application vendor has no idea as to what operating system the application will be installed under. Installing application software thus results in the installation of various versions of operating system DLLs and executables to a user's computer, some of which may be incompatible with the operating system and\/or other applications on the system. This mismatched set of components causes an unknown and unreliable state to exist on the user's computer, a problem often referred to in the industry as \u201cDLL Hell.\u201d","By way of example, consider a user who installs an operating system such as Windows\u00ae 2000 on a given computer, and later starts browsing the web with that computer. While browsing the web, an interesting software application is found, downloaded to the computer, and then installed. However, during the installation, the application installer replaces the known, stable copy of MSVCRT.DLL that is in the user's system directory, with an earlier, or possibly later (and thus possibly untested), version. In many instances, the copy of the DLL that is installed is not fully compatible with the operating system and\/or other applications already installed on the user's computer.","As a result, the user's computer will sometimes fail and =become less reliable, both in the operating system and in applications. One solution has been to use versioning techniques for system files, e.g., never copy over a higher-numbered version of a DLL. However, this has its own drawbacks, because version stamping is often done incorrectly, e.g., the versions are not properly identified in the DLLs relative to other versions. Moreover, for proper operation, providing new versions requires that those versions are backwards compatible, which even when it could be done correctly, is very difficult to get anyone to put into practice. Removing the application that is suspected of having made a system unstable does not eliminate this problem, and often the user's only recourse to an unstable system is to reinstall the operating system, and sometimes reinstall some of the applications.","Some systems prevent upgrading of system files by using file system security to prevent modification. This falls short because typically, the administrator (or power user) is the person installing the new application, which means that the user is allowed to modify the files. Also, system upgrades\/patches are more difficult, since the security prevents correct and desired modifications of system files.","Briefly, the present invention provides a method and system that protect selected system and other files, by preventing changes to those files. In one embodiment, the change is prevented by copying back the original file when a protected file is changed, as known via an asynchronous notification. In an alternative embodiment, the change to the file is detected before it occurs, i.e., synchronously, whereby the original file can be preserved, or the change can be prevented from occurring.","More particularly, in the asynchronous notification alternative, a directory change notification mechanism is instructed to watch a set of one or more specified directories. The directory change notification mechanism notifies a file protection service whenever a file that has possibly changed is closed, providing the filename as part of the notification. The file protection service determines whether the file is protected, such as by looking for the filename (e.g., a hash thereof) in a data structure maintaining filename information of protected files. If protected, the file protection service prevents any actual change by verifying (e.g., via a verification mechanism) whether the protected file changed. To this end, the verification mechanism may call a cryptographic API, which makes a determination by analyzing the file's content signature against known good contents, e.g., by comparing a cryptographic hash of the file contents against a catalog of known valid file hashes, and returning information as to whether the new file is verified as valid. Note that as used herein the phrase \u201cnot valid\u201d or the like does not necessarily mean that a file is bad or will cause problems, only that it has not been verified, and if installed may lead to an unstable system. If not a valid change, the file protection service restores a saved copy (that is itself verified) from one of a number of possible sources, e.g., an on-disk cache, a network share, an operating system CD, and so forth.","Exceptions are provided to enable certain critical protected files to be replaced when necessary, and to allow other, \u201cless-protected\u201d files to be changed. For example, a critical system file that needs to be replaced can have its information added to the catalog, whereby it will be verified as valid after the file is written and closed. Less protected files, such as certain third party software drivers, may be allowed to be changed by the user, which may include first notifying the user via a warning prompt or the like and receiving user approval. For security, signatures may be required to allow such exceptions to be implemented. A scan utility is described which enables a user to restore such changed files to a set of protected files that are known to be good.","In the other alternative, referred to herein as a synchronous alternative, changes to a protected file are detected by the operating system (including, but not limited to, file system component, security component, or filter drivers) before they occur and one of several actions may take place. First, the original file may be saved to a separate, protected location and the change allowed to proceed. Upon subsequent user direction or by rules implemented in the file protection service, this saved version may be returned to the original location. Second, the change may be temporarily kept (e.g., via a copy-on-write process). Depending on user selection and\/or other rules, the temporarily maintained change may be discarded, leaving the original version intact, or the change may be copied over the original. In cases where the original file is left intact, (or restored from a preserved location), a success status indication may be returned to the application so that it believes its change was made when it was not. Alternatively, a failure status indication may be returned to the application. This will cause the application install to fail, and notify the user of this problem.","One way to achieve this failure action is to use a security component. For example, the security descriptors of protected files may be marked in a special way, requiring the application process to have a specific capability enabled before a change is allowed. Any application that attempts direct modification of the files will not have this capability enabled, and the security system will reject the modification. For the application to successfully modify the file, a new system service may be provided that performs the cryptographic verification, e.g., in the operating system kernel. If the verification succeeds, the capability is enabled, the system service (not the application) performs the modification, and then the capability is disabled before control is returned to the application.","Other advantages will become apparent from the following detailed description when taken in conjunction with the drawings, in which:","Exemplary Operating Environment",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 1"},"Moreover, those skilled in the art will appreciate that the invention may be practiced with other computer system configurations, including hand-held devices, multi-processor systems, microprocessor-based or programmable consumer electronics, network PCs, minicomputers, mainframe computers and the like. The invention may also be practiced in distributed computing environments where tasks are performed by remote processing devices that are linked through a communications network. In a distributed computing environment, program modules may be located in both local and remote memory storage devices.","With reference to , an exemplary system for implementing the invention includes a general purpose computing device in the form of a conventional personal computer  or the like, including a processing unit , a system memory , and a system bus  that couples various system components including the system memory to the processing unit . The system bus  may be any of several types of bus structures including a memory bus or memory controller, a peripheral bus, and a local bus using any of a variety of bus architectures. The system memory includes read-only memory (ROM)  and random access memory (RAM) . A basic input\/output system  (BIOS), containing the basic routines that help to transfer information between elements within the personal computer , such as during start-up, is stored in ROM . The personal computer  may further include a hard disk drive  for reading from and writing to a hard disk, not shown, a magnetic disk drive  for reading from or writing to a removable magnetic disk , and an optical disk drive  for reading from or writing to a removable optical disk  such as a CD-ROM or other optical media. The hard disk drive , magnetic disk drive , and optical disk drive  are connected to the system bus  by a hard disk drive interface , a magnetic disk drive interface , and an optical drive interface , respectively. The drives and their associated computer-readable media provide non-volatile storage of computer readable instructions, data structures, program modules and other data for the personal computer . Although the exemplary environment described herein employs a hard disk, a removable magnetic disk  and a removable optical disk , it should be appreciated by those skilled in the art that other types of computer readable media which can store data that is accessible by a computer, such as magnetic cassettes, flash memory cards, digital video disks, Bernoulli cartridges, random access memories (RAMs), read-only memories (ROMs) and the like may also be used in the exemplary operating environment.","A number of program modules may be stored on the hard disk, magnetic disk , optical disk , ROM  or RAM , including an operating system  (such as Microsoft Corporation's Windows\u00ae 2000, formerly Windows NT\u00ae, operating system). The computer  includes a file system  associated with or included within the operating system , such as the Windows NT\u00ae File System (NTFS), one or more application programs , other program modules  and program data . A user may enter commands and information into the personal computer  through input devices such as a keyboard  and pointing device . Other input devices (not shown) may include a microphone, joystick, game pad, satellite dish, scanner or the like. These and other input devices are often connected to the processing unit  through a serial port interface  that is coupled to the system bus, but may be connected by other interfaces, such as a parallel port, game port or universal serial bus (USB). A monitor  or other type of display device is also connected to the system bus  via an interface, such as a video adapter . In addition to the monitor , personal computers typically include other peripheral output devices (not shown), such as speakers and printers.","The personal computer  may operate in a networked environment using logical connections to one or more remote computers, such as a remote computer . The remote computer  may be another personal computer, a server, a router, a network PC, a peer device or other common network node, and typically includes many or all of the elements described above relative to the personal computer , although only a memory storage device  has been illustrated in . The logical connections depicted in  include a local area network (LAN)  and a wide area network (WAN) . Such networking environments are commonplace in offices, enterprise-wide computer networks, Intranets and the Internet.","When used in a LAN networking environment, the personal computer  is connected to the local network  through a network interface or adapter . When used in a WAN networking environment, the personal computer  typically includes a modem  or other means for establishing communications over the wide area network , such as the Internet. The modem , which may be internal or external, is connected to the system bus  via the serial port interface . In a networked environment, program modules depicted relative to the personal computer , or portions thereof, may be stored in the remote memory storage device. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers may be used.","The present invention is primarily described herein with respect to the Windows\u00ae 2000 (formerly Windows\u00ae NT\u00ae) operating system and the protection of system files, including DLLS. However, as can be readily appreciated, the present invention is not limited to any particular operating system or files, but rather may be used with any operating system, and moreover, has many uses in general computing.","File Protection","Turning to  of the drawings, there is shown a file protection service  for protecting selected files in accordance with an aspect of the present invention. In general, the files that are protected comprise critical system files and other important files such as drivers, although as will be understood below, there is no reason that virtually any file may not be similarly protected. To protect the files, the file protection service  maintains a list or the like identifying the files that are to be protected, in an in-memory data structure . For performance reasons, the data structure  is loaded into memory from persistent storage (as indicated by the dashed box in the file storage  ), and is preferably arranged as a balanced binary tree that is optimized for lookup. In one embodiment, the tree includes hashed filenames. As can be appreciated, the tree can be arranged in many ways, such as numerically, alphabetically, by frequency of hits, or some other way that tends to increase lookup speed.","A change notification mechanism  is provided, in general, to monitor files for changes thereto. In one implementation, the change notification mechanism  returns a name of a changed file to the file protection service  on the close of that file. One such mechanism is a Windows\u00ae 2000 operating system feature known as \u201cdirectory watch,\u201d which when given a set of one or more directories or directory trees, watches any corresponding file system volumes for possible changes to files therein, and provides a notification including the filename on such a change, at the close of the file.","In the case in which filenames are returned, the in-memory data structure  includes a corresponding list of hashed filenames identifying the protected files, for fast hash-based lookup. In alternative implementations, a change notification mechanism may return a system-unique file identifier or the like, whereby the data structure  would instead include file identifiers of protected files, or some hash thereof. Note that the change notification mechanism  is preferably narrowed in its watch scope so as to only watch certain directories, (or possibly even only certain files), whereby every file that is changed on a given system does not result in a notification and resultant search of the data structure . It is alternatively feasible to provide an attribute or the like with the file that indicates that the file is protected, whereby the file system, for example, may provide the notification, or even run the protection mechanism software. However, the asynchronous service described herein which leverages the existing directory watch feature, operates upon notifications and is independent of any given file system, and thus can work with the Windows NT\u00ae filesystem (NTFS), the FAT file system, and so forth, even when multiple file systems are present on a given computer system.","As will be described below, there are certain instances when a protected file may be validly changed, in which case the file protection mechanism will not put back the original protected file that was copied over (in the asynchronous alternative), or will allow (i.e., not prevent) the change (in the synchronous alternative). A verification mechanism , in conjunction with a set of cryptographic APIs  are provided to make this determination. Note that the verification mechanism  may be incorporated into the cryptographic API mechanism , or may place calls to it. A suitable cryptographic mechanism including a cryptographic application program interface is described in U.S. Pat. No. 5,689,565, herein incorporated by reference.","Prior to releasing a version of an operating system, a determination is made for each file released therewith as to whether that file is protected. The identities of these files are stored in the data structure . Also, a file signature mechanism or the like hashes each file, for example via a hash algorithm such as SHA1 or MD5, cryptographically encodes it into a unique (or essentially unique) signature, and stores the signature in a catalog file  released with the operating system and maintained in the system file storage  upon installation of the operating system, along with the protected files  and other files.","In accordance with one aspect of the present invention, when a protected file has been changed (or in the synchronous alternative, may be changed), the file protection service  communicates with the verify mechanism  (e.g., WinVerifyTrust) and the cryptographic API set  to determine whether a change is valid. In general, the file contents including any possibly changed data is cryptographically hashed into a unique signature, and sent to the cryptographic APIs  to request whether the signature is valid. The cryptographic API set  looks up the signature in the catalog file, and returns information as to whether the signature matches one that is known to be valid. In the asynchronous case, if valid, the data is left alone, while if invalid, a copy of what is believed to be valid is located. If (following a similar signature verification) the located copy is valid, the copy is copied over the changed file data, thereby restoring the protected file.","To restore a protected file that has been copied over, in one embodiment, the file protection service  first attempts to locate the file in a cache  of operating system files. The cache  of all (or at least most) operating system files is normally stored in file storage , and is maintained up-to-date, e.g., files are replaced in the cache  as well as in other locations as needed, such as when fixes are downloaded to the system. Although normally local and thus generally treated as a local cache  herein, there is no reason that a cache  may not be maintained remotely and accessed via a network connection. The cache  size is dependent on the amount of available disk space, (i.e., it has a quota), and the data in the cache  is considered volatile. As a result, because the cache  is volatile and accessible by the user, the user, system or some other party can replace the files therein, delete the cache  or selected files therein, and so forth. Because of this, a copy of a protected file may not be present, and even if present, is not trusted. Thus, if found, the found copy is similarly verified via the signature process before it can be copied back to the set of protected files .","If the protected copy found in the cache  is not valid, or was not in the cache , the file protection service  looks elsewhere for a copy. If the copy was installed from a network share , the file protection service  looks to the network share , e.g., via an API call or the like that provides access to the network share  through a network interface . Again, the copy at the network share  may have since changed, so if found, the copy of the protected file is verified via the verification mechanism\/cryptographic API set . If valid, the network share copy of the protected file is used to restore the pre-changed state of the system.","If the installation was not from a network or if the protected copy found in the network share  is not valid or was not found, the file protection service  continues by looking to a local media reader  (via its interface ) for a copy, such as a CD-ROM, DVD-ROM or the like. Again, this may be accomplished via an API call or the like. The file protection service will prompt for the media if not found, via a user interface . Again, any located copy is verified as valid in the above-described manner before it is restored. If a valid copy of the file cannot be found, the user can cancel the restoration of the file via the user interface , whereby the user preferably will be warned via a further prompt that the system is now considered unstable.","In the synchronous case, the (possibly) changed file data is separately saved to a separate, protected location, such as preserved via a copy-on-write process, and then either used or discarded depending on whether the change is allowed or prevented by the file protection service. Alternatively, the original file can be copied to a separate, protected location, the change allowed to occur, and the original copy restored from the separate, protected location, or discarded if not restored. The data is similarly cryptographically hashed (e.g., when the file is closed) and sent to the cryptographic API mechanism . If determined to be valid thereby, the file protection service  causes the new file data, which has been separately preserved via the copy-on-write process, to be written to the file. If not valid, the copy-on-write data is discarded. Whether kept or discarded, however, the entity requesting the change, e.g., a setup mechanism such as a setup installer (SETUP API) , may be told that the copy succeeded (e.g., via a returned errorcode). In this manner, the file protection service  operates transparently with respect to the setup mechanism . Alternatively, a failure may be returned. Note that in the synchronous case, the original, valid copy may not be overwritten, (unless another valid copy is allowed to overwrite it), or, if overwritten, the valid copy is first preserved in a known, secure location, and thus there is no need to access the cache , network share and\/or media player for a valid copy.","One time that a new\/different valid copy of a protected file is allowed to be installed is when an important fix or upgrade to a protected system file or the like is necessary. Such a fix\/upgrade also should have been thoroughly tested before being released, and thus should be known to be relatively stable. In any event, the cryptographic API set may be called (with a proper manufacturer's signature for security purposes) to add a new cryptographic hash signature for the new protected file as a new catalog, whereby it will be considered valid when it is installed. Note that the file protection service  would otherwise copy over or alternatively reject such a change. Further, note that the hash is added as a new catalog, whereby both the previous and new versions are considered valid, however it is feasible to replace an existing hash with a new hash.","For certain files, a policy is set on systems to block replacement thereof, (to the extent possible, i.e., in the asynchronous case, replacement occurs only when the valid file cannot be found and the user cancels a request for it), unless another valid file is replacing it, as known via the catalog . Further, note that the cryptographic API mechanism  that checks for a manufacturer's signature before allowing the addition to the catalog  can be configured such that only one certain signature can make such a change, whereby, for example, an operating system vendor can control which files are considered valid. Alternatively, the cryptographic API mechanism  can be extended to accept one of a plurality of acceptable signatures when adding a file's cryptographic hash signature to the catalog , whereby multiple parties can enable the change of protected files.","Another time that a new\/different valid copy of a protected file may be installed is when the file is a third party driver or the like. Such files are not part of the operating system, but are protected by the file protection service. Indeed, to be part of the protected file set  when the operating system ships, the drivers also undergo thorough testing to ensure a stable system. However, there are times when such a driver needs to be replaced\/upgraded, before it undergoes the thorough testing necessary to have its cryptographic hash added to the catalog file as a known valid file. For example, the driver manufacturer may need to load an upgraded driver to test it, as will the testing programs\/mechanisms that will test that version of the driver to ultimately determine whether it is considered sufficiently stable to be valid. The replacement of such a \u201cless-protected\u201d file is thus allowed rather than prevented by the file protection service , however a warning prompt first may be issued, dependent on code signing policies . For example, files in certain device classes should not ordinarily be changed without first having been verified as stable, (e.g., by a verifying entity), and a warning may be issued before replacing these files even if the policy had been set to ignore such warnings. However, classes of files that are not verifiable may not receive such a warning if their policy is set to ignore such changes, although in one implementation, a warning always occurs. The installation of a driver and driver signing policies are controlled by a driver installer  (), as described in more detail below.","Because it is possible for a user to override the file protection service , such as when installing a less-protected driver, or when the cache , network share (if any) or media does not have a valid copy of a file, it is possible for a system to become unstable. In keeping with the present invention, there is thus provided a scan utility  as generally represented in . In general, when run, which may be on demand, in a background process, and\/or on a schedule, the scan utility  will cause each protected file to be checked against the known valid file information stored in the catalog file . One way this may occur is to access each protected file in the set  thereof in file storage , which will cause the above-described mechanism to automatically perform the check. Another way is to have the utility  place a certain call or the like to the file protection service , which can walk a list of protected files calling the verification mechanism \/cryptographic APIs for each one and restoring when necessary. The scan utility also may be run after initial installation, for example, automatically after a manufacturer configures a machine with an operating system and its applications (as part of a system preparation process).",{"@attributes":{"id":"p-0040","num":"0039"},"figref":["FIG. 3","FIG. 3"],"b":["60","60","102","102","102","70","70","102","60","104","70"]},"As represented in , the session manager  uses the file protection service for a deferred rename operation. More particularly, contemporary operating systems allow a file that is in use to be replaced on a subsequent session, via a deferred rename operation. For example, a core operating system DLL will always be in use, and without this mechanism cannot otherwise be replaced. To this end, a new version of a file gets saved, and the operating system notes (e.g., in a registry) that the file should be replaced the next time possible, i.e., on the next re-boot when the session manager  is started. One of the session manager's first tasks is to process any such delayed renames that are listed. However, before it does this, it checks the list of protected files (e.g., in the data structure  or equivalent that it can load), and denies any change to a protected file. Note that the session manager  cannot call the crypto-APIs  at this time to verify the new file's signature, as the crypto-APIs  are not loaded at this time. To replace such a file via the session manager , a special flag may be set, in which case the session manager  will allow the change. Note that this flag is hidden and protected by the operating system vendor for security reasons, since there is no reason that such core operating system files should ever be changed without knowledge the operating system vendor.","A backup\/restore mechanism  similarly needs to work with the file protection service , otherwise the system state cannot be restored. To this end, a file protection service API or the like may be provided, which when called, returns information as to whether a specified filename is a protected system file that needs to be restored by the backup\/restore mechanism  in order to properly restore the state. Thus, on backup, the file protection service API is called to determine the protected system files. On restore, the restore mechanism needs to restore the catalog  before it can restore the protected system files. Note that the backup mechanism can save the names of the protected system files, whereby the restore mechanism does not have to call the API to determine which files are protected.","The setup installer  (SETUPAPI) includes a device installer , which is a plug and play (PNP) component that is responsible for installing the software responsible for supporting a given device. For example, files that need to be copied, registry modifications, interactions with the plug and play manager component are controlled by the device installer , which also controls driver signing policies. As described below, certain protected classes of driver files are generally an exception, i.e., are \u201cless-protected\u201d than other protected system files, to allow their installation (following a warning) even though protected.","Turning to an explanation of the present invention with particular reference to the flow diagrams of ,  describe the operation of the various components described above to perform file protection in the asynchronous notification alternative in accordance with the present invention. Beginning at step  of , the asynchronous notification is received at the file protection service  from the notification mechanism  when a protected file is changed in some way and then closed, such as after having been opened for read-write access, renamed or deleted. The notification includes the name of the file that changed. Note that in the case of renaming or deletion, the original file copy may be simply restored if one is found that is valid, e.g., there is no new file to check for validity and thus a valid copy is put back, e.g., via , described below. Thus, rather than focus on the rename or delete of a file, the case of a known valid copy having been (possibly) changed by a new copy is generally described hereinafter.","At step , the filename is hashed (although it could have been hashed by the notification mechanism ), and the internal data structure  searched for a matching entry to determine whether the file is protected. If no match is found, the file is not protected, and step  branches to step  where the new file is considered successfully copied and the process ends for this notification. As described above, the search of a balanced binary tree optimized for lookup based on hashed data is very fast on average. As can be readily appreciated, the file protection service thus operates rapidly for non-protected files, which facilitates system performance.","If at step  a protected file is identified as having been (possibly) changed, step  branches to step  wherein a determination is made as to whether the file is one that the file protection service previously had been specifically instructed to let be changed, e.g., is a driver being installed by the device installation mechanism  (of the setup installer API ). Step  is described below. If not, at step  a cryptographic hash is computed for the new file, e.g., by calling an appropriate one of the cryptographic APIs . At step , this information is provided to the verify mechanism  (which may be an API of the cryptographic API set ) to test whether the computed hash corresponds to a known good hash stored in the catalog . For example, the computed hash (or a pointer thereto) may be passed as a parameter in an API call, whereby the cryptographic APIs  search the catalog file for a match, and return a yes or no answer on whether a match is found. If the catalog had a match, step  branches to step  allow the copy to remain. Alternatively, if at step  the computed hash does not correspond to a known good hash stored in the catalog , step  branches to step .","If at step  the file has a signature, step  branches to step  to allow the copy. Otherwise, the new copy should be replaced with a known, verified-as-valid copy, whereby the process continues to  to attempt to restore a verified copy, as described below.","Returning to the situation at step  where the file is one that is specifically allowed to be changed by a call, e.g., is a driver being installed by the SETUPAPI , step  is next executed. More particularly, any time that an unsigned driver package is being installed, (i.e., by the SETUPAPI), and one of the constituent files about to be copied is a protected file, then the user is given a warning prompt (policy is elevated to \u201cWarn\u201d) by SETUPAPI to confirm with the user that installation of unsigned files is actually desired. Note that the user may already have been given this warning, if the device installation was in a certifiable class whose default policy is already \u201cWarn.\u201d If the user elects to proceed, then SETUPAPI calls the file protection mechanism to tell it to allow the next (unsigned) replacement of this file. Note that if the user does not elect replacement, SETUPAPI will simply not make the initial copy, whereby there is no change and thus no notification for such a file. Alternatively, the file protection service may provide such prompts and allow the user to decide how to proceed. If the file protection process has not been told to ignore the particular file at step , the file protection process will branch to step  as described above.","At step , in one alternative implementation, only trusted components such as SETUPAPI will be allowed to make a call to let a file be allowed to be changed. Note that in one present implementation, steps  does not exist, i.e., any component can make such a call. Step  represents the successful copying of the new file, i.e., the new file is left as is in the asynchronous case (no restoration takes place).",{"@attributes":{"id":"p-0050","num":"0049"},"figref":["FIG. 5","FIG. 4","FIG. 6","FIG. 6"],"b":["500","78","500","600","78","502","506","506","510","506","72","508","508","510","600"]},{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 6","FIG. 4","FIG. 7","FIG. 2","FIG. 7"],"b":["78","600","600","700","602","80","602","600","700"]},"If the original network sharepoint  is available at step , (and thus a copy of the file is ordinarily found), the file is verified to determine its validity via steps \u2013, i.e., the file is tested to determine if the cryptographic hash of its contents matches a valid entry in the catalog . If there is no match, the known valid file is further tested to determine whether it is physically signed at step . If the catalog did not have a match at step , nor was the file physically signed at step , the process continues to step  of  to look for the file on media.","If the network share copy of the file matched at step  or was itself signed (i.e., the file contained the signature instead of the catalog) at step , then the copy is known to be valid, and is copied to the system's (e.g., local) cache , if the cache  quota permits. Then, step  returns to step  of  to copy the file from the cache  to the file's correct final location, to restore the system to a known stable state. Note that copying it once from the network sharepoint  to the cache , and then from the cache  to the correct is faster than copying both from the network share. Further, note that if the cache quota does not allow the copy, the valid network share file can be directly copied to the file's final location to overwrite the changed file and restore the system to a known stable state.",{"@attributes":{"id":"p-0054","num":"0053"},"figref":["FIG. 7","FIG. 4"],"b":["700","84","700","714","716","700","718","718"]},"If at step  the correct media is present, steps \u2013 verify that the file copy is valid, i.e., its cryptographic hash is calculated and compared with the catalog  as described above. If it does not match, step  branches to step  to request another medium be inserted to attempt to find a valid copy, possibly varying the prompt slightly to inform the user that the version on the particular medium is not the correct one. Steps  and  (and if appropriate step ) generally operate as described above.","If the media copy of the file matched at step , then the copy is known to be valid, and is copied to the system's (e.g., local) cache  at step , if the cache  quota permits. Then, step  continues to step  to copy the file from the media to the file's correct final location, to restore the system to a known stable state. Note that often the file could also be copied from the cache , but the cache may not have a copy based on its quota, and copying from the media is relatively fast, so it is straightforward to copy from the media twice.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":"FIGS. 8\u20139"},"Such synchronous notification may be accomplished via a filter driver, which for example in the Windows\u00ae 2000 operating system is a driver in a stack of drivers that can intercept I\/O request packets (IRPs) to the file system to allow, deny or modify requested file operations based on type of operation requested and whether a file (identified in the IRP) is protected. However, it is also possible and somewhat more desirable to build file protection into (or closely coordinate file protection with) the file system.","Step \u2013 of  primarily describes a file protection service that is external to the file system but is closely coordinated therewith, e.g., the service can make callbacks thereto and the file system holds operations (at least for some time) until the callback instructs the file system as to what action to take. However, the IRP model and file system with a built-in file protection service will also be described herein.  also describe the copy-on-write process, (as the alternative of preserving the file when synchronous notification of a change about to occur is received is similar to , except that the original file is first preserved in a secure location, and if necessary, restored from that location instead of via ).","Beginning at step  of , a directory change notification is received by the file protection service  when a file is opened, e.g., for read-write access, before a file is changed. Note that a delete or rename operation may be similarly detected and a notification sent to the file protection mechanism , which can callback to the file system to fail the requested operation if the file is protected. This straightforward operation is thus is not described herein for purposes of simplicity.","Alternatively, if the file protection service  is implemented as a filter driver in the stack, instead of receiving a notification, the file protection service  can intercept IRPs to the file system, analyze the information therein, and decide whether to allow the IRP, modify the IRP or send back the IRP with failure information therein based on the requested operation and the file name (or a cached handle). The interception can be in either direction, i.e., on the way to the file system, or on the return therefrom with possibly another IRP sent to the file system by the file protection service. Thus, renames and deletes IRPs on protected files can be failed, while, as described below, writes to protected files can be subject to a copy-on-write process that preserves the writes but does not change the file, until a decision is made to either change the file or discard the change data at the time of file closing.","Step  represents the search of the binary tree structure  for whether the file to be changed is a protected file. If not as evaluated at step , the file change is allowed (or IRP passed intact) at step . Otherwise, a copy-on-write process is turned on for writes to this file as represented by step . In an alternative implementation, instead of performing the copy-on-write, the original file may be copied to a separate, secure location, whereby the change can take place but be restored directly from that location without needing to search the cache, network and\/or CD-ROM and verify the data.","Note that if the file protection service  is built into the file system, and a file attribute identifies which files are protected, steps \u2013 may be eliminated, as the file system will immediately know which files are protected. If an attribute is not used, but the file protection service  is built into the file system, there is no need for a notification at step , and the file system will perform the search at step .","If copy-on-write is turned on at step , the general logic of  is executed, e.g., at the time of file closing, to determine what to do with the copied data, i.e., whether it should be kept or whether it should be discarded. At step , a determination is made as to whether the file is one that the file protection service previously had been specifically instructed to let be changed, e.g., is a driver being installed by the setup API , as described above. If not, at step  a cryptographic hash is computed for the new file, e.g., by calling an appropriate one of the cryptographic APIs . At step , this information is provided to the verify mechanism  (which may be an API of the cryptographic API set ) to test whether the computed hash corresponds to a known good hash stored in the catalog . If the catalog had a match, step  branches to step  to determine whether the user should be prompted before allowing the copy as described below. Alternatively, if at step  the computed hash does not correspond to a known good hash stored in the catalog , step  branches to step .","If at step  the file has a signature, step  branches to step  to keep the new data. Otherwise, the new data that was copy-on-written is discarded (step ), and the file installation application (or other process) is provided with a result via step .","In cases where the original file is left intact, or restored, a success status indication may be returned as the result to the application at step  so that it believes its change was made, when it was not. Alternatively, a failure status indication may be returned to the application. This will normally cause the application install to fail, and notify the user of this problem.","One way to achieve this failure action is to use the security component. For example, the security descriptors of protected files may be marked in a special way, requiring the application process to have a specific capability enabled before a change is allowed. Any application that attempts direct modification of the files will not have this capability enabled, and the security system will reject the modification. For the application to successfully modify the file, a new system service may be provided that performs the cryptographic verification, e.g., in the operating system kernel. If the verification succeeds, the capability is enabled, the system service (not the application) performs the modification, and then the capability is disabled before control is returned to the application.","Returning to the situation at step  where the file is a specifically identified file for which installation should be allowed, optional step  is reached, which if present evaluates whether the component that requested the change is trusted. If so, step  branches to step , which represents the copy-on-write data being kept. For example, the file system can accomplish this by manipulating metadata or copying the file allocation units (e.g., clusters) of the new data that were copy-on-written over the old. If not trusted, the file protection process will discard the copy-on-write data at step .","Note that the synchronous and asynchronous models can both exist on a given system. For example, the asynchronous model may be used for FAT file system volumes, while the synchronous model may be used with NTFS file system volumes, which can be mixed on one system.","As can be seen from the foregoing, there is provided a method and system that protect the stability of a computer system by protecting selected system files from being changed. The method and system are fast, reliable and extensible, and do not rely on other parties, e.g., to get versioning and backwards compatibility requirements correct.","While the invention is susceptible to various modifications and alternative constructions, certain illustrated embodiments thereof are shown in the drawings and have been described above in detail. It should be understood, however, that there is no intention to limit the invention to the specific form or forms disclosed, but on the contrary, the intention is to cover all modifications, alternative constructions, and equivalents falling within the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0017","num":"0016"},"figref":"FIGS. 4\u20137"},{"@attributes":{"id":"p-0018","num":"0017"},"figref":"FIGS. 8\u20139"}]},"DETDESC":[{},{}]}
