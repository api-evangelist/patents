---
title: System and methods for generating and managing a virtual device
abstract: Embodiments of the present disclosure may be configured to permit development and validation of a device driver or a device application program by using improved virtual devices. Such improved virtual devices may facilitate driver development without use of physical devices or hardware prototypes. In various embodiments, advanced validation of a device-driver combination may be permitted that would be difficult to achieve even with a physical device. Certain embodiments also may detect inconsistencies between virtual and physical devices, which may be used to improve drivers and device application programs and increase compatibility of such drivers and device application programs with physical devices.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=09152540&OS=09152540&RS=09152540
owner: Oregon State Board of Higher Education on Behalf of Portland State University
number: 09152540
owner_city: Portland
owner_country: US
publication_date: 20130111
---

{"@attributes":{"id":"description"},"GOVINT":[{},{}],"heading":["GOVERNMENT FUNDING","CROSS REFERENCE TO RELATED APPLICATION","FIELD OF THE INVENTION","BACKGROUND OF THE INVENTION","DETAILED DESCRIPTION"],"p":["The invention was made with government support under grants 0720546 and 0916968 awarded by the National Science Foundation. The United States Government has certain rights in the invention.","This application claims the benefit of U.S. patent application Ser. No. 13\/601,425 filed Aug. 31, 2012.","The present invention generally relates to computer systems. More specifically, the present invention relates to development and testing of computer programs such as virtual devices that simulate or emulate hardware devices, and \u201cdevice drivers\u201d that facilitate communication between virtual or hardware devices and other hardware or software entities.","Computer systems, such as smartphones, personal digital assistants, tablets, netbooks, laptops, and desktops, typically include a processor, communication unit such as a bus, power supply, and, optionally, a housing unit. Often, computer systems are configured to function with peripheral devices, which are termed \u201cdevices\u201d for purposes of this application.","Devices may be categorized by the position of each relative to a housing unit. For example, internal devices\u2014called also \u201cintegrated devices\u201d\u2014generally are stored inside or integrated with the housing unit. Such integrated devices may include an internal hard drive, CD-R drive, CD-ROM drive, DVD-ROM drive, sound card, network card, video adapter, or an internal modem. External devices, on the other hand, generally are stored outside of the housing unit and may include a printer, scanner, monitor, touchscreen, keyboard, or pointing devices such as a mouse, gaming controller, or joystick.","Devices may be categorized also by function. For example, storage devices may include an external hard drive, flash drive, disk drive, or any other device configured to permit information storage. Input devices may include keyboard, pointing devices such as a mouse, gaming controller, or joystick, digital camera, webcam, barcode reader, microphone, fingerprint scanner, or any other device configured to permit input of information into the computer. Output devices may include display devices such as a monitor, segment display such as a digital clock display, television set, or tactile electronic display, audio output devices such as speakers or headphones, printers, or any other device configured to permit information output from the computer.","Many devices are configured to provide an output that is perceivable by a user. For purposes of this application, a \u201cperceivable output\u201d may include any perceptible output from the device including, for example, that which is viewable on a display, a touchable button, a light, or stored information. Other perceivable outputs may be input from one device\u2014e.g., a keyboard or a mouse\u2014and perceived as an output on a display device\u2014such as a monitor or a touchscreen.","Computer systems may use hardware, software, or both to manage the resources of the computer system. Software used to manage a computer system's resources is termed an \u201coperating system.\u201d When a user seeks to use a device with a computer system, the operating system may not have the information necessary to communicate with that device. Because of the plethora of devices available to connect with computer systems, it would be impractical to include the information necessary for communicating with every device in every operating system. Accordingly, a software program\u2014called a \u201cdevice driver\u201d or \u201cdriver\u201d\u2014allows the device and operating system to communicate with each other. Generally, at least one driver is available for every type of device. At times, a driver may be developed for each of multiple operating systems (e.g., Microsoft Windows, Mac OS X, Android, Linux, BSD, etc.). When the driver permits communication between the operating system and a physical device, the device can perform its function to generate a perceivable input\/output.","Drivers also may be used to facilitate communication between the operating system and an application program. An application program\u2014also referred to herein as an \u201capp\u201d\u2014may be configured to permit the user to perform a specific task. Popular apps may include word processing programs, image editing programs, game programs, database management programs, and document management programs. Certain apps may be configured for use specifically with a device. Such an app is termed a \u201cdevice application program\u201d for purposes of this application.","Conventionally, a driver or an app utilizing a device through the driver could not be developed until the physical device, or at least a stable prototype of the physical device, was completed. Clearly, such a delay in the development and validation of the driver further delays offering of the product for sale. At times, developers begin designing drivers based on predictions of the physical device. When the physical device becomes available, draft versions of the driver often require substantial revisions, which results in a largely inefficient process.","To shorten the development cycle, systems have been built to enable earlier development of a driver. One such approach includes using an early prototype such as a Field-Programmable Gate Array (\u201cFPGA prototype\u201d) for driver development. However, such prototypes can delay the start of driver development until the register transfer level (\u201cRTL\u201d) design of the device is generally finished. Also, an FPGA prototype may differ significantly from the physical device. As a result, the driver developed to work with that prototype may need significant revision in order that it can function with the physical device.","In addition, known approaches for testing an FPGA prototype, or even the physical device, during driver development permit only limited observation of the internal conditions of the prototype or device. Also, prototypes and physical devices generally do not permit recording events that occurred, for example, before an error, and are difficult to control without a time-consuming and labor-intensive bootstrapping process.","Another approach to enable the development of a driver involves the utilization of virtual machines and virtual devices. A \u201cvirtual machine\u201d is a software program configured to simulate the operation of certain hardware or operating system with minimal access to the actual hardware or operating system in the host computer system. In certain embodiments, a virtual machine is a simulated computer system operating within, but generally isolated from, a physical computer system.","A \u201cvirtual device\u201d is a software program configured to simulate the operation of or function as a physical device without access to the physical device or a prototype of the physical device. In various embodiments, a virtual device may be configured to have the same functional restrictions and other restrictions as physical devices. In various embodiments, a virtual device may be presented as a virtualized replacement of a physical device.","Virtual devices may operate within an environmental infrastructure such as a virtual machine or an operating system. When functioning in a virtual machine, a guest operating system may interact with a virtual device as if it is a physical device. This requires no change to the driver stack of the guest operating system. In contrast, when functioning in a non-virtual operating system, an operating system may be extended to allow loading of a virtual device as if it is a physical device. This involves changing the driver stack of the operating system. An example of this approach is the Device Simulation Framework (\u201cDSF\u201d), which allows introduction of virtual devices that model and simulate Universal Serial Bus (\u201cUSB\u201d) devices in an operating system.","While certain virtual devices are known, such virtual devices have not been optimized for device simulation and driver development. Specifically, certain known virtual devices are too simple to permit development of a driver that consistently functions with the physical device. Other known virtual devices are too complex to create an efficient simulation. For example, certain virtual devices permit observation, tracking, and control of the device, but often result in excess performance overhead and cause the simulation to operate slowly.","In addition, known virtual devices use concrete execution of software code. In other words, to achieve a certain task, a program may execute instructions that include one or more if-then statements (e.g., if A, then B; if not A, then C). In concrete execution, the developer must predetermine which choice the program will make at each decision point. Accordingly, to simulate each physical device behavior, a developer must explicitly specify concrete values and choices or supply run-time scripts for each device behavior. Such virtual devices render it difficult to conduct comprehensive exploration of possible device behaviors and simulation of the possible concurrency in device-driver interaction.","Other known device simulations are not configured to operate in virtualization environments such as DSF and a Quick EMUlator (\u201cQEMU\u201d) virtual machine. Such simulations include those generated from device designs at different stages within the development process, for example, transaction-level (\u201cTL\u201d) designs in SystemC or SystemVerilog, register-transfer-level (\u201cRTL\u201d) designs in Verilog or VHDL, and gate-level (\u201cGL\u201d) designs as net-lists.","In addition, methods for preparing testing protocols for known virtual devices and the co-developed drivers typically must be generated manually and\/or on a case-by-case basis, which is time-intensive and cost-prohibitive.","Clearly, there is a demand for a system and methods for constructing virtual devices that incorporate various levels of detail from a device design, developing a driver or application program with improved performance, preparing automated testing protocols for validating a driver, driver-device combination, or application program, and verifying conformance between virtual devices and their real counterparts, where such system and methods are configured to maximize the smooth integration of the resulting driver or application program with a physical device.","Embodiments of the present invention may be configured to use characteristics of virtual devices to improve symbolic execution effectiveness, generate test cases characterizing paths through virtual devices and drivers, provide facilities to replay those paths with the generated test cases, and to assess conformance of virtual devices used for testing during development of physical devices with the physical devices themselves.","Referring to , a device driver  may facilitate communication between a hardware device  and various other software or hardware logic, such as an application program  or an operating system . Additionally or alternatively, and as illustrated in , device driver  may facilitate indirect communication between hardware device  and application program , e.g., through operating system . In other embodiments, hardware device  may communicate directly with application program  or operating system .","In various embodiments, device driver  may be configured to act as translator between hardware device  and other entities, such as application program  or operating system . For example, device driver  may communicate with hardware device  through a computer bus or communications link, and with application program  or operating system  through system calls. When application program  or operating system  invokes a routine in device driver , device driver  may issue commands to hardware device . Once hardware device  sends data back to device driver , device driver  may invoke routines in application program  or operating system . Device driver  is illustrated with broken lines in various Figures since various drafts of the driver may be developed throughout the implementation of the system and methods.","Certain components of the system  of the present invention may form modules, as illustrated in , B, , , and . An infrastructure module  may be configured to provide computer infrastructure to the other modules. A virtual device module  may be configured to simulate a hardware device. A support module  may be configured to provide support functions such as generating test cases and reports and providing management options to the other modules.","In various embodiments, infrastructure module  may include a program environment such as operating system  and\/or virtual machine . Virtual machine  may come in various forms, including but not limited to Quick EMUlator (\u201cQEMU\u201d), VMWare, VirtualBox, or Xen. In various embodiments, infrastructure module  may also include application program . Operating system  may include or may be configured to communicate with device driver  developed through certain methods of the present invention or other methods. Virtual machine  may include a virtual device stub component , which may be configured to appear to virtual machine  as if it is virtual device . Virtual device stub component  also may be configured to facilitate communication with the actual virtual device  such as by sending and receiving information such as input\/output requests to and from a virtual machine interface  in virtual device module .","In various embodiments, virtual device module  may include a virtual device , virtual machine interface , and a symbolic execution engine . Virtual machine interface  may be a program configured to facilitate communication with other components such as by sending and receiving information to and from virtual device stub component  in infrastructure module .","Symbolic execution engine  may be configured to facilitate symbolic execution of a computer code, such as virtual device computer code or device driver computer code. Tools that may be used to implement all or aspects of symbolic execution engine  may include but are not limited to SAGE, KLEE and S2E, Cute, jCute, CREST, BitBlaze, DART, and Java Pathfinder. In various embodiments, symbolic execution engine  may be configured to explore execution paths through a computer program, and to generate a set of constraints called a \u201cpath condition\u201d that describes the set of values possible on each explored path. During symbolic execution, variables may be represented as symbolic expressions instead of concrete values. Accordingly, the outputs computed by the computer program may be expressed as a function of input symbolic values. In various embodiments, a symbolic state of a program may include symbolic values of program variables, a path condition, and a program counter. In various embodiments, the path condition may be a Boolean formula comprising constraints accumulated as the path is explored. In order to follow a particular path through a computer program, inputs to the computer program must satisfy the corresponding path condition determined during symbolic execution of the computer program. In various embodiments, the program counter may point to the next statement to be executed.","Embodiments of the support module  may include components such as a management component , test case generator , bug report generator , and a coverage report generator . Management component  may be configured to test, control, and communicate with application program , virtual device , and device driver . Test case generator  may generate test cases for use with virtual device , device driver , and application program  to achieve various test criteria. If, during testing, a bug or error is detected, bug report generator  may prepare a report describing the bug or error. Coverage report generator  may be configured to prepare a report describing the functions and status of virtual device , device driver , or application program . Based on the coverage report, test case generator  may generate additional test cases that may improve the coverage.","In various embodiments, virtual device  may include a symbolic virtual device (\u201cSVD\u201d) or a hardware device design-based virtual device. Embodiments of a symbolic virtual device may be configured to permit non-deterministic device behaviors. For example, instructions for implementing the device may include code with decision points for two or more choices. When the execution reaches that decision point, the decision may be made according to certain guidelines. Advantageously, such instructions may be easier and faster to develop since the developer can provide general guidelines instead of mapping every choice at every decision point.","Program instructions for an SVD may be non-deterministic in terms of both concurrency and environment inputs. Concurrency is a property of a system in which several programs are executing simultaneously and potentially interacting with each other by, for example, sharing certain resources. Environmental inputs may include information received from other system components (e.g., an operating system, application program, or device), and in various embodiments may be symbolic values and\/or concrete values.","In various embodiments, symbolic execution engine  may be configured to execute an SVD. As noted above, instead of running program code on manually-generated or randomly-generated inputs, engines run the SVD code using a symbolic input initially allowed to be \u201canything.\u201d In various embodiments, symbolic execution engine  may replace program inputs with symbolic values and concrete operations with symbolic operations. When execution of the program reaches a decision point based on a symbolic value, symbolic execution engine  may follow both options conceptually.","In various embodiments, symbolic execution engine  and\/or test case generator  may be configured to generate test inputs. In various embodiments, test case generator  may be part of symbolic execution engine , or vice versa. During execution of an SVD, when a path reaches a result, a test case may be generated by solving the current path condition for concrete values. When the concrete values are used as the input, the same path may be followed, which may facilitate identification and\/or repair of bugs.","A simple example of analysis of every possible path through one or more decision points in a computer program is illustrated in  and . A symbolic execution tree  illustrates the possible paths explored by the symbolic execution of the following computer code:",{"@attributes":{"id":"p-0051","num":"0050"},"tables":{"@attributes":{"id":"TABLE-US-00001","num":"00001"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int f(int x)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if(x<0)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return \u2212x;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if (x == 1)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"105pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"112pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return 2;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"return x;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"In , decision point nodes  may represent the symbolic program states and arcs  may represent the state transitions. At the input , the variable X has a symbolic value, e.g., any value allowed by its type (in this case, an integer). At each decision point node , the constraint is accumulated, and the set of accumulated constraints up to that point may be a current path condition.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 2B","FIG. 2B"],"b":["9","9","9","6","2"],"br":[{},{},{},{}],"in-line-formulae":[{},{},{},{},{},{}],"i":["X<","X==","X\u2267","x\u2260"]},"The example code above is a simple example. \u201cReal life\u201d code implementing a virtual device or device driver may be dramatically more complex. The number of paths through a program may be roughly exponential in program size. Thus, attempting to traverse all paths of a complex computer program may result in so-called \u201cpath explosion.\u201d Path explosion may strain computing resources (e.g., processing cycles, memory) and development schedules, limiting the ability to utilize symbolic execution to thoroughly test computer programs such as device drivers or virtual devices.","Accordingly, embodiments of an engine may be configured to minimize or eliminate the challenges with exponential path possibilities, e.g., by managing use of computing resources such as processing cycles and memory. One or more restraints may be applied when executing the virtual device. One type of restraint is a loop bound, which may be added to bound loops with loop conditions that are symbolic expressions. In this manner, it may be possible to control or limit the depth to which each loop is explored. In various embodiments, loop bounds may be added manually (e.g., for embodiments having only a few loops) or automatically (e.g., for embodiments having many loops).","Another type of restraint that may be utilized to minimize or eliminate path explosion may be a time bound. A time bound may be configured to require termination of symbolic execution of a computer program (e.g., virtual device, device driver) in a particular amount of time. If the symbolic execution does not completely finish within the given time bound, there may be unfinished paths. For such paths, test cases for the incomplete path conditions may still be generated. In various embodiments, both loop and time bounds may be utilized concurrently.","Embodiments of an engine may be configured to generate reports describing information about traces through a computer program. However, certain reporting methods may result in reports of traces covering the same instruction or sequence of instructions. For example, assume the following simple computer program:",{"@attributes":{"id":"p-0058","num":"0057"},"tables":{"@attributes":{"id":"TABLE-US-00002","num":"00002"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"int f (int x)"]},{"entry":[{},"{"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"84pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"133pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"if ( x == 1 \u2225 x == 2)"]},{"entry":[{},"return 0;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"70pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"147pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"return 1;"]},{"entry":[{},"}"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Symbolic execution similar to that described above with regard to  of this computer program may yield two paths and two corresponding path conditions.\n\n12 \u2003\u2003Path 1:\n\n1 &&2 \u2003\u2003Path 2:\n","However, a computer program executed using symbolic execution engine  may be compiled to an intermediate representation in which the compiler may decompose the \u201cif\u201d conditional expression into two separate branches. For example, KLEE may operate on Low Level Virtual Machine (\u201cLLVM\u201d) bitcode to find three paths and corresponding path conditions:\n\n1\u2003\u2003Path 1:\n\n2\u2003\u2003Path 2:\n\n1 &&2.\u2003\u2003Path 3:\n","Paths  and  may cover the same sequence of computer program instructions. To provide the ability to output a trace report without duplicative traces, in various embodiments, symbolic execution engine  or other another component may be configured to detect and eliminate duplicative traces.","In various embodiments, multiple types of reports may be created, e.g., at various levels of complexity. For example, in various embodiments, a virtual device may be executed, e.g., by symbolic execution engine , with symbolic value. Test cases may be generated, e.g., by symbolic execution engine , that include concrete values for all explored paths. For each generated test case, the virtual device may be executed with the concrete value or values. A path trace may be obtained. If a path trace covers a sequence of code already covered, path information may be output to an extended analysis report. If a path trace covers a sequence of code yet to be covered, then path information may be output in both the extended analysis report and a simplified analysis report that does not include duplicative traces.","In various embodiments, generation of effective test cases may be facilitated by enabling specification of various types of initial states of a virtual device. One example type of initial state is a concrete state. A concrete state may be a predefined state, in which all state variables are assigned specific values. In various embodiments, these values may be captured from a physical device that is the same as or similar to the virtual device. Another type of initial state is a symbolic state, in which all state variables are made symbolic. As described above, the symbolic state may be used to identify paths of a computer program such as a virtual device or device driver. Another type of initial state is a \u201cconcolic\u201d state, in which some state variables may be assigned concrete values and other state variables are made symbolic.","Certain embodiments of a virtual device may invoke outside functions from its environment. Such outside functions may be implemented using a function call for a subroutine. In various embodiments, if a function call does not affect a state variable of a virtual device, symbolic execution engine  may be configured to display a warning message and refrain from taking further action regarding the function call. If the function call may affect the value of state variable of the virtual devices, on the other hand, the function may be implemented in a stub, which is invoked by the virtual device in symbolic execution.","In various embodiments, once concrete test cases are generated, the virtual device or driver may be executed, e.g., by symbolic execution engine , independently or by another component, using the concrete test cases. In some embodiments, the computer program may be executed with generated concrete test cases in a debugging environment that facilitates real-time examination of variables and states, e.g., using breakpoints. In various embodiments, such execution may operate in accordance with the following pseudocode:",{"@attributes":{"id":"p-0066","num":"0065"},"tables":{"@attributes":{"id":"TABLE-US-00003","num":"00003"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"thead":{"row":{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"initialize a stack;"},{"entry":"load a test case;"},{"entry":"assign the test case to the corresponding variables of device model."},{"entry":"while (true) {"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if there is no user input"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"sleep for a period;"]},{"entry":[{},"continue;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"14pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"203pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"switch (user input)"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case forward:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"execute one instruction and display the variable changes;"]},{"entry":[{},"push the current state into the stack;"]},{"entry":[{},"break;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case backward:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"pop one state off the stack and set the state as current"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"state;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"break;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case inspect variable:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"search the variable in the current state and return the value"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"of the variable;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"break;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"case exit:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"finish execution;"]},{"entry":[{},"return;"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"default:"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"break;"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"left"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":"}"},{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}}]}}]}}},"In various embodiments, a developer may interrupt or change the path while running the concrete test cases, e.g., to permit further exploration of what inputs and initial states are used to trigger the path and inspect values of variables at any step. This method can be easily applied to many types of device models of virtual devices, minimizes overhead, and provides a user-friendly interface.","In various embodiments, symbolic execution engine  may be capable of executing one programming language or multiple programming languages. In various embodiments, an SVD specification may be compatible with a specific symbolic execution engine  or multiple symbolic execution engines. In various embodiments, an SVD specification may include one programming language, certain language features, or multiple programming languages. Symbolic execution engine  may symbolically execute the SVD wherein the environmental inputs are provided as symbolic values rather than concrete values. Additionally, the engine symbolically executes the SVD at decision points wherein the decision is selected non-deterministically from all the possible choices.","Embodiments of an engine may include various constraint solvers such as the STP constraint solver.","Embodiments of an SVD may operate in a number of modes. In a debugging mode, an SVD may be executed symbolically, e.g., by symbolic execution engine . As the SVD responds to an input\/output request, symbolic execution engine  may compute the feasible SVD execution paths at the current device state. The feasible paths may be provided directly to the user to make a choice or the choice is made by a pre-set strategies. This mode may provide for step-by-step debugging by facilitating complete control over the SVD. The debugging mode also may be configured to permit in-situ path prediction and randomized execution of the SVD.","In a profiling mode, an SVD may be executed concretely by the virtual machine and symbolically by the symbolic execution engine, sometimes, simultaneously. Symbolic execution may exhaustively explore all possible execution paths through the SVD. The concrete execution paths of the SVD resulting from a test case may be compared, e.g., by coverage report generator , against the symbolic paths to calculate the coverage report for the test case. In this mode, the symbolic paths can be pre-generated by the symbolic engine to improve the run-time profiling efficiency.","Upon executing test cases, the symbolic execution engine  may provide the coverage statistics such as statement coverage, branch coverage, path coverage, and transaction coverage information. Transaction coverage information may include identification of some or all possible transactions of an SVD resulting from an environmental input or a driver command. Transaction coverage information also may include an assessment of the impact of a test case or test suite in terms of which transactions or paths have been hit and how often each was hit. Additional metrics specific to devices may also be utilized that considers one or more driver commands and environmental inputs. After the execution statistics such as percentiles for the coverage metrics are collected, they may be visualized graphically as bar charts, pie charts, or other diagrams.","If symbolic execution engine  is not compatible with an SVD, or symbolic execution engine  is configured for use with a number of SVDs, an adapter may be created for each SVD or a group of SVDs. Such an adapter is termed a \u201charness\u201d for purposes of this application. In certain embodiments, a harness and an SVD pair may form a stand-alone program. Embodiments of a harness may include a virtual machine with a guest operating system. However, other simpler embodiments are contemplated as well. In various embodiments, a harness may be configured to handle non-deterministic entry function calls, symbolic inputs to device models, and function calls to the environment.","A harness may be generated using manual harness generation or automatic harness generation. Manual generation of a harness may involve examination of how a virtual machine invokes the virtual device, which virtual machine APIs are invoked by a virtual device, and what these APIs invoke recursively. The implementation of the invoked functions is included in the harness. At times, it may be necessary to make a function produce non-deterministic outputs by throwing away its implementation.","Manual harness generation may be useful to generate a harness configured to function with a category of devices. Certain devices are categorized based on functionality, such as network adapters and massive storage devices, or based on a type of interface standard, such as Peripheral Component Interconnect (\u201cPCI\u201d) and Universal Serial Bus (\u201cUSB\u201d).","A harness may be generated automatically by implementing an algorithm that includes a number of steps. First, a call graph\u2014that is a graph displaying the invocation relationships between various subroutines\u2014originating from a virtual device is analyzed to determine which functions were invoked by the virtual device and how often those functions were invoked. Then, based on the frequency of use, certain functions are selected for incorporation into the harness code. It is often sufficient to include the implementations of the first level functions invoked. This algorithm also includes a refinement loop which adjusts based on the symbolic execution, for instance, if making a function non-deterministic leads to a large number of paths, the implementation of this function may need to be included.","Embodiments of a harness, which may be generated manually or automatically, may include a number of components, including declarations of state variables and parameters of entry functions, code for making state variables and inputs of entry functions symbolic, non-deterministic calls to virtual device entry functions, and stub functions for virtual machine API functions invoked by virtual devices.","Regarding the declarations of state variables and parameters of entry functions, in various embodiments, a virtual device may not be a stand-alone program. Accordingly, the state variables and function parameters may be defined. If a virtual device is running in a virtual machine, it may register its entry functions with the virtual machine. Moreover, the virtual machine may help the virtual device manage its state variables. When an entry function is invoked, the state variables and necessary parameters of the function may be transferred to the function from the virtual machine. Other declarations define necessary parameters for the entry functions.","Regarding code for making state variables and inputs of entry functions symbolic, this permits covering as many paths as possible. The inputs of an entry function should contain state variables and necessary parameters. Certain embodiments implement a specific function \u201csvd_make_symbolic\u201d in the engine to initialize the inputs symbolically. All state variables and parameters of entry functions may be made symbolic before they are used.","Regarding non-deterministic calls to virtual device entry functions, virtual devices provide all kinds of entry functions for communicating with the operating system or virtual machine. To analyze a virtual device, all entry functions are executed with symbolic inputs. A symbolic variable is defined in the harness to make nondeterministic calls to all entry functions. Certain functions may be invoked by a driver to write to or read from the device registers. Additional functions may be invoked by the operating system or virtual machine to notify the device about events from outside environments, such as whether there is a physical link to the device and whether there is a new packet to receive.","Regarding stub functions for virtual machine API functions invoked by virtual devices, certain stub functions for selected functionalities are known in the art. Such stub functions may be included in a harness according to desired or necessary functionalities.","The above-described techniques were applied to five existing virtual devices that are distributed with the QEMU virtual machine, and which are described in the Table I, below:",{"@attributes":{"id":"p-0083","num":"0082"},"tables":{"@attributes":{"id":"TABLE-US-00004","num":"00004"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"126pt","align":"left"}}],"thead":{"row":[{"entry":"TABLE I"},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Virtual Device","Vendor","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["E1000","Intel","Pro\/1000 Gigabit Ethernet Adaptor"]},{"entry":["EEPro100","Intel","Pro\/100 Ethernet Adaptor"]},{"entry":["PCNet","AMD","PCNet32 10\/100 Ethernet Adaptor"]},{"entry":["RTL8139","RealTek","PCI Fast Ethernet Adaptor"]},{"entry":["Tigeon 3","Broadcom","BCM57xx-based Gigabit Ethernet Adapter"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}}}},"To execute these virtual devices symbolically, a simple harness was manually created for each virtual device. A common library of stub functions was also created for all five virtual devices. The size of this stub library was 481 lines. The respective source code files for these virtual devices ranged from 2099 lines to 4648 lines. The respective harnesses were relatively simple, with about 100 lines. Creation of the harnesses and stub libraries only required several hours a piece. Details about the device models and their harnesses are given in Table II, below.",{"@attributes":{"id":"p-0085","num":"0084"},"tables":{"@attributes":{"id":"TABLE-US-00005","num":"00005"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}}],"thead":{"row":[{"entry":"TABLE II"},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}},{"entry":["Virtual","Lines of",{},{},"# of "]},{"entry":["device","code in","# of functions","Lines of code","entry functions in"]},{"entry":["(VD)","VD","in VD","in harness","harness"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]},"tbody":{"@attributes":{"valign":"top"},"row":{"entry":{}}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"5"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"28pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"49pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["E1000","2099","53","74","4"]},{"entry":["EEPro100","2178","70","85","7"]},{"entry":["RTL8139","3528","110","111","13"]},{"entry":["PCNet","2139","50","112","13"]},{"entry":["Tigeon 3","4648","34","80","4"]},{"entry":{"@attributes":{"namest":"1","nameend":"5","align":"center","rowsep":"1"}}}]}}]}}},"To evaluate the performance overhead of our approach, these virtual devices were executed under five configurations which are shown in Table III, below. The experiments were performed on a laptop with an 8-core Intel\u00ae Core\u2122 2 i7 CPU, 8 GB of RAM, 320 GB and 7200 RPM IDE disk drive and running the Ubuntu Linux OS with 64-bit kernel version 2.6.38. The five configurations are divided into two groups based on different loop bound (\u201cLB\u201d) and time bound (\u201cTB\u201d). The first group contains configurations ,  and , for which the same loop bound and different time bounds were selected. The second group contains configurations ,  and , for which different loop bounds and different time bounds were selected. Table III includes the number of different paths followed in simplified results and memory usages (in megabytes) for running the five virtual devices under the five configurations.",{"@attributes":{"id":"p-0087","num":"0086"},"tables":{"@attributes":{"id":"TABLE-US-00006","num":"00006"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0","pgwide":"1"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"56pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"56pt","align":"center"}}],"thead":{"row":{"entry":[{},"TABLE III"]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"5","align":"center","rowsep":"1"}}]},{"entry":[{},"Config. 1","Config. 2","Config. 3","Config. 4","Config. 5"]},{"entry":[{},"LB: 1","LB: 1","LB: 1","LB: 2","LB: 3"]},{"entry":[{},"TB: 150 sec.","TB: 300 sec.","TB: 600 sec.","TB: 300 sec.","TB: 600 sec."]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"11"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"8","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"9","colwidth":"35pt","align":"center"}},{"@attributes":{"colname":"10","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"11","colwidth":"35pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Device","Paths","Memory","Paths","Memory","Paths","Memory","Paths","Memory","Paths","Memory"]},{"entry":{"@attributes":{"namest":"1","nameend":"11","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"11"},"colspec":[{"@attributes":{"colname":"1","colwidth":"35pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"3","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"6","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"7","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"8","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"9","colwidth":"35pt","align":"char","char":"."}},{"@attributes":{"colname":"10","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"11","colwidth":"35pt","align":"char","char":"."}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["E1000","318","216","545","1006","601","1229","427","626","669","1891"]},{"entry":["EEPro100","207","41","534","115","1087","328","469","82","590","126"]},{"entry":["RTL8139","457","76","487","82","503","86","493","82","508","87"]},{"entry":["PCNet","279","74","424","139","646","262","417","139","601","262"]},{"entry":["Tigeon 3","150","172","150","172","150","172","315","817","366","1541"]},{"entry":{"@attributes":{"namest":"1","nameend":"11","align":"center","rowsep":"1"}}}]}}]}}},"With the given loop bounds and time bounds, the above-described techniques achieved exploration of numerous paths with modest memory usage. With the same loop bound, more paths may be explored with a larger time bound. With a larger loop bound, new paths may be followed with multiple loop iterations. However, each path may take different amount time to explore. A path containing multiple loop iterations often takes more time to explore. Therefore, in some test runs, for instance, PCNet, it may be possible to follow relatively few paths with the same time bound but a larger loop bound.","In certain embodiments, the SVD may be loaded into an operating system or may be included in a virtual machine in the same manner as a conventional virtual device. In such embodiments, the interface of the SVD to the operating system or virtual machine may mimic a conventional virtual device interface. However, the internal mechanism for loading an SVD is executed by a symbolic execution engine. The execution of SVD may include two parts: the symbolic execution of its device model and the virtual device interface that connects its device model to the operating system or virtual machine. As the SVD is loaded, both the symbolic device model and the virtual device interface are executed. When the SVD is initialized, for each variable in the device model, a concrete value is assigned if such a value is known; otherwise a symbolic value is assigned.","With SVD loaded in the environment, the developer may execute the device driver in the operating system\u2014the host operating system or a guest operating system on the virtual machine\u2014to interact with the SVD as if it was a physical device. As the SVD receives a command from the driver, it executes the device model symbolically in response to the command. The engine may introduce environment inputs non-deterministically to permit exploration of concurrent execution of device model and device driver. Inputs may be assigned symbolic values so that many concrete input scenarios are explored by the execution. When multiple execution paths are feasible, one path is selected non-deterministically. Instead of a specific device behavior, the SVD exhibits a permissible device behavior non-deterministically selected.","Certain embodiments of the present invention permit a developer to control the behavior of the SVD so that its execution is not completely non-deterministic. The developer may control the SVD behavior by instructing the engine to yield control to the developer at certain decision points rather than making non-deterministic choices. The developer may also control the SVD behavior by assigning different weights to different choices at certain decision point so that the symbolic engine makes its choice according to the weights.","Certain embodiments of the present invention include a hardware device design-based virtual device as illustrated in . The simulation of a hardware design  such as an RTL model, may incorporated into a virtual machine as a virtual device. A device design may be simulated by a design simulator  such as a stand-alone hardware simulator, or a design-specific simulation library. The simulation may be configured to communicate with the virtual machine  through a virtual device stub component . Inputs\/outputs may be converted through the virtual device stub interface to the inputs\/outputs of the simulated design. The virtual device stub component  may be defined to follow the requirements of the virtual machine and the interface protocols of the anticipated device such as PCI and USB. Virtual device inputs\/outputs are often defined as software function calls while inputs\/outputs to hardware designs vary depending on the hardware design languages used. For example, for RTL designs the inputs\/outputs are defined as signals coming in and going out of a hardware module and for SystemC design, the inputs\/outputs are defined as function calls, but in different formats from the virtual device function calls. Accordingly, the convertor specification includes inputs\/outputs to the virtual device, inputs\/outputs to the hardware design, and rules for converting between them.","The hardware design is compiled into a design-specific virtual device  such as a C\/C++ module and the module is packaged as a virtual device and loaded into the virtual machine module , as illustrated in .","Once the HD-VD is specified, the necessary software programs are automatically generated that implement the convertor, connect the virtual device stub interface to the convertor, and connect the convertor to the interface of the hardware design through the facilities of the design simulators . For a design simulator  such as Mentor Graphics ModelSim which operates as a stand-alone system, the convertor is split into two parts: the virtual device side and the simulator side. Each side of the convertor is implemented as a dynamically linked library, loaded by the virtual device environment and the hardware simulator respectively. The two libraries communicate with each other at run time to realize the input\/output conversion.","The virtual device side library may capture the input function calls to the virtual device and communicates the type of calls and the parameters to the simulator side library, which then generates the input signals\/function calls to the hardware design accordingly. The simulator side library captures the output signals\/function calls from the hardware design and communicates the types of signals and their values or the types of function calls and their parameters to the virtual device side library, which then invokes the corresponding virtual device output function calls with the properly formulated parameters. For a hardware simulator such as Verilator which compiles the hardware design into a software program that may be utilized as a library, the convertor is combined with the simulation program to create a dynamically linked library. This library is loaded by the virtual device environment. As the stub virtual device receives a virtual device input, a corresponding function of the convertor is called and the parameters of the virtual device input are passed onto the convertor. In this convertor function, those parameters are analyzed and the proper sequence of functions in the simulator program is called with the properly formulated parameters. When the simulator program is ready to output, it invokes a function in the convertor which transforms the output from the simulated design into the invocation to the corresponding virtual device output functions.","The HD-VD may be loaded into an operating system or a virtual machine. For a stand-alone simulator such as ModelSim, the simulator is first started and the hardware design loaded. As it starts, the simulator side library is loaded. Then, the virtual device stub is loaded by the virtual device environment. As the virtual device stub is loaded, the virtual device-side library may also be loaded. As this library is loaded, it synchronizes with the simulator side library. Once these libraries are synchronized and the virtual device stub recognized by the operating system or the virtual machine, the loading of HD-VD is complete and ready to be utilized by the device driver. In this setup, the virtual device environment and the simulator are two separate processes and they communicate through inter-process communication. For a simulator generated as a library, as the virtual device stub is loaded by the virtual device environment, the dynamically linked library is also loaded with the virtual device stub. Once the virtual device stub is recognized by the operating system, the loading of HD-VD is complete and ready to be utilized by the device driver. In the setup, the simulator is part of the virtual device environment and often executed in a thread.","Once the HD-VD is recognized by the operating system or virtual machine, it is treated as if it was a physical device. The development and validation of device driver may be conducted on top of the HD-VD the same way as the physical device. Since the HD-VD is the simulated hardware design, as the device driver interacts with it, all functionalities of the simulator may be utilized to monitor its status (such as internal states), control its behaviors, and log its execution traces.","Embodiments of the present invention include an integrated development environment configured to provide automation through the lifecycle of SVDs including creation, analysis, deployment, run-time control, and testing. Such an integrated development environment is configured to provide a number of functions automatically. For example, it may permit: (1) creation, compilation, and debugging of SVDs, (2) SVD transaction analysis: enumerating possible types of transactions through SVDs, (3) push-a-button deployment of SVDs into virtual machines, (4) run-time control of SVDs: breakpoint, step-through, in-situ path prediction, and randomized execution, (5) incorporation of HD-VD into SVD, and (6) SVD test coverage report and automatic test generation.","An embodiment of an integrated development environment including three workflows (e.g., SVD workflow, HD-VD workflow, and SVD+HD-VD workflow) is illustrated in . All the three workflows can be initiated from a user interface  such as a VD Studio graphical user interface. A user interface  may be viewed on an input\/output display interface . In certain embodiments, a user interface  is used to invoke a visual editor  for each corresponding workflow, namely SVD visual editor A and\/or HD-VD visual editor B. The user may create and configure SVD and HD-VD through the visual editor  to create an SVD specification A or an HD-VD specification B. Once the SVD specification A and\/or HD-VD specification B is completed, it is compiled into a SVD A and\/or HD-VD B automatically using a compiler A, B. The SVD A and HD-VD B are then deployed into an environment such as a virtual machine  or operating system , or an embodiment of a virtual device module  that may include a symbolic engine  and\/or a design simulator . As the simulators execute, the SVD A and HD-VD B traces are captured and send to the bug report and coverage report generator in the support module . Test cases can also be generated and provided to the simulators to apply.",{"@attributes":{"id":"p-0100","num":"0099"},"figref":"FIG. 8","b":"1"},"As noted above, in various embodiments, virtual devices may be used to develop a device driver for future use with a later-developed physical device. However, virtual devices may behave differently from physical devices due to design and implementation errors, misunderstanding of design specifications, and even the different level of details. It therefore may be beneficial to assess the conformance of a physical device with its virtual device and discover the inconsistencies.","Accordingly, in various embodiments, conformance assessment of a hardware device with its corresponding virtual device may be facilitated, e.g., to localize any inconsistencies, as illustrated in . This may permit symbolic execution of a virtual device with the same driver request sequence to a corresponding physical device, and assessment of whether the physical device and its virtual device counterpart behave consistently. For example, in various embodiments, the driver requests sent to the physical device may be recorded, the virtual device may be symbolically executed using the recorded request sequence, and the observable states of the virtual device and physical device may be analyzed for inconsistencies.","Conformance assessment may address the limited observability of physical devices. A physical device may have internal states which are difficult to observe. Moreover, the outside environment inputs of the physical device may also be difficult to capture. However, using disclosed techniques, physical device state transitions on the virtual device may be replayed to model the internal states and outside environment inputs using variables with symbolic values. In this way, symbolic execution covers their possible values.","Conformance assessment may not suffer from the complexity of symbolic execution. As noted above, the complexity of symbolic execution may be high due to path explosion. As will be explained further below, to reduce resulting time and resource overheads, a technique referred to herein as \u201cadaptive concretization\u201d may be employed to eliminate unnecessary symbolic variables, a major factor contributing to the symbolic execution complexity.","In various embodiments, conformance assessment may be implemented by a trace recorder  and a conformance checker , as illustrated in . Trace recorder  may be configured to capture a driver request sequence to physical device  and the physical device state before each driver request is issued. A sequence of such request-state pairs may be referred to as a \u201cdevice trace.\u201d Trace recorder  may produce a trace file  that includes the captured device traces.","In some embodiments, trace recorder  may record every driver request. In other embodiments, trace recorder  may selectively record certain driver requests. In some embodiments, trade recorder  may only be capable of capturing a subset of all possible variables that together form a physical device state. For example, in various embodiments, some registers of physical device , such as interface registers, may be accessible to trace recorder . Other registers, such as internal registers, may not be accessible to trace recorder. In some such embodiments, conformance checker  may assign symbolic values to the inaccessible registers (or more generally, variables). The resulting physical device state may be referred to as a \u201cpartial state.\u201d","In various embodiments, conformance checker  may be configured to execute virtual device  with the recorded driver request sequence from trace file , determine whether physical device  and virtual device  are consistent, and output an inconsistency record  if inconsistencies are found.","In various embodiments, conformance assessment may include initializing a state of virtual device  by assigning the observable state of physical device  before virtual device  takes a first driver request. Then, virtual device  may be symbolically executed upon a driver request from the device trace. After virtual device  consumes the driver request, a consistency between virtual device  and physical device  may assessed. If an inconsistency is found, it may be recorded, and virtual device  and physical device  may be synchronized by setting the physical device state as the virtual device state. Otherwise, virtual device  may be synchronized by further constraining the virtual device states with the corresponding register values in the physical device state. Then, conformance checker  may receive the next driver request and repeat the executing, checking, and recording steps. The conformance checking process may terminate when it completes a trace file, e.g., by finishing the last driver request in the sequence.","In various embodiments, conformance checker  may include a state checker component (not shown), which may receive a partial state of physical device  and a set of symbolic states of virtual device  as inputs. As noted above, the partial state may be a symbolic state that may contain concrete values (e.g., for accessible registers) and symbolic values (e.g., for inaccessible registers) that together form all possible states of physical device . Each symbolic state of virtual device  may contain a set of possible virtual device states. An inconsistency may be discovered if there is no intersection between the partial state and any symbolic state of the virtual device.","An algorithm that may be implemented in the state checker component may, in various embodiments, operate on a partial state P and the set of symbolic states of the virtual device, G. G may contain several symbolic states, S, S, . . . , S. For each S\u03b5G, <i\u2266m, P \u2229Smay be computed. If for all S\u03b5G, P \u2229S=\u00f8, an inconsistency may exist between virtual device  and physical device .","In order to compute P \u2229S, expressions of P and Smay be constructed. Assume that the device state has the following variables: var, var, . . . , var. The values of the state variables of P may be defined as Val(var), Val(var), . . . Val(var). In various embodiments, the expression of P may be constructed as Expr (P): (van==Val(var))\u039b(var==Val(var))\u039b . . . \u039b(var==Val(var)). Similarly, assuming that the constraints of Sis expressed as Cont(S), the expression of S, Expr(S), may be constructed as follows: (var==Val(var))\u039b(var==Val(var))\u039b . . . \u039b(van==Val(var))\u039bCont(S). By constructing the expressions of P and S, testing whether P \u2229Sis non-empty may be transformed to testing whether Expr (P)\u039bExpr(S) may be satisfied. An example algorithm for implementing this process is below:",{"@attributes":{"id":"p-0112","num":"0111"},"tables":{"@attributes":{"id":"TABLE-US-00007","num":"00007"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NextState = NULL"]},{"entry":[{},"FLAG = FALSE"]},{"entry":[{},"Expr(P) = TRUE"]},{"entry":[{},"for all varof P do"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Expr(P) = Expr(P) \u039b (var== Val(var))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end for"]},{"entry":[{},"for all S\u2208 G do"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"Expr(S) = 1"]},{"entry":[{},"for all varof Sdo"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"Expr(S) = Expr(S) \u039b (var== Val(var))"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end for"]},{"entry":[{},"Expr(S) = Expr(S) \u039b Cont(S)"]},{"entry":[{},"if Expr(S) \u039b Expr(P) is satisfied then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"56pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"161pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NextState = NextState \u222a (S\u2229 P)"]},{"entry":[{},"FLAG = TRUE"]},{"entry":[{},"break"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"175pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"end if"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"28pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"189pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end for"]},{"entry":[{},"return FLAG"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Suppose a device state contains two variables, a and b. In the partial state P, there may be only one variable, a, which has the concrete value of 3. The symbolic value \u03b2 may represent the variable b. In the set of symbolic states of the virtual device, there may be a symbolic state S {a==\u03b1, b==\u03b2\u2032, \u03b1<=5, \u03b2\u2032<10}. The expression of the state P, Expr(P) may be (a==3)\u039bb==\u03b2). The expression of S, Expr(S) may be (a==\u03b1)\u039b(b==\u03b2\u2032)\u039b(\u03b1<=5)\u039b(\u03b2\u2032<10). Since the expression Expr(P)\u039bExpr(S) is satisfied, P\u2229S\u2260\u00f8. Thus, the physical device state and the virtual device state may be considered consistent.","After conformance checking, synchronization steps may be employed. In various embodiments, if an inconsistency was found during conformance testing, the physical device state may be set as the virtual device state. Otherwise, the new virtual device state may be a union of all non-empty intersection of P and S, since this union contains the possible virtual states consistent with the physical device state.","As described above, certain embodiments of the present invention include a harness. A harness may be used in association with the conformance checking process as well. Non-deterministic choices are used to enable non-determinism in virtual devices such as QEMU virtual devices. Some input variables of the virtual device have unknown values. For example, outside environment inputs of the virtual device are unknown, as they are not captured from the physical device. These variables are initialized with symbolic values, so that symbolic execution can cover the possible inputs from the outside environment. Capturing the hardware concurrency requires non-deterministic executions of a loop where the module functions are invoked non-deterministically. Such a loop is defined as the main loop of an execution harness. Theoretically, symbolic execution needs to execute the loop until all states are explored. However, this is not realistic for some embodiments, as fix-point computation in symbolic execution is expensive.","In various embodiments, symbolically executing a module function of a virtual device often may have the same effect or a similar effect on the device state as executing it only once. For example, receiving a packet and receiving multiple packets usually lead to the same effect on the device registers: an interrupt is fired by setting one bit in the interrupt register. Therefore, to efficiently capture the concurrency of module functions, the loop bound may be set equal to the number of the module functions in the execution harness. This implementation of non-deterministic interleaving may cover most of the device concurrency. Nevertheless, it is possible to have false negatives, as a boundary for the main loop may be set instead of non-deterministic many executions.","False negatives may result in certain embodiments because the non-deterministic interleaving by executing the main loop of the execution harness is bounded to a fixed number of times or because symbolic execution executes a loop in the virtual device that is not statically bounded a fixed number of times. However, such false negatives are typically low because the loops in the virtual device and the main loop in the execution harness are bound to reflect physical device usage and accordingly cover most of the virtual device behaviors.","In various embodiments, a conformance checking embodiment may be implemented as a kernel library such as a Linux kernel library. Linux device drivers may call kernel API functions to manipulate devices. For example, a driver may call a function \u201cwritel\u201d to write a long integer to a device register. The source code of these kernel functions may be instrumented so that the trace recorder is invoked to record the driver requests once the driver calls these functions to manipulate the device.","A conformance checking embodiment also may include a symbolic execution engine to symbolically execute the virtual device. Before execution, a compiler such as an llvm-gcc compiler may be used to translate the virtual device into an intermediate representation, such as LLVM bitcode. A symbolic execution engine such as KLEE may be modified for state checking. The symbolic execution engine also may be modified to remove certain functions not used in certain embodiments, for example, generating test cases.","As was the case with test case generation, symbolic execution during conformance checking may be vulnerable to path explosion. To reduce symbolic execution overhead, in various embodiments, a technique known as \u201cadaptive concretization\u201d may be used to eliminate unnecessary symbolic variables. When conformance checking reveals that a virtual device state is consistent with a corresponding physical device, that may suggest that, during execution of the virtual device, few if any of the symbolic variables of the virtual device were accessed. In fact, the values of the symbolic variables may not affect the conformance checking results most of the time. Therefore, in various embodiments, symbolic symbols may be adaptively concretized while introducing relatively few false negatives.","An example adaptive concretization process is illustrated in . In various embodiments, a first round of the adaptive concretization may be referred to as a \u201cconcretizing mode.\u201d In this mode, virtual device  may be concretized at block , e.g., by directly assigning concrete, random values to its symbolic variables. Conformance assessment similar to that illustrated in  may then be conducted, e.g., by a first conformance checker A. As input, first conformance checker A may use a concretized virtual device A, rather than general virtual device , as well as trace file . In various embodiments, first conformance checker A may be configured to output driver requests  that reveal inconsistencies between concretized virtual device A and its counterpart physical device .","In various embodiments, a second round of adaptive concretization may be referred to as a \u201csymbolic mode.\u201d In such a mode, a second conformance checker B may be configured to perform a second round of conformance assessment using the original virtual device  (e.g., with symbolic variables). In various embodiments, second conformance checker B may be configured to output inconsistency records . Because second conformance checker B may only perform conformance assessment using the driver requests output by first conformance checker A in the first round of conformance checking (which as noted above are only those request that lead to inconsistencies), complexity and resource usage of symbolic execution may be reduced. Inconsistencies discovered by second conformance checker B may be output in an inconsistency record  as inconsistencies between the virtual device and the physical device. In various embodiments, inconsistencies in inconsistency record  may include virtual device bugs and\/or physical device bugs. By using adaptive concretization, enumerating unnecessary states is avoided. This can reduce symbolic execution overheads significantly.","In embodiments in which the virtual device is concretized using adaptive concretization, a state checking algorithm of the concretizing mode may be simplified. The state checker in the concretizing mode may check concrete states that do not have any variables with symbolic values and any symbolic constraints. Accordingly, the state checker may not need to construct symbolic expressions for each state or invoke the solver to solve constraints. Instead, the state checker may be configured to implement an algorithm, an example of which is shown below, to determine whether the observable states of the physical device are equal to the corresponding states of the virtual device. In the example below, \u201cInterfaceRegisters\u201d may represent a set of interface registers variables located in the range of selective capturing:",{"@attributes":{"id":"p-0124","num":"0123"},"tables":{"@attributes":{"id":"TABLE-US-00008","num":"00008"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"thead":{"row":{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NextState = NULL"]},{"entry":[{},"for all S\u2208 G do"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FLAG = TRUE"]},{"entry":[{},"for all var\u2208 InterfaceRegisters do"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"if Val(var)\u2260 Val(var)then"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"126pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"FLAG = FALSE"]},{"entry":[{},"break"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"end if"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end for"]},{"entry":[{},"if FLAG \u2260 TRUE then"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"continue"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"else"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"77pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"140pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"NextState = P"]},{"entry":[{},"return TRUE"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"63pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"154pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":{"entry":[{},"end if"]}}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"2"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"168pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},"end for"]},{"entry":[{},"return FALSE"]},{"entry":[{},{"@attributes":{"namest":"offset","nameend":"1","align":"center","rowsep":"1"}}]}]}}]}}},"Three real-world network adaptors and their corresponding virtual devices (provided with QEMU) were assessed for conformance using techniques described herein.",{"@attributes":{"id":"p-0126","num":"0125"},"tables":{"@attributes":{"id":"TABLE-US-00009","num":"00009"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"1"},"colspec":{"@attributes":{"colname":"1","colwidth":"217pt","align":"center"}},"thead":{"row":{"entry":"TABLE IV"}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":{"@attributes":{"namest":"1","nameend":"1","align":"center","rowsep":"1"}}},{"entry":"DEVICE USED FOR CONFORMANCE ASSESSMENT EXPERIMENT"}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"1","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"center"}},{"@attributes":{"colname":"3","colwidth":"119pt","align":"left"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Device","VD Size","Description"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}},{"entry":["Intel e1000","88 KB","Intel Gigabyte Ethernet Adaptor"]},{"entry":["Broadcom","184 KB\u2002","Broadcom Gigabyte Ethernet Adaptor"]},{"entry":"bcm5751"},{"entry":["Intel eepro100","72 KB","Intel Megabyte Ethernet Adaptor"]},{"entry":{"@attributes":{"namest":"1","nameend":"3","align":"center","rowsep":"1"}}}]}}]}}},"Conformance assessment was performed using the physical devices and corresponding virtual devices described in TABLE IV above. As shown in the charts of , fourteen inconsistencies were found between the three network adapters and their virtual device counterparts: seven in the e1000, six in the bcm5751, and one in the eepro100. By analyzing the inconsistency reports generated by conformance checker , ten bugs were discovered in the virtual devices and two bugs were discovered in the silicon devices. As the results in  demonstrate, most of these inconsistencies are caused by the bugs of the virtual devices. This may be attributable to the facts that these network adaptor devices are stable products which have gone through extensive testing and bug-fixing procedures, and that their virtual devices may not have been as rigorously tested. However, such virtual device bugs may nonetheless appear in physical device prototypes, particular during earlier stages of hardware development, since these bugs are common violations of hardware designs. Accordingly, the conformance assessment described herein may be implemented during various hardware development stages, which may lead to the discovery of many inconsistencies caused by bugs in physical device prototypes.","We evaluate the time usages in the two rounds of conformance checking respectively. Table V, below, shows the results. \u201cConc.\u201d and \u201cSymb.\u201d denote the concretizing mode and the symbolic mode respectively. Values in the \u201cTime Usage\u201d column are the average time usages for the conformance checker processing every one hundred driver requests of the device trace collected under the different test cases. The time usages of both concretizing mode and symbolic mode are not so great as to render the technique useless. However, if adaptive concretization is not used while processing the driver requests, the time usages may be quite large. For example, take e1000 and \u201cReset NIC\u201d test case. Using a native, non-adaptive concretized approach, the time usage is 2363.41 seconds. In contrast, the time usages achieved using adaptive concretization described herein, shown in Table V, are lower, e.g., 8.22 seconds under the concretized mode and 119.6 seconds under the symbolic mode. These results demonstrate that adaptive concretization can significantly reduce the time usage of symbolic execution. Memory utilizations may be evaluated in a similar way time usages.",{"@attributes":{"id":"p-0129","num":"0128"},"tables":{"@attributes":{"id":"TABLE-US-00010","num":"00010"},"table":{"@attributes":{"frame":"none","colsep":"0","rowsep":"0"},"tgroup":[{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"3"},"colspec":[{"@attributes":{"colname":"offset","colwidth":"91pt","align":"left"}},{"@attributes":{"colname":"1","colwidth":"63pt","align":"center"}},{"@attributes":{"colname":"2","colwidth":"63pt","align":"center"}}],"thead":{"row":{"entry":[{},"TABLE V"]}},"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":[{},{"@attributes":{"namest":"offset","nameend":"2","align":"center","rowsep":"1"}}]},{"entry":[{},"Time Usage","Memory"]},{"entry":[{},"(seconds)","Usages (MB)"]}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"center"}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["Device","Test cases","Conc.","Symb.","Conc.","Symb."]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}},{"@attributes":{"align":"left","colsep":"0","rowsep":"0","cols":"6"},"colspec":[{"@attributes":{"colname":"1","colwidth":"42pt","align":"left"}},{"@attributes":{"colname":"2","colwidth":"49pt","align":"left"}},{"@attributes":{"colname":"3","colwidth":"21pt","align":"char","char":"."}},{"@attributes":{"colname":"4","colwidth":"42pt","align":"char","char":"."}},{"@attributes":{"colname":"5","colwidth":"21pt","align":"center"}},{"@attributes":{"colname":"6","colwidth":"42pt","align":"center"}}],"tbody":{"@attributes":{"valign":"top"},"row":[{"entry":["e1000","Reset NIC","8.22","119.60","122","313"]},{"entry":[{},"Send Pkts","8.35","225.91","137","336"]},{"entry":[{},"Chg. MTU","8.28","166.49","133","302"]},{"entry":["bcm5751","Reset NIC","11.21","89.16","135","335"]},{"entry":[{},"Send Pkts","13.11","251.68","128","302"]},{"entry":[{},"Chg. MTU","6.8","203.5","132","302"]},{"entry":["eepro100","Reset NIC","8.02","127.32","120","310"]},{"entry":[{},"Send Pkts","8.11","161.32","122","342"]},{"entry":[{},"Chg. MTU","8.91","91.52","122","301"]},{"entry":{"@attributes":{"namest":"1","nameend":"6","align":"center","rowsep":"1"}}}]}}]}}},{"@attributes":{"id":"p-0130","num":"0129"},"figref":"FIG. 12","b":["80","80"]},"Computer system  includes an input\/output display interface  connected to communication unit \u2014such as a bus \u2014, which forwards data such as graphics, text, and information, from the communication unit  or from a frame buffer (not shown) to other components of the computer system . The input\/output display interface  may be, for example, a keyboard, touch screen, joystick, trackball, mouse, monitor, speaker, printer, any other computer peripheral device, or any combination thereof, capable of entering and\/or viewing data.","A computer system  includes one or more processors , which may be a special purpose or a general-purpose digital signal processor that processes certain information. Computer system  also may include a main memory , for example, random access memory (\u201cRAM\u201d), read-only memory (\u201cROM\u201d), mass storage device, or any combination thereof. Embodiments of a computer system  may also include a secondary memory  such as a hard disk unit , a removable storage unit , or any combination thereof. Computer system  may also include a communication interface , for example, a modem, a network interface (such as an Ethernet card or Ethernet cable), a communication port, a PCMCIA slot and card, wired or wireless systems (such as Wi-Fi, Bluetooth, Infrared), local area networks, wide area networks, intranets, etc.","It is contemplated that the main memory , secondary memory , communication interface , or a combination thereof, function as a computer usable storage medium, otherwise referred to as a computer readable storage medium, to store and\/or access computer software including computer instructions. For example, computer programs or other instructions may be loaded into the computer system  such as through a removable storage device, for example, a floppy disk, ZIP disks, magnetic tape, portable flash drive, optical disk such as a CD or DVD or Blu-ray, Micro-Electro-Mechanical Systems (\u201cMEMS\u201d), nanotechnological apparatus. Specifically, computer software including computer instructions may be transferred from the removable storage unit  or hard disc unit  to the secondary memory  or through the communication unit  to the main memory  of the computer system .","Communication interface  allows software, instructions and data to be transferred between the computer system  and external devices or external networks. Software, instructions, and\/or data transferred by the communication interface  are typically in the form of signals that may be electronic, electromagnetic, optical or other signals capable of being sent and received by the communication interface . Signals may be sent and received using wire or cable, fiber optics, a phone line, a cellular phone link, a Radio Frequency (\u201cRF\u201d) link, wireless link, or other communication channels.","Computer programs, when executed, enable the computer system , particularly the processor , to implement the methods of the invention according to computer software including instructions.","The computer system  described herein may perform any one of, or any combination of, the steps of any of the methods presented herein. It is also contemplated that the methods according to the invention may be performed automatically, or may be invoked by some form of manual intervention.","The computer system  of  is provided only for purposes of illustration, such that the invention is not limited to this specific embodiment. It is appreciated that a person skilled in the relevant art knows how to program and implement the invention using any computer system.","The computer system  may be a handheld device and include any small-sized computer device including, for example, a personal digital assistant (\u201cPDA\u201d), smart hand-held computing device, cellular telephone, or a laptop or netbook computer, hand held console or MP3 player, tablet, or similar hand held computer device, such as an iPad\u00ae, iPad Touch\u00ae or iPhone\u00ae.","While the foregoing written description of the invention enables one of ordinary skill to make and use what is considered presently to be the best mode thereof, those of ordinary skill will understand and appreciate the existence of variations, combinations, and equivalents of the specific embodiments, and examples herein. The invention should therefore not be limited by the above described embodiments and examples, but by all embodiments within the scope and spirit of the invention."],"BRFSUM":[{},{}],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":["The preferred embodiments of the invention will be described in conjunction with the appended drawings provided to illustrate and not to limit the invention, where like designations denote like elements, and in which:",{"@attributes":{"id":"p-0023","num":"0022"},"figref":"FIG. 1A"},{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 1B"},{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2A"},{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 2B"},{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 3A"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 3B"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 6"},{"@attributes":{"id":"p-0032","num":"0031"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0033","num":"0032"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 10"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 11"},{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 12"}]},"DETDESC":[{},{}]}
