---
title: Delta transfers in distributed file systems
abstract: Disclosed are novel methods and apparatus for delta transfers in distributed file systems. In an embodiment, a communication system for transferring a delta of a file is disclosed. The communication system includes a sender site, a file transfer system, and a receiver site. The sender site includes a database with a trove section and a transfer section. The file transfer system includes a trove reader and a transfer reader. The trove reader may communicate with the trove and transfer sections. The transfer reader may have access to the transfer section. The receiver site receives the file delta from the transfer reader. The receiver site includes a file installer, which patches a previously installed version of the file with the file delta.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=07092972&OS=07092972&RS=07092972
owner: Sun Microsystems, Inc.
number: 07092972
owner_city: Santa Clara
owner_country: US
publication_date: 20020509
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["CROSS-REFERENCE TO RELATED APPLICATIONS","FIELD OF INVENTION","BACKGROUND OF INVENTION","SUMMARY OF INVENTION","DETAILED DESCRIPTION"],"p":["This application relates to application Ser. No. 10\/143,313, entitled \u201cDistributed Configuration-Managed File Synchronization Systems,\u201d and application Ser. No. 10\/143,191, entitled \u201cPersistent Queuing for Distributed File Systems,\u201d both filed concurrently herewith and in the name of the present assignee. All these documents are hereby incorporated by reference for all purposes.","The subject of this application relates generally to the field of data transfer. More particularly, an embodiment of the present invention relates to delta transfers in distributed file systems.","As the use of digital data becomes more prominent in everyday life, the need for access to reliable data sources increases. For example, a user may need regular access to data that can be physically located across different buildings or even around the world. This is often the case with respect to large company projects that may involve many groups worldwide working on a same solution.","As these types of joint projects become more commonplace, so does the need for having access to such data in real-time. In other words, the data accessed by each remote site will need to be current whether that data is stored locally or halfway around the world. Accordingly, the users need to have access to the latest version of the data as soon as it is released into the system from any site.","In many current implementations utilizing transmission control protocol\/Internet protocol (TCP\/IP), file transfer protocol (FTP), and other similar facilities (e.g., RSYNC command provided in Unix systems) are utilized to maintain data amongst remote sites. These tools, however, are generally useful only for transferring files from one point to the next. Moreover, automation of these tools only results in synchronization among multiple sites when a batch update or a nightly synchronization is performed. Also, if one of the remote sites goes down or cannot accept external data, the data may be dropped and unavailable.","One of the biggest challenges for a distributed file system is the efficient utilization of the available network bandwidth. This can be key to an effective real-time file synchronization utility, especially in a large multi-user community sprawled across a country or even the globe. The RSYNC utility uses an internal computation for transferring only the change in data to a remote site. This internal computation, however, cannot be harnessed by a multi-site file system using, for example, a revision control system (RCS) at the backend. Also, the RSYNC utility computes the change on an entire file without regard for different versions of a same file.","The present invention, which may be implemented utilizing a general-purpose digital computer, includes novel methods and apparatus to provide delta transfers in distributed file systems that can provide ready access to data among remote users. In an embodiment, a communication system for transferring a delta of a file is disclosed. The communication system includes a sender site, a file transfer system, and a receiver site. The sender site includes a database with a trove section and a transfer section. The file transfer system includes a trove reader and a transfer reader. The trove reader may communicate with the trove and transfer sections. The transfer reader may have access to the transfer section. The receiver site receives the file delta from the transfer reader. The receiver site includes a file installer, which patches a previously installed version of the file with the file delta.","In another embodiment, the communication system utilizes an available bandwidth more efficiently by transferring the file delta between the sender site and the receiver site.","In a further embodiment, a method of transferring a delta of a file is disclosed. The method includes providing a sender site, a file transfer system, and a receiver site. The sender site includes a database, which has a trove section and a transfer section. The file transfer system has a trove reader and a transfer reader. The trove reader communicates with the trove and transfer sections. The transfer reader has access to the transfer section. The receiver site receives the file delta from the transfer reader. The receiver site includes a file installer, which patches a previously installed version of the file with the file delta.","The use of the same reference symbols in different drawings indicates similar or identical items.","In the following description, numerous details are set forth. It will be apparent, however, to one skilled in the art, that the present invention may be practiced without these specific details. In other instances, well-known structures and devices are shown in block diagram form, rather than in detail, in order to avoid obscuring the present invention.","Reference in the specification to \u201cone embodiment\u201d or \u201can embodiment\u201d means that a particular feature, structure, or characteristic described in connection with the embodiment is included in at least one embodiment of the invention. The appearances of the phrase \u201cin one embodiment\u201d in various places in the specification are not necessarily all referring to the same embodiment.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","102","104","106","108","110","112","114","118","116","100","100","120"]},"In an embodiment, the computer system  includes a Sun Microsystems computer utilizing a SPARC microprocessor available from several vendors (including Sun Microsystems of Palo Alto, Calif.). Those with ordinary skill in the art understand, however, that any type of computer system may be utilized to embody the present invention, including those made by Hewlett Packard of Palo Alto, Calif., and IBM-compatible personal computers utilizing Intel microprocessor, which are available from several vendors (including IBM of Armonk, N.Y.). Also, instead of a single processor, two or more processors (whether on a single chip or on separate chips) can be utilized to provide speedup in operations. It is further envisioned that the processor  may be a complex instruction set computer (CISC) microprocessor, a reduced instruction set computing (RISC) microprocessor, a very long instruction word (VLIW) microprocessor, a processor implementing a combination of instruction sets, and the like.","The network interface  provides communication capability with other computer systems on a same local network, on a different network connected via modems and the like to the present network, or to other computers across the Internet. In various embodiments, the network interface  can be implemented in Ethernet, Fast Ethernet, wide-area network (WAN), leased line (such as T1, T3, optical carrier 3 (OC3), and the like), digital subscriber line (DSL and its varieties such as high bit-rate DSL (HDSL), integrated services digital network DSL (IDSL), and the like), time division multiplexing (TDM), asynchronous transfer mode (ATM), satellite, cable modem, and FireWire.","Moreover, the computer system  may utilize operating systems such as Solaris, Windows (and its varieties such as NT, 2000, XP, ME, and the like), HP-UX, IBM-AIX, Unix, Berkeley software distribution (BSD) Unix, Linux, Apple Unix (AUX), and the like. Also, it is envisioned that in certain embodiments, the computer system  is a general purpose computer capable of running any number of applications such as those available from companies including Oracle, Siebel, Unisys, Microsoft, and the like.","It is envisioned that the present invention may be applied to systems, which utilize RCS and meta data information, individually or in combination. The RCS can be configured as a backend storage system including the actual files. It is envisioned that RCS may be hidden from users. The meta data information can include data about the actual files. The meta data may be stored in a database, such as that provided by Sybase, Inc., of Emeryville, Calif. The meta data may include relational information, block and sector information, file type, and the like.",{"@attributes":{"id":"p-0025","num":"0024"},"figref":"FIG. 2","b":["200","200","1","202","2","204","3","206","1","202","208","210","212","2","204","214","218","3","220","224"]},"Each spoke may have a set of configuration parameters defined in a local or remote database. When the spoke is brought up, the spoke may utilize the configuration parameters to configure itself or auto-configure. Accordingly, each site may be easily reconfigured by, for example, changing the entries in the database that contains the configuration data for each site. Each spoke (\u2013, for example) can have the following configuration parameters defined, in addition to any already existing ones:\n\n","Depending on the above parameters, each spoke can then become a hub or a spoke. Furthermore, in an embodiment, all hubs need not be in pass-through mode, and all spokes may be in store-n-go mode. For example, on a site, if there is a single spoke, it is unnecessary to add another hub on the same site. The only spoke can then act as a hub in store-n-go mode. So, each site may be configured as per the requirements at that site. In an embodiment, some of the advantages of such architecture are that each site only transfers the file once to the other sites, but not to each spoke. This reduces network traffic. Also, such architecture is very scalable, and is highly flexible to accommodate different configurations at each site.","In some embodiments, it is envisioned that hubs may not have users working on them. So, no new files may be created on such hubs. In case a hub hosts users, that hub may be configured similar to a spoke. For example, that hub can transfer the given file locally to all spokes, and transfer a copy to each of the remote hubs.","It is envisioned that a hub may differentiate between the local-domain generated file and the file that it received from a foreign domain. In one embodiment, the receiving entity (or module), for example upon receiving a file, can check to see if the origin site of the file is the same domain as the hub. If so, the file does not need to be routed any further and can be just locally copied. On the other hand, if the domain of the origin site is different, the hub knows that it has to transfer a copy of the file to each of the local spokes.","It is also envisioned that this checking may be performed by, for example, employing a FileReceiver module. The FileReceiver module can receive files and may run as a thread on a general-purpose computer or an appropriate networking device. The FileReceiver upon receiving a file may: (1) ensure that the received file is accurate (for example, by performing checksum validations) and\/or (2) check the file origin (and if the file is foreign, the FileReceiver can route the received file locally). In an embodiment, the step (2) above can be done by the FileReceiver present on a hub rather than on a spoke. In an embodiment, if the FileReceiver module has to route the file, the FileReceiver module can insert entries into, for example, a transfer table in a database (e.g., locally). In one embodiment, there can be one entry per each local spoke in the database. Another process, e.g., a database reader (DBReader such as that discussed with respect to ), can then handle additional work for transferring the file.","Accordingly, the routing information can be stored in a database. In an embodiment, with the above-proposed architecture, each hub may know which domain it belongs to, and what spokes exist on its local domain. Also, each spoke may know to which other spokes and hubs is it directly connected. For example, an entry in a transfer table can be inserted for each spoke and\/or hub that the given local spoke is directly connected to. In certain embodiments, the DBReader module on the local spoke can then handle or initiate the transfers.",{"@attributes":{"id":"p-0032","num":"0034"},"figref":["FIG. 3","FIG. 1"],"b":["300","300","302","304","302","306","308","310","312","306","302","310","310","310","310","306","308","310","306"]},"In an embodiment, the DBReader module  may further communicate with the send daemon . It is envisioned that the send daemon  can be responsible for sending data from the sender site  to the receiver site . The send daemon  can be a Unix daemon thread or other similarly configured process running on a computer system. The send daemon  may be configured to run in the background so it can be activated with short notice. In one embodiment, the send daemon  may be a thread spawned from the DBReader module .","The send daemon  may have access to a local queue  (internal or external to the send daemon ). The local queue  may provide storage capabilities to the send daemon . It is envisioned that the local queue  may be any type of storage such as random access memory (RAM), its varieties such as dynamic RAM (DRAM), static RAM (SRAM), synchronous DRAM (SDRAM), and the like. Further information regarding the local queue  may be found by reference to .","The receiver site  includes a database , an RCS , a monitor , and a remote server . The database  and RCS  may be similar to those of the sender site  (i.e., database  and RCS ). The monitor  can be on lookout for information of interest and inform a selected party (e.g., a user) about the status of the information desired. For example, the monitor  may be a visual aid indicating status of a transfer in real-time. The remote server  can have access to the database , RCS , and monitor . The remote server  may also have access to a remote queue  (RemoteQ). The remote queue  may be a similar device such as that discussed with respect to the local queue . The remote queue  can provide the remote server  with storage capabilities. It is envisioned that the remote queue  may store meta data for the receiver site . Also, the remote queue  may provide memory for delivered job descriptions which are uninstalled. Further information regarding the remote queue  may be found by reference to .","The sender site  can also include one or more file sender(s)  which may communicate with one or more, respective, file receiver(s) . This communication may also utilize acknowledge capabilities to ensure a file is properly transferred. Other error correction capabilities may also be used to ensure proper communication between the file senders  and file receivers . Such error correction capabilities may include parity checking, M0\u20135 checksum validation, and the like. The file senders  may hold all information about the file that is being transferred. Further, it is envisioned that the file sender  may perform one or more of the following: physically transfer a file from the sender site  to the receiver site , obtain acknowledgment regarding the transfer, update a ReceivedTime field (indicating when the data sent was received), for example, in the transfer table that may be stored in the database . The file sender  can be a thread spawned by the send daemon .","The file receiver  may be responsible for one or more of the following tasks: receiving files over, for example, a TCP socket, re-calculating the checksum, verifying file correctness, copying the file into the designated buffer area, sending an ACK\/NAK signal (to acknowledge receipt or non-receipt), remove the current entry (or row) from queue of the remote server , and update the file receiver count at the remote server . In some embodiments, the file receiver  may be a thread spawned by a remote server routine.","The sender site  can additionally include a command sender  for sending commands from the sender site  to a command executor (CE)  on the receiver site . It is envisioned that the command sender  may perform one or more of the following: start a server socket, wait for the acknowledgment from the command executor , and update the appropriate database (such as the database ). Moreover, the command sender  may be a thread spawned by the remote server . Furthermore, the command executor  may perform one or more of the following: connect to the command sender , execute the command (e.g., copy data, delete data, and\/or delete directory), send acknowledgment, and update information about when an action is done in an appropriate database (such as the database ). Moreover, the command executor  may be a thread spawned by the remote server .","In an embodiment, the sender site  can include a command manager (Cmd Mgr)  and a monitor . The monitor  may be similar to that discussed with respect to the receiver site  (i.e., the monitor ). The command manager  is envisioned to be able to communicate (directly or indirectly) with the remote server  and to execute commands. Such commands may, for example, include push data and pull data, which can be used to change the priority on a file that is being transferred, so that it is shipped ahead of or after the rest (or select ones) of the current queue members.","The receiver site  can further include one or more file installer(s) . The file installers  may perform one or more of the following: verify whether meta data of predecessor and object being installed are in place, verify whether the RCS  of predecessor is in place, install the object into the RCS , update object's meta data, send acknowledgment as required, update flags including CompleteTime (indicating the time the installation was complete) and Installation Message (any messages resulting from the installation) on, for example, a source database (where the file being installed is located), and delete any unused buffer files utilized for the installation. It is envisioned that the file installer  may be a thread spawned by the remote server .","It is also envisioned that the send daemon  may perform one or more of the following: perform handshake operations between the sender and receiver sites, initiate a file transfer or a command execution, execute a remote method invocation (RMI) call on the remote server , transfer job description, request\/provide a port number, spawn a file sender (such as ) along with passing relevant port information, spawn a command sender (such as ), wait on the local queue  for more jobs, and keep a balance in the number of existing transport channels. Further, the remote server  may provide remote methods to the send daemon  to initiate a file transfer or a command execution. The remote server  may also keep an account on file receiver\/file installer counts, spawn the file receivers  to receive files, and spawn file installers  when the remote queue  receives a new member.","The communication system  may further include a service provider . The service provider  may provide a variety of services to the system components including one or more of the following: handling periodic registrations from key modules, subscribing and unsubscribing of available monitoring services, routing the monitor messages to the corresponding monitors, and providing a pointer to the correct log file for remote modules. It is envisioned that one service provider  is sufficient for the entire system. In an embodiment, the service provider  may run on a primary site.","Also, the communication system  may further include a database manager module (not shown), which may provide useful application programming interfaces (APIs) to, for example, insert, update, delete, and select information on various tables in the databases present in the communication system . Such a database manager may be implemented as a Java object.","It is envisioned that an interface between a user command and transparent transport layer may be a database. More specifically, this interface may be a transfer table. Such a transfer table may store the required information about each file transfer. Each user command, after successful completion, may in turn deposit a transfer request into the transfer table. Furthermore, it is envisioned that the DB Reader  may be present on all sites where there is a possibility of users checking in files. The DB Reader  having sensed what needs to be transferred can buffer the jobs into the respective queues of the destinations. It also can spawn the send daemon , for each destination and from then on, it may hand over the corresponding queue to it. The send daemon  may then handle the handshake between itself and the remote server , and establish full-duplex communication channels for example, to transfer files and receive acknowledgments. This may involve creation of file sender\u2014file receiver pairs ( and , respectively) on sender and receiver sites, respectively. If the command is other than create or save data, the command sender  and command executor  pairs may be created.","The file sender  can transfer a file, and the checksum of that file over the established channel, and wait for the acknowledgment from the file receiver . The file receiver  having received the file may perform checksum verification between the received checksum, and the re-calculated checksum on the receiver site . If they tally, a positive ACK maybe sent to the file sender . Otherwise, a NAK may be sent. Upon receiving an ACK, the file sender  may update the ReceivedTime in, for example, the transfer table and exit. On receiving a NAK, the file sender  may re-transfer the file. The iteration may be continued until a positive ACK is received, or once the file sender  times out. If the file sender  times out, it may enter a panic state, and send out emails to an appropriate target (such as a system administrator).","Once a file is received correctly, the file receiver  may copy the file to its designated buffer area, and enter the job description into the remote queue , and also register the job in an appropriate (e.g., RemoteQ) table in the database . In case of the remote server  break down, the remote queue  may rebuild the required information from the database . In such a case, the remote server  may start a FileInstaller thread for each file received (such as file installer ). The FileInstaller can be responsible for the installation of the file in the RCS , and for updating a VersionHere bit in a FileVersions table in the database . The FileInstaller may perform a series of checks for the presence of both the predecessor's and the file's meta-data, and also the RCS version of the predecessor. Upon having verified all the dependencies, the file may be checked into the RCS . Then the FileVersions, TransferConfirm, and RemoteQ tables may be notified of the successful installation, and the CompleteTime and Installation Message entries (or columns) may be set on the source database, i.e., the database on the site where the file originated. This process may complete the file transfer procedure in accordance with an embodiment of the present invention.","The above procedure may be applied where the command is either create or save data. If the command is one of delete data, delete directory, or copy data, a command sender (such as the command sender ) may be started instead of the file sender . The command sender  may then wait for the ACK from the corresponding command executor . Having received the ACK\/NAK, the acknowledgment may be recorded in the database , and a panic mail may be sent in case of NAK. In case of delete data or delete directory, a deletor thread may be spawned, for example, as a part of the command sender . This thread may wait for the positive acknowledgments from all the sites, for example, from its VectorOut. Having received them, the deletor thread can delete the RCS files from the local central directory, and then clean the meta-data on its site. This process may replicate to other sites, through meta-data replication, for example.",{"@attributes":{"id":"p-0048","num":"0050"},"figref":["FIG. 4","FIG. 4","FIG. 3"],"b":["400","401","402","404","404","402","406","408","406","410","410","410","406","404","408","406"]},"It is envisioned that in an embodiment the trove section  may include any combination of the following fields: TroveRowId (a unique row identity generated by the database); Command (name of the CDMS++ command, for example); ObjName (CDMS++ name of the file or directory, for example); ObjId (CDMS++ object identity, for example); Version (RCS version of the object); Branch (CDMS++ branch of the file object, for example); OriginSiteId (site identity for the site where the transfer request originated); Priority (transfer priority of the object); InsertTime (time when the job was inserted into the trove section by the CDMS++ command, for example); PredName (ObjName of the predecessor of the current object); PredId (ObjectId of the predecessor of the current object); PredType (type of the predecessor object); PredVer (version of the predecessor file object); PredBranch (branch\/es of the predecessor file object); FileSize (file size in bytes); ToObjName (destination of ObjName, for example, for a copy data command); ToObjId (destination of ObjId, for example, for a copy data command); ToVersions (list of latest version of all branches for the file that is being copied); StorageType (type of backend storage); DeltaFile (location of the file where the delta will be stored); SiteCounter (maximum number of sites to which the corresponding file has to be transferred); ChkSum (stores the ChkSum field of the delta file); and\/or BBlock (which stands for the Byte Block field of the delta file). In an embodiment, the BBlock indicates the number of octets a file can be divided into (or in other words the size of the file).","Additionally, the FTS  may include a trove reader  and a transfer reader . In an embodiment, the transfer reader  may be implemented similarly to the DBReader module  of . In such an embodiment, it is envisioned that the transfer reader  reads both the transfer and trove sections ( and , respectively). In one embodiment, the trove reader  communicates with the trove section , including reading the contents of the trove section , and performs one or more of the following:\n\n","Moreover, in embodiments similar to those discussed with respect to , in case of a save data command, instead of checking out an RCS file (e.g., the RCS ) from, for example, a central directory, the file sender (e.g.,  of ) may only send the delta file. The row object, which is passed to the file sender may have a record of where exactly the delta file is stored.","In accordance with an embodiment of the present invention, in case of a save data command, the file installer (e.g.,  of ), instead of checking in the received file directly, may check out the predecessor version from, for example, the central directory, patch it with delta data, and check the new version into the central directory. The file installer may perform these functions after the dependency checks by verifying the checksum of the buffer file. The file installer may further send appropriate acknowledgments after performing its tasks. Furthermore, in an embodiment, in case of a create data command, the file installer may verify the checksum of the buffer file (after the dependency checks), install the file into RCS, and send the appropriate acknowledgements.","With respect to re-routing, in an embodiment, FileReceivers (e.g., file receivers  of ) may insert one row per transfer job into the trove section  as opposed to inserting multiple rows into the transfer section . Since the routing, in an embodiment, may already be happening with the trove reader , it becomes trivial to re-route transfer requests through the hubs (e.g., hubs of ).","In an embodiment, the checksum calculation (discussed with respect to ) may no longer be done on the file version identified by the row object of, for example, the DBReader module . Instead, checksum verification of the delta data may be calculated by the trove reader  and stored in, for example, the transfer section .","In a further embodiment, a message digest  (MD also known as a one-way hash function) verification may be done after the file (including the delta information, for example) has been installed by the file installer. This can be done by checking out the just checked-in version and calculating its respective MD and comparing the result with the previous MD stored in, for example, the database  of . This confirms at least one of the following two items: first, that the file has been installed in RCS; and second, that the file is in fact correctly installed.","In yet another embodiment, there is a pre-assigned directory on each spoke where the trove reader(s)  store the delta files. These files need to exist as long as the send daemons on the local spoke have not received positive acknowledgments from their respective remote spokes. After receiving positive acknowledgments, the local delta file can be cleaned. This may be accomplished by making use of the Sybase XP technology in an embodiment. As discussed above, the trove section  may have a SiteCounter field which stores the maximum number of sites to which the corresponding file has to be transferred. The SiteCounter is decremented each time an ACK (or positive acknowledgment) is received. Once the counter reaches zero, a trigger may be fired to run a stored procedure, which may in turn make a system call, for example, to perform a cleanup of the corresponding delta file(s).",{"@attributes":{"id":"p-0057","num":"0065"},"figref":["FIG. 5","FIG. 4","FIG. 4","FIG. 4"],"b":["500","500","502","500","406","504","506","5","508","500","510","512","514","408","516","500","406"]},"Therefore, in accordance with some embodiments of the present invention, the procedure for receiving a file at a recipient site is independent of installing the file on the recipient site. This bifurcation is envisioned to yield better performance, be more tunable, provide improved control, and allow for load balancing (for example, among distributed systems). Also, some embodiments of the present invention address the problems associated with keeping live data on a particular site, spoke, or a domain, in sync with the data on multiple remote spokes in real-time. In a user community distributed across a country or anywhere in the globe, the need arises to have select data be available on any site at any time. Embodiments of the present invention provide users access to the latest version of the data as soon as it is released into the system from any site. Therefore, there should not be a need to wait for the new data until there is a batch update or a nightly synchronization, for example.","Additionally, if one of the remote sites is down or cannot accept external data, the systems provided in accordance with some embodiments of the present invention can temporarily store (e.g., buffer or queue) the new data until the remote spoke is back on-line. Further, the system can work with the configuration control mechanisms (CCM) on each site and can install the new data into the CCM on the remote sites. Additionally, the system can work with meta data (if any) in, for example, the backend database storage, so that the user commands or interfaces to the database function accurately during any synchronization process.","Furthermore, in an embodiment, the present invention works with a FTS to extract the difference (or the delta) from a file and its previous version. It then calculates the checksum for the delta. The delta and the checksum are then sent to the appropriate remote sites. This reduces the network traffic and also speeds up the transfer rates. This technique works very well with an FTS and is very useful in terms of doing optimal pre-transfer computations. Also, it is envisioned that this technique is especially helpful in situations where relatively large files, with relatively small deltas, would have to be synchronized across multiple remote sites.","In one embodiment, the present invention takes care of polling the transfer requests from the database, calculating the delta, calculating the checksum, storing them appropriately so that they can be used by all the send daemons that are functional on the current site. In this fashion, each send daemon may read the delta and send it, and need not compute or checkout any file from the respective RCS. As such, the pre-transfer overhead is greatly reduced.","The foregoing description has been directed to specific embodiments. It will be apparent to those with ordinary skill in the art that modifications may be made to the described embodiments, with the attainment of all or some of the advantages. For example, the schemes, data structures, and methods described herein can also be extended to other applications. More specifically, any type of data may be transferred utilizing embodiments of the present invention. Also, the transfer systems provisioned in accordance with embodiments of the present invention may be configured depending on a specific project, data types, number of users, size of files, location of users, and the like. Further, the routines described herein may be implemented utilizing Java programming techniques. Therefore, it is the object of the appended claims to cover all such variations and modifications as come within the spirit and scope of the invention."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF DRAWINGS","p":["The present invention may be better understood and its numerous objects, features, and advantages made apparent to those skilled in the art by reference to the accompanying drawings. These drawings, however, should not be taken to limit the invention to the specific embodiments, but are for explanation and understanding only.",{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 1","b":"100"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 2","b":"200"},{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 3","b":"300"},{"@attributes":{"id":"p-0015","num":"0014"},"figref":"FIG. 4","b":"400"},{"@attributes":{"id":"p-0016","num":"0015"},"figref":"FIG. 5","b":"500"}]},"DETDESC":[{},{}]}
