---
title: Using domains for physical address management in a multiprocessor system
abstract: A multi-processor computer system is provided for managing physical memory domains. The system includes at least one processor having an address interface for sending a memory access message, which includes an address in physical memory and a domain identification (ID). The system also includes a physical memory portioned into a plurality of domains, where each domain includes a plurality of physical addresses. A domain mapping unit (DMU) has an interface to accept the memory access message from the processor. The DMU uses the domain ID to access a permission list, cross-reference the domain ID to a domain including addresses in physical memory, and grant the processor access to the address in response to the address being located in the domain.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08190839&OS=08190839&RS=08190839
owner: Applied Micro Circuits Corporation
number: 08190839
owner_city: San Diego
owner_country: US
publication_date: 20090311
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND OF THE INVENTION","SUMMARY OF THE INVENTION","DETAILED DESCRIPTION","Functional Description"],"p":["1. Field of the Invention","This invention generally relates to computer memory management and, more particularly, to a means for managing physical memory addresses in a system using multiple processors.","2. Description of the Related Art","Physical memory, as used herein, is the actual memory device(s) (DRAM, SRAM, FLASH, etc.) where data is stored. In processing, two types of information are generally stored in this memory\u2014data and instructions. Data is the working set of constants and variables that software acts upon. Instructions are the list of commands or operations that are to be carried out on the data. Access to the memory is done through an address. Each location in memory has a unique address. The address of the actual physical devices is referred to as the physical address, or sometimes, real address.","In the early days of microprocessors, the address generated by software (SW) to access a memory location, was always a physical address. The working area that contained both the instructions and the data was called the working set. In the early days one, and only one, program would execute at a time on the computer, so operations were simple. Later, the notion of operating systems and applications was introduced. This meant that more than one SW program was resident on the computer and the processor could switch back and forth between these programs. Since multiple programs had access to all of physical memory it was possible for a bug or mistake in one program to corrupt the working set of another program. For example, if a first program made a mistake with an address pointer calculation, the wrong address might be written, perhaps overwriting the instructions for a second program. When the second program sequentially stepped through its instruction list and landed on a corrupted instruction, the computer would crash.","To get around this problem, the notion of virtual memory addressing was introduced. Each application is given a virtual address space to work within. The memory management unit and address translation mechanism permit the virtual address space to be translated to the actual physical memory where the storage of data and instructions actually exists. Alternately stated, software executes in what is called virtual address space. Each application, as well as the operating system (OS), \u201clive\u201d in their own virtual address map. However, the processor must ultimately use physical addresses in memory. So, an association has to be made between the virtual address space and the physical address space. The OS does this association and makes assignments to the individual applications using a memory allocation software routine.","When the system first boots, the OS builds an overall physical address map of the system. Memory is mapped in chunks called pages. A page table is built in memory by the OS with entries for each page called page table entries (PTE). Each page table entry includes the virtual page number, the associated physical page number, and any additional attribute bits related to the virtual or physical address. For example, each virtual address also includes the a Process Number associating a particular application with its physical address space.","A programmer writes their program with a specific address map in mind for the data structures to be accessed. Physical address cannot be used in the program because the programmer cannot know in advance if the addresses they might select are available or being used by another program. The memory management unit acts as a translation mechanism between the virtual address space where the program is executing and the actual physical address space where the instructions and data actually reside. As an example, when both application A and application B want to write address 0x0001 4000, a translation might be made such that the actual physical location for A is 0x00F0 1000 and for B is 0x000C 1000. This assignment of virtual to physical address translation is made by the Operating System in what is called a memory allocation routine or MALLOC.","But, if more than one operating system is being used in the system, it becomes possible for a first OS to assign the same physical address space to a first SW application, as a second OS might assign to a second application. In this circumstance, a Hypervisor and Virtualization become necessary. Now, a second level of address management software must run on the microprocessor, which assigns virtual address spaces and associated physical address translations to the individual OSs. The current art for cross-referencing virtual and physical addresses requires adding \u201cextra\u201d bits to the virtual side of the address, essentially expanding the virtual address. This expansion of the virtual address requires running some additional code (e.g., the Hypervisor). The advantage of this approach is that multiple OSs can then coexist on the same processor core. However, this approach does require an additional software layer (Hypervisor) to be active to manage that assignment on the virtual side.","It is not possible to use a Hypervisor if the system is using multiple heterogeneous asymmetric processors. Symmetric multiprocessing (SMP) is a system of computer architecture where two or more identical processors are connected to a single shared main (physical) memory. Further, each processor participating in the SMP system must coordinate together to manage memory. SMP systems permit any processor to work on any task no matter where the data for that task is located in memory. SMP systems can move tasks between processors to balance the workload efficiently. Asymmetric multiprocessing (AMP) refers to a system whereby multiple processors independently run operating systems with no awareness of each other. In this case there is no memory management coordination between the operating systems. Heterogeneous processors in this context are processors that have different programming models especially where memory management is concerned. Given the incompatibilities in memory management mechanisms between processors in a heterogeneous asymmetric multiprocessor, it is generally not pragmatic to use a Hypervisor.","Modern general purpose Harvard architecture processors typically include a multi-level cache hierarchy. The cache memory subsystem aids in delivering of commonly used instructions or data to the execution unit with the lowest latency possible. The average access latency is a key component to the execution performance of a software application.","The access time of a cache is based on the physical constraints of the access time of the SRAM arrays and logic associated with the cache controller. A larger cache has a physically larger array and, thus, the access latency due to lookup overhead and wire delays increases. Therefore, a processor typically has a moderately small first level cache (L1) in order to provide the best trade off in access latency vs. cache hit ratios. Subsequently, a second level cache (L2) is responsible for reducing cache miss penalty by caching a larger portion of the working set. This is done by providing a much larger cache array size, and comes with a penalty of longer access latency.",{"@attributes":{"id":"p-0014","num":"0013"},"figref":"FIG. 1"},"Certain applications require deterministic behavior as part of their operating characteristics. For example, real-time or deadline based computing often found in embedded applications requires a certain amount of computation be completed within a predetermined time period. Given a cache shared by multiple concurrent software processes, and further by multiple processors, the access latency for a thread is not guaranteed to be consistent due to the varied interactions of the other threads.","One solution has been to allow software configurable partitioning of the shared cache based on each physical processor that is sharing the cache. Such partitioning is implemented as part of the cache allocation scheme of the cache controller. For a two-CPU system, software running on CPU A is allocated use of space A in the cache, while CPU B is allocated space B. Such partitioning is very coarse and does not allow for inter-processor behaviors, especially where larger numbers of cores exist. Further, it does not address the specific behaviors and needs of different software operating on the same processor core.","The reduction in performance and access determinism is primarily due to two factors\u2014the first is cache line replacement. This is the case where two or more threads are concurrently sharing a common cache. As these threads interact with the cache they compete for the limited resource, thus, randomly replacing cache elements that the other is potentially using, now or in the near future. In this circumstance, a change of code in one thread may adversely impact the performance of another thread.","The second item that impacts cache access latency is blocking. Blocking is the condition whereby two processors are accessing a common cache tag in order to examine if the desired cache element is currently resident in the cache. Since coherency must be maintained, one and only one access to a particular cache address can occur at a time.",{"@attributes":{"id":"p-0019","num":"0018"},"figref":"FIG. 2"},"It would be advantageous if a mechanism existed that permitted a physical memory to be efficiently shared between processors.","It would be advantageous if the above-referenced mechanism could be enabled in hardware, without implementing an additional software layer such as a Hypervisor.","Disclosed herein is a means to enable combined subsystems on a multicore processor with configurable partitioning. For example, some cores might be dedicated to a symmetric multiprocessing (SMP) shared memory domain, while others may work in separate partitions as individual single core subsystems.","Accordingly, a multi-processor computer system is provided for managing physical memory domains. The system includes at least one processor having an address interface for sending a memory access message, which includes an address in physical memory and a domain identification (ID). The system also includes a physical memory portioned into a plurality of domains, where each domain includes a plurality of physical addresses. A domain mapping unit (DMU) has an interface to accept the memory access message from the processor. The DMU uses the domain ID to access a permission list, cross-reference the domain ID to a domain including addresses in physical memory, and grant the processor access to the address in response to the address being located in the domain. The DMU fails to grant access to the address if the permission list does not locate the address in a domain cross-referenced to the domain ID.","For example, the DMU accepts a first memory access message from a first processor, with a first address in physical memory and a first domain ID. Further, the DMU accepts a second memory access message from a second processor, with a second address in physical memory and a second domain ID. The DMU uses the first and second domain IDs to access the permission list, and grants access to the first and second addresses, in response to the permission list locating the first and second addresses in a shared domain cross-referenced to the first and second domain IDs.","In one aspect, the system includes a plurality of operating systems (OSs) enabled as computer readable code and a plurality of memory management units (MMUs). Each MMU includes a page table map of virtual memory addresses cross-referenced to addresses in the physical memory, and the domain ID associated with each address in physical memory. A plurality of processors is included, and each processor is associated with a corresponding OS and MMU. In this aspect, at least two of the processors are heterogeneous, in that they have different MMU algorithms for associating virtual addresses to addresses in physical memory. However, the DMU permits the physical memory to be accessed, without conflict, by the heterogeneous processors, as long as the addresses in the memory access message match domains to which the domain IDs are cross-referenced.","Additional details of the above-described system, and a method for managing physical memory domains in a multi-processor computer system, are provided in more detail below.",{"@attributes":{"id":"p-0037","num":"0036"},"figref":"FIG. 3"},"The system  comprises a processor  having an address interface on line  for sending a memory access message including an address in physical memory and a domain identification (ID). A physical memory  is portioned into a plurality of domains, where each domain includes a plurality of physical addresses. Shown are domains through . In this example, n is a variable equal to 3, but the system is not limited to any particular number of domains.","A domain mapping unit (DMU)  has an interface on line  to accept the memory access message from the processor . The DMU  uses the domain ID to access a permission list , and cross-references the domain ID to a domain that includes addresses in physical memory . The DMU  grants the processor access to the address in response to the address being located in the domain. Typically, \u201caccess\u201d involves either a read or write operation. As explained in more detail below, the memory access message may include information to define the type of access allowed.","For example, the processor  sends a memory access message with the address of \u201c0000\u201d and a domain ID of AA. The DMU cross-references domain ID AA to domain , and notes that address \u201c0000\u201d is located in domain . As a result, the processor is granted access to address \u201c0000\u201d. In another example, the DMU  accepts a memory access message with an address in physical memory (e.g., \u201c0000\u201d) and a domain ID (e.g., BB), and uses the domain ID to access the permission list, as described above. The DMU  fails to grant access to the address if the permission list does not locate the address in a domain (e.g., ) cross-referenced to the domain ID (BB).","As another example, the DMU  accepts a first memory access message from a first processor , with a third address in physical memory and a third domain ID. Further, the DMU  accepts a second memory access message from a second processor , with a second address in physical memory and a second domain ID. The DMU  uses the second and third domain IDs to access the permission list, and grants access to the second and third addresses, in response to the permission list locating the second and third addresses in a shared domain cross-referenced to the second and third domain IDs. For example, the second address may be \u201c1111\u201d, the third address \u201c11AA\u201d, the second domain ID ZZ, and the third domain ID XX. If the XX and ZZ domain IDs both cross-reference to domain , and addresses \u201c1111\u201d and \u201c11AA\u201d are both located in domain , then both the first and second processors are granted access to the requested addresses.","In one aspect, the system  includes an operating system (OS) enabled as computer readable code. For convenience, the OS is shown as a module, but it should be understood that an OS is a type of software application made up of instructions stored in a memory that are operated upon by a processor. These instructions may be referenced using virtual addressing, however, the OS instructions are actually stored in a physical memory. More explicitly, an OS is responsible for the management of software applications, the coordination of activities, and the sharing of computer resources. By using the OS as an interface to the hardware, an application is relieved of management details, making the applications easier to write. Applications access OS services through application programming interfaces (APIs) or system calls. By invoking these interfaces, the application can request a service from the operating system, pass parameters, and receive the results of the operation.","A memory management unit (MMU)  includes a page table map  of virtual memory addresses cross-referenced to addresses in the physical memory, and the domain ID associated with each address in physical memory. An MMU is a computer hardware component responsible for handling accesses to memory requested by a processor. For example, the MMU  may be embedded in a load store unit of a processor, which connector the processor to the memory system. An MMU typically divides the virtual address space into pages, each having a size which is a power of 2, usually a few kilobytes. The bottom n bits of the address (the offset within a page) are left unchanged. The upper address bits are the (virtual) page number. The MMU normally translates virtual page numbers to physical page numbers via an associative cache called a Translation Lookaside Buffer (TLB), which is also referred to as page table map . The data found in such a data structure is typically called a page table entry (PTEs), and the data structure itself is typically called a page table. The physical page number is typically combined with the page offset to give the complete physical address.","Each TLB entry typically carries descriptors that tell the system hardware how to treat memory accesses. Some example descriptors include address space cacheability, globally visibility, write through vs. write back, process number, and the allocation policy to be followed. Globally visible refers to an address space that is shared by other processors and associated caches, thus requiring a mechanism to maintain coherency. In addition to the table entry including the virtual page number and associated physical page number, the above-mentioned descriptors may be added as additional attribute bits related to a virtual or physical address.","More explicitly, additional attribute bits are added to the physical side of the PTEs, called domain bits. During typical operation, domain mappings are made during system initialization. Each OS is assigned to one or more domains and given those numbers (domain IDs). If multiple OSs coexist sharing the same physical address space, then the domain mechanism is used to make sure that one OS doesn't allocate or use a non-assigned physical address space.","During runtime, the OS or an application calculates and generates address pointers within their allocated virtual memory space. When a load or store instruction occurs, the virtual memory address lookup occurs in the processor's MMU. This lookup results returns the associated physical address and the additional attribute (domain) bits.","The DMU contains a list of associations between domain bits and address spaces. When a load or store operation is generated by a processor, the DMU uses the domain bits as a lookup to check whether the operation is allowed to the specific address that was generated. In this way multiple processors can share the same physical address map each running independent OSs, without fear of address map collisions.","In contrast, the current art for the performance of similar operations is enabled in virtual memory. This solution requires that additional bits be added to the virtual side of the address, which essentially expands the virtual address. This expanded virtual address requires the running of a top layer application called a Hypervisor. While this approach permits multiple OSs to coexist on the same processor core, the additional Hypervisor software layer requires extra processing steps. Further, the Hypervisor approach breaks down in a system using heterogeneous or asymmetric processors. The claimed invention's use of domains is enabled in hardware as the physical memory is accessed.","Thus, the OS  is assigned addresses in a physical memory domain at initialization, builds the page table map, and loads the page table map into the MMU . The DMU  builds the permission list cross-referencing domain IDs to domains at initialization.","In a different aspect, the system further includes at least one application  enabled as processor readable code. Shown are applications through , where t is an unlimited variable. For convenience, the applications are shown as modules, but it should be understood that an application or program is made up of instructions stored in a memory that are operated upon by a processor. The OS  allocates a unique portion of virtual memory to the application, and the MMU  includes a page table map of application addresses in virtual memory cross-referenced to addresses in the physical memory.",{"@attributes":{"id":"p-0051","num":"0050"},"figref":["FIG. 4","FIG. 3"],"b":["400","400","400","402","402","402"],"i":["a ","p","a ","r"]},"A plurality of processors through are shown, where s is an unlimited variable (in this example, equal to 3). Each processor  is associated with a corresponding OS and MMU. At least two of the processors are heterogeneous (e.g., processors and ), having different MMU algorithms for associating virtual addresses to addresses in physical memory. For example, processor may be a general purpose computer processing unit (CPU), while processor is a data management application (DMA) engine. The CPU and the DMA engine have completely different memory management models. As another example, the processors may be an ARM processor and a PowerPC processor. However, the DMU  permits the physical memory to be accessed by the heterogeneous processors, without conflict or the possibility of cross-corruption.",{"@attributes":{"id":"p-0053","num":"0052"},"figref":["FIG. 5","FIG. 3"],"b":["302","400","400","302","402","306","500"],"i":["a ","b"]},"Returning to , the plurality of processors through may all be homogeneous processors. Each processor  is associated with a corresponding OS  and MMU . Each processor  receives a request to access virtual memory addresses from its corresponding OS , accesses its corresponding MMU  to recover cross-referenced addresses in physical memory and associated domain IDs, and sends the addresses in physical memory and domain IDs to the DMU  as memory access messages.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":["FIG. 6","FIG. 3"],"b":["400","402","700","302","302","702","302","302"],"i":["a ","n","o ","z"]},"Each processor from the first and second subsystems receives requests to access virtual memory locations from an OS, accesses an MMU to recover cross-referenced addresses in physical memory and associated domain IDs, and sends the addresses in physical memory and domain IDs to the DMU as memory access messages.",{"@attributes":{"id":"p-0057","num":"0056"},"figref":["FIG. 7","FIG. 3"]},"The DMU may also use the domain ID as an index to access a permission list look-up table to discover the following types of information: the base address associated with an OS, an address range, permission types, and steering information. The DMU reads addresses in physical memory from the look-up table, compares the addresses from the look-up table to the address in the memory access message, and grants access to the physical memory in response to matching addresses.","Permissions would include making a space \u201cread-only\u201d vs. \u201cwrite-only\u201d vs. \u201cread-write\u201d. So it is possible to set up a producer-consumer arrangement where one OS has only the rights to write data into a memory location, while another OS has only rights to read data from that same memory location. The domain programming controls such a privilege in the physical address map.","Steering information is used to determine what to do with the transaction based on the address and domain information. For example, if a transaction can be steered into multiple paths, steering information bits can be used to make that steering determination without requiring a full address decode.",{"@attributes":{"id":"p-0061","num":"0060"},"figref":"FIG. 8","b":["0","1","0","0","1","1","0","0","1","1","0","1","2","2"]},{"@attributes":{"id":"p-0062","num":"0061"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0063","num":"0062"},"figref":"FIG. 10","b":"1100"},"At a DMU, Step  accepts a memory access message, including an address in physical memory and a domain identification (ID), from a processor. Step  accesses a permission list cross-referencing domain IDs to domains of addresses in physical memory. In Step  the DMU grants the processor access to the address in physical memory, in response to the address being located in the domain. Alternately, in Step , the DMU fails to grant access to the address in physical memory if the permission list does not locate the address in a domain cross-referenced to the domain ID.","In one aspect, accepting the memory access message in Step  includes accepting a first memory access message from a first processor, with a first address in physical memory and a first domain ID. Further, Step  accesses a second memory access message from a second processor, with a second address in physical memory and a second domain ID. Accessing the permission list in Step  includes the DMU using the first and second domain IDs to access the permission list. Then, granting the processor access to the address in physical memory in Step  includes granting access to the first and second addresses, in response to the permission list locating the first and second addresses in a shared domain cross-referenced to the first and second domain IDs.","In another aspect, Step  generates a plurality of page table maps of virtual memory addresses cross-referenced to addresses in the physical memory, and the domain ID associated with each address in physical memory. Step  accepts memory access messages from a corresponding plurality of processors, including at least two heterogeneous processors having different MMU algorithms for associating virtual addresses to addresses in physical memory. Step  grants the heterogeneous processors access to the addresses in physical memory, in response to addresses being located in corresponding domains. Alternately, Step  accepts memory access messages from homogeneous processors, and access by the homogeneous processors is granted in Step , in response to addresses being located in corresponding domains.","In another variation, Step  accepts a plurality of memory access messages from a processor, each memory access message associated with a corresponding OS. Then, Step  grants access to the memory access messages associated with each OS, in response to addresses being located in corresponding domains. If Step  accepts memory access messages from a first subsystem including a plurality of symmetric processors and a second subsystem including a plurality asymmetric processors, Step  grants access to the processors in the first and second subsystems, in response to addresses being located in corresponding domains.","In one aspect, accessing the permission list in Step  includes using the domain ID as an index to access a permission list look-up table including the base address associated with an OS, an address range, permission types, and steering information. Then, granting access to the address in physical memory in Step  includes the DMU reading addresses in physical memory from the look-up table, comparing the addresses from the look-up table to the address in the memory access message, and granting access to the physical memory in response to matching addresses.","In another aspect, Step  accepts a memory access message including an access type. Then, failing to grant access to the address in physical memory in Step  includes failing to grant access to the address if the received access type does not match the permission type listed in the permission list.","A system and method have been provided for managing physical memory domains in a multi-processor computer system. Examples of particular message structures, processor, and hardware units have been presented to illustrate the invention. However, the invention is not limited to merely these examples. Other variations and embodiments of the invention will occur to those skilled in the art."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0027","num":"0026"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0028","num":"0027"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0029","num":"0028"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0030","num":"0029"},"figref":["FIG. 4","FIG. 3"]},{"@attributes":{"id":"p-0031","num":"0030"},"figref":["FIG. 5","FIG. 3"]},{"@attributes":{"id":"p-0032","num":"0031"},"figref":["FIG. 6","FIG. 3"]},{"@attributes":{"id":"p-0033","num":"0032"},"figref":["FIG. 7","FIG. 3"]},{"@attributes":{"id":"p-0034","num":"0033"},"figref":"FIG. 8"},{"@attributes":{"id":"p-0035","num":"0034"},"figref":"FIG. 9"},{"@attributes":{"id":"p-0036","num":"0035"},"figref":"FIG. 10"}]},"DETDESC":[{},{}]}
