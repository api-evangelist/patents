---
title: Notification for a set of sessions using a single call issued from a connection pool
abstract: A server-to-server notification model that employs a connection pool such that an asynchronous request issued from the pool can access any session of the remote server for pending notifications on all of the sessions. Only one asynchronous request (or call) is issued to the remote server for all sessions in the connection pool, and the call is completed if any notifications to any participating sessions occur on the remote server. When the asynchronous request completes, the returned data provides a set of the sessions that have pending notifications.
url: http://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO2&Sect2=HITOFF&p=1&u=%2Fnetahtml%2FPTO%2Fsearch-adv.htm&r=1&f=G&l=50&d=PALL&S1=08886787&OS=08886787&RS=08886787
owner: Microsoft Corporation
number: 08886787
owner_city: Redmond
owner_country: US
publication_date: 20090226
---

{"@attributes":{"id":"description"},"BRFSUM":[{},{}],"heading":["BACKGROUND","SUMMARY","DETAILED DESCRIPTION"],"p":["In server-to-server communications when multiple sessions are created, multiple asynchronous requests (e.g., remote procedure call (RPC) calls) can consume a significant amount of server resources. The requests are mapped one-to-one to the sessions. If a request is made from a local server to a remote server, and the requested information is unavailable (the session is idle), the connection is wasted. The number of active connections can be in the thousands from one process to another process. Reducing the number of requests, such as for change notifications, and responses to those requests will have a substantial performance improvement for the entire system.","The following presents a simplified summary in order to provide a basic understanding of some novel embodiments described herein. This summary is not an extensive overview, and it is not intended to identify key\/critical elements or to delineate the scope thereof. Its sole purpose is to present some concepts in a simplified form as a prelude to the more detailed description that is presented later.","The disclosed architecture is a server-to-server notification model that employs a connection pool such that an asynchronous request issued from the pool can access any session of the remote server for pending notifications on all of the sessions. Only one asynchronous request (or call) is issued to the remote server for all sessions in the connection pool, and the call is completed if any notifications to any participating sessions occur on the remote server. When the asynchronous request completes, the returned data provides a list of the sessions that have pending notifications.","To the accomplishment of the foregoing and related ends, certain illustrative aspects are described herein in connection with the following description and the annexed drawings. These aspects are indicative of the various ways in which the principles disclosed herein can be practiced and all aspects and equivalents thereof are intended to be within the scope of the claimed subject matter. Other advantages and novel features will become apparent from the following detailed description when considered in conjunction with the drawings.","The disclosed architecture improves server-to-server communications where many sessions are created between the servers. Multiple connections (e.g., asynchronous remote procedure calls (RPC's) can consume a significant amount of server resources. Reducing the number of asynchronous requests (e.g., RPC calls) that are made between servers improves performance for the entire system.","The architecture decreases the number of active requests that occur between a middle tier server and a backend server, for example. Consider that in reality where the number of sessions can be in the thousands, the number of active requests can now be reduced significantly by factors at any given point in time, rather than equivalent thousands in current systems.","The architecture obtains a connection from that pool only for the duration that the connection is needed and then releases the connection to the connection pool. A connection pool is a group of connections (e.g., RPC) opened between a local server (and store) and a set of sessions (or session objects) in a remote server, where the sessions are associated with the connections.","There can be several connection pools created on the local server, and each connection pool manages requests and sessions open on a single backend server. Similarly, there can be multiple connection pools created on the backend, each with a set of sessions associated with the connection pool.","In other words, there is no longer a one-to-one mapping established between connections (e.g., RPC handles) and session objects. Each connection in the pool can be used to perform requests with any session associated with the pool.","Reference is now made to the drawings, wherein like reference numerals are used to refer to like elements throughout. In the following description, for purposes of explanation, numerous specific details are set forth in order to provide a thorough understanding thereof. It may be evident, however, that the novel embodiments can be practiced without these specific details. In other instances, well known structures and devices are shown in block diagram form in order to facilitate a description thereof. The intention is to cover all modifications, equivalents, and alternatives falling within the spirit and scope of the claimed subject matter.",{"@attributes":{"id":"p-0020","num":"0019"},"figref":"FIG. 1","b":["100","100","102","104","106","108","110","112","114","110","112","110","106","110","112","102","114"]},"The session data can be a list of all sessions (e.g., Sessionand Session, but not Session) of the remote server  having pending change notifications. The return component  completes the request in response to receiving the session data. The request can be an RPC handle issued asynchronously by the local server  to the remote server  for the one or more notifications . The local server  can be a middle tier messaging server (e.g., email) and the remote server  can be a backend messaging server.","The request can be queued in the remote server  and completed in response to a notification that occurs after the request is sent. The request can also be queued, and then immediately completed in response to a notification that occurred before the request was sent. The request can use a handle of an RPC connection and the handle is released back to the connection pool  upon completion of the request.","Note that the remote server  can include the same functionality such that the remote server  issues the asynchronous request to the local server  for a list of all sessions in the local server  that have change notifications.",{"@attributes":{"id":"p-0024","num":"0023"},"figref":"FIG. 2","b":["200","200","102","110","106","200","114","110"]},"The call is an RPC using a connection  in the connection pool . The call is issued asynchronously through the CP  to the remote server and the connection is released back to the connection pool  when the call completed. The completion of the RPC call returns a list, string, expression, etc., (e.g., denoted Sessions: (1,N)) that represents all sessions in the connection pool  that have pending notifications. The call can be queued in the remote server, and then completed in response to a notification that occurs in one of the sessions. Alternatively, the call is issued and immediately completed in response to notifications that occurred before the call was issued.",{"@attributes":{"id":"p-0026","num":"0025"},"figref":"FIG. 3","b":["300","302","304","306","302","304","306","302","308","304","310","302","312","306","314","102","114","318"]},"The access component  can send separate single requests to each of the servers ( and ) for the status of change notifications. In other words, a first request (denoted Request) from the access component  can be sent over a connection  selected from the first connection pool  to a third session  (denoted Session) of the second server . Similarly, a second request (denoted Request) from the access component  can be sent over a connection  selected from the second connection pool  to a first session  (denoted Session) of the third server .","Since there are already change notifications  that are pending for the sessions  of the first connection pool , the second server  replies to the first request with a list of all sessions of the sessions  that have pending notifications. Thus, the list that includes identifiers of a first session  and the third session  of the second server  is returned over the same connection  to the access component . Once the first request is completed, the connection  is returned to the first connection pool .","Similarly, since there are already change notifications  that are pending for the sessions  of the second connection pool , the third server  replies to the second request with a list of all sessions of the sessions  that have pending notifications. Thus, the list from the third server  includes identifiers of the first session , a second session , and a third session  and is returned over the same connection  to the access component . Once the second request is completed, the connection  is returned to the second connection pool .","The first server  can be a mid-tier messaging server, for example, and the second and third servers ( and ) can be backend messaging servers, or other types of servers.",{"@attributes":{"id":"p-0031","num":"0030"},"figref":"FIG. 4","b":["400","402","302","304","304","404","304","404"]},"In a second scenario , two notifications  are pending in the second server  for one or two sessions. The first server  sends a second asynchronous request to the second server . The second server  then immediately processes the second request, rather than having to wait, as in the first scenario . The second server  sends a list that includes the session identifier(s) for the session(s) for which the two notifications  have occurred, and the request is completed.","Following is a more detailed description of a specific implementation for a middle-tier notification model for RPC as the main transport. A connection pool is then a pool of RPC handles opened between the middle-tier server (e.g., email) and a set of session objects associated with the connections on the backend server(s). On the middle-tier side a session is implemented in a connect object, while on the backend server side a session is implemented in MAPI (messaging application programming interface) session.","There can be several connection pools created on the mid-tier side. Each connection pool manages RPC handles and sessions open on a single backend server. Similarly, there can be multiple connection pools created on the backend server, each backend connection pool having a set of sessions associated with the connection pool.","In other words, there is no longer a one-to-one mapping established between RPC handles and session objects. Each RPC handle in the pool can be used to perform operations with any session associated with the pool. Each session within the pool is identified by a session handle.","An RPC interface is created to manage connection pools and perform operations on the backend (or remote) server. The interface can include three groups of functions: pool connects and disconnects, session creation and closing, and waiting for notifications. The connect and disconnect APIs manage RPC handles in the connection pool. The session creation and closing APIs manage MAPI sessions and execute operations identified by operation codes for an RPC request. The utilization of the operation codes facilitates the use of a single signature of an RPC method to perform various operations on the backend (or remote) server and extends these operations easily with less version-related issues. The notification API is an asynchronous RPC method to inform the connection pool that some of the sessions in the pool have pending notifications.","The session close function can utilize parameters related to an RPC handle from the pool to use for this operation, and the handle of the session in the pool to close.","A pool session RPC function can utilize parameters related to the RPC handle from the pool to use for this operation, the handle of the session to perform the operation, in\/out parameter with flags, and so on.","The notification function can take parameters related to the RPC handle from the pool to use for this operation, the out parameter to receive the length of the response data, and the out parameter to receive the response data.","There can be multiple connection pool objects created on the backend server. All connection pool objects are stored in a global mapping table that maps an identifier (e.g., a GUID (globally unique identifier), serial number of a pool created since last server restart, etc.) to the pool. RPC handles from all connection pools can share the same value space, and each RPC handle can be used to identify a connection pool. The pool includes at least one active RPC handle. If a last RPC handle is closed, the pool is destroyed. However, the pool may have no active sessions open, and the pool is not destroyed when the last session is disconnected.","All sessions created within a connection pool are linked to the connection pool. All sessions created in the same pool remain open until closed explicitly, or when a pool is destroyed as a result of the cleanup of server resources allocated to a client, for example.","The pool functionality is implemented by pool, pool reference, and pool manager classes. The manager class is responsible for RPC handle management. The reference class represents a connection pool reference identified by a pool identifier, and the pool class represents the connection pool itself.","When a pool connect request is received, and the pool identifier is a zero identifier, a new pool object is created and a new RPC handle is created. If the pool identifier is not zero, then new handle is created in the pool identified by the pool identifier.","Each handle contains a reference to the pool reference, which in turn contains a reference on the pool itself. Every time a new handle is created, a reference count on the pool reference class is increased by one. Every time a handle is closed, either explicitly or via RPC cleanup, a reference on the pool reference class is decremented by one. When last reference to the pool reference class instance is released, the instance itself is destroyed and a reference to pool class is released.","When an RPC call is processed and requires access to a connection pool, a reference count on the corresponding pool instance is incremented by one. When the RPC call completes, the reference is decremented by one. When the last reference to the pool instance is released, the instance is destroyed, and all MAPI sessions which are still open under that pool are closed.","Since references on pool reference and pool are maintained independently, it is guaranteed that the pool will remain alive as long as there are outstanding RPC calls which need it.","All operations on the RPC handles and pool reference instances can be protected by a global reader-writer lock. All operations which manipulate the state of the pool instance can be protected by a reader-writer lock on the instance.","In one implementation, the connection pool functionality is available only to the middle-tier server.","There can be multiple connection pools created in the middle tier to allow communication with different backend servers. There is only one connection pool created for any given backend server. Connection pool objects can be identified by the backend server name. A connection pool can be created on demand when a first session to a backend server is created. The connection pool is destroyed either on RPC layer shutdown, or when the RPC layer throws an exception which is fatal for the pool.","If no connection pools exist for the given backend server, a new pool is created. Every time the mid-tier needs to perform an operation, an RPC handle is retrieved from the pool. If there are no free handles in the pool and the pool has not reached its maximum size, a new RPC handle is created and added to the pool. If the pool is at its maximum size, all incoming calls have to wait on the pool semaphore until a handle is returned to the pool.","As a brief overview of notifications, an asynchronous RPC method is used by the mid-tier RPC layer to receive notifications from the backend. When the asynchronous call completes, a list of sessions which have pending notifications is returned. In one implementation, only one asynchronous RPC call is made per connection pool, and the returned notifications are for sessions of the connection pool only.","The store notification infrastructure is used to collect notifications on Logon objects for all sessions opened in a connection pool. The connection pool maintains a list of all sessions handles for the sessions that have notifications that have not yet been sent to the mid-tier server. When an asynchronous RPC call is received, the list is traversed, session handles are packed into the response buffer, and the RPC call completes. If the notification list is empty, the asynchronous call is parked on the connection pool object. The asynchronous call is completed when new notifications occur. If an asynchronous call has been parked for a certain time, and no new notifications occur, the asynchronous RPC call is completed anyway.","With respect to the mid-tier RPC layer, an asynchronous RPC call from the connection pool is issued when a first session in the pool registers for push notification. A single background thread is used to process the response for all connection pools. A completion port is used to wait for the completion of an asynchronous RPC call. Once an asynchronous RPC call is complete, the response data is processed and connect information is added to the notification poll list. Thereafter, notifications are processed and dispatched the same way as before.","Included herein is a set of flow charts representative of exemplary methodologies for performing novel aspects of the disclosed architecture. While, for purposes of simplicity of explanation, the one or more methodologies shown herein, for example, in the form of a flow chart or flow diagram, are shown and described as a series of acts, it is to be understood and appreciated that the methodologies are not limited by the order of acts, as some acts may, in accordance therewith, occur in a different order and\/or concurrently with other acts from that shown and described herein. For example, those skilled in the art will understand and appreciate that a methodology could alternatively be represented as a series of interrelated states or events, such as in a state diagram. Moreover, not all acts illustrated in a methodology may be required for a novel implementation.",{"@attributes":{"id":"p-0055","num":"0054"},"figref":"FIG. 5","b":["500","502","504"]},{"@attributes":{"id":"p-0056","num":"0055"},"figref":["FIG. 6","FIG. 5"],"b":["600","602","604","606"]},"As used in this application, the terms \u201ccomponent\u201d and \u201csystem\u201d are intended to refer to a computer-related entity, either hardware, a combination of hardware and software, software, or software in execution. For example, a component can be, but is not limited to being, a process running on a processor, a processor, a hard disk drive, multiple storage drives (of optical and\/or magnetic storage medium), an object, an executable, a thread of execution, a program, and\/or a computer. By way of illustration, both an application running on a server and the server can be a component. One or more components can reside within a process and\/or thread of execution, and a component can be localized on one computer and\/or distributed between two or more computers. The word \u201cexemplary\u201d may be used herein to mean serving as an example, instance, or illustration. Any aspect or design described herein as \u201cexemplary\u201d is not necessarily to be construed as preferred or advantageous over other aspects or designs.","Referring now to , there is illustrated a block diagram of a computing system  operable to execute server-to-server notification using a connection pool in accordance with the disclosed architecture. In order to provide additional context for various aspects thereof,  and the following discussion are intended to provide a brief, general description of the suitable computing system  in which the various aspects can be implemented. While the description above is in the general context of computer-executable instructions that can run on one or more computers, those skilled in the art will recognize that a novel embodiment also can be implemented in combination with other program modules and\/or as a combination of hardware and software.","The computing system  for implementing various aspects includes the computer  having processing unit(s) , a system memory , and a system bus . The processing unit(s)  can be any of various commercially available processors such as single-processor, multi-processor, single-core units and multi-core units. Moreover, those skilled in the art will appreciate that the novel methods can be practiced with other computer system configurations, including minicomputers, mainframe computers, as well as personal computers (e.g., desktop, laptop, etc.), hand-held computing devices, microprocessor-based or programmable consumer electronics, and the like, each of which can be operatively coupled to one or more associated devices.","The system memory  can include volatile (VOL) memory  (e.g., random access memory (RAM)) and non-volatile memory (NON-VOL)  (e.g., ROM, EPROM, EEPROM, etc.). A basic input\/output system (BIOS) can be stored in the non-volatile memory , and includes the basic routines that facilitate the communication of data and signals between components within the computer , such as during startup. The volatile memory  can also include a high-speed RAM such as static RAM for caching data.","The system bus  provides an interface for system components including, but not limited to, the memory subsystem  to the processing unit(s) . The system bus  can be any of several types of bus structure that can further interconnect to a memory bus (with or without a memory controller), and a peripheral bus (e.g., PCI, PCIe, AGP, LPC, etc.), using any of a variety of commercially available bus architectures.","The computer  further includes storage subsystem(s)  and storage interface(s)  for interfacing the storage subsystem(s)  to the system bus  and other desired computer components. The storage subsystem(s)  can include one or more of a hard disk drive (HDD), a magnetic floppy disk drive (FDD), and\/or optical disk storage drive (e.g., a CD-ROM drive DVD drive), for example. The storage interface(s)  can include interface technologies such as EIDE, ATA, SATA, and IEEE 1394, for example.","One or more programs and data can be stored in the memory subsystem , a removable memory subsystem  (e.g., flash drive form factor technology), and\/or the storage subsystem(s) , including an operating system , one or more application programs , other program modules , and program data .","Where the computer  is utilized as a server, the one or more application programs , other program modules , and program data  can include the entities and components of system  of , the entities and components of the system  of , the entities and components of the system  of , the functionality represented in the flow diagram  of , and the methods represented in the flowcharts for , for example.","Generally, programs include routines, methods, data structures, other software components, etc., that perform particular tasks or implement particular abstract data types. All or portions of the operating system , applications , modules , and\/or data  can also be cached in memory such as the volatile memory , for example. It is to be appreciated that the disclosed architecture can be implemented with various commercially available operating systems or combinations of operating systems (e.g., as virtual machines).","The storage subsystem(s)  and memory subsystems ( and ) serve as computer readable media for volatile and non-volatile storage of data, data structures, computer-executable instructions, and so forth. Computer readable media can be any available media that can be accessed by the computer  and includes volatile and non-volatile media, removable and non-removable media. For the computer , the media accommodate the storage of data in any suitable digital format. It should be appreciated by those skilled in the art that other types of computer readable media can be employed such as zip drives, magnetic tape, flash memory cards, cartridges, and the like, for storing computer executable instructions for performing the novel methods of the disclosed architecture.","A user can interact with the computer , programs, and data using external user input devices  such as a keyboard and a mouse. Other external user input devices  can include a microphone, an IR (infrared) remote control, a joystick, a game pad, camera recognition systems, a stylus pen, touch screen, gesture systems (e.g., eye movement, head movement, etc.), and\/or the like. The user can interact with the computer , programs, and data using onboard user input devices  such a touchpad, microphone, keyboard, etc., where the computer  is a portable computer, for example. These and other input devices are connected to the processing unit(s)  through input\/output (I\/O) device interface(s)  via the system bus , but can be connected by other interfaces such as a parallel port, IEEE 1394 serial port, a game port, a USB port, an IR interface, etc. The I\/O device interface(s)  also facilitate the use of output peripherals  such as printers, audio devices, camera devices, and so on, such as a sound card and\/or onboard audio processing capability.","One or more graphics interface(s)  (also commonly referred to as a graphics processing unit (GPU)) provide graphics and video signals between the computer  and external display(s)  (e.g., LCD, plasma) and\/or onboard displays  (e.g., for portable computer). The graphics interface(s)  can also be manufactured as part of the computer system board.","The computer  can operate in a networked environment (e.g., IP) using logical connections via a wired\/wireless communications subsystem  to one or more networks and\/or other computers. The other computers can include workstations, servers, routers, personal computers, microprocessor-based entertainment appliance, a peer device or other common network node, and typically include many or all of the elements described relative to the computer . The logical connections can include wired\/wireless connectivity to a local area network (LAN), a wide area network (WAN), hotspot, and so on. LAN and WAN networking environments are commonplace in offices and companies and facilitate enterprise-wide computer networks, such as intranets, all of which may connect to a global communications network such as the Internet.","When used in a networking environment the computer  connects to the network via a wired\/wireless communication subsystem  (e.g., a network interface adapter, onboard transceiver subsystem, etc.) to communicate with wired\/wireless networks, wired\/wireless printers, wired\/wireless input devices , and so on. The computer  can include a modem or has other means for establishing communications over the network. In a networked environment, programs and data relative to the computer  can be stored in the remote memory\/storage device, as is associated with a distributed system. It will be appreciated that the network connections shown are exemplary and other means of establishing a communications link between the computers can be used.","The computer  is operable to communicate with wired\/wireless devices or entities using the radio technologies such as the IEEE 802.xx family of standards, such as wireless devices operatively disposed in wireless communication (e.g., IEEE 802.11 over-the-air modulation techniques) with, for example, a printer, scanner, desktop and\/or portable computer, personal digital assistant (PDA), communications satellite, any piece of equipment or location associated with a wirelessly detectable tag (e.g., a kiosk, news stand, restroom), and telephone. This includes at least Wi-Fi (or Wireless Fidelity) for hotspots, WiMax, and Bluetooth\u2122 wireless technologies. Thus, the communications can be a predefined structure as with a conventional network or simply an ad hoc communication between at least two devices. Wi-Fi networks use radio technologies called IEEE 802.11x (a, b, g, etc.) to provide secure, reliable, fast wireless connectivity. A Wi-Fi network can be used to connect computers to each other, to the Internet, and to wire networks (which use IEEE 802.3-related media and functions).","Referring now to , there is illustrated a schematic block diagram of a computing environment  for server-to-server change notifications using a connection pool. The environment  includes one or more client(s) . The client(s)  can be hardware and\/or software (e.g., threads, processes, computing devices). The client(s)  can house cookie(s) and\/or associated contextual information, for example.","The environment  also includes one or more server(s) . The server(s)  can also be hardware and\/or software (e.g., threads, processes, computing devices). The servers  can house threads to perform transformations by employing the architecture, for example. One possible communication between a client  and a server  can be in the form of a data packet adapted to be transmitted between two or more computer processes. The data packet may include a cookie and\/or associated contextual information, for example. The environment  includes a communication framework  (e.g., a global communication network such as the Internet) that can be employed to facilitate communications between the client(s)  and the server(s) .","Communications can be facilitated via a wire (including optical fiber) and\/or wireless technology. The client(s)  are operatively connected to one or more client data store(s)  that can be employed to store information local to the client(s)  (e.g., cookie(s) and\/or associated contextual information). Similarly, the server(s)  are operatively connected to one or more server data store(s)  that can be employed to store information local to the servers .","What has been described above includes examples of the disclosed architecture. It is, of course, not possible to describe every conceivable combination of components and\/or methodologies, but one of ordinary skill in the art may recognize that many further combinations and permutations are possible. Accordingly, the novel architecture is intended to embrace all such alterations, modifications and variations that fall within the spirit and scope of the appended claims. Furthermore, to the extent that the term \u201cincludes\u201d is used in either the detailed description or the claims, such term is intended to be inclusive in a manner similar to the term \u201ccomprising\u201d as \u201ccomprising\u201d is interpreted when employed as a transitional word in a claim."],"brief-description-of-drawings":[{},{}],"description-of-drawings":{"heading":"BRIEF DESCRIPTION OF THE DRAWINGS","p":[{"@attributes":{"id":"p-0006","num":"0005"},"figref":"FIG. 1"},{"@attributes":{"id":"p-0007","num":"0006"},"figref":"FIG. 2"},{"@attributes":{"id":"p-0008","num":"0007"},"figref":"FIG. 3"},{"@attributes":{"id":"p-0009","num":"0008"},"figref":"FIG. 4"},{"@attributes":{"id":"p-0010","num":"0009"},"figref":"FIG. 5"},{"@attributes":{"id":"p-0011","num":"0010"},"figref":["FIG. 6","FIG. 5"]},{"@attributes":{"id":"p-0012","num":"0011"},"figref":"FIG. 7"},{"@attributes":{"id":"p-0013","num":"0012"},"figref":"FIG. 8"}]},"DETDESC":[{},{}]}
